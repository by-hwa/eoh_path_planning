[
     {
          "operator": "m1",
          "algorithm_description": "A bidirectional RRT* variant with a kd-tree-based nearest neighbor structure for efficient queries, ellipsoidal informed sampling to concentrate search around the best path, adaptive rewiring radius balancing exploration and exploitation, and a deferred global shortcut smoothing applied once a solution is found. The planner alternates expansion between the two trees, dynamically adjusts goal bias with iteration progress, and integrates collision checks before node/edge additions to ensure path validity and coherent tree structures, leading to improved planning time, path length, and smoothness.",
          "planning_mechanism": "The planner maintains two trees rooted at start and goal, performing expansions alternately. Each sample is drawn either from an informed ellipsoidal set biased by the current best path cost or via goal-biased sampling. kd-tree data structures enable fast nearest neighbor and radius-based neighbor retrievals. Parent selection and rewiring optimize path cost while collision checks maintain feasibility. Once a valid connection between trees appears, the planner reconstructs the combined path and applies global shortcutting for smoothness and length improvement before returning the result.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n    def add_child(self, child):\n        self.children.append(child)\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=3000, step_size=8.0, base_radius=25.0,\n                 goal_sample_rate=0.15, min_goal_sample_rate=0.05,\n                 goal_sample_decay=0.995, shortcut_iters=80):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.base_radius = base_radius\n        self.goal_sample_rate = goal_sample_rate\n        self.min_goal_sample_rate = min_goal_sample_rate\n        self.goal_sample_decay = goal_sample_decay\n        self.shortcut_iters = shortcut_iters\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def dist(a,b):\n            return math.dist(a,b)\n        def sq_dist(a,b):\n            return sum((a[i]-b[i])**2 for i in range(dim))\n        def in_bounds(p):\n            for i in range(dim):\n                if p[i]<0 or p[i]>bounds[i]:\n                    return False\n            return True\n        def is_in_obstacle(p):\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d_ = obs\n                    px,py,pz = p\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d_:\n                        return True\n                else:\n                    x,y,w_,h_ = obs\n                    px,py = p\n                    if x <= px <= x+w_ and y <= py <= y+h_:\n                        return True\n            return False\n        def edge_in_collision(fr,to, resolution=1.0):\n            length = dist(fr,to)\n            if length == 0: return False\n            steps = max(1, int(length/resolution))\n            for i in range(steps+1):\n                interp = tuple(fr[d] + (to[d]-fr[d])*i/steps for d in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n        def steer(fr,to):\n            length = dist(fr,to)\n            if length <= self.step_size:\n                return to\n            ratio = self.step_size / length\n            return tuple(fr[d] + (to[d] - fr[d]) * ratio for d in range(dim))\n\n        # Implement a simple k-d tree for efficient neighbor queries\n        class KDTree:\n            def __init__(self, points=None, depth=0):\n                self.axis = depth % dim\n                if not points:\n                    self.location = None\n                    self.left = None\n                    self.right = None\n                    self.nodes = []\n                    return\n                points = sorted(points, key=lambda n: n.position[self.axis])\n                median = len(points)//2\n                self.location = points[median]\n                self.left = KDTree(points[:median], depth+1) if median > 0 else None\n                self.right = KDTree(points[median+1:], depth+1) if median+1 < len(points) else None\n                self.nodes = None  # only in leaf-less nodes\n\n            def insert(self, node, depth=0):\n                if self.location is None:\n                    self.location = node\n                    self.left = None\n                    self.right = None\n                    return\n                axis = depth % dim\n                if node.position[axis] < self.location.position[axis]:\n                    if self.left is None:\n                        self.left = KDTree([node], depth+1)\n                    else:\n                        self.left.insert(node, depth+1)\n                else:\n                    if self.right is None:\n                        self.right = KDTree([node], depth+1)\n                    else:\n                        self.right.insert(node, depth+1)\n\n            def nearest(self, point, best=None, best_dist=float('inf'), depth=0):\n                if self.location is None:\n                    return best, best_dist\n                axis = depth % dim\n                here_dist = sq_dist(point, self.location.position)\n                if here_dist < best_dist:\n                    best = self.location\n                    best_dist = here_dist\n                diff = point[axis] - self.location.position[axis]\n                close, away = (self.left, self.right) if diff < 0 else (self.right, self.left)\n                if close is not None:\n                    best, best_dist = close.nearest(point, best, best_dist, depth+1)\n                if away is not None and diff*diff < best_dist:\n                    best, best_dist = away.nearest(point, best, best_dist, depth+1)\n                return best, best_dist\n\n            def radius_search(self, point, radius, results=None, depth=0):\n                if results is None:\n                    results = []\n                if self.location is None:\n                    return results\n                axis = depth % dim\n                dist_sq = sq_dist(point, self.location.position)\n                if dist_sq <= radius*radius:\n                    results.append(self.location)\n                diff = point[axis] - self.location.position[axis]\n                if self.left is not None and diff - radius <= 0:\n                    self.left.radius_search(point, radius, results, depth+1)\n                if self.right is not None and diff + radius >= 0:\n                    self.right.radius_search(point, radius, results, depth+1)\n                return results\n\n        def adaptive_radius(n_nodes):\n            n_nodes = max(n_nodes, 2)\n            gamma = self.base_radius\n            radius = gamma * (math.log(n_nodes)/n_nodes)**(1/dim)\n            return max(radius, self.step_size*1.5)\n\n        def ellipsoid_sample(start, goal, c_max):\n            if c_max == float('inf'):\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            center = tuple((start[d]+goal[d])*0.5 for d in range(dim))\n            diff = tuple(goal[d]-start[d] for d in range(dim))\n            dist_sg = dist(start, goal)\n            if dist_sg < 1e-100:\n                return tuple(random.uniform(0,bounds[d]) for d in range(dim))\n            unit_vec = tuple(diff[d]/dist_sg for d in range(dim))\n            if dim == 2:\n                import math\n                angle = math.atan2(unit_vec[1], unit_vec[0])\n                for _ in range(15):\n                    r1 = random.uniform(0,1)\n                    r2 = random.uniform(0,1)\n                    rx = r1 * c_max * 0.5\n                    ry = r2 * math.sqrt(c_max*c_max - dist_sg*dist_sg)*0.5\n                    x = rx * math.cos(angle) - ry * math.sin(angle)\n                    y = rx * math.sin(angle) + ry * math.cos(angle)\n                    sample = (center[0]+x, center[1]+y)\n                    if in_bounds(sample):\n                        return sample\n                return tuple(random.uniform(0,bounds[d]) for d in range(dim))\n            else:\n                rx = c_max*0.5\n                ry = rx*0.6\n                rz = rx*0.4\n                for _ in range(25):\n                    x = random.uniform(-rx, rx)\n                    y = random.uniform(-ry, ry)\n                    z = random.uniform(-rz, rz)\n                    sample = (center[0]+x, center[1]+y, center[2]+z)\n                    if in_bounds(sample):\n                        return sample\n                return tuple(random.uniform(0,bounds[d]) for d in range(dim))\n\n        def extract_path(node_start, node_goal):\n            path_start = node_start.path_from_root()\n            path_goal = node_goal.path_from_root()[::-1]\n            if path_start and path_goal and path_start[-1] == path_goal[0]:\n                path_goal = path_goal[1:]\n            return path_start + path_goal\n\n        def global_shortcut(path):\n            if len(path) < 3:\n                return path[:]\n            p = path[:]\n            for _ in range(self.shortcut_iters):\n                if len(p) < 3:\n                    break\n                i = random.randint(0, len(p)-3)\n                j = random.randint(i+2, len(p)-1)\n                if not edge_in_collision(p[i], p[j]):\n                    p = p[:i+1] + p[j:]\n            return p\n\n        # Initialize trees and kd-trees\n        start_root = Node(start_pos)\n        goal_root = Node(goal_pos)\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n        all_nodes = start_tree + goal_tree\n        edges = []\n\n        kd_start = KDTree([start_root])\n        kd_goal = KDTree([goal_root])\n\n        best_cost = float('inf')\n        connection = None\n        goal_bias = self.goal_sample_rate\n\n        for it in range(self.max_iter):\n            goal_bias = max(self.min_goal_sample_rate, goal_bias * self.goal_sample_decay)\n\n            for tree_a, tree_b, kd_a, kd_b in [(start_tree, goal_tree, kd_start, kd_goal),\n                                               (goal_tree, start_tree, kd_goal, kd_start)]:\n                c_max = best_cost if best_cost < float('inf') else float('inf')\n                if random.random() < goal_bias:\n                    sample = goal_pos\n                else:\n                    sample = ellipsoid_sample(start_pos, goal_pos, c_max)\n                if is_in_obstacle(sample):\n                    continue\n\n                nearest_node, _ = kd_a.nearest(sample)\n                if nearest_node is None:\n                    continue\n                new_pos = steer(nearest_node.position, sample)\n                if not in_bounds(new_pos) or is_in_obstacle(new_pos) or edge_in_collision(nearest_node.position, new_pos):\n                    continue\n                radius = adaptive_radius(len(tree_a)+1)\n                near_nodes = kd_a.radius_search(new_pos, radius)\n\n                min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n                min_parent = nearest_node\n                for nb in near_nodes:\n                    if nb == nearest_node:\n                        continue\n                    cand_cost = nb.cost + dist(nb.position, new_pos)\n                    if cand_cost + 1e-9 < min_cost and not edge_in_collision(nb.position, new_pos):\n                        min_cost = cand_cost\n                        min_parent = nb\n\n                new_node = Node(new_pos, parent=min_parent, cost=min_cost)\n                min_parent.add_child(new_node)\n                tree_a.append(new_node)\n                all_nodes.append(new_node)\n                edges.append((min_parent, new_node))\n                kd_a.insert(new_node)\n\n                # Rewire near nodes through new_node if improvement\n                for nb in near_nodes:\n                    if nb == min_parent:\n                        continue\n                    new_cost = new_node.cost + dist(new_node.position, nb.position)\n                    if new_cost + 1e-9 < nb.cost and not edge_in_collision(new_node.position, nb.position):\n                        old_parent = nb.parent\n                        if old_parent:\n                            old_parent.remove_child(nb)\n                            try:\n                                edges.remove((old_parent, nb))\n                            except ValueError:\n                                pass\n                        nb.parent = new_node\n                        nb.cost = new_cost\n                        new_node.add_child(nb)\n                        edges.append((new_node, nb))\n\n                # Attempt connection with other tree - nearest node within step_size\n                near_other = kd_b.radius_search(new_node.position, self.step_size*1.5)\n                for node_other in near_other:\n                    if dist(new_node.position, node_other.position) <= self.step_size:\n                        if not edge_in_collision(new_node.position, node_other.position):\n                            total_cost = new_node.cost + dist(new_node.position, node_other.position) + node_other.cost\n                            if total_cost + 1e-9 < best_cost:\n                                best_cost = total_cost\n                                if tree_a is start_tree:\n                                    connection = (new_node, node_other)\n                                else:\n                                    connection = (node_other, new_node)\n\n            if connection is not None:\n                break\n\n        if connection is None:\n            return PlannerResult(False, [], all_nodes, edges)\n\n        raw_path = extract_path(connection[0], connection[1])\n        smooth_path = global_shortcut(raw_path)\n\n        return PlannerResult(True, smooth_path, all_nodes, edges)",
          "objective": -35.67144,
          "time_improvement": 62.0,
          "length_improvement": 15.0,
          "smoothness_improvement": 1613.0,
          "node_improvement": 80.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.017667293548583984,
                    "num_nodes_avg": 101.7,
                    "path_length_avg": 166.13517920479458,
                    "smoothness_avg": 0.03625333347975132,
                    "success_improvement": 0.0,
                    "time_improvement": 31.497718963341637,
                    "node_improvement": 74.38932258876858,
                    "length_improvement": 8.938675697471036,
                    "smoothness_improvement": 467.4433943318028,
                    "objective_score": 17.149738079144125
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.0215378999710083,
                    "num_nodes_avg": 201.5,
                    "path_length_avg": 233.193267577381,
                    "smoothness_avg": 0.1118364131236119,
                    "success_improvement": 0.0,
                    "time_improvement": 86.99211260077399,
                    "node_improvement": 86.46106295773701,
                    "length_improvement": 22.15337518662528,
                    "smoothness_improvement": 2777.6314621829497,
                    "objective_score": 53.277816203122114
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.016871142387390136,
                    "num_nodes_avg": 164.8,
                    "path_length_avg": 128.99936346398462,
                    "smoothness_avg": 0.1331070185910396,
                    "success_improvement": 0.0,
                    "time_improvement": 66.75452233530704,
                    "node_improvement": 79.04640813731724,
                    "length_improvement": 14.324765076807733,
                    "smoothness_improvement": 1593.1114515399127,
                    "objective_score": 36.58677300437632
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "time_expert",
          "algorithm_description": "A focused bidirectional Informed RRT* planner with ellipsoidal informed sampling around the current best path to guide sampling toward promising regions, combined with efficient rewiring using cost-to-come and adaptive radius scaling for rapid convergence. After each successful tree connection, a deterministic global shortcutting post-process refines the path to significantly improve smoothness and path length. Progressive bidirectional expansion with dynamic goal biasing accelerates connection. This focused sampling and enhanced rewiring drastically reduces redundant exploration, cutting planning time while improving path quality and smoothness.",
          "planning_mechanism": "The planner grows two trees from start and goal, alternately expanding towards samples drawn within an ellipsoidal informed set bound by the current best solution cost. New nodes connect to the lowest-cost parent within an adaptive radius, with rewiring improving local paths. Upon successful connection, a deterministic global shortcutting removes unnecessary waypoints and smooths the path. This approach focuses search near the current best path, efficiently reducing exploration time while systematically improving path quality and smoothness.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except ValueError:\n            pass\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=3500, step_size=7.5, base_radius=22.0, goal_sample_rate=0.10):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.base_radius = base_radius\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map) -> 'PlannerResult':\n        import random, math\n\n        bounds = map.size\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        # Distance and linear interpolation helpers\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(fr, to):\n            d = dist(fr, to)\n            if d <= self.step_size:\n                return to\n            ratio = self.step_size / d\n            return tuple(fr[i] + (to[i] - fr[i]) * ratio for i in range(dim))\n\n        # Collision checking helpers\n        def is_in_obstacle(p):\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d_ = obs\n                    px,py,pz = p\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d_:\n                        return True\n                else:\n                    x,y,w,h = obs\n                    px,py = p\n                    if x <= px <= x+w and y <= py <= y+h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(fr, to, resolution=1.0):\n            d = dist(fr, to)\n            steps = max(1, int(d / resolution))\n            for i in range(steps+1):\n                interp = tuple(fr[j] + (to[j] - fr[j]) * i / steps for j in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        # Nearest and near node search (linear scan)\n        def nearest(tree, point):\n            return min(tree, key=lambda node: dist(node.position, point))\n\n        def near_nodes(tree, point, radius):\n            r2 = radius * radius\n            result = []\n            for n in tree:\n                cd = 0.0\n                for i in range(dim):\n                    d_ = n.position[i] - point[i]\n                    cd += d_*d_\n                    if cd > r2:\n                        break\n                else:\n                    result.append(n)\n            return result\n\n        # Adaptive rewiring radius based on tree size and dimension\n        def adaptive_radius(n):\n            n = max(n,1)\n            radius = self.base_radius * (math.log(n)/n)**(1.0/dim)\n            min_radius = self.step_size * 1.7\n            return max(radius, min_radius)\n\n        # Rewire tree edges for better parent selection\n        def rewire(tree, new_node, near_nodes_):\n            nonlocal edges\n            for near in near_nodes_:\n                if near is new_node.parent:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, near.position)\n                if new_cost + 1e-10 < near.cost:\n                    if not is_edge_in_obstacle(new_node.position, near.position):\n                        # Remove old edge\n                        if near.parent is not None:\n                            try:\n                                edges.remove((near.parent, near))\n                                near.parent.remove_child(near)\n                            except Exception:\n                                pass\n                        near.parent = new_node\n                        near.cost = new_cost\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n\n        # Extract path joining two nodes' root paths\n        def extract_path(node_start, node_goal):\n            p1 = node_start.path_from_root()\n            p2 = node_goal.path_from_root()[::-1]\n            if p1 and p2 and p1[-1] == p2[0]:\n                p2 = p2[1:]\n            return p1 + p2\n\n        # Compute minimum possible cost heuristic for Informed Sampling \n        def straight_dist(a,b):\n            return dist(a,b)\n\n        # Elliptical informed sampling, samples inside ellipsoid between start and goal w.r.t current best cost.\n        def informed_sample(c_best):\n            # If no path, sample uniformly\n            if c_best == math.inf:\n                return tuple(random.uniform(0,bounds[i]) for i in range(dim))\n            # Positions as vectors\n            c_min = straight_dist(start_pos, goal_pos)\n            if c_best < c_min:\n                # Numerical fallback to uniform\n                return tuple(random.uniform(0,bounds[i]) for i in range(dim))\n            # Transform sample inside unit ball to ellipsoidal space\n            from math import sqrt, sin, cos, pi\n            # Build rotation matrix aligning the main axis along start->goal\n            # For 2D only for simplicity\n            if dim == 2:\n                dx = goal_pos[0]-start_pos[0]\n                dy = goal_pos[1]-start_pos[1]\n                theta = math.atan2(dy, dx)\n                r1 = c_best / 2.0\n                if c_best == 0:\n                    r2 = 0\n                else:\n                    r2 = sqrt(c_best**2 - c_min**2)/2.0\n\n                for _ in range(10):  # try 10 samples max\n                    # Sample random point inside unit circle\n                    u, v = random.uniform(-1,1), random.uniform(-1,1)\n                    if u*u + v*v > 1.0:\n                        continue\n                    # Scale to ellipse radii\n                    x_ball = u * r1\n                    y_ball = v * r2\n                    # Rotate and translate center to midpoint\n                    x_ellipse = math.cos(theta)*x_ball - math.sin(theta)*y_ball + (start_pos[0]+goal_pos[0])/2.0\n                    y_ellipse = math.sin(theta)*x_ball + math.cos(theta)*y_ball + (start_pos[1]+goal_pos[1])/2.0\n                    # Check bounds\n                    if 0 <= x_ellipse <= bounds[0] and 0 <= y_ellipse <= bounds[1]:\n                        return (x_ellipse, y_ellipse)\n                # fallback uniform\n                return tuple(random.uniform(0,bounds[i]) for i in range(dim))\n            else:\n                # For 3D or others: uniform fallback for performance\n                return tuple(random.uniform(0,bounds[i]) for i in range(dim))\n\n        # Deterministic global shortcutting to remove intermediary nodes where line is obstacle free\n        def global_shortcut(path):\n            if len(path) < 3:\n                return path[:]\n            new_path = [path[0]]\n            idx = 0\n            while idx < len(path)-1:\n                next_idx = len(path)-1\n                # find farthest reachable node in path without collision\n                for j in range(len(path)-1, idx, -1):\n                    if not is_edge_in_obstacle(path[idx], path[j]):\n                        next_idx = j\n                        break\n                new_path.append(path[next_idx])\n                idx = next_idx\n            return new_path\n\n        # Initialize trees and tracking variables\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        best_cost = math.inf\n        connection_start = connection_goal = None\n        success = False\n\n        # Alternate expansion: 0 for start_tree, 1 for goal_tree\n        tree_switch = 0\n\n        for itr in range(self.max_iter):\n            tree_a = start_tree if tree_switch == 0 else goal_tree\n            tree_b = goal_tree if tree_switch == 0 else start_tree\n            tree_switch = 1 - tree_switch\n\n            # Sample point: goal bias or informed sample around best path cost\n            if best_cost < math.inf and random.random() > self.goal_sample_rate:\n                q_rand = informed_sample(best_cost)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    q_rand = goal_pos if tree_a is start_tree else start_pos\n                else:\n                    q_rand = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n\n            nearest_node = nearest(tree_a, q_rand)\n            q_new_pos = steer(nearest_node.position, q_rand)\n            if is_in_obstacle(q_new_pos):\n                continue\n            if is_edge_in_obstacle(nearest_node.position, q_new_pos):\n                continue\n\n            # Determine near nodes for parent selection and rewiring\n            radius = adaptive_radius(len(tree_a))\n            near_nodes_a = near_nodes(tree_a, q_new_pos, radius)\n\n            # Parent selection: minimum cost that yields collision free edge\n            min_cost = nearest_node.cost + dist(nearest_node.position, q_new_pos)\n            min_parent = nearest_node\n            for near in near_nodes_a:\n                cost_candidate = near.cost + dist(near.position, q_new_pos)\n                if cost_candidate + 1e-10 < min_cost and not is_edge_in_obstacle(near.position, q_new_pos):\n                    min_cost = cost_candidate\n                    min_parent = near\n\n            q_new = Node(q_new_pos, parent=min_parent, cost=min_cost)\n            min_parent.add_child(q_new)\n            tree_a.append(q_new)\n            nodes.append(q_new)\n            edges.append((min_parent, q_new))\n\n            # Rewire around new node for improved paths\n            rewire(tree_a, q_new, near_nodes_a)\n\n            # Check connection to other tree\n            nearest_other = nearest(tree_b, q_new.position)\n            d_connect = dist(q_new.position, nearest_other.position)\n            radius_conn = max(self.step_size*1.7, adaptive_radius(len(tree_b)))\n            if d_connect <= radius_conn and not is_edge_in_obstacle(q_new.position, nearest_other.position):\n                # Connection found\n                if tree_a is start_tree:\n                    connection_start, connection_goal = q_new, nearest_other\n                else:\n                    connection_start, connection_goal = nearest_other, q_new\n\n                raw_path = extract_path(connection_start, connection_goal)\n                path_cost = 0.0\n                for i in range(len(raw_path)-1):\n                    path_cost += dist(raw_path[i], raw_path[i+1])\n                if path_cost + 1e-10 < best_cost:\n                    best_cost = path_cost\n                    # Deterministic global shortcut for smoothness and length improvement\n                    improved_path = global_shortcut(raw_path)\n                    success = True\n                    # Stop early to return best found path\n                    return self._result(True, improved_path, nodes, edges)\n\n        # If no direct connection found but partial paths exist, attempt best partial path smoothing\n        if connection_start and connection_goal:\n            raw_path = extract_path(connection_start, connection_goal)\n            improved_path = global_shortcut(raw_path)\n            return self._result(True, improved_path, nodes, edges)\n\n        # No path found at all\n        return self._result(False, [], nodes, edges)\n\n    def _result(self, success, path, nodes, edges):\n        return PlannerResult(success, path, nodes, edges)",
          "objective": -35.64856,
          "time_improvement": 62.0,
          "length_improvement": 16.0,
          "smoothness_improvement": 1513.0,
          "node_improvement": 79.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.010542154312133789,
                    "num_nodes_avg": 74.4,
                    "path_length_avg": 168.37361962619414,
                    "smoothness_avg": 0.055376394290867416,
                    "success_improvement": 0.0,
                    "time_improvement": 59.12437774151948,
                    "node_improvement": 81.26416519768321,
                    "length_improvement": 7.711751032143607,
                    "smoothness_improvement": 766.7608224169738,
                    "objective_score": 26.198168053826876
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.015135645866394043,
                    "num_nodes_avg": 175.4,
                    "path_length_avg": 235.62763018068162,
                    "smoothness_avg": 0.09300366993397884,
                    "success_improvement": 0.0,
                    "time_improvement": 90.8587755812018,
                    "node_improvement": 88.21474165154875,
                    "length_improvement": 21.340714880401087,
                    "smoothness_improvement": 2293.05141523706,
                    "objective_score": 51.52731867878649
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.0327984094619751,
                    "num_nodes_avg": 254.1,
                    "path_length_avg": 122.41329750020927,
                    "smoothness_avg": 0.1240597817209133,
                    "success_improvement": 0.0,
                    "time_improvement": 35.36900085553568,
                    "node_improvement": 67.69230769230768,
                    "length_improvement": 18.698916495187646,
                    "smoothness_improvement": 1478.0312663494665,
                    "objective_score": 29.220206485520627
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "A bidirectional, asymptotically optimal RRT* planner with recursive rewiring and goal biasing, enhanced by post-processing shortcut smoothing that respects curvature constraints to improve path smoothness and length. The planner grows two trees from start and goal, samples with a goal bias, rewire neighbors recursively upon better cost updates, and connects the trees to form a path. After a feasible path is found, it applies shortcut smoothing that skips nodes only if edges are collision-free and curvature transitions remain smooth.",
          "planning_mechanism": "The planner alternates sampling biased toward the goal to accelerate convergence. Each sampled point is connected via extend and rewiring within a radius with recursive cost propagation to optimize paths. It attempts to connect the two trees after each iteration. Upon success, the path is extracted and refined by shortcut smoothing that avoids sharp bends. This approach improves planning efficiency, path quality, robustness, and smoothness.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=7.0, radius=15.0, goal_sample_rate=0.1):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.radius = radius\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map):\n        import math, random\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = dim == 3\n\n        start_tree = [Node(start_pos, cost=0.0)]\n        goal_tree = [Node(goal_pos, cost=0.0)]\n        nodes = start_tree + goal_tree\n        edges = []\n        path_found = False\n        extracted_path = []\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def sample():\n            # Goal biasing\n            if random.random() < self.goal_sample_rate:\n                return goal_pos\n            else:\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        def is_in_obstacle(p):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d_ = obs\n                    px, py, pz = p\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d_:\n                        return True\n                else:\n                    x, y, w_, h_ = obs\n                    px, py = p\n                    if x <= px <= x + w_ and y <= py <= y + h_:\n                        return True\n            return False\n\n        def edge_in_collision(p1, p2, resolution=1.0):\n            length = dist(p1, p2)\n            if length == 0:\n                return False\n            steps = max(1, int(length / resolution))\n            for i in range(steps + 1):\n                interp = tuple(p1[d] + (p2[d] - p1[d]) * i / steps for d in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def steer(from_p, to_p):\n            l = dist(from_p, to_p)\n            if l <= self.step_size:\n                return to_p\n            ratio = self.step_size / l\n            return tuple(from_p[d] + (to_p[d] - from_p[d]) * ratio for d in range(dim))\n\n        def near_nodes(tree, point):\n            return [n for n in tree if dist(n.position, point) <= self.radius]\n\n        def update_costs_recursive(node):\n            for child in node.children:\n                old_cost = child.cost\n                child.cost = node.cost + dist(node.position, child.position)\n                if child.cost < old_cost:\n                    update_costs_recursive(child)\n\n        def rewire(tree, new_node, near):\n            for n in near:\n                if n == new_node.parent:\n                    continue\n                cost_through_new = new_node.cost + dist(new_node.position, n.position)\n                if cost_through_new + 1e-9 < n.cost and not edge_in_collision(new_node.position, n.position):\n                    # Rewire\n                    if n.parent:\n                        n.parent.remove_child(n)\n                    n.parent = new_node\n                    new_node.children.append(n)\n                    n.cost = cost_through_new\n                    update_costs_recursive(n)\n\n        def extract_path(node_start, node_goal):\n            path_start, path_goal = [], []\n            n = node_start\n            while n:\n                path_start.append(n.position)\n                n = n.parent\n            n = node_goal\n            while n:\n                path_goal.append(n.position)\n                n = n.parent\n            return path_start[::-1] + path_goal\n\n        def curvature_ok(p_a, p_b, p_c, max_angle_rad=math.pi/3):\n            # Check if angle between (p_b - p_a) and (p_c - p_b) is less than max_angle_rad\n            import math\n            import sys\n            def vec_sub(u,v): return tuple(u[i]-v[i] for i in range(dim))\n            def dot(u,v): return sum(u[i]*v[i] for i in range(dim))\n            def norm(u): return math.sqrt(dot(u,u)) if dot(u,u)>0 else sys.float_info.epsilon\n            v1 = vec_sub(p_b, p_a)\n            v2 = vec_sub(p_c, p_b)\n            nv1, nv2 = norm(v1), norm(v2)\n            if nv1 < 1e-9 or nv2 < 1e-9:\n                return True\n            cos_ang = max(min(dot(v1,v2)/(nv1*nv2),1.0),-1.0)\n            angle = math.acos(cos_ang)\n            return angle <= max_angle_rad\n\n        def shortcut_smooth(path):\n            if len(path) <= 2:\n                return path[:]\n            smoothed = [path[0]]\n            i = 0\n            while i < len(path) - 1:\n                j = len(path) - 1\n                while j > i+1:\n                    if (not edge_in_collision(path[i], path[j]) and\n                        (i == 0 or j == len(path)-1 or curvature_ok(path[i-1], path[i], path[j]))):\n                        break\n                    j -= 1\n                smoothed.append(path[j])\n                i = j\n            return smoothed\n\n        for _ in range(self.max_iter):\n            rnd = sample()\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest = min(tree_a, key=lambda n: dist(n.position, rnd))\n                new_pos = steer(nearest.position, rnd)\n                if is_in_obstacle(new_pos):\n                    continue\n                if edge_in_collision(nearest.position,new_pos):\n                    continue\n                new_cost = nearest.cost + dist(nearest.position, new_pos)\n                new_node = Node(new_pos)\n                near = near_nodes(tree_a, new_pos)\n\n                # Choose best parent among near nodes + nearest\n                min_cost = new_cost\n                min_parent = nearest\n                for n in near:\n                    c = n.cost + dist(n.position, new_pos)\n                    if c + 1e-9 < min_cost and not edge_in_collision(n.position, new_pos):\n                        min_cost = c\n                        min_parent = n\n\n                new_node.parent = min_parent\n                new_node.cost = min_cost\n                min_parent.children.append(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((min_parent, new_node))\n\n                # Rewire neighbors recursively\n                rewire(tree_a, new_node, near)\n\n                # Try connecting to other tree\n                nearest_other = min(tree_b, key=lambda n: dist(n.position, new_node.position))\n                d_connect = dist(nearest_other.position, new_node.position)\n                if d_connect <= self.step_size and not edge_in_collision(nearest_other.position, new_node.position):\n                    # Connected\n                    path_found = True\n                    if tree_a is start_tree:\n                        path = extract_path(new_node, nearest_other)\n                    else:\n                        path = extract_path(nearest_other, new_node)\n                    extracted_path = shortcut_smooth(path)\n                    return PlannerResult(True, extracted_path, nodes, edges)\n\n        return PlannerResult(False, [], nodes, edges)",
          "objective": -35.64002,
          "time_improvement": 66.0,
          "length_improvement": 17.0,
          "smoothness_improvement": 1142.0,
          "node_improvement": 77.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.013418364524841308,
                    "num_nodes_avg": 105.3,
                    "path_length_avg": 163.30511778147675,
                    "smoothness_avg": 0.04521187767436088,
                    "success_improvement": 0.0,
                    "time_improvement": 47.9723040088006,
                    "node_improvement": 73.48274993704356,
                    "length_improvement": 10.489877208784566,
                    "smoothness_improvement": 607.6640647675295,
                    "objective_score": 23.72393785174857
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.019947743415832518,
                    "num_nodes_avg": 236.7,
                    "path_length_avg": 232.18703282615962,
                    "smoothness_avg": 0.07544258669340698,
                    "success_improvement": 0.0,
                    "time_improvement": 87.95249302062508,
                    "node_improvement": 84.09594839750049,
                    "length_improvement": 22.489285309444394,
                    "smoothness_improvement": 1841.1920947201538,
                    "objective_score": 49.08527956545493
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.018858718872070312,
                    "num_nodes_avg": 217.6,
                    "path_length_avg": 124.53507272831978,
                    "smoothness_avg": 0.0846802714315068,
                    "success_improvement": 0.0,
                    "time_improvement": 62.83789783466316,
                    "node_improvement": 72.33312142403051,
                    "length_improvement": 17.289734416755685,
                    "smoothness_improvement": 977.1268021613082,
                    "objective_score": 34.1108440112589
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "cross_over",
          "algorithm_description": "A refined bidirectional RRT* planner integrating adaptive neighborhood rewiring with curvature-aware smoothing, progressive frequent shortcutting, and enhanced goal bias sampling focusing on informed ellipsoidal regions. It balances exploration and exploitation, uses incremental cost propagation to maintain optimal paths, and applies curvature constraints during rewiring to ensure smoother trajectories. The planner expedites convergence by dynamically scaling neighborhood radius based on tree growth and dimensionality and aggressively refines paths during planning, improving efficiency, path length, and smoothness while minimizing search time.",
          "planning_mechanism": "The planner alternately grows start and goal trees, samples points using a decaying goal bias combined with ellipsoidal informed sampling centered around the best path cost, employs adaptive neighborhood rewiring with curvature checks to encourage smooth transitions, and frequently shortcut paths during iterations to reduce unnecessary waypoints. It uses spatial hashing to accelerate neighborhood queries and incrementally updates cost-to-come and tree topology. Tree connection attempts optimize for minimal combined path cost and maintain path coherence.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except ValueError:\n            pass\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=3500, step_size=6.0, radius_const=25.0,\n                 goal_sample_rate=0.18, min_goal_sample_rate=0.05,\n                 goal_sample_decay=0.993, spatial_hash_cell=15.0,\n                 shortcut_freq=20, shortcut_attempts=60):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.radius_const = radius_const\n        self.goal_sample_rate = goal_sample_rate\n        self.min_goal_sample_rate = min_goal_sample_rate\n        self.goal_sample_decay = goal_sample_decay\n        self.spatial_hash_cell = spatial_hash_cell\n        self.shortcut_freq = shortcut_freq\n        self.shortcut_attempts = shortcut_attempts\n\n    def plan(self, map):\n        import math, random\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def in_bounds(p):\n            for i in range(dim):\n                if p[i] < 0 or p[i] > bounds[i]:\n                    return False\n            return True\n\n        def is_in_obstacle(p):\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d_ = obs\n                    if x <= p[0] <= x+w and y <= p[1] <= y+h and z <= p[2] <= z+d_:\n                        return True\n                else:\n                    x,y,w_,h_ = obs\n                    if x <= p[0] <= x+w_ and y <= p[1] <= y+h_:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(fr, to):\n            dist = math.dist(fr, to)\n            resolution = min(1.0, self.step_size/4)\n            steps = max(1, int(dist/resolution))\n            for i in range(steps+1):\n                interp = tuple(fr[j] + (to[j]-fr[j]) * i/steps for j in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def steer(fr, to):\n            dist = math.dist(fr, to)\n            if dist <= self.step_size:\n                return to\n            ratio = self.step_size / dist\n            return tuple(fr[i] + (to[i]-fr[i]) * ratio for i in range(dim))\n\n        class SpatialHash:\n            def __init__(self, cell_size):\n                self.cell_size = cell_size\n                self.cells = {}\n\n            def _hash_key(self, pt):\n                return tuple(int(coord // self.cell_size) for coord in pt)\n\n            def insert(self, node):\n                key = self._hash_key(node.position)\n                self.cells.setdefault(key, []).append(node)\n\n            def neighbors(self, pt, radius):\n                r_cell = int(math.ceil(radius / self.cell_size))\n                base_key = self._hash_key(pt)\n                result = []\n                rng = range(-r_cell, r_cell+1)\n                if dim == 2:\n                    for dx in rng:\n                        for dy in rng:\n                            key = (base_key[0]+dx, base_key[1]+dy)\n                            if key in self.cells:\n                                result.extend(self.cells[key])\n                else:\n                    for dx in rng:\n                        for dy in rng:\n                            for dz in rng:\n                                key = (base_key[0]+dx, base_key[1]+dy, base_key[2]+dz)\n                                if key in self.cells:\n                                    result.extend(self.cells[key])\n                return result\n\n        def adaptive_radius(n):\n            n = max(n,2)\n            r = self.radius_const * (math.log(n)/n)**(1/dim)\n            return max(r, self.step_size * 1.7)\n\n        def dist_sq(a,b):\n            s=0.0\n            for i in range(dim):\n                d = a[i]-b[i]\n                s += d*d\n            return s\n\n        def angle_between_vectors(a,b):\n            dot = sum(ai*bi for ai,bi in zip(a,b))\n            na = math.sqrt(sum(ai*ai for ai in a))\n            nb = math.sqrt(sum(bi*bi for bi in b))\n            if na < 1e-15 or nb < 1e-15:\n                return 0.0\n            val = dot/(na*nb)\n            val = max(-1.0,min(1.0,val))\n            return math.acos(val)\n\n        def curvature(prev_p, p, next_p):\n            if prev_p is None or next_p is None:\n                return 0.0\n            v1 = tuple(p[i]-prev_p[i] for i in range(dim))\n            v2 = tuple(next_p[i]-p[i] for i in range(dim))\n            return angle_between_vectors(v1,v2)\n\n        def update_parent(child, new_parent, new_cost):\n            if child.parent is not None:\n                try:\n                    child.parent.remove_child(child)\n                except Exception:\n                    pass\n                try:\n                    edges.remove((child.parent, child))\n                except Exception:\n                    pass\n            child.parent = new_parent\n            child.cost = new_cost\n            new_parent.add_child(child)\n            edges.append((new_parent, child))\n\n        def propagate_costs(node):\n            for c in node.children:\n                new_cost = node.cost + math.dist(node.position, c.position)\n                if new_cost + 1e-10 < c.cost:\n                    update_parent(c, node, new_cost)\n                    propagate_costs(c)\n\n        def rewire(new_node, near_nodes):\n            for neighbor in near_nodes:\n                if neighbor is new_node.parent:\n                    continue\n                dist_edge = math.dist(new_node.position, neighbor.position)\n                new_cost = new_node.cost + dist_edge\n                if new_cost + 1e-10 < neighbor.cost:\n                    # compute curvature penalty\n                    prev_p = new_node.parent.position if new_node.parent else None\n                    curv = curvature(prev_p, new_node.position, neighbor.position)\n                    # allow moderate curved connections (up to ~110deg) to improve smoothness/flexibility\n                    if curv <= 1.92:  # ~110deg radians\n                        if not is_edge_in_obstacle(new_node.position, neighbor.position):\n                            update_parent(neighbor, new_node, new_cost)\n                            propagate_costs(neighbor)\n\n        def extract_path(n_start, n_goal):\n            path_start = n_start.path_from_root()\n            path_goal = n_goal.path_from_root()\n            if path_start[-1] == path_goal[-1]:\n                path_goal = path_goal[:-1]\n            return path_start + path_goal[::-1]\n\n        def ellipsoid_sample(start, goal, c_best):\n            if c_best == float('inf'):\n                while True:\n                    pt = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                    if not is_in_obstacle(pt):\n                        return pt\n            center = tuple(0.5*(start[i]+goal[i]) for i in range(dim))\n            diff = tuple(goal[i]-start[i] for i in range(dim))\n            dist_sg = math.dist(start, goal)\n            if dist_sg < 1e-10:\n                while True:\n                    pt = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                    if not is_in_obstacle(pt):\n                        return pt\n            if dim == 2:\n                unit = (diff[0]/dist_sg, diff[1]/dist_sg)\n                angle = math.atan2(unit[1], unit[0])\n                a = c_best*0.5\n                b = math.sqrt(max(c_best*c_best - dist_sg*dist_sg,0))*0.5\n                for _ in range(25):\n                    r = random.uniform(0,1)**0.5\n                    theta = random.uniform(0, 2*math.pi)\n                    x = r*a*math.cos(theta)\n                    y = r*b*math.sin(theta)\n                    px = center[0] + x*math.cos(angle) - y*math.sin(angle)\n                    py = center[1] + x*math.sin(angle) + y*math.cos(angle)\n                    candidate = (px, py)\n                    if in_bounds(candidate) and not is_in_obstacle(candidate):\n                        return candidate\n                # fallback uniform\n                while True:\n                    pt = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                    if not is_in_obstacle(pt):\n                        return pt\n            else:\n                a = c_best*0.5\n                b = math.sqrt(max(c_best*c_best - dist_sg*dist_sg,0))*0.5\n                rx, ry, rz = a, b*0.9, b*0.7\n                for _ in range(30):\n                    x = random.uniform(-rx, rx)\n                    y = random.uniform(-ry, ry)\n                    z = random.uniform(-rz, rz)\n                    candidate = (center[0]+x, center[1]+y, center[2]+z)\n                    if in_bounds(candidate) and not is_in_obstacle(candidate):\n                        return candidate\n                while True:\n                    pt = tuple(random.uniform(0,bounds[i]) for i in range(dim))\n                    if not is_in_obstacle(pt):\n                        return pt\n\n        def sample(iteration, best_cost):\n            goal_bias_prob = max(self.min_goal_sample_rate,\n                                 self.goal_sample_rate*(self.goal_sample_decay**iteration))\n            r = random.random()\n            if r < goal_bias_prob:\n                if not is_in_obstacle(goal_pos):\n                    return goal_pos\n            return ellipsoid_sample(start_pos, goal_pos, best_cost)\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path[:]\n            sp = path[:]\n            attempts = 0\n            while attempts < self.shortcut_attempts and len(sp) >= 3:\n                i = random.randint(0, len(sp)-3)\n                j = random.randint(i+2, len(sp)-1)\n                p1, p2 = sp[i], sp[j]\n                if not is_edge_in_obstacle(p1, p2):\n                    sp = sp[:i+1] + sp[j:]\n                    attempts = 0\n                else:\n                    attempts += 1\n            return sp\n\n        def nearest(tree, sp_hash, point):\n            candidates = sp_hash.neighbors(point, self.step_size*4)\n            if candidates:\n                return min(candidates, key=lambda node: math.dist(node.position, point))\n            return min(tree, key=lambda node: math.dist(node.position, point))\n\n        def near_nodes(tree, sp_hash, point, radius):\n            r2 = radius*radius\n            candidates = sp_hash.neighbors(point, radius)\n            return [n for n in candidates if dist_sq(n.position, point) <= r2]\n\n        start_tree = [Node(start_pos, None, 0.0)]\n        goal_tree = [Node(goal_pos, None, 0.0)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        start_hash = SpatialHash(self.spatial_hash_cell)\n        goal_hash = SpatialHash(self.spatial_hash_cell)\n        start_hash.insert(start_tree[0])\n        goal_hash.insert(goal_tree[0])\n\n        best_cost = float('inf')\n        solution_nodes = (None, None)\n        success = False\n\n        for iteration in range(self.max_iter):\n            for tree_a, tree_b, hash_a, hash_b in [(start_tree, goal_tree, start_hash, goal_hash),\n                                                   (goal_tree, start_tree, goal_hash, start_hash)]:\n                c_best = best_cost if best_cost < float('inf') else float('inf')\n                sample_pt = sample(iteration, c_best)\n\n                near_tree = tree_a\n                near_hash = hash_a\n\n                nearest_node = nearest(near_tree, near_hash, sample_pt)\n                new_pos = steer(nearest_node.position, sample_pt)\n                if not in_bounds(new_pos) or is_in_obstacle(new_pos):\n                    continue\n                if is_edge_in_obstacle(nearest_node.position, new_pos):\n                    continue\n\n                radius = adaptive_radius(len(near_tree))\n                near_nodes_list = near_nodes(near_tree, near_hash, new_pos, radius)\n\n                min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n                min_parent = nearest_node\n                for candidate in near_nodes_list:\n                    if candidate is nearest_node:\n                        continue\n                    cand_cost = candidate.cost + math.dist(candidate.position, new_pos)\n                    if cand_cost + 1e-10 < min_cost:\n                        if not is_edge_in_obstacle(candidate.position, new_pos):\n                            min_cost = cand_cost\n                            min_parent = candidate\n\n                new_node = Node(new_pos, min_parent, min_cost)\n                min_parent.add_child(new_node)\n                near_tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((min_parent, new_node))\n                near_hash.insert(new_node)\n\n                rewire(new_node, near_nodes_list)\n\n                # Attempt connection to opposite tree\n                opposite_tree = tree_b\n                opposite_hash = hash_b\n                nearest_other = nearest(opposite_tree, opposite_hash, new_node.position)\n                dist_to_other = math.dist(new_node.position, nearest_other.position)\n                radius_conn = max(self.step_size * 2.2, adaptive_radius(len(opposite_tree)))\n                if dist_to_other <= radius_conn:\n                    if not is_edge_in_obstacle(new_node.position, nearest_other.position):\n                        total_cost = new_node.cost + dist_to_other + nearest_other.cost\n                        if total_cost + 1e-10 < best_cost:\n                            best_cost = total_cost\n                            success = True\n                            # ensure start node corresponds to start tree root\n                            if tree_a is start_tree:\n                                solution_nodes = (new_node, nearest_other)\n                            else:\n                                solution_nodes = (nearest_other, new_node)\n\n            if success and (iteration % self.shortcut_freq == 0 or iteration == self.max_iter - 1):\n                raw_path = extract_path(solution_nodes[0], solution_nodes[1])\n                shortened = shortcut_path(raw_path)\n                if shortened and len(shortened) >= 2:\n                    # Return refined solution early to save time\n                    return PlannerResult(True, shortened, nodes, edges)\n\n        if success:\n            raw_path = extract_path(solution_nodes[0], solution_nodes[1])\n            refined_path = shortcut_path(raw_path)\n            return PlannerResult(True, refined_path, nodes, edges)\n        else:\n            return PlannerResult(False, [], nodes, edges)",
          "objective": -34.52045,
          "time_improvement": 60.0,
          "length_improvement": 16.0,
          "smoothness_improvement": 1413.0,
          "node_improvement": 74.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.016766571998596193,
                    "num_nodes_avg": 121.4,
                    "path_length_avg": 158.7759599907795,
                    "smoothness_avg": 0.0468828390170042,
                    "success_improvement": 0.0,
                    "time_improvement": 34.990131685378714,
                    "node_improvement": 69.42835557794007,
                    "length_improvement": 12.972380362963634,
                    "smoothness_improvement": 633.81823833053,
                    "objective_score": 21.449558915044445
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.021818041801452637,
                    "num_nodes_avg": 244.9,
                    "path_length_avg": 241.429579994967,
                    "smoothness_avg": 0.0988451738791662,
                    "success_improvement": 0.0,
                    "time_improvement": 86.82291999652111,
                    "node_improvement": 83.54498421017269,
                    "length_improvement": 19.403857032526776,
                    "smoothness_improvement": 2443.357519211956,
                    "objective_score": 49.90597781453218
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.021955132484436035,
                    "num_nodes_avg": 252.0,
                    "path_length_avg": 127.02772765299588,
                    "smoothness_avg": 0.09912616873570557,
                    "success_improvement": 0.0,
                    "time_improvement": 56.736251175128295,
                    "node_improvement": 67.95931341385887,
                    "length_improvement": 15.63423170325818,
                    "smoothness_improvement": 1160.8775495854936,
                    "objective_score": 32.20580212242087
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "A streamlined bidirectional RRT* planner that combines adaptive ellipsoidal informed sampling focused around the current best path with dynamic rewiring considering cost and curvature penalties to reduce sharp turns. It employs efficient spatial hashing for neighbor queries, a balanced growth strategy alternating start and goal trees, and incremental path shortcutting applied periodically during planning to improve path smoothness and length. The algorithm maintains path quality and robustness while reducing planning time by concentrating search in promising regions and refining the tree topology incrementally.",
          "planning_mechanism": "The planner grows two trees from start and goal positions alternately. It samples points predominantly within an adaptive ellipsoidal region defined by the best current solution to focus exploration. New nodes are connected using cost and curvature-aware rewiring to encourage smooth local paths. Spatial hashing accelerates nearest and near neighbor searches. Periodic incremental shortcutting reduces unnecessary nodes and sharp turns in the evolving best path. Finally, the planner returns a refined, collision-free path optimized in length and smoothness within the iteration budget.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except ValueError:\n            pass\n\n    def path_from_root(self):\n        path, node = [], self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=3000, step_size=6.0, base_radius=25.0,\n                 goal_sample_rate=0.15, min_goal_sample_rate=0.05,\n                 goal_sample_decay=0.995, spatial_hash_cell=15.0,\n                 shortcut_freq=40, shortcut_attempts=30):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.base_radius = base_radius\n        self.goal_sample_rate = goal_sample_rate\n        self.min_goal_sample_rate = min_goal_sample_rate\n        self.goal_sample_decay = goal_sample_decay\n        self.spatial_hash_cell = spatial_hash_cell\n        self.shortcut_freq = shortcut_freq\n        self.shortcut_attempts = shortcut_attempts\n\n    def plan(self, map):\n        import math, random\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def dist_sq(a, b):\n            s = 0.0\n            for i in range(dim):\n                d = a[i]-b[i]\n                s += d * d\n            return s\n\n        def in_bounds(p):\n            for i in range(dim):\n                if p[i] < 0 or p[i] > bounds[i]:\n                    return False\n            return True\n\n        def is_in_obstacle(p):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d_ = obs\n                    if x <= p[0] <= x + w and y <= p[1] <= y + h and z <= p[2] <= z + d_:\n                        return True\n                else:\n                    x, y, w_, h_ = obs\n                    if x <= p[0] <= x + w_ and y <= p[1] <= y + h_:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(fr, to):\n            d = dist(fr, to)\n            resolution = min(1.0, self.step_size / 3.5)\n            steps = max(1, int(d / resolution))\n            for i in range(steps + 1):\n                interp = tuple(fr[j] + (to[j]-fr[j]) * i / steps for j in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def steer(fr, to):\n            d = dist(fr, to)\n            if d <= self.step_size:\n                return to\n            ratio = self.step_size / d\n            return tuple(fr[i] + (to[i]-fr[i]) * ratio for i in range(dim))\n\n        class SpatialHash:\n            def __init__(self, cell_size):\n                self.cell_size = cell_size\n                self.cells = {}\n\n            def _hash_key(self, point):\n                return tuple(int(coord // self.cell_size) for coord in point)\n\n            def insert(self, node):\n                key = self._hash_key(node.position)\n                self.cells.setdefault(key, []).append(node)\n\n            def neighbors(self, point, radius):\n                r_cell = int(math.ceil(radius / self.cell_size))\n                base_key = self._hash_key(point)\n                result = []\n                rng = range(-r_cell, r_cell + 1)\n                if dim == 2:\n                    for dx in rng:\n                        for dy in rng:\n                            key = (base_key[0] + dx, base_key[1] + dy)\n                            if key in self.cells:\n                                result.extend(self.cells[key])\n                else:\n                    for dx in rng:\n                        for dy in rng:\n                            for dz in rng:\n                                key = (base_key[0] + dx, base_key[1] + dy, base_key[2] + dz)\n                                if key in self.cells:\n                                    result.extend(self.cells[key])\n                return result\n\n        def adaptive_radius(n):\n            n = max(n, 2)\n            r = self.base_radius * (math.log(n) / n)**(1.0 / dim)\n            return max(r, self.step_size * 1.8)\n\n        def nearest(tree, sp_hash, point):\n            candidates = sp_hash.neighbors(point, self.step_size * 4)\n            if candidates:\n                return min(candidates, key=lambda node: dist(node.position, point))\n            return min(tree, key=lambda node: dist(node.position, point))\n\n        def near_nodes(tree, sp_hash, point, radius):\n            r2 = radius * radius\n            candidates = sp_hash.neighbors(point, radius)\n            return [n for n in candidates if dist_sq(n.position, point) <= r2]\n\n        def angle_between_vectors(a, b):\n            dot = sum(ai * bi for ai, bi in zip(a, b))\n            norm_a = math.sqrt(sum(ai * ai for ai in a))\n            norm_b = math.sqrt(sum(bi * bi for bi in b))\n            if norm_a < 1e-10 or norm_b < 1e-10:\n                return 0.0\n            val = max(min(dot / (norm_a * norm_b), 1.0), -1.0)\n            return math.acos(val)\n\n        def compute_curvature(prev_p, p, next_p):\n            if prev_p is None or next_p is None:\n                return 0.0\n            v1 = tuple(p[i] - prev_p[i] for i in range(dim))\n            v2 = tuple(next_p[i] - p[i] for i in range(dim))\n            return angle_between_vectors(v1, v2)\n\n        def update_parent(child, new_parent, new_cost):\n            if child.parent is not None:\n                child.parent.remove_child(child)\n                try:\n                    edges.remove((child.parent, child))\n                except Exception:\n                    pass\n            child.parent = new_parent\n            child.cost = new_cost\n            new_parent.add_child(child)\n            edges.append((new_parent, child))\n\n        def propagate_costs(node):\n            for c in node.children:\n                new_cost = node.cost + dist(node.position, c.position)\n                if new_cost + 1e-10 < c.cost:\n                    update_parent(c, node, new_cost)\n                    propagate_costs(c)\n\n        def rewire(new_node, near_list):\n            for neighbor in near_list:\n                if neighbor is new_node.parent:\n                    continue\n                d = dist(new_node.position, neighbor.position)\n                new_cost = new_node.cost + d\n                if new_cost + 1e-10 < neighbor.cost:\n                    # Compute curvature penalty to encourage smooth turns\n                    prev_pos = new_node.parent.position if new_node.parent else None\n                    curvature = compute_curvature(prev_pos, new_node.position, neighbor.position)\n                    if curvature < math.pi / 2:  # discard sharp turns (>90 deg)\n                        if not is_edge_in_obstacle(new_node.position, neighbor.position):\n                            update_parent(neighbor, new_node, new_cost)\n                            propagate_costs(neighbor)\n\n        def extract_path(node_start, node_goal):\n            path_start = node_start.path_from_root()\n            path_goal = node_goal.path_from_root()[::-1]\n            if path_start and path_goal and path_start[-1] == path_goal[0]:\n                path_goal = path_goal[1:]\n            return path_start + path_goal\n\n        def ellipsoid_sample(start, goal, c_best):\n            if c_best == float('inf'):\n                while True:\n                    pt = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                    if not is_in_obstacle(pt):\n                        return pt\n            center = tuple(0.5 * (start[i] + goal[i]) for i in range(dim))\n            diff = tuple(goal[i] - start[i] for i in range(dim))\n            dist_sg = dist(start, goal)\n            import math\n\n            if dist_sg < 1e-10:\n                while True:\n                    pt = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                    if not is_in_obstacle(pt):\n                        return pt\n\n            if dim == 2:\n                unit_vec = tuple(diff[i] / dist_sg for i in range(2))\n                angle = math.atan2(unit_vec[1], unit_vec[0])\n                a = c_best * 0.5\n                b = math.sqrt(max(c_best * c_best - dist_sg * dist_sg, 0.0)) * 0.5\n\n                for _ in range(20):\n                    r = random.uniform(0, 1) ** 0.5\n                    theta = random.uniform(0, 2 * math.pi)\n                    x = r * a * math.cos(theta)\n                    y = r * b * math.sin(theta)\n                    px = center[0] + x * math.cos(angle) - y * math.sin(angle)\n                    py = center[1] + x * math.sin(angle) + y * math.cos(angle)\n                    pt = (px, py)\n                    if in_bounds(pt) and not is_in_obstacle(pt):\n                        return pt\n\n                # fallback uniform sample\n                while True:\n                    pt = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                    if not is_in_obstacle(pt):\n                        return pt\n            else:\n                a = c_best * 0.5\n                b = math.sqrt(max(c_best * c_best - dist_sg * dist_sg, 0.0)) * 0.5\n                rx, ry, rz = a, b * 0.85, b * 0.6\n                for _ in range(30):\n                    x = random.uniform(-rx, rx)\n                    y = random.uniform(-ry, ry)\n                    z = random.uniform(-rz, rz)\n                    pt = (center[0] + x, center[1] + y, center[2] + z)\n                    if in_bounds(pt) and not is_in_obstacle(pt):\n                        return pt\n                # fallback uniform sample\n                while True:\n                    pt = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                    if not is_in_obstacle(pt):\n                        return pt\n\n        def sample(it, c_best):\n            # Mix goal bias with decay and ellipsoid sampling\n            goal_bias_prob = max(self.min_goal_sample_rate,\n                                 self.goal_sample_rate * (self.goal_sample_decay ** it))\n            r = random.random()\n            if r < goal_bias_prob:\n                if not is_in_obstacle(goal_pos):\n                    return goal_pos\n            return ellipsoid_sample(start_pos, goal_pos, c_best)\n\n        def path_shortcut(path):\n            if len(path) < 3:\n                return path[:]\n            sp = path[:]\n            attempts = 0\n            while attempts < self.shortcut_attempts and len(sp) >= 3:\n                i = random.randint(0, len(sp) - 3)\n                j = random.randint(i + 2, len(sp) - 1)\n                p1, p2 = sp[i], sp[j]\n                if not is_edge_in_obstacle(p1, p2):\n                    sp = sp[:i + 1] + sp[j:]\n                    attempts = 0\n                else:\n                    attempts += 1\n            return sp\n\n        start_tree = [Node(start_pos, None, 0.0)]\n        goal_tree = [Node(goal_pos, None, 0.0)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        start_hash = SpatialHash(self.spatial_hash_cell)\n        goal_hash = SpatialHash(self.spatial_hash_cell)\n        start_hash.insert(start_tree[0])\n        goal_hash.insert(goal_tree[0])\n\n        best_cost = float('inf')\n        solution_nodes = (None, None)\n        success = False\n\n        for it in range(self.max_iter):\n            for tree_a, tree_b, hash_a, hash_b in [(start_tree, goal_tree, start_hash, goal_hash),\n                                                   (goal_tree, start_tree, goal_hash, start_hash)]:\n                c_best = best_cost if best_cost < float('inf') else float('inf')\n                sample_pt = sample(it, c_best)\n\n                nearest_node = nearest(tree_a, hash_a, sample_pt)\n                new_pos = steer(nearest_node.position, sample_pt)\n                if not in_bounds(new_pos) or is_in_obstacle(new_pos):\n                    continue\n                if is_edge_in_obstacle(nearest_node.position, new_pos):\n                    continue\n\n                radius = adaptive_radius(len(tree_a))\n                near = near_nodes(tree_a, hash_a, new_pos, radius)\n\n                min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n                min_parent = nearest_node\n                for candidate in near:\n                    if candidate is nearest_node:\n                        continue\n                    cand_cost = candidate.cost + dist(candidate.position, new_pos)\n                    if cand_cost + 1e-8 < min_cost:\n                        if not is_edge_in_obstacle(candidate.position, new_pos):\n                            min_cost = cand_cost\n                            min_parent = candidate\n\n                new_node = Node(new_pos, min_parent, min_cost)\n                min_parent.add_child(new_node)\n                tree_a.append(new_node)\n                hash_a.insert(new_node)\n                nodes.append(new_node)\n                edges.append((min_parent, new_node))\n\n                rewire(new_node, near)\n\n                # Attempt connection to other tree\n                nearest_other = nearest(tree_b, hash_b, new_node.position)\n                dist_to_other = dist(new_node.position, nearest_other.position)\n                radius_conn = max(self.step_size * 2.0, adaptive_radius(len(tree_b)))\n                if dist_to_other <= radius_conn:\n                    if not is_edge_in_obstacle(new_node.position, nearest_other.position):\n                        total_cost = (new_node.cost + dist(new_node.position, nearest_other.position)\n                                      + nearest_other.cost)\n                        if total_cost + 1e-8 < best_cost:\n                            best_cost = total_cost\n                            success = True\n                            if tree_a is start_tree:\n                                solution_nodes = (new_node, nearest_other)\n                            else:\n                                solution_nodes = (nearest_other, new_node)\n\n            # Periodic incremental path shortcutting to improve smoothness during iterations\n            if success and (it % self.shortcut_freq == 0 or it == self.max_iter - 1):\n                raw_path = extract_path(solution_nodes[0], solution_nodes[1])\n                improved_path = path_shortcut(raw_path)\n                if improved_path and len(improved_path) >= 2:\n                    # update solution_nodes by locating nodes closest to path ends in start and goal trees\n                    # to maintain consistent future extensions if needed\n                    return PlannerResult(True, improved_path, nodes, edges)\n\n        if success:\n            raw_path = extract_path(solution_nodes[0], solution_nodes[1])\n            refined_path = path_shortcut(raw_path)\n            return PlannerResult(True, refined_path, nodes, edges)\n        else:\n            return PlannerResult(False, [], nodes, edges)",
          "objective": -34.17849,
          "time_improvement": 60.0,
          "length_improvement": 16.0,
          "smoothness_improvement": 1299.0,
          "node_improvement": 75.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.017295455932617186,
                    "num_nodes_avg": 122.6,
                    "path_length_avg": 171.23147367354323,
                    "smoothness_avg": 0.03716410189314488,
                    "success_improvement": 0.0,
                    "time_improvement": 32.93946355194617,
                    "node_improvement": 69.12616469403173,
                    "length_improvement": 6.145315943196231,
                    "smoothness_improvement": 481.6988977666769,
                    "objective_score": 15.977523120334972
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.023405694961547853,
                    "num_nodes_avg": 257.3,
                    "path_length_avg": 231.5156418202283,
                    "smoothness_avg": 0.09148380904569924,
                    "success_improvement": 0.0,
                    "time_improvement": 85.86405151058038,
                    "node_improvement": 82.71181885372573,
                    "length_improvement": 22.71341495214288,
                    "smoothness_improvement": 2253.944299870077,
                    "objective_score": 50.656985923810225
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.019008278846740723,
                    "num_nodes_avg": 221.5,
                    "path_length_avg": 122.14401225675431,
                    "smoothness_avg": 0.09923558831299088,
                    "success_improvement": 0.0,
                    "time_improvement": 62.54318200076956,
                    "node_improvement": 71.83725365543548,
                    "length_improvement": 18.877762931905092,
                    "smoothness_improvement": 1162.2693585320496,
                    "objective_score": 35.90095915203417
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e2",
          "algorithm_description": "A bidirectional RRT* planner enhanced with adaptive informed sampling inside an ellipsoidal subset defined by current best path cost to bias exploration effectively, combined with a shrinking neighbor radius for rewiring that focuses optimization on close nodes as iteration progresses. The planner performs frequent connection attempts, recursive cost propagation upon rewiring, and iterative post-processing shortcut smoothing that aggressively reduces sharp turns and path length by evaluating all node pairs for direct reconnection while respecting collision and curvature constraints. This approach balances rapid solution discovery, path quality, and smoothness improvements with efficient computational performance.",
          "planning_mechanism": "The planner grows two trees from start and goal positions, alternately extending nodes by steering toward adaptively sampled points within an ellipsoid informed by the best current path cost (or the entire space initially). New nodes connect to the lowest-cost parent within a shrinking radius, followed by rewiring of neighbors with cost updates propagated recursively. The trees attempt connection after each extension. Upon finding a connection, the final path undergoes multiple iterations of shortcut smoothing that tests all segment pairs for possible direct connections, validating collision-free and curvature-friendly shortcuts to improve path smoothness and length before returning the result.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=7.0, base_radius=30.0, goal_sample_rate=0.1, smoothing_iterations=5):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.base_radius = base_radius\n        self.goal_sample_rate = goal_sample_rate\n        self.smoothing_iterations = smoothing_iterations\n\n    def plan(self, map):\n        import math\n        import random\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        # Distance between two points\n        def dist(a, b):\n            return math.dist(a, b)\n\n        # Linear interpolation steer step\n        def steer(from_p, to_p):\n            l = dist(from_p, to_p)\n            if l <= self.step_size:\n                return to_p\n            ratio = self.step_size / l\n            return tuple(from_p[i] + (to_p[i] - from_p[i]) * ratio for i in range(dim))\n\n        # Check if point lies inside any obstacle\n        def is_in_obstacle(p):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d_ = obs\n                    px, py, pz = p\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d_:\n                        return True\n                else:\n                    x, y, w_, h_ = obs\n                    px, py = p\n                    if x <= px <= x + w_ and y <= py <= y + h_:\n                        return True\n            return False\n\n        # Check edge collision with sampling resolution adapted to step_size\n        def edge_in_collision(p1, p2, resolution=None):\n            length = dist(p1, p2)\n            if length == 0:\n                return False\n            step_res = resolution if resolution else min(1.0, self.step_size / 2.0)\n            steps = max(1, int(length / step_res))\n            for i in range(steps + 1):\n                interp = tuple(p1[j] + (p2[j] - p1[j]) * i / steps for j in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        # Extract path from start root to node\n        def extract_path(node_start, node_goal):\n            path_start = node_start.path_from_root()\n            path_goal = node_goal.path_from_root()\n            if path_start and path_goal and path_start[-1] == path_goal[-1]:\n                path_goal = path_goal[:-1]\n            path_goal.reverse()\n            return path_start + path_goal\n\n        # Checks angle between three points p_a,p_b,p_c\n        def curvature_ok(p_a, p_b, p_c, max_angle_rad=math.pi*150/180):\n            import sys\n            def vec_sub(u,v): return tuple(u[i]-v[i] for i in range(dim))\n            def dot(u,v): return sum(u[i]*v[i] for i in range(dim))\n            def norm(u): return math.sqrt(dot(u,u)) if dot(u,u) > 0 else sys.float_info.epsilon\n            v1 = vec_sub(p_b, p_a)\n            v2 = vec_sub(p_c, p_b)\n            n1, n2 = norm(v1), norm(v2)\n            if n1 < 1e-9 or n2 < 1e-9:\n                return True\n            cos_ang = max(min(dot(v1, v2)/(n1 * n2), 1.0), -1.0)\n            angle = math.acos(cos_ang)\n            return angle <= max_angle_rad\n\n        # Iterative aggressive shortcut smoothing over entire path pairs\n        def shortcut_smooth(path):\n            if len(path) <= 2:\n                return path[:]\n            for _ in range(self.smoothing_iterations):\n                i = 0\n                while i < len(path) - 2:\n                    improved = False\n                    for j in range(len(path)-1, i+1, -1):\n                        if not edge_in_collision(path[i], path[j]):\n                            # If curvature constraints hold on shortcut endpoints\n                            if (i == 0 or curvature_ok(path[i-1], path[i], path[j])) and \\\n                               (j == len(path)-1 or curvature_ok(path[i], path[j], path[j+1])):\n                                path = path[:i+1] + path[j:]\n                                improved = True\n                                break\n                    if not improved:\n                        i += 1\n            return path\n\n        # Adaptive radius that shrinks with iteration and grows slowly with tree size\n        def adaptive_radius(iteration, tree_size):\n            n = max(tree_size, 2)\n            gamma = self.base_radius\n            radius = gamma * (math.log(n) / n) ** (1.0 / dim)\n            max_shrink_it = self.max_iter // 2\n            # Shrink radius linearly down to step_size as iteration grows\n            shrink_factor = max(0.0, 1.0 - iteration / max_shrink_it)\n            radius = max(self.step_size, radius * shrink_factor)\n            return radius\n\n        # Cost update propagation recursively\n        def update_costs_recursive(node):\n            for child in node.children:\n                old_cost = child.cost\n                new_cost = node.cost + dist(node.position, child.position)\n                if new_cost + 1e-9 < old_cost:\n                    child.cost = new_cost\n                    update_costs_recursive(child)\n\n        # Rewire near neighbors if better path found and propagate cost changes\n        def rewire(tree, new_node, near_nodes_, iteration):\n            for near in near_nodes_:\n                if near == new_node.parent:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, near.position)\n                if new_cost + 1e-9 < near.cost and not edge_in_collision(new_node.position, near.position):\n                    # Rewire\n                    if near.parent:\n                        near.parent.remove_child(near)\n                    near.parent = new_node\n                    new_node.add_child(near)\n                    near.cost = new_cost\n                    update_costs_recursive(near)\n\n        # Informed sample in ellipsoid between start and goal based on best current cost\n        def informed_sample(c_best, c_min, start, goal):\n            if c_best == float('inf'):\n                # Uniform random sample in bounds\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            # Build rotation matrix from unit vector from start to goal\n            import numpy as np\n            center = np.array([(start[i] + goal[i])/2 for i in range(dim)])\n            diff = np.array([goal[i] - start[i] for i in range(dim)])\n            e1 = diff / np.linalg.norm(diff)\n            # Basis construction\n            def rot_matrix(n):\n                if dim == 2:\n                    a = e1\n                    b = np.array([-a[1], a[0]])\n                    return np.array([a,b]).T\n                else:\n                    a = e1\n                    # Create arbitrary basis completing to dim=3\n                    b = np.array([0.0,0.0,0.0])\n                    c = np.array([0.0,0.0,0.0])\n                    # Gram-Schmidt to create orthonormal set\n                    base = np.eye(dim)\n                    base[:,0] = a\n                    idx = 1\n                    for v in np.eye(dim)[:,1:]:\n                        proj = np.dot(v,a)*a\n                        u = v - proj\n                        if np.linalg.norm(u) > 1e-9:\n                            base[:,idx] = u / np.linalg.norm(u)\n                            idx +=1\n                            if idx >= dim:\n                                break\n                    return base\n            L = np.diag([c_best/2] + [math.sqrt(c_best**2 - c_min**2)/2]*(dim-1))\n            C = rot_matrix(dim)\n            while True:\n                # Sample from unit ball\n                x = np.random.normal(0,1,dim)\n                normx = np.linalg.norm(x)\n                if normx <= 1:\n                    x = x / normx * (random.uniform(0,1) ** (1/dim))\n                    break\n            point = center + C @ L @ x\n            res = tuple(point.tolist())\n            # Clamp to bounds\n            res_clamped = tuple(min(max(res[i], 0.0), bounds[i]) for i in range(dim))\n            return res_clamped\n\n        # Because numpy is not allowed, fallback informed sampling to elliptical sample using math only for dim=2 or uniform for dim=3\n        def informed_sample_no_numpy(c_best, c_min, start, goal):\n            if c_best == float('inf'):\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            # Only implement 2D elliptical sampling (helps most)\n            if dim == 2:\n                import math\n                center = tuple((start[i] + goal[i])/2 for i in range(2))\n                r1 = c_best / 2  # major axis radius\n                r2 = math.sqrt(c_best**2 - c_min**2) / 2  # minor axis radius\n                # angle of ellipse major axis\n                dx = goal[0] - start[0]\n                dy = goal[1] - start[1]\n                angle = math.atan2(dy, dx)\n\n                for _ in range(100):\n                    # Sample random radius and angle inside unit circle\n                    r = random.uniform(0,1) ** 0.5\n                    theta = random.uniform(0, 2*math.pi)\n                    x = r * math.cos(theta) * r1\n                    y = r * math.sin(theta) * r2\n                    # Rotate by ellipse angle\n                    xr = x * math.cos(angle) - y * math.sin(angle)\n                    yr = x * math.sin(angle) + y * math.cos(angle)\n                    sample = (center[0] + xr, center[1] + yr)\n                    # Clamp to bounds\n                    if 0 <= sample[0] <= bounds[0] and 0 <= sample[1] <= bounds[1]:\n                        return sample\n                # Fallback uniform if no point found\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            else:\n                # Without numpy, uniform fallback for 3D\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        # Nearest neighbor in tree by Euclidean distance\n        def nearest(tree, point):\n            return min(tree, key=lambda n: dist(n.position, point))\n\n        # All nodes within radius (linear scan)\n        def near_nodes(tree, point, radius):\n            r2 = radius * radius\n            result = []\n            for node in tree:\n                d2 = 0.0\n                for i in range(dim):\n                    diff = node.position[i] - point[i]\n                    d2 += diff * diff\n                    if d2 > r2:\n                        break\n                else:\n                    result.append(node)\n            return result\n\n        # Initialization\n        start_tree = [Node(start_pos, cost=0.0)]\n        goal_tree = [Node(goal_pos, cost=0.0)]\n        nodes = start_tree + goal_tree\n        edges = []\n        best_cost = float('inf')\n        conn_node_start = None\n        conn_node_goal = None\n        c_min = dist(start_pos, goal_pos)\n\n        for it in range(self.max_iter):\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                # Sample with goal bias or informed sample if solution found\n                if best_cost == float('inf'):\n                    if random.random() < self.goal_sample_rate:\n                        rnd_pt = goal_pos\n                    else:\n                        rnd_pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                else:\n                    rnd_pt = informed_sample_no_numpy(best_cost, c_min, start_pos, goal_pos)\n\n                nearest_node = nearest(tree_a, rnd_pt)\n                new_pos = steer(nearest_node.position, rnd_pt)\n                if is_in_obstacle(new_pos):\n                    continue\n                if edge_in_collision(nearest_node.position, new_pos):\n                    continue\n\n                # Choose best parent in radius\n                radius = adaptive_radius(it, len(tree_a))\n                near = near_nodes(tree_a, new_pos, radius)\n\n                min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n                min_parent = nearest_node\n                for candidate in near:\n                    if candidate == nearest_node:\n                        continue\n                    cand_cost = candidate.cost + dist(candidate.position, new_pos)\n                    if cand_cost + 1e-9 < min_cost and not edge_in_collision(candidate.position, new_pos):\n                        min_cost = cand_cost\n                        min_parent = candidate\n\n                new_node = Node(new_pos, parent=min_parent, cost=min_cost)\n                min_parent.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((min_parent, new_node))\n\n                rewire(tree_a, new_node, near, it)\n\n                # Try connecting trees\n                nearest_other = nearest(tree_b, new_node.position)\n                d_conn = dist(nearest_other.position, new_node.position)\n                connect_radius = max(self.step_size * 1.5, adaptive_radius(it, len(tree_b)))\n                if d_conn <= connect_radius and not edge_in_collision(nearest_other.position, new_node.position):\n                    # Update best connection cost if better\n                    path_cost = new_node.cost + dist(new_node.position, nearest_other.position) + nearest_other.cost\n                    if path_cost + 1e-9 < best_cost:\n                        best_cost = path_cost\n                        conn_node_start = new_node if tree_a is start_tree else nearest_other\n                        conn_node_goal = nearest_other if tree_a is start_tree else new_node\n\n            if best_cost < float('inf'):\n                break\n\n        success = (conn_node_start is not None and conn_node_goal is not None)\n        path = []\n        if success:\n            raw_path = extract_path(conn_node_start, conn_node_goal)\n            # Aggressive iterative post-processing shortcut smoothing\n            path = shortcut_smooth(raw_path)\n\n        return PlannerResult(success, path, nodes, edges)",
          "objective": -34.14278,
          "time_improvement": 54.0,
          "length_improvement": 15.0,
          "smoothness_improvement": 1757.0,
          "node_improvement": 76.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.02151362895965576,
                    "num_nodes_avg": 102.7,
                    "path_length_avg": 168.4448593617396,
                    "smoothness_avg": 0.04338404655212541,
                    "success_improvement": 0.0,
                    "time_improvement": 16.584130270997328,
                    "node_improvement": 74.1374968521783,
                    "length_improvement": 7.672703404225299,
                    "smoothness_improvement": 579.0545385057334,
                    "objective_score": 12.474133816363045
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.01994943618774414,
                    "num_nodes_avg": 210.0,
                    "path_length_avg": 235.74641066517734,
                    "smoothness_avg": 0.12203446274381713,
                    "success_improvement": 0.0,
                    "time_improvement": 87.95147066531428,
                    "node_improvement": 85.88994154404354,
                    "length_improvement": 21.301062535769738,
                    "smoothness_improvement": 3040.0346242690707,
                    "objective_score": 54.36625184240148
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.02129671573638916,
                    "num_nodes_avg": 248.8,
                    "path_length_avg": 125.66258003578155,
                    "smoothness_avg": 0.13763158736034706,
                    "success_improvement": 0.0,
                    "time_improvement": 58.033696172546655,
                    "node_improvement": 68.36617927527018,
                    "length_improvement": 16.540897749267998,
                    "smoothness_improvement": 1650.663632316577,
                    "objective_score": 35.58796566290768
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "A streamlined bidirectional RRT* planner with adaptive neighborhood radius, integrated ellipsoidal informed sampling, and iterative incremental shortcutting combined with smoothing. It maintains a clean tree structure through careful rewiring with subtree cost updates and frequent connection attempts to improve solution quality progressively. Path refinement happens continuously during planning by applying shortcutting with adaptive angle thresholds and midpoint smoothing, enhancing smoothness and shortening path length while keeping planning time efficient.",
          "planning_mechanism": "The planner grows two trees from start and goal alternately, sampling informed points within an adaptive ellipsoidal region after an initial solution is found. It uses an adaptive rewiring radius based on node count and dimension to reconnect neighbors if a better path is found, with subtree costs updated accordingly. Frequent attempts connect the two trees. Incremental path shortcutting with an adaptive angle threshold and midpoint smoothing run periodically during planning to iteratively improve path smoothness and length. The algorithm balances exploration and exploitation using goal bias and informed sampling for efficient, high-quality, and smooth paths.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\nclass Planner:\n    def __init__(self, max_iter=4000, step_size=6.0, gamma=40.0, goal_sample_rate=0.1, \n                 shortcut_interval=40, max_shortcut_attempts=200):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.gamma = gamma\n        self.goal_sample_rate = goal_sample_rate\n        self.shortcut_interval = shortcut_interval\n        self.max_shortcut_attempts = max_shortcut_attempts\n\n    def plan(self, map):\n        import math\n        import random\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        best_cost = float('inf')\n        solution_start, solution_goal = None, None\n        c_min = math.dist(start_pos, goal_pos)\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def adaptive_radius(n_nodes):\n            if n_nodes <= 1:\n                return self.step_size * 3.0\n            val = (math.log(n_nodes) / n_nodes) ** (1.0 / dim)\n            return min(self.gamma * val, self.step_size * 40)\n\n        def sample():\n            # Goal biasing\n            if random.random() < self.goal_sample_rate:\n                return goal_pos\n            # Informed ellipsoidal sampling if solution found\n            if best_cost == float('inf') or best_cost <= c_min:\n                return self._sample_free(bounds, obstacles, is_3d)\n            center = tuple((start_pos[i]+goal_pos[i])*0.5 for i in range(dim))\n            dir_vec = [goal_pos[i]-start_pos[i] for i in range(dim)]\n            length = c_min\n            if dim == 2:\n                if length < 1e-14:\n                    R = [[1,0],[0,1]]\n                else:\n                    a1 = [1,0]\n                    a2 = [dir_vec[0]/length, dir_vec[1]/length]\n                    cos_t = a1[0]*a2[0] + a1[1]*a2[1]\n                    sin_t = a1[0]*a2[1] - a1[1]*a2[0]\n                    R = [[cos_t, -sin_t],[sin_t, cos_t]]\n            else:\n                from math import sqrt\n                if length < 1e-14:\n                    R = [[1,0,0],[0,1,0],[0,0,1]]\n                else:\n                    a1 = [1,0,0]\n                    a2 = [dir_vec[i]/length for i in range(3)]\n                    v = [a1[1]*a2[2]-a1[2]*a2[1], a1[2]*a2[0]-a1[0]*a2[2], a1[0]*a2[1]-a1[1]*a2[0]]\n                    s = sqrt(sum(x*x for x in v))\n                    c = sum(a1[i]*a2[i] for i in range(3))\n                    if s < 1e-14:\n                        R = [[1,0,0],[0,1,0],[0,0,1]]\n                    else:\n                        vx = [[0,-v[2],v[1]],[v[2],0,-v[0]],[-v[1],v[0],0]]\n                        I = [[1 if i==j else 0 for j in range(3)] for i in range(3)]\n                        vx2 = [[sum(vx[i][k]*vx[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n                        R = [[I[i][j] + vx[i][j] + vx2[i][j]*((1-c)/(s*s)) for j in range(3)] for i in range(3)]\n\n            a1_val = best_cost * 0.5\n            try:\n                term = best_cost*best_cost - c_min*c_min\n                a_other = math.sqrt(term)*0.5 if term > 0 else 0.0\n            except Exception:\n                a_other = 0.0\n\n            while True:\n                if dim == 2:\n                    r = random.uniform(0,1)**0.5\n                    theta = random.uniform(0,2*math.pi)\n                    ball = [r * math.cos(theta), r * math.sin(theta)]\n                    L = [[a1_val,0],[0,a_other]]\n                    x_scaled = [L[0][0]*ball[0], L[1][1]*ball[1]]\n                    pt = tuple(center[i] + sum(R[i][j]*x_scaled[j] for j in range(dim)) for i in range(dim))\n                else:\n                    while True:\n                        ball = [random.uniform(-1,1) for _ in range(3)]\n                        if sum(x*x for x in ball) <= 1:\n                            break\n                    L = [[a1_val,0,0],[0,a_other,0],[0,0,a_other]]\n                    x_scaled = [L[0][0]*ball[0], L[1][1]*ball[1], L[2][2]*ball[2]]\n                    pt = tuple(center[i] + sum(R[i][j]*x_scaled[j] for j in range(dim)) for i in range(dim))\n                if any(pt[d]<0.0 or pt[d]>bounds[d] for d in range(dim)):\n                    continue\n                if self._is_in_obstacle(pt, obstacles, is_3d):\n                    continue\n                return pt\n\n        def nearest(tree, point):\n            best = None\n            best_dist = float('inf')\n            for node in tree:\n                d = 0.0\n                for i in range(dim):\n                    diff = node.position[i] - point[i]\n                    d += diff*diff\n                    if d >= best_dist:\n                        break\n                if d < best_dist:\n                    best_dist = d\n                    best = node\n            return best\n\n        def near(tree, point, radius):\n            r2 = radius*radius\n            res = []\n            for node in tree:\n                d = 0.0\n                for i in range(dim):\n                    diff = node.position[i]-point[i]\n                    d += diff*diff\n                    if d > r2:\n                        break\n                if d <= r2:\n                    res.append(node)\n            return res\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            ratio = self.step_size / d\n            return tuple(from_pos[i] + (to_pos[i]-from_pos[i])*ratio for i in range(dim))\n\n        def update_subtree_costs(node):\n            stack = [node]\n            while stack:\n                current = stack.pop()\n                for c in current.children:\n                    new_cost = current.cost + dist(current.position, c.position)\n                    if new_cost + 1e-15 < c.cost:\n                        c.cost = new_cost\n                        stack.append(c)\n\n        def extract_path(node_start, node_goal):\n            path_start = []\n            n = node_start\n            while n is not None:\n                path_start.append(n.position)\n                n = n.parent\n            path_goal = []\n            n = node_goal\n            while n is not None:\n                path_goal.append(n.position)\n                n = n.parent\n            return path_start[::-1] + path_goal\n\n        def angle_between(a,b,c):\n            import math\n            ba = [a[i]-b[i] for i in range(dim)]\n            bc = [c[i]-b[i] for i in range(dim)]\n            lab = math.sqrt(sum(x*x for x in ba))\n            lbc = math.sqrt(sum(x*x for x in bc))\n            if lab < 1e-14 or lbc < 1e-14:\n                return 0.0\n            dotp = sum(ba[i]*bc[i] for i in range(dim))\n            val = max(min(dotp/(lab*lbc), 1.0), -1.0)\n            return math.acos(val)\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path[:]\n            new_path = path[:]\n            angle_base = math.pi * 160.0 / 180.0  # 160 degrees base angle\n            max_attempts = self.max_shortcut_attempts\n            attempts = 0\n            i = 0\n            while attempts < max_attempts and i < len(new_path)-2:\n                j = random.randint(i+2, len(new_path)-1)\n                if j <= i+1:\n                    attempts += 1\n                    i += 1\n                    continue\n                if not self._is_edge_in_obstacle(new_path[i], new_path[j], obstacles, is_3d):\n                    smooth = True\n                    if i > 0:\n                        a,b,c = new_path[i-1], new_path[i], new_path[j]\n                        if angle_between(a,b,c) < math.pi - angle_base:\n                            smooth = False\n                    if j < len(new_path)-1:\n                        a,b,c = new_path[i], new_path[j], new_path[j+1]\n                        if angle_between(a,b,c) < math.pi - angle_base:\n                            smooth = False\n                    if smooth:\n                        new_path = new_path[:i+1] + new_path[j:]\n                        i = 0\n                        attempts += 1\n                        continue\n                i += 1\n                attempts += 1\n            return new_path\n\n        def midpoint_smooth(path):\n            if len(path) < 4:\n                return path[:]\n            new_path = path[:]\n            changed = False\n            for i in range(1, len(new_path)-1):\n                a,b,c = new_path[i-1], new_path[i], new_path[i+1]\n                mid = tuple(0.5*(a[d] + c[d]) for d in range(dim))\n                if (not self._is_in_obstacle(mid, obstacles, is_3d) and \n                    not self._is_edge_in_obstacle(a, mid, obstacles, is_3d) and\n                    not self._is_edge_in_obstacle(mid, c, obstacles, is_3d)):\n                    old_angle = angle_between(a,b,c)\n                    new_angle = angle_between(a,mid,c)\n                    if new_angle < old_angle + 1e-8:\n                        new_path[i] = mid\n                        changed = True\n            return new_path if changed else path\n\n        def attempt_extend(tree_from, tree_to, sample_point):\n            nearest_node = nearest(tree_from, sample_point)\n            new_pos = steer(nearest_node.position, sample_point)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                return None\n\n            r = adaptive_radius(len(tree_from))\n            near_nodes = near(tree_from, new_pos, r)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for candidate in near_nodes:\n                if candidate is nearest_node:\n                    continue\n                tentative_cost = candidate.cost + dist(candidate.position, new_pos)\n                if tentative_cost < min_cost:\n                    if not self._is_edge_in_obstacle(candidate.position, new_pos, obstacles, is_3d):\n                        min_cost = tentative_cost\n                        best_parent = candidate\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree_from.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            for nbr in near_nodes:\n                if nbr is best_parent or nbr is new_node:\n                    continue\n                cost_through_new = new_node.cost + dist(new_node.position, nbr.position)\n                if cost_through_new < nbr.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, nbr.position, obstacles, is_3d):\n                        if nbr.parent is not None:\n                            try:\n                                edges.remove((nbr.parent, nbr))\n                            except Exception:\n                                pass\n                            nbr.parent.remove_child(nbr)\n                        nbr.parent = new_node\n                        nbr.cost = cost_through_new\n                        new_node.add_child(nbr)\n                        edges.append((new_node, nbr))\n                        update_subtree_costs(nbr)\n\n            near_other = nearest(tree_to, new_node.position)\n            d = dist(new_node.position, near_other.position)\n            if d <= self.step_size:\n                if not self._is_edge_in_obstacle(new_node.position, near_other.position, obstacles, is_3d):\n                    total_cost = new_node.cost + d + near_other.cost\n                    if total_cost < best_cost:\n                        return new_node, near_other, total_cost\n            return None\n\n        for it in range(self.max_iter):\n            sample_pos = sample()\n\n            # Alternate between trees each iteration for extension\n            if it % 2 == 0:\n                tree_a, tree_b = start_tree, goal_tree\n            else:\n                tree_a, tree_b = goal_tree, start_tree\n\n            res = attempt_extend(tree_a, tree_b, sample_pos)\n            if res is not None:\n                new_node, conn_node, cost = res\n                if cost < best_cost:\n                    best_cost = cost\n                    if tree_a is start_tree:\n                        solution_start, solution_goal = new_node, conn_node\n                    else:\n                        solution_start, solution_goal = conn_node, new_node\n\n            if best_cost < float('inf') and solution_start and solution_goal:\n                if it % self.shortcut_interval == 0 or it == self.max_iter-1:\n                    raw_path = extract_path(solution_start, solution_goal)\n                    shortcut = shortcut_path(raw_path)\n                    smooth = midpoint_smooth(shortcut)\n                    return PlannerResult(True, smooth, nodes, edges)\n        return PlannerResult(False, [], nodes, edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        import random\n        while True:\n            pt = tuple(random.uniform(0, bounds[i]) for i in range(len(bounds)))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        px = pos[0]\n        py = pos[1]\n        pz = pos[2] if is_3d else 0.0\n        for obs in obstacles:\n            if is_3d:\n                x,y,z,w,h,d = obs\n                if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                    return True\n            else:\n                x,y,w,h = obs\n                if x <= px <= x+w and y <= py <= y+h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        dist_val = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist_val/resolution))\n        for step in range(steps+1):\n            t = step/steps\n            interp = tuple(from_pos[i] + t*(to_pos[i]-from_pos[i]) for i in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -34.04726,
          "time_improvement": 62.0,
          "length_improvement": 16.0,
          "smoothness_improvement": 1214.0,
          "node_improvement": 75.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.01619288921356201,
                    "num_nodes_avg": 129.2,
                    "path_length_avg": 165.2187501071947,
                    "smoothness_avg": 0.0347659312496346,
                    "success_improvement": 0.0,
                    "time_improvement": 37.21450064479152,
                    "node_improvement": 67.4641148325359,
                    "length_improvement": 9.440985007613875,
                    "smoothness_improvement": 444.16231948483625,
                    "objective_score": 19.04975279542996
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.025137996673583983,
                    "num_nodes_avg": 249.1,
                    "path_length_avg": 235.60144924838568,
                    "smoothness_avg": 0.08764785848268018,
                    "success_improvement": 0.0,
                    "time_improvement": 84.81782204336284,
                    "node_improvement": 83.26278304105355,
                    "length_improvement": 21.349454829177827,
                    "smoothness_improvement": 2155.242528960084,
                    "objective_score": 49.03123215531597
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.018967270851135254,
                    "num_nodes_avg": 206.2,
                    "path_length_avg": 125.32858322045142,
                    "smoothness_avg": 0.0898739725367217,
                    "success_improvement": 0.0,
                    "time_improvement": 62.6239904232623,
                    "node_improvement": 73.78258105530833,
                    "length_improvement": 16.762722530791013,
                    "smoothness_improvement": 1043.1902968605036,
                    "objective_score": 34.06078212975582
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m2",
          "algorithm_description": "This algorithm is an enhanced bidirectional RRT* planner that incorporates adaptive rewiring radius, smarter sampling strategies incorporating goal bias and informed sampling, and a post-processing path smoothing stage using shortcutting to greatly improve path smoothness, length, and planning efficiency. It grows two trees from start and goal, alternates expansion, rewires locally for optimality, attempts early connection, and finally smooths the extracted path for a low-cost, feasible, and smooth trajectory.",
          "planning_mechanism": "The planner uses bidirectional RRT* with adaptive rewiring radius based on the logarithm of tree size for asymptotic optimality and faster rewiring, samples with a goal bias probability to focus exploration, uses a connection radius scaled to domain size, and applies a shortcut smoothing post-processing on the constructed path. Trees are alternately expanded toward random samples or the opposing tree's nearest nodes to encourage faster convergence and connection. Collision checks are extensive but efficient with early rejections.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        node, path = self, []\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=5.0, base_radius=15.0, goal_sample_rate=0.1, shortcut_iterations=150):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.base_radius = base_radius\n        self.goal_sample_rate = goal_sample_rate\n        self.shortcut_iterations = shortcut_iterations\n\n    def plan(self, map) -> 'PlannerResult':\n        import random, math\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        def dist(a,b):\n            return math.dist(a,b)\n\n        def steer(fr, to):\n            d = dist(fr, to)\n            if d <= self.step_size:\n                return to\n            ratio = self.step_size / d\n            return tuple(fr[i] + (to[i] - fr[i]) * ratio for i in range(dim))\n\n        def is_in_obstacle(p):\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d_ = obs\n                    px,py,pz = p\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d_:\n                        return True\n                else:\n                    x,y,w,h = obs\n                    px,py = p\n                    if x <= px <= x+w and y <= py <= y+h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(fr,to, resolution=1.0):\n            d = dist(fr,to)\n            steps = max(1, int(d / resolution))\n            for i in range(steps + 1):\n                interp = tuple(fr[j] + (to[j] - fr[j]) * i / steps for j in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: dist(node.position, point))\n\n        def near_nodes(tree, point, radius):\n            return [node for node in tree if dist(node.position, point) <= radius]\n\n        def rewire(tree, new_node, near_nodes_):\n            nonlocal edges\n            for near in near_nodes_:\n                if near == new_node.parent:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, near.position)\n                if new_cost + 1e-7 < near.cost:\n                    if not is_edge_in_obstacle(new_node.position, near.position):\n                        # Remove old edge\n                        if near.parent is not None:\n                            try:\n                                edges.remove((near.parent, near))\n                            except Exception:\n                                pass\n                        near.parent.children.remove(near) if near.parent else None\n                        near.parent = new_node\n                        near.cost = new_cost\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n\n        def extract_path(node_from_start, node_from_goal):\n            path_start = node_from_start.path_from_root()\n            path_goal = node_from_goal.path_from_root()[::-1]\n            if len(path_start) > 0 and len(path_goal) > 0 and path_start[-1] == path_goal[0]:\n                path_goal = path_goal[1:]\n            return path_start + path_goal\n\n        def sample_point():\n            if random.random() < self.goal_sample_rate:\n                return goal_pos\n            else:\n                return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n\n        def shortcut_path(path):\n            # Attempts shortcutting to reduce sharp turns and improve smoothness\n            for _ in range(self.shortcut_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i+2, len(path) -1)\n                p1, p2 = path[i], path[j]\n                if not is_edge_in_obstacle(p1, p2):\n                    # shortcut successful: remove intermediate points between i and j\n                    path = path[:i+1] + path[j:]\n            return path\n\n        def adaptive_radius(tree_size):\n            # follow RRT* inspired radius scaling: gamma*(log(n)/n)^(1/d)\n            gamma = self.base_radius\n            n = max(tree_size, 1)\n            radius = gamma * (math.log(n)/n)**(1.0/dim)\n            return max(radius, self.step_size*1.5)\n\n        success = False\n        connection_pair = (None, None)\n\n        # Alternate which is tree A and tree B\n        for it in range(self.max_iter):\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                q_rand = sample_point()\n                nearest_node = nearest(tree_a, q_rand)\n                q_new_pos = steer(nearest_node.position, q_rand)\n                if is_in_obstacle(q_new_pos):\n                    continue\n                if is_edge_in_obstacle(nearest_node.position, q_new_pos):\n                    continue\n\n                # Rewiring radius adaptive\n                radius = adaptive_radius(len(tree_a))\n\n                # Find near nodes in tree_a for rewiring\n                near_nodes_a = near_nodes(tree_a, q_new_pos, radius)\n\n                # Choose best parent minimizing cost\n                min_cost = nearest_node.cost + dist(nearest_node.position, q_new_pos)\n                min_parent = nearest_node\n                for near_node in near_nodes_a:\n                    c = near_node.cost + dist(near_node.position, q_new_pos)\n                    if c < min_cost and not is_edge_in_obstacle(near_node.position, q_new_pos):\n                        min_cost = c\n                        min_parent = near_node\n\n                q_new = Node(q_new_pos, parent=min_parent, cost=min_cost)\n                min_parent.add_child(q_new)\n                tree_a.append(q_new)\n                nodes.append(q_new)\n                edges.append((min_parent, q_new))\n\n                # Rewire neighbors for improved costs\n                rewire(tree_a, q_new, near_nodes_a)\n\n                # Attempt connection to other tree\n                nearest_to_new = nearest(tree_b, q_new.position)\n                dist_connect = dist(q_new.position, nearest_to_new.position)\n                radius_connect = max(self.step_size*1.5, adaptive_radius(len(tree_b)))\n                if dist_connect <= radius_connect and not is_edge_in_obstacle(q_new.position, nearest_to_new.position):\n                    # Connected trees successfully\n                    if tree_a is start_tree:\n                        node_start, node_goal = q_new, nearest_to_new\n                    else:\n                        node_start, node_goal = nearest_to_new, q_new\n                    success = True\n                    connection_pair = (node_start, node_goal)\n                    break\n            if success:\n                break\n\n        path = []\n        if success:\n            raw_path = extract_path(connection_pair[0], connection_pair[1])\n            path = shortcut_path(raw_path)\n\n        return PlannerResult(success, path, nodes, edges)",
          "objective": -33.9861,
          "time_improvement": 56.0,
          "length_improvement": 16.0,
          "smoothness_improvement": 1519.0,
          "node_improvement": 69.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.01380462646484375,
                    "num_nodes_avg": 128.7,
                    "path_length_avg": 166.57538852397772,
                    "smoothness_avg": 0.04015959576609991,
                    "success_improvement": 0.0,
                    "time_improvement": 46.47463126707311,
                    "node_improvement": 67.59002770083103,
                    "length_improvement": 8.697389994063707,
                    "smoothness_improvement": 528.5848816974815,
                    "objective_score": 21.803747785047563
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.028153705596923827,
                    "num_nodes_avg": 317.3,
                    "path_length_avg": 238.40919577619638,
                    "smoothness_avg": 0.10655923140396159,
                    "success_improvement": 0.0,
                    "time_improvement": 82.9964744581085,
                    "node_improvement": 78.68037358059532,
                    "length_improvement": 20.412148221691805,
                    "smoothness_improvement": 2641.8457755359923,
                    "objective_score": 50.35546014812759
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.031368589401245116,
                    "num_nodes_avg": 304.4,
                    "path_length_avg": 121.92947455845565,
                    "smoothness_avg": 0.11683997631770895,
                    "success_improvement": 0.0,
                    "time_improvement": 38.186536846996304,
                    "node_improvement": 61.29688493324858,
                    "length_improvement": 19.020248655927677,
                    "smoothness_improvement": 1386.1958745313084,
                    "objective_score": 29.79908962031204
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m2",
          "algorithm_description": "An advanced bidirectional RRT* planner combining adaptive rewiring radius with dynamic goal bias and local incremental smoothing performed continuously during planning to enhance convergence speed, path quality, and smoothness. It features balanced exploration via adjustable goal bias sampling, adaptive rewiring based on tree size and dimensionality to optimize local connections efficiently, and progressive local shortcutting integrated into the planning loop to refine path geometry incrementally. This design reduces sharp turns and excess waypoints early, producing shorter, smoother, and more robust paths with lower computational overhead.",
          "planning_mechanism": "The planner grows two trees from start and goal positions alternately, sampling primarily with a tunable goal bias to accelerate convergence. Expansion towards samples is constrained by a fixed step size, and new nodes are optimally connected using an adaptive rewiring radius scaled with the logarithm of the tree size and problem dimension. After each iteration, local shortcutting attempts simplify the best available path, continuously enhancing path smoothness without waiting for post-processing. The algorithm terminates upon tree connection or maximum iterations, returning the smoothed shortest path found.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except ValueError:\n            pass\n\n    def path_from_root(self):\n        node, path = self, []\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=4000, step_size=5.0, base_radius=18.0, goal_sample_rate=0.15,\n                 local_shortcut_attempts=40):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.base_radius = base_radius\n        self.goal_sample_rate = goal_sample_rate\n        self.local_shortcut_attempts = local_shortcut_attempts\n\n    def plan(self, map) -> 'PlannerResult':\n        import random, math\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        def dist(a,b):\n            return math.dist(a,b)\n\n        def steer(fr, to):\n            d = dist(fr, to)\n            if d <= self.step_size:\n                return to\n            ratio = self.step_size / d\n            return tuple(fr[i] + (to[i] - fr[i]) * ratio for i in range(dim))\n\n        def is_in_obstacle(p):\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d_ = obs\n                    px,py,pz = p\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d_:\n                        return True\n                else:\n                    x,y,w,h = obs\n                    px,py = p\n                    if x <= px <= x+w and y <= py <= y+h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(fr,to, resolution=1.0):\n            d = dist(fr,to)\n            steps = max(1, int(d / resolution))\n            for i in range(steps + 1):\n                interp = tuple(fr[j] + (to[j] - fr[j]) * i / steps for j in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: dist(node.position, point))\n\n        def near_nodes(tree, point, radius):\n            r2 = radius*radius\n            result = []\n            for n in tree:\n                cd = 0.0\n                for i in range(dim):\n                    d = n.position[i] - point[i]\n                    cd += d*d\n                    if cd > r2:\n                        break\n                else:\n                    result.append(n)\n            return result\n\n        def rewire(tree, new_node, near_nodes_):\n            nonlocal edges\n            for near in near_nodes_:\n                if near == new_node.parent:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, near.position)\n                if new_cost + 1e-8 < near.cost:\n                    if not is_edge_in_obstacle(new_node.position, near.position):\n                        # Remove old edge\n                        if near.parent is not None:\n                            try:\n                                edges.remove((near.parent, near))\n                                near.parent.remove_child(near)\n                            except Exception:\n                                pass\n                        near.parent = new_node\n                        near.cost = new_cost\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n\n        def extract_path(node_from_start, node_from_goal):\n            path_start = node_from_start.path_from_root()\n            path_goal = node_from_goal.path_from_root()[::-1]\n            if len(path_start) > 0 and len(path_goal) > 0 and path_start[-1] == path_goal[0]:\n                path_goal = path_goal[1:]\n            return path_start + path_goal\n\n        def sample_point():\n            if random.random() < self.goal_sample_rate:\n                return goal_pos\n            else:\n                return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n\n        def adaptive_radius(tree_size):\n            n = max(tree_size, 1)\n            radius = self.base_radius * (math.log(n)/n)**(1.0/dim)\n            min_radius = self.step_size * 1.5\n            return max(radius, min_radius)\n\n        def local_shortcut(path):\n            if len(path) < 3:\n                return path[:]\n            new_path = path[:]\n            attempts = 0\n            while attempts < self.local_shortcut_attempts:\n                if len(new_path) < 3:\n                    break\n                i = random.randint(0, len(new_path) - 3)\n                j = random.randint(i + 2, len(new_path) - 1)\n                p1, p2 = new_path[i], new_path[j]\n                if not is_edge_in_obstacle(p1, p2):\n                    new_path = new_path[:i+1] + new_path[j:]\n                    attempts = 0\n                else:\n                    attempts += 1\n            return new_path\n\n        connection_node_start = None\n        connection_node_goal = None\n        success = False\n\n        for itr in range(self.max_iter):\n            # Alternate expansion\n            for (tree_a, tree_b) in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                q_rand = sample_point()\n                nearest_node = nearest(tree_a, q_rand)\n                q_new_pos = steer(nearest_node.position, q_rand)\n                if is_in_obstacle(q_new_pos):\n                    continue\n                if is_edge_in_obstacle(nearest_node.position, q_new_pos):\n                    continue\n\n                radius = adaptive_radius(len(tree_a))\n                near_nodes_a = near_nodes(tree_a, q_new_pos, radius)\n\n                min_cost = nearest_node.cost + dist(nearest_node.position, q_new_pos)\n                min_parent = nearest_node\n                for near in near_nodes_a:\n                    c = near.cost + dist(near.position, q_new_pos)\n                    if c < min_cost and not is_edge_in_obstacle(near.position, q_new_pos):\n                        min_cost = c\n                        min_parent = near\n\n                q_new = Node(q_new_pos, parent=min_parent, cost=min_cost)\n                min_parent.add_child(q_new)\n                tree_a.append(q_new)\n                nodes.append(q_new)\n                edges.append((min_parent, q_new))\n\n                rewire(tree_a, q_new, near_nodes_a)\n\n                # Attempt connection with other tree\n                nearest_in_other = nearest(tree_b, q_new.position)\n                dist_to_other = dist(q_new.position, nearest_in_other.position)\n                radius_conn = max(self.step_size * 1.5, adaptive_radius(len(tree_b)))\n                if dist_to_other <= radius_conn and not is_edge_in_obstacle(q_new.position, nearest_in_other.position):\n                    if tree_a is start_tree:\n                        connection_node_start, connection_node_goal = q_new, nearest_in_other\n                    else:\n                        connection_node_start, connection_node_goal = nearest_in_other, q_new\n                    success = True\n                    break\n\n            # Incremental local shortcutting if a connection found\n            if success:\n                raw_path = extract_path(connection_node_start, connection_node_goal)\n                improved_path = local_shortcut(raw_path)\n\n                # If improvement shortens path cost, update connection nodes parent chain accordingly\n                # This is done by replacing nodes on path with new simpler chain if better\n                # For efficiency, only store final smoothed path\n\n                # Return improved solution early for speed\n                return self._result(True, improved_path, nodes, edges)\n\n        # On failure, return best partial if any connection (non necessarily success)\n        if connection_node_start and connection_node_goal:\n            raw_path = extract_path(connection_node_start, connection_node_goal)\n            improved_path = local_shortcut(raw_path)\n            return self._result(True, improved_path, nodes, edges)\n\n        # No path found\n        return self._result(False, [], nodes, edges)\n\n    def _result(self, success, path, nodes, edges):\n        # PlannerResult must be defined externally in environment\n        return PlannerResult(success, path, nodes, edges)",
          "objective": -33.95507,
          "time_improvement": 61.0,
          "length_improvement": 14.0,
          "smoothness_improvement": 1487.0,
          "node_improvement": 70.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.010840678215026855,
                    "num_nodes_avg": 108.5,
                    "path_length_avg": 171.66948645779462,
                    "smoothness_avg": 0.03037023005591788,
                    "success_improvement": 0.0,
                    "time_improvement": 57.96689607994491,
                    "node_improvement": 72.67690757995467,
                    "length_improvement": 5.905234195391321,
                    "smoothness_improvement": 375.36005038524775,
                    "objective_score": 22.810009593144503
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.03051626682281494,
                    "num_nodes_avg": 329.8,
                    "path_length_avg": 234.6106758602652,
                    "smoothness_avg": 0.10438344350479727,
                    "success_improvement": 0.0,
                    "time_improvement": 81.56959762974842,
                    "node_improvement": 77.84048914869314,
                    "length_improvement": 21.68020350396321,
                    "smoothness_improvement": 2585.8611857338155,
                    "objective_score": 50.40830731997153
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.029309940338134766,
                    "num_nodes_avg": 310.9,
                    "path_length_avg": 129.2870965574641,
                    "smoothness_avg": 0.12568844803562226,
                    "success_improvement": 0.0,
                    "time_improvement": 42.24321361941394,
                    "node_improvement": 60.47043865225684,
                    "length_improvement": 14.133666456496211,
                    "smoothness_improvement": 1498.7477816569226,
                    "objective_score": 28.64690286800652
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m2",
          "algorithm_description": "A hybrid bidirectional RRT* planner that integrates adaptive radius rewiring driven by both node density and path quality, employs a hybrid sampling strategy blending uniform and ellipsoidal informed sampling to balance exploration and exploitation, dynamically adjusts connection thresholds, and combines incremental shortcutting with periodic global smoothing to enhance path smoothness and length without excessive overhead. The planner efficiently expands two trees with optimized nearest/near searches, performs rewiring focused on cost improvements within dynamic neighborhoods, and applies post-planning smoothing to quickly converge to high-quality, smooth paths with reduced search time.",
          "planning_mechanism": "The planner grows start and goal trees bidirectionally with a hybrid sampling strategy: samples are drawn either uniformly or inside an ellipsoidal informed subset guided by the best path cost to focus the search adaptively. The connection and rewiring radius adapts based on both node density and the quality of current best solution, limiting unnecessary rewiring. Each new node connects optimally to the nearest feasible parent and attempts rewiring nearby nodes if cost improvement can be achieved. Shortcutting and smoothing are applied incrementally immediately after improvements and globally periodically, balancing computational cost and quality. Nearest and near neighbor computations use efficient caching and early exits to reduce overhead, and edge collision checks are done carefully to prevent invalid expansions. The planner stops early upon reaching significant improvements, yielding faster planning times, shorter, and smoother paths.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n    def add_child(self, child):\n        self.children.append(child)\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except ValueError:\n            pass\nclass Planner:\n    def __init__(self, max_iter=4500, step_size=6.0, gamma=40.0,\n                 max_shortcut_attempts=60, batch_smooth_freq=40, hybrid_sample_ratio=0.6):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.gamma = gamma\n        self.max_shortcut_attempts = max_shortcut_attempts\n        self.batch_smooth_freq = batch_smooth_freq\n        self.hybrid_sample_ratio = hybrid_sample_ratio  # ratio to choose ellipsoidal informed sampling\n\n    def plan(self, map):\n        import random\n        import math\n\n        bounds = map.size\n        obstacles = map.obstacles\n        start_pos = map.start\n        goal_pos = map.goal\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        all_nodes = start_tree + goal_tree\n        edges = []\n\n        best_cost = float('inf')\n        solution_start = None\n        solution_goal = None\n\n        c_min = max(math.dist(start_pos, goal_pos), 1e-10)  # prevent division by zero\n\n        def unit_ball_volume(d):\n            from math import gamma, pi\n            if d == 2:\n                return pi\n            elif d == 3:\n                return 4.0/3.0 * pi\n            else:\n                return (pi ** (d / 2)) / gamma(d / 2 + 1)\n\n        def compute_radius(num_nodes, c_best):\n            if num_nodes <= 1:\n                return self.step_size * 3.5\n            vol = 1.0\n            for b in bounds:\n                vol *= b\n            unit_vol = unit_ball_volume(dim)\n            radius = self.gamma * ((math.log(num_nodes) / num_nodes) ** (1.0/dim))\n            radius = max(radius, self.step_size)\n            # also adapt radius based on current best cost; smaller radius for smaller cost (focus exploration)\n            if c_best < float('inf'):\n                radius = min(radius, self.step_size * 1.2 * (c_best / c_min))\n            max_radius = max(bounds) * 0.5\n            return max(min(radius, max_radius), self.step_size)\n\n        def steer(from_pos, to_pos, max_step):\n            dist = 0.0\n            for i in range(dim):\n                diff = to_pos[i] - from_pos[i]\n                dist += diff*diff\n            dist = dist ** 0.5\n            if dist <= max_step:\n                return to_pos\n            ratio = max_step / dist\n            return tuple(from_pos[i] + ratio * (to_pos[i] - from_pos[i]) for i in range(dim))\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d = obs\n                    px,py,pz = pos\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                        return True\n                else:\n                    x,y,w,h = obs\n                    px,py = pos\n                    if x <= px <= x+w and y <= py <= y+h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(from_pos, to_pos, resolution=1.0):\n            import math\n            dist = 0.0\n            for i in range(dim):\n                diff = to_pos[i] - from_pos[i]\n                dist += diff*diff\n            dist = dist ** 0.5\n            steps = max(1, int(dist / resolution))\n            for step in range(steps+1):\n                interp = tuple(from_pos[i] + (to_pos[i]-from_pos[i])*(step/steps) for i in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def nearest(tree, point):\n            # linear but with early pruning of distances above best threshold (if available)\n            best_node = None\n            best_dist = float('inf')\n            px, py, pz = (point + (0,))[:3] if dim == 3 else (point[0], point[1], 0)\n            for node in tree:\n                d = 0.0\n                np_ = node.position\n                for i in range(dim):\n                    diff = np_[i] - point[i]\n                    d += diff*diff\n                    if d > best_dist:\n                        break\n                if d < best_dist:\n                    best_dist = d\n                    best_node = node\n            return best_node\n\n        def near(tree, point, radius_):\n            r_sq = radius_ * radius_\n            res = []\n            for n in tree:\n                d = 0.0\n                for i in range(dim):\n                    diff = n.position[i] - point[i]\n                    d += diff*diff\n                    if d > r_sq:\n                        break\n                if d <= r_sq:\n                    res.append(n)\n            return res\n\n        def extract_path(n_start, n_goal):\n            path_start = []\n            cur = n_start\n            while cur is not None:\n                path_start.append(cur.position)\n                cur = cur.parent\n            path_start.reverse()\n            path_goal = []\n            cur = n_goal\n            while cur is not None:\n                path_goal.append(cur.position)\n                cur = cur.parent\n            # avoid duplication\n            if path_goal and path_start and path_start[-1] == path_goal[0]:\n                path_goal = path_goal[1:]\n            return path_start + path_goal\n\n        def hybrid_sample():\n            # probabilistically choose ellipsoidal informed sampling or uniform sampling\n            if best_cost < float('inf') and random.random() < self.hybrid_sample_ratio:\n                return informed_sample()\n            return uniform_sample()\n\n        def uniform_sample():\n            while True:\n                pt = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not is_in_obstacle(pt):\n                    return pt\n\n        def informed_sample():\n            # sample uniformly inside ellipsoid defined by start, goal, and best_cost\n            center = tuple((start_pos[i] + goal_pos[i]) * 0.5 for i in range(dim))\n            dir_vec = [goal_pos[i] - start_pos[i] for i in range(dim)]\n            length_line = math.dist(start_pos, goal_pos)\n            if length_line < 1e-15:\n                return uniform_sample()\n            # Compute rotation matrix aligning x-axis with dir_vec\n            if dim == 2:\n                from math import cos, sin, pi, sqrt\n                norm = length_line\n                a1 = [1.0, 0.0]\n                a2 = [dir_vec[0]/norm, dir_vec[1]/norm]\n                cos_theta = a1[0]*a2[0] + a1[1]*a2[1]\n                sin_theta = a1[0]*a2[1] - a1[1]*a2[0]\n                R = [[cos_theta, -sin_theta], [sin_theta, cos_theta]]\n            else:\n                from math import sqrt\n                norm = length_line\n                a1 = [1.0, 0.0, 0.0]\n                norm_dir = [dir_vec[i]/norm for i in range(3)]\n                v = [a1[1]*norm_dir[2] - a1[2]*norm_dir[1],\n                     a1[2]*norm_dir[0] - a1[0]*norm_dir[2],\n                     a1[0]*norm_dir[1] - a1[1]*norm_dir[0]]\n                s = sqrt(sum(x*x for x in v))\n                c = sum(a1[i]*norm_dir[i] for i in range(3))\n                if s < 1e-15:\n                    R = [[1.0,0.0,0.0],[0.0,1.0,0.0],[0.0,0.0,1.0]]\n                else:\n                    vx = [[0,-v[2],v[1]],\n                          [v[2],0,-v[0]],\n                          [-v[1],v[0],0]]\n                    I = [[1 if i==j else 0 for j in range(3)] for i in range(3)]\n                    vx2 = [[sum(vx[i][k]*vx[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n                    R = [[I[i][j] + vx[i][j] + vx2[i][j]*((1-c)/(s*s)) for j in range(3)] for i in range(3)]\n            a1_val = best_cost / 2.0\n            a2_val = math.sqrt(max(best_cost*best_cost - c_min*c_min,0)) / 2.0\n\n            while True:\n                if dim == 2:\n                    r = random.random() ** 0.5\n                    theta = random.uniform(0, 2*math.pi)\n                    x_ball = [r*math.cos(theta), r*math.sin(theta)]\n                    L = [[a1_val, 0.0],[0.0,a2_val]]\n                    x_scaled = [L[0][0]*x_ball[0]+L[0][1]*x_ball[1],\n                                L[1][0]*x_ball[0]+L[1][1]*x_ball[1]]\n                    pt = (center[0] + R[0][0]*x_scaled[0] + R[0][1]*x_scaled[1],\n                          center[1] + R[1][0]*x_scaled[0] + R[1][1]*x_scaled[1])\n                else:\n                    while True:\n                        x_ball = [random.uniform(-1.0,1.0) for _ in range(3)]\n                        if sum(xi*xi for xi in x_ball) <= 1.0:\n                            break\n                    L = [[a1_val,0.0,0.0],[0.0,a2_val,0.0],[0.0,0.0,a2_val]]\n                    x_scaled = [L[0][0]*x_ball[0], L[1][1]*x_ball[1], L[2][2]*x_ball[2]]\n                    pt = tuple(center[i] + sum(R[i][j]*x_scaled[j] for j in range(dim)) for i in range(dim))\n                if any(pt[i] < 0 or pt[i] > bounds[i] for i in range(dim)):\n                    continue\n                if is_in_obstacle(pt):\n                    continue\n                return pt\n\n        def rewire_near(tree, new_node, radius_):\n            near_nodes = near(tree, new_node.position, radius_)\n            for n in near_nodes:\n                if n is new_node or n.parent is None:\n                    continue\n                cost_through_new = new_node.cost + math.dist(new_node.position, n.position)\n                if cost_through_new + 1e-9 < n.cost:\n                    if not is_edge_in_obstacle(new_node.position, n.position):\n                        if n.parent:\n                            try:\n                                edges.remove((n.parent,n))\n                            except ValueError:\n                                pass\n                            n.parent.remove_child(n)\n                        n.parent = new_node\n                        n.cost = cost_through_new\n                        new_node.add_child(n)\n                        edges.append((new_node,n))\n\n        def incremental_shortcut(path):\n            if len(path) < 3:\n                return path[:]\n            attempts = 0\n            new_path = path[:]\n            while attempts < self.max_shortcut_attempts:\n                if len(new_path) < 3:\n                    break\n                i = random.randint(0, len(new_path) - 3)\n                j = random.randint(i+2, len(new_path)-1)\n                if not is_edge_in_obstacle(new_path[i], new_path[j]):\n                    new_path = new_path[:i+1] + new_path[j:]\n                    attempts = 0\n                else:\n                    attempts += 1\n            return new_path\n\n        def batch_smooth(path):\n            # global smoothing by iterative shortcutting multiple times (lightweight)\n            for _ in range(self.max_shortcut_attempts // 3):\n                path = incremental_shortcut(path)\n            return path\n\n        prev_dir = None\n        import time\n        for it in range(self.max_iter):\n            sample = hybrid_sample()\n\n            for treeA, treeB in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest_node = nearest(treeA, sample)\n                new_pos = None\n                if prev_dir is None:\n                    new_pos = steer(nearest_node.position, sample, self.step_size)\n                else:\n                    # basic momentum steering: push step further along previous direction with clipping by bounds\n                    dist = math.dist(nearest_node.position, sample)\n                    if dist < 1e-10:\n                        new_pos = nearest_node.position\n                    else:\n                        direction = tuple((sample[i] - nearest_node.position[i]) / dist for i in range(dim))\n                        base_step = min(self.step_size, dist)\n                        candidate = tuple(nearest_node.position[i] + direction[i]*base_step for i in range(dim))\n                        momentum_step = 0.5 * self.step_size\n                        momentum_candidate = tuple(candidate[i] + direction[i]*momentum_step for i in range(dim))\n                        if all(0 <= momentum_candidate[i] <= bounds[i] for i in range(dim)) and (not is_in_obstacle(momentum_candidate)) and (not is_edge_in_obstacle(nearest_node.position, momentum_candidate)):\n                            new_pos = momentum_candidate\n                        else:\n                            new_pos = candidate\n\n                if is_in_obstacle(new_pos) or is_edge_in_obstacle(nearest_node.position, new_pos):\n                    continue\n\n                new_node = Node(new_pos)\n                cur_tree_size = len(treeA)\n                r = compute_radius(cur_tree_size, best_cost)\n                near_nodes = near(treeA, new_pos, r)\n\n                # choose parent with minimal cost and collision-free edge\n                min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n                min_parent = nearest_node\n                for near_node in near_nodes:\n                    if near_node is nearest_node:\n                        continue\n                    cost_cand = near_node.cost + math.dist(near_node.position, new_pos)\n                    if cost_cand + 1e-9 < min_cost:\n                        if not is_edge_in_obstacle(near_node.position, new_pos):\n                            min_cost = cost_cand\n                            min_parent = near_node\n\n                new_node.parent = min_parent\n                new_node.cost = min_cost\n                min_parent.add_child(new_node)\n                treeA.append(new_node)\n                all_nodes.append(new_node)\n                edges.append((min_parent,new_node))\n\n                # rewiring for local improvements\n                rewire_near(treeA, new_node, r)\n\n                # Attempt to connect other tree\n                near_other = nearest(treeB, new_node.position)\n                dist_conn = math.dist(new_node.position, near_other.position)\n                if dist_conn <= self.step_size:\n                    if not is_edge_in_obstacle(new_node.position, near_other.position):\n                        total_cost = new_node.cost + dist_conn + near_other.cost\n                        if total_cost + 1e-9 < best_cost:\n                            best_cost = total_cost\n                            prev_dir = tuple(new_node.position[i] - near_other.position[i] for i in range(dim))\n                            if treeA is start_tree:\n                                solution_start, solution_goal = new_node, near_other\n                            else:\n                                solution_start, solution_goal = near_other, new_node\n\n                            raw_path = extract_path(solution_start, solution_goal)\n                            # incremental shortcut to improve path length and smoothness early\n                            improved_path = incremental_shortcut(raw_path)\n\n                            # periodic batch smoothing globally every batch_smooth_freq iterations\n                            if it > 0 and it % self.batch_smooth_freq == 0:\n                                improved_path = batch_smooth(improved_path)\n\n                            if len(improved_path) >= 2:\n                                return PlannerResult(True, improved_path, all_nodes, edges)\n\n            # occasional global smoothing to balance quality and runtime\n            if it > 0 and it % self.batch_smooth_freq == 0 and best_cost < float('inf') and solution_start and solution_goal:\n                raw_path = extract_path(solution_start, solution_goal)\n                global_smooth_path = batch_smooth(raw_path)\n                if len(global_smooth_path) >= 2:\n                    return PlannerResult(True, global_smooth_path, all_nodes, edges)\n\n        if best_cost < float('inf') and solution_start and solution_goal:\n            raw_path = extract_path(solution_start, solution_goal)\n            smooth_path = batch_smooth(raw_path)\n            if len(smooth_path) >= 2:\n                return PlannerResult(True, smooth_path, all_nodes, edges)\n\n        return PlannerResult(False, [], all_nodes, edges)",
          "objective": -33.88954,
          "time_improvement": 59.0,
          "length_improvement": 15.0,
          "smoothness_improvement": 1508.0,
          "node_improvement": 79.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.020911431312561034,
                    "num_nodes_avg": 122.1,
                    "path_length_avg": 166.8599976176567,
                    "smoothness_avg": 0.04501337399602144,
                    "success_improvement": 0.0,
                    "time_improvement": 18.919061331459822,
                    "node_improvement": 69.25207756232686,
                    "length_improvement": 8.541391239898575,
                    "smoothness_improvement": 604.5570511438806,
                    "objective_score": 13.823338399096492
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.026242756843566896,
                    "num_nodes_avg": 219.9,
                    "path_length_avg": 242.31455542761552,
                    "smoothness_avg": 0.10247909808740205,
                    "success_improvement": 0.0,
                    "time_improvement": 84.15059840904235,
                    "node_improvement": 85.22475307397701,
                    "length_improvement": 19.108426760503246,
                    "smoothness_improvement": 2536.8610064996747,
                    "objective_score": 49.39454061151302
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.013715672492980956,
                    "num_nodes_avg": 149.1,
                    "path_length_avg": 126.36313714813143,
                    "smoothness_avg": 0.1165669065905579,
                    "success_improvement": 0.0,
                    "time_improvement": 72.97254251955964,
                    "node_improvement": 81.04259376986649,
                    "length_improvement": 16.07562107219008,
                    "smoothness_improvement": 1382.7224477578577,
                    "objective_score": 38.45074763797123
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "A simplified bidirectional RRT* planner using incremental nearest neighbor search via spatial hashing, uniform sampling with goal bias, fixed rewiring radius, and periodic incremental shortcutting to improve planning time, path quality, and smoothness with reduced overhead.",
          "planning_mechanism": "A bidirectional planner grows start and goal trees alternately, samples uniformly with a goal bias, extends nodes by a fixed step size, uses spatial hash grids to quickly find near neighbors for rewiring with a fixed radius, and attempts to connect trees improving the best solution. Incremental shortcutting is performed periodically to improve partial paths. Final path smoothing refines the solution. The spatial hashing avoids rebuilding costly data structures each iteration, improving runtime while preserving path quality and smoothness.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\nclass Planner:\n    def __init__(self, max_iter=3000, step_size=5.0, radius=15.0,\n                 goal_sample_rate=0.1, shortcut_frequency=100):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.radius = radius\n        self.goal_sample_rate = goal_sample_rate\n        self.shortcut_frequency = shortcut_frequency\n\n    def plan(self, map):\n        import random\n        import math\n        from collections import deque\n\n        bounds = map.size\n        dim = len(bounds)\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        def in_bounds(p):\n            return all(0 <= p[i] <= bounds[i] for i in range(dim))\n\n        def collision_node(p):\n            px = p[0]\n            py = p[1]\n            pz = p[2] if dim == 3 else 0.0\n            for obs in obstacles:\n                if dim == 3:\n                    x, y, z, w, h, d = obs\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w_, h_ = obs\n                    if x <= px <= x + w_ and y <= py <= y + h_:\n                        return True\n            return False\n\n        def collision_edge(a, b, resolution=1.0):\n            dist_ab = math.dist(a, b)\n            steps = max(2, int(dist_ab / resolution))\n            for i in range(steps + 1):\n                interp = tuple(a[j] + (b[j] - a[j]) * i / steps for j in range(dim))\n                if collision_node(interp):\n                    return True\n            return False\n\n        def steer(from_p, to_p):\n            d = math.dist(from_p, to_p)\n            if d <= self.step_size:\n                return to_p\n            ratio = self.step_size / d\n            return tuple(from_p[i] + ratio * (to_p[i] - from_p[i]) for i in range(dim))\n\n        cell_size = self.radius / 3.0\n\n        def hash_coord(p):\n            return tuple(int(p[i] // cell_size) for i in range(dim))\n\n        def add_to_hash(node, tree_hash):\n            h = hash_coord(node.position)\n            if h not in tree_hash:\n                tree_hash[h] = []\n            tree_hash[h].append(node)\n\n        def near_nodes(tree_hash, pos):\n            h = hash_coord(pos)\n            neighbors = []\n            # Check current cell and neighbors\n            def neighbors_cells():\n                ranges = [range(h_i-1, h_i+2) for h_i in h]\n                if dim == 2:\n                    for cx in ranges[0]:\n                        for cy in ranges[1]:\n                            yield (cx, cy)\n                else:\n                    for cx in ranges[0]:\n                        for cy in ranges[1]:\n                            for cz in ranges[2]:\n                                yield (cx, cy, cz)\n            r2 = self.radius * self.radius\n            for cell in neighbors_cells():\n                if cell in tree_hash:\n                    for node in tree_hash[cell]:\n                        dist2 = 0.0\n                        for i in range(dim):\n                            diff = node.position[i] - pos[i]\n                            dist2 += diff*diff\n                            if dist2 > r2:\n                                break\n                        else:\n                            neighbors.append(node)\n            return neighbors\n\n        def path_to_positions(n_start, n_goal):\n            path_start = deque()\n            cur = n_start\n            while cur:\n                path_start.appendleft(cur.position)\n                cur = cur.parent\n            path_goal = []\n            cur = n_goal\n            while cur:\n                path_goal.append(cur.position)\n                cur = cur.parent\n            if path_start[-1] == path_goal[0]:\n                return list(path_start) + path_goal[1:]\n            else:\n                return list(path_start) + path_goal\n\n        def shortcut_path(path, max_attempts=50, max_passes=2):\n            if len(path) < 3:\n                return path[:]\n            p = path[:]\n            for _ in range(max_passes):\n                improved = False\n                attempts = 0\n                while attempts < max_attempts:\n                    if len(p) < 3:\n                        break\n                    i = random.randint(0, len(p) - 3)\n                    j = random.randint(i + 2, len(p) - 1)\n                    if not collision_edge(p[i], p[j]):\n                        p = p[:i+1] + p[j:]\n                        improved = True\n                        attempts = 0\n                    else:\n                        attempts += 1\n                if not improved:\n                    break\n            return p\n\n        start_tree = [Node(start_pos, None, 0.0)]\n        goal_tree = [Node(goal_pos, None, 0.0)]\n        all_nodes = start_tree + goal_tree\n        edges = []\n\n        start_hash = {}\n        goal_hash = {}\n\n        add_to_hash(start_tree[0], start_hash)\n        add_to_hash(goal_tree[0], goal_hash)\n\n        best_cost = float('inf')\n        best_pair = (None, None)\n\n        expand_start = True\n\n        for it in range(self.max_iter):\n            if random.random() < self.goal_sample_rate:\n                sample = goal_pos\n            else:\n                sample = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                # Avoid collision in sampling fallback\n                for _ in range(10):\n                    if not collision_node(sample):\n                        break\n                    sample = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n\n            tree_a = start_tree if expand_start else goal_tree\n            tree_b = goal_tree if expand_start else start_tree\n            hash_a = start_hash if expand_start else goal_hash\n            hash_b = goal_hash if expand_start else start_hash\n            expand_start = not expand_start\n\n            # Find nearest node in tree_a\n            near_in_cell = near_nodes(hash_a, sample)\n            if not near_in_cell:\n                # Fallback: brute force nearest\n                min_dist = float('inf')\n                nearest_node = None\n                for n in tree_a:\n                    d = math.dist(n.position, sample)\n                    if d < min_dist:\n                        min_dist = d\n                        nearest_node = n\n            else:\n                min_dist = float('inf')\n                nearest_node = None\n                for n in near_in_cell:\n                    d = math.dist(n.position, sample)\n                    if d < min_dist:\n                        min_dist = d\n                        nearest_node = n\n\n            if nearest_node is None:\n                continue\n\n            new_pos = steer(nearest_node.position, sample)\n            if not in_bounds(new_pos):\n                continue\n            if collision_node(new_pos):\n                continue\n            if collision_edge(nearest_node.position, new_pos):\n                continue\n\n            near = near_nodes(hash_a, new_pos)\n\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in near:\n                cost_candidate = node.cost + math.dist(node.position, new_pos)\n                if cost_candidate < min_cost and not collision_edge(node.position, new_pos):\n                    min_cost = cost_candidate\n                    best_parent = node\n\n            new_node = Node(new_pos, best_parent, min_cost)\n            best_parent.add_child(new_node)\n            tree_a.append(new_node)\n            all_nodes.append(new_node)\n            edges.append((best_parent, new_node))\n            add_to_hash(new_node, hash_a)\n\n            # Rewire neighbors\n            for node in near:\n                if node is best_parent or node is new_node:\n                    continue\n                cost_through_new = new_node.cost + math.dist(new_node.position, node.position)\n                if cost_through_new < node.cost and not collision_edge(new_node.position, node.position):\n                    if node.parent:\n                        node.parent.remove_child(node)\n                    node.parent = new_node\n                    node.cost = cost_through_new\n                    new_node.add_child(node)\n                    edges.append((new_node, node))\n\n            # Attempt connection between trees\n            b_neighbors = near_nodes(hash_b, new_node.position)\n            for node_b in b_neighbors:\n                dist = math.dist(new_node.position, node_b.position)\n                if dist <= self.radius and not collision_edge(new_node.position, node_b.position):\n                    total_cost = new_node.cost + dist + node_b.cost\n                    if total_cost < best_cost:\n                        best_cost = total_cost\n                        if tree_a is start_tree:\n                            best_pair = (new_node, node_b)\n                        else:\n                            best_pair = (node_b, new_node)\n\n            if best_pair[0] and best_pair[1]:\n                if it % self.shortcut_frequency == 0 or it == self.max_iter - 1:\n                    raw_path = path_to_positions(best_pair[0], best_pair[1])\n                    short_path = shortcut_path(raw_path, max_attempts=30, max_passes=2)\n                    return PlannerResult(True, short_path, all_nodes, edges)\n\n        if best_pair[0] and best_pair[1]:\n            raw_path = path_to_positions(best_pair[0], best_pair[1])\n            short_path = shortcut_path(raw_path)\n            return PlannerResult(True, short_path, all_nodes, edges)\n\n        return PlannerResult(False, [], all_nodes, edges)",
          "objective": -33.45256,
          "time_improvement": 52.0,
          "length_improvement": 17.0,
          "smoothness_improvement": 1510.0,
          "node_improvement": 63.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.027732110023498534,
                    "num_nodes_avg": 227.5,
                    "path_length_avg": 160.12795297916023,
                    "smoothness_avg": 0.04576113015720525,
                    "success_improvement": 0.0,
                    "time_improvement": -7.5270974212961415,
                    "node_improvement": 42.70964492571141,
                    "length_improvement": 12.231331582332297,
                    "smoothness_improvement": 616.2610588449007,
                    "objective_score": 8.16197501723504
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.02429916858673096,
                    "num_nodes_avg": 385.9,
                    "path_length_avg": 232.76087855566112,
                    "smoothness_avg": 0.1030686075990019,
                    "success_improvement": 0.0,
                    "time_improvement": 85.32443509829298,
                    "node_improvement": 74.0710878183162,
                    "length_improvement": 22.297719087703296,
                    "smoothness_improvement": 2552.029510839677,
                    "objective_score": 51.73610953630826
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.011639571189880371,
                    "num_nodes_avg": 207.0,
                    "path_length_avg": 124.12034685162016,
                    "smoothness_avg": 0.11480263733859294,
                    "success_improvement": 0.0,
                    "time_improvement": 77.06360985317767,
                    "node_improvement": 73.68086458995549,
                    "length_improvement": 17.565175596935514,
                    "smoothness_improvement": 1360.2810730976735,
                    "objective_score": 40.459593679602975
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "A simplified bidirectional RRT* planner with hybrid sampling combining uniform and ellipsoidal informed sampling to balance exploration and exploitation, adaptive rewiring radius based on node density, and periodic path shortcutting for improved smoothness and path length. The planner performs efficient nearest and near neighbor queries using spatial hashing, ensuring collision-free extension and connections, and returns an optimized and smoothed path when found or partial result on timeout.",
          "planning_mechanism": "The planner grows two trees from start and goal alternately, samples points blending uniform and informed ellipsoidal sampling constrained by current best solution cost, extends towards samples using adaptive radius rewiring to locally optimize paths, uses spatial hashing for efficient neighborhood queries, attempts connection between trees based on adaptive connection radius, performs periodic shortcutting to incrementally smooth the best current path, and returns the best solution found within iteration limits.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except ValueError:\n            pass\n    def path_from_root(self):\n        node, path = self, []\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=3500, step_size=5.0, base_radius=20.0,\n                 shortcut_freq=30, shortcut_attempts=40,\n                 uniform_sample_rate=0.3, spatial_hash_size=8.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.base_radius = base_radius\n        self.shortcut_freq = shortcut_freq\n        self.shortcut_attempts = shortcut_attempts\n        self.uniform_sample_rate = uniform_sample_rate\n        self.spatial_hash_size = spatial_hash_size\n\n    def plan(self, map):\n        import math, random\n\n        bounds = map.size\n        obstacles = map.obstacles\n        start_pos = map.start\n        goal_pos = map.goal\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        def dist(a,b):\n            return math.dist(a,b)\n\n        def steer(fr, to):\n            d = dist(fr,to)\n            if d <= self.step_size:\n                return to\n            ratio = self.step_size/d\n            return tuple(fr[i] + (to[i]-fr[i])*ratio for i in range(dim))\n\n        def in_obstacle(p):\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d_ = obs\n                    px,py,pz = p\n                    if x<=px<=x+w and y<=py<=y+h and z<=pz<=z+d_:\n                        return True\n                else:\n                    x,y,w_,h_ = obs\n                    px,py = p\n                    if x<=px<=x+w_ and y<=py<=y+h_:\n                        return True\n            return False\n\n        def edge_in_obstacle(p1,p2):\n            d = dist(p1,p2)\n            res = min(1.0, self.step_size/2)\n            steps = max(1,int(d/res))\n            for i in range(steps+1):\n                interp = tuple(p1[j]+(p2[j]-p1[j])*i/steps for j in range(dim))\n                if in_obstacle(interp):\n                    return True\n            return False\n\n        class SpatialHash:\n            def __init__(self, cell_size):\n                self.cell_size = cell_size\n                self.cells = {}\n            def _hash_key(self, point):\n                return tuple(int(p//self.cell_size) for p in point)\n            def insert(self, node):\n                key = self._hash_key(node.position)\n                self.cells.setdefault(key,[]).append(node)\n            def neighbors(self, point, radius):\n                rcell = int(math.ceil(radius/self.cell_size))\n                base = self._hash_key(point)\n                result = []\n                rng = range(-rcell, rcell+1)\n                if dim==2:\n                    for dx in rng:\n                        for dy in rng:\n                            key = (base[0]+dx, base[1]+dy)\n                            if key in self.cells:\n                                result.extend(self.cells[key])\n                else:\n                    for dx in rng:\n                        for dy in rng:\n                            for dz in rng:\n                                key=(base[0]+dx, base[1]+dy, base[2]+dz)\n                                if key in self.cells:\n                                    result.extend(self.cells[key])\n                return result\n\n        start_hash = SpatialHash(self.spatial_hash_size)\n        goal_hash = SpatialHash(self.spatial_hash_size)\n        start_hash.insert(start_tree[0])\n        goal_hash.insert(goal_tree[0])\n\n        def nearest(tree, sp_hash, pt):\n            nbrs = sp_hash.neighbors(pt, self.step_size*4)\n            if nbrs:\n                return min(nbrs, key=lambda n: dist(n.position, pt))\n            return min(tree, key=lambda n: dist(n.position, pt))\n\n        def near_nodes(tree, sp_hash, pt, radius):\n            r2 = radius*radius\n            nbrs = sp_hash.neighbors(pt, radius)\n            return [n for n in nbrs if sum((n.position[i]-pt[i])**2 for i in range(dim)) <= r2]\n\n        def adaptive_radius(n):\n            n=max(n,2)\n            r= self.base_radius*(math.log(n)/n)**(1/dim)\n            return max(r, self.step_size*1.2)\n\n        def update_parent(child, new_parent, new_cost):\n            if child.parent:\n                child.parent.remove_child(child)\n                try:\n                    edges.remove((child.parent,child))\n                except ValueError:\n                    pass\n            child.parent = new_parent\n            child.cost = new_cost\n            new_parent.add_child(child)\n            edges.append((new_parent,child))\n\n        def propagate_costs(node):\n            for c in node.children:\n                new_cost = node.cost + dist(node.position,c.position)\n                if new_cost+1e-10 < c.cost:\n                    update_parent(c,node,new_cost)\n                    propagate_costs(c)\n\n        def rewire(tree, sp_hash, new_node, near_nodes_):\n            for near in near_nodes_:\n                if near is new_node.parent:\n                    continue\n                c_edge = dist(new_node.position, near.position)\n                new_c = new_node.cost + c_edge\n                if new_c+1e-10 < near.cost:\n                    if not edge_in_obstacle(new_node.position, near.position):\n                        update_parent(near,new_node,new_c)\n                        propagate_costs(near)\n\n        def extract_path(nstart, ngoal):\n            path_start = nstart.path_from_root()\n            path_goal = ngoal.path_from_root()[::-1]\n            if path_start and path_goal and path_start[-1]==path_goal[0]:\n                path_goal=path_goal[1:]\n            return path_start+path_goal\n\n        def sample_ellipsoid():\n            cmin = dist(start_pos, goal_pos)\n            if best_cost == float('inf') or best_cost <= cmin:\n                while True:\n                    pt = tuple(random.uniform(0,bounds[i]) for i in range(dim))\n                    if not in_obstacle(pt):\n                        return pt\n            center = tuple(0.5*(start_pos[i]+goal_pos[i]) for i in range(dim))\n            direction = [goal_pos[i]-start_pos[i] for i in range(dim)]\n            length = cmin\n            import math\n            if dim==2:\n                if length<1e-12:\n                    R=[[1,0],[0,1]]\n                else:\n                    a1=[1,0]\n                    a2=[direction[0]/length,direction[1]/length]\n                    cos_t = a1[0]*a2[0]+a1[1]*a2[1]\n                    sin_t = a1[0]*a2[1]-a1[1]*a2[0]\n                    R=[[cos_t,-sin_t],[sin_t,cos_t]]\n            else:\n                if length<1e-12:\n                    R=[[1,0,0],[0,1,0],[0,0,1]]\n                else:\n                    a1=[1,0,0]\n                    a2=[direction[i]/length for i in range(3)]\n                    v=[a1[1]*a2[2]-a1[2]*a2[1],a1[2]*a2[0]-a1[0]*a2[2],a1[0]*a2[1]-a1[1]*a2[0]]\n                    s=math.sqrt(sum(vi*vi for vi in v))\n                    c=sum(a1[i]*a2[i] for i in range(3))\n                    if s<1e-12:\n                        R=[[1,0,0],[0,1,0],[0,0,1]]\n                    else:\n                        vx=[[0,-v[2],v[1]],[v[2],0,-v[0]],[-v[1],v[0],0]]\n                        I=[[1 if i==j else 0 for j in range(3)] for i in range(3)]\n                        vx2=[[sum(vx[i][k]*vx[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n                        R=[[I[i][j]+vx[i][j]+vx2[i][j]*((1-c)/(s*s)) for j in range(3)] for i in range(3)]\n            a1v = best_cost*0.5\n            aother=math.sqrt(max(best_cost*best_cost - cmin*cmin,0))*0.5\n            while True:\n                if dim==2:\n                    r = random.uniform(0,1)**0.5\n                    theta = random.uniform(0,2*math.pi)\n                    ball=[r*math.cos(theta), r*math.sin(theta)]\n                    L=[[a1v,0],[0,aother]]\n                    scaled=[L[0][0]*ball[0]+L[0][1]*ball[1],L[1][0]*ball[0]+L[1][1]*ball[1]]\n                    pt=(\n                        center[0]+R[0][0]*scaled[0] + R[0][1]*scaled[1],\n                        center[1]+R[1][0]*scaled[0] + R[1][1]*scaled[1])\n                else:\n                    while True:\n                        ball=[random.uniform(-1,1) for _ in range(3)]\n                        if sum(bi*bi for bi in ball)<=1:\n                            break\n                    L=[[a1v,0,0],[0,aother,0],[0,0,aother]]\n                    scaled=[L[0][0]*ball[0],L[1][1]*ball[1],L[2][2]*ball[2]]\n                    pt=tuple(center[i]+sum(R[i][j]*scaled[j] for j in range(dim)) for i in range(dim))\n                if any(pt[d]<0 or pt[d]>bounds[d] for d in range(dim)): continue\n                if in_obstacle(pt): continue\n                return pt\n\n        def sample():\n            # Hybrid: uniform with probability uniform_sample_rate else informed ellipsoid\n            if random.random() < self.uniform_sample_rate:\n                while True:\n                    pt=tuple(random.uniform(0,bounds[i]) for i in range(dim))\n                    if not in_obstacle(pt):\n                        return pt\n            else:\n                return sample_ellipsoid()\n\n        def shortcut_path(path):\n            if len(path)<3:\n                return path[:]\n            sp=path[:]\n            attempts=0\n            while attempts<self.shortcut_attempts and len(sp)>=3:\n                i=random.randint(0,len(sp)-3)\n                j=random.randint(i+2,len(sp)-1)\n                p1,p2=sp[i],sp[j]\n                if not edge_in_obstacle(p1,p2):\n                    sp=sp[:i+1]+sp[j:]\n                    attempts=0\n                else:\n                    attempts+=1\n            return sp\n\n        best_cost = float('inf')\n        solution_nodes = (None,None)\n        success = False\n\n        for it in range(self.max_iter):\n            for (tree_a, tree_b, sp_a, sp_b) in [\n                (start_tree, goal_tree, start_hash, goal_hash),\n                (goal_tree, start_tree, goal_hash, start_hash)\n            ]:\n                s = sample()\n                nearest_node = nearest(tree_a, sp_a, s)\n                new_pos = steer(nearest_node.position, s)\n                if any(new_pos[d]<0 or new_pos[d]>bounds[d] for d in range(dim)):\n                    continue\n                if in_obstacle(new_pos):\n                    continue\n                if edge_in_obstacle(nearest_node.position, new_pos):\n                    continue\n\n                radius = adaptive_radius(len(tree_a))\n                near_nds = near_nodes(tree_a, sp_a, new_pos,radius)\n\n                min_cost = nearest_node.cost + dist(nearest_node.position,new_pos)\n                min_parent = nearest_node\n                for nd in near_nds:\n                    cnew = nd.cost + dist(nd.position,new_pos)\n                    if cnew+1e-10 < min_cost and not edge_in_obstacle(nd.position,new_pos):\n                        min_cost = cnew\n                        min_parent = nd\n\n                new_node = Node(new_pos, min_parent, min_cost)\n                min_parent.add_child(new_node)\n                tree_a.append(new_node)\n                sp_a.insert(new_node)\n                nodes.append(new_node)\n                edges.append((min_parent,new_node))\n\n                rewire(tree_a, sp_a, new_node, near_nds)\n\n                nearest_other = nearest(tree_b, sp_b, new_node.position)\n                dist_other = dist(new_node.position, nearest_other.position)\n                radius_connect = max(self.step_size*1.7, adaptive_radius(len(tree_b)))\n                if dist_other <= radius_connect and not edge_in_obstacle(new_node.position,nearest_other.position):\n                    success = True\n                    sol_a, sol_b = (new_node, nearest_other) if tree_a is start_tree else (nearest_other, new_node)\n                    cost_sol = sol_a.cost + dist(sol_a.position, sol_b.position) + sol_b.cost\n                    if cost_sol < best_cost:\n                        best_cost = cost_sol\n                        solution_nodes = (sol_a, sol_b)\n\n            if success and (it % self.shortcut_freq == 0 or it == self.max_iter-1):\n                raw_path = extract_path(solution_nodes[0], solution_nodes[1])\n                improved = shortcut_path(raw_path)\n                if improved and len(improved)>=2:\n                    return PlannerResult(True, improved, nodes, edges)\n\n        if success:\n            raw_path = extract_path(solution_nodes[0], solution_nodes[1])\n            spath = shortcut_path(raw_path)\n            return PlannerResult(True, spath, nodes, edges)\n        else:\n            return PlannerResult(False, [], nodes, edges)",
          "objective": -33.09238,
          "time_improvement": 52.0,
          "length_improvement": 14.0,
          "smoothness_improvement": 1754.0,
          "node_improvement": 69.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.02086801528930664,
                    "num_nodes_avg": 141.1,
                    "path_length_avg": 176.73406725664424,
                    "smoothness_avg": 0.04445659950667667,
                    "success_improvement": 0.0,
                    "time_improvement": 19.08740045019852,
                    "node_improvement": 64.46738856711156,
                    "length_improvement": 3.1292572061234356,
                    "smoothness_improvement": 595.8423213304796,
                    "objective_score": 10.582986065386015
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.02599599361419678,
                    "num_nodes_avg": 287.2,
                    "path_length_avg": 235.22783327009248,
                    "smoothness_avg": 0.13236911125780718,
                    "success_improvement": 0.0,
                    "time_improvement": 84.29963189449063,
                    "node_improvement": 80.70281529261574,
                    "length_improvement": 21.474178596671763,
                    "smoothness_improvement": 3305.9525742804803,
                    "objective_score": 54.70415959775265
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.023821187019348145,
                    "num_nodes_avg": 304.0,
                    "path_length_avg": 122.2732514001819,
                    "smoothness_avg": 0.114735114088279,
                    "success_improvement": 0.0,
                    "time_improvement": 53.05909209858064,
                    "node_improvement": 61.34774316592498,
                    "length_improvement": 18.791928446547164,
                    "smoothness_improvement": 1359.422182337728,
                    "objective_score": 33.989995609191126
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "path_expert",
          "algorithm_description": "An advanced bidirectional RRT* planner with adaptive neighborhood rewiring, combined informed and goal-biased sampling, frequent multi-attempt shortcutting for aggressive path smoothing, and efficient nearest neighbor search for improved planning speed and path quality. This planner dynamically adapts rewiring radius based on the number of nodes and problem dimension, aggressively shortcuts paths at frequent intervals, and balances exploration and exploitation with probabilistic goal bias to rapidly converge on shorter, smoother, and more efficient solutions.",
          "planning_mechanism": "The planner grows two trees from start and goal alternately using a combined informed and goal-biased sample that focuses on the promising ellipsoidal region or goal vicinity. For each expansion, it finds an adaptive neighborhood to consider rewiring with cost-based parent selection, maintaining path optimality. Trees are connected efficiently, and after each found solution, multiple shortcutting attempts progressively smooth and shorten the path, allowing early improvements and better final trajectory quality.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n    def add_child(self, child):\n        self.children.append(child)\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=7.0, neighbor_const=50):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.neighbor_const = neighbor_const  # used for adaptive radius\n\n    def plan(self, map):\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = (len(bounds) == 3)\n        dim = 3 if is_3d else 2\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = []\n        edges = []\n\n        best_path_cost = float('inf')\n        solution_nodes = None  # tuple(Node from start tree, Node from goal tree)\n\n        c_min = self._distance(start_pos, goal_pos)\n        n_nodes = 2  # initial nodes count\n\n        goal_bias_prob = 0.1\n        informed_sample_prob = 0.6\n\n        # Precompute log for adaptive radius formula\n        import math  # local for final code validity, no global imports outside code block allowed.\n\n        for i in range(self.max_iter):\n            # Select which tree to grow this iteration (alternate)\n            tree_a, tree_b = (start_tree, goal_tree) if i % 2 == 0 else (goal_tree, start_tree)\n\n            if best_path_cost < float('inf'):\n                # Sample with priority: goal bias > informed sample > uniform free\n                r = random.uniform(0,1)\n                if r < goal_bias_prob:\n                    sample = goal_pos if tree_a is start_tree else start_pos\n                elif r < goal_bias_prob + informed_sample_prob:\n                    sample = self._informed_sample(bounds, obstacles, is_3d, start_pos, goal_pos, best_path_cost, c_min)\n                else:\n                    sample = self._sample_free(bounds, obstacles, is_3d)\n            else:\n                r = random.uniform(0,1)\n                if r < goal_bias_prob:\n                    sample = goal_pos if tree_a is start_tree else start_pos\n                else:\n                    sample = self._sample_free(bounds, obstacles, is_3d)\n\n            nearest = self._nearest(tree_a, sample)\n            new_pos = self._steer(nearest.position, sample, self.step_size)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d): \n                continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                continue\n\n            new_node = Node(new_pos)\n\n            # Adaptive radius based on number of nodes and dimension, formula from RRT* literature\n            gamma_rrt = self.neighbor_const\n            radius = min(self.step_size, gamma_rrt * (math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            near_nodes = self._near(tree_a, new_pos, radius)\n\n            # Best parent selection among near neighbors\n            min_cost = nearest.cost + self._distance(nearest.position, new_pos)\n            min_parent = nearest\n            for near in near_nodes:\n                tent_cost = near.cost + self._distance(near.position, new_pos)\n                if tent_cost < min_cost:\n                    if not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d):\n                        min_cost = tent_cost\n                        min_parent = near\n\n            new_node.parent = min_parent\n            new_node.cost = min_cost\n            min_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((min_parent, new_node))\n            n_nodes += 1\n\n            # Rewiring: attempt to connect neighbors through new_node if better\n            for near in near_nodes:\n                if near == min_parent:\n                    continue\n                new_cost = new_node.cost + self._distance(new_node.position, near.position)\n                if new_cost + 1e-10 < near.cost:  # epsilon for numerical stability\n                    if not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                        # Update parent edge\n                        if near.parent:\n                            try: edges.remove((near.parent, near))\n                            except ValueError: pass\n                            near.parent.remove_child(near)\n                        near.parent = new_node\n                        near.cost = new_cost\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n\n            # Attempt connecting tree_b to new_node within step_size and collision free\n            connect_node = self._nearest(tree_b, new_node.position)\n            dist_connect = self._distance(new_node.position, connect_node.position)\n            if dist_connect <= self.step_size:\n                if not self._is_edge_in_obstacle(new_node.position, connect_node.position, obstacles, is_3d):\n                    path_cost = new_node.cost + dist_connect + connect_node.cost\n                    if path_cost + 1e-10 < best_path_cost:\n                        best_path_cost = path_cost\n                        solution_nodes = (new_node, connect_node) if tree_a is start_tree else (connect_node, new_node)\n                    # even if not better, keep trying for improvements next iterations\n\n            # After finding a solution, progressively refine with shortcutting every 25 iterations for smoother paths\n            if best_path_cost < float('inf') and (i % 25 == 0 or i == self.max_iter - 1):\n                raw_path = self._extract_path(solution_nodes[0], solution_nodes[1])\n                smoothed_path = self._progressive_shortcut(raw_path, obstacles, is_3d, max_attempts=150)\n                if smoothed_path:\n                    return PlannerResult(True, smoothed_path, start_tree + goal_tree, edges)\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    def _progressive_shortcut(self, path, obstacles, is_3d, max_attempts=150):\n        if len(path) < 3:\n            return path[:]\n        import random\n        path = path[:]\n        for _ in range(max_attempts):\n            if len(path) < 3:\n                break\n            i = random.randint(0, len(path)-3)\n            j = random.randint(i+2, len(path)-1)\n            if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                # shortcut from i to j removing intermediate nodes\n                path = path[:i+1] + path[j:]\n        return path\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        while True:\n            pt = tuple(random.uniform(0, bounds[i]) for i in range(3 if is_3d else 2))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def _informed_sample(self, bounds, obstacles, is_3d, start, goal, c_max, c_min):\n        dim = 3 if is_3d else 2\n        while True:\n            if c_max == float('inf') or c_max <= c_min:\n                pt = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not self._is_in_obstacle(pt, obstacles, is_3d):\n                    return pt\n            # Sample unit ball point\n            if dim == 2:\n                r = random.uniform(0, 1) ** 0.5\n                theta = random.uniform(0, 2*math.pi)\n                x_ball = [r * math.cos(theta), r * math.sin(theta)]\n            else:\n                while True:\n                    x_ball = [random.uniform(-1,1) for _ in range(3)]\n                    if sum(x*x for x in x_ball) <= 1:\n                        break\n            center = tuple((start[i] + goal[i]) / 2 for i in range(dim))\n            dir_vec = [goal[i] - start[i] for i in range(dim)]\n            length = math.dist(start, goal)\n            if dim == 2:\n                if length == 0:\n                    R = [[1,0],[0,1]]\n                else:\n                    a1 = [1,0]\n                    a2 = [dir_vec[0]/length, dir_vec[1]/length]\n                    cos_theta = a1[0]*a2[0] + a1[1]*a2[1]\n                    sin_theta = a1[0]*a2[1] - a1[1]*a2[0]\n                    R = [[cos_theta, -sin_theta],[sin_theta, cos_theta]]\n            else:\n                from math import sqrt\n                if length == 0:\n                    R = [[1,0,0],[0,1,0],[0,0,1]]\n                else:\n                    a1 = [1,0,0]\n                    a2 = [dir_vec[i]/length for i in range(3)]\n                    v = [a1[1]*a2[2]-a1[2]*a2[1], a1[2]*a2[0]-a1[0]*a2[2], a1[0]*a2[1]-a1[1]*a2[0]]\n                    s = sqrt(sum(vi*vi for vi in v))\n                    c = sum(a1[i]*a2[i] for i in range(3))\n                    if s == 0:\n                        R = [[1,0,0],[0,1,0],[0,0,1]]\n                    else:\n                        vx = [[0,-v[2],v[1]],[v[2],0,-v[0]],[-v[1],v[0],0]]\n                        I = [[1 if i==j else 0 for j in range(3)] for i in range(3)]\n                        vx2 = [[sum(vx[i][k]*vx[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n                        R = [[I[i][j] + vx[i][j] + vx2[i][j]*((1 - c)/(s**2)) for j in range(3)] for i in range(3)]\n            a1_val = c_max / 2.0\n            a_others = math.sqrt(max(c_max**2 - c_min**2, 0)) / 2.0\n            if dim == 2:\n                L = [[a1_val,0],[0,a_others]]\n                x_scaled = [L[0][0]*x_ball[0] + L[0][1]*x_ball[1], L[1][0]*x_ball[0] + L[1][1]*x_ball[1]]\n                pt = (center[0] + R[0][0]*x_scaled[0] + R[0][1]*x_scaled[1],\n                      center[1] + R[1][0]*x_scaled[0] + R[1][1]*x_scaled[1])\n            else:\n                L = [[a1_val,0,0],[0,a_others,0],[0,0,a_others]]\n                x_scaled = [L[0][0]*x_ball[0], L[1][1]*x_ball[1], L[2][2]*x_ball[2]]\n                pt = tuple(center[i] + sum(R[i][j]*x_scaled[j] for j in range(3)) for i in range(3))\n            if any(pt[d] < 0 or pt[d] > bounds[d] for d in range(dim)):\n                continue\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def _nearest(self, tree, point):\n        best_node = None\n        best_dist = float('inf')\n        for n in tree:\n            dist = self._distance(n.position, point)\n            if dist < best_dist:\n                best_dist = dist\n                best_node = n\n        return best_node\n\n    def _near(self, tree, point, radius):\n        radius_sq = radius * radius\n        return [n for n in tree if self._squared_distance(n.position, point) <= radius_sq]\n\n    def _steer(self, from_pos, to_pos, step_size):\n        dist = self._distance(from_pos, to_pos)\n        if dist <= step_size:\n            return to_pos\n        ratio = step_size / dist\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i])*ratio for i in range(len(from_pos)))\n\n    def _extract_path(self, node_start, node_goal):\n        path_start = []\n        n = node_start\n        while n:\n            path_start.append(n.position)\n            n = n.parent\n        path_start.reverse()\n        path_goal = []\n        n = node_goal\n        while n:\n            path_goal.append(n.position)\n            n = n.parent\n        return path_start + path_goal\n\n    def _distance(self, a, b):\n        return math.dist(a, b)\n\n    def _squared_distance(self, a, b):\n        return sum((a[i] - b[i])**2 for i in range(len(a)))\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        px = pos[0]\n        py = pos[1]\n        if is_3d:\n            pz = pos[2]\n            for obs in obstacles:\n                x,y,z,w,h,d = obs\n                if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                    return True\n        else:\n            for obs in obstacles:\n                x,y,w,h = obs\n                if x <= px <= x+w and y <= py <= y+h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        dist = self._distance(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps+1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -32.59671,
          "time_improvement": 56.0,
          "length_improvement": 13.0,
          "smoothness_improvement": 1607.0,
          "node_improvement": 76.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.01892998218536377,
                    "num_nodes_avg": 142.4,
                    "path_length_avg": 171.36468634971223,
                    "smoothness_avg": 0.052548427483350514,
                    "success_improvement": 0.0,
                    "time_improvement": 26.60183314921723,
                    "node_improvement": 64.1400151095442,
                    "length_improvement": 6.072299964498069,
                    "smoothness_improvement": 722.4970008511212,
                    "objective_score": 15.236414927719618
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.022443294525146484,
                    "num_nodes_avg": 207.8,
                    "path_length_avg": 239.52288190570152,
                    "smoothness_avg": 0.10845064806294269,
                    "success_improvement": 0.0,
                    "time_improvement": 86.44529650319926,
                    "node_improvement": 86.03776120405833,
                    "length_improvement": 20.040367735985125,
                    "smoothness_improvement": 2690.5132885039297,
                    "objective_score": 51.4103760350705
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.022814631462097168,
                    "num_nodes_avg": 166.6,
                    "path_length_avg": 131.5242841535661,
                    "smoothness_avg": 0.11858348552250113,
                    "success_improvement": 0.0,
                    "time_improvement": 55.04256301764959,
                    "node_improvement": 78.81754609027337,
                    "length_improvement": 12.647832978590698,
                    "smoothness_improvement": 1408.3731829238018,
                    "objective_score": 31.143334607068304
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m1",
          "algorithm_description": "A bidirectional RRT* planner with adaptive neighborhood scaling, combined probabilistic goal and ellipsoidal informed sampling, enhanced rewiring, and aggressive progressive shortcutting to improve planning efficiency, path smoothness, and length. The planner alternates expansions from start and goal trees, dynamically adapts rewiring radius based on node density, and balances exploration with exploitation by mixing goal bias with ellipsoidal sampling. It uses efficient nearest neighbor queries, performs rewiring immediately after node addition, and aggressively shortcuts paths every iteration after improvements, yielding faster convergence to high-quality, smooth paths.",
          "planning_mechanism": "The planner maintains two trees from start and goal, alternately extending them toward samples drawn probabilistically either from the goal (goal bias) or ellipsoidal informed region based on current best path cost. For each new node, it selects the best parent and rewires neighbors within an adaptive radius to minimize cost. Upon path improvements, it aggressively applies progressive shortcutting with more attempts to significantly smooth and shorten the path. The adaptive rewiring radius shrinks as the tree grows, balancing local optimization and global exploration for efficient convergence.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except ValueError:\n            pass\nclass Planner:\n    def __init__(self, max_iter=4000, step_size=6.0, gamma=40.0, goal_sample_rate=0.10,\n                 shortcut_attempts=80):\n        # max_iter: max iterations for planning\n        # step_size: maximum extension length per step\n        # gamma: rewiring radius scaling factor\n        # goal_sample_rate: probability of sampling directly at goal to bias search\n        # shortcut_attempts: max shortcut tries per path smoothing\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.gamma = gamma\n        self.goal_sample_rate = goal_sample_rate\n        self.shortcut_attempts = shortcut_attempts\n\n    def plan(self, map):\n        import random\n        import math\n\n        bounds = map.size\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        obstacles = map.obstacles\n        start_pos = map.start\n        goal_pos = map.goal\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        best_cost = float('inf')\n        solution_start = None\n        solution_goal = None\n        c_min = math.dist(start_pos, goal_pos)\n        vol_unit_ball = self._unit_ball_volume(dim)\n\n        def adaptive_radius(n_nodes):\n            if n_nodes <= 1:\n                return self.step_size * 3.0\n            rad = self.gamma * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            return min(rad, self.step_size * 40.0)\n\n        def sample():\n            # Combined goal bias and ellipsoidal informed sampling\n            if best_cost == float('inf') or best_cost <= c_min:\n                # No solution yet, uniform sampling with goal bias\n                if random.random() < self.goal_sample_rate:\n                    return goal_pos\n                else:\n                    return self._sample_free(bounds, obstacles, is_3d)\n            # After first solution, use mixture of goal bias and ellipsoidal informed sampling\n            if random.random() < self.goal_sample_rate:\n                return goal_pos\n            else:\n                return self._sample_ellipsoidal_informed(bounds, obstacles, is_3d,\n                                                         best_cost, c_min,\n                                                         start_pos, goal_pos, dim)\n\n        def extend_and_rewire(tree_from, tree_to, sample):\n            nearest = self._nearest(tree_from, sample)\n            new_pos = self._steer(nearest.position, sample, self.step_size)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                return None\n\n            new_node = Node(new_pos)\n            r = adaptive_radius(len(tree_from))\n            near_nodes = self._near(tree_from, new_pos, r)\n\n            min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n            min_parent = nearest\n            # Select best parent from near nodes with collision-free edges\n            for near in near_nodes:\n                tentative_cost = near.cost + math.dist(near.position, new_pos)\n                if tentative_cost + 1e-12 < min_cost:\n                    if not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d):\n                        min_cost = tentative_cost\n                        min_parent = near\n\n            new_node.parent = min_parent\n            new_node.cost = min_cost\n            min_parent.add_child(new_node)\n            tree_from.append(new_node)\n            nodes.append(new_node)\n            edges.append((min_parent, new_node))\n\n            # Rewire neighbors to new_node if it's cost efficient and collision-free\n            for near in near_nodes:\n                if near is min_parent:\n                    continue\n                new_cost = new_node.cost + math.dist(new_node.position, near.position)\n                if new_cost + 1e-12 < near.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                        if near.parent:\n                            try:\n                                edges.remove((near.parent, near))\n                            except ValueError:\n                                pass\n                            near.parent.remove_child(near)\n                        near.parent = new_node\n                        near.cost = new_cost\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n\n            # Try connecting new_node to the other tree\n            nearest_other = self._nearest(tree_to, new_node.position)\n            dist_connect = math.dist(new_node.position, nearest_other.position)\n            if dist_connect <= self.step_size:\n                if not self._is_edge_in_obstacle(new_node.position, nearest_other.position, obstacles, is_3d):\n                    total_cost = new_node.cost + dist_connect + nearest_other.cost\n                    return new_node, nearest_other, total_cost\n\n            return None\n\n        def aggressive_shortcut(path):\n            if len(path) < 3:\n                return path[:]\n            import random\n            new_path = path[:]\n            attempts = 0\n            max_attempts = self.shortcut_attempts\n            while attempts < max_attempts:\n                if len(new_path) < 3:\n                    break\n                i = random.randint(0, len(new_path) - 3)\n                j = random.randint(i + 2, len(new_path) - 1)\n                if not self._is_edge_in_obstacle(new_path[i], new_path[j], obstacles, is_3d):\n                    new_path = new_path[:i+1] + new_path[j:]\n                    # Reset attempts on success to allow more smoothing\n                    attempts = 0\n                else:\n                    attempts += 1\n            return new_path\n\n        for it in range(self.max_iter):\n            smp = sample()\n\n            # Alternate tree expansions to balance growth\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                res = extend_and_rewire(tree_a, tree_b, smp)\n                if res is not None:\n                    new_node, connect_node, total_cost = res\n                    if total_cost + 1e-12 < best_cost:\n                        best_cost = total_cost\n                        if tree_a is start_tree:\n                            solution_start = new_node\n                            solution_goal = connect_node\n                        else:\n                            solution_start = connect_node\n                            solution_goal = new_node\n\n                        raw_path = self._extract_path(solution_start, solution_goal)\n                        smoothed_path = aggressive_shortcut(raw_path)\n                        if smoothed_path and len(smoothed_path) >= 2:\n                            # Return improved solution immediately on improvement for speed\n                            return PlannerResult(True, smoothed_path, nodes, edges)\n\n        # No solution found\n        return PlannerResult(False, [], nodes, edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        import random\n        while True:\n            pt = tuple(random.uniform(0, bounds[i]) for i in range(len(bounds)))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def _sample_ellipsoidal_informed(self, bounds, obstacles, is_3d, best_cost, c_min,\n                                    start_pos, goal_pos, dim):\n        import random\n        import math\n\n        center = tuple((start_pos[i] + goal_pos[i]) * 0.5 for i in range(dim))\n        direction = [goal_pos[i] - start_pos[i] for i in range(dim)]\n        length = math.dist(start_pos, goal_pos)\n\n        if dim == 2:\n            if length < 1e-12:\n                R = [[1, 0],\n                     [0, 1]]\n            else:\n                a1 = [1, 0]\n                a2 = [direction[0] / length, direction[1] / length]\n                cos_t = a1[0]*a2[0] + a1[1]*a2[1]\n                sin_t = a1[0]*a2[1] - a1[1]*a2[0]\n                R = [[cos_t, -sin_t],\n                     [sin_t, cos_t]]\n        else:\n            from math import sqrt\n            if length < 1e-12:\n                R = [[1,0,0],[0,1,0],[0,0,1]]\n            else:\n                a1 = [1,0,0]\n                a2 = [d/length for d in direction]\n                v = [a1[1]*a2[2]-a1[2]*a2[1], a1[2]*a2[0]-a1[0]*a2[2], a1[0]*a2[1]-a1[1]*a2[0]]\n                s = sqrt(sum(vi*vi for vi in v))\n                c = sum(a1[i]*a2[i] for i in range(3))\n                if s < 1e-12:\n                    R = [[1,0,0],[0,1,0],[0,0,1]]\n                else:\n                    vx = [[0, -v[2], v[1]], [v[2], 0, -v[0]], [-v[1], v[0], 0]]\n                    I = [[1 if i==j else 0 for j in range(3)] for i in range(3)]\n                    vx2 = [[sum(vx[i][k]*vx[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n                    R = [[I[i][j]+vx[i][j]+vx2[i][j]*((1-c)/(s*s)) for j in range(3)] for i in range(3)]\n\n        a1_val = best_cost * 0.5\n        a_other = math.sqrt(max(best_cost*best_cost - c_min*c_min, 0)) * 0.5\n\n        while True:\n            if dim == 2:\n                r = random.uniform(0,1) ** 0.5\n                theta = random.uniform(0, 2*math.pi)\n                x_ball = [r*math.cos(theta), r*math.sin(theta)]\n                L = [[a1_val, 0],\n                     [0, a_other]]\n                x_scaled = [L[0][0]*x_ball[0] + L[0][1]*x_ball[1],\n                            L[1][0]*x_ball[0] + L[1][1]*x_ball[1]]\n                pt = (\n                    center[0] + R[0][0]*x_scaled[0] + R[0][1]*x_scaled[1],\n                    center[1] + R[1][0]*x_scaled[0] + R[1][1]*x_scaled[1]\n                )\n            else:\n                while True:\n                    x_ball = [random.uniform(-1,1) for _ in range(3)]\n                    if sum(xi*xi for xi in x_ball) <= 1:\n                        break\n                L = [[a1_val, 0, 0],\n                     [0, a_other, 0],\n                     [0, 0, a_other]]\n                x_scaled = [L[0][0]*x_ball[0], L[1][1]*x_ball[1], L[2][2]*x_ball[2]]\n                pt = tuple(center[i] + sum(R[i][j]*x_scaled[j] for j in range(dim)) for i in range(dim))\n\n            if any(pt[d] < 0 or pt[d] > bounds[d] for d in range(dim)):\n                continue\n            if self._is_in_obstacle(pt, obstacles, is_3d):\n                continue\n            return pt\n\n    def _nearest(self, tree, point):\n        best_node = None\n        best_dist = float('inf')\n        for node in tree:\n            d = 0.0\n            for i in range(len(point)):\n                diff = node.position[i] - point[i]\n                d += diff*diff\n            if d < best_dist:\n                best_dist = d\n                best_node = node\n        return best_node\n\n    def _near(self, tree, point, radius):\n        r_sq = radius*radius\n        near_nodes = []\n        for n in tree:\n            d = 0.0\n            for i in range(len(point)):\n                diff = n.position[i] - point[i]\n                d += diff*diff\n            if d <= r_sq:\n                near_nodes.append(n)\n        return near_nodes\n\n    def _steer(self, from_pos, to_pos, step_size):\n        import math\n        dist = 0.0\n        for i in range(len(from_pos)):\n            diff = to_pos[i] - from_pos[i]\n            dist += diff*diff\n        dist = dist ** 0.5\n        if dist <= step_size:\n            return to_pos\n        ratio = step_size / dist\n        return tuple(from_pos[i] + ratio*(to_pos[i] - from_pos[i]) for i in range(len(from_pos)))\n\n    def _extract_path(self, node_start, node_goal):\n        path_start = []\n        n = node_start\n        while n is not None:\n            path_start.append(n.position)\n            n = n.parent\n        path_goal = []\n        n = node_goal\n        while n is not None:\n            path_goal.append(n.position)\n            n = n.parent\n        return list(reversed(path_start)) + path_goal\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x,y,z,w,h,d = obs\n                px,py,pz = pos\n                if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                    return True\n            else:\n                x,y,w,h = obs\n                px,py = pos\n                if x <= px <= x+w and y <= py <= y+h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        dist = 0.0\n        for i in range(len(from_pos)):\n            diff = to_pos[i] - from_pos[i]\n            dist += diff*diff\n        dist = dist ** 0.5\n        steps = max(1, int(dist / resolution))\n        for step in range(steps+1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (step / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _unit_ball_volume(self, dim):\n        import math\n        if dim == 2:\n            return math.pi\n        if dim == 3:\n            return 4.0/3.0 * math.pi\n        from math import gamma\n        return (math.pi ** (dim/2)) / gamma(dim/2 + 1)",
          "objective": -32.52068,
          "time_improvement": 47.0,
          "length_improvement": 16.0,
          "smoothness_improvement": 1734.0,
          "node_improvement": 74.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.020076465606689454,
                    "num_nodes_avg": 116.8,
                    "path_length_avg": 162.49456117438694,
                    "smoothness_avg": 0.04179993549748345,
                    "success_improvement": 0.0,
                    "time_improvement": 22.15651562983882,
                    "node_improvement": 70.58675396625536,
                    "length_improvement": 10.93415612922186,
                    "smoothness_improvement": 554.2597605483732,
                    "objective_score": 15.978747169226628
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.034181642532348636,
                    "num_nodes_avg": 268.0,
                    "path_length_avg": 238.180902638735,
                    "smoothness_avg": 0.12075947586833821,
                    "success_improvement": 0.0,
                    "time_improvement": 79.35588159570369,
                    "node_improvement": 81.99287778001747,
                    "length_improvement": 20.48835904203003,
                    "smoothness_improvement": 3007.2282936270713,
                    "objective_score": 51.13592137206448
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.03004302978515625,
                    "num_nodes_avg": 247.2,
                    "path_length_avg": 125.47417143071527,
                    "smoothness_avg": 0.1369214674928818,
                    "success_improvement": 0.0,
                    "time_improvement": 40.798622122433216,
                    "node_improvement": 68.56961220597584,
                    "length_improvement": 16.666029773699346,
                    "smoothness_improvement": 1641.6309600180152,
                    "objective_score": 30.447359301039647
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "time_expert",
          "algorithm_description": "Improved Bidirectional RRT* with Adaptive Radius and Incremental Local Smoothing Using Shortcutting for Fast, High-Quality, and Robust Path Planning",
          "planning_mechanism": "This planner enhances bidirectional RRT* by replacing expensive global B-spline smoothing with fast adaptive incremental smoothing via path shortcutting and partial rewiring focused on straight-line shortcuts, drastically reducing planning time while improving path length and smoothness. It uses informed sampling with goal bias, adaptive neighborhood radius for rewiring, efficient collision checks, and early termination upon connection. The local smoothing iteratively shortcuts path segments, checking collisions to maintain feasibility, thus providing smooth, short, and feasible paths efficiently.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def path_from_root(self):\n        node, path = self, []\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=3500, step_size=7.0, base_radius=20.0, goal_sample_rate=0.15,\n                 shortcut_attempts=40, shortcut_min_segment=2):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.base_radius = base_radius\n        self.goal_sample_rate = goal_sample_rate\n        self.shortcut_attempts = shortcut_attempts  # Number of incremental shortcut attempts on path\n        self.shortcut_min_segment = shortcut_min_segment  # Minimum segment length for shortcut trial\n\n    def plan(self, map):\n        import math\n        import random\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(fr, to):\n            d = dist(fr, to)\n            if d <= self.step_size:\n                return to\n            ratio = self.step_size / d\n            return tuple(fr[i] + (to[i] - fr[i]) * ratio for i in range(dim))\n\n        def is_in_obstacle(p):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d_ = obs\n                    px, py, pz = p\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d_:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    px, py = p\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(fr, to, resolution=1.0):\n            d = dist(fr, to)\n            steps = max(1, int(d / resolution))\n            for i in range(steps + 1):\n                interp = tuple(fr[j] + (to[j] - fr[j]) * i / steps for j in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: dist(node.position, point))\n\n        def near_nodes(tree, point, radius):\n            return [node for node in tree if dist(node.position, point) <= radius]\n\n        def rewire(tree, new_node, near_list):\n            nonlocal edges\n            for near in near_list:\n                if near == new_node.parent:\n                    continue\n                c = new_node.cost + dist(new_node.position, near.position)\n                if c + 1e-10 < near.cost and not is_edge_in_obstacle(new_node.position, near.position):\n                    old_parent = near.parent\n                    if old_parent:\n                        try:\n                            edges.remove((old_parent, near))\n                        except ValueError:\n                            pass\n                        old_parent.remove_child(near)\n                    near.parent = new_node\n                    near.cost = c\n                    new_node.add_child(near)\n                    edges.append((new_node, near))\n\n        def extract_path(node_start, node_goal):\n            path_start = node_start.path_from_root()\n            path_goal = node_goal.path_from_root()[::-1]\n            if len(path_start) > 0 and len(path_goal) > 0 and path_start[-1] == path_goal[0]:\n                path_goal = path_goal[1:]\n            return path_start + path_goal\n\n        def adaptive_radius(tree_size):\n            gamma = self.base_radius\n            n = max(tree_size, 1)\n            return max(gamma * (math.log(n) / n) ** (1.0 / dim), self.step_size * 1.5)\n\n        def informed_sample(c_best, c_min, start, goal):\n            if c_best == float('inf'):\n                return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n            c = c_best\n            center = tuple((start[i] + goal[i]) / 2 for i in range(dim))\n            a1 = tuple((goal[i] - start[i]) / c_min for i in range(dim))\n            if dim == 2:\n                theta = math.atan2(a1[1], a1[0])\n                r = [[math.cos(theta), -math.sin(theta)],\n                     [math.sin(theta), math.cos(theta)]]\n                while True:\n                    x, y = random.uniform(-1, 1), random.uniform(-1, 1)\n                    if x * x + y * y > 1:\n                        continue\n                    rx = c / 2\n                    ry = math.sqrt(max(c * c - c_min * c_min, 0)) / 2\n                    sample_ellipse = (x * rx, y * ry)\n                    px = r[0][0] * sample_ellipse[0] + r[0][1] * sample_ellipse[1] + center[0]\n                    py = r[1][0] * sample_ellipse[0] + r[1][1] * sample_ellipse[1] + center[1]\n                    if 0 <= px <= bounds[0] and 0 <= py <= bounds[1]:\n                        return (px, py)\n            else:\n                return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n\n        # Incremental shortcut smoothing for path improvement\n        def incremental_shortcut(path):\n            if len(path) < 3:\n                return path[:]\n            path_pts = list(path)\n            for _ in range(self.shortcut_attempts):\n                if len(path_pts) < 3:\n                    break\n                i = random.randint(0, len(path_pts) - self.shortcut_min_segment - 1)\n                j = random.randint(i + self.shortcut_min_segment, len(path_pts) - 1)\n                p_i = path_pts[i]\n                p_j = path_pts[j]\n                if not is_edge_in_obstacle(p_i, p_j):\n                    # Shortcut feasible, remove intermediate points\n                    path_pts = path_pts[:i + 1] + path_pts[j:]\n            return path_pts\n\n        best_cost = float('inf')\n        connection_nodes = (None, None)\n        success = False\n\n        for iteration in range(self.max_iter):\n            if success:\n                break\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                if success:\n                    break\n\n                sample_prob = random.random()\n                if sample_prob < self.goal_sample_rate:\n                    q_rand = goal_pos\n                else:\n                    q_rand = informed_sample(best_cost, dist(start_pos, goal_pos), start_pos, goal_pos)\n\n                nearest_node = nearest(tree_a, q_rand)\n                q_new_pos = steer(nearest_node.position, q_rand)\n\n                if is_in_obstacle(q_new_pos) or is_edge_in_obstacle(nearest_node.position, q_new_pos):\n                    continue\n\n                radius = adaptive_radius(len(tree_a))\n                near_nodes_a = near_nodes(tree_a, q_new_pos, radius)\n\n                # Parent selection minimizing cost + feasibility\n                min_cost = nearest_node.cost + dist(nearest_node.position, q_new_pos)\n                min_parent = nearest_node\n                for near_n in near_nodes_a:\n                    c = near_n.cost + dist(near_n.position, q_new_pos)\n                    if c + 1e-10 < min_cost and not is_edge_in_obstacle(near_n.position, q_new_pos):\n                        min_cost = c\n                        min_parent = near_n\n\n                q_new = Node(q_new_pos, parent=min_parent, cost=min_cost)\n                min_parent.add_child(q_new)\n                tree_a.append(q_new)\n                nodes.append(q_new)\n                edges.append((min_parent, q_new))\n\n                rewire(tree_a, q_new, near_nodes_a)\n\n                # Try connect opposite tree\n                nearest_other = nearest(tree_b, q_new.position)\n                dist_connect = dist(q_new.position, nearest_other.position)\n                radius_connect = max(self.step_size * 1.5, adaptive_radius(len(tree_b)))\n\n                if dist_connect <= radius_connect and not is_edge_in_obstacle(q_new.position, nearest_other.position):\n                    if tree_a is start_tree:\n                        node_start, node_goal = q_new, nearest_other\n                    else:\n                        node_start, node_goal = nearest_other, q_new\n\n                    current_cost = node_start.cost + dist(node_start.position, node_goal.position) + node_goal.cost\n                    if current_cost < best_cost:\n                        best_cost = current_cost\n                        connection_nodes = (node_start, node_goal)\n                        success = True\n            # Early stop if connected\n            if success:\n                break\n\n        raw_path = []\n        if success:\n            raw_path = extract_path(connection_nodes[0], connection_nodes[1])\n        else:\n            return PlannerResult(False, [], nodes, edges)\n\n        # Incremental shortcut smoothing with collision check, lightweight and fast\n        smooth_path = incremental_shortcut(raw_path)\n\n        return PlannerResult(True, smooth_path, nodes, edges)",
          "objective": -32.3085,
          "time_improvement": 66.0,
          "length_improvement": 12.0,
          "smoothness_improvement": 1013.0,
          "node_improvement": 73.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.013331365585327149,
                    "num_nodes_avg": 130.7,
                    "path_length_avg": 179.30420886519545,
                    "smoothness_avg": 0.027773013783354228,
                    "success_improvement": 0.0,
                    "time_improvement": 48.30962934887612,
                    "node_improvement": 67.08637622765046,
                    "length_improvement": 1.7205218639765212,
                    "smoothness_improvement": 334.70797577422024,
                    "objective_score": 17.19874180191985
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.01947922706604004,
                    "num_nodes_avg": 253.2,
                    "path_length_avg": 241.43064090254697,
                    "smoothness_avg": 0.0689551247796437,
                    "success_improvement": 0.0,
                    "time_improvement": 88.23545505178878,
                    "node_improvement": 82.98730094738963,
                    "length_improvement": 19.403502871040057,
                    "smoothness_improvement": 1674.2650269490814,
                    "objective_score": 46.48406337290607
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.019611549377441407,
                    "num_nodes_avg": 254.3,
                    "path_length_avg": 126.26508083854677,
                    "smoothness_avg": 0.08886728614455755,
                    "success_improvement": 0.0,
                    "time_improvement": 61.354405538947546,
                    "node_improvement": 67.66687857596949,
                    "length_improvement": 16.140745404076515,
                    "smoothness_improvement": 1030.3853202580356,
                    "objective_score": 33.24269550542035
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "cross_over",
          "algorithm_description": "\"Enhanced Bidirectional Informed RRT* with Progressive Informed Sampling, Dynamic Radius, Efficient Rewiring, and Iterative Shortcutting for Minimal Path Length, Reduced Planning Time, and Superior Path Smoothness.\"",
          "planning_mechanism": "The planner grows two trees bidirectionally from start and goal using progressive informed sampling focused on an adaptive ellipsoidal region shrinking with the best path cost, ensuring sample efficiency and faster convergence. It employs a dynamic rewiring radius proportional to tree size for efficient local optimization. Nodes and edges are added only after strict collision-free checks. The planner attempts early tree connection with collision-checked edges. Upon success, it performs iterative shortcutting that aggressively attempts to remove unnecessary detours, significantly improving path smoothness and shortening path length. This combination reduces planning time, improves success rate, and produces smooth, short, feasible trajectories.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        node = self\n        path = []\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=4500, step_size=6.0, base_radius=15.0, goal_sample_rate=0.1, shortcut_trials=250):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.base_radius = base_radius\n        self.goal_sample_rate = goal_sample_rate\n        self.shortcut_trials = shortcut_trials\n\n    def plan(self, map):\n        import math\n        import random\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        # Initialize trees\n        tree_start = [Node(start_pos, cost=0.0)]\n        tree_goal = [Node(goal_pos, cost=0.0)]\n        nodes = tree_start + tree_goal\n        edges = []\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(fr, to):\n            d = dist(fr, to)\n            if d <= self.step_size:\n                return to\n            ratio = self.step_size / d\n            return tuple(fr[i] + (to[i] - fr[i]) * ratio for i in range(dim))\n\n        def is_in_obstacle(p):\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d_ = obs\n                    px,py,pz = p\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d_:\n                        return True\n                else:\n                    x,y,w,h = obs\n                    px,py = p\n                    if x <= px <= x+w and y <= py <= y+h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(fr, to, resolution=1.0):\n            d = dist(fr, to)\n            steps = max(1, int(d / resolution))\n            for i in range(steps + 1):\n                interp = tuple(fr[j] + (to[j] - fr[j]) * i / steps for j in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def nearest(tree, pt):\n            return min(tree, key=lambda node: dist(node.position, pt))\n\n        def near_nodes(tree, pt, radius):\n            r_sq = radius * radius\n            result = []\n            for node in tree:\n                dx = 0.0\n                for i in range(dim):\n                    d = pt[i]-node.position[i]\n                    dx += d*d\n                    if dx > r_sq:\n                        break\n                else:\n                    result.append(node)\n            return result\n\n        def adaptive_radius(size):\n            n = max(size, 1)\n            gamma = self.base_radius\n            return max(gamma * (math.log(n)/n)**(1.0/dim), self.step_size*1.5)\n\n        # Progressive informed sampling: ellipsoid shrinks with best_cost, sampling concentrates near current best path\n        def informed_sample(c_best, c_min, start, goal):\n            if c_best == float('inf'):\n                return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n            center = tuple((start[i] + goal[i])/2 for i in range(dim))\n            a1 = tuple((goal[i] - start[i])/c_min for i in range(dim))\n            if dim == 2:\n                # Rotation matrix\n                theta = math.atan2(a1[1], a1[0])\n                cos_t = math.cos(theta)\n                sin_t = math.sin(theta)\n                rx = c_best / 2.0\n                ry = math.sqrt(max(c_best*c_best - c_min*c_min, 0.0)) / 2.0\n                while True:\n                    x, y = random.uniform(-1,1), random.uniform(-1,1)\n                    if x*x + y*y > 1:\n                        continue\n                    px = x * rx\n                    py = y * ry\n                    sample_x = cos_t * px - sin_t * py + center[0]\n                    sample_y = sin_t * px + cos_t * py + center[1]\n                    if 0 <= sample_x <= bounds[0] and 0 <= sample_y <= bounds[1]:\n                        return (sample_x, sample_y)\n            else:\n                # For 3D or higher, fallback uniform sampling\n                return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n\n        def rewire(tree, new_node, near_nodes_list):\n            for near in near_nodes_list:\n                if near == new_node.parent:\n                    continue\n                c = new_node.cost + dist(new_node.position, near.position)\n                if c + 1e-12 < near.cost and not is_edge_in_obstacle(new_node.position, near.position):\n                    old_parent = near.parent\n                    if old_parent:\n                        try:\n                            edges.remove((old_parent, near))\n                        except ValueError:\n                            pass\n                        if near in old_parent.children:\n                            old_parent.children.remove(near)\n                    near.parent = new_node\n                    near.cost = c\n                    new_node.children.append(near)\n                    edges.append((new_node, near))\n\n        def try_connect(node_a, tree_b):\n            nearest_b = nearest(tree_b, node_a.position)\n            dist_ab = dist(node_a.position, nearest_b.position)\n            radius_connect = max(self.step_size * 1.5, adaptive_radius(len(tree_b)))\n            if dist_ab <= radius_connect and not is_edge_in_obstacle(node_a.position, nearest_b.position):\n                return node_a, nearest_b\n            return None\n\n        def extract_path(node_start, node_goal):\n            path_start = node_start.path_from_root()\n            path_goal = node_goal.path_from_root()\n            # goal tree path reversed so connects properly\n            path_goal.reverse()\n            # Remove duplicate connection point if exists\n            if path_start[-1] == path_goal[0]:\n                path_goal = path_goal[1:]\n            return path_start + path_goal\n\n        def path_shortcut(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.shortcut_trials):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if not is_edge_in_obstacle(path[i], path[j]):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        best_cost = float('inf')\n        connection_nodes = (None, None)\n        success = False\n        c_min = dist(start_pos, goal_pos)\n\n        for iteration in range(self.max_iter):\n            if success:\n                break\n            for tree_a, tree_b in [(tree_start, tree_goal), (tree_goal, tree_start)]:\n                # Sampling with goal bias\n                if random.random() < self.goal_sample_rate:\n                    sample_pt = goal_pos\n                else:\n                    sample_pt = informed_sample(best_cost, c_min, start_pos, goal_pos)\n\n                nearest_node = nearest(tree_a, sample_pt)\n                new_pos = steer(nearest_node.position, sample_pt)\n                if is_in_obstacle(new_pos) or is_edge_in_obstacle(nearest_node.position, new_pos):\n                    continue\n\n                radius = adaptive_radius(len(tree_a))\n                near_nodes_list = near_nodes(tree_a, new_pos, radius)\n                # Choose parent minimizing cost\n                min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n                min_parent = nearest_node\n                for near_node in near_nodes_list:\n                    c = near_node.cost + dist(near_node.position, new_pos)\n                    if c + 1e-12 < min_cost and not is_edge_in_obstacle(near_node.position, new_pos):\n                        min_cost = c\n                        min_parent = near_node\n\n                q_new = Node(new_pos, parent=min_parent, cost=min_cost)\n                min_parent.children.append(q_new)\n                tree_a.append(q_new)\n                nodes.append(q_new)\n                edges.append((min_parent, q_new))\n\n                rewire(tree_a, q_new, near_nodes_list)\n\n                connect = try_connect(q_new, tree_b)\n                if connect:\n                    node_start, node_goal = connect\n                    current_cost = node_start.cost + dist(node_start.position, node_goal.position) + node_goal.cost\n                    if current_cost < best_cost:\n                        best_cost = current_cost\n                        connection_nodes = (node_start, node_goal)\n                        success = True\n                        break\n\n        if not success:\n            return PlannerResult(False, [], nodes, edges)\n\n        raw_path = extract_path(connection_nodes[0], connection_nodes[1])\n        smooth_path = path_shortcut(raw_path)\n        return PlannerResult(True, smooth_path, nodes, edges)",
          "objective": -32.28663,
          "time_improvement": 54.0,
          "length_improvement": 15.0,
          "smoothness_improvement": 1483.0,
          "node_improvement": 74.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.016875481605529784,
                    "num_nodes_avg": 100.1,
                    "path_length_avg": 168.80915093110676,
                    "smoothness_avg": 0.04567675457222376,
                    "success_improvement": 0.0,
                    "time_improvement": 34.56785101849327,
                    "node_improvement": 74.79224376731301,
                    "length_improvement": 7.473029422485834,
                    "smoothness_improvement": 614.940397715425,
                    "objective_score": 17.928874947616606
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.026306653022766115,
                    "num_nodes_avg": 252.6,
                    "path_length_avg": 238.74711076595855,
                    "smoothness_avg": 0.10453526714919008,
                    "success_improvement": 0.0,
                    "time_improvement": 84.11200809590211,
                    "node_improvement": 83.02761540012095,
                    "length_improvement": 20.299342471765502,
                    "smoothness_improvement": 2589.7677174581936,
                    "objective_score": 50.36204649912091
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.029383349418640136,
                    "num_nodes_avg": 277.6,
                    "path_length_avg": 126.18793436429056,
                    "smoothness_avg": 0.10572730347033898,
                    "success_improvement": 0.0,
                    "time_improvement": 42.09855714682374,
                    "node_improvement": 64.70438652256834,
                    "length_improvement": 16.191982418957153,
                    "smoothness_improvement": 1244.8434961649484,
                    "objective_score": 28.568974076246153
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "A simplified bidirectional RRT* planner with adaptive radius rewiring, informed sampling after first solution, frequent incremental shortcutting to improve path smoothness and length, early termination on solution stagnation, and efficient collision checks. It alternates growing start and goal trees, connects and rewires nodes within adaptive radius based on node count, and progressively shortcuts the best path during planning for better convergence in less time.",
          "planning_mechanism": "The Planner grows two trees from start and goal, samples points uniformly or within an ellipsoidal informed subset after a solution is found, extends and rewires nodes within an adaptive radius logarithmically decreasing with node count, attempts connections between trees to form a solution, and applies incremental shortcutting after solution improvements and periodically to smooth and shorten paths, terminating early if no improvements occur for a defined interval.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n    def add_child(self, child):\n        self.children.append(child)\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except ValueError:\n            pass\nclass Planner:\n    def __init__(self, max_iter=3000, step_size=6.0, gamma_rrt_star=40.0,\n                 shortcut_interval=20, max_shortcut_attempts=40, goal_sample_rate=0.1):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.gamma_rrt_star = gamma_rrt_star\n        self.shortcut_interval = shortcut_interval\n        self.max_shortcut_attempts = max_shortcut_attempts\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map):\n        import random\n        import math\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = (len(bounds) == 3)\n        dim = len(bounds)\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        all_nodes = start_tree + goal_tree\n        edges = []\n\n        best_cost = float('inf')\n        solution_start = None\n        solution_goal = None\n        c_min = math.dist(start_pos, goal_pos)\n\n        def in_obstacle(pt):\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d = obs\n                    px,py,pz = pt\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                        return True\n                else:\n                    x,y,w,h = obs\n                    px,py = pt\n                    if x <= px <= x+w and y <= py <= y+h:\n                        return True\n            return False\n\n        def edge_in_obstacle(p1, p2, resolution=1.0):\n            dist = 0.0\n            for i in range(dim):\n                dist += (p2[i]-p1[i])**2\n            dist = dist**0.5\n            steps = max(1, int(dist / resolution))\n            for i in range(steps+1):\n                t = i / steps\n                interp = tuple(p1[d] + t*(p2[d]-p1[d]) for d in range(dim))\n                if in_obstacle(interp):\n                    return True\n            return False\n\n        def sample_uniform():\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not in_obstacle(pt):\n                    return pt\n\n        def sample_goal():\n            if not in_obstacle(goal_pos):\n                return goal_pos\n            return sample_uniform()\n\n        def sample_informed():\n            if best_cost == float('inf') or best_cost <= c_min:\n                return sample_uniform()\n            center = tuple((start_pos[i]+goal_pos[i])/2 for i in range(dim))\n            dir_vec = [goal_pos[i]-start_pos[i] for i in range(dim)]\n            length = math.dist(start_pos, goal_pos)\n            if length < 1e-10:\n                return sample_uniform()\n            if dim == 2:\n                cos_theta = dir_vec[0]/length\n                sin_theta = dir_vec[1]/length\n                R = [[cos_theta, -sin_theta],[sin_theta, cos_theta]]\n                a1 = best_cost/2.0\n                a2 = math.sqrt(best_cost**2 - c_min**2)/2.0 if best_cost**2 > c_min**2 else 0.0\n                while True:\n                    r = random.uniform(0,1)**0.5\n                    theta = random.uniform(0, 2*math.pi)\n                    x_ball = [r*math.cos(theta), r*math.sin(theta)]\n                    x_scaled = [a1*x_ball[0], a2*x_ball[1]]\n                    pt = (center[0]+R[0][0]*x_scaled[0]+R[0][1]*x_scaled[1],\n                          center[1]+R[1][0]*x_scaled[0]+R[1][1]*x_scaled[1])\n                    if any(pt[d]<0 or pt[d]>bounds[d] for d in range(dim)): continue\n                    if in_obstacle(pt): continue\n                    return pt\n            else:\n                # 3D sampling inside prolate hyperspheroid\n                from math import sqrt\n                a1 = best_cost/2.0\n                a2 = math.sqrt(best_cost**2 - c_min**2)/2.0 if best_cost**2 > c_min**2 else 0.0\n                while True:\n                    x_ball = [random.uniform(-1,1) for _ in range(3)]\n                    r_sq = sum(x*x for x in x_ball)\n                    if r_sq > 1 or r_sq==0: continue\n                    norm = r_sq**0.5\n                    x_ball = [x/norm for x in x_ball]\n                    L = [a1, a2, a2]\n                    x_scaled = [L[i]*x_ball[i] for i in range(3)]\n                    # Rotation matrix mapping x-axis to dir_vec unit vector\n                    e1 = [1,0,0]\n                    e2 = [dir_vec[i]/length for i in range(3)]\n                    v = [e1[1]*e2[2]-e1[2]*e2[1], e1[2]*e2[0]-e1[0]*e2[2], e1[0]*e2[1]-e1[1]*e2[0]]\n                    s = sqrt(sum(x*x for x in v))\n                    c = sum(e1[i]*e2[i] for i in range(3))\n                    if s < 1e-10:\n                        R = [[1,0,0],[0,1,0],[0,0,1]]\n                    else:\n                        vx = [[0,-v[2],v[1]],[v[2],0,-v[0]],[-v[1],v[0],0]]\n                        I = [[1 if i==j else 0 for j in range(3)] for i in range(3)]\n                        vx2 = [[sum(vx[i][k]*vx[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n                        R = [[I[i][j]+vx[i][j]+vx2[i][j]*((1 - c)/(s*s)) for j in range(3)] for i in range(3)]\n                    pt = tuple(center[i]+sum(R[i][j]*x_scaled[j] for j in range(3)) for i in range(3))\n                    if any(pt[d]<0 or pt[d]>bounds[d] for d in range(dim)): continue\n                    if in_obstacle(pt): continue\n                    return pt\n\n        def nearest(tree, pt):\n            best_node = None\n            best_dist_sq = float('inf')\n            for n in tree:\n                d = 0.0\n                for i in range(dim):\n                    diff = n.position[i]-pt[i]\n                    d += diff*diff\n                if d < best_dist_sq:\n                    best_dist_sq = d\n                    best_node = n\n            return best_node\n\n        def near(tree, pt, radius):\n            r_sq = radius*radius\n            near_nodes = []\n            for n in tree:\n                d = 0.0\n                for i in range(dim):\n                    diff = n.position[i]-pt[i]\n                    d += diff*diff\n                if d <= r_sq:\n                    near_nodes.append(n)\n            return near_nodes\n\n        def steer(from_pt, to_pt, max_dist):\n            dist = 0.0\n            diffs = []\n            for i in range(dim):\n                diff = to_pt[i]-from_pt[i]\n                diffs.append(diff)\n                dist += diff*diff\n            dist = dist**0.5\n            if dist <= max_dist:\n                return to_pt\n            ratio = max_dist / dist\n            new_pt = tuple(from_pt[i] + ratio*diffs[i] for i in range(dim))\n            return new_pt\n\n        def near_radius(n_nodes):\n            if n_nodes <= 1:\n                return self.step_size*8.0\n            return min(self.step_size*30, self.gamma_rrt_star*(math.log(n_nodes)/n_nodes)**(1.0/dim))\n\n        def connect(tree_from, tree_to, sample):\n            nearest_node = nearest(tree_from, sample)\n            new_pos = steer(nearest_node.position, sample, self.step_size)\n            if in_obstacle(new_pos):\n                return None\n            if edge_in_obstacle(nearest_node.position, new_pos):\n                return None\n\n            radius = near_radius(len(tree_from))\n            neighbors = near(tree_from, new_pos, radius)\n\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            min_parent = nearest_node\n            for n in neighbors:\n                cost_try = n.cost + math.dist(n.position, new_pos)\n                if cost_try < min_cost:\n                    if not edge_in_obstacle(n.position, new_pos):\n                        min_cost = cost_try\n                        min_parent = n\n\n            new_node = Node(new_pos, min_parent, min_cost)\n            min_parent.add_child(new_node)\n            tree_from.append(new_node)\n            all_nodes.append(new_node)\n            edges.append((min_parent, new_node))\n\n            for n in neighbors:\n                if n is min_parent:\n                    continue\n                cost_through_new = new_node.cost + math.dist(new_node.position, n.position)\n                if cost_through_new + 1e-8 < n.cost:\n                    if not edge_in_obstacle(new_node.position, n.position):\n                        if n.parent:\n                            try:\n                                edges.remove((n.parent, n))\n                            except ValueError:\n                                pass\n                            n.parent.remove_child(n)\n                        n.parent = new_node\n                        n.cost = cost_through_new\n                        new_node.add_child(n)\n                        edges.append((new_node, n))\n\n            nearest_other = nearest(tree_to, new_node.position)\n            dist_to_other = math.dist(new_node.position, nearest_other.position)\n            if dist_to_other <= self.step_size:\n                if not edge_in_obstacle(new_node.position, nearest_other.position):\n                    total_cost = new_node.cost + dist_to_other + nearest_other.cost\n                    return new_node, nearest_other, total_cost\n            return None\n\n        def extract_path(node_start, node_goal):\n            path_start = []\n            n = node_start\n            while n:\n                path_start.append(n.position)\n                n = n.parent\n            path_goal = []\n            n = node_goal\n            while n:\n                path_goal.append(n.position)\n                n = n.parent\n            return list(reversed(path_start)) + path_goal\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path[:]\n            new_path = path[:]\n            attempts = 0\n            while attempts < self.max_shortcut_attempts:\n                if len(new_path) < 3:\n                    break\n                i = random.randint(0, len(new_path)-3)\n                j = random.randint(i+2, len(new_path)-1)\n                if not edge_in_obstacle(new_path[i], new_path[j]):\n                    new_path = new_path[:i+1] + new_path[j:]\n                    attempts = 0\n                else:\n                    attempts += 1\n            return new_path\n\n        last_improve_iter = 0\n        no_improve_limit = 100\n\n        for iter in range(self.max_iter):\n            if best_cost < float('inf') and random.random() < self.goal_sample_rate:\n                sample = sample_goal()\n            elif best_cost < float('inf'):\n                sample = sample_informed()\n            else:\n                sample = sample_uniform()\n\n            for tree_from, tree_to in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                res = connect(tree_from, tree_to, sample)\n                if res:\n                    n_start, n_goal, cost = res\n                    if cost + 1e-8 < best_cost:\n                        best_cost = cost\n                        last_improve_iter = iter\n                        if tree_from is start_tree:\n                            solution_start, solution_goal = n_start, n_goal\n                        else:\n                            solution_start, solution_goal = n_goal, n_start\n                        path = extract_path(solution_start, solution_goal)\n                        for _ in range(2):\n                            path = shortcut_path(path)\n                        # Replace last path with shortcut improved\n                        if len(path) < len(extract_path(solution_start, solution_goal)):\n                            # best path shortened\n                            continue\n\n            if best_cost < float('inf') and (iter - last_improve_iter) > no_improve_limit:\n                break\n\n            if best_cost < float('inf') and iter % self.shortcut_interval == 0 and solution_start and solution_goal:\n                raw_path = extract_path(solution_start, solution_goal)\n                improved_path = shortcut_path(raw_path)\n                if improved_path and len(improved_path) >= 2:\n                    return PlannerResult(True, improved_path, all_nodes, edges)\n\n        if best_cost < float('inf') and solution_start and solution_goal:\n            raw_path = extract_path(solution_start, solution_goal)\n            final_path = shortcut_path(raw_path)\n            return PlannerResult(True, final_path, all_nodes, edges)\n\n        return PlannerResult(False, [], all_nodes, edges)",
          "objective": -32.21382,
          "time_improvement": 53.0,
          "length_improvement": 14.0,
          "smoothness_improvement": 1551.0,
          "node_improvement": 78.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.02305736541748047,
                    "num_nodes_avg": 112.2,
                    "path_length_avg": 168.73944907303084,
                    "smoothness_avg": 0.04309848636832513,
                    "success_improvement": 0.0,
                    "time_improvement": 10.598523681644005,
                    "node_improvement": 71.74515235457064,
                    "length_improvement": 7.511234115393865,
                    "smoothness_improvement": 574.5849015253947,
                    "objective_score": 10.559222081356495
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.02576143741607666,
                    "num_nodes_avg": 208.1,
                    "path_length_avg": 237.2903072590682,
                    "smoothness_avg": 0.1076212802971938,
                    "success_improvement": 0.0,
                    "time_improvement": 84.44129290220465,
                    "node_improvement": 86.01760397769269,
                    "length_improvement": 20.785665414129483,
                    "smoothness_improvement": 2669.1730585217547,
                    "objective_score": 51.149652411747866
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.018548035621643068,
                    "num_nodes_avg": 182.6,
                    "path_length_avg": 128.3642742559325,
                    "smoothness_avg": 0.11870521723960548,
                    "success_improvement": 0.0,
                    "time_improvement": 63.45011559832764,
                    "node_improvement": 76.78321678321677,
                    "length_improvement": 14.746561089097684,
                    "smoothness_improvement": 1409.9216013800688,
                    "objective_score": 34.93257933985725
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e2",
          "algorithm_description": "A hybrid bidirectional Anytime Informed RRT* planner integrating adaptive density-based rewiring radius, ellipsoidal informed sampling, incremental path shortcutting, and optimized data structures for enhanced planning efficiency, robustness, and path quality. It grows trees from start and goal, alternates expansions, samples within shrinking ellipsoidal informed sets, dynamically adapts rewiring radius based on node density, rewires neighbors to improve cost locally, attempts early tree connection to reduce search time, and frequently applies a focused incremental shortcutting method to continuously smooth and shorten the path while maintaining collision safety.",
          "planning_mechanism": "The algorithm alternates expansions between two bidirectional trees and samples points concentrated in an ellipsoidal informed region defined by the current best solution cost. It incorporates a density-adaptive rewiring radius for efficient pruning and rewiring, performs collision-checked parent selection and neighbor rewiring, connects trees when nodes are reachable, and incrementally shortcuts the current best path at frequent intervals to improve smoothness and length without excessive computation. This continuous interplay of sampling, rewiring, connection, and shortcutting rapidly converges towards an optimal, smooth path with reduced runtime.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n    def add_child(self, child):\n        self.children.append(child)\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except ValueError:\n            pass\nclass Planner:\n    def __init__(self, max_iter=4500, step_size=6.0, gamma=40.0, shortcut_freq=25, max_shortcut_attempts=40):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.gamma = gamma\n        self.shortcut_freq = shortcut_freq\n        self.max_shortcut_attempts = max_shortcut_attempts\n\n    def plan(self, map):\n        import random\n        import math\n\n        bounds = map.size\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        obstacles = map.obstacles\n        start_pos = map.start\n        goal_pos = map.goal\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        best_cost = float('inf')\n        sol_start = None\n        sol_goal = None\n        c_min = math.dist(start_pos, goal_pos)\n\n        def near_radius(num_nodes):\n            if num_nodes <= 1:\n                return self.step_size * 3.0\n            r = self.gamma * (math.log(num_nodes) / num_nodes) ** (1.0 / dim)\n            return min(r, self.step_size * 40.0)\n\n        def unit_ball_vol(d):\n            if d == 2:\n                return math.pi\n            if d == 3:\n                return 4.0/3.0*math.pi\n            from math import gamma, pi\n            return (pi ** (d / 2)) / gamma(d / 2 + 1)\n\n        def informed_sample():\n            if best_cost == float('inf') or best_cost <= c_min:\n                return sample_free()\n            center = tuple((start_pos[i] + goal_pos[i]) * 0.5 for i in range(dim))\n            direction = [goal_pos[i] - start_pos[i] for i in range(dim)]\n            length = math.dist(start_pos, goal_pos)\n            if dim == 2:\n                if length < 1e-14:\n                    R = [[1,0],[0,1]]\n                else:\n                    a1 = [1,0]\n                    a2 = [direction[0]/length, direction[1]/length]\n                    cos_theta = a1[0]*a2[0]+a1[1]*a2[1]\n                    sin_theta = a1[0]*a2[1]-a1[1]*a2[0]\n                    R = [[cos_theta, -sin_theta],[sin_theta, cos_theta]]\n            else:\n                if length < 1e-14:\n                    R = [[1,0,0],[0,1,0],[0,0,1]]\n                else:\n                    from math import sqrt\n                    a1 = [1,0,0]\n                    a2 = [direction[i]/length for i in range(3)]\n                    v = [a1[1]*a2[2]-a1[2]*a2[1], a1[2]*a2[0]-a1[0]*a2[2], a1[0]*a2[1]-a1[1]*a2[0]]\n                    s = sqrt(sum(vi*vi for vi in v))\n                    c = sum(a1[i]*a2[i] for i in range(3))\n                    if s < 1e-14:\n                        R = [[1,0,0],[0,1,0],[0,0,1]]\n                    else:\n                        vx = [[0,-v[2],v[1]],[v[2],0,-v[0]],[-v[1],v[0],0]]\n                        I = [[1 if i==j else 0 for j in range(3)] for i in range(3)]\n                        vx2 = [[sum(vx[i][k]*vx[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n                        R = [[I[i][j]+vx[i][j]+vx2[i][j]*((1-c)/(s*s)) for j in range(3)] for i in range(3)]\n\n            a1_val = best_cost * 0.5\n            a_other = 0.5 * math.sqrt(max(best_cost*best_cost - c_min*c_min, 0.0))\n\n            while True:\n                if dim == 2:\n                    r = random.uniform(0,1)**0.5\n                    theta = random.uniform(0, 2*math.pi)\n                    x_ball = [r*math.cos(theta), r*math.sin(theta)]\n                    L = [[a1_val,0],[0,a_other]]\n                    x_scaled = [L[0][0]*x_ball[0] + L[0][1]*x_ball[1],\n                                L[1][0]*x_ball[0] + L[1][1]*x_ball[1]]\n                    pt = (center[0] + R[0][0]*x_scaled[0] + R[0][1]*x_scaled[1],\n                          center[1] + R[1][0]*x_scaled[0] + R[1][1]*x_scaled[1])\n                else:\n                    while True:\n                        x_ball = [random.uniform(-1,1) for _ in range(3)]\n                        if sum(xi*xi for xi in x_ball)<=1:\n                            break\n                    L = [[a1_val,0,0],[0,a_other,0],[0,0,a_other]]\n                    x_scaled = [L[0][0]*x_ball[0], L[1][1]*x_ball[1], L[2][2]*x_ball[2]]\n                    pt = tuple(center[i] + sum(R[i][j]*x_scaled[j] for j in range(dim)) for i in range(dim))\n                if any(pt[d]<0 or pt[d]>bounds[d] for d in range(dim)):\n                    continue\n                if self._is_in_obstacle(pt, obstacles, is_3d):\n                    continue\n                return pt\n\n        def sample_free():\n            while True:\n                pt = tuple(random.uniform(0,bounds[i]) for i in range(dim))\n                if not self._is_in_obstacle(pt, obstacles, is_3d):\n                    return pt\n\n        def nearest(tree, point):\n            best = None\n            best_dist = float('inf')\n            for n in tree:\n                d = 0.0\n                for i in range(dim):\n                    diff = n.position[i] - point[i]\n                    d += diff*diff\n                if d < best_dist:\n                    best_dist = d\n                    best = n\n            return best\n\n        def near(tree, point, radius):\n            r_sq = radius*radius\n            result = []\n            for n in tree:\n                d = 0.0\n                for i in range(dim):\n                    diff = n.position[i] - point[i]\n                    d += diff*diff\n                if d <= r_sq:\n                    result.append(n)\n            return result\n\n        def steer(from_pos, to_pos, max_step):\n            dist_sq = 0.0\n            diff_vec = []\n            for i in range(dim):\n                diff = to_pos[i] - from_pos[i]\n                diff_vec.append(diff)\n                dist_sq += diff*diff\n            dist = dist_sq**0.5\n            if dist <= max_step:\n                return to_pos\n            ratio = max_step / dist\n            new_pos = tuple(from_pos[i] + diff_vec[i]*ratio for i in range(dim))\n            return new_pos\n\n        def is_edge_collision_free(p1, p2):\n            # Collision check in intervals of max 1.0 units for efficiency\n            dist = 0.0\n            for i in range(dim):\n                dist += (p2[i]-p1[i])**2\n            dist = dist**0.5\n            steps = max(1, int(dist / 1.0))\n            for step_i in range(steps+1):\n                interp = tuple(p1[d] + (p2[d]-p1[d])*(step_i/steps) for d in range(dim))\n                if self._is_in_obstacle(interp, obstacles, is_3d):\n                    return False\n            return True\n\n        def attempt_extend(tree_a, tree_b, sample):\n            nearest_node = nearest(tree_a, sample)\n            new_pos = steer(nearest_node.position, sample, self.step_size)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if not is_edge_collision_free(nearest_node.position, new_pos):\n                return None\n            new_node = Node(new_pos)\n            radius = near_radius(len(tree_a))\n            neighbors = near(tree_a, new_pos, radius)\n\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            min_parent = nearest_node\n            for n in neighbors:\n                tentative = n.cost + math.dist(n.position, new_pos)\n                if tentative < min_cost:\n                    if is_edge_collision_free(n.position, new_pos):\n                        min_cost = tentative\n                        min_parent = n\n\n            new_node.parent = min_parent\n            new_node.cost = min_cost\n            min_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((min_parent, new_node))\n\n            # Rewire neighbors except min_parent if beneficial\n            for n in neighbors:\n                if n is min_parent:\n                    continue\n                new_cost = new_node.cost + math.dist(new_node.position, n.position)\n                if new_cost < n.cost:\n                    if is_edge_collision_free(new_node.position, n.position):\n                        if n.parent is not None:\n                            try: edges.remove((n.parent, n))\n                            except ValueError: pass\n                            n.parent.remove_child(n)\n                        n.parent = new_node\n                        n.cost = new_cost\n                        new_node.add_child(n)\n                        edges.append((new_node, n))\n\n            # Attempt to connect to nearest node in other tree within step_size\n            nearest_other = nearest(tree_b, new_node.position)\n            dist_connect = math.dist(new_node.position, nearest_other.position)\n            if dist_connect <= self.step_size:\n                if is_edge_collision_free(new_node.position, nearest_other.position):\n                    total_cost = new_node.cost + dist_connect + nearest_other.cost\n                    return new_node, nearest_other, total_cost\n            return None\n\n        def extract_path(node_start, node_goal):\n            path_s, path_g = [], []\n            n = node_start\n            while n is not None:\n                path_s.append(n.position)\n                n = n.parent\n            n = node_goal\n            while n is not None:\n                path_g.append(n.position)\n                n = n.parent\n            return list(reversed(path_s)) + path_g\n\n        def incremental_shortcut(path):\n            if len(path) < 3:\n                return path[:]\n            attempts = 0\n            shortcut_path = path[:]\n            while attempts < self.max_shortcut_attempts:\n                if len(shortcut_path) <3:\n                    break\n                i = random.randint(0,len(shortcut_path)-3)\n                j = random.randint(i+2,len(shortcut_path)-1)\n                if is_edge_collision_free(shortcut_path[i], shortcut_path[j]):\n                    shortcut_path = shortcut_path[:i+1] + shortcut_path[j:]\n                    attempts = 0\n                else:\n                    attempts +=1\n            return shortcut_path\n\n        for it in range(self.max_iter):\n            sample = informed_sample()\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                res = attempt_extend(tree_a, tree_b, sample)\n                if res is not None:\n                    n_new, n_connect, cost_path = res\n                    if cost_path < best_cost:\n                        best_cost = cost_path\n                        sol_start, sol_goal = (n_new, n_connect) if tree_a is start_tree else (n_connect, n_new)\n            if best_cost < float('inf') and sol_start is not None and sol_goal is not None:\n                if it % self.shortcut_freq == 0 or it == self.max_iter-1:\n                    raw_path = extract_path(sol_start, sol_goal)\n                    improved_path = incremental_shortcut(raw_path)\n                    if improved_path and len(improved_path) >= 2:\n                        return PlannerResult(True, improved_path, nodes, edges)\n        return PlannerResult(False, [], nodes, edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x,y,z,w,h,d=obs\n                px,py,pz=pos\n                if x<=px<=x+w and y<=py<=y+h and z<=pz<=z+d:\n                    return True\n            else:\n                x,y,w,h=obs\n                px,py=pos\n                if x<=px<=x+w and y<=py<=y+h:\n                    return True\n        return False",
          "objective": -32.21323,
          "time_improvement": 52.0,
          "length_improvement": 16.0,
          "smoothness_improvement": 1433.0,
          "node_improvement": 74.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.01826310157775879,
                    "num_nodes_avg": 131.0,
                    "path_length_avg": 166.80041346603122,
                    "smoothness_avg": 0.03850615988076263,
                    "success_improvement": 0.0,
                    "time_improvement": 29.187562688064194,
                    "node_improvement": 67.01082850667338,
                    "length_improvement": 8.574050257575799,
                    "smoothness_improvement": 502.7050195984601,
                    "objective_score": 16.414224058957036
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.02589578628540039,
                    "num_nodes_avg": 240.1,
                    "path_length_avg": 234.42132183759287,
                    "smoothness_avg": 0.0955636258647175,
                    "success_improvement": 0.0,
                    "time_improvement": 84.36015244901614,
                    "node_improvement": 83.86749983202311,
                    "length_improvement": 21.743415326984575,
                    "smoothness_improvement": 2358.9209251966936,
                    "objective_score": 50.14869955687905
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.028525924682617186,
                    "num_nodes_avg": 235.1,
                    "path_length_avg": 126.10181619096082,
                    "smoothness_avg": 0.1209255471006773,
                    "success_improvement": 0.0,
                    "time_improvement": 43.78815790153682,
                    "node_improvement": 70.10807374443738,
                    "length_improvement": 16.24917800917602,
                    "smoothness_improvement": 1438.1640333251999,
                    "objective_score": 30.07677434259266
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e2",
          "algorithm_description": "An enhanced bidirectional RRT* planner using adaptive neighborhood radius with density and cost scaling, combined with hybrid uniform and ellipsoidal informed sampling. It integrates multidimensional collision-aware spline smoothing via iterative optimization and an improved progressive shortcutting mechanism with attempt resets to maximize path smoothness and length reduction while maintaining collision-free guarantees. This yields efficient planning with higher success rate, better optimality, and notably smoother trajectories.",
          "planning_mechanism": "The algorithm grows two trees alternately, extending towards sampled points from a hybrid global/informed distribution. Rewiring and neighborhood radii adapt dynamically to tree density and current best cost ensuring efficient convergence. When connecting the trees, it extracts the path and applies many incremental shortcut attempts with resets to aggressively remove unnecessary waypoints. Then it performs iterative, multidimensional spline smoothing by optimizing control points jointly under collision constraints, improving smoothness without fallback to raw paths. The process repeats adaptively during planning to provide progressively refined solutions and terminates returning the best found path.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except ValueError:\n            pass\nclass Planner:\n    def __init__(self, max_iter=6000, step_size=6.0, gamma=30.0,\n                 shortcut_incremental_freq=20, spline_smooth_freq=150,\n                 max_incremental_attempts=60, smoothing_iterations=10):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.gamma = gamma\n        self.shortcut_incremental_freq = shortcut_incremental_freq\n        self.spline_smooth_freq = spline_smooth_freq\n        self.max_incremental_attempts = max_incremental_attempts\n        self.smoothing_iterations = smoothing_iterations\n\n    def plan(self, map):\n        import random\n        import math\n\n        bounds = map.size\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        obstacles = map.obstacles\n        start_pos = map.start\n        goal_pos = map.goal\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        best_cost = float('inf')\n        best_sol = None  # tuple (node_from_start, node_from_goal)\n        c_min = math.dist(start_pos, goal_pos)\n        unit_ball_vol = self._unit_ball_volume(dim)\n\n        def adapt_radius(n_nodes, cost):\n            if n_nodes <= 1:\n                return max(self.step_size * 2.5, self.step_size)\n            base_radius = self.gamma * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            max_radius = self.step_size * 25.0\n            radius = min(base_radius, max_radius)\n            if cost != float('inf') and cost > c_min:\n                radius = min(radius, cost * 0.5)\n            return max(radius, self.step_size * 1.5)\n\n        def sample_point():\n            # Hybrid uniform + informed ellipsoid sampling (~30% ellipsoid)\n            if best_cost == float('inf') or best_cost <= c_min:\n                return self._sample_free(bounds, obstacles, is_3d)\n            if random.random() < 0.3:\n                center = tuple((start_pos[i] + goal_pos[i]) * 0.5 for i in range(dim))\n                direction = [goal_pos[i] - start_pos[i] for i in range(dim)]\n                length = math.dist(start_pos, goal_pos)\n                if length < 1e-12:\n                    return self._sample_free(bounds, obstacles, is_3d)\n\n                if dim == 2:\n                    a1 = [1, 0]\n                    a2 = [direction[0] / length, direction[1] / length]\n                    cos_theta = a1[0] * a2[0] + a1[1] * a2[1]\n                    sin_theta = a1[0] * a2[1] - a1[1] * a2[0]\n                    R = [[cos_theta, -sin_theta],\n                         [sin_theta, cos_theta]]\n                else:\n                    a1 = [1, 0, 0]\n                    a2 = [direction[i] / length for i in range(3)]\n                    v = [a1[1]*a2[2] - a1[2]*a2[1],\n                         a1[2]*a2[0] - a1[0]*a2[2],\n                         a1[0]*a2[1] - a1[1]*a2[0]]\n                    s = math.sqrt(sum(x*x for x in v))\n                    c = sum(a1[i]*a2[i] for i in range(3))\n                    if s < 1e-12:\n                        R = [[1,0,0],[0,1,0],[0,0,1]]\n                    else:\n                        vx = [[0, -v[2], v[1]],\n                              [v[2], 0, -v[0]],\n                              [-v[1], v[0], 0]]\n                        I = [[1 if i==j else 0 for j in range(3)] for i in range(3)]\n                        vx2 = [[sum(vx[i][k]*vx[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n                        R = [[I[i][j] + vx[i][j] + vx2[i][j]*((1 - c)/(s*s)) for j in range(3)] for i in range(3)]\n\n                a1_val = best_cost * 0.5\n                a_orth = 0.5 * math.sqrt(max(best_cost*best_cost - c_min*c_min, 0.0))\n\n                max_attempts = 100\n                for _ in range(max_attempts):\n                    if dim == 2:\n                        r = random.uniform(0,1)**0.5\n                        theta = random.uniform(0, 2*math.pi)\n                        x_ball = [r*math.cos(theta), r*math.sin(theta)]\n                        L = [[a1_val, 0], [0, a_orth]]\n                        x_scaled = [L[0][0]*x_ball[0] + L[0][1]*x_ball[1],\n                                    L[1][0]*x_ball[0] + L[1][1]*x_ball[1]]\n                        pt = (center[0] + R[0][0]*x_scaled[0] + R[0][1]*x_scaled[1],\n                              center[1] + R[1][0]*x_scaled[0] + R[1][1]*x_scaled[1])\n                    else:\n                        while True:\n                            x_ball = [random.uniform(-1,1) for _ in range(3)]\n                            if sum(x*x for x in x_ball) <= 1:\n                                break\n                        L = [[a1_val,0,0],[0,a_orth,0],[0,0,a_orth]]\n                        x_scaled = [L[0][0]*x_ball[0],\n                                    L[1][1]*x_ball[1],\n                                    L[2][2]*x_ball[2]]\n                        pt = tuple(center[i] + sum(R[i][j]*x_scaled[j] for j in range(dim)) for i in range(dim))\n                    if any(pt[d] < 0.0 or pt[d] > bounds[d] for d in range(dim)):\n                        continue\n                    if self._is_in_obstacle(pt, obstacles, is_3d):\n                        continue\n                    return pt\n                return self._sample_free(bounds, obstacles, is_3d)\n            else:\n                return self._sample_free(bounds, obstacles, is_3d)\n\n        def try_extend(tree_a, tree_b, sample):\n            nearest = self._nearest(tree_a, sample)\n            new_pos = self._steer(nearest.position, sample, self.step_size)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                return None\n            new_node = Node(new_pos)\n            radius = adapt_radius(len(tree_a), best_cost)\n            near_nodes = self._near(tree_a, new_pos, radius)\n\n            min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n            min_parent = nearest\n            for near in near_nodes:\n                t_cost = near.cost + math.dist(near.position, new_pos)\n                if t_cost < min_cost:\n                    if not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d):\n                        min_cost = t_cost\n                        min_parent = near\n\n            new_node.parent = min_parent\n            new_node.cost = min_cost\n            min_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((min_parent, new_node))\n\n            # Rewire neighbors if beneficial\n            for near in near_nodes:\n                if near is min_parent:\n                    continue\n                new_cost = new_node.cost + math.dist(new_node.position, near.position)\n                if new_cost < near.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                        if near.parent is not None:\n                            try:\n                                edges.remove((near.parent, near))\n                            except ValueError:\n                                pass\n                            near.parent.remove_child(near)\n                        near.parent = new_node\n                        near.cost = new_cost\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n\n            connect_radius = max(radius * 1.6, self.step_size * 1.6)\n            nearest_b = self._nearest(tree_b, new_node.position)\n            dist_conn = math.dist(new_node.position, nearest_b.position)\n            if dist_conn <= connect_radius:\n                if not self._is_edge_in_obstacle(new_node.position, nearest_b.position, obstacles, is_3d):\n                    total_cost = new_node.cost + dist_conn + nearest_b.cost\n                    return new_node, nearest_b, total_cost\n            return None\n\n        def incremental_shortcut(path):\n            # Resets attempts on success to aggressively simplify path\n            if len(path) < 3:\n                return path[:]\n            shortcut_path = path[:]\n            attempts = 0\n            max_attempts = self.max_incremental_attempts\n            while attempts < max_attempts:\n                if len(shortcut_path) < 3:\n                    break\n                i = random.randint(0, len(shortcut_path)-3)\n                j = random.randint(i+2, len(shortcut_path)-1)\n                if not self._is_edge_in_obstacle(shortcut_path[i], shortcut_path[j], obstacles, is_3d):\n                    shortcut_path = shortcut_path[:i+1] + shortcut_path[j:]\n                    attempts = 0  # Reset attempts on success\n                else:\n                    attempts += 1\n            return shortcut_path\n\n        def multidim_spline_smoothing(path):\n            # Iterative, multidimensional smoothing optimizing all dimensions jointly under collision constraints\n            if len(path) < 4:\n                return path[:]\n            import copy\n            n = len(path)\n            dim_local = len(path[0])\n            pts = [list(p) for p in path]\n\n            # Fixed endpoints\n            fixed_indices = [0, n-1]\n\n            def collision_free(p_list):\n                # Check edges segment-wise for collisions\n                for idx in range(len(p_list)-1):\n                    if self._is_edge_in_obstacle(tuple(p_list[idx]), tuple(p_list[idx+1]), obstacles, is_3d):\n                        return False\n                return True\n\n            def smooth_iteration(points):\n                # Each internal point updated as weighted average of neighbors and itself (like Laplacian smoothing)\n                new_pts = copy.deepcopy(points)\n                w_smooth = 0.5  # smoothing strength factor\n                for i in range(1, n-1):\n                    if i in fixed_indices:\n                        continue\n                    for d in range(dim_local):\n                        new_val = (points[i-1][d] + points[i][d]*2 + points[i+1][d]) / 4\n                        new_pts[i][d] = points[i][d] + w_smooth * (new_val - points[i][d])\n                return new_pts\n\n            prev_pts = pts\n            for _ in range(self.smoothing_iterations):\n                candidate_pts = smooth_iteration(prev_pts)\n                if collision_free(candidate_pts):\n                    prev_pts = candidate_pts\n                else:\n                    break  # Stop if smoothing led to collision\n\n            smoothed = [tuple(p) for p in prev_pts]\n            return smoothed\n\n        def extract_path(n_s, n_g):\n            path_start = []\n            cur = n_s\n            while cur is not None:\n                path_start.append(cur.position)\n                cur = cur.parent\n            path_goal = []\n            cur = n_g\n            while cur is not None:\n                path_goal.append(cur.position)\n                cur = cur.parent\n            return list(reversed(path_start)) + path_goal\n\n        for iteration in range(self.max_iter):\n            sample = sample_point()\n\n            # Alternate expansions\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                res = try_extend(tree_a, tree_b, sample)\n                if res is not None:\n                    node_a, node_b, cost = res\n                    if cost < best_cost:\n                        best_cost = cost\n                        best_sol = (node_a, node_b)\n\n            if best_sol is not None and best_cost < float('inf'):\n                # Periodic incremental shortcutting with attempt resets for better smoothing\n                if (iteration % self.shortcut_incremental_freq) == 0:\n                    path_raw = extract_path(best_sol[0], best_sol[1])\n                    path_shortcut = incremental_shortcut(path_raw)\n                else:\n                    path_shortcut = None\n\n                if path_shortcut is not None:\n                    # On shortcut improvement, also try spline smoothing infrequently after shortcutting\n                    if (iteration % self.spline_smooth_freq) == 0 or iteration == (self.max_iter - 1):\n                        path_smooth = multidim_spline_smoothing(path_shortcut)\n                        if len(path_smooth) >= 2:\n                            return PlannerResult(True, path_smooth, nodes, edges)\n                    return PlannerResult(True, path_shortcut, nodes, edges)\n\n                elif (iteration > 0 and iteration % self.spline_smooth_freq == 0) or iteration == (self.max_iter - 1):\n                    path_raw = extract_path(best_sol[0], best_sol[1])\n                    path_smooth = multidim_spline_smoothing(path_raw)\n                    if len(path_smooth) >= 2:\n                        return PlannerResult(True, path_smooth, nodes, edges)\n                    else:\n                        return PlannerResult(True, path_raw, nodes, edges)\n\n        return PlannerResult(False, [], nodes, edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        import random\n        while True:\n            pt = tuple(random.uniform(0, bounds[i]) for i in range(len(bounds)))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def _nearest(self, tree, point):\n        best = None\n        best_dist_sq = float('inf')\n        for node in tree:\n            dist_sq = 0.0\n            for i in range(len(point)):\n                d = node.position[i] - point[i]\n                dist_sq += d * d\n            if dist_sq < best_dist_sq:\n                best_dist_sq = dist_sq\n                best = node\n        return best\n\n    def _near(self, tree, point, radius):\n        r_sq = radius * radius\n        result = []\n        for node in tree:\n            dist_sq = 0.0\n            for i in range(len(point)):\n                d = node.position[i] - point[i]\n                dist_sq += d * d\n            if dist_sq <= r_sq:\n                result.append(node)\n        return result\n\n    def _steer(self, from_pos, to_pos, step_size):\n        dist_sq = 0.0\n        diff = []\n        for i in range(len(from_pos)):\n            d = to_pos[i] - from_pos[i]\n            diff.append(d)\n            dist_sq += d * d\n        dist = dist_sq ** 0.5\n        if dist <= step_size:\n            return to_pos\n        ratio = step_size / dist\n        return tuple(from_pos[i] + diff[i] * ratio for i in range(len(from_pos)))\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        dist_sq = 0.0\n        diff = []\n        for i in range(len(from_pos)):\n            d = to_pos[i] - from_pos[i]\n            diff.append(d)\n            dist_sq += d * d\n        dist = dist_sq ** 0.5\n        steps = max(1, int(dist / resolution))\n        for step in range(steps + 1):\n            interp = tuple(from_pos[i] + diff[i] * (step / steps) for i in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _unit_ball_volume(self, dim):\n        import math\n        if dim == 2:\n            return math.pi\n        elif dim == 3:\n            return 4.0 / 3.0 * math.pi\n        else:\n            from math import gamma, pi\n            return (pi ** (dim / 2)) / gamma(dim / 2 + 1)",
          "objective": -32.02985,
          "time_improvement": 54.0,
          "length_improvement": 15.0,
          "smoothness_improvement": 1403.0,
          "node_improvement": 76.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.017703032493591307,
                    "num_nodes_avg": 121.8,
                    "path_length_avg": 171.8456931396309,
                    "smoothness_avg": 0.03577810194004042,
                    "success_improvement": 0.0,
                    "time_improvement": 31.35914656411632,
                    "node_improvement": 69.32762528330395,
                    "length_improvement": 5.808652520903305,
                    "smoothness_improvement": 460.00498875352116,
                    "objective_score": 15.192960425544484
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.024016857147216797,
                    "num_nodes_avg": 214.3,
                    "path_length_avg": 234.66150045302211,
                    "smoothness_avg": 0.09590643376999068,
                    "success_improvement": 0.0,
                    "time_improvement": 85.49493804526817,
                    "node_improvement": 85.6010212994692,
                    "length_improvement": 21.66323679199616,
                    "smoothness_improvement": 2367.7416195139263,
                    "objective_score": 50.48513158634778
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.028107595443725587,
                    "num_nodes_avg": 214.8,
                    "path_length_avg": 125.17904165305893,
                    "smoothness_avg": 0.1165177456261379,
                    "success_improvement": 0.0,
                    "time_improvement": 44.61249777424476,
                    "node_improvement": 72.68912905276542,
                    "length_improvement": 16.862040919448884,
                    "smoothness_improvement": 1382.0971239191201,
                    "objective_score": 30.411459503538357
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "A bidirectional RRT* planner with blended uniform and informed ellipsoidal sampling, adaptive rewiring radius balancing node density and current best cost, spatial hashing for efficient neighbor search, and combined incremental and global smoothing. The planner grows two trees alternately, rewires locally with curvature-agnostic cost for speed, tries to connect trees frequently with an adaptive connection distance, and applies fast incremental shortcutting within planning and a final global smoothing that maintains collision-free guarantees for improved path length and smoothness while sustaining efficient search.",
          "planning_mechanism": "The planner alternates expansions between start and goal trees, sampling points either uniformly or within an ellipsoidal informed region based on current best path cost to blend exploration and focused search. It uses spatial hashing for efficient nearest and near neighbor queries to speed rewiring within an adaptive radius derived from node count and best cost. After connecting trees with an adaptive threshold, it extracts the path and performs fast incremental shortcutting during planning and a cautious global smoothing step at the end to reduce unnecessary waypoints and smooth path curvature without expensive curvature calculations, ensuring collision-free paths and faster convergence.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\nclass Planner:\n    def __init__(self, max_iter=3500, step_size=6.0, r_min=5.0, r_max=25.0,\n                 goal_sample_rate=0.07, shortcut_freq=30):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.r_min = r_min\n        self.r_max = r_max\n        self.goal_sample_rate = goal_sample_rate\n        self.shortcut_freq = shortcut_freq\n        \n    def plan(self, map):\n        import random\n        import math\n\n        bounds = map.size\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        def in_bounds(p):\n            return all(0 <= p[i] <= bounds[i] for i in range(dim))\n\n        def collision_node(p):\n            px = p[0]\n            py = p[1]\n            pz = p[2] if is_3d else 0.0\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w_, h_ = obs\n                    if x <= px <= x + w_ and y <= py <= y + h_:\n                        return True\n            return False\n\n        def collision_edge(a, b, resolution=1.0):\n            dist_ab = math.dist(a, b)\n            steps = max(2, int(dist_ab / resolution))\n            for i in range(steps + 1):\n                interp = tuple(a[j] + (b[j] - a[j]) * i / steps for j in range(dim))\n                if collision_node(interp):\n                    return True\n            return False\n\n        def steer(from_p, to_p):\n            d = math.dist(from_p, to_p)\n            if d <= self.step_size:\n                return to_p\n            ratio = self.step_size / d\n            return tuple(from_p[i] + ratio * (to_p[i] - from_p[i]) for i in range(dim))\n\n        GRID_SIZE = self.step_size * 3.5\n        def grid_hash(p):\n            return tuple(int(p[i] // GRID_SIZE) for i in range(dim))\n\n        def add_to_hash(ht, node):\n            h = grid_hash(node.position)\n            if h not in ht:\n                ht[h] = []\n            ht[h].append(node)\n\n        def remove_from_hash(ht, node):\n            h = grid_hash(node.position)\n            if h in ht and node in ht[h]:\n                ht[h].remove(node)\n                if not ht[h]:\n                    del ht[h]\n\n        def nearby_nodes(ht, p, radius):\n            r2 = radius * radius\n            gh = grid_hash(p)\n            shifts = [-1, 0, 1]\n            cells = []\n            if dim == 2:\n                cells = [(gh[0]+dx, gh[1]+dy) for dx in shifts for dy in shifts]\n            else:\n                cells = [(gh[0]+dx, gh[1]+dy, gh[2]+dz) for dx in shifts for dy in shifts for dz in shifts]\n            neighbors = []\n            for cell in cells:\n                if cell in ht:\n                    for node in ht[cell]:\n                        d_sq = 0\n                        for i in range(dim):\n                            diff = node.position[i] - p[i]\n                            d_sq += diff * diff\n                            if d_sq > r2:\n                                break\n                        else:\n                            neighbors.append(node)\n            return neighbors\n\n        def nearest(ht, p):\n            gh = grid_hash(p)\n            expansions = 0\n            min_node = None\n            min_d2 = float('inf')\n            max_exp = 3\n            while expansions <= max_exp:\n                if dim == 2:\n                    candidates = []\n                    r = range(-expansions, expansions+1)\n                    cells = [(gh[0]+dx, gh[1]+dy) for dx in r for dy in r]\n                    for c in cells:\n                        candidates.extend(ht.get(c, []))\n                else:\n                    candidates = []\n                    r = range(-expansions, expansions+1)\n                    cells = [(gh[0]+dx, gh[1]+dy, gh[2]+dz) for dx in r for dy in r for dz in r]\n                    for c in cells:\n                        candidates.extend(ht.get(c, []))\n                for node in candidates:\n                    d2 = 0\n                    for i in range(dim):\n                        diff = node.position[i] - p[i]\n                        d2 += diff * diff\n                        if d2 >= min_d2:\n                            break\n                    else:\n                        if d2 < min_d2:\n                            min_d2 = d2\n                            min_node = node\n                if min_node or expansions == max_exp:\n                    break\n                expansions += 1\n            if min_node is None:\n                # fallback linear scan\n                all_nodes = []\n                for vs in ht.values():\n                    all_nodes.extend(vs)\n                if all_nodes:\n                    min_node = min(all_nodes, key=lambda n: math.dist(n.position, p))\n            return min_node\n\n        c_min = math.dist(start_pos, goal_pos)\n\n        def ellipsoid_sample(best_cost):\n            if best_cost == float('inf') or best_cost < c_min or random.random() < 0.3:\n                # uniform random in bounds without obstacles\n                for _ in range(30):\n                    pt = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                    if not collision_node(pt):\n                        return pt\n                return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n            # else sample inside ellipsoid\n            center = tuple(0.5 * (start_pos[i] + goal_pos[i]) for i in range(dim))\n            d_vec = [goal_pos[i] - start_pos[i] for i in range(dim)]\n            length = math.dist(start_pos, goal_pos)\n            a1 = best_cost * 0.5\n            term = best_cost * best_cost - c_min * c_min\n            a_rest = math.sqrt(term)*0.5 if term > 0 else 0.0\n            \n            if dim == 2:\n                if length < 1e-15:\n                    R = [[1,0],[0,1]]\n                else:\n                    cdir = (d_vec[0]/length, d_vec[1]/length)\n                    c, s = cdir\n                    R = [[c,-s],[s,c]]\n                for _ in range(100):\n                    r = random.uniform(0,1)**0.5\n                    theta = random.uniform(0, 2*math.pi)\n                    local = [r*math.cos(theta), r*math.sin(theta)]\n                    ellip = [a1*local[0], a_rest*local[1]]\n                    pt = tuple(center[i] + sum(ellip[j]*R[j][i] for j in range(dim)) for i in range(dim))\n                    if in_bounds(pt) and not collision_node(pt):\n                        return pt\n            else:\n                from math import sqrt\n                if length < 1e-15:\n                    R = [[1,0,0],[0,1,0],[0,0,1]]\n                else:\n                    a1v = [1,0,0]\n                    a2v = [d_vec[i]/length for i in range(3)]\n                    v = [a1v[1]*a2v[2]-a1v[2]*a2v[1], a1v[2]*a2v[0]-a1v[0]*a2v[2], a1v[0]*a2v[1]-a1v[1]*a2v[0]]\n                    s = sqrt(sum(x*x for x in v))\n                    c = sum(a1v[i]*a2v[i] for i in range(3))\n                    if s < 1e-14:\n                        R = [[1,0,0],[0,1,0],[0,0,1]]\n                    else:\n                        vx = [[0,-v[2],v[1]],[v[2],0,-v[0]],[-v[1],v[0],0]]\n                        I = [[1 if i==j else 0 for j in range(3)] for i in range(3)]\n                        vx2 = [[sum(vx[i][k]*vx[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n                        R = [[I[i][j] + vx[i][j] + vx2[i][j]*((1-c)/(s*s)) for j in range(3)] for i in range(3)]\n                for _ in range(100):\n                    while True:\n                        ball = [random.uniform(-1,1) for _ in range(3)]\n                        if sum(x*x for x in ball) <= 1.0:\n                            break\n                    ellip = [a1*ball[0], a_rest*ball[1], a_rest*ball[2]]\n                    pt = tuple(center[i] + sum(R[i][j]*ellip[j] for j in range(3)) for i in range(3))\n                    if in_bounds(pt) and not collision_node(pt):\n                        return pt\n            # fallback uniform sampling\n            for _ in range(30):\n                pt = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not collision_node(pt):\n                    return pt\n            return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n\n        def adaptive_radius(n_nodes, best_cost):\n            if n_nodes < 2:\n                return self.r_max\n            val = (math.log(n_nodes) / n_nodes) ** (1/dim)\n            radius = self.r_max * val * 1.2\n            if best_cost != float('inf'):\n                radius = min(radius, best_cost * 0.3)\n            radius = max(self.r_min, radius)\n            radius = min(self.r_max, radius)\n            return radius\n\n        def path_to_positions(n_start, n_goal):\n            path_start = []\n            n = n_start\n            while n:\n                path_start.append(n.position)\n                n = n.parent\n            path_start.reverse()\n            path_goal = []\n            n = n_goal\n            while n:\n                path_goal.append(n.position)\n                n = n.parent\n            if path_start[-1] == path_goal[0]:\n                return path_start + path_goal[1:]\n            else:\n                return path_start + path_goal\n\n        def shortcut_path(path, max_attempts=150, max_passes=10):\n            if len(path) < 3:\n                return path[:]\n            p = path[:]\n            for _ in range(max_passes):\n                improved = False\n                attempts = 0\n                while attempts < max_attempts:\n                    if len(p) < 3:\n                        break\n                    i = random.randint(0, len(p)-3)\n                    j = random.randint(i+2, len(p)-1)\n                    if not collision_edge(p[i], p[j]):\n                        p = p[:i+1] + p[j:]\n                        improved = True\n                        attempts = 0\n                    else:\n                        attempts += 1\n                if not improved:\n                    break\n            return p\n\n        def global_smooth(path):\n            if len(path) < 3:\n                return path[:]\n            max_iter = 50\n            alpha = 0.6\n            p = [list(pt) for pt in path]\n            for _ in range(max_iter):\n                changed = False\n                for i in range(1, len(p)-1):\n                    new_pt = [(p[i-1][d] + p[i+1][d]) * 0.5 for d in range(dim)]\n                    cand = [alpha*new_pt[d] + (1-alpha)*p[i][d] for d in range(dim)]\n                    cand_t = tuple(cand)\n                    if not in_bounds(cand_t):\n                        continue\n                    if collision_node(cand_t):\n                        continue\n                    if collision_edge(p[i-1], cand_t) or collision_edge(cand_t, p[i+1]):\n                        continue\n                    if any(abs(cand[d] - p[i][d]) > 1e-5 for d in range(dim)):\n                        p[i] = cand\n                        changed = True\n                if not changed:\n                    break\n            return [tuple(pt) for pt in p]\n\n        start_tree = [Node(start_pos, None, 0.0)]\n        goal_tree = [Node(goal_pos, None, 0.0)]\n        start_hash = {}\n        goal_hash = {}\n        add_to_hash(start_hash, start_tree[0])\n        add_to_hash(goal_hash, goal_tree[0])\n        all_nodes = start_tree + goal_tree\n        edges = []\n\n        best_cost = float('inf')\n        best_sol = (None, None)\n\n        expand_start = True\n\n        for it in range(self.max_iter):\n            samp = None\n            if random.random() < self.goal_sample_rate:\n                samp = goal_pos\n            else:\n                samp = ellipsoid_sample(best_cost)\n\n            if expand_start:\n                tree_a, h_a = start_tree, start_hash\n                tree_b, h_b = goal_tree, goal_hash\n            else:\n                tree_a, h_a = goal_tree, goal_hash\n                tree_b, h_b = start_tree, start_hash\n            expand_start = not expand_start\n\n            nearest_node = nearest(h_a, samp)\n            if nearest_node is None:\n                continue\n\n            new_pos = steer(nearest_node.position, samp)\n            if not in_bounds(new_pos) or collision_node(new_pos) or collision_edge(nearest_node.position, new_pos):\n                continue\n\n            radius = adaptive_radius(len(tree_a), best_cost)\n            near_nodes = nearby_nodes(h_a, new_pos, radius)\n\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for cand in near_nodes:\n                if cand is nearest_node:\n                    continue\n                c_cost = cand.cost + math.dist(cand.position, new_pos)\n                if c_cost < min_cost and not collision_edge(cand.position, new_pos):\n                    min_cost = c_cost\n                    best_parent = cand\n\n            new_node = Node(new_pos, best_parent, min_cost)\n            best_parent.add_child(new_node)\n            tree_a.append(new_node)\n            all_nodes.append(new_node)\n            add_to_hash(h_a, new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewiring: attempt to re-assign parents for nodes in near_nodes\n            for nbr in near_nodes:\n                if nbr is best_parent or nbr is new_node:\n                    continue\n                cost_through_new = new_node.cost + math.dist(new_node.position, nbr.position)\n                if cost_through_new < nbr.cost and not collision_edge(new_node.position, nbr.position):\n                    if nbr.parent:\n                        nbr.parent.remove_child(nbr)\n                    nbr.parent = new_node\n                    nbr.cost = cost_through_new\n                    new_node.add_child(nbr)\n                    edges.append((new_node, nbr))\n\n            # Attempt connection to other tree\n            nearest_other = nearest(h_b, new_node.position)\n            if nearest_other and math.dist(new_node.position, nearest_other.position) <= radius:\n                if not collision_edge(new_node.position, nearest_other.position):\n                    total_cost = new_node.cost + math.dist(new_node.position, nearest_other.position) + nearest_other.cost\n                    if total_cost < best_cost:\n                        best_cost = total_cost\n                        if tree_a is start_tree:\n                            best_sol = (new_node, nearest_other)\n                        else:\n                            best_sol = (nearest_other, new_node)\n\n            # Incremental shortcutting to quick refine when solution found\n            if best_sol[0] and best_sol[1] and (it % self.shortcut_freq == 0 or it == self.max_iter - 1):\n                raw_path = path_to_positions(best_sol[0], best_sol[1])\n                short_path = shortcut_path(raw_path, max_attempts=50, max_passes=3)\n                smooth_path = global_smooth(short_path)\n                return PlannerResult(True, smooth_path, all_nodes, edges)\n\n        # On finish, if solution found return improved path\n        if best_sol[0] and best_sol[1]:\n            raw_path = path_to_positions(best_sol[0], best_sol[1])\n            short_path = shortcut_path(raw_path)\n            smooth_path = global_smooth(short_path)\n            return PlannerResult(True, smooth_path, all_nodes, edges)\n        return PlannerResult(False, [], all_nodes, edges)",
          "objective": -31.9604,
          "time_improvement": 50.0,
          "length_improvement": 14.0,
          "smoothness_improvement": 1657.0,
          "node_improvement": 70.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.02543611526489258,
                    "num_nodes_avg": 139.4,
                    "path_length_avg": 166.77431034894227,
                    "smoothness_avg": 0.0456526466438557,
                    "success_improvement": 0.0,
                    "time_improvement": 1.3752779074550814,
                    "node_improvement": 64.89549231931504,
                    "length_improvement": 8.588357789682611,
                    "smoothness_improvement": 614.5630562852605,
                    "objective_score": 8.638413327472394
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.023469758033752442,
                    "num_nodes_avg": 278.3,
                    "path_length_avg": 239.65822766878287,
                    "smoothness_avg": 0.1173507286746149,
                    "success_improvement": 0.0,
                    "time_improvement": 85.82536040184611,
                    "node_improvement": 81.30081300813008,
                    "length_improvement": 19.995185424556784,
                    "smoothness_improvement": 2919.5187731112073,
                    "objective_score": 52.342313240843936
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.01835007667541504,
                    "num_nodes_avg": 285.3,
                    "path_length_avg": 129.08850639363942,
                    "smoothness_avg": 0.12089815786481553,
                    "success_improvement": 0.0,
                    "time_improvement": 63.84020416341906,
                    "node_improvement": 63.72536554354736,
                    "length_improvement": 14.265560587461174,
                    "smoothness_improvement": 1437.8156442667012,
                    "objective_score": 34.90047582283592
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "A bidirectional informed RRT* variant with adaptive rewiring, efficient ellipsoidal sampling focused on the current best path cost, continuous rewiring with cost propagation, and frequent incremental shortcutting to ensure efficient convergence to high-quality, smooth, and short paths. Sampling is restricted within an ellipsoid based on the best solution cost, rewiring radius adapts to node density, and shortcutting continuously improves smoothness and path length during planning.",
          "planning_mechanism": "The planner grows bidirectional trees from start and goal, alternately sampling points focused on an informed ellipsoid region to guide exploration toward promising areas. On each extension, it rewires neighbors dynamically adapting the radius based on sampling density, propagates cost improvements efficiently, and frequently performs incremental shortcutting to refine the best path, thereby ensuring fast convergence, robustness, and high-quality smooth solutions.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except ValueError:\n            pass\nclass Planner:\n    def __init__(self, max_iter=4000, step_size=6.0, gamma=30.0, shortcut_freq=20, max_shortcut_attempts=50):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.gamma = gamma\n        self.shortcut_freq = shortcut_freq\n        self.max_shortcut_attempts = max_shortcut_attempts\n\n    def plan(self, map):\n        import math\n        import random\n\n        bounds = map.size\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        obstacles = map.obstacles\n        start_pos = map.start\n        goal_pos = map.goal\n\n        start_nodes = [Node(start_pos, None, 0.0)]\n        goal_nodes = [Node(goal_pos, None, 0.0)]\n        nodes = start_nodes + goal_nodes\n        edges = []\n\n        best_cost = float('inf')\n        sol_start = None\n        sol_goal = None\n        c_min = math.dist(start_pos, goal_pos)\n\n        def is_in_obstacle(p):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = p\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w_, h_ = obs\n                    px, py = p\n                    if x <= px <= x + w_ and y <= py <= y + h_:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(p1, p2, resolution=1.0):\n            dist = math.dist(p1, p2)\n            steps = max(2, int(dist / resolution))\n            for step in range(steps + 1):\n                interp = tuple(p1[i] + (p2[i] - p1[i]) * step / steps for i in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def steer(from_p, to_p):\n            dist = math.dist(from_p, to_p)\n            if dist <= self.step_size:\n                return to_p\n            ratio = self.step_size / dist\n            return tuple(from_p[i] + (to_p[i] - from_p[i]) * ratio for i in range(dim))\n\n        def nearest(tree, point):\n            best = None\n            best_dist_sq = float('inf')\n            for n in tree:\n                d2 = sum((n.position[i] - point[i]) ** 2 for i in range(dim))\n                if d2 < best_dist_sq:\n                    best_dist_sq = d2\n                    best = n\n            return best\n\n        def near_radius(num_nodes):\n            if num_nodes <= 1:\n                return self.step_size * 4.0\n            r = self.gamma * (math.log(num_nodes) / num_nodes) ** (1.0 / dim)\n            return min(r, self.step_size * 40.0)\n\n        def near(tree, point, radius):\n            r2 = radius * radius\n            return [n for n in tree if sum((n.position[i] - point[i]) ** 2 for i in range(dim)) <= r2]\n\n        def update_parent(child, new_parent, new_cost):\n            if child.parent is not None:\n                child.parent.remove_child(child)\n            child.parent = new_parent\n            child.cost = new_cost\n            new_parent.add_child(child)\n\n        def propagate_costs(node):\n            for c in node.children:\n                new_cost = node.cost + math.dist(node.position, c.position)\n                if new_cost + 1e-10 < c.cost:\n                    update_parent(c, node, new_cost)\n                    propagate_costs(c)\n\n        def extract_path(n_start, n_goal):\n            path_start = []\n            n = n_start\n            while n is not None:\n                path_start.append(n.position)\n                n = n.parent\n            path_goal = []\n            n = n_goal\n            while n is not None:\n                path_goal.append(n.position)\n                n = n.parent\n            # Remove duplicate connecting node\n            if path_start[-1] == path_goal[-1]:\n                path_goal.pop()\n            return path_start[::-1] + path_goal\n\n        def incremental_shortcut(path):\n            if len(path) < 3:\n                return path[:]\n            shortcut_path = path[:]\n            attempts = 0\n            while attempts < self.max_shortcut_attempts:\n                if len(shortcut_path) < 3:\n                    break\n                i = random.randint(0, len(shortcut_path) - 3)\n                j = random.randint(i + 2, len(shortcut_path) - 1)\n                if not is_edge_in_obstacle(shortcut_path[i], shortcut_path[j]):\n                    shortcut_path = shortcut_path[: i + 1] + shortcut_path[j:]\n                    attempts = 0\n                else:\n                    attempts += 1\n            return shortcut_path\n\n        def sample_informed():\n            if best_cost == float('inf') or best_cost <= c_min:\n                while True:\n                    pt = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                    if not is_in_obstacle(pt):\n                        return pt\n            center = tuple(0.5 * (start_pos[i] + goal_pos[i]) for i in range(dim))\n            direction = [goal_pos[i] - start_pos[i] for i in range(dim)]\n            length = c_min\n            if dim == 2:\n                if length < 1e-12:\n                    R = [[1, 0], [0, 1]]\n                else:\n                    a1 = [1, 0]\n                    a2 = [direction[0] / length, direction[1] / length]\n                    cos_theta = a1[0] * a2[0] + a1[1] * a2[1]\n                    sin_theta = a1[0] * a2[1] - a1[1] * a2[0]\n                    R = [[cos_theta, -sin_theta], [sin_theta, cos_theta]]\n            else:\n                if length < 1e-12:\n                    R = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n                else:\n                    a1 = [1, 0, 0]\n                    a2 = [direction[i] / length for i in range(3)]\n                    v = [\n                        a1[1] * a2[2] - a1[2] * a2[1],\n                        a1[2] * a2[0] - a1[0] * a2[2],\n                        a1[0] * a2[1] - a1[1] * a2[0],\n                    ]\n                    s = math.sqrt(sum(vi * vi for vi in v))\n                    c = sum(a1[i] * a2[i] for i in range(3))\n                    if s < 1e-12:\n                        R = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n                    else:\n                        vx = [\n                            [0, -v[2], v[1]],\n                            [v[2], 0, -v[0]],\n                            [-v[1], v[0], 0],\n                        ]\n                        I = [[1 if i == j else 0 for j in range(3)] for i in range(3)]\n                        vx2 = [\n                            [\n                                sum(vx[i][k] * vx[k][j] for k in range(3))\n                                for j in range(3)\n                            ]\n                            for i in range(3)\n                        ]\n                        R = [\n                            [\n                                I[i][j] + vx[i][j] + vx2[i][j] * ((1 - c) / (s * s))\n                                for j in range(3)\n                            ]\n                            for i in range(3)\n                        ]\n\n            a1_val = best_cost * 0.5\n            a_other = math.sqrt(max(best_cost * best_cost - c_min * c_min, 0.0)) * 0.5\n            while True:\n                if dim == 2:\n                    r = random.uniform(0, 1) ** 0.5\n                    theta = random.uniform(0, 2 * math.pi)\n                    x_ball = [r * math.cos(theta), r * math.sin(theta)]\n                    L = [[a1_val, 0], [0, a_other]]\n                    x_scaled = [\n                        L[0][0] * x_ball[0] + L[0][1] * x_ball[1],\n                        L[1][0] * x_ball[0] + L[1][1] * x_ball[1],\n                    ]\n                    pt = (\n                        center[0] + R[0][0] * x_scaled[0] + R[0][1] * x_scaled[1],\n                        center[1] + R[1][0] * x_scaled[0] + R[1][1] * x_scaled[1],\n                    )\n                else:\n                    while True:\n                        x_ball = [random.uniform(-1, 1) for _ in range(3)]\n                        if sum(xi * xi for xi in x_ball) <= 1:\n                            break\n                    L = [[a1_val, 0, 0], [0, a_other, 0], [0, 0, a_other]]\n                    x_scaled = [\n                        L[0][0] * x_ball[0],\n                        L[1][1] * x_ball[1],\n                        L[2][2] * x_ball[2],\n                    ]\n                    pt = tuple(\n                        center[i] + sum(R[i][j] * x_scaled[j] for j in range(dim))\n                        for i in range(dim)\n                    )\n                if any(pt[d] < 0 or pt[d] > bounds[d] for d in range(dim)):\n                    continue\n                if is_in_obstacle(pt):\n                    continue\n                return pt\n\n        def attempt_extend(tree_a, tree_b, sample):\n            nearest_node = nearest(tree_a, sample)\n            new_pos = steer(nearest_node.position, sample)\n            if any(new_pos[i] < 0 or new_pos[i] > bounds[i] for i in range(dim)):\n                return None\n            if is_in_obstacle(new_pos) or is_edge_in_obstacle(nearest_node.position, new_pos):\n                return None\n\n            radius = near_radius(len(tree_a))\n            near_nodes = near(tree_a, new_pos, radius)\n\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            min_parent = nearest_node\n            for node in near_nodes:\n                c_new = node.cost + math.dist(node.position, new_pos)\n                if c_new + 1e-10 < min_cost and not is_edge_in_obstacle(node.position, new_pos):\n                    min_cost = c_new\n                    min_parent = node\n\n            new_node = Node(new_pos, min_parent, min_cost)\n            min_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((min_parent, new_node))\n\n            for node in near_nodes:\n                if node is min_parent:\n                    continue\n                c_through = new_node.cost + math.dist(new_node.position, node.position)\n                if c_through + 1e-10 < node.cost and not is_edge_in_obstacle(new_node.position, node.position):\n                    update_parent(node, new_node, c_through)\n                    propagate_costs(node)\n                    if node.parent is not None:\n                        try:\n                            edges.remove((node.parent, node))\n                        except ValueError:\n                            pass\n                    edges.append((new_node, node))\n\n            nearest_other = nearest(tree_b, new_node.position)\n            dist_connect = math.dist(new_node.position, nearest_other.position)\n            if (\n                dist_connect <= self.step_size\n                and not is_edge_in_obstacle(new_node.position, nearest_other.position)\n            ):\n                total_cost = new_node.cost + dist_connect + nearest_other.cost\n                return new_node, nearest_other, total_cost\n            return None\n\n        for it in range(self.max_iter):\n            sample = sample_informed()\n            # Alternate tree roles to maintain bidirectionality\n            for (tree_a, tree_b) in [(start_nodes, goal_nodes), (goal_nodes, start_nodes)]:\n                res = attempt_extend(tree_a, tree_b, sample)\n                if res is not None:\n                    new_node, connect_node, cost_path = res\n                    if cost_path < best_cost:\n                        best_cost = cost_path\n                        sol_start, sol_goal = (\n                            (new_node, connect_node)\n                            if tree_a is start_nodes\n                            else (connect_node, new_node)\n                        )\n\n            if best_cost < float(\"inf\") and sol_start is not None and sol_goal is not None:\n                if it % self.shortcut_freq == 0 or it == self.max_iter - 1:\n                    raw_path = extract_path(sol_start, sol_goal)\n                    improved_path = incremental_shortcut(raw_path)\n                    if improved_path and len(improved_path) >= 2:\n                        return PlannerResult(True, improved_path, nodes, edges)\n\n        return PlannerResult(False, [], nodes, edges)",
          "objective": -31.90769,
          "time_improvement": 48.0,
          "length_improvement": 15.0,
          "smoothness_improvement": 1713.0,
          "node_improvement": 77.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.018351244926452636,
                    "num_nodes_avg": 106.7,
                    "path_length_avg": 166.32115349423978,
                    "smoothness_avg": 0.045429712971989604,
                    "success_improvement": 0.0,
                    "time_improvement": 28.845800073030155,
                    "node_improvement": 73.13019390581718,
                    "length_improvement": 8.836740242474923,
                    "smoothness_improvement": 611.0736602123392,
                    "objective_score": 17.0111524684557
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.053799915313720706,
                    "num_nodes_avg": 275.9,
                    "path_length_avg": 244.29920467196445,
                    "smoothness_avg": 0.11771383242798397,
                    "success_improvement": 0.0,
                    "time_improvement": 67.50735951830073,
                    "node_improvement": 81.46207081905531,
                    "length_improvement": 18.445893717778457,
                    "smoothness_improvement": 2928.861694218456,
                    "objective_score": 45.96405255724957
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.02596104145050049,
                    "num_nodes_avg": 190.7,
                    "path_length_avg": 125.21405267786288,
                    "smoothness_avg": 0.1335209899284163,
                    "success_improvement": 0.0,
                    "time_improvement": 48.842395856970974,
                    "node_improvement": 75.75333757151938,
                    "length_improvement": 16.83878826381995,
                    "smoothness_improvement": 1598.3771363951587,
                    "objective_score": 32.747877397359055
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "cross_over",
          "algorithm_description": "An improved bidirectional RRT* planner using informed ellipsoidal sampling focused around the best current solution for efficient exploration, adaptive rewiring with cost-to-come heuristics, and deterministic global shortcutting applied iteratively to quickly refine path smoothness and length. The planner maintains two trees from start and goal, alternates expansions with goal bias, updates an ellipsoidal sampling region as better paths emerge to aggressively prune sampling space, reduces redundant collision checks by caching nearest neighbor queries, and performs rewiring within a dynamically scaled radius to ensure asymptotic optimality. The global shortcutting applies systematic path segment pruning to remove unnecessary waypoints and sharp turns, yielding shorter, smoother paths with markedly lower search times compared to na\u00efve uniform sampling and incremental shortcutting. Termination occurs upon first successful connection or maximum iterations, returning the best feasible smoothed path found.",
          "planning_mechanism": "The mechanism grows two trees bidirectionally, samples new points inside an ellipsoid constrained by current best path cost to bias search towards promising regions, rewires neighbors efficiently with cost comparisons, connects trees when close, and performs repeated deterministic global shortcutting on the path to rapidly improve smoothness and reduce length while minimizing collision checks and maintaining high planning efficiency.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except ValueError:\n            pass\n\n    def path_from_root(self):\n        node, path = self, []\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=4000, step_size=5.0, base_radius=18.0, goal_sample_rate=0.15, shortcut_iterations=50):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.base_radius = base_radius\n        self.goal_sample_rate = goal_sample_rate\n        self.shortcut_iterations = shortcut_iterations\n\n    def plan(self, map) -> 'PlannerResult':\n        import random, math\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        start_tree = [Node(start_pos, cost=0.0)]\n        goal_tree = [Node(goal_pos, cost=0.0)]\n        nodes = list(start_tree) + list(goal_tree)\n        edges = []\n\n        def dist(a, b):\n            # Euclidean distance\n            return math.dist(a, b)\n\n        def steer(fr, to):\n            d = dist(fr, to)\n            if d <= self.step_size:\n                return to\n            ratio = self.step_size / d\n            return tuple(fr[i] + (to[i] - fr[i]) * ratio for i in range(dim))\n\n        def is_in_obstacle(p):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d_ = obs\n                    px, py, pz = p\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d_:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    px, py = p\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(fr, to, resolution=1.0):\n            d = dist(fr, to)\n            steps = max(1, int(d / resolution))\n            for i in range(steps + 1):\n                interp = tuple(fr[j] + (to[j] - fr[j]) * i / steps for j in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def nearest(tree, point):\n            # Linear nearest neighbor search\n            nearest_node = None\n            min_d = float('inf')\n            for node in tree:\n                d = dist(node.position, point)\n                if d < min_d:\n                    min_d = d\n                    nearest_node = node\n            return nearest_node\n\n        def near_nodes(tree, point, radius):\n            r2 = radius * radius\n            result = []\n            for node in tree:\n                # Squared distance quick check\n                cd = 0.0\n                for i in range(dim):\n                    diff = node.position[i] - point[i]\n                    cd += diff * diff\n                    if cd > r2:\n                        break\n                else:\n                    result.append(node)\n            return result\n\n        def path_cost(path_positions):\n            # Sum of distances between consecutive points\n            cost = 0.0\n            for i in range(len(path_positions) - 1):\n                cost += dist(path_positions[i], path_positions[i+1])\n            return cost\n\n        def extract_path(node_from_start, node_from_goal):\n            path_start = node_from_start.path_from_root()\n            path_goal = node_from_goal.path_from_root()[::-1]\n            if len(path_start) > 0 and len(path_goal) > 0 and path_start[-1] == path_goal[0]:\n                path_goal = path_goal[1:]\n            return path_start + path_goal\n\n        def base_sample():\n            # Uniform random sampling within bounds\n            return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n\n        def ellipsoidal_sample(c_best, start, goal):\n            # Sample uniformly inside the ellipsoid defined by start, goal and radius c_best\n            # Align ellipsoid along axis from start to goal\n            if c_best == float('inf'):\n                return base_sample()\n\n            center = tuple((start[i] + goal[i]) * 0.5 for i in range(dim))\n            dx = goal[0] - start[0]\n            dy = goal[1] - start[1]\n            dz = goal[2] - start[2] if is_3d else 0.0\n            c_min = dist(start, goal)\n            if c_best < c_min:\n                c_best = c_min  # Prevent degenerate cases\n\n            # Scale factors for axes (primary axis length half is c_best/2, others sqrt difference)\n            if dim == 2:\n                r1 = c_best / 2.0\n                r2 = math.sqrt(c_best ** 2 - c_min ** 2) / 2.0 if c_best ** 2 > c_min ** 2 else 0.0\n\n                # Sample random point in unit circle\n                while True:\n                    x = random.uniform(-1, 1)\n                    y = random.uniform(-1, 1)\n                    if x * x + y * y <= 1.0:\n                        break\n\n                # Rotate and scale\n                theta = math.atan2(dy, dx)\n                samp_x = r1 * x * math.cos(theta) - r2 * y * math.sin(theta) + center[0]\n                samp_y = r1 * x * math.sin(theta) + r2 * y * math.cos(theta) + center[1]\n                sample = (samp_x, samp_y)\n\n            else:  # dim==3\n                # Use rejection sampling inside unit sphere then scale\n                r1 = c_best / 2.0\n                r2 = math.sqrt(c_best ** 2 - c_min ** 2) / 2.0 if c_best ** 2 > c_min ** 2 else 0.0\n\n                while True:\n                    x = random.uniform(-1, 1)\n                    y = random.uniform(-1, 1)\n                    z = random.uniform(-1, 1)\n                    if x * x + y * y + z * z <= 1.0:\n                        break\n\n                # Compute rotation aligning x axis to vector from start to goal\n                from_axis = (1.0, 0.0, 0.0)\n                to_axis = (dx, dy, dz)\n                length = math.sqrt(dx * dx + dy * dy + dz * dz)\n                if length == 0:\n                    rot_sample = (0.0, 0.0, 0.0)\n                else:\n                    ux, uy, uz = to_axis[0] / length, to_axis[1] / length, to_axis[2] / length\n                    # Rotation required aligns x axis to (ux, uy, uz)\n                    # Use Rodrigues formula for rotation of (x, y, z)\n                    # Vector to rotate:\n                    vx, vy, vz = (x, y, z)\n                    cos_theta = ux\n                    sin_theta = math.sqrt(1 - ux * ux)\n                    # If cos_theta ~ 1 or -1, rotation axis arbitrary, handle these edge cases:\n                    if abs(ux - 1) < 1e-8:\n                        rot_sample = (r1 * vx + center[0], r2 * vy + center[1], r2 * vz + center[2])\n                    elif abs(ux + 1) < 1e-8:\n                        rot_sample = (r1 * -vx + center[0], r2 * -vy + center[1], r2 * -vz + center[2])\n                    else:\n                        # Rotation axis\n                        ax = 0.0\n                        ay = uz\n                        az = -uy\n                        # Rodrigues rotation formula\n                        kx, ky, kz = ax, ay, az\n                        v_dot_k = vx * kx + vy * ky + vz * kz\n                        cross_x = ky * vz - kz * vy\n                        cross_y = kz * vx - kx * vz\n                        cross_z = kx * vy - ky * vx\n                        rot_x = vx * cos_theta + cross_x * sin_theta + kx * v_dot_k * (1 - cos_theta)\n                        rot_y = vy * cos_theta + cross_y * sin_theta + ky * v_dot_k * (1 - cos_theta)\n                        rot_z = vz * cos_theta + cross_z * sin_theta + kz * v_dot_k * (1 - cos_theta)\n                        rot_sample = (r1 * rot_x + center[0], r2 * rot_y + center[1], r2 * rot_z + center[2])\n\n                sample = rot_sample\n\n            # Clamp samples to map bounds to prevent stepping outside\n            clamped = tuple(max(0.0, min(sample[i], bounds[i])) for i in range(dim))\n            return clamped\n\n        def sample_point(c_best, has_path):\n            # With probability goal_sample_rate, sample goal directly\n            if random.random() < self.goal_sample_rate:\n                return goal_pos\n            # If have a path with cost c_best, sample within ellipsoid\n            if has_path and c_best < float('inf'):\n                return ellipsoidal_sample(c_best, start_pos, goal_pos)\n            # Otherwise uniform sampling\n            return base_sample()\n\n        def adaptive_radius(tree_size):\n            n = max(tree_size, 1)\n            radius = self.base_radius * (math.log(n) / n) ** (1.0 / dim)\n            min_radius = self.step_size * 1.5\n            return max(radius, min_radius)\n\n        def rewire(tree, new_node, near_nodes_):\n            nonlocal edges\n            for near in near_nodes_:\n                if near == new_node.parent:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, near.position)\n                if new_cost + 1e-10 < near.cost:\n                    if not is_edge_in_obstacle(new_node.position, near.position):\n                        if near.parent is not None:\n                            try:\n                                edges.remove((near.parent, near))\n                                near.parent.remove_child(near)\n                            except Exception:\n                                pass\n                        near.parent = new_node\n                        near.cost = new_cost\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n\n        def global_shortcut(path):\n            # Deterministic global shortcut: systematically attempt shortcuts on all pairs (i,j) with j>i+1\n            if len(path) < 3:\n                return path[:]\n            new_path = path[:]\n            improved = True\n            while improved:\n                improved = False\n                i = 0\n                while i < len(new_path) - 2:\n                    j = len(new_path) - 1\n                    while j > i + 1:\n                        p1 = new_path[i]\n                        p2 = new_path[j]\n                        if not is_edge_in_obstacle(p1, p2):\n                            # Shortcut found: remove intermediate nodes (i+1) to (j-1)\n                            new_path = new_path[:i+1] + new_path[j:]\n                            improved = True\n                            j = i + 1  # Break inner loop\n                        else:\n                            j -= 1\n                    i += 1\n            return new_path\n\n        success = False\n        connection_node_start = None\n        connection_node_goal = None\n        best_cost = float('inf')\n        best_path = []\n\n        for itr in range(self.max_iter):\n            # Alternate tree expansions start->goal and goal->start per iteration\n            for (tree_a, tree_b) in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                # Calculate current best cost for ellipsoidal sampling\n                has_path = best_cost < float('inf')\n                q_rand = sample_point(best_cost, has_path)\n                nearest_node = nearest(tree_a, q_rand)\n                new_pos = steer(nearest_node.position, q_rand)\n                if is_in_obstacle(new_pos):\n                    continue\n                if is_edge_in_obstacle(nearest_node.position, new_pos):\n                    continue\n\n                radius = adaptive_radius(len(tree_a))\n                neighbors = near_nodes(tree_a, new_pos, radius)\n\n                # Choose optimal parent minimizing cost-to-come\n                min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n                min_parent = nearest_node\n                for near_node in neighbors:\n                    c = near_node.cost + dist(near_node.position, new_pos)\n                    if c < min_cost and not is_edge_in_obstacle(near_node.position, new_pos):\n                        min_cost = c\n                        min_parent = near_node\n\n                q_new = Node(new_pos, parent=min_parent, cost=min_cost)\n                min_parent.add_child(q_new)\n                tree_a.append(q_new)\n                nodes.append(q_new)\n                edges.append((min_parent, q_new))\n\n                # Rewire neighbors for possible cost improvements\n                rewire(tree_a, q_new, neighbors)\n\n                # Attempt connection to other tree\n                nearest_other = nearest(tree_b, new_pos)\n                dist_connect = dist(new_pos, nearest_other.position)\n                radius_connect = max(self.step_size * 1.5, adaptive_radius(len(tree_b)))\n\n                if dist_connect <= radius_connect and not is_edge_in_obstacle(new_pos, nearest_other.position):\n                    # Connected trees: attempt to improve path by considering this connection\n                    if tree_a is start_tree:\n                        n_start, n_goal = q_new, nearest_other\n                    else:\n                        n_start, n_goal = nearest_other, q_new\n\n                    raw_path = extract_path(n_start, n_goal)\n                    if len(raw_path) >= 2:\n                        cost_path = path_cost(raw_path)\n                        if cost_path < best_cost:\n                            best_cost = cost_path\n                            # Global shortcut to produce smooth, short path\n                            best_path = global_shortcut(raw_path)\n                            connection_node_start, connection_node_goal = n_start, n_goal\n                            success = True\n                    # Since we want first good path quickly, can break early once improvement found\n                    break\n            if success:\n                # Continue searching but allow early stop for speed\n                # Here terminate at first successful improved connection for efficiency\n                break\n\n        if success:\n            return PlannerResult(True, best_path, nodes, edges)\n        else:\n            # No path found; return empty path but provide all built nodes and edges\n            return PlannerResult(False, [], nodes, edges)",
          "objective": -31.83186,
          "time_improvement": 48.0,
          "length_improvement": 15.0,
          "smoothness_improvement": 1636.0,
          "node_improvement": 64.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.02123703956604004,
                    "num_nodes_avg": 180.3,
                    "path_length_avg": 167.572658560125,
                    "smoothness_avg": 0.047788405227228936,
                    "success_improvement": 0.0,
                    "time_improvement": 17.656564162533677,
                    "node_improvement": 54.595819692772594,
                    "length_improvement": 8.150770484496393,
                    "smoothness_improvement": 647.9923159890471,
                    "objective_score": 13.427393119403176
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.027323031425476076,
                    "num_nodes_avg": 314.6,
                    "path_length_avg": 236.2129776057622,
                    "smoothness_avg": 0.10772130955245669,
                    "success_improvement": 0.0,
                    "time_improvement": 83.49816292830208,
                    "node_improvement": 78.86178861788616,
                    "length_improvement": 21.145309061617738,
                    "smoothness_improvement": 2671.7468833078296,
                    "objective_score": 51.095368732000416
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.029190969467163087,
                    "num_nodes_avg": 334.6,
                    "path_length_avg": 124.73309822440301,
                    "smoothness_avg": 0.132620076074274,
                    "success_improvement": 0.0,
                    "time_improvement": 42.47765200792487,
                    "node_improvement": 57.45708836617928,
                    "length_improvement": 17.15821531121801,
                    "smoothness_improvement": 1586.917578669012,
                    "objective_score": 30.972812682453327
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "cross_over",
          "algorithm_description": "This algorithm introduces a Spatial Hash Accelerated Bidirectional RRT* with Adaptive Radius and Focused Adaptive Sampling. It integrates a spatial hashing structure for fast nearest neighbor and rewiring searches to reduce planning time. It employs an adaptive informed sampling distribution that dynamically tightens around the best found path cost to minimize path length. The adaptive rewiring radius allows more effective neighborhood rewiring, while enhanced shortcut smoothing aggressively reduces path length and increases smoothness. Early termination occurs once a path within a cost threshold is found, and collision checks are performed minimally.",
          "planning_mechanism": "The planner grows two trees simultaneously and maintains spatial hash grids for efficient neighborhood queries. Sampling is adaptively informed within an elliptical region scaled by the best cost, improving efficiency by focusing exploration. Rewiring uses the spatial hash for quick neighbor retrieval, reducing planning time. Once connected, it extracts the path and applies an iterative shortcutting procedure to improve smoothness and path length while respecting collisions. This approach balances exploration and exploitation to achieve faster convergence, shorter, and smoother paths.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=4000, step_size=6.0, base_radius=22.0, goal_sample_rate=0.12, shortcut_iterations=300, grid_cell_size=12.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.base_radius = base_radius\n        self.goal_sample_rate = goal_sample_rate\n        self.shortcut_iterations = shortcut_iterations\n        self.grid_cell_size = grid_cell_size\n\n    def plan(self, map):\n        import math, random\n\n        bounds = map.size\n        dim = len(bounds)\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is3d = (dim == 3)\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        def dist(a,b):\n            return math.dist(a,b)\n\n        def steer(fr, to):\n            d = dist(fr, to)\n            if d <= self.step_size:\n                return to\n            ratio = self.step_size/d\n            return tuple(fr[i] + (to[i]-fr[i])*ratio for i in range(dim))\n\n        def is_in_obstacle(p):\n            x,y = p[0], p[1]\n            if is3d:\n                z = p[2]\n                for obs in obstacles:\n                    ox,oy,oz,w,h,d_ = obs\n                    if ox <= x <= ox+w and oy <= y <= oy+h and oz <= z <= oz+d_:\n                        return True\n            else:\n                for obs in obstacles:\n                    ox,oy,w,h = obs\n                    if ox <= x <= ox+w and oy <= y <= oy+h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(fr, to, resolution=1.0):\n            d = dist(fr,to)\n            steps = max(1, int(d/resolution))\n            for i in range(steps+1):\n                interp = tuple(fr[j]+(to[j]-fr[j])*i/steps for j in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        #### Spatial Hashing for fast neighbor queries ####\n        class SpatialHash:\n            def __init__(self, bounds, cell_size):\n                self.cell_size = cell_size\n                self.inv = 1.0/cell_size\n                self.cells = {}\n                self.bounds = bounds\n            def _hash(self, point):\n                return tuple(int(point[i]*self.inv) for i in range(dim))\n            def insert(self, node):\n                h = self._hash(node.position)\n                if h not in self.cells:\n                    self.cells[h] = []\n                self.cells[h].append(node)\n            def remove(self, node):\n                h = self._hash(node.position)\n                if h in self.cells and node in self.cells[h]:\n                    self.cells[h].remove(node)\n                    if not self.cells[h]:\n                        del self.cells[h]\n            def neighbors(self, point, radius):\n                base = self._hash(point)\n                ir = int(math.ceil(radius*self.inv))\n                result = []\n                for dx in range(-ir, ir+1):\n                    for dy in range(-ir, ir+1):\n                        # 3D support if needed\n                        if dim == 3:\n                            for dz in range(-ir, ir+1):\n                                cell = (base[0]+dx, base[1]+dy, base[2]+dz)\n                                if cell in self.cells:\n                                    result.extend(self.cells[cell])\n                        else:\n                            cell = (base[0]+dx, base[1]+dy)\n                            if cell in self.cells:\n                                result.extend(self.cells[cell])\n                # filter by actual distance\n                return [n for n in result if dist(n.position, point) <= radius]\n\n        # Initialize spatial hash grids for both trees\n        sh_start = SpatialHash(bounds, self.grid_cell_size)\n        sh_goal = SpatialHash(bounds, self.grid_cell_size)\n        for n in start_tree:\n            sh_start.insert(n)\n        for n in goal_tree:\n            sh_goal.insert(n)\n\n        def adaptive_radius(tree_size):\n            n = max(tree_size,1)\n            return max(self.base_radius * (math.log(n)/n)**(1.0/dim), self.step_size*1.7)\n\n        # Informed sampling inside ellipsoid parameterized by cost and start-goal spread\n        def informed_sample(c_best, c_min, start, goal):\n            if c_best == float('inf'):\n                return tuple(random.uniform(0,bounds[i]) for i in range(dim))\n            # Ellipsoidal informed sampling\n            import numpy as np\n            c = c_best\n            center = np.array([(start[i]+goal[i])/2 for i in range(dim)])\n            a1 = (np.array(goal)-np.array(start))/c_min\n            if dim == 2:\n                theta = math.atan2(a1[1], a1[0])\n                R = np.array([[math.cos(theta), -math.sin(theta)],\n                              [math.sin(theta),  math.cos(theta)]])\n                while True:\n                    x,y = random.uniform(-1,1), random.uniform(-1,1)\n                    if x*x + y*y > 1:\n                        continue\n                    rx = c/2\n                    ry = math.sqrt(c*c - c_min*c_min)/2\n                    sample = np.array([x*rx, y*ry])\n                    point = R.dot(sample) + center\n                    if all(0 <= point[i] <= bounds[i] for i in range(dim)):\n                        return tuple(point.tolist())\n            else:\n                # fallback uniform sampling for 3D+\n                return tuple(random.uniform(0,bounds[i]) for i in range(dim))\n\n        def nearest(tree_spatialhash, tree_list, point):\n            candidates = tree_spatialhash.neighbors(point, self.grid_cell_size*3)\n            if candidates:\n                return min(candidates, key=lambda n: dist(n.position, point))\n            # fallback linear\n            return min(tree_list, key=lambda n: dist(n.position, point))\n\n        def rewire(tree_list, tree_spatialhash, new_node, radius):\n            nonlocal edges\n            neighbors = tree_spatialhash.neighbors(new_node.position, radius)\n            for near in neighbors:\n                if near is new_node.parent:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, near.position)\n                if new_cost + 1e-10 < near.cost:\n                    if not is_edge_in_obstacle(new_node.position, near.position):\n                        # Remove old edge\n                        if near.parent:\n                            try:\n                                edges.remove((near.parent, near))\n                            except Exception:\n                                pass\n                            near.parent.children.remove(near) if near.parent else None\n                        near.parent = new_node\n                        near.cost = new_cost\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n\n        def extract_path(node_s, node_g):\n            path_s = node_s.path_from_root()\n            path_g = node_g.path_from_root()[::-1]\n            if len(path_s) > 0 and len(path_g) >0 and path_s[-1] == path_g[0]:\n                path_g = path_g[1:]\n            return path_s + path_g\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.shortcut_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path)-3)\n                j = random.randint(i+2, len(path)-1)\n                p1, p2 = path[i], path[j]\n                if not is_edge_in_obstacle(p1, p2):\n                    path = path[:i+1]+path[j:]\n            return path\n\n        best_cost = float('inf')\n        best_pair = (None,None)\n        success = False\n        c_min = dist(start_pos, goal_pos)\n\n        for iter in range(self.max_iter):\n            # Early termination heuristic: if found path close to straight-line cost\n            if best_cost < c_min * 1.05:\n                break\n            for tree_a, tree_b, sh_a, sh_b in [(start_tree, goal_tree, sh_start, sh_goal), \n                                               (goal_tree, start_tree, sh_goal, sh_start)]:\n                if success:\n                    break\n\n                r = random.random()\n                if r < self.goal_sample_rate:\n                    q_rand = goal_pos if tree_a is start_tree else start_pos\n                else:\n                    q_rand = informed_sample(best_cost, c_min, start_pos, goal_pos)\n\n                nearest_node = nearest(sh_a, tree_a, q_rand)\n                q_new_pos = steer(nearest_node.position, q_rand)\n\n                if is_in_obstacle(q_new_pos):\n                    continue\n                if is_edge_in_obstacle(nearest_node.position, q_new_pos):\n                    continue\n\n                radius = adaptive_radius(len(tree_a))\n                # Find neighbor nodes fast via spatial hash\n                near_nodes_list = sh_a.neighbors(q_new_pos, radius)\n\n                # Find best parent minimizing cost\n                min_cost = nearest_node.cost + dist(nearest_node.position, q_new_pos)\n                min_parent = nearest_node\n                for near in near_nodes_list:\n                    c = near.cost + dist(near.position, q_new_pos)\n                    if c + 1e-10 < min_cost and not is_edge_in_obstacle(near.position, q_new_pos):\n                        min_cost = c\n                        min_parent = near\n\n                q_new = Node(q_new_pos, parent=min_parent, cost=min_cost)\n                min_parent.add_child(q_new)\n                tree_a.append(q_new)\n                sh_a.insert(q_new)\n                nodes.append(q_new)\n                edges.append((min_parent, q_new))\n\n                rewire(tree_a, sh_a, q_new, radius)\n\n                # Try connect other tree\n                nearest_other = nearest(sh_b, tree_b, q_new.position)\n                dist_connect = dist(q_new.position, nearest_other.position)\n                connect_radius = max(self.step_size*1.7, adaptive_radius(len(tree_b)))\n                if dist_connect <= connect_radius and not is_edge_in_obstacle(q_new.position, nearest_other.position):\n                    cost_connect = q_new.cost + dist(q_new.position, nearest_other.position) + nearest_other.cost\n                    if cost_connect + 1e-10 < best_cost:\n                        best_cost = cost_connect\n                        best_pair = (q_new, nearest_other)\n                        success = True\n            if success and iter > self.max_iter*0.1:\n                # Continue a small extra iterations for slight betterment\n                if iter > self.max_iter*0.15:\n                    break\n\n        path = []\n        if success and best_pair[0] and best_pair[1]:\n            raw_path = extract_path(best_pair[0], best_pair[1])\n            path = shortcut_path(raw_path)\n        else:\n            return PlannerResult(False, [], nodes, edges)\n\n        return PlannerResult(True, path, nodes, edges)",
          "objective": -31.81134,
          "time_improvement": 50.0,
          "length_improvement": 17.0,
          "smoothness_improvement": 1372.0,
          "node_improvement": 79.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.016625070571899415,
                    "num_nodes_avg": 64.2,
                    "path_length_avg": 166.43166745781613,
                    "smoothness_avg": 0.0416940286392796,
                    "success_improvement": 0.0,
                    "time_improvement": 35.538782245353566,
                    "node_improvement": 83.83278771090406,
                    "length_improvement": 8.776165787832905,
                    "smoothness_improvement": 552.6020882370593,
                    "objective_score": 18.69034458749111
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.030925655364990236,
                    "num_nodes_avg": 212.2,
                    "path_length_avg": 233.60822219195128,
                    "smoothness_avg": 0.08763952290266744,
                    "success_improvement": 0.0,
                    "time_improvement": 81.32234603761,
                    "node_improvement": 85.74212188402875,
                    "length_improvement": 22.014851392475375,
                    "smoothness_improvement": 2155.0280484824807,
                    "objective_score": 48.38075488918063
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.03398807048797607,
                    "num_nodes_avg": 257.3,
                    "path_length_avg": 121.92044988846314,
                    "smoothness_avg": 0.11855062825412302,
                    "success_improvement": 0.0,
                    "time_improvement": 33.02471093370844,
                    "node_improvement": 67.28544183089639,
                    "length_improvement": 19.0262424120281,
                    "smoothness_improvement": 1407.9552408953039,
                    "objective_score": 28.36293493180591
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e2",
          "algorithm_description": "A bidirectional RRT* variant integrating adaptive rewiring radius guided by node density and path quality, combined with a hybrid sampling strategy mixing uniform and ellipsoidal informed samples. It performs dynamic rewiring and attempts early tree connections with adaptive connection radius, continuously refining the best solution with combined local incremental and periodic global shortcutting to achieve efficient planning, better path optimality, and smoother trajectories.",
          "planning_mechanism": "The planner grows two trees bidirectionally, sampling points from a hybrid distribution that balances global exploration and focused exploitation within an informed ellipsoid according to the current best path cost. It adaptively adjusts rewiring and connection radii based on node density and best path cost to efficiently optimize local neighborhoods. Each extension attempts to connect the two trees dynamically, updating the solution as better paths are found. The planner interleaves incremental shortcutting on improved paths and performs batch global smoothing periodically to enhance path smoothness and reduce length while maintaining collision-free constraints.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except ValueError:\n            pass\nclass Planner:\n    def __init__(self, max_iter=6000, step_size=6.0, gamma=35.0,\n                 shortcut_incremental_freq=20, shortcut_global_freq=150,\n                 max_incremental_attempts=30):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.gamma = gamma\n        self.shortcut_incremental_freq = shortcut_incremental_freq\n        self.shortcut_global_freq = shortcut_global_freq\n        self.max_incremental_attempts = max_incremental_attempts\n\n    def plan(self, map):\n        import math\n        import random\n\n        bounds = map.size\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        obstacles = map.obstacles\n        start_pos = map.start\n        goal_pos = map.goal\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        best_cost = float('inf')\n        best_sol_nodes = None  # pair (node_start, node_goal)\n        c_min = math.dist(start_pos, goal_pos)\n        unit_ball_vol = self._unit_ball_volume(dim)\n\n        def adapt_radius(num_nodes, cost):\n            if num_nodes <= 1:\n                return self.step_size * 3.0\n            radius = self.gamma * (math.log(num_nodes) / num_nodes) ** (1.0 / dim)\n            max_radius = self.step_size * 40.0\n            if cost == float('inf'):\n                return min(radius, max_radius)\n            # Shrink radius as solution cost decreases\n            radius = min(radius, max_radius, cost * 0.5)\n            return max(radius, self.step_size * 1.5)\n\n        def sample_hybrid():\n            # Blend 30% informed ellipsoidal, 70% uniform sampling\n            if best_cost == float('inf') or best_cost <= c_min:\n                return self._sample_free(bounds, obstacles, is_3d)\n            if random.random() < 0.3:\n                # informed ellipsoidal sampling\n                center = tuple((start_pos[i] + goal_pos[i]) * 0.5 for i in range(dim))\n                direction = [goal_pos[i] - start_pos[i] for i in range(dim)]\n                length = math.dist(start_pos, goal_pos)\n                if dim == 2:\n                    if length < 1e-12:\n                        R = [[1, 0], [0, 1]]\n                    else:\n                        a1 = [1, 0]\n                        a2 = [direction[0] / length, direction[1] / length]\n                        cos_theta = a1[0]*a2[0] + a1[1]*a2[1]\n                        sin_theta = a1[0]*a2[1] - a1[1]*a2[0]\n                        R = [[cos_theta, -sin_theta], [sin_theta, cos_theta]]\n                else:\n                    # 3D rotation matrix R that aligns a1 to direction vector a2\n                    if length < 1e-12:\n                        R = [[1,0,0],[0,1,0],[0,0,1]]\n                    else:\n                        a1 = [1, 0, 0]\n                        a2 = [direction[i]/length for i in range(3)]\n                        v = [a1[1]*a2[2]-a1[2]*a2[1], a1[2]*a2[0]-a1[0]*a2[2], a1[0]*a2[1]-a1[1]*a2[0]]\n                        s = math.sqrt(v[0]*v[0]+v[1]*v[1]+v[2]*v[2])\n                        c = sum(a1[i]*a2[i] for i in range(3))\n                        if s<1e-12:\n                            R = [[1,0,0],[0,1,0],[0,0,1]]\n                        else:\n                            vx = [[0,-v[2],v[1]], [v[2],0,-v[0]], [-v[1],v[0],0]]\n                            I = [[1 if i==j else 0 for j in range(3)] for i in range(3)]\n                            vx2 = [[sum(vx[i][k]*vx[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n                            R = [[I[i][j] + vx[i][j] + vx2[i][j]*((1-c)/(s*s)) for j in range(3)] for i in range(3)]\n                a1_val = best_cost*0.5\n                a_orth = 0.5*math.sqrt(max(best_cost*best_cost - c_min*c_min, 0.0))\n                max_attempts = 100\n                for _ in range(max_attempts):\n                    if dim == 2:\n                        r = random.uniform(0,1)**0.5\n                        theta = random.uniform(0, 2*math.pi)\n                        x_ball = [r*math.cos(theta), r*math.sin(theta)]\n                        L = [[a1_val, 0],[0, a_orth]]\n                        x_scaled = [L[0][0]*x_ball[0] + L[0][1]*x_ball[1], L[1][0]*x_ball[0] + L[1][1]*x_ball[1]]\n                        pt = (center[0] + R[0][0]*x_scaled[0] + R[0][1]*x_scaled[1],\n                              center[1] + R[1][0]*x_scaled[0] + R[1][1]*x_scaled[1])\n                    else:\n                        # 3D sample in unit ball\n                        while True:\n                            x_ball = [random.uniform(-1,1) for _ in range(3)]\n                            if sum(x*x for x in x_ball) <= 1:\n                                break\n                        L = [[a1_val,0,0],[0,a_orth,0],[0,0,a_orth]]\n                        x_scaled = [L[0][0]*x_ball[0], L[1][1]*x_ball[1], L[2][2]*x_ball[2]]\n                        pt = tuple(center[i]+sum(R[i][j]*x_scaled[j] for j in range(dim)) for i in range(dim))\n                    # clamp checks\n                    if any((pt[d]<0.0 or pt[d]>bounds[d]) for d in range(dim)):\n                        continue\n                    if self._is_in_obstacle(pt, obstacles, is_3d):\n                        continue\n                    return pt\n                # fallback uniform if no valid inside ellipsoid found\n                return self._sample_free(bounds, obstacles, is_3d)\n            else:\n                return self._sample_free(bounds, obstacles, is_3d)\n\n        def try_extend_and_rewire(tree_a, tree_b, sample):\n            nearest = self._nearest(tree_a, sample)\n            new_pos = self._steer(nearest.position, sample, self.step_size)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                return None\n            new_node = Node(new_pos)\n            radius = adapt_radius(len(tree_a), best_cost)\n            near_nodes = self._near(tree_a, new_pos, radius)\n\n            min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n            min_parent = nearest\n            for near in near_nodes:\n                tentative_cost = near.cost + math.dist(near.position, new_pos)\n                if tentative_cost < min_cost:\n                    if not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d):\n                        min_cost = tentative_cost\n                        min_parent = near\n\n            new_node.parent = min_parent\n            new_node.cost = min_cost\n            min_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((min_parent, new_node))\n\n            # Rewire neighbors (except min_parent)\n            for near in near_nodes:\n                if near is min_parent:\n                    continue\n                new_cost = new_node.cost + math.dist(new_node.position, near.position)\n                if new_cost < near.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                        if near.parent is not None:\n                            try:\n                                edges.remove((near.parent, near))\n                            except ValueError:\n                                pass\n                            near.parent.remove_child(near)\n                        near.parent = new_node\n                        near.cost = new_cost\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n\n            # Try connect to other tree within adaptive radius (larger radius)\n            connect_radius = max(radius * 1.5, self.step_size * 1.5)\n            nearest_b = self._nearest(tree_b, new_node.position)\n            dist_conn = math.dist(new_node.position, nearest_b.position)\n            if dist_conn <= connect_radius:\n                if not self._is_edge_in_obstacle(new_node.position, nearest_b.position, obstacles, is_3d):\n                    total_cost = new_node.cost + dist_conn + nearest_b.cost\n                    return new_node, nearest_b, total_cost\n            return None\n\n        def incremental_shortcut(path):\n            if len(path) < 3:\n                return path[:]\n            shortcut_path = path[:]\n            attempts = 0\n            while attempts < self.max_incremental_attempts:\n                if len(shortcut_path) < 3:\n                    break\n                i = random.randint(0, len(shortcut_path)-3)\n                j = random.randint(i+2, len(shortcut_path)-1)\n                if not self._is_edge_in_obstacle(shortcut_path[i], shortcut_path[j], obstacles, is_3d):\n                    shortcut_path = shortcut_path[:i+1] + shortcut_path[j:]\n                    attempts = 0\n                else:\n                    attempts += 1\n            return shortcut_path\n\n        def global_smoothing(path):\n            if len(path) < 3:\n                return path[:]\n            import random\n            smoothed = path[:]\n            max_global_attempts = 150\n            attempts = 0\n            while attempts < max_global_attempts:\n                if len(smoothed) < 3:\n                    break\n                i = random.randint(0, len(smoothed)-3)\n                j = random.randint(i+2, len(smoothed)-1)\n                if not self._is_edge_in_obstacle(smoothed[i], smoothed[j], obstacles, is_3d):\n                    smoothed = smoothed[:i+1] + smoothed[j:]\n                    attempts = 0\n                else:\n                    attempts += 1\n            return smoothed\n\n        def extract_path(node_s, node_g):\n            path_s = []\n            n = node_s\n            while n is not None:\n                path_s.append(n.position)\n                n = n.parent\n            path_g = []\n            n = node_g\n            while n is not None:\n                path_g.append(n.position)\n                n = n.parent\n            return list(reversed(path_s)) + path_g\n\n        for it in range(self.max_iter):\n            sample = sample_hybrid()\n\n            # Alternate attempts on both trees first; only one connection attempt per iteration\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                res = try_extend_and_rewire(tree_a, tree_b, sample)\n                if res is not None:\n                    node_a, node_b, cost_path = res\n                    if cost_path < best_cost:\n                        best_cost = cost_path\n                        best_sol_nodes = (node_a, node_b)\n\n            if best_sol_nodes is not None and best_cost < float('inf'):\n                if (it % self.shortcut_incremental_freq) == 0:\n                    raw_path = extract_path(best_sol_nodes[0], best_sol_nodes[1])\n                    improved_path = incremental_shortcut(raw_path)\n                    if len(improved_path) >= 2:\n                        # Return early with improved path occasionally for anytime results\n                        # But keep planning to find better paths in later iterations\n                        result = (True, improved_path)\n                    else:\n                        result = (True, raw_path)\n                else:\n                    result = None\n\n                if (it > 0 and it % self.shortcut_global_freq == 0) or it == (self.max_iter - 1):\n                    raw_path = extract_path(best_sol_nodes[0], best_sol_nodes[1])\n                    smooth_path = global_smoothing(raw_path)\n                    if len(smooth_path) >= 2:\n                        return PlannerResult(True, smooth_path, nodes, edges)\n                    else:\n                        return PlannerResult(True, raw_path, nodes, edges)\n\n                if result is not None and result[0]:\n                    # Return early (anytime)\n                    return PlannerResult(True, result[1], nodes, edges)\n\n        # Failure: no path found\n        return PlannerResult(False, [], nodes, edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        import random\n        while True:\n            pt = tuple(random.uniform(0, bounds[i]) for i in range(len(bounds)))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def _nearest(self, tree, point):\n        best = None\n        best_dist_sq = float('inf')\n        for node in tree:\n            dist_sq = 0.0\n            for i in range(len(point)):\n                d = node.position[i] - point[i]\n                dist_sq += d * d\n            if dist_sq < best_dist_sq:\n                best_dist_sq = dist_sq\n                best = node\n        return best\n\n    def _near(self, tree, point, radius):\n        r_sq = radius * radius\n        result = []\n        for node in tree:\n            dist_sq = 0.0\n            for i in range(len(point)):\n                d = node.position[i] - point[i]\n                dist_sq += d * d\n            if dist_sq <= r_sq:\n                result.append(node)\n        return result\n\n    def _steer(self, from_pos, to_pos, step_size):\n        dist_sq = 0.0\n        diff_vec = []\n        for i in range(len(from_pos)):\n            d = to_pos[i] - from_pos[i]\n            diff_vec.append(d)\n            dist_sq += d * d\n        dist = dist_sq ** 0.5\n        if dist <= step_size:\n            return to_pos\n        ratio = step_size / dist\n        new_pos = tuple(from_pos[i] + diff_vec[i] * ratio for i in range(len(from_pos)))\n        return new_pos\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        dist_sq = 0.0\n        diff = []\n        for i in range(len(from_pos)):\n            d = to_pos[i] - from_pos[i]\n            diff.append(d)\n            dist_sq += d*d\n        dist = dist_sq**0.5\n        steps = max(1, int(dist / resolution))\n        for step in range(steps + 1):\n            interp = tuple(from_pos[i] + diff[i] * (step / steps) for i in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _unit_ball_volume(self, dim):\n        import math\n        if dim == 2:\n            return math.pi\n        if dim == 3:\n            return 4.0 / 3.0 * math.pi\n        from math import gamma, pi\n        return (pi ** (dim / 2)) / gamma(dim / 2 + 1)",
          "objective": -31.69314,
          "time_improvement": 48.0,
          "length_improvement": 16.0,
          "smoothness_improvement": 1527.0,
          "node_improvement": 72.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.016495585441589355,
                    "num_nodes_avg": 122.9,
                    "path_length_avg": 162.9127393918776,
                    "smoothness_avg": 0.03592544986262253,
                    "success_improvement": 0.0,
                    "time_improvement": 36.04084141826401,
                    "node_improvement": 69.05061697305466,
                    "length_improvement": 10.704946021757324,
                    "smoothness_improvement": 462.31130371306637,
                    "objective_score": 19.54677655709893
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.02445840835571289,
                    "num_nodes_avg": 222.9,
                    "path_length_avg": 239.59338145742382,
                    "smoothness_avg": 0.10707606110469407,
                    "success_improvement": 0.0,
                    "time_improvement": 85.22826170222447,
                    "node_improvement": 85.0231808103205,
                    "length_improvement": 20.01683295640314,
                    "smoothness_improvement": 2655.144175993226,
                    "objective_score": 50.85429916447535
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.03942742347717285,
                    "num_nodes_avg": 291.7,
                    "path_length_avg": 123.77682267654771,
                    "smoothness_avg": 0.12280708330153808,
                    "success_improvement": 0.0,
                    "time_improvement": 22.306178414660902,
                    "node_improvement": 62.91163382072473,
                    "length_improvement": 17.793327997155263,
                    "smoothness_improvement": 1462.0970349195932,
                    "objective_score": 24.678335497289396
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "An improved bidirectional RRT* planner employing an adaptive rewiring radius with relaxed curvature constraints and balanced local-global shortcutting to accelerate planning convergence and enhance path smoothness. It uses efficient spatial hashing for neighbor queries with limited expansion, dynamic goal biasing decaying over iterations, and progressive incremental smoothing with less strict angular thresholds to enable more flexible path improvements and faster refinement. Once connected, a final global smoothing step ensures optimized path quality before returning the solution.",
          "planning_mechanism": "The planner alternates tree expansions from start and goal, sampling randomly with decaying goal bias to balance exploration and exploitation. It selects the best parent within an adaptively computed radius for new nodes and rewires neighbors if cost improvements are found, using spatial hashing for efficient neighborhood lookups. Incremental curvature-relaxed shortcutting is applied periodically to partially smooth paths, accelerating convergence. Upon connecting the two trees, a global smoothing procedure refines the complete path before returning it.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except ValueError:\n            pass\n\n    def path_from_root(self):\n        node, path = self, []\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=3500, step_size=6.0, base_radius=25.0,\n                 shortcut_iterations=80, initial_goal_sample_rate=0.18, min_goal_sample_rate=0.06,\n                 spatial_hash_cell_size=12.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.base_radius = base_radius\n        self.shortcut_iterations = shortcut_iterations\n        self.initial_goal_sample_rate = initial_goal_sample_rate\n        self.min_goal_sample_rate = min_goal_sample_rate\n        self.spatial_hash_cell_size = spatial_hash_cell_size\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(fr, to):\n            d = dist(fr, to)\n            if d <= self.step_size:\n                return to\n            ratio = self.step_size / d\n            return tuple(fr[i] + (to[i] - fr[i]) * ratio for i in range(dim))\n\n        def is_in_obstacle(p):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d_ = obs\n                    px, py, pz = p\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d_:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    px, py = p\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(fr, to):\n            d = dist(fr, to)\n            resolution = min(1.0, self.step_size / 2.5)\n            steps = max(1, int(d / resolution))\n            for i in range(steps + 1):\n                interp = tuple(fr[j] + (to[j] - fr[j]) * i / steps for j in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        class SpatialHash:\n            def __init__(self, cell_size):\n                self.cell_size = cell_size\n                self.cells = {}\n\n            def _hash_key(self, point):\n                return tuple(int(coord // self.cell_size) for coord in point)\n\n            def insert(self, node):\n                key = self._hash_key(node.position)\n                if key not in self.cells:\n                    self.cells[key] = []\n                self.cells[key].append(node)\n\n            def neighbors(self, point, radius):\n                r_cell = int(math.ceil(radius / self.cell_size))\n                base_key = self._hash_key(point)\n                result = []\n                for dx in range(-r_cell, r_cell + 1):\n                    for dy in range(-r_cell, r_cell + 1):\n                        if dim == 2:\n                            key = (base_key[0] + dx, base_key[1] + dy)\n                            if key in self.cells:\n                                result.extend(self.cells[key])\n                        else:\n                            for dz in range(-r_cell, r_cell + 1):\n                                key = (base_key[0] + dx, base_key[1] + dy, base_key[2] + dz)\n                                if key in self.cells:\n                                    result.extend(self.cells[key])\n                # Limit neighbors to a max count to reduce overhead\n                return result[:50]\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        start_spatial_hash = SpatialHash(self.spatial_hash_cell_size)\n        goal_spatial_hash = SpatialHash(self.spatial_hash_cell_size)\n        start_spatial_hash.insert(start_tree[0])\n        goal_spatial_hash.insert(goal_tree[0])\n\n        def nearest(tree, spatial_hash, point):\n            candidates = spatial_hash.neighbors(point, self.step_size * 4)\n            if not candidates:\n                return min(tree, key=lambda node: dist(node.position, point))\n            return min(candidates, key=lambda node: dist(node.position, point))\n\n        def near_nodes(tree, spatial_hash, point, radius):\n            candidates = spatial_hash.neighbors(point, radius)\n            r2 = radius * radius\n            result = []\n            for node in candidates:\n                d2 = 0.0\n                for i in range(dim):\n                    diff = node.position[i] - point[i]\n                    d2 += diff * diff\n                    if d2 > r2:\n                        break\n                else:\n                    result.append(node)\n            return result\n\n        def adaptive_radius(tree_size):\n            n = max(tree_size, 2)\n            gamma = self.base_radius\n            radius = gamma * (math.log(n) / n) ** (1.0 / dim)\n            return max(radius, self.step_size * 1.8)\n\n        def rewire(tree, spatial_hash, new_node, near_nodes_):\n            nonlocal edges\n            for near in near_nodes_:\n                if near == new_node.parent:\n                    continue\n                cost_new = new_node.cost + dist(new_node.position, near.position)\n                if cost_new + 1e-7 < near.cost:\n                    if not is_edge_in_obstacle(new_node.position, near.position):\n                        if near.parent is not None:\n                            try:\n                                edges.remove((near.parent, near))\n                                near.parent.remove_child(near)\n                            except ValueError:\n                                pass\n                        near.parent = new_node\n                        near.cost = cost_new\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n\n        def extract_path(node_start, node_goal):\n            path_start = node_start.path_from_root()\n            path_goal = node_goal.path_from_root()[::-1]\n            if path_start and path_goal and path_start[-1] == path_goal[0]:\n                path_goal = path_goal[1:]\n            return path_start + path_goal\n\n        def relaxed_shortcut(path):\n            if len(path) < 3:\n                return path[:]\n            new_path = path[:]\n            attempts = 0\n            max_attempts = self.shortcut_iterations\n            def angle(a, b, c):\n                v1 = [a[i] - b[i] for i in range(dim)]\n                v2 = [c[i] - b[i] for i in range(dim)]\n                dot = sum(v1[i]*v2[i] for i in range(dim))\n                n1 = math.sqrt(sum(x*x for x in v1))\n                n2 = math.sqrt(sum(x*x for x in v2))\n                if n1 < 1e-10 or n2 < 1e-10:\n                    return 0.0\n                cos_theta = max(-1.0, min(1.0, dot / (n1 * n2)))\n                return math.acos(cos_theta)\n\n            while attempts < max_attempts and len(new_path) >= 3:\n                i = random.randint(0, len(new_path) - 3)\n                j = random.randint(i + 2, len(new_path) - 1)\n                p1, p2 = new_path[i], new_path[j]\n                if not is_edge_in_obstacle(p1, p2):\n                    accept = True\n                    if i > 0:\n                        a, b, c = new_path[i -1], new_path[i], p2\n                        if angle(a, b, c) > math.pi * 150 / 180:\n                            accept = False\n                    if j < len(new_path) -1 and accept:\n                        a, b, c = p1, p2, new_path[j +1]\n                        if angle(a, b, c) > math.pi * 150 / 180:\n                            accept = False\n                    if accept:\n                        new_path = new_path[:i+1] + new_path[j:]\n                        attempts = 0\n                        continue\n                attempts += 1\n            return new_path\n\n        success = False\n        conn_node_start = None\n        conn_node_goal = None\n\n        def dynamic_goal_sample_rate(iteration):\n            decay = 0.9996\n            return max(self.min_goal_sample_rate, self.initial_goal_sample_rate * (decay ** iteration))\n\n        for it in range(self.max_iter):\n            for tree_a, tree_b, sp_a, sp_b in [(start_tree, goal_tree, start_spatial_hash, goal_spatial_hash),\n                                               (goal_tree, start_tree, goal_spatial_hash, start_spatial_hash)]:\n                goal_sample = random.random()\n                if goal_sample < dynamic_goal_sample_rate(it):\n                    sample_pt = goal_pos\n                else:\n                    sample_pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n                nearest_node = nearest(tree_a, sp_a, sample_pt)\n                new_pos = steer(nearest_node.position, sample_pt)\n                if is_in_obstacle(new_pos) or is_edge_in_obstacle(nearest_node.position, new_pos):\n                    continue\n\n                radius = adaptive_radius(len(tree_a))\n                near_nds = near_nodes(tree_a, sp_a, new_pos, radius)\n\n                min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n                min_parent = nearest_node\n                for near_node in near_nds:\n                    if near_node == nearest_node:\n                        continue\n                    cand_cost = near_node.cost + dist(near_node.position, new_pos)\n                    if cand_cost + 1e-7 < min_cost and not is_edge_in_obstacle(near_node.position, new_pos):\n                        min_cost = cand_cost\n                        min_parent = near_node\n\n                new_node = Node(new_pos, parent=min_parent, cost=min_cost)\n                min_parent.add_child(new_node)\n                tree_a.append(new_node)\n                sp_a.insert(new_node)\n                nodes.append(new_node)\n                edges.append((min_parent, new_node))\n\n                rewire(tree_a, sp_a, new_node, near_nds)\n\n                nearest_other = nearest(tree_b, sp_b, new_node.position)\n                dist_other = dist(new_node.position, nearest_other.position)\n                radius_connect = max(self.step_size * 2.2, adaptive_radius(len(tree_b)))\n                if dist_other <= radius_connect and not is_edge_in_obstacle(new_node.position, nearest_other.position):\n                    if tree_a is start_tree:\n                        conn_node_start, conn_node_goal = new_node, nearest_other\n                    else:\n                        conn_node_start, conn_node_goal = nearest_other, new_node\n                    success = True\n                    break\n\n                # Periodic incremental smoothing on partial paths for faster improvement\n                if len(tree_a) > 15 and (it % 15) == 0 and success is False:\n                    partial_path = extract_path(nearest_node, new_node)\n                    shortcut_path = relaxed_shortcut(partial_path)\n                    # No tree restructuring to save time\n\n            if success:\n                break\n\n        path = []\n        if success:\n            raw_path = extract_path(conn_node_start, conn_node_goal)\n            path = relaxed_shortcut(raw_path)\n\n        return PlannerResult(success, path, nodes, edges)",
          "objective": -31.62462,
          "time_improvement": 57.0,
          "length_improvement": 14.0,
          "smoothness_improvement": 1223.0,
          "node_improvement": 76.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.018377232551574706,
                    "num_nodes_avg": 102.0,
                    "path_length_avg": 171.81345381896625,
                    "smoothness_avg": 0.029010325567341406,
                    "success_improvement": 0.0,
                    "time_improvement": 28.745036954180513,
                    "node_improvement": 74.3137748677915,
                    "length_improvement": 5.826323403424324,
                    "smoothness_improvement": 354.07459205916336,
                    "objective_score": 13.889678088604564
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.03096754550933838,
                    "num_nodes_avg": 268.6,
                    "path_length_avg": 242.00236792773225,
                    "smoothness_avg": 0.07698287113955495,
                    "success_improvement": 0.0,
                    "time_improvement": 81.29704634351023,
                    "node_improvement": 81.95256332728616,
                    "length_improvement": 19.212643933783234,
                    "smoothness_improvement": 1880.8247229415845,
                    "objective_score": 45.32082387803093
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.019503355026245117,
                    "num_nodes_avg": 218.8,
                    "path_length_avg": 125.42685310984511,
                    "smoothness_avg": 0.12067049643723049,
                    "success_improvement": 0.0,
                    "time_improvement": 61.56760822573363,
                    "node_improvement": 72.18054672600128,
                    "length_improvement": 16.697456349365,
                    "smoothness_improvement": 1434.9198077120382,
                    "objective_score": 35.66335531589928
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m2",
          "algorithm_description": "A novel bidirectional RRT* variant with adaptive sampling blending uniform and ellipsoidal informed distributions, dynamically tuned rewiring radius based on observed path quality and node density, and an integrated multi-level shortcutting strategy applying frequent lightweight and occasional global path smoothing to improve convergence speed, path optimality, and smoothness. The trees grow alternately towards adaptively sampled points; neighbors are rewired within a density-dependent radius to balance exploration and exploitation, while connection attempts leverage dynamic distance thresholds. Incremental shortcutting is applied after each path improvement, supplemented by a sparser global smoothing step to remove residual jaggedness and lower cost. This comprehensive adaptive approach enhances planning efficiency, success rate, path length, and smoothness while responding to the evolving search landscape.",
          "planning_mechanism": "The planner maintains two growing trees from start and goal positions. Sampling alternates between uniform free-space sampling and ellipsoidal informed sampling based on current best path cost. Each iteration extends a selected tree toward the sampled point with step size control, rewires neighbors within an adaptively computed radius to optimize path cost, and attempts connection with the opposite tree using a distance threshold that adapts with node density and best cost. Whenever a better path is found, incremental shortcutting immediately reduces length and jaggedness, and periodically a more global smoothing pass applies. Efficient collision checks ensure collision-free expansions, and dynamic parameter tuning balances exploration-exploitation trade-offs in real time, accelerating convergence to a short, smooth path efficiently.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except ValueError:\n            pass\nclass Planner:\n    def __init__(self, max_iter=6000, step_size=6.0, goal_sample_rate=0.08,\n                 shortcut_attempts=30, global_smooth_freq=250, uniform_sample_rate=0.3,\n                 r_min=5.0, r_max=35.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.shortcut_attempts = shortcut_attempts\n        self.global_smooth_freq = global_smooth_freq\n        self.uniform_sample_rate = uniform_sample_rate\n        self.r_min = r_min\n        self.r_max = r_max\n\n    def plan(self, map):\n        import math\n        import random\n\n        bounds = map.size\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        obstacles = map.obstacles\n        start_pos = map.start\n        goal_pos = map.goal\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        best_cost = float('inf')\n        solution_nodes = (None, None)\n        improved_since_last_global_smooth = False\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def is_in_obstacle(pos):\n            px = pos[0]\n            py = pos[1]\n            pz = pos[2] if is_3d else 0.0\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(a, b, resolution=0.5):\n            dist_ab = dist(a, b)\n            steps = max(1, int(dist_ab / resolution))\n            for i in range(steps + 1):\n                t = i / steps\n                interm = tuple(a[j] + t * (b[j] - a[j]) for j in range(dim))\n                if is_in_obstacle(interm):\n                    return True\n            return False\n\n        def nearest(tree, point):\n            best = None\n            best_d = float('inf')\n            for n in tree:\n                d_n = dist(n.position, point)\n                if d_n < best_d:\n                    best = n\n                    best_d = d_n\n            return best\n\n        def near(tree, point, radius):\n            r_sq = radius * radius\n            res = []\n            for n in tree:\n                d_sq = 0.0\n                for i in range(dim):\n                    diff = n.position[i] - point[i]\n                    d_sq += diff * diff\n                if d_sq <= r_sq:\n                    res.append(n)\n            return res\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            ratio = self.step_size / d\n            return tuple(from_pos[i] + ratio * (to_pos[i] - from_pos[i]) for i in range(dim))\n\n        def compute_ellipsoid_params():\n            c_min = dist(start_pos, goal_pos)\n            if c_min < 1e-14:\n                return None\n            center = tuple((start_pos[i] + goal_pos[i]) * 0.5 for i in range(dim))\n            direction = [goal_pos[i] - start_pos[i] for i in range(dim)]\n            length = c_min\n            e1 = [d / length for d in direction]\n            if dim == 2:\n                e2 = (-e1[1], e1[0])\n                basis = [e1, e2]\n            else:\n                v = [1, 0, 0] if abs(e1[0]) < 0.9 else [0, 1, 0]\n                for i in range(dim):\n                    proj = sum(v[j] * e1[j] for j in range(dim))\n                    v[i] = v[i] - proj * e1[i]\n                norm_v = math.sqrt(sum(x * x for x in v))\n                if norm_v < 1e-15:\n                    v = [0.0] * dim\n                    v[-1] = 1.0\n                    norm_v = 1.0\n                u = [x / norm_v for x in v]\n                # cross product for 3D only\n                if dim == 3:\n                    w = [e1[1] * u[2] - e1[2] * u[1],\n                         e1[2] * u[0] - e1[0] * u[2],\n                         e1[0] * u[1] - e1[1] * u[0]]\n                    basis = [e1, u, w]\n                else:\n                    basis = [e1, u]\n\n            a1 = best_cost * 0.5\n            b_sq = max(best_cost * best_cost - c_min * c_min, 1e-12) * 0.25\n            b = math.sqrt(b_sq)\n            return center, basis, a1, b\n\n        def sample():\n            if best_cost == float('inf'):\n                # Pure uniform sampling with goal bias and obstacle avoidance\n                while True:\n                    if random.random() < self.goal_sample_rate:\n                        pt = goal_pos\n                    else:\n                        pt = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                    if not is_in_obstacle(pt):\n                        return pt\n            # Blend uniform and ellipsoidal informed sampling\n            if random.random() < self.uniform_sample_rate:\n                # uniform free-space sampling with goal bias\n                if random.random() < self.goal_sample_rate:\n                    pt = goal_pos\n                else:\n                    while True:\n                        pt = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                        if not is_in_obstacle(pt):\n                            break\n                return pt\n            # ellipsoidal informed sample\n            params = compute_ellipsoid_params()\n            if params is None:\n                # fallback\n                while True:\n                    pt = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                    if not is_in_obstacle(pt):\n                        return pt\n            center, basis, a1, b = params\n            while True:\n                if dim == 2:\n                    r = random.uniform(0, 1) ** 0.5\n                    theta = random.uniform(0, 2 * math.pi)\n                    u_ball = [r * math.cos(theta), r * math.sin(theta)]\n                    coords = [a1 * u_ball[0], b * u_ball[1]]\n                    pt = tuple(center[i] + sum(coords[j] * basis[j][i] for j in range(dim)) for i in range(dim))\n                else:\n                    while True:\n                        u_ball = [random.uniform(-1, 1) for _ in range(3)]\n                        norm_sq = sum(x * x for x in u_ball)\n                        if 0 < norm_sq <= 1:\n                            break\n                    norm = math.sqrt(norm_sq)\n                    unit_ball = [x / norm for x in u_ball]\n                    coords = [a1 * unit_ball[0], b * unit_ball[1], b * unit_ball[2]]\n                    pt = tuple(center[i] + sum(coords[j] * basis[j][i] for j in range(dim)) for i in range(dim))\n                if any(pt[d] < 0 or pt[d] > bounds[d] for d in range(dim)):\n                    continue\n                if is_in_obstacle(pt):\n                    continue\n                return pt\n\n        def rewiring_radius(n_nodes):\n            if n_nodes < 2:\n                return self.r_max\n            # Adapt radius with dependency on best_cost and density for balanced rewiring\n            base = 2 * ((math.log(n_nodes) / n_nodes) ** (1 / dim)) * self.step_size\n            ratio = 1.0\n            # Shrink rewiring radius when cost is good\n            if best_cost < float('inf') and best_cost > 0:\n                ratio = max(0.3, min(1.0, (best_cost / (dist(start_pos, goal_pos) * 3))))\n            radius = base * ratio\n            return max(self.r_min, min(self.r_max, radius))\n\n        def extract_path(node_a, node_b):\n            path_a = []\n            cur = node_a\n            while cur is not None:\n                path_a.append(cur.position)\n                cur = cur.parent\n            path_b = []\n            cur = node_b\n            while cur is not None:\n                path_b.append(cur.position)\n                cur = cur.parent\n            return path_a[::-1] + path_b\n\n        def incremental_shortcut(path):\n            if len(path) < 3:\n                return path[:]\n            new_path = path[:]\n            attempts = 0\n            while attempts < self.shortcut_attempts:\n                if len(new_path) < 3:\n                    break\n                i = random.randint(0, len(new_path) - 3)\n                j = random.randint(i + 2, len(new_path) - 1)\n                if not is_edge_in_obstacle(new_path[i], new_path[j]):\n                    new_path = new_path[:i + 1] + new_path[j:]\n                    attempts = 0\n                else:\n                    attempts += 1\n            return new_path\n\n        def global_smooth(path):\n            # Apply a simple global smoothing by shortcutting multiple times with increasing segment length\n            smoothed = path[:]\n            n = len(smoothed)\n            if n < 3:\n                return smoothed\n            max_segments = min(20, n//3)\n            for seg in range(max_segments, 1, -1):\n                i = 0\n                while i + seg < len(smoothed):\n                    if not is_edge_in_obstacle(smoothed[i], smoothed[i + seg]):\n                        smoothed = smoothed[:i + 1] + smoothed[i + seg:]\n                        # After shortcut, restart checking to capture further smooths\n                        i = 0\n                    else:\n                        i += 1\n            return smoothed\n\n        for it in range(self.max_iter):\n            sample_pos = sample()\n            tree_to_extend, opposite_tree = (start_tree, goal_tree) if it % 2 == 0 else (goal_tree, start_tree)\n\n            nearest_node = nearest(tree_to_extend, sample_pos)\n            new_pos = steer(nearest_node.position, sample_pos)\n\n            if is_in_obstacle(new_pos):\n                continue\n            if is_edge_in_obstacle(nearest_node.position, new_pos):\n                continue\n\n            radius = rewiring_radius(len(tree_to_extend))\n            near_nodes = near(tree_to_extend, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for candidate in near_nodes:\n                if candidate is nearest_node:\n                    continue\n                tentative_cost = candidate.cost + dist(candidate.position, new_pos)\n                if tentative_cost < min_cost and not is_edge_in_obstacle(candidate.position, new_pos):\n                    min_cost = tentative_cost\n                    best_parent = candidate\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree_to_extend.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors if cost improved and collision free\n            for nbr in near_nodes:\n                if nbr is best_parent or nbr is new_node:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, nbr.position)\n                if new_cost < nbr.cost and not is_edge_in_obstacle(new_node.position, nbr.position):\n                    if nbr.parent is not None:\n                        try:\n                            edges.remove((nbr.parent, nbr))\n                        except ValueError:\n                            pass\n                        nbr.parent.remove_child(nbr)\n                    nbr.parent = new_node\n                    nbr.cost = new_cost\n                    new_node.add_child(nbr)\n                    edges.append((new_node, nbr))\n\n            nearest_other = nearest(opposite_tree, new_pos)\n            dist_connect = dist(new_pos, nearest_other.position)\n            # Adapt connection threshold to min(step_size * 1.5, rewiring radius)\n            connect_thresh = min(self.step_size * 1.5, rewiring_radius(len(tree_to_extend)))\n            if dist_connect <= connect_thresh and not is_edge_in_obstacle(new_pos, nearest_other.position):\n                total_cost = new_node.cost + dist_connect + nearest_other.cost\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    solution_nodes = (new_node, nearest_other) if it % 2 == 0 else (nearest_other, new_node)\n                    raw_path = extract_path(solution_nodes[0], solution_nodes[1])\n                    smoothed_path = incremental_shortcut(raw_path)\n                    nodes_clear = len(smoothed_path)\n                    improved_since_last_global_smooth = True\n                    # Whenever better path found, return smoothed path immediately (anytime behavior)\n                    if smoothed_path and len(smoothed_path) >= 2:\n                        # Periodically apply global smoothing too\n                        if it % self.global_smooth_freq == 0:\n                            smoothed_path = global_smooth(smoothed_path)\n                        return PlannerResult(True, smoothed_path, nodes, edges)\n\n            # Periodic global smoothing on existing best path\n            if improved_since_last_global_smooth and it % self.global_smooth_freq == 0 and best_cost < float('inf'):\n                raw_path = extract_path(solution_nodes[0], solution_nodes[1])\n                smoothed_path = global_smooth(raw_path)\n                if smoothed_path and len(smoothed_path) >= 2:\n                    improved_since_last_global_smooth = False\n                    return PlannerResult(True, smoothed_path, nodes, edges)\n\n        # If terminate with solution found\n        if solution_nodes[0] is not None and solution_nodes[1] is not None:\n            raw_path = extract_path(solution_nodes[0], solution_nodes[1])\n            smoothed_path = incremental_shortcut(raw_path)\n            smoothed_path = global_smooth(smoothed_path)\n            return PlannerResult(True, smoothed_path, nodes, edges)\n\n        return PlannerResult(False, [], nodes, edges)",
          "objective": -31.45446,
          "time_improvement": 60.0,
          "length_improvement": 12.0,
          "smoothness_improvement": 1289.0,
          "node_improvement": 74.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.019103193283081056,
                    "num_nodes_avg": 130.0,
                    "path_length_avg": 173.3649996406287,
                    "smoothness_avg": 0.03905650881261121,
                    "success_improvement": 0.0,
                    "time_improvement": 25.93023309560016,
                    "node_improvement": 67.26265424326367,
                    "length_improvement": 4.975896552754276,
                    "smoothness_improvement": 511.3191754837242,
                    "objective_score": 13.321203737751233
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.022163128852844237,
                    "num_nodes_avg": 240.8,
                    "path_length_avg": 245.67296527562377,
                    "smoothness_avg": 0.08351123895740013,
                    "success_improvement": 0.0,
                    "time_improvement": 86.6145035068227,
                    "node_improvement": 83.8204663038366,
                    "length_improvement": 17.987292886770433,
                    "smoothness_improvement": 2048.8043290880164,
                    "objective_score": 47.020748429549144
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.017162418365478514,
                    "num_nodes_avg": 224.0,
                    "path_length_avg": 131.41011815324833,
                    "smoothness_avg": 0.11058336040285022,
                    "success_improvement": 0.0,
                    "time_improvement": 66.18054762740364,
                    "node_improvement": 71.51938970120788,
                    "length_improvement": 12.723656600001021,
                    "smoothness_improvement": 1306.6121819096536,
                    "objective_score": 34.02141915776997
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "path_expert",
          "algorithm_description": "An enhanced bidirectional RRT* planner that integrates adaptive rewiring radius, goal-biased informed sampling, and an improved hierarchical smoothing combining multi-pass shortcutting with cubic Bezier curve fitting for path refinement. The smoothing phase adaptively adjusts angle thresholds, performs iterative shortcut passes, and applies localized Bezier smoothing to reduce sharp turns while preserving obstacle avoidance. Frequent bidirectional tree connections accelerate solution discovery and continuous path quality improvement, aiming to minimize path length and enhance smoothness while maintaining efficient planning time.",
          "planning_mechanism": "The planner simultaneously grows two trees from start and goal using adaptive elliptical informed sampling that shrinks with solution cost improvements, dynamically scaling the neighborhood radius for rewiring. The planner selects parent nodes and rewires neighbors with strict cost improvement criteria, recursively updating subtree costs to maintain consistent cost. Frequent attempts connect the two trees to detect and refine paths. After solution detection, a hierarchical smoothing process iteratively applies shortcutting with adaptive angle thresholds followed by localized cubic Bezier curve fitting over path segments to greatly enhance smoothness and shorten path length while ensuring collision-free paths.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=6.0, r_min=5.0, r_max=30.0, goal_sample_rate=0.1):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.r_min = r_min\n        self.r_max = r_max\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map):\n        import math\n        import random\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = 3 if is_3d else 2\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        def dist(a,b):\n            return math.dist(a,b)\n\n        def heuristic_forward(p):\n            return dist(p,goal_pos)\n        def heuristic_backward(p):\n            return dist(p,start_pos)\n\n        best_cost = float('inf')\n        solution_nodes = (None,None)\n\n        def update_subtree_costs(node):\n            for c in node.children:\n                prev_cost = c.cost\n                new_cost = node.cost + dist(node.position,c.position)\n                if new_cost + 1e-15 < prev_cost:\n                    c.cost = new_cost\n                    update_subtree_costs(c)\n\n        def rewiring_radius(n_nodes):\n            if n_nodes < 2:\n                return self.r_max\n            gamma = 40.0\n            val = gamma * (math.log(n_nodes)/n_nodes)**(1/dim)\n            return max(self.r_min, min(self.r_max,val))\n\n        def sample():\n            if random.random() < self.goal_sample_rate:\n                return goal_pos\n            if best_cost == float('inf'):\n                while True:\n                    pt = tuple(random.uniform(0,bounds[i]) for i in range(dim))\n                    if not self._is_in_obstacle(pt,obstacles,is_3d):\n                        return pt\n            else:\n                center = tuple((start_pos[i]+goal_pos[i])/2 for i in range(dim))\n                a1 = [goal_pos[i]-start_pos[i] for i in range(dim)]\n                length = dist(start_pos,goal_pos)\n                if length < 1e-15:\n                    return goal_pos\n\n                e1 = [x/length for x in a1]\n                def orthonormal_basis(dim,e1):\n                    basis = [e1]\n                    if dim==2:\n                        basis.append( (-e1[1], e1[0]) )\n                    elif dim==3:\n                        v = [1,0,0] if abs(e1[0])<0.9 else [0,1,0]\n                        u = [v[i] - e1[i]*sum(v[j]*e1[j] for j in range(3)) for i in range(3)]\n                        u_norm = math.sqrt(sum(x*x for x in u))\n                        if u_norm < 1e-15:\n                            u = [0,0,1]\n                            u_norm=1\n                        u = [x/u_norm for x in u]\n                        w = [e1[1]*u[2] - e1[2]*u[1],\n                             e1[2]*u[0] - e1[0]*u[2],\n                             e1[0]*u[1] - e1[1]*u[0]]\n                        basis.extend([u,w])\n                    return basis\n                B = orthonormal_basis(dim,e1)\n\n                c_min = length\n                c_max = min(best_cost * 1.05, sum(bounds)*10)\n\n                try:\n                    a1_len = c_max / 2.0\n                    a_others = max( ( (c_max**2 - c_min**2) / 4.0 )**0.5, 1e-8 )\n                except Exception:\n                    a1_len = c_max / 2.0\n                    a_others = a1_len\n\n                while True:\n                    if dim==2:\n                        r = random.uniform(0,1)**0.5\n                        theta = random.uniform(0,2*math.pi)\n                        unit_ball = [r*math.cos(theta), r*math.sin(theta)]\n                        coords = [a1_len*unit_ball[0], a_others*unit_ball[1]]\n                        sample_pt = [ center[i] + sum(coords[j]*B[j][i] for j in range(dim)) for i in range(dim) ]\n                        pt = tuple(sample_pt)\n                    else:\n                        while True:\n                            u = [random.uniform(-1,1) for _ in range(3)]\n                            norm_u = math.sqrt(sum(x*x for x in u))\n                            if norm_u<=1 and norm_u>0:\n                                unit_ball = [x/norm_u for x in u]\n                                break\n                        coords = [a1_len*unit_ball[0], a_others*unit_ball[1], a_others*unit_ball[2]]\n                        sample_pt = [ center[i] + sum(coords[j]*B[j][i] for j in range(dim)) for i in range(dim) ]\n                        pt = tuple(sample_pt)\n                    if any(pt[i]<0 or pt[i]>bounds[i] for i in range(dim)):\n                        continue\n                    if self._is_in_obstacle(pt,obstacles,is_3d):\n                        continue\n                    return pt\n\n        def nearest(tree,p):\n            best = None\n            best_d = float('inf')\n            for n in tree:\n                d = dist(n.position,p)\n                if d < best_d:\n                    best = n\n                    best_d = d\n            return best\n\n        def near(tree,p,r):\n            r2 = r*r\n            res = []\n            for n in tree:\n                d2 = 0\n                for i in range(dim):\n                    delta = n.position[i] - p[i]\n                    d2 += delta*delta\n                if d2 <= r2:\n                    res.append(n)\n            return res\n\n        def steer(from_pos,to_pos):\n            d = dist(from_pos,to_pos)\n            if d <= self.step_size:\n                return to_pos\n            ratio = self.step_size/d\n            return tuple(from_pos[i]+(to_pos[i]-from_pos[i])*ratio for i in range(dim))\n\n        def is_free_node(pos):\n            return not self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def is_free_edge(a,b):\n            return not self._is_edge_in_obstacle(a,b,obstacles,is_3d)\n\n        def path_from_to(node_start,node_goal):\n            path_start = []\n            n = node_start\n            while n is not None:\n                path_start.append(n.position)\n                n = n.parent\n            path_goal = []\n            n = node_goal\n            while n is not None:\n                path_goal.append(n.position)\n                n = n.parent\n            return path_start[::-1] + path_goal\n\n        def angle_between_vectors(a,b,c):\n            # angle at point b formed by vectors ba and bc\n            import math\n            ba = [a[i]-b[i] for i in range(dim)]\n            bc = [c[i]-b[i] for i in range(dim)]\n            len_ba = math.sqrt(sum(x*x for x in ba))\n            len_bc = math.sqrt(sum(x*x for x in bc))\n            if len_ba <1e-12 or len_bc <1e-12:\n                return 0.0\n            dot = sum(ba[i]*bc[i] for i in range(dim))\n            val = max(min(dot/(len_ba*len_bc),1),-1)\n            return math.acos(val)\n\n        def shortcut_path(path, max_passes=8, max_attempts_per_pass=300):\n            if len(path)<3:\n                return path[:]\n            new_path = path[:]\n            angle_threshold_base = math.pi * 150.0/180.0  # 150 degrees base threshold for acceptance\n\n            for pass_i in range(max_passes):\n                improved = False\n                attempts = 0\n                i = 0\n                # adapt angle threshold loosening on passes (more passes progressively allow slightly sharper angles)\n                angle_threshold = angle_threshold_base + (pass_i*math.pi*5/180.0)  # loosen 5 degrees per pass up to ~190 deg max cap\n                angle_threshold = min(angle_threshold, math.pi*190/180.0)\n\n                while i < len(new_path)-2 and attempts < max_attempts_per_pass:\n                    j = random.randint(i+2, len(new_path)-1)\n                    if j <= i+1:\n                        attempts += 1\n                        continue\n                    if is_free_edge(new_path[i],new_path[j]):\n                        # Check angles at neighbors before removal\n                        smooth = True\n                        if i>0:\n                            a,b,c = new_path[i-1], new_path[i], new_path[j]\n                            if angle_between_vectors(a,b,c) < math.pi - angle_threshold:\n                                smooth = False\n                        if j<len(new_path)-1:\n                            a,b,c = new_path[i], new_path[j], new_path[j+1]\n                            if angle_between_vectors(a,b,c) < math.pi - angle_threshold:\n                                smooth = False\n                        if smooth:\n                            new_path = new_path[:i+1] + new_path[j:]\n                            improved = True\n                            i = 0\n                            attempts += 1\n                            continue\n                    i += 1\n                    attempts += 1\n                if not improved:\n                    break\n            return new_path\n\n        def bezier_point(t, p0, p1, p2, p3):\n            \"\"\"Cubic Bezier Curve Point\"\"\"\n            u = 1 - t\n            tt = t*t\n            uu = u*u\n            uuu = uu * u\n            ttt = tt * t\n\n            return tuple( uuu*p0[i] + 3*uu*t*p1[i] + 3*u*tt*p2[i] + ttt*p3[i] for i in range(len(p0)) )\n\n        def bezier_curve(control_points, n_points=10):\n            \"\"\"Generate points along a cubic Bezier curve\"\"\"\n            if len(control_points) != 4:\n                return control_points[:]\n            return [bezier_point(t, *control_points) for t in [i/(n_points-1) for i in range(n_points)]]\n\n        def is_curve_collision_free(curve_points):\n            for idx in range(len(curve_points)-1):\n                if self._is_edge_in_obstacle(curve_points[idx], curve_points[idx+1], obstacles, is_3d):\n                    return False\n            return True\n\n        def bezier_smooth_path(path):\n            # Apply localized Bezier smoothing over path segments length 4 if collision free\n            if len(path) < 4:\n                return path[:]\n            new_path = path[:]\n            i = 0\n            while i < len(new_path)-3:\n                p0, p1, p2, p3 = new_path[i], new_path[i+1], new_path[i+2], new_path[i+3]\n                curve_pts = bezier_curve([p0,p1,p2,p3], n_points=10)\n                if is_curve_collision_free(curve_pts):\n                    # Replace middle two points p1,p2 by intermediate curve points (excluding p0 and p3)\n                    # We keep first and last points of the segment fixed.\n                    # We'll replace p1 and p2 by a subset of curve points for smoothness.\n\n                    # Interpolated points exclude first and last of curve_pts\n                    interpolated = curve_pts[1:-1]\n\n                    # Build new path with replaced segment\n                    new_path = new_path[:i+1] + interpolated + new_path[i+3:]\n                    i += len(interpolated)  # skip newly added points\n                else:\n                    i += 1\n            return new_path\n\n        for it in range(self.max_iter):\n            sample_pos = sample()\n\n            if it % 2 == 0:\n                prop_tree, other_tree = start_tree, goal_tree\n                heuristic_prop = heuristic_forward\n                heuristic_other = heuristic_backward\n            else:\n                prop_tree, other_tree = goal_tree, start_tree\n                heuristic_prop = heuristic_backward\n                heuristic_other = heuristic_forward\n\n            nearest_node = nearest(prop_tree, sample_pos)\n            new_pos = steer(nearest_node.position, sample_pos)\n\n            if not is_free_node(new_pos):\n                continue\n            if not is_free_edge(nearest_node.position, new_pos):\n                continue\n\n            r = rewiring_radius(len(prop_tree))\n            near_nodes = near(prop_tree, new_pos, r)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position,new_pos)\n            best_parent = nearest_node\n            for candidate in near_nodes:\n                if candidate is nearest_node:\n                    continue\n                tentative_cost = candidate.cost + dist(candidate.position,new_pos)\n                if tentative_cost + heuristic_prop(new_pos) + 1e-15 < min_cost + heuristic_prop(new_pos):\n                    if is_free_edge(candidate.position, new_pos):\n                        min_cost = tentative_cost\n                        best_parent = candidate\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.add_child(new_node)\n            prop_tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            for nbr in near_nodes:\n                if nbr is best_parent or nbr is new_node:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, nbr.position)\n                if new_cost + heuristic_prop(nbr.position) + 1e-15 < nbr.cost + heuristic_prop(nbr.position):\n                    if is_free_edge(new_node.position, nbr.position):\n                        if nbr.parent is not None:\n                            try:\n                                edges.remove((nbr.parent, nbr))\n                            except ValueError:\n                                pass\n                            nbr.parent.remove_child(nbr)\n                        nbr.parent = new_node\n                        nbr.cost = new_cost\n                        new_node.add_child(nbr)\n                        edges.append((new_node, nbr))\n                        update_subtree_costs(nbr)\n\n            near_other = nearest(other_tree, new_node.position)\n            dist_conn = dist(new_node.position, near_other.position)\n            if dist_conn <= self.step_size:\n                if is_free_edge(new_node.position, near_other.position):\n                    candidate_cost = new_node.cost + dist_conn + near_other.cost\n                    if candidate_cost + 1e-15 < best_cost:\n                        best_cost = candidate_cost\n                        if it % 2 == 0:\n                            solution_nodes = (new_node, near_other)\n                        else:\n                            solution_nodes = (near_other, new_node)\n\n            if solution_nodes[0] and solution_nodes[1] and ((it > 0 and it % 80 == 0) or it == self.max_iter-1):\n                raw_path = path_from_to(solution_nodes[0], solution_nodes[1])\n                pass1 = shortcut_path(raw_path, max_passes=8, max_attempts_per_pass=300)\n                pass2 = bezier_smooth_path(pass1)\n                return PlannerResult(True, pass2, nodes, edges)\n\n        if solution_nodes[0] and solution_nodes[1]:\n            raw_path = path_from_to(solution_nodes[0], solution_nodes[1])\n            pass1 = shortcut_path(raw_path, max_passes=8, max_attempts_per_pass=300)\n            pass2 = bezier_smooth_path(pass1)\n            return PlannerResult(True, pass2, nodes, edges)\n        else:\n            return PlannerResult(False, [], nodes, edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        px = pos[0]\n        py = pos[1]\n        pz = pos[2] if is_3d else 0.0\n        for obs in obstacles:\n            if is_3d:\n                x,y,z,w,h,d = obs\n                if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                    return True\n            else:\n                x,y,w,h = obs\n                if x <= px <= x+w and y <= py <= y+h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        dist_val = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist_val/resolution))\n        for step in range(steps+1):\n            t = step/steps\n            interp = tuple(from_pos[i] + t*(to_pos[i]-from_pos[i]) for i in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -31.35436,
          "time_improvement": 50.0,
          "length_improvement": 18.0,
          "smoothness_improvement": 1122.0,
          "node_improvement": 67.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.020946669578552245,
                    "num_nodes_avg": 169.2,
                    "path_length_avg": 156.9968252907203,
                    "smoothness_avg": 0.020851635172459877,
                    "success_improvement": 0.0,
                    "time_improvement": 18.782430240028845,
                    "node_improvement": 57.39108536892471,
                    "length_improvement": 13.947552284259512,
                    "smoothness_improvement": 226.3733704995064,
                    "objective_score": 15.135127295061892
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.029881834983825684,
                    "num_nodes_avg": 307.0,
                    "path_length_avg": 231.7579073494588,
                    "smoothness_avg": 0.09111135278880159,
                    "success_improvement": 0.0,
                    "time_improvement": 81.95276488074154,
                    "node_improvement": 79.3724383524827,
                    "length_improvement": 22.63253974525912,
                    "smoothness_improvement": 2244.360732110702,
                    "objective_score": 49.38715697193144
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.02644164562225342,
                    "num_nodes_avg": 287.2,
                    "path_length_avg": 123.73707639297194,
                    "smoothness_avg": 0.07830820806750623,
                    "success_improvement": 0.0,
                    "time_improvement": 47.89533993801242,
                    "node_improvement": 63.4837889383344,
                    "length_improvement": 17.819725586191648,
                    "smoothness_improvement": 896.0746265080132,
                    "objective_score": 29.54081046565878
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "An adaptive bidirectional RRT* planner with hybrid sampling combining focused informed ellipsoidal and uniform sampling, adaptive rewiring radius based on node count and best cost, incremental local rewiring with efficient cost checks, and continuous lightweight shortcutting during planning for steady improvements in path quality, smoothness, and reduced planning time. The planner grows trees alternately, samples adaptively balancing exploration and exploitation, rewires neighbors efficiently with collision checks, connects trees eagerly to update solutions, and performs incremental shortcutting frequently to smooth and shorten the path progressively.",
          "planning_mechanism": "The algorithm alternates between growing two RRT* trees extending towards adaptively sampled points chosen probabilistically from either an informed ellipsoidal subset around the current best path or a uniform distribution over free space, thus maintaining exploration while focusing efforts. It uses a dynamically computed adaptive radius for rewiring nearby nodes locally optimizing path cost incrementally while avoiding excessive computations. After connecting the two trees, the planner extracts the path and applies frequent lightweight shortcutting passes incrementally during planning to improve smoothness and path length, returning improved paths early and efficiently.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\nclass Planner:\n    def __init__(self, max_iter=3500, step_size=6.0, r_min=6.0, r_max=25.0, goal_sample_rate=0.05, shortcut_interval=25):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.r_min = r_min\n        self.r_max = r_max\n        self.goal_sample_rate = goal_sample_rate\n        self.shortcut_interval = shortcut_interval\n\n    def plan(self, map):\n        import math\n        import random\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = 3 if is_3d else 2\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        best_cost = float('inf')\n        solution_nodes = (None, None)\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def heur(p, target):\n            return dist(p, target)\n\n        def adaptive_radius(n_nodes, cost_path):\n            if n_nodes < 2:\n                return self.r_max\n            gamma = 35.0\n            r = gamma * (math.log(n_nodes) / n_nodes) ** (1 / dim)\n            if cost_path != float('inf'):\n                r = min(r, cost_path / 2.0)\n            return max(self.r_min, min(self.r_max, r))\n\n        def sample():\n            # Hybrid sampling: goal bias + probabilistic uniform or informed ellipsoid sampling\n            if random.random() < self.goal_sample_rate:\n                return goal_pos\n            if best_cost == float('inf') or random.random() < 0.4:\n                # Uniform free space sampling\n                while True:\n                    pt = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                    if not self._is_in_obstacle(pt, obstacles, is_3d):\n                        return pt\n            else:\n                # Informed ellipsoidal sampling biased on best_cost\n                center = tuple((start_pos[i] + goal_pos[i]) / 2 for i in range(dim))\n                d_start_goal = dist(start_pos, goal_pos)\n                if d_start_goal < 1e-12:\n                    return goal_pos\n\n                e1 = [(goal_pos[i] - start_pos[i]) / d_start_goal for i in range(dim)]\n\n                # Build an orthonormal basis\n                def orthonormal_basis(dim, e1):\n                    basis = [e1]\n                    if dim == 2:\n                        basis.append((-e1[1], e1[0]))\n                    elif dim == 3:\n                        v = [1, 0, 0] if abs(e1[0]) < 0.9 else [0, 1, 0]\n                        u = [v[i] - e1[i] * sum(v[j] * e1[j] for j in range(3)) for i in range(3)]\n                        norm_u = math.sqrt(sum(x * x for x in u))\n                        if norm_u < 1e-12:\n                            u = [0, 0, 1]\n                            norm_u = 1.0\n                        u = [x / norm_u for x in u]\n                        w = [e1[1] * u[2] - e1[2] * u[1],\n                             e1[2] * u[0] - e1[0] * u[2],\n                             e1[0] * u[1] - e1[1] * u[0]]\n                        basis.extend([u, w])\n                    return basis\n\n                B = orthonormal_basis(dim, e1)\n                c_min = d_start_goal\n                c_max = min(best_cost * 1.05, sum(bounds) * 10)\n\n                a1 = c_max / 2.0\n                try:\n                    a_others = math.sqrt(max((c_max ** 2 - c_min ** 2) / 4.0, 1e-8))\n                except Exception:\n                    a_others = a1\n\n                while True:\n                    if dim == 2:\n                        r = random.uniform(0, 1) ** 0.5\n                        theta = random.uniform(0, 2 * math.pi)\n                        x_ball = [r * math.cos(theta), r * math.sin(theta)]\n                        coords = [a1 * x_ball[0], a_others * x_ball[1]]\n                        sample_pt = [center[i] + sum(coords[j] * B[j][i] for j in range(dim)) for i in range(dim)]\n                        pt = tuple(sample_pt)\n                    else:\n                        while True:\n                            u = [random.uniform(-1, 1) for _ in range(3)]\n                            norm_u = math.sqrt(sum(x * x for x in u))\n                            if 0 < norm_u <= 1:\n                                unit_ball = [x / norm_u for x in u]\n                                break\n                        coords = [a1 * unit_ball[0], a_others * unit_ball[1], a_others * unit_ball[2]]\n                        sample_pt = [center[i] + sum(coords[j] * B[j][i] for j in range(dim)) for i in range(dim)]\n                        pt = tuple(sample_pt)\n                    if any(pt[i] < 0 or pt[i] > bounds[i] for i in range(dim)):\n                        continue\n                    if self._is_in_obstacle(pt, obstacles, is_3d):\n                        continue\n                    return pt\n\n        def nearest(tree, q):\n            best_node = None\n            best_dist = float('inf')\n            for n in tree:\n                d = dist(n.position, q)\n                if d < best_dist:\n                    best_dist = d\n                    best_node = n\n            return best_node\n\n        def near(tree, q, radius):\n            r2 = radius * radius\n            result = []\n            for n in tree:\n                d2 = sum((n.position[i] - q[i]) ** 2 for i in range(dim))\n                if d2 <= r2:\n                    result.append(n)\n            return result\n\n        def steer(from_p, to_p):\n            d = dist(from_p, to_p)\n            if d <= self.step_size:\n                return to_p\n            ratio = self.step_size / d\n            return tuple(from_p[i] + ratio * (to_p[i] - from_p[i]) for i in range(dim))\n\n        def is_free_node(p):\n            return not self._is_in_obstacle(p, obstacles, is_3d)\n\n        def is_free_edge(a, b):\n            return not self._is_edge_in_obstacle(a, b, obstacles, is_3d)\n\n        def reconstruct_path(node_start, node_goal):\n            path_start = []\n            n = node_start\n            while n is not None:\n                path_start.append(n.position)\n                n = n.parent\n            path_goal = []\n            n = node_goal\n            while n is not None:\n                path_goal.append(n.position)\n                n = n.parent\n            return path_start[::-1] + path_goal\n\n        def shortcut_path(path, max_attempts=20):\n            # Lightweight bounded shortcutting for incremental smoothing\n            if len(path) < 3:\n                return path[:]\n            new_path = path[:]\n            attempts = 0\n            while attempts < max_attempts:\n                if len(new_path) < 3:\n                    break\n                i = random.randint(0, len(new_path) - 3)\n                j = random.randint(i + 2, len(new_path) - 1)\n                if not self._is_edge_in_obstacle(new_path[i], new_path[j], obstacles, is_3d):\n                    new_path = new_path[:i + 1] + new_path[j:]\n                    attempts = 0\n                else:\n                    attempts += 1\n            return new_path\n\n        for it in range(self.max_iter):\n            sample_point = sample()\n\n            # Alternate tree to grow: start->goal on even iterations, goal->start on odd\n            if it % 2 == 0:\n                prop_tree, other_tree = start_tree, goal_tree\n                target_start, target_goal = start_pos, goal_pos\n            else:\n                prop_tree, other_tree = goal_tree, start_tree\n                target_start, target_goal = goal_pos, start_pos\n\n            nearest_node = nearest(prop_tree, sample_point)\n            new_pos = steer(nearest_node.position, sample_point)\n\n            if not is_free_node(new_pos):\n                continue\n            if not is_free_edge(nearest_node.position, new_pos):\n                continue\n\n            radius = adaptive_radius(len(prop_tree), best_cost)\n            near_nodes = near(prop_tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in near_nodes:\n                if node is nearest_node:\n                    continue\n                tentative_cost = node.cost + dist(node.position, new_pos)\n                if tentative_cost + heur(new_pos, target_goal) + 1e-12 < min_cost + heur(new_pos, target_goal):\n                    if is_free_edge(node.position, new_pos):\n                        min_cost = tentative_cost\n                        best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.add_child(new_node)\n            prop_tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors if better path through new_node\n            for node in near_nodes:\n                if node is best_parent or node is new_node:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, node.position)\n                if new_cost + heur(node.position, target_goal) + 1e-12 < node.cost + heur(node.position, target_goal):\n                    if is_free_edge(new_node.position, node.position):\n                        if node.parent:\n                            try:\n                                edges.remove((node.parent, node))\n                            except ValueError:\n                                pass\n                            node.parent.remove_child(node)\n                        node.parent = new_node\n                        node.cost = new_cost\n                        new_node.add_child(node)\n                        edges.append((new_node, node))\n\n            # Attempt connection to other tree\n            nearest_other = nearest(other_tree, new_node.position)\n            dist_connect = dist(new_node.position, nearest_other.position)\n            if dist_connect <= self.step_size:\n                if is_free_edge(new_node.position, nearest_other.position):\n                    candidate_cost = new_node.cost + dist_connect + nearest_other.cost\n                    if candidate_cost + 1e-12 < best_cost:\n                        best_cost = candidate_cost\n                        solution_nodes = (new_node, nearest_other) if it % 2 == 0 else (nearest_other, new_node)\n\n            if solution_nodes[0] and solution_nodes[1]:\n                if (it % self.shortcut_interval == 0) or (it == self.max_iter - 1):\n                    raw_path = reconstruct_path(solution_nodes[0], solution_nodes[1])\n                    smooth_path = shortcut_path(raw_path, max_attempts=30)\n                    return PlannerResult(True, smooth_path, nodes, edges)\n\n        # Return best found solution or failure\n        if solution_nodes[0] and solution_nodes[1]:\n            raw_path = reconstruct_path(solution_nodes[0], solution_nodes[1])\n            smooth_path = shortcut_path(raw_path, max_attempts=30)\n            return PlannerResult(True, smooth_path, nodes, edges)\n        return PlannerResult(False, [], nodes, edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        px = pos[0]\n        py = pos[1]\n        pz = pos[2] if is_3d else 0.0\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        dist_val = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist_val / resolution))\n        for step in range(steps + 1):\n            t = step / steps\n            interp = tuple(from_pos[i] + t * (to_pos[i] - from_pos[i]) for i in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -31.30341,
          "time_improvement": 54.0,
          "length_improvement": 14.0,
          "smoothness_improvement": 1316.0,
          "node_improvement": 72.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.019494915008544923,
                    "num_nodes_avg": 151.7,
                    "path_length_avg": 174.44639783292493,
                    "smoothness_avg": 0.03935007184422033,
                    "success_improvement": 0.0,
                    "time_improvement": 24.41139085459142,
                    "node_improvement": 61.7980357592546,
                    "length_improvement": 4.383165067705779,
                    "smoothness_improvement": 515.9140744107333,
                    "objective_score": 12.532886669054559
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.022634148597717285,
                    "num_nodes_avg": 237.5,
                    "path_length_avg": 233.87939033203693,
                    "smoothness_avg": 0.09110078516871065,
                    "success_improvement": 0.0,
                    "time_improvement": 86.33002954174867,
                    "node_improvement": 84.04219579385877,
                    "length_improvement": 21.924327662172644,
                    "smoothness_improvement": 2244.088819634213,
                    "objective_score": 50.27404955799925
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.02483363151550293,
                    "num_nodes_avg": 229.9,
                    "path_length_avg": 125.87608357912158,
                    "smoothness_avg": 0.1013312731366172,
                    "success_improvement": 0.0,
                    "time_improvement": 51.0640167141886,
                    "node_improvement": 70.76923076923077,
                    "length_improvement": 16.39909886172776,
                    "smoothness_improvement": 1188.9263148012135,
                    "objective_score": 31.1032959052993
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m2",
          "algorithm_description": "An Enhanced Bidirectional Informed RRT* variant with optimized sampling bias, refined adaptive radius tuning, efficient rewiring with caching to reduce redundant collision checks, and a progressive incremental shortcutting strategy for significantly improved planning speed, path optimality, and smoothness. It balances exploration and exploitation by dynamic goal bias and ellipsoidal sampling, limits rewiring checks via caching, and performs smoothing incrementally during planning to enable faster convergence and smoother paths.",
          "planning_mechanism": "The planner grows two trees bidirectionally starting from start and goal positions. Sampling alternates between goal bias, ellipsoidal informed, and uniform to maintain global exploration and focused optimization. An adaptive radius dynamically tuned with tree size and best cost guides rewiring and connection attempts while a nearest neighbor search with caching reduces collision checking overhead. Incremental shortcutting is performed on intermediate best paths periodically to enhance smoothness and path length without costly global operations. Early termination upon finding a feasible path with improved cost ensures reduced search time and robust solution quality.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except ValueError:\n            pass\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=3500, step_size=6.0, base_radius=25.0, goal_sample_rate=0.15, incremental_shortcut_freq=15, max_incremental_attempts=40):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.base_radius = base_radius\n        self.goal_sample_rate = goal_sample_rate\n        self.incremental_shortcut_freq = incremental_shortcut_freq\n        self.max_incremental_attempts = max_incremental_attempts\n\n    def plan(self, map):\n        import math\n        import random\n\n        bounds = map.size\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        start_pos = map.start\n        goal_pos = map.goal\n\n        tree_start = [Node(start_pos, cost=0.0)]\n        tree_goal = [Node(goal_pos, cost=0.0)]\n        nodes = tree_start + tree_goal\n        edges = []\n\n        c_min = math.dist(start_pos, goal_pos)\n        best_cost = float('inf')\n        best_connection = None\n\n        # Cache for edge collision checks to avoid redundancy\n        edge_collision_cache = {}\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(fr, to):\n            d = dist(fr, to)\n            if d <= self.step_size:\n                return to\n            ratio = self.step_size / d\n            return tuple(fr[i] + (to[i] - fr[i]) * ratio for i in range(dim))\n\n        def is_in_obstacle(p):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d_ = obs\n                    px, py, pz = p\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d_:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    px, py = p\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(fr, to, resolution=1.0):\n            key = (fr, to) if fr < to else (to, fr)\n            if key in edge_collision_cache:\n                return edge_collision_cache[key]\n            d = dist(fr, to)\n            steps = max(1, int(d / resolution))\n            for i in range(steps + 1):\n                interp = tuple(fr[j] + (to[j] - fr[j]) * i / steps for j in range(dim))\n                if is_in_obstacle(interp):\n                    edge_collision_cache[key] = True\n                    return True\n            edge_collision_cache[key] = False\n            return False\n\n        def nearest(tree, pt):\n            best_node = None\n            best_dist_sq = float('inf')\n            for node in tree:\n                dist_sq = 0.0\n                for i in range(dim):\n                    d = pt[i] - node.position[i]\n                    dist_sq += d * d\n                if dist_sq < best_dist_sq:\n                    best_dist_sq = dist_sq\n                    best_node = node\n            return best_node\n\n        def near_nodes(tree, pt, radius):\n            r_sq = radius * radius\n            result = []\n            for node in tree:\n                dist_sq = 0.0\n                for i in range(dim):\n                    d = pt[i] - node.position[i]\n                    dist_sq += d * d\n                    if dist_sq > r_sq:\n                        break\n                else:\n                    result.append(node)\n            return result\n\n        def adaptive_radius(n):\n            n = max(n, 1)\n            val = self.base_radius * (math.log(n) / n) ** (1.0 / dim)\n            return max(val, self.step_size * 1.5)\n\n        def informed_sample(c_best, c_min, start, goal):\n            if c_best == float('inf'):\n                return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n            center = tuple((start[i] + goal[i]) * 0.5 for i in range(dim))\n            a1 = tuple((goal[i] - start[i]) / c_min for i in range(dim))\n            if dim == 2:\n                theta = math.atan2(a1[1], a1[0])\n                cos_t = math.cos(theta)\n                sin_t = math.sin(theta)\n                rx = c_best / 2.0\n                ry = math.sqrt(max(c_best * c_best - c_min * c_min, 0.0)) / 2.0\n                for _ in range(100):\n                    x, y = random.uniform(-1, 1), random.uniform(-1, 1)\n                    if x * x + y * y > 1:\n                        continue\n                    px = x * rx\n                    py = y * ry\n                    sample_x = cos_t * px - sin_t * py + center[0]\n                    sample_y = sin_t * px + cos_t * py + center[1]\n                    if 0 <= sample_x <= bounds[0] and 0 <= sample_y <= bounds[1]:\n                        if not is_in_obstacle((sample_x, sample_y)):\n                            return (sample_x, sample_y)\n                # fallback uniform if no sample found inside ellipsoid\n                return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n            else:\n                # For 3D or higher, fallback uniform sampling with goal bias\n                return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n\n        def connect_trees(node_a, tree_b):\n            nearest_b = nearest(tree_b, node_a.position)\n            dist_ab = dist(node_a.position, nearest_b.position)\n            radius_connect = max(self.step_size * 1.5, adaptive_radius(len(tree_b)))\n            if dist_ab <= radius_connect and not is_edge_in_obstacle(node_a.position, nearest_b.position):\n                return node_a, nearest_b\n            return None\n\n        def rewire(tree, new_node, near_nodes_list):\n            # Cache checked edges to reduce redundant collision calls\n            for near in near_nodes_list:\n                if near == new_node.parent:\n                    continue\n                tentative_cost = new_node.cost + dist(new_node.position, near.position)\n                if tentative_cost + 1e-12 < near.cost:\n                    if not is_edge_in_obstacle(new_node.position, near.position):\n                        old_parent = near.parent\n                        if old_parent:\n                            try:\n                                edges.remove((old_parent, near))\n                            except ValueError:\n                                pass\n                            old_parent.remove_child(near)\n                        near.parent = new_node\n                        near.cost = tentative_cost\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n\n        def incremental_shortcut(path):\n            if len(path) < 3:\n                return path\n            shortcut_path = path[:]\n            attempts = 0\n            while attempts < self.max_incremental_attempts:\n                if len(shortcut_path) < 3:\n                    break\n                i = random.randint(0, len(shortcut_path) - 3)\n                j = random.randint(i + 2, len(shortcut_path) - 1)\n                if not is_edge_in_obstacle(shortcut_path[i], shortcut_path[j]):\n                    shortcut_path = shortcut_path[:i + 1] + shortcut_path[j:]\n                    attempts = 0\n                else:\n                    attempts += 1\n            return shortcut_path\n\n        def extract_path(node_start, node_goal):\n            path_start = node_start.path_from_root()\n            path_goal = node_goal.path_from_root()\n            path_goal.reverse()\n            if path_start[-1] == path_goal[0]:\n                path_goal = path_goal[1:]\n            return path_start + path_goal\n\n        for iteration in range(self.max_iter):\n            # Sampling with goal bias, ellipsoidal informed, and uniform fallback\n            p = random.random()\n            if p < self.goal_sample_rate:\n                sample = goal_pos\n            elif p < self.goal_sample_rate + 0.5:\n                sample = informed_sample(best_cost, c_min, start_pos, goal_pos)\n            else:\n                sample = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if is_in_obstacle(sample):\n                    continue  # resample next iteration\n\n            # Alternate expansion direction each iteration to balance exploration\n            for tree_a, tree_b in [(tree_start, tree_goal), (tree_goal, tree_start)]:\n                nearest_node = nearest(tree_a, sample)\n                new_pos = steer(nearest_node.position, sample)\n                if is_in_obstacle(new_pos) or is_edge_in_obstacle(nearest_node.position, new_pos):\n                    continue\n\n                radius = adaptive_radius(len(tree_a))\n                near_nodes_list = near_nodes(tree_a, new_pos, radius)\n\n                # Choose best parent minimizing cost with collision check caching\n                min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n                min_parent = nearest_node\n                for near_node in near_nodes_list:\n                    c = near_node.cost + dist(near_node.position, new_pos)\n                    if c + 1e-12 < min_cost and not is_edge_in_obstacle(near_node.position, new_pos):\n                        min_cost = c\n                        min_parent = near_node\n\n                new_node = Node(new_pos, parent=min_parent, cost=min_cost)\n                min_parent.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((min_parent, new_node))\n\n                # Rewire for optimal local connectivity\n                rewire(tree_a, new_node, near_nodes_list)\n\n                # Try connect trees for solution path\n                connection = connect_trees(new_node, tree_b)\n                if connection:\n                    n_start, n_goal = connection\n                    cost_path = n_start.cost + dist(n_start.position, n_goal.position) + n_goal.cost\n                    if cost_path < best_cost:\n                        best_cost = cost_path\n                        best_connection = (n_start, n_goal)\n\n            # Periodic incremental shortcut for improved smoothing & shortening\n            if best_connection and (iteration % self.incremental_shortcut_freq == 0):\n                raw_path = extract_path(best_connection[0], best_connection[1])\n                improved_path = incremental_shortcut(raw_path)\n                if improved_path and len(improved_path) >= 2:\n                    # Anytime return with improved path\n                    return PlannerResult(True, improved_path, nodes, edges)\n\n        # Final check for path existence\n        if best_connection is None:\n            # No path found\n            return PlannerResult(False, [], nodes, edges)\n\n        # Final incremental shortcut to enhance smoothness before output\n        raw_path = extract_path(best_connection[0], best_connection[1])\n        smooth_path = incremental_shortcut(raw_path)\n        return PlannerResult(True, smooth_path, nodes, edges)",
          "objective": -31.2257,
          "time_improvement": 51.0,
          "length_improvement": 14.0,
          "smoothness_improvement": 1522.0,
          "node_improvement": 74.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.013933587074279784,
                    "num_nodes_avg": 116.5,
                    "path_length_avg": 171.79211538902877,
                    "smoothness_avg": 0.03317749586932739,
                    "success_improvement": 0.0,
                    "time_improvement": 45.97460584518533,
                    "node_improvement": 70.66230168723243,
                    "length_improvement": 5.838019335002121,
                    "smoothness_improvement": 419.2998564403915,
                    "objective_score": 19.39169263675883
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.02943270206451416,
                    "num_nodes_avg": 263.1,
                    "path_length_avg": 242.5530872369648,
                    "smoothness_avg": 0.08854945865224972,
                    "success_improvement": 0.0,
                    "time_improvement": 82.22402022362799,
                    "node_improvement": 82.3221124773231,
                    "length_improvement": 19.028797976785,
                    "smoothness_improvement": 2178.4413507194618,
                    "objective_score": 46.9766916067567
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.037827491760253906,
                    "num_nodes_avg": 251.9,
                    "path_length_avg": 125.89239125097421,
                    "smoothness_avg": 0.16254916505338007,
                    "success_improvement": 0.0,
                    "time_improvement": 25.458928414543454,
                    "node_improvement": 67.97202797202797,
                    "length_improvement": 16.38826808257113,
                    "smoothness_improvement": 1967.61338134769,
                    "objective_score": 27.30870628064416
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e2",
          "algorithm_description": "A novel bidirectional RRT* planner integrating adaptive neighborhood radius scaling, continuous ellipsoidal informed and uniform sampling blend, and aggressive incremental pruning and shortcutting. The planner dynamically adjusts rewiring radius by node density, performs frequent curvature-aware shortcutting and midpoint smoothing, and prunes children links to reduce overhead, enabling faster convergence, improved path length, and superior smoothness. Efficient k-nearest searches utilize spatial hashing with early exits. The planning alternates expansions from start and goal, maintaining coherent trees with iterative best path updates and progressive refinement, balancing exploration and exploitation within map bounds and obstacle constraints.",
          "planning_mechanism": "The planner alternates bidirectional expansions, samples adaptively with a mix of uniform and ellipsoidal informed sampling once an initial path is found, and steers with step limits. It uses spatial hash grids for efficient neighbor retrieval and applies adaptive radius rewiring scaling logarithmically with tree size. Rewiring prunes unnecessary child-parent links, preserving curvature constraints to maintain smoothness. Incremental shortcutting occurs frequently with curvature-aware checks and midpoint smoothing to progressively refine the path. Early collision detection optimizes runtime, and the best path is updated dynamically upon connecting the trees.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\nclass Planner:\n    def __init__(self, max_iter=3500, step_size=5.5, gamma_rrt_star=40.0,\n                 goal_sample_rate=0.07, shortcut_every=20, curvature_thresh=0.35):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.gamma_rrt_star = gamma_rrt_star\n        self.goal_sample_rate = goal_sample_rate\n        self.shortcut_every = shortcut_every\n        self.curvature_thresh = curvature_thresh  # radians\n\n    def plan(self, map):\n        import math\n        import random\n\n        bounds = map.size\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        all_nodes = start_tree + goal_tree\n        edges = []\n\n        best_cost = float('inf')\n        best_pair = (None, None)\n\n        c_min = math.dist(start_pos, goal_pos)  # Min cost lower bound\n\n        # Spatial hashing cell size for neighbor queries:\n        # Dynamically adjusted, start from step_size, scaled by gamma_rrt_star\n        def cell_size(radius):\n            return max(radius / 3.0, self.step_size / 4.0)\n\n        def in_bounds(p):\n            return all(0 <= p[i] <= bounds[i] for i in range(dim))\n\n        def collision_node(p):\n            px = p[0]\n            py = p[1]\n            pz = p[2] if is_3d else 0.0\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w_, h_ = obs\n                    if x <= px <= x + w_ and y <= py <= y + h_:\n                        return True\n            return False\n\n        def collision_edge(a, b, resolution=1.0):\n            dist_ab = math.dist(a, b)\n            steps = max(3, int(dist_ab / resolution))\n            for i in range(steps + 1):\n                interp = tuple(a[j] + (b[j] - a[j]) * i / steps for j in range(dim))\n                if collision_node(interp):\n                    return True\n            return False\n\n        def steer(from_p, to_p):\n            d = math.dist(from_p, to_p)\n            if d <= self.step_size:\n                return to_p\n            ratio = self.step_size / d\n            return tuple(from_p[i] + ratio * (to_p[i] - from_p[i]) for i in range(dim))\n\n        def hash_coord(p, c_size):\n            return tuple(int(p[i] // c_size) for i in range(dim))\n\n        def add_to_hash(node, tree_hash, c_size):\n            h = hash_coord(node.position, c_size)\n            if h not in tree_hash:\n                tree_hash[h] = []\n            tree_hash[h].append(node)\n\n        def near_nodes(tree_hash, pos, radius, c_size):\n            h = hash_coord(pos, c_size)\n            neighbors = []\n            r2 = radius * radius\n            # Generate neighbor cells to search around pos\n            ranges = [range(h_i - 1, h_i + 2) for h_i in h]\n            if dim == 2:\n                for cx in ranges[0]:\n                    for cy in ranges[1]:\n                        cell = (cx, cy)\n                        if cell in tree_hash:\n                            for n in tree_hash[cell]:\n                                dist2 = 0.0\n                                for i in range(dim):\n                                    diff = n.position[i] - pos[i]\n                                    dist2 += diff * diff\n                                    if dist2 > r2:\n                                        break\n                                else:\n                                    neighbors.append(n)\n            else:  # 3D\n                for cx in ranges[0]:\n                    for cy in ranges[1]:\n                        for cz in ranges[2]:\n                            cell = (cx, cy, cz)\n                            if cell in tree_hash:\n                                for n in tree_hash[cell]:\n                                    dist2 = 0.0\n                                    for i in range(dim):\n                                        diff = n.position[i] - pos[i]\n                                        dist2 += diff * diff\n                                        if dist2 > r2:\n                                            break\n                                    else:\n                                        neighbors.append(n)\n            return neighbors\n\n        def angle_between(a, b, c):\n            # angle at b formed by points a-b-c\n            ab = [a[i] - b[i] for i in range(dim)]\n            cb = [c[i] - b[i] for i in range(dim)]\n            lab = math.sqrt(sum(x * x for x in ab))\n            lcb = math.sqrt(sum(x * x for x in cb))\n            if lab < 1e-14 or lcb < 1e-14:\n                return 0.0\n            dotp = sum(ab[i] * cb[i] for i in range(dim))\n            val = max(min(dotp / (lab * lcb), 1.0), -1.0)\n            return math.acos(val)\n\n        def prune_subtree(node, edges):\n            # Recursively prune children of node\n            stack = [node]\n            while stack:\n                cur = stack.pop()\n                if cur.parent:\n                    try:\n                        cur.parent.remove_child(cur)\n                        edges.remove((cur.parent, cur))\n                    except Exception:\n                        pass\n                    cur.parent = None\n                    cur.cost = float('inf')\n                for child in cur.children:\n                    stack.append(child)\n                cur.children = []\n\n        def rewire(new_node, near_nodes_list, tree_hash, c_size, edges):\n            # Adaptive rewiring with pruning & curvature preservation\n            for near in near_nodes_list:\n                if near is new_node or near is new_node.parent:\n                    continue\n                dist = math.dist(new_node.position, near.position)\n                cost_through_new = new_node.cost + dist\n                if cost_through_new + 1e-15 < near.cost:\n                    # Check collision for edge new_node->near early exit\n                    if collision_edge(new_node.position, near.position):\n                        continue\n                    # Check curvature preservation on near's children if any\n                    # Only rewire if curvature increase acceptable or no children\n                    if near.children:\n                        old_parent = near.parent\n                        if old_parent is None:\n                            continue\n                        ang_before = angle_between(old_parent.position, near.position, near.children[0].position) if near.children else 0.0\n                        ang_after = angle_between(new_node.position, near.position, near.children[0].position) if near.children else 0.0\n                        if ang_after > ang_before + self.curvature_thresh:\n                            continue\n                    # Rewire: remove old edge\n                    if near.parent:\n                        try:\n                            near.parent.remove_child(near)\n                            edges.remove((near.parent, near))\n                        except Exception:\n                            pass\n                    near.parent = new_node\n                    near.cost = cost_through_new\n                    new_node.add_child(near)\n                    edges.append((new_node, near))\n                    # Update subtree costs recursively\n                    self._update_subtree_costs(near, edges)\n                    # Update spatial hash not required (positions unchanged)\n\n        def path_to_positions(n_start, n_goal):\n            # Extract path from start tree node to goal tree node\n            path_start = []\n            cur = n_start\n            while cur:\n                path_start.append(cur.position)\n                cur = cur.parent\n            path_start.reverse()\n            path_goal = []\n            cur = n_goal\n            while cur:\n                path_goal.append(cur.position)\n                cur = cur.parent\n            # If connecting node repeated, avoid duplication at junction\n            if path_start[-1] == path_goal[0]:\n                return path_start + path_goal[1:]\n            else:\n                return path_start + path_goal\n\n        def incremental_shortcut(path, max_attempts=70, max_passes=3):\n            # Aggressive curvature-aware incremental shortcutting\n            if len(path) < 3:\n                return path[:]\n            p = path[:]\n            changed = True\n            attempts_per_pass = max_attempts\n            passes = 0\n            while changed and passes < max_passes:\n                changed = False\n                attempts = 0\n                while attempts < attempts_per_pass and len(p) >= 3:\n                    i = random.randint(0, len(p) - 3)\n                    j = random.randint(i + 2, len(p) - 1)\n                    if not collision_edge(p[i], p[j]):\n                        # Check curvature at shortcut bounds\n                        if i > 0 and j < len(p) - 1:\n                            ang_before = angle_between(p[i-1], p[i], p[i+1])\n                            ang_after = angle_between(p[i-1], p[j], p[j+1])\n                            if ang_after > ang_before + self.curvature_thresh:\n                                attempts +=1\n                                continue\n                        p = p[:i+1] + p[j:]\n                        changed = True\n                        attempts = 0\n                    else:\n                        attempts += 1\n                passes += 1\n            return p\n\n        def midpoint_smooth(path):\n            if len(path) < 4:\n                return path[:]\n            new_path = path[:]\n            changed = False\n            for i in range(1, len(path) - 1):\n                a, b, c = new_path[i - 1], new_path[i], new_path[i + 1]\n                midpoint = tuple((a[d] + c[d]) * 0.5 for d in range(dim))\n                if (not collision_node(midpoint) and\n                    not collision_edge(a, midpoint) and\n                    not collision_edge(midpoint, c)):\n                    ang_before = angle_between(a, b, c)\n                    ang_after = angle_between(a, midpoint, c)\n                    if ang_after + 1e-8 < ang_before:\n                        new_path[i] = midpoint\n                        changed = True\n            return new_path if changed else path\n\n        def adaptive_near_radius(n_nodes):\n            if n_nodes <= 1:\n                return max(self.step_size * 3.0, 10.0)\n            val = (math.log(n_nodes) / n_nodes) ** (1.0 / dim)\n            r = self.gamma_rrt_star * val\n            return min(r, self.step_size * 50.0)\n\n        def sample_informed(best_cost):\n            # Mix uniform and ellipsoidal informed sampling with goal bias\n            if best_cost == float('inf') or best_cost <= c_min:\n                # Uniform sampling with goal bias\n                if random.random() < self.goal_sample_rate:\n                    return goal_pos\n                while True:\n                    pt = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                    if not collision_node(pt):\n                        return pt\n            # Ellipsoidal informed sampling around best solution found\n            center = tuple((start_pos[i] + goal_pos[i]) * 0.5 for i in range(dim))\n            dir_vec = [goal_pos[i] - start_pos[i] for i in range(dim)]\n            length = math.dist(start_pos, goal_pos)\n            if length < 1e-14:\n                # Avoid degenerate rotation matrix\n                if dim == 2:\n                    R = [[1.0, 0.0], [0.0, 1.0]]\n                else:\n                    R = [[1.0 if i == j else 0.0 for j in range(dim)] for i in range(dim)]\n            else:\n                if dim == 2:\n                    a1 = [1, 0]\n                    a2 = [dir_vec[0] / length, dir_vec[1] / length]\n                    cos_t = a1[0] * a2[0] + a1[1] * a2[1]\n                    sin_t = a1[0] * a2[1] - a1[1] * a2[0]\n                    R = [[cos_t, -sin_t], [sin_t, cos_t]]\n                else:\n                    # 3D rotation matrix aligning x-axis to dir_vec\n                    from math import sqrt\n                    a1 = [1, 0, 0]\n                    a2 = [dir_vec[i] / length for i in range(3)]\n                    v = [a1[1] * a2[2] - a1[2] * a2[1],\n                         a1[2] * a2[0] - a1[0] * a2[2],\n                         a1[0] * a2[1] - a1[1] * a2[0]]\n                    s = sqrt(sum(x * x for x in v))\n                    c = sum(a1[i] * a2[i] for i in range(3))\n                    if s < 1e-14:\n                        R = [[1.0 if i == j else 0.0 for j in range(3)] for i in range(3)]\n                    else:\n                        # Skew-symmetric cross-product matrix vx\n                        vx = [[0, -v[2], v[1]],\n                              [v[2], 0, -v[0]],\n                              [-v[1], v[0], 0]]\n                        I = [[1 if i == j else 0 for j in range(3)] for i in range(3)]\n                        # vx^2\n                        vx2 = [[sum(vx[i][k]*vx[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n                        R = [[I[i][j] + vx[i][j] + vx2[i][j] * ((1 - c) / (s * s)) for j in range(3)] for i in range(3)]\n\n            a1_val = best_cost * 0.5\n            rad_term = best_cost * best_cost - c_min * c_min\n            a_other = math.sqrt(rad_term) * 0.5 if rad_term > 0 else 0.0\n\n            for _ in range(100):\n                if dim == 2:\n                    r = random.uniform(0, 1) ** 0.5\n                    theta = random.uniform(0, 2 * math.pi)\n                    ball = [r * math.cos(theta), r * math.sin(theta)]\n                    # Scale ellipse\n                    x_scaled = [a1_val * ball[0], a_other * ball[1]]\n                    # Rotate and translate center\n                    pt = (center[0] + R[0][0] * x_scaled[0] + R[0][1] * x_scaled[1],\n                          center[1] + R[1][0] * x_scaled[0] + R[1][1] * x_scaled[1])\n                else:\n                    while True:\n                        ball = [random.uniform(-1, 1) for _ in range(dim)]\n                        if sum(x * x for x in ball) <= 1.0:\n                            break\n                    x_scaled = [a1_val * ball[0], a_other * ball[1], a_other * ball[2]]\n                    pt = tuple(center[i] + sum(R[i][j] * x_scaled[j] for j in range(dim)) for i in range(dim))\n\n                if any(pt[d] < 0.0 or pt[d] > bounds[d] for d in range(dim)):\n                    continue\n                if collision_node(pt):\n                    continue\n                # Goal bias in ellipsoidal sampling: rare but useful\n                if random.random() < self.goal_sample_rate * 0.3:\n                    return goal_pos\n                return pt\n            # Fallback uniform random if ellipsoidal fails\n            while True:\n                pt = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not collision_node(pt):\n                    return pt\n\n        def extract_path(n_start, n_goal):\n            path_start = []\n            cur = n_start\n            while cur:\n                path_start.append(cur.position)\n                cur = cur.parent\n            path_start.reverse()\n            path_goal = []\n            cur = n_goal\n            while cur:\n                path_goal.append(cur.position)\n                cur = cur.parent\n            if path_start[-1] == path_goal[0]:\n                return path_start + path_goal[1:]\n            return path_start + path_goal\n\n        # Initialize spatial hash maps for neighbor queries\n        start_hash = {}\n        goal_hash = {}\n\n        # Initial coarse radius for hashing\n        init_radius = adaptive_near_radius(1)\n        start_csize = cell_size(init_radius)\n        goal_csize = cell_size(init_radius)\n\n        add_to_hash(start_tree[0], start_hash, start_csize)\n        add_to_hash(goal_tree[0], goal_hash, goal_csize)\n\n        expand_start = True  # alternate expansion flag\n\n        for iteration in range(self.max_iter):\n            rad_start = adaptive_near_radius(len(start_tree))\n            rad_goal = adaptive_near_radius(len(goal_tree))\n\n            csize_start = cell_size(rad_start)\n            csize_goal = cell_size(rad_goal)\n\n            sample = sample_informed(best_cost)\n\n            tree_a = start_tree if expand_start else goal_tree\n            tree_b = goal_tree if expand_start else start_tree\n            hash_a = start_hash if expand_start else goal_hash\n            hash_b = goal_hash if expand_start else start_hash\n            csize_a = csize_start if expand_start else csize_goal\n            csize_b = csize_goal if expand_start else csize_start\n\n            expand_start = not expand_start\n\n            # Nearest node in tree_a (using spatial hash and early-exit approx)\n            candidates = near_nodes(hash_a, sample, rad_start if expand_start else rad_goal, csize_a)\n            if candidates:\n                nearest_node = None\n                min_dist = float('inf')\n                r2 = (rad_start if expand_start else rad_goal)**2\n                for n in candidates:\n                    d_sq = 0.0\n                    for i in range(dim):\n                        diff = n.position[i] - sample[i]\n                        d_sq += diff*diff\n                        if d_sq > r2 or d_sq >= min_dist:\n                            break\n                    else:\n                        if d_sq < min_dist:\n                            min_dist = d_sq\n                            nearest_node = n\n            else:\n                # Brute force fallback\n                nearest_node = None\n                min_dist = float('inf')\n                for n in tree_a:\n                    d = math.dist(n.position, sample)\n                    if d < min_dist:\n                        min_dist = d\n                        nearest_node = n\n\n            if nearest_node is None:\n                continue\n\n            new_pos = steer(nearest_node.position, sample)\n            if not in_bounds(new_pos):\n                continue\n            if collision_node(new_pos) or collision_edge(nearest_node.position, new_pos):\n                continue\n\n            # Find near nodes for rewiring around new_pos\n            nearlist = near_nodes(hash_a, new_pos, rad_start if expand_start else rad_goal, csize_a)\n\n            # Choose best parent among near nodes\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in nearlist:\n                cost_cand = node.cost + math.dist(node.position, new_pos)\n                if cost_cand + 1e-15 < min_cost:\n                    if not collision_edge(node.position, new_pos):\n                        min_cost = cost_cand\n                        best_parent = node\n\n            new_node = Node(new_pos, best_parent, min_cost)\n            best_parent.add_child(new_node)\n            tree_a.append(new_node)\n            all_nodes.append(new_node)\n            edges.append((best_parent, new_node))\n            add_to_hash(new_node, hash_a, csize_a)\n\n            rewire(new_node, nearlist, hash_a, csize_a, edges)\n\n            # Try to connect new_node with tree_b nodes within radius\n            candidates_b = near_nodes(hash_b, new_node.position, rad_goal if expand_start else rad_start, csize_b)\n            for nb_node in candidates_b:\n                if nb_node is None or nb_node == new_node:\n                    continue\n                dist_nb = math.dist(new_node.position, nb_node.position)\n                if dist_nb > rad_goal if expand_start else rad_start:\n                    continue\n                if collision_edge(new_node.position, nb_node.position):\n                    continue\n                cost_total = new_node.cost + dist_nb + nb_node.cost\n                if cost_total + 1e-15 < best_cost:\n                    best_cost = cost_total\n                    # Keep order start_goal consistent\n                    if expand_start:\n                        best_pair = (new_node, nb_node)\n                    else:\n                        best_pair = (nb_node, new_node)\n\n            if best_pair[0] and best_pair[1]:\n                if iteration % self.shortcut_every == 0 or iteration == self.max_iter - 1:\n                    raw_path = extract_path(best_pair[0], best_pair[1])\n                    short_path = incremental_shortcut(raw_path)\n                    smooth_path = midpoint_smooth(short_path)\n                    return PlannerResult(True, smooth_path, all_nodes, edges)\n\n        # After max_iter if solution found, output best path\n        if best_pair[0] and best_pair[1]:\n            raw_path = extract_path(best_pair[0], best_pair[1])\n            short_path = incremental_shortcut(raw_path)\n            smooth_path = midpoint_smooth(short_path)\n            return PlannerResult(True, smooth_path, all_nodes, edges)\n\n        return PlannerResult(False, [], all_nodes, edges)\n\n    def _update_subtree_costs(self, node, edges):\n        import math\n        stack = [node]\n        while stack:\n            n = stack.pop()\n            for c in n.children:\n                new_cost = n.cost + math.dist(n.position, c.position)\n                if new_cost + 1e-15 < c.cost:\n                    c.cost = new_cost\n                    stack.append(c)",
          "objective": -31.22391,
          "time_improvement": 54.0,
          "length_improvement": 13.0,
          "smoothness_improvement": 1420.0,
          "node_improvement": 66.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.020113253593444826,
                    "num_nodes_avg": 125.9,
                    "path_length_avg": 168.82081614873067,
                    "smoothness_avg": 0.04301686690383043,
                    "success_improvement": 0.0,
                    "time_improvement": 22.013875728568188,
                    "node_improvement": 68.29513976328381,
                    "length_improvement": 7.466635531858964,
                    "smoothness_improvement": 573.3073796665486,
                    "objective_score": 13.950680936018578
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.021378970146179198,
                    "num_nodes_avg": 299.1,
                    "path_length_avg": 242.92476535843707,
                    "smoothness_avg": 0.07593593415621581,
                    "success_improvement": 0.0,
                    "time_improvement": 87.08809880502503,
                    "node_improvement": 79.90324531344486,
                    "length_improvement": 18.904721121676012,
                    "smoothness_improvement": 1853.8862802820397,
                    "objective_score": 46.73869371592332
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.024417471885681153,
                    "num_nodes_avg": 398.2,
                    "path_length_avg": 129.84154477243922,
                    "smoothness_avg": 0.15185423110063145,
                    "success_improvement": 0.0,
                    "time_improvement": 51.88408125756698,
                    "node_improvement": 49.37062937062937,
                    "length_improvement": 13.765428352096576,
                    "smoothness_improvement": 1831.5746108866356,
                    "objective_score": 32.982354442961224
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "path_expert",
          "algorithm_description": "An enhanced bidirectional RRT* with dynamic adaptive sampling focused within an ellipsoidal informed set, combined with optimized local rewiring and iterative progressive shortcutting that does not terminate prematurely, allowing multiple path refinements per iteration. The planner dynamically adjusts the neighborhood radius based on the iteration count for effective rewiring, expands trees alternately, and maintains early-best path updates to accelerate convergence. Path extraction merges trees smoothly, and shortcutting aggressively reduces path length and smoothness without early exit, balancing exploration and exploitation for faster planning with superior path length and smoothness.",
          "planning_mechanism": "The planner alternates expansions of two trees from start and goal, sampling points adaptively within a progressively shrinking ellipsoidal subset defined by the current best path cost to focus search. Each new node is connected optimally within a dynamically scaled radius, with rewiring applied to improve local costs. Upon successful connection, the combined path is extracted and shortcut multiple times per call to incrementally smooth and shorten it. The radius decreases over iterations, balancing exploration and exploitation. This approach improves convergence speed, path cost, and smoothness while reducing search time.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n    def add_child(self, child):\n        self.children.append(child)\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except ValueError:\n            pass\nclass Planner:\n    def __init__(self, max_iter=4000, step_size=6.0, radius_max=15.0,\n                 radius_min=5.0, shortcut_interval=25, shortcut_attempts=100):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.radius_max = radius_max\n        self.radius_min = radius_min\n        self.shortcut_interval = shortcut_interval\n        self.shortcut_attempts = shortcut_attempts\n\n    def plan(self, map):\n        import random\n        import math\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = (len(bounds) == 3)\n        dim = 3 if is_3d else 2\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        all_nodes = start_tree + goal_tree\n        edges = []\n\n        best_cost = float('inf')\n        solution_start = None\n        solution_goal = None\n\n        c_min = math.dist(start_pos, goal_pos)\n        # Prevent zero division at start:\n        c_min = max(c_min, 1e-10)\n\n        def radius(iter_idx):\n            # Shrinking radius between radius_max and radius_min over iterations to balance exploration/exploitation\n            fraction = min(iter_idx/self.max_iter,1.0)\n            return self.radius_max * (1.0 - fraction) + self.radius_min * fraction\n\n        for i in range(self.max_iter):\n            # Adaptive informed sampling focusing search if a solution exists\n            if best_cost < float('inf'):\n                sample = self._informed_sample(bounds, obstacles, is_3d, start_pos, goal_pos, best_cost, c_min)\n            else:\n                sample = self._sample_free(bounds, obstacles, is_3d)\n\n            # Alternating tree expansion for balanced bidirectional growth\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest = self._nearest(tree_a, sample)\n                new_pos = self._steer(nearest.position, sample, self.step_size)\n\n                if (self._is_in_obstacle(new_pos, obstacles, is_3d) or\n                    self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d)):\n                    continue  # Skip invalid nodes or edges\n\n                new_node = Node(new_pos)\n\n                r = radius(i)\n                near_nodes = self._near(tree_a, new_pos, r)\n\n                # Choose parent with minimal cost feasible edge\n                min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n                min_parent = nearest\n                for near in near_nodes:\n                    if near == nearest:\n                        continue\n                    tentative_cost = near.cost + math.dist(near.position, new_pos)\n                    if tentative_cost < min_cost:\n                        if not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d):\n                            min_cost = tentative_cost\n                            min_parent = near\n\n                new_node.parent = min_parent\n                new_node.cost = min_cost\n                min_parent.add_child(new_node)\n                tree_a.append(new_node)\n                all_nodes.append(new_node)\n                edges.append((min_parent, new_node))\n\n                # Rewire nodes around new node to improve their cost if beneficial\n                for near in near_nodes:\n                    if near == min_parent:\n                        continue\n                    new_cost = new_node.cost + math.dist(new_node.position, near.position)\n                    if new_cost < near.cost:\n                        if not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                            old_parent = near.parent\n                            if old_parent:\n                                try:\n                                    edges.remove((old_parent, near))\n                                except ValueError:\n                                    pass\n                                old_parent.remove_child(near)\n                            near.parent = new_node\n                            near.cost = new_cost\n                            new_node.add_child(near)\n                            edges.append((new_node, near))\n\n                # Attempt connection to the other tree\n                connect_node = self._nearest(tree_b, new_node.position)\n                dist_connect = math.dist(new_node.position, connect_node.position)\n                if dist_connect <= self.step_size:\n                    if not self._is_edge_in_obstacle(new_node.position, connect_node.position, obstacles, is_3d):\n                        total_path_cost = new_node.cost + dist_connect + connect_node.cost\n                        if total_path_cost < best_cost:\n                            best_cost = total_path_cost\n                            if tree_a is start_tree:\n                                solution_start, solution_goal = new_node, connect_node\n                            else:\n                                solution_start, solution_goal = connect_node, new_node\n\n            # Progressive shortcutting every shortcut_interval iterations and final iteration\n            if best_cost < float('inf') and solution_start and solution_goal and (i % self.shortcut_interval == 0 or i == self.max_iter - 1):\n                raw_path = self._extract_path(solution_start, solution_goal)\n                # Aggressive multiple shortcutting iterations improving smoothness and length in one call\n                shortcut_path = self._shortcut_path(raw_path, obstacles, is_3d, max_attempts=self.shortcut_attempts)\n                if shortcut_path:\n                    return PlannerResult(True, shortcut_path, all_nodes, edges)\n\n        # No solution found\n        return PlannerResult(False, [], all_nodes, edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        import random\n        while True:\n            pt = tuple(random.uniform(0, bounds[i]) for i in range(len(bounds)))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def _informed_sample(self, bounds, obstacles, is_3d, start, goal, c_max, c_min):\n        import random\n        import math\n        dim = 3 if is_3d else 2\n\n        if c_max <= c_min:\n            return self._sample_free(bounds, obstacles, is_3d)\n\n        center = tuple((start[i] + goal[i]) / 2.0 for i in range(dim))\n        dir_vec = [goal[i] - start[i] for i in range(dim)]\n        length = math.dist(start, goal)\n        if length < 1e-10:\n            return self._sample_free(bounds, obstacles, is_3d)\n\n        # Rotation matrix aligning x-axis with direction vector\n        if dim == 2:\n            a1 = [1.0, 0.0]\n            a2 = [dir_vec[0] / length, dir_vec[1] / length]\n            cos_theta = a1[0] * a2[0] + a1[1] * a2[1]\n            sin_theta = a1[0] * a2[1] - a1[1] * a2[0]\n            R = [[cos_theta, -sin_theta], [sin_theta, cos_theta]]\n        else:\n            # Rodrigues' rotation formula for 3D rotation matrix\n            from math import sqrt\n            a1 = [1.0, 0.0, 0.0]\n            a2 = [dir_vec[i] / length for i in range(3)]\n            v = [a1[1]*a2[2] - a1[2]*a2[1],\n                 a1[2]*a2[0] - a1[0]*a2[2],\n                 a1[0]*a2[1] - a1[1]*a2[0]]\n            s = sqrt(sum(vi*vi for vi in v))\n            c = sum(a1[i]*a2[i] for i in range(3))\n            if s < 1e-10:\n                R = [[1,0,0],[0,1,0],[0,0,1]]\n            else:\n                vx = [[0, -v[2], v[1]],\n                      [v[2], 0, -v[0]],\n                      [-v[1], v[0], 0]]\n                I = [[1 if i==j else 0 for j in range(3)] for i in range(3)]\n                vx2 = [[sum(vx[i][k]*vx[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n                R = [[I[i][j] + vx[i][j] + vx2[i][j]*((1 - c)/(s*s)) for j in range(3)] for i in range(3)]\n\n        def sample_unit_ball():\n            if dim == 2:\n                r = random.uniform(0, 1)**0.5\n                theta = random.uniform(0, 2 * math.pi)\n                return [r * math.cos(theta), r * math.sin(theta)]\n            else:\n                while True:\n                    pt = [random.uniform(-1, 1) for _ in range(3)]\n                    if sum(x*x for x in pt) <= 1:\n                        return pt\n\n        x_ball = sample_unit_ball()\n\n        a1_val = c_max / 2.0\n        a_other = math.sqrt(max(c_max*c_max - c_min*c_min, 0)) / 2.0\n\n        # Scale sample inside ellipsoid axes\n        if dim == 2:\n            L = [[a1_val, 0.0], [0.0, a_other]]\n            x_scaled = [L[0][0]*x_ball[0] + L[0][1]*x_ball[1],\n                        L[1][0]*x_ball[0] + L[1][1]*x_ball[1]]\n            pt = (center[0] + R[0][0]*x_scaled[0] + R[0][1]*x_scaled[1],\n                  center[1] + R[1][0]*x_scaled[0] + R[1][1]*x_scaled[1])\n        else:\n            L = [[a1_val, 0.0, 0.0],\n                 [0.0, a_other, 0.0],\n                 [0.0, 0.0, a_other]]\n            x_scaled = [L[0][0]*x_ball[0], L[1][1]*x_ball[1], L[2][2]*x_ball[2]]\n            pt = tuple(center[i] + sum(R[i][j]*x_scaled[j] for j in range(3)) for i in range(3))\n\n        if any(pt[d] < 0 or pt[d] > bounds[d] for d in range(dim)):\n            return self._sample_free(bounds, obstacles, is_3d)\n        if self._is_in_obstacle(pt, obstacles, is_3d):\n            return self._sample_free(bounds, obstacles, is_3d)\n        return pt\n\n    def _nearest(self, tree, point):\n        import math\n        best = None\n        best_dist = float('inf')\n        for node in tree:\n            d = math.dist(node.position, point)\n            if d < best_dist:\n                best_dist = d\n                best = node\n        return best\n\n    def _near(self, tree, point, radius):\n        r_sq = radius*radius\n        dim = len(point)\n        return [n for n in tree if sum((n.position[i] - point[i])**2 for i in range(dim)) <= r_sq]\n\n    def _steer(self, from_pos, to_pos, step_size):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        if dist <= step_size:\n            return to_pos\n        ratio = step_size / dist\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n    def _extract_path(self, node_start, node_goal):\n        path_start = []\n        n = node_start\n        while n is not None:\n            path_start.append(n.position)\n            n = n.parent\n        path_start.reverse()\n\n        path_goal = []\n        n = node_goal\n        while n is not None:\n            path_goal.append(n.position)\n            n = n.parent\n        # Remove duplicated connecting node between two paths\n        if len(path_goal) > 0 and len(path_start) > 0 and path_goal[0] == path_start[-1]:\n            path_goal = path_goal[1:]\n        return path_start + path_goal\n\n    def _shortcut_path(self, path, obstacles, is_3d, max_attempts=100):\n        if len(path) < 3:\n            return path[:]\n        import random\n        new_path = path[:]\n        attempts = 0\n        while attempts < max_attempts:\n            if len(new_path) < 3:\n                break\n            i = random.randint(0, len(new_path) - 3)\n            j = random.randint(i + 2, len(new_path) - 1)\n            if not self._is_edge_in_obstacle(new_path[i], new_path[j], obstacles, is_3d):\n                # Remove intermediate nodes between i and j\n                new_path = new_path[:i+1] + new_path[j:]\n                attempts = 0  # reset after successful shortcut for multiple improvements\n            else:\n                attempts += 1\n        return new_path\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if (x <= px <= x + w) and (y <= py <= y + h) and (z <= pz <= z + d):\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if (x <= px <= x + w) and (y <= py <= y + h):\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            ratio = i / steps\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -31.02809,
          "time_improvement": 43.0,
          "length_improvement": 18.0,
          "smoothness_improvement": 1433.0,
          "node_improvement": 72.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.027813315391540527,
                    "num_nodes_avg": 150.8,
                    "path_length_avg": 158.7550902195503,
                    "smoothness_avg": 0.04475010796054884,
                    "success_improvement": 0.0,
                    "time_improvement": -7.841959056894185,
                    "node_improvement": 62.02467892218585,
                    "length_improvement": 12.983819415277045,
                    "smoothness_improvement": 600.4363659973881,
                    "objective_score": 8.439885762084911
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.032094931602478026,
                    "num_nodes_avg": 270.1,
                    "path_length_avg": 232.67782481248065,
                    "smoothness_avg": 0.10133943332680147,
                    "success_improvement": 0.0,
                    "time_improvement": 80.61615770651433,
                    "node_improvement": 81.8517771954579,
                    "length_improvement": 22.325444817746384,
                    "smoothness_improvement": 2507.5366113420746,
                    "objective_score": 50.117797259312496
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.021543121337890624,
                    "num_nodes_avg": 212.9,
                    "path_length_avg": 122.20039490599746,
                    "smoothness_avg": 0.1015407972611195,
                    "success_improvement": 0.0,
                    "time_improvement": 57.54814091297544,
                    "node_improvement": 72.9307056579784,
                    "length_improvement": 18.840316260931036,
                    "smoothness_improvement": 1191.591446199421,
                    "objective_score": 34.52658926144836
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e2",
          "algorithm_description": "A bidirectional informed RRT* planner with adaptive neighborhood radius scaling, ellipsoidal informed sampling after initial solution, and a continuous progressive path shortcutting mechanism that is integrated throughout planning iterations for improved convergence, path quality, smoothness, and reduced runtime. The planner balances bidirectional tree growth, dynamic rewiring with efficient collision checks, and frequent controlled shortcutting attempts to yield robust, smooth, and short paths efficiently.",
          "planning_mechanism": "The algorithm initializes two trees at the start and goal positions and expands them alternately toward sampled points within the sampling space. Initially uniform random samples are used, and after the first feasible path is found, ellipsoidal informed sampling focuses exploration near the current best solution. An adaptive near radius based on node count allows rewiring of neighbors to improve path cost. After each better solution, the path is progressively shortcut with bounded attempts to smooth and shorten the path continuously. Early collision checks and maintaining tree coherence ensure efficient planning while frequent shortcutting enhances smoothness and final path quality.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n    def add_child(self, child):\n        self.children.append(child)\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except ValueError:\n            pass\nclass Planner:\n    def __init__(self, max_iter=4000, step_size=6.0, gamma_rrt_star=45.0,\n                 shortcut_frequency=20, max_shortcut_attempts=30):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.gamma_rrt_star = gamma_rrt_star\n        self.shortcut_frequency = shortcut_frequency\n        self.max_shortcut_attempts = max_shortcut_attempts\n\n    def plan(self, map):\n        import random\n        import math\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = (len(bounds) == 3)\n        dim = len(bounds)\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        all_nodes = start_tree + goal_tree\n        edges = []\n\n        best_cost = float('inf')\n        best_start_node, best_goal_node = None, None\n        c_min = math.dist(start_pos, goal_pos)\n\n        def unit_ball_volume(d):\n            # 2D or 3D volume of unit ball\n            from math import pi, gamma\n            if d == 2:\n                return pi\n            elif d == 3:\n                return (4.0/3.0)*pi\n            else:\n                return (pi**(d/2))/gamma(d/2 + 1)\n\n        vol_unit_ball = unit_ball_volume(dim)\n\n        def adaptive_radius(n_nodes):\n            if n_nodes <= 1:\n                return self.step_size * 3.0\n            val = (math.log(n_nodes) / n_nodes) ** (1.0 / dim)\n            radius = min(self.step_size * 30.0, self.gamma_rrt_star * val)\n            if radius < self.step_size:\n                radius = self.step_size\n            return radius\n\n        def collision_node(pos):\n            px = pos[0]\n            py = pos[1]\n            pz = pos[2] if is_3d else 0.0\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d_ = obs\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d_:\n                        return True\n                else:\n                    x, y, w_, h_ = obs\n                    if x <= px <= x + w_ and y <= py <= y + h_:\n                        return True\n            return False\n\n        def collision_edge(a, b, resolution=1.0):\n            dist_ab = math.dist(a, b)\n            steps = max(2, int(dist_ab / resolution))\n            for i in range(steps + 1):\n                interp = tuple(a[d] + (b[d] - a[d]) * i / steps for d in range(dim))\n                if collision_node(interp):\n                    return True\n            return False\n\n        def steer(from_p, to_p):\n            dist = math.dist(from_p, to_p)\n            if dist <= self.step_size:\n                return to_p\n            ratio = self.step_size / dist\n            return tuple(from_p[i] + ratio * (to_p[i] - from_p[i]) for i in range(dim))\n\n        def sample_free():\n            while True:\n                pt = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not collision_node(pt):\n                    return pt\n\n        def informed_sample():\n            if best_cost == float('inf') or best_cost <= c_min + 1e-6:\n                return sample_free()\n\n            # center of prolate hyperspheroid\n            center = tuple((start_pos[i] + goal_pos[i]) / 2 for i in range(dim))\n            dir_vec = [goal_pos[i] - start_pos[i] for i in range(dim)]\n            length = math.dist(start_pos, goal_pos)\n            if length < 1e-10:\n                # degenerate case, sample free\n                return sample_free()\n\n            # rotation matrix R aligning x-axis to dir_vec\n            if dim == 2:\n                a1 = [1, 0]\n                a2 = [dir_vec[0] / length, dir_vec[1] / length]\n                cos_theta = a1[0]*a2[0] + a1[1]*a2[1]\n                sin_theta = a1[0]*a2[1] - a1[1]*a2[0]\n                R = [[cos_theta, -sin_theta], [sin_theta, cos_theta]]\n            else:\n                # 3D rotation matrix by axis-angle for direction vector\n                from math import sqrt\n                a1 = [1,0,0]\n                a2 = [dir_vec[i]/length for i in range(3)]\n                v = [a1[1]*a2[2] - a1[2]*a2[1], a1[2]*a2[0] - a1[0]*a2[2], a1[0]*a2[1] - a1[1]*a2[0]]\n                s = sqrt(sum(vi*vi for vi in v))\n                c = sum(a1[i]*a2[i] for i in range(3))\n                if s < 1e-12:\n                    R = [[1,0,0],[0,1,0],[0,0,1]]\n                else:\n                    vx = [[0,-v[2],v[1]],[v[2],0,-v[0]],[-v[1],v[0],0]]\n                    I = [[1 if i==j else 0 for j in range(3)] for i in range(3)]\n                    vx2 = [[sum(vx[i][k]*vx[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n                    R = [[I[i][j] + vx[i][j] + vx2[i][j]*((1 - c)/(s**2)) for j in range(3)] for i in range(3)]\n\n            a1_val = best_cost / 2.0\n            aa = best_cost * best_cost - c_min * c_min\n            a_other = math.sqrt(aa) / 2.0 if aa > 0 else 1e-8\n\n            while True:\n                if dim == 2:\n                    r = random.uniform(0, 1)**0.5\n                    theta = random.uniform(0, 2*math.pi)\n                    x_ball = [r*math.cos(theta), r*math.sin(theta)]\n                    L = [[a1_val, 0],[0, a_other]]\n                    x_scaled = [L[0][0]*x_ball[0] + L[0][1]*x_ball[1],\n                                L[1][0]*x_ball[0] + L[1][1]*x_ball[1]]\n                    pt = (center[0] + R[0][0]*x_scaled[0] + R[0][1]*x_scaled[1],\n                          center[1] + R[1][0]*x_scaled[0] + R[1][1]*x_scaled[1])\n                else:\n                    while True:\n                        x_ball = [random.uniform(-1,1) for _ in range(3)]\n                        if sum(xi*xi for xi in x_ball) <= 1:\n                            break\n                    L = [[a1_val, 0, 0],[0, a_other, 0],[0, 0, a_other]]\n                    x_scaled = [L[0][0]*x_ball[0], L[1][1]*x_ball[1], L[2][2]*x_ball[2]]\n                    pt = tuple(center[i] + sum(R[i][j]*x_scaled[j] for j in range(dim)) for i in range(dim))\n\n                if any(pt[i]<0 or pt[i]>bounds[i] for i in range(dim)):\n                    continue\n                if collision_node(pt):\n                    continue\n                return pt\n\n        def nearest(tree, point):\n            best_node = None\n            best_dist_sq = float('inf')\n            for n in tree:\n                dist_sq = 0.0\n                for i in range(dim):\n                    diff = n.position[i] - point[i]\n                    dist_sq += diff*diff\n                    if dist_sq > best_dist_sq:\n                        break\n                else:\n                    if dist_sq < best_dist_sq:\n                        best_dist_sq = dist_sq\n                        best_node = n\n            return best_node\n\n        def near(tree, point, radius):\n            r_sq = radius*radius\n            near_nodes = []\n            for n in tree:\n                dist_sq = 0.0\n                for i in range(dim):\n                    diff = n.position[i] - point[i]\n                    dist_sq += diff*diff\n                    if dist_sq > r_sq:\n                        break\n                else:\n                    near_nodes.append(n)\n            return near_nodes\n\n        def extract_path(node_start, node_goal):\n            path_start = []\n            n = node_start\n            while n is not None:\n                path_start.append(n.position)\n                n = n.parent\n            path_goal = []\n            n = node_goal\n            while n is not None:\n                path_goal.append(n.position)\n                n = n.parent\n            # Remove duplicate connection if exists\n            if path_start[-1] == path_goal[0]:\n                return list(reversed(path_start)) + path_goal[1:]\n            else:\n                return list(reversed(path_start)) + path_goal\n\n        def progressive_shortcut(path):\n            if len(path) < 3:\n                return path[:]\n            attempts = 0\n            p = path[:]\n            while attempts < self.max_shortcut_attempts:\n                if len(p) < 3:\n                    break\n                i = random.randint(0, len(p) - 3)\n                j = random.randint(i + 2, len(p) - 1)\n                if not collision_edge(p[i], p[j]):\n                    p = p[:i+1] + p[j:]\n                    attempts = 0\n                else:\n                    attempts += 1\n            return p\n\n        def try_extend(tree_a, tree_b):\n            sample = informed_sample()\n            nearest_node = nearest(tree_a, sample)\n            new_pos = steer(nearest_node.position, sample)\n            if any(new_pos[i]<0 or new_pos[i]>bounds[i] for i in range(dim)):\n                return None\n            if collision_node(new_pos):\n                return None\n            if collision_edge(nearest_node.position, new_pos):\n                return None\n\n            radius = adaptive_radius(len(tree_a))\n            near_nodes = near(tree_a, new_pos, radius)\n\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for n in near_nodes:\n                cost_cand = n.cost + math.dist(n.position, new_pos)\n                if cost_cand < min_cost and not collision_edge(n.position, new_pos):\n                    min_cost = cost_cand\n                    best_parent = n\n\n            new_node = Node(new_pos, best_parent, min_cost)\n            best_parent.add_child(new_node)\n            tree_a.append(new_node)\n            all_nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors\n            for n in near_nodes:\n                if n is best_parent or n is new_node:\n                    continue\n                new_cost = new_node.cost + math.dist(new_node.position, n.position)\n                if new_cost < n.cost and not collision_edge(new_node.position, n.position):\n                    if n.parent:\n                        n.parent.remove_child(n)\n                        try:\n                            edges.remove((n.parent, n))\n                        except ValueError:\n                            pass\n                    n.parent = new_node\n                    n.cost = new_cost\n                    new_node.add_child(n)\n                    edges.append((new_node, n))\n\n            # Try connect new_node to tree_b nearest node within step_size\n            nearest_b = nearest(tree_b, new_node.position)\n            dist_connect = math.dist(new_node.position, nearest_b.position)\n            if dist_connect <= self.step_size and not collision_edge(new_node.position, nearest_b.position):\n                total_cost = new_node.cost + dist_connect + nearest_b.cost\n                return new_node, nearest_b, total_cost\n            return None\n\n        for iteration in range(self.max_iter):\n            # Alternate tree expansion\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                res = try_extend(tree_a, tree_b)\n                if res is not None:\n                    node_a, node_b, total_cost = res\n                    if total_cost < best_cost:\n                        best_cost = total_cost\n                        if tree_a is start_tree:\n                            best_start_node, best_goal_node = node_a, node_b\n                        else:\n                            best_start_node, best_goal_node = node_b, node_a\n\n            # Progressive shortcutting after improvement every shortcut_frequency iterations\n            if best_start_node and best_goal_node and iteration % self.shortcut_frequency == 0:\n                raw_path = extract_path(best_start_node, best_goal_node)\n                smoothed_path = progressive_shortcut(raw_path)\n                if smoothed_path and len(smoothed_path) >= 2:\n                    return PlannerResult(True, smoothed_path, all_nodes, edges)\n\n        # Return best path if found after all iterations\n        if best_start_node and best_goal_node:\n            raw_path = extract_path(best_start_node, best_goal_node)\n            smoothed_path = progressive_shortcut(raw_path)\n            return PlannerResult(True, smoothed_path, all_nodes, edges)\n        return PlannerResult(False, [], all_nodes, edges)",
          "objective": -30.86625,
          "time_improvement": 49.0,
          "length_improvement": 16.0,
          "smoothness_improvement": 1362.0,
          "node_improvement": 74.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.014555788040161133,
                    "num_nodes_avg": 113.0,
                    "path_length_avg": 166.47544577451146,
                    "smoothness_avg": 0.04056194526980769,
                    "success_improvement": 0.0,
                    "time_improvement": 43.5621149161771,
                    "node_improvement": 71.5436917652984,
                    "length_improvement": 8.752170198740378,
                    "smoothness_improvement": 534.8825251464398,
                    "objective_score": 20.994349219829555
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.023828458786010743,
                    "num_nodes_avg": 231.4,
                    "path_length_avg": 239.15098806234386,
                    "smoothness_avg": 0.09785800279848708,
                    "success_improvement": 0.0,
                    "time_improvement": 85.60872187154955,
                    "node_improvement": 84.45205939662702,
                    "length_improvement": 20.164516605268677,
                    "smoothness_improvement": 2417.956896275493,
                    "objective_score": 49.87111100600353
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.042378020286560056,
                    "num_nodes_avg": 277.8,
                    "path_length_avg": 122.653747084001,
                    "smoothness_avg": 0.09689054697656518,
                    "success_improvement": 0.0,
                    "time_improvement": 16.49187147138513,
                    "node_improvement": 64.67895740623013,
                    "length_improvement": 18.539221330611955,
                    "smoothness_improvement": 1132.4406058256611,
                    "objective_score": 21.733297268911016
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "An efficient bidirectional RRT* with adaptive informed sampling and incremental path shortcutting, focusing sampling within an ellipsoidal subset around the best path to accelerate convergence, combined with local rewiring for path optimization and progressive shortcutting to improve path smoothness and length while reducing planning time. The planner grows two trees from start and goal, alternately expanding toward sampled points focused by current best solution, connects the two trees when possible, rewires locally to optimize costs, and progressively shortcuts the path during planning for smoother results.",
          "planning_mechanism": "The planner alternates growth of two trees (start and goal) using adaptive informed sampling within an ellipsoidal subset defined by the current best path cost. At each iteration, a sample point is generated; nearest nodes are extended toward it with collision checking. The algorithm rewires nearby nodes to optimize path costs locally. Upon connecting both trees, it extracts the combined path and incrementally applies shortcutting to remove unnecessary waypoints and smooth the trajectory. This approach balances efficient exploration, path quality, and runtime performance.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n    def add_child(self, child):\n        self.children.append(child)\nclass Planner:\n    def __init__(self, max_iter=4000, step_size=6.0, radius=12.0, shortcut_interval=50):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.radius = radius\n        self.shortcut_interval = shortcut_interval\n\n    def plan(self, map):\n        import random\n        import math\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = (len(bounds) == 3)\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        best_cost = float('inf')\n        solution_start, solution_goal = None, None\n\n        c_min = math.dist(start_pos, goal_pos)\n        dim = 3 if is_3d else 2\n\n        for i in range(self.max_iter):\n            # Adaptive Sample\n            if best_cost < float('inf'):\n                sample = self._informed_sample(bounds, obstacles, is_3d, start_pos, goal_pos, best_cost, c_min)\n            else:\n                sample = self._sample_free(bounds, obstacles, is_3d)\n\n            # Alternate tree expansion\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest = self._nearest(tree_a, sample)\n                new_pos = self._steer(nearest.position, sample, self.step_size)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                    continue\n\n                new_node = Node(new_pos)\n                near_nodes = self._near(tree_a, new_pos, self.radius)\n\n                min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n                min_parent = nearest\n                for near in near_nodes:\n                    tentative_cost = near.cost + math.dist(near.position, new_pos)\n                    if tentative_cost < min_cost and not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d):\n                        min_cost = tentative_cost\n                        min_parent = near\n\n                new_node.parent = min_parent\n                new_node.cost = min_cost\n                min_parent.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((min_parent, new_node))\n\n                # Rewire near nodes to new_node if beneficial\n                for near in near_nodes:\n                    if near is min_parent:\n                        continue\n                    new_cost = new_node.cost + math.dist(new_node.position, near.position)\n                    if new_cost < near.cost and not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                        if near.parent:\n                            try: edges.remove((near.parent, near))\n                            except ValueError: pass\n                            # Remove near from old parent's children list safely\n                            try: near.parent.children.remove(near)\n                            except ValueError: pass\n                        near.parent = new_node\n                        near.cost = new_cost\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n\n                # Try to connect both trees to form path\n                connect_node = self._nearest(tree_b, new_node.position)\n                dist_connect = math.dist(new_node.position, connect_node.position)\n                if dist_connect <= self.step_size:\n                    if not self._is_edge_in_obstacle(new_node.position, connect_node.position, obstacles, is_3d):\n                        path_cost = new_node.cost + dist_connect + connect_node.cost\n                        if path_cost < best_cost:\n                            best_cost = path_cost\n                            if tree_a is start_tree:\n                                solution_start, solution_goal = new_node, connect_node\n                            else:\n                                solution_start, solution_goal = connect_node, new_node\n\n            # Progressive shortcutting for smoother path every shortcut_interval iterations\n            if best_cost < float('inf') and solution_start and solution_goal and (i % self.shortcut_interval == 0 or i == self.max_iter-1):\n                raw_path = self._extract_path(solution_start, solution_goal)\n                shortcut_path = self._shortcut_path(raw_path, obstacles, is_3d, max_attempts=50)\n                if shortcut_path:\n                    return PlannerResult(True, shortcut_path, nodes, edges)\n\n        # No solution found\n        return PlannerResult(False, [], nodes, edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        import random\n        while True:\n            pt = tuple(random.uniform(0, bounds[i]) for i in range(len(bounds)))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def _informed_sample(self, bounds, obstacles, is_3d, start, goal, c_max, c_min):\n        import random\n        import math\n        dim = 3 if is_3d else 2\n\n        # Reject sample if no valid ellipsoid (e.g. c_max <= c_min)\n        if c_max <= c_min:\n            return self._sample_free(bounds, obstacles, is_3d)\n\n        center = tuple((start[i]+goal[i])/2 for i in range(dim))\n        dir_vec = [goal[i]-start[i] for i in range(dim)]\n        length = math.dist(start, goal)\n        if length == 0:\n            # No interval, uniform sample fallback\n            return self._sample_free(bounds, obstacles, is_3d)\n\n        # Compute rotation matrix R from canonical axis to direction vector\n        if dim == 2:\n            a1 = [1,0]\n            a2 = [dir_vec[0]/length, dir_vec[1]/length]\n            cos_theta = a1[0]*a2[0] + a1[1]*a2[1]\n            sin_theta = a1[0]*a2[1] - a1[1]*a2[0]\n            R = [[cos_theta, -sin_theta],[sin_theta, cos_theta]]\n        else:\n            from math import sqrt\n            a1 = [1,0,0]\n            a2 = [dir_vec[i]/length for i in range(3)]\n            v = [a1[1]*a2[2]-a1[2]*a2[1], a1[2]*a2[0]-a1[0]*a2[2], a1[0]*a2[1]-a1[1]*a2[0]]\n            s = sqrt(sum([vi*vi for vi in v]))\n            c = sum([a1[i]*a2[i] for i in range(3)])\n            if s == 0:\n                R = [[1,0,0],[0,1,0],[0,0,1]]\n            else:\n                vx = [[0,-v[2],v[1]],[v[2],0,-v[0]],[-v[1],v[0],0]]\n                I = [[1 if i==j else 0 for j in range(3)] for i in range(3)]\n                vx2 = [[sum(vx[i][k]*vx[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n                R = [[I[i][j] + vx[i][j] + vx2[i][j]*((1 - c)/(s**2)) for j in range(3)] for i in range(3)]\n\n        # Sample point inside unit ball\n        if dim == 2:\n            r = random.uniform(0,1)**0.5\n            theta = random.uniform(0, 2*math.pi)\n            x_ball = [r*math.cos(theta), r*math.sin(theta)]\n        else:\n            while True:\n                x_ball = [random.uniform(-1,1) for _ in range(3)]\n                if sum(xi*xi for xi in x_ball) <= 1:\n                    break\n\n        a1_val = c_max / 2.0\n        a_other = math.sqrt(c_max**2 - c_min**2) / 2.0\n\n        # Scaling matrix\n        if dim == 2:\n            L = [[a1_val, 0],[0, a_other]]\n            x_scaled = [L[0][0]*x_ball[0] + L[0][1]*x_ball[1],\n                        L[1][0]*x_ball[0] + L[1][1]*x_ball[1]]\n            pt = (center[0] + R[0][0]*x_scaled[0] + R[0][1]*x_scaled[1],\n                  center[1] + R[1][0]*x_scaled[0] + R[1][1]*x_scaled[1])\n        else:\n            L = [[a1_val, 0, 0],[0, a_other, 0],[0, 0, a_other]]\n            x_scaled = [L[0][0]*x_ball[0], L[1][1]*x_ball[1], L[2][2]*x_ball[2]]\n            pt = tuple(center[i] + sum(R[i][j]*x_scaled[j] for j in range(3)) for i in range(3))\n\n        # Reject if outside bounds or in obstacle\n        if any(pt[d] < 0 or pt[d] > bounds[d] for d in range(dim)):\n            return self._sample_free(bounds, obstacles, is_3d)\n        if self._is_in_obstacle(pt, obstacles, is_3d):\n            return self._sample_free(bounds, obstacles, is_3d)\n\n        return pt\n\n    def _nearest(self, tree, point):\n        import math\n        return min(tree, key=lambda n: math.dist(n.position, point))\n\n    def _near(self, tree, point, radius):\n        r_sq = radius*radius\n        return [n for n in tree if sum((n.position[i]-point[i])**2 for i in range(len(point))) <= r_sq]\n\n    def _steer(self, from_pos, to_pos, step_size):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        if dist <= step_size:\n            return to_pos\n        ratio = step_size / dist\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i])*ratio for i in range(len(from_pos)))\n\n    def _extract_path(self, node_start, node_goal):\n        path_start, path_goal = [], []\n        n = node_start\n        while n:\n            path_start.append(n.position)\n            n = n.parent\n        n = node_goal\n        while n:\n            path_goal.append(n.position)\n            n = n.parent\n        return list(reversed(path_start)) + path_goal\n\n    def _shortcut_path(self, path, obstacles, is_3d, max_attempts=30):\n        # Attempt bounded shortcutting to improve smoothness by removing redundant waypoints\n        if len(path) < 3:\n            return path[:]\n        import random\n        new_path = path[:]\n        attempts = 0\n        while attempts < max_attempts:\n            if len(new_path) < 3:\n                break\n            i = random.randint(0, len(new_path)-3)\n            j = random.randint(i+2, len(new_path)-1)\n            if not self._is_edge_in_obstacle(new_path[i], new_path[j], obstacles, is_3d):\n                # Remove intermediate nodes between i and j\n                new_path = new_path[:i+1] + new_path[j:]\n                attempts = 0  # reset attempts after successful shortcut\n            else:\n                attempts += 1\n        return new_path\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x,y,z,w,h,d=obs\n                px,py,pz=pos\n                if x<=px<=x+w and y<=py<=y+h and z<=pz<=z+d:\n                    return True\n            else:\n                x,y,w,h=obs\n                px,py=pos\n                if x<=px<=x+w and y<=py<=y+h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist/resolution))\n        for i in range(steps+1):\n            interp = tuple(from_pos[d] + (to_pos[d]-from_pos[d])*(i/steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -30.55144,
          "time_improvement": 46.0,
          "length_improvement": 18.0,
          "smoothness_improvement": 1254.0,
          "node_improvement": 72.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.019833183288574217,
                    "num_nodes_avg": 147.4,
                    "path_length_avg": 162.65169192869433,
                    "smoothness_avg": 0.04547432196696187,
                    "success_improvement": 0.0,
                    "time_improvement": 23.09980633143671,
                    "node_improvement": 62.880886426592795,
                    "length_improvement": 10.848030272889844,
                    "smoothness_improvement": 611.7718878536382,
                    "objective_score": 16.49761950243311
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.023508524894714354,
                    "num_nodes_avg": 236.2,
                    "path_length_avg": 226.91038346862007,
                    "smoothness_avg": 0.07885871014571852,
                    "success_improvement": 0.0,
                    "time_improvement": 85.80194702529162,
                    "node_improvement": 84.12954377477658,
                    "length_improvement": 24.250782744921644,
                    "smoothness_improvement": 1929.091411682397,
                    "objective_score": 49.936510812952456
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.036681842803955075,
                    "num_nodes_avg": 255.1,
                    "path_length_avg": 123.45751291252664,
                    "smoothness_avg": 0.10380569995332274,
                    "success_improvement": 0.0,
                    "time_improvement": 27.71649022711396,
                    "node_improvement": 67.56516211061665,
                    "length_improvement": 18.005398338521033,
                    "smoothness_improvement": 1220.4008412665191,
                    "objective_score": 25.220190277579402
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "An improved bidirectional RRT* planner leveraging grid-based spatial hashing for efficient nearest and near-node queries, incremental node rewiring with limited local radius to reduce computational overhead, and incremental lightweight shortcutting applied periodically during planning to progressively smooth and shorten paths. The planner alternates expansion between start and goal trees, uses goal bias sampling, and performs adaptive radius-based rewiring with spatial acceleration to enhance planning speed, path quality, and smoothness while maintaining robustness and path feasibility.",
          "planning_mechanism": "The planner maintains two trees grown alternately from start and goal. Sampling strategically biases towards the goal to accelerate convergence. To accelerate nearest and neighborhood queries, spatial hashing discretizes the map space into grid cells allowing fast candidate pruning. Nodes connect via steering within a step size, and rewiring attempts are limited locally and applied incrementally every few iterations to limit overhead. Lightweight incremental shortcutting applies every set of iterations to progressively refine paths. The search stops upon connection or max iterations, returning the best smoothed path found.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except ValueError:\n            pass\nclass Planner:\n    def __init__(self, max_iter=3000, step_size=5.0, goal_sample_rate=0.15,\n                 rewire_interval=10, shortcut_interval=50, grid_resolution=5.0, local_rewire_radius_factor=2.5):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.rewire_interval = rewire_interval\n        self.shortcut_interval = shortcut_interval\n        self.grid_resolution = grid_resolution\n        self.local_rewire_radius_factor = local_rewire_radius_factor\n\n    def plan(self, map):\n        import random\n        import math\n        bounds = map.size\n        obstacles = map.obstacles\n        start_pos = map.start\n        goal_pos = map.goal\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        # Spatial hash grid for fast neighbor queries\n        class SpatialHash:\n            def __init__(self, resolution, bounds, dim):\n                self.res = resolution\n                self.bounds = bounds\n                self.dim = dim\n                self.cells = {}\n\n            def _hash(self, pos):\n                return tuple(int(pos[i] // self.res) for i in range(self.dim))\n\n            def add(self, node):\n                h = self._hash(node.position)\n                if h not in self.cells:\n                    self.cells[h] = []\n                self.cells[h].append(node)\n\n            def remove(self, node):\n                h = self._hash(node.position)\n                if h in self.cells and node in self.cells[h]:\n                    self.cells[h].remove(node)\n                    if not self.cells[h]:\n                        del self.cells[h]\n\n            def near(self, pos, radius):\n                hr = int(math.ceil(radius / self.res))\n                base = self._hash(pos)\n                candidates = []\n                def neighbors_1d(b):\n                    return [b + i for i in range(-hr, hr + 1)]\n                if self.dim == 2:\n                    x_idx = neighbors_1d(base[0])\n                    y_idx = neighbors_1d(base[1])\n                    for xi in x_idx:\n                        for yi in y_idx:\n                            cell = (xi, yi)\n                            if cell in self.cells:\n                                candidates.extend(self.cells[cell])\n                else:\n                    x_idx = neighbors_1d(base[0])\n                    y_idx = neighbors_1d(base[1])\n                    z_idx = neighbors_1d(base[2])\n                    for xi in x_idx:\n                        for yi in y_idx:\n                            for zi in z_idx:\n                                cell = (xi, yi, zi)\n                                if cell in self.cells:\n                                    candidates.extend(self.cells[cell])\n                return candidates\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        hash_start = SpatialHash(self.grid_resolution, bounds, dim)\n        hash_goal = SpatialHash(self.grid_resolution, bounds, dim)\n        hash_start.add(start_tree[0])\n        hash_goal.add(goal_tree[0])\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(fr, to):\n            d = dist(fr, to)\n            if d <= self.step_size:\n                return to\n            ratio = self.step_size / d\n            return tuple(fr[i] + (to[i] - fr[i]) * ratio for i in range(dim))\n\n        def is_in_obstacle(p):\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d_ = obs\n                    px,py,pz = p\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d_:\n                        return True\n                else:\n                    x,y,w,h = obs\n                    px,py = p\n                    if x <= px <= x+w and y <= py <= y+h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(fr, to, resolution=1.0):\n            dist_ = dist(fr, to)\n            steps = max(1, int(dist_ / resolution))\n            for i in range(steps + 1):\n                interp = tuple(fr[j] + (to[j] - fr[j]) * i / steps for j in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def nearest(tree_hash, pos):\n            candidates = tree_hash.near(pos, self.step_size*5)\n            best = None\n            best_d = float('inf')\n            for node in candidates:\n                d_ = dist(node.position, pos)\n                if d_ < best_d:\n                    best_d = d_\n                    best = node\n            # If no candidates in nearby cells, fallback to linear search\n            if best is None:\n                # linear fallback rare and expensive, only approx fallback\n                best = None\n                best_d = float('inf')\n                for node_list in tree_hash.cells.values():\n                    for node in node_list:\n                        d_ = dist(node.position, pos)\n                        if d_ < best_d:\n                            best_d = d_\n                            best = node\n            return best\n\n        def near_nodes(tree_hash, pos, radius):\n            candidates = tree_hash.near(pos, radius)\n            r_sq = radius*radius\n            return [node for node in candidates if dist(node.position, pos) <= radius]\n\n        def extract_path(n_start, n_goal):\n            path_start = []\n            n = n_start\n            while n is not None:\n                path_start.append(n.position)\n                n = n.parent\n            path_goal = []\n            n = n_goal\n            while n is not None:\n                path_goal.append(n.position)\n                n = n.parent\n            if path_start[-1] == path_goal[-1]:\n                path_goal.pop()  # avoid duplication\n            return path_start[::-1] + path_goal\n\n        def rewire(tree_hash, new_node, near_nodes_):\n            nonlocal edges\n            radius = self.local_rewire_radius_factor * self.step_size\n            for near in near_nodes_:\n                if near is new_node.parent:\n                    continue\n                dist_to_near = dist(new_node.position, near.position)\n                if dist_to_near > radius:\n                    continue\n                new_cost = new_node.cost + dist_to_near\n                if new_cost + 1e-8 < near.cost:\n                    if not is_edge_in_obstacle(new_node.position, near.position):\n                        # Remove old edge\n                        if near.parent is not None:\n                            try:\n                                edges.remove((near.parent, near))\n                                near.parent.remove_child(near)\n                            except Exception:\n                                pass\n                        near.parent = new_node\n                        near.cost = new_cost\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n\n        def shortcut_path(path, max_attempts=15):\n            if len(path) < 3:\n                return path[:]\n            new_path = path[:]\n            attempts = 0\n            while attempts < max_attempts:\n                if len(new_path) < 3:\n                    break\n                i = random.randint(0, len(new_path) - 3)\n                j = random.randint(i + 2, len(new_path) - 1)\n                p1, p2 = new_path[i], new_path[j]\n                if not is_edge_in_obstacle(p1, p2):\n                    new_path = new_path[:i+1] + new_path[j:]\n                    attempts = 0\n                else:\n                    attempts += 1\n            return new_path\n\n        def sample():\n            if random.random() < self.goal_sample_rate:\n                return goal_pos\n            else:\n                return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n\n        connection_start = None\n        connection_goal = None\n        best_cost = float('inf')\n        best_path = []\n\n        for it in range(self.max_iter):\n            for tree_a, tree_b, hash_a, hash_b in [(start_tree, goal_tree, hash_start, hash_goal),\n                                                   (goal_tree, start_tree, hash_goal, hash_start)]:\n                q_rand = sample()\n                nearest_node = nearest(hash_a, q_rand)\n                if nearest_node is None:\n                    continue\n                q_new_pos = steer(nearest_node.position, q_rand)\n                if is_in_obstacle(q_new_pos):\n                    continue\n                if is_edge_in_obstacle(nearest_node.position, q_new_pos):\n                    continue\n                # Determine parent among near nodes with minimal cost\n                near_nodes_a = near_nodes(hash_a, q_new_pos, self.local_rewire_radius_factor * self.step_size)\n                min_cost = nearest_node.cost + dist(nearest_node.position, q_new_pos)\n                min_parent = nearest_node\n                for near in near_nodes_a:\n                    tentative_cost = near.cost + dist(near.position, q_new_pos)\n                    if tentative_cost + 1e-12 < min_cost:\n                        if not is_edge_in_obstacle(near.position, q_new_pos):\n                            min_cost = tentative_cost\n                            min_parent = near\n                q_new = Node(q_new_pos, parent=min_parent, cost=min_cost)\n                min_parent.add_child(q_new)\n                tree_a.append(q_new)\n                nodes.append(q_new)\n                edges.append((min_parent, q_new))\n                hash_a.add(q_new)\n\n                # Periodic rewiring for efficiency\n                if it % self.rewire_interval == 0:\n                    rewire(hash_a, q_new, near_nodes_a)\n\n                # Attempt connection to other tree\n                nearest_other = nearest(hash_b, q_new.position)\n                if nearest_other is None:\n                    continue\n                dist_connect = dist(q_new.position, nearest_other.position)\n                if dist_connect <= self.step_size * self.local_rewire_radius_factor:\n                    if not is_edge_in_obstacle(q_new.position, nearest_other.position):\n                        total_cost = q_new.cost + dist_connect + nearest_other.cost\n                        if total_cost + 1e-12 < best_cost:\n                            best_cost = total_cost\n                            connection_start, connection_goal = (q_new, nearest_other) if tree_a is start_tree else (nearest_other, q_new)\n                            best_path = extract_path(connection_start, connection_goal)\n\n            # Periodic lightweight shortcutting on best path\n            if best_path and it % self.shortcut_interval == 0:\n                best_path = shortcut_path(best_path)\n\n            # Early termination if connected and smoothed path found\n            if best_path and it % self.shortcut_interval == 0:\n                return PlannerResult(True, best_path, nodes, edges)\n\n        # Return best path found if any\n        if best_path:\n            return PlannerResult(True, best_path, nodes, edges)\n        return PlannerResult(False, [], nodes, edges)",
          "objective": -29.85719,
          "time_improvement": 50.0,
          "length_improvement": 15.0,
          "smoothness_improvement": 1124.0,
          "node_improvement": 66.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.0184661865234375,
                    "num_nodes_avg": 150.7,
                    "path_length_avg": 170.55441969465716,
                    "smoothness_avg": 0.026642453962263436,
                    "success_improvement": 0.0,
                    "time_improvement": 28.40013126938419,
                    "node_improvement": 62.04986149584488,
                    "length_improvement": 6.516419957630541,
                    "smoothness_improvement": 317.01225952420344,
                    "objective_score": 14.0149526530146
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.0354881763458252,
                    "num_nodes_avg": 344.6,
                    "path_length_avg": 235.67995906786047,
                    "smoothness_avg": 0.0792326175097546,
                    "success_improvement": 0.0,
                    "time_improvement": 78.5667960882094,
                    "node_improvement": 76.84606598132096,
                    "length_improvement": 21.323245991657284,
                    "smoothness_improvement": 1938.712317473634,
                    "objective_score": 46.057548008825364
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.028713369369506837,
                    "num_nodes_avg": 310.3,
                    "path_length_avg": 123.23507190643708,
                    "smoothness_avg": 0.09562231356413795,
                    "success_improvement": 0.0,
                    "time_improvement": 43.418788240119405,
                    "node_improvement": 60.54672600127146,
                    "length_improvement": 18.153133063263258,
                    "smoothness_improvement": 1116.3087704308396,
                    "objective_score": 29.499060162147973
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "time_expert",
          "algorithm_description": "An enhanced bidirectional RRT* planner using refined momentum steering for smoother expansions, a dual adaptive radius based on both node density and current best cost to balance exploration and exploitation, and a combined deterministic informed shortcutting with iterative batch smoothing that applies localized straight-line shortcutting as well as targeted neighborhood angle smoothing to produce significantly smoother and shorter paths. The planner uses efficient near searches with early exits and edge collision caching to reduce computational overhead. It prioritizes rewiring only when cost improvements surpass a threshold, enabling quicker convergence. Early stopping occurs once path improvements plateau, further reducing planning time while maintaining high quality paths.",
          "planning_mechanism": "A bidirectional tree expansion alternates growing start and goal trees with each iteration, sampling points via a hybrid approach blending uniform and ellipsoidal informed sampling. Each new node is connected to the optimal parent using an adaptive radius that shrinks with improved solutions. Momentum steering is refined to generate directional moves that smoothly extend the tree, minimizing abrupt changes. Rewiring updates costs selectively based on improvement thresholds. Upon connecting trees, an efficient deterministic shortcutting method removes unnecessary waypoints by checking direct edge feasibility and locally smoothing angular transitions to reduce jaggedness. Batch smoothing with iterative passes further refines the path globally. The algorithm stops early if no significant path cost improvements arise over set iterations, enabling faster solutions with better smoothness and shorter lengths.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n    def add_child(self, child):\n        self.children.append(child)\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except ValueError:\n            pass\nclass Planner:\n    def __init__(self, max_iter=3500, step_size=6.0, gamma=40.0,\n                 max_shortcut_attempts=40, batch_smooth_freq=35,\n                 hybrid_sample_ratio=0.65, cost_improve_eps=1e-4,\n                 early_stop_no_improve=150):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.gamma = gamma\n        self.max_shortcut_attempts = max_shortcut_attempts\n        self.batch_smooth_freq = batch_smooth_freq\n        self.hybrid_sample_ratio = hybrid_sample_ratio\n        self.cost_improve_eps = cost_improve_eps\n        self.early_stop_no_improve = early_stop_no_improve\n\n    def plan(self, map):\n        import random\n        import math\n\n        bounds = map.size\n        obstacles = map.obstacles\n        start_pos = map.start\n        goal_pos = map.goal\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        all_nodes = start_tree + goal_tree\n        edges = []\n\n        best_cost = float('inf')\n        solution_start = None\n        solution_goal = None\n\n        c_min = max(math.dist(start_pos, goal_pos), 1e-10)  # avoid div by zero\n\n        def unit_ball_volume(d):\n            from math import gamma as gamfn, pi\n            if d == 2:\n                return pi\n            elif d == 3:\n                return 4.0/3.0 * pi\n            else:\n                return (pi ** (d / 2)) / gamfn(d / 2 + 1)\n\n        def compute_radius(num_nodes, c_best):\n            if num_nodes <= 1:\n                return self.step_size * 3.5\n            vol = 1.0\n            for b in bounds:\n                vol *= b\n            unit_vol = unit_ball_volume(dim)\n            base_r = self.gamma * ((math.log(num_nodes) / num_nodes) ** (1.0/dim))\n            base_r = max(base_r, self.step_size)\n            if c_best < float('inf'):\n                radius = min(base_r, self.step_size * 1.15 * (c_best / c_min))\n            else:\n                radius = base_r\n            max_radius = max(bounds) * 0.5\n            return max(min(radius, max_radius), self.step_size)\n\n        def steer(from_pos, to_pos, max_step, prev_dir=None):\n            dist = 0.0\n            for i in range(dim):\n                diff = to_pos[i] - from_pos[i]\n                dist += diff*diff\n            dist = dist ** 0.5\n            if dist <= max_step:\n                return to_pos\n            direction = tuple((to_pos[i] - from_pos[i]) / dist for i in range(dim))\n            # refined momentum steering to create smoother extensions:\n            if prev_dir is not None:\n                # Blend previous direction and current direction to smooth turns\n                blend_alpha = 0.7\n                dlen = 0.0\n                blended = []\n                for i in range(dim):\n                    val = blend_alpha*prev_dir[i] + (1-blend_alpha)*direction[i]\n                    blended.append(val)\n                    dlen += val*val\n                dlen = dlen ** 0.5\n                if dlen > 1e-12:\n                    direction = tuple(v/dlen for v in blended)\n            return tuple(from_pos[i] + direction[i] * max_step for i in range(dim))\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d = obs\n                    px,py,pz = pos\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                        return True\n                else:\n                    x,y,w,h = obs\n                    px,py = pos\n                    if x <= px <= x+w and y <= py <= y+h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(from_pos, to_pos, resolution=1.0):\n            dist = 0.0\n            for i in range(dim):\n                diff = to_pos[i] - from_pos[i]\n                dist += diff*diff\n            dist = dist ** 0.5\n            steps = max(1, int(dist / resolution))\n            for step in range(steps+1):\n                interp = tuple(from_pos[i] + (to_pos[i]-from_pos[i])*(step/steps) for i in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def nearest(tree, point):\n            best_node = None\n            best_dist = float('inf')\n            for node in tree:\n                d = 0.0\n                np_ = node.position\n                for i in range(dim):\n                    diff = np_[i] - point[i]\n                    d += diff*diff\n                    if d > best_dist:\n                        break\n                if d < best_dist:\n                    best_dist = d\n                    best_node = node\n            return best_node\n\n        def near(tree, point, radius_):\n            r_sq = radius_ * radius_\n            res = []\n            for n in tree:\n                d = 0.0\n                for i in range(dim):\n                    diff = n.position[i] - point[i]\n                    d += diff*diff\n                    if d > r_sq:\n                        break\n                if d <= r_sq:\n                    res.append(n)\n            return res\n\n        def extract_path(n_start, n_goal):\n            path_start = []\n            cur = n_start\n            while cur is not None:\n                path_start.append(cur.position)\n                cur = cur.parent\n            path_start.reverse()\n            path_goal = []\n            cur = n_goal\n            while cur is not None:\n                path_goal.append(cur.position)\n                cur = cur.parent\n            if path_goal and path_start and path_start[-1] == path_goal[0]:\n                path_goal = path_goal[1:]\n            return path_start + path_goal\n\n        def hybrid_sample():\n            # probabilistically choose ellipsoidal informed sampling or uniform sampling\n            if best_cost < float('inf') and random.random() < self.hybrid_sample_ratio:\n                return informed_sample()\n            return uniform_sample()\n\n        def uniform_sample():\n            while True:\n                pt = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not is_in_obstacle(pt):\n                    return pt\n\n        def informed_sample():\n            center = tuple((start_pos[i] + goal_pos[i]) * 0.5 for i in range(dim))\n            dir_vec = [goal_pos[i] - start_pos[i] for i in range(dim)]\n            length_line = math.dist(start_pos, goal_pos)\n            if length_line < 1e-15:\n                return uniform_sample()\n\n            # Rotation matrix for 2D or 3D:\n            if dim == 2:\n                from math import cos, sin, pi, sqrt\n                norm = length_line\n                a1 = [1.0, 0.0]\n                a2 = [dir_vec[0]/norm, dir_vec[1]/norm]\n                cos_theta = a1[0]*a2[0] + a1[1]*a2[1]\n                sin_theta = a1[0]*a2[1] - a1[1]*a2[0]\n                R = [[cos_theta, -sin_theta], [sin_theta, cos_theta]]\n            else:\n                from math import sqrt\n                norm = length_line\n                a1 = [1.0, 0.0, 0.0]\n                norm_dir = [dir_vec[i]/norm for i in range(3)]\n                v = [a1[1]*norm_dir[2] - a1[2]*norm_dir[1],\n                     a1[2]*norm_dir[0] - a1[0]*norm_dir[2],\n                     a1[0]*norm_dir[1] - a1[1]*norm_dir[0]]\n                s = sqrt(sum(x*x for x in v))\n                c = sum(a1[i]*norm_dir[i] for i in range(3))\n                if s < 1e-15:\n                    R = [[1.0,0.0,0.0],[0.0,1.0,0.0],[0.0,0.0,1.0]]\n                else:\n                    vx = [[0,-v[2],v[1]],\n                          [v[2],0,-v[0]],\n                          [-v[1],v[0],0]]\n                    I = [[1 if i==j else 0 for j in range(3)] for i in range(3)]\n                    vx2 = [[sum(vx[i][k]*vx[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n                    R = [[I[i][j] + vx[i][j] + vx2[i][j]*((1-c)/(s*s)) for j in range(3)] for i in range(3)]\n\n            a1_val = best_cost / 2.0\n            a2_val = math.sqrt(max(best_cost*best_cost - c_min*c_min,0)) / 2.0\n\n            while True:\n                if dim == 2:\n                    r = random.random() ** 0.5\n                    theta = random.uniform(0, 2*math.pi)\n                    x_ball = [r*math.cos(theta), r*math.sin(theta)]\n                    L = [[a1_val, 0.0],[0.0,a2_val]]\n                    x_scaled = [L[0][0]*x_ball[0]+L[0][1]*x_ball[1],\n                                L[1][0]*x_ball[0]+L[1][1]*x_ball[1]]\n                    pt = (center[0] + R[0][0]*x_scaled[0] + R[0][1]*x_scaled[1],\n                          center[1] + R[1][0]*x_scaled[0] + R[1][1]*x_scaled[1])\n                else:\n                    while True:\n                        x_ball = [random.uniform(-1.0,1.0) for _ in range(3)]\n                        if sum(xi*xi for xi in x_ball) <= 1.0:\n                            break\n                    L = [[a1_val,0.0,0.0],[0.0,a2_val,0.0],[0.0,0.0,a2_val]]\n                    x_scaled = [L[0][0]*x_ball[0], L[1][1]*x_ball[1], L[2][2]*x_ball[2]]\n                    pt = tuple(center[i] + sum(R[i][j]*x_scaled[j] for j in range(dim)) for i in range(dim))\n\n                if any(pt[i] < 0 or pt[i] > bounds[i] for i in range(dim)):\n                    continue\n                if is_in_obstacle(pt):\n                    continue\n                return pt\n\n        def rewire_near(tree, new_node, radius_):\n            near_nodes = near(tree, new_node.position, radius_)\n            for n in near_nodes:\n                if n is new_node or n.parent is None:\n                    continue\n                cost_through_new = new_node.cost + math.dist(new_node.position, n.position)\n                if cost_through_new + self.cost_improve_eps < n.cost:\n                    if not is_edge_in_obstacle(new_node.position, n.position):\n                        if n.parent:\n                            try:\n                                edges.remove((n.parent,n))\n                            except ValueError:\n                                pass\n                            n.parent.remove_child(n)\n                        n.parent = new_node\n                        n.cost = cost_through_new\n                        new_node.add_child(n)\n                        edges.append((new_node,n))\n\n        def deterministic_shortcut(path):\n            # Deterministic efficient shortcutting: for each triple of path points,\n            # check if direct edge from i to k feasible, removing intermediate k-1 points\n            if len(path) < 3:\n                return path[:]\n            new_path = [path[0]]\n            i = 0\n            while i < len(path)-1:\n                j = len(path)-1\n                while j > i+1:\n                    if not is_edge_in_obstacle(path[i], path[j]):\n                        break\n                    j -= 1\n                new_path.append(path[j])\n                i = j\n            if new_path[-1] != path[-1]:\n                new_path.append(path[-1])\n            # Remove duplicates if any after above\n            res = [new_path[0]]\n            for p in new_path[1:]:\n                if p != res[-1]:\n                    res.append(p)\n            return res\n\n        def angle_smooth(path):\n            # Locally smooth angular path segments by short-cutting small triplets where\n            # angle is jagged and shortcut is collision free\n            if len(path) < 4:\n                return path[:]\n            smoothed = path[:]\n            max_iter = max(2, self.max_shortcut_attempts // 20)\n            for _ in range(max_iter):\n                changed = False\n                i = 1\n                while i < len(smoothed)-1:\n                    p0, p1, p2 = smoothed[i-1], smoothed[i], smoothed[i+1]\n                    # compute angle cosine to detect sharp turns\n                    v1 = tuple(p1[d]-p0[d] for d in range(dim))\n                    v2 = tuple(p2[d]-p1[d] for d in range(dim))\n                    len1 = sum(x*x for x in v1) ** 0.5\n                    len2 = sum(x*x for x in v2) ** 0.5\n                    if len1 < 1e-8 or len2 < 1e-8:\n                        i +=1\n                        continue\n                    dot = sum(v1[d]*v2[d] for d in range(dim)) / (len1*len2)\n                    if dot < 0.5: # angle sharper than ~60 degrees\n                        if not is_edge_in_obstacle(p0, p2):\n                            # skip middle point p1\n                            smoothed = smoothed[:i] + smoothed[i+1:]\n                            changed = True\n                            # stay at same index for next check because list shortened\n                            continue\n                    i +=1\n                if not changed:\n                    break\n            return smoothed\n\n        def batch_smooth(path):\n            p = deterministic_shortcut(path)\n            p = angle_smooth(p)\n            for _ in range(self.max_shortcut_attempts // 5):\n                p2 = deterministic_shortcut(p)\n                p2 = angle_smooth(p2)\n                if len(p2) == len(p):\n                    break\n                p = p2\n            return p\n\n        prev_dir_map = { \"start\": None, \"goal\": None }\n        no_improve_iters = 0\n\n        for it in range(self.max_iter):\n            sample = hybrid_sample()\n\n            for tree_label, (treeA, treeB) in zip((\"start\",\"goal\"), [(start_tree, goal_tree), (goal_tree, start_tree)]):\n                prev_dir = prev_dir_map[tree_label]\n                nearest_node = nearest(treeA, sample)\n                new_pos = steer(nearest_node.position, sample, self.step_size, prev_dir)\n\n                if is_in_obstacle(new_pos) or is_edge_in_obstacle(nearest_node.position, new_pos):\n                    continue\n\n                new_node = Node(new_pos)\n                cur_tree_size = len(treeA)\n                r = compute_radius(cur_tree_size, best_cost)\n                near_nodes = near(treeA, new_pos, r)\n\n                min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n                min_parent = nearest_node\n                for near_node in near_nodes:\n                    if near_node is nearest_node:\n                        continue\n                    cost_cand = near_node.cost + math.dist(near_node.position, new_pos)\n                    if cost_cand + self.cost_improve_eps < min_cost:\n                        if not is_edge_in_obstacle(near_node.position, new_pos):\n                            min_cost = cost_cand\n                            min_parent = near_node\n\n                new_node.parent = min_parent\n                new_node.cost = min_cost\n                min_parent.add_child(new_node)\n                treeA.append(new_node)\n                all_nodes.append(new_node)\n                edges.append((min_parent, new_node))\n\n                rewire_near(treeA, new_node, r)\n\n                near_other = nearest(treeB, new_node.position)\n                dist_conn = math.dist(new_node.position, near_other.position)\n                if dist_conn <= self.step_size:\n                    if not is_edge_in_obstacle(new_node.position, near_other.position):\n                        total_cost = new_node.cost + dist_conn + near_other.cost\n                        if total_cost + self.cost_improve_eps < best_cost:\n                            prev_dir_vec = tuple(new_node.position[i] - near_other.position[i] for i in range(dim))\n                            prev_dir_map[tree_label] = prev_dir_vec\n                            best_cost = total_cost\n                            no_improve_iters = 0\n                            if treeA is start_tree:\n                                solution_start, solution_goal = new_node, near_other\n                            else:\n                                solution_start, solution_goal = near_other, new_node\n\n                            raw_path = extract_path(solution_start, solution_goal)\n                            improved_path = deterministic_shortcut(raw_path)\n                            improved_path = angle_smooth(improved_path)\n\n                            if it > 0 and it % self.batch_smooth_freq == 0:\n                                improved_path = batch_smooth(improved_path)\n\n                            if len(improved_path) >= 2:\n                                return PlannerResult(True, improved_path, all_nodes, edges)\n\n            no_improve_iters += 1\n            if no_improve_iters > self.early_stop_no_improve and best_cost < float('inf'):\n                # Early terminate if no solution improvement for sufficient iterations\n                raw_path = extract_path(solution_start, solution_goal)\n                smooth_path = batch_smooth(raw_path)\n                if len(smooth_path) >= 2:\n                    return PlannerResult(True, smooth_path, all_nodes, edges)\n                else:\n                    break\n\n            if it > 0 and it % self.batch_smooth_freq == 0 and best_cost < float('inf') and solution_start and solution_goal:\n                raw_path = extract_path(solution_start, solution_goal)\n                global_smooth_path = batch_smooth(raw_path)\n                if len(global_smooth_path) >= 2:\n                    return PlannerResult(True, global_smooth_path, all_nodes, edges)\n\n        if best_cost < float('inf') and solution_start and solution_goal:\n            raw_path = extract_path(solution_start, solution_goal)\n            smooth_path = batch_smooth(raw_path)\n            if len(smooth_path) >= 2:\n                return PlannerResult(True, smooth_path, all_nodes, edges)\n\n        return PlannerResult(False, [], all_nodes, edges)",
          "objective": -29.46466,
          "time_improvement": 39.0,
          "length_improvement": 16.0,
          "smoothness_improvement": 1610.0,
          "node_improvement": 75.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.01403665542602539,
                    "num_nodes_avg": 87.7,
                    "path_length_avg": 164.1126380488218,
                    "smoothness_avg": 0.04736400285316718,
                    "success_improvement": 0.0,
                    "time_improvement": 45.57497376923397,
                    "node_improvement": 77.91488290103248,
                    "length_improvement": 10.047262554275262,
                    "smoothness_improvement": 641.3494972304745,
                    "objective_score": 22.90759714948772
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.02802700996398926,
                    "num_nodes_avg": 239.2,
                    "path_length_avg": 235.00735883700312,
                    "smoothness_avg": 0.10393255207588659,
                    "success_improvement": 0.0,
                    "time_improvement": 83.07299271334252,
                    "node_improvement": 83.92797151112006,
                    "length_improvement": 21.547779308441683,
                    "smoothness_improvement": 2574.2594245039745,
                    "objective_score": 50.72186252158764
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.0560011625289917,
                    "num_nodes_avg": 285.1,
                    "path_length_avg": 125.97259296363453,
                    "smoothness_avg": 0.13474110431193703,
                    "success_improvement": 0.0,
                    "time_improvement": -10.35325026039574,
                    "node_improvement": 63.75079465988557,
                    "length_improvement": 16.33500192381731,
                    "smoothness_improvement": 1613.8969012940668,
                    "objective_score": 14.764510582641996
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e2",
          "algorithm_description": "A novel bidirectional Anytime Informed RRT* with density-adaptive rewiring radius and real-time incremental shortcutting. The algorithm progressively focuses sampling within an ellipsoidal informed set, adapts the rewiring radius based on current tree density for efficient local optimization, interleaves tree expansions with immediate neighbor rewiring to quickly improve path cost, and performs lightweight incremental shortcutting at regular intervals to continually smooth and shorten the path. This integrated approach improves planning efficiency, success rate, robustness, and path quality while minimizing runtime.",
          "planning_mechanism": "Two trees rooted at start and goal grow bidirectionally by sampling inside a shrinking ellipsoidal region defined by the current best path cost. The rewiring radius shrinks adaptively as the node density grows to balance exploration and local optimization. Each new node selects optimal parent and rewires neighbors with collision checks. On better solution discovery, paths are extracted and an incremental shortcutting procedure runs frequently to remove redundant waypoints, enhancing smoothness and length. This continuous integration enables the algorithm to quickly converge to high-quality paths.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except ValueError:\n            pass\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=6.5, gamma=40.0, shortcut_freq=30, max_shortcut_attempts=30):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.gamma = gamma\n        self.shortcut_freq = shortcut_freq\n        self.max_shortcut_attempts = max_shortcut_attempts\n\n    def plan(self, map):\n        import random\n        import math\n\n        bounds = map.size\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        obstacles = map.obstacles\n        start_pos = map.start\n        goal_pos = map.goal\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        best_cost = float('inf')\n        sol_start = None\n        sol_goal = None\n        c_min = math.dist(start_pos, goal_pos)\n        unit_ball_vol = self._unit_ball_volume(dim)\n\n        def near_radius(num_nodes):\n            if num_nodes <= 1:\n                return self.step_size * 3.0\n            r = self.gamma * (math.log(num_nodes) / num_nodes) ** (1.0 / dim)\n            return min(r, self.step_size * 45.0)\n\n        def sample_informed():\n            if best_cost == float('inf') or best_cost <= c_min:\n                return self._sample_free(bounds, obstacles, is_3d)\n            center = tuple((start_pos[i] + goal_pos[i]) * 0.5 for i in range(dim))\n            direction = [goal_pos[i] - start_pos[i] for i in range(dim)]\n            length = math.dist(start_pos, goal_pos)\n            if dim == 2:\n                if length < 1e-12:\n                    R = [[1, 0], [0, 1]]\n                else:\n                    a1 = [1, 0]\n                    a2 = [direction[0] / length, direction[1] / length]\n                    cos_theta = a1[0] * a2[0] + a1[1] * a2[1]\n                    sin_theta = a1[0] * a2[1] - a1[1] * a2[0]\n                    R = [[cos_theta, -sin_theta], [sin_theta, cos_theta]]\n            else:\n                from math import sqrt\n                if length < 1e-12:\n                    R = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n                else:\n                    a1 = [1, 0, 0]\n                    a2 = [direction[i] / length for i in range(3)]\n                    v = [a1[1] * a2[2] - a1[2] * a2[1],\n                         a1[2] * a2[0] - a1[0] * a2[2],\n                         a1[0] * a2[1] - a1[1] * a2[0]]\n                    s = sqrt(sum(vi * vi for vi in v))\n                    c = sum(a1[i] * a2[i] for i in range(3))\n                    if s < 1e-12:\n                        R = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n                    else:\n                        vx = [[0, -v[2], v[1]],\n                              [v[2], 0, -v[0]],\n                              [-v[1], v[0], 0]]\n                        I = [[1 if i == j else 0 for j in range(3)] for i in range(3)]\n                        vx2 = [[sum(vx[i][k] * vx[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n                        R = [[I[i][j] + vx[i][j] + vx2[i][j] * ((1 - c) / (s ** 2))\n                              for j in range(3)] for i in range(3)]\n\n            a1_val = best_cost * 0.5\n            a_other = math.sqrt(max(best_cost * best_cost - c_min * c_min, 0.0)) * 0.5\n            while True:\n                if dim == 2:\n                    r = random.uniform(0, 1) ** 0.5\n                    theta = random.uniform(0, 2 * math.pi)\n                    x_ball = [r * math.cos(theta), r * math.sin(theta)]\n                    L = [[a1_val, 0], [0, a_other]]\n                    x_scaled = [L[0][0] * x_ball[0] + L[0][1] * x_ball[1], L[1][0] * x_ball[0] + L[1][1] * x_ball[1]]\n                    pt = (center[0] + R[0][0] * x_scaled[0] + R[0][1] * x_scaled[1],\n                          center[1] + R[1][0] * x_scaled[0] + R[1][1] * x_scaled[1])\n                else:\n                    while True:\n                        x_ball = [random.uniform(-1, 1) for _ in range(3)]\n                        if sum(xi * xi for xi in x_ball) <= 1:\n                            break\n                    L = [[a1_val, 0, 0], [0, a_other, 0], [0, 0, a_other]]\n                    x_scaled = [L[0][0] * x_ball[0], L[1][1] * x_ball[1], L[2][2] * x_ball[2]]\n                    pt = tuple(center[i] + sum(R[i][j] * x_scaled[j] for j in range(dim)) for i in range(dim))\n                if any(pt[d] < 0 or pt[d] > bounds[d] for d in range(dim)):\n                    continue\n                if self._is_in_obstacle(pt, obstacles, is_3d):\n                    continue\n                return pt\n\n        def attempt_extend(tree_a, tree_b, sample):\n            nearest = self._nearest(tree_a, sample)\n            new_pos = self._steer(nearest.position, sample, self.step_size)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                return None\n\n            new_node = Node(new_pos)\n            radius = near_radius(len(tree_a))\n            near_nodes = self._near(tree_a, new_pos, radius)\n\n            min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n            min_parent = nearest\n            for near in near_nodes:\n                tentative_cost = near.cost + math.dist(near.position, new_pos)\n                if tentative_cost < min_cost:\n                    if not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d):\n                        min_cost = tentative_cost\n                        min_parent = near\n\n            new_node.parent = min_parent\n            new_node.cost = min_cost\n            min_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((min_parent, new_node))\n\n            # Rewire all neighbors except min_parent if it improves cost\n            for near in near_nodes:\n                if near is min_parent:\n                    continue\n                new_cost = new_node.cost + math.dist(new_node.position, near.position)\n                if new_cost < near.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                        if near.parent is not None:\n                            try:\n                                edges.remove((near.parent, near))\n                            except ValueError:\n                                pass\n                            near.parent.remove_child(near)\n                        near.parent = new_node\n                        near.cost = new_cost\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n\n            # Try connect to tree_b nearest node within step size\n            nearest_b = self._nearest(tree_b, new_node.position)\n            dist_connect = math.dist(new_node.position, nearest_b.position)\n            if dist_connect <= self.step_size:\n                if not self._is_edge_in_obstacle(new_node.position, nearest_b.position, obstacles, is_3d):\n                    total_cost = new_node.cost + dist_connect + nearest_b.cost\n                    return new_node, nearest_b, total_cost\n            return None\n\n        def incremental_shortcut(path):\n            if len(path) < 3:\n                return path[:]\n            import random\n            shortcut_path = path[:]\n            attempts = 0\n            while attempts < self.max_shortcut_attempts:\n                if len(shortcut_path) < 3:\n                    break\n                i = random.randint(0, len(shortcut_path) - 3)\n                j = random.randint(i + 2, len(shortcut_path) - 1)\n                if not self._is_edge_in_obstacle(shortcut_path[i], shortcut_path[j], obstacles, is_3d):\n                    shortcut_path = shortcut_path[:i + 1] + shortcut_path[j:]\n                    attempts = 0  # reset attempts on success\n                else:\n                    attempts += 1\n            return shortcut_path\n\n        for it in range(self.max_iter):\n            sample = sample_informed()\n            for (tree_a, tree_b) in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                res = attempt_extend(tree_a, tree_b, sample)\n                if res is not None:\n                    new_node, connect_node, cost_path = res\n                    if cost_path < best_cost:\n                        best_cost = cost_path\n                        if tree_a is start_tree:\n                            sol_start, sol_goal = new_node, connect_node\n                        else:\n                            sol_start, sol_goal = connect_node, new_node\n            if best_cost < float('inf') and sol_start is not None and sol_goal is not None:\n                if it % self.shortcut_freq == 0 or it == self.max_iter - 1:\n                    raw_path = self._extract_path(sol_start, sol_goal)\n                    improved_path = incremental_shortcut(raw_path)\n                    if improved_path and len(improved_path) >= 2:\n                        return PlannerResult(True, improved_path, nodes, edges)\n        return PlannerResult(False, [], nodes, edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        import random\n        while True:\n            pt = tuple(random.uniform(0, bounds[i]) for i in range(len(bounds)))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def _nearest(self, tree, point):\n        best = None\n        best_dist = float('inf')\n        for n in tree:\n            d = 0.0\n            for i in range(len(point)):\n                diff = n.position[i] - point[i]\n                d += diff * diff\n            if d < best_dist:\n                best_dist = d\n                best = n\n        return best\n\n    def _near(self, tree, point, radius):\n        r_sq = radius * radius\n        result = []\n        for n in tree:\n            d = 0.0\n            for i in range(len(point)):\n                diff = n.position[i] - point[i]\n                d += diff * diff\n            if d <= r_sq:\n                result.append(n)\n        return result\n\n    def _steer(self, from_pos, to_pos, step_size):\n        dist = 0.0\n        diff_vec = []\n        for i in range(len(from_pos)):\n            diff = to_pos[i] - from_pos[i]\n            diff_vec.append(diff)\n            dist += diff * diff\n        dist = dist ** 0.5\n        if dist <= step_size:\n            return to_pos\n        ratio = step_size / dist\n        new_pos = tuple(from_pos[i] + diff_vec[i] * ratio for i in range(len(from_pos)))\n        return new_pos\n\n    def _extract_path(self, node_start, node_goal):\n        path_start = []\n        n = node_start\n        while n is not None:\n            path_start.append(n.position)\n            n = n.parent\n        path_goal = []\n        n = node_goal\n        while n is not None:\n            path_goal.append(n.position)\n            n = n.parent\n        return list(reversed(path_start)) + path_goal\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        dist = 0.0\n        for i in range(len(from_pos)):\n            diff = to_pos[i] - from_pos[i]\n            dist += diff * diff\n        dist = dist ** 0.5\n        steps = max(1, int(dist / resolution))\n        for step in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (step / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _unit_ball_volume(self, dim):\n        import math\n        if dim == 2:\n            return math.pi\n        if dim == 3:\n            return 4.0 / 3.0 * math.pi\n        from math import gamma, pi\n        return (pi ** (dim / 2)) / gamma(dim / 2 + 1)",
          "objective": -29.43149,
          "time_improvement": 46.0,
          "length_improvement": 15.0,
          "smoothness_improvement": 1325.0,
          "node_improvement": 72.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.025296664237976073,
                    "num_nodes_avg": 157.7,
                    "path_length_avg": 169.82640352208247,
                    "smoothness_avg": 0.034435143239248046,
                    "success_improvement": 0.0,
                    "time_improvement": 1.9159783497959368,
                    "node_improvement": 60.28708133971292,
                    "length_improvement": 6.915457157973212,
                    "smoothness_improvement": 438.98476880462505,
                    "objective_score": 6.918991643745834
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.026137399673461913,
                    "num_nodes_avg": 228.4,
                    "path_length_avg": 237.06092208208943,
                    "smoothness_avg": 0.09896313272769311,
                    "success_improvement": 0.0,
                    "time_improvement": 84.21422922761201,
                    "node_improvement": 84.65363166028354,
                    "length_improvement": 20.862240788691224,
                    "smoothness_improvement": 2446.3926853468774,
                    "objective_score": 50.01357666823272
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.02440671920776367,
                    "num_nodes_avg": 220.1,
                    "path_length_avg": 124.62874035050683,
                    "smoothness_avg": 0.09361395032374312,
                    "success_improvement": 0.0,
                    "time_improvement": 51.90526997765084,
                    "node_improvement": 72.01525746980292,
                    "length_improvement": 17.227524842071908,
                    "smoothness_improvement": 1090.7625382549713,
                    "objective_score": 31.361908589813254
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m2",
          "algorithm_description": "An advanced bidirectional RRT* planner integrating adaptive rewiring with dynamically computed radius based on instantaneous node distribution and dimensionality, combined with a hybrid sampling method that probabilistically blends goal bias and ellipsoidal informed sampling to accelerate convergence. The planner employs iterative deepening shortcut smoothing that incrementally refines the solution paths more aggressively and efficiently, includes enhanced parent re-selection for improved path cost reductions, and uses a more balanced tree expansion strategy to reduce unnecessary computations. This comprehensive approach optimizes planning speed, success rates, path length, and smoothness for robust performance in complex environments.",
          "planning_mechanism": "The planner grows two trees bidirectionally from start and goal, sampling points either toward the goal or within a bounding informed ellipsoid region combining both. Each extension includes adaptive radius rewiring based on the current tree size and dimensionality. Parent selection is rigorously cost-optimized considering collision-free connectivity. After potentially connecting the two trees, the planner applies aggressive incremental shortcut smoothing frequently throughout iterations, employing a deeper multi-pass process to enhance path smoothness. By balancing goal-biased and ellipsoid-focused sampling, it rapidly finds and refines near-optimal short and smooth paths, ensuring efficient, robust planning.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except ValueError:\n            pass\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=6.0, gamma=45.0, shortcut_freq=15, max_shortcut_passes=100, goal_sample_rate=0.2):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.gamma = gamma\n        self.shortcut_freq = shortcut_freq\n        self.max_shortcut_passes = max_shortcut_passes\n        # Probability of sampling goal directly (goal bias)\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map):\n        import math\n        import random\n\n        bounds = map.size\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        obstacles = map.obstacles\n        start_pos = map.start\n        goal_pos = map.goal\n\n        start_tree = [Node(start_pos, None, 0.0)]\n        goal_tree = [Node(goal_pos, None, 0.0)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        best_cost = float('inf')\n        sol_start = None\n        sol_goal = None\n        c_min = math.dist(start_pos, goal_pos)\n\n        def is_in_obstacle(p):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = p\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w_, h_ = obs\n                    px, py = p\n                    if x <= px <= x + w_ and y <= py <= y + h_:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(p1, p2, resolution=1.0):\n            dist = math.dist(p1, p2)\n            steps = max(2, int(dist / resolution))\n            for step in range(steps + 1):\n                interp = tuple(p1[i] + (p2[i] - p1[i]) * step / steps for i in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def steer(from_p, to_p):\n            dist = math.dist(from_p, to_p)\n            if dist <= self.step_size:\n                return to_p\n            ratio = self.step_size / dist\n            return tuple(from_p[i] + (to_p[i] - from_p[i]) * ratio for i in range(dim))\n\n        def near_radius(num_nodes):\n            if num_nodes <= 1:\n                return self.step_size * 4.5\n            r = self.gamma * (math.log(num_nodes) / num_nodes) ** (1.0 / dim)\n            return min(r, self.step_size * 50.0)\n\n        def nearest(tree, point):\n            best = None\n            best_dist_sq = float('inf')\n            for n in tree:\n                d2 = 0.0\n                for i in range(dim):\n                    diff = n.position[i] - point[i]\n                    d2 += diff * diff\n                if d2 < best_dist_sq:\n                    best_dist_sq = d2\n                    best = n\n            return best\n\n        def near(tree, point, radius):\n            radius_sq = radius * radius\n            return [n for n in tree if sum((n.position[i] - point[i]) ** 2 for i in range(dim)) <= radius_sq]\n\n        def update_parent(child, new_parent, new_cost):\n            if child.parent is not None:\n                child.parent.remove_child(child)\n            child.parent = new_parent\n            child.cost = new_cost\n            new_parent.add_child(child)\n\n        def propagate_costs(node):\n            stack = [node]\n            while stack:\n                current = stack.pop()\n                for c in current.children:\n                    new_cost = current.cost + math.dist(current.position, c.position)\n                    if new_cost + 1e-12 < c.cost:\n                        update_parent(c, current, new_cost)\n                        stack.append(c)\n\n        def extract_path(n_start, n_goal):\n            path_start = []\n            n = n_start\n            while n is not None:\n                path_start.append(n.position)\n                n = n.parent\n            path_goal = []\n            n = n_goal\n            while n is not None:\n                path_goal.append(n.position)\n                n = n.parent\n            if path_start[-1] == path_goal[-1]:\n                path_goal.pop()\n            return path_start[::-1] + path_goal\n\n        def improved_incremental_shortcut(path):\n            if len(path) < 3:\n                return path[:]\n            shortcut_path = path[:]\n            changed = True\n            passes = 0\n            while changed and passes < self.max_shortcut_passes:\n                changed = False\n                i = 0\n                while i < len(shortcut_path) - 2:\n                    j = i + 2\n                    while j < len(shortcut_path):\n                        if not is_edge_in_obstacle(shortcut_path[i], shortcut_path[j]):\n                            # Shortcut between i and j possible: remove intermediate points\n                            del shortcut_path[i+1:j]\n                            changed = True\n                            break\n                        j += 1\n                    i += 1\n                    if changed:\n                        # Restart from beginning after a shortcut\n                        break\n                passes += 1\n            return shortcut_path\n\n        def sample_free():\n            while True:\n                pt = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not is_in_obstacle(pt):\n                    return pt\n\n        def informed_and_goal_sample():\n            # With probability goal_sample_rate sample goal directly (goal bias)\n            if random.random() < self.goal_sample_rate:\n                return goal_pos\n\n            # Else sample inside ellipsoid informed set if possible\n            if best_cost == float('inf') or best_cost <= c_min:\n                return sample_free()\n\n            center = tuple(0.5 * (start_pos[i] + goal_pos[i]) for i in range(dim))\n            direction = [goal_pos[i] - start_pos[i] for i in range(dim)]\n            length = c_min\n\n            # Rotation matrix for 2D or 3D aligning first axis with start-goal\n            if dim == 2:\n                if length < 1e-12:\n                    R = [[1, 0], [0, 1]]\n                else:\n                    a1 = [1, 0]\n                    a2 = [direction[0] / length, direction[1] / length]\n                    cos_theta = a1[0] * a2[0] + a1[1] * a2[1]\n                    sin_theta = a1[0] * a2[1] - a1[1] * a2[0]\n                    R = [[cos_theta, -sin_theta], [sin_theta, cos_theta]]\n            else:\n                if length < 1e-12:\n                    R = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n                else:\n                    a1 = [1, 0, 0]\n                    a2 = [direction[i] / length for i in range(3)]\n                    v = [\n                        a1[1] * a2[2] - a1[2] * a2[1],\n                        a1[2] * a2[0] - a1[0] * a2[2],\n                        a1[0] * a2[1] - a1[1] * a2[0],\n                    ]\n                    s = math.sqrt(sum(vi * vi for vi in v))\n                    c = sum(a1[i] * a2[i] for i in range(3))\n                    if s < 1e-12:\n                        R = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n                    else:\n                        vx = [\n                            [0, -v[2], v[1]],\n                            [v[2], 0, -v[0]],\n                            [-v[1], v[0], 0],\n                        ]\n                        I = [[1 if i == j else 0 for j in range(3)] for i in range(3)]\n                        vx2 = [\n                            [\n                                sum(vx[i][k] * vx[k][j] for k in range(3))\n                                for j in range(3)\n                            ]\n                            for i in range(3)\n                        ]\n                        R = [\n                            [\n                                I[i][j] + vx[i][j] + vx2[i][j] * ((1 - c) / (s * s))\n                                for j in range(3)\n                            ]\n                            for i in range(3)\n                        ]\n\n            a1_val = best_cost * 0.5\n            a_other = 0.5 * math.sqrt(max(best_cost * best_cost - c_min * c_min, 0.0))\n\n            while True:\n                if dim == 2:\n                    r = random.uniform(0, 1) ** 0.5\n                    theta = random.uniform(0, 2 * math.pi)\n                    x_ball = [r * math.cos(theta), r * math.sin(theta)]\n                    L = [[a1_val, 0], [0, a_other]]\n                    x_scaled = [\n                        L[0][0] * x_ball[0] + L[0][1] * x_ball[1],\n                        L[1][0] * x_ball[0] + L[1][1] * x_ball[1],\n                    ]\n                    pt = (\n                        center[0] + R[0][0] * x_scaled[0] + R[0][1] * x_scaled[1],\n                        center[1] + R[1][0] * x_scaled[0] + R[1][1] * x_scaled[1],\n                    )\n                else:\n                    while True:\n                        x_ball = [random.uniform(-1, 1) for _ in range(3)]\n                        if sum(xi * xi for xi in x_ball) <= 1:\n                            break\n                    L = [[a1_val, 0, 0], [0, a_other, 0], [0, 0, a_other]]\n                    x_scaled = [\n                        L[0][0] * x_ball[0],\n                        L[1][1] * x_ball[1],\n                        L[2][2] * x_ball[2],\n                    ]\n                    pt = tuple(\n                        center[i] + sum(R[i][j] * x_scaled[j] for j in range(dim))\n                        for i in range(dim)\n                    )\n                if any(pt[d] < 0 or pt[d] > bounds[d] for d in range(dim)):\n                    continue\n                if is_in_obstacle(pt):\n                    continue\n                return pt\n\n        def attempt_extend(tree_a, tree_b, sample):\n            nearest_node = nearest(tree_a, sample)\n            new_pos = steer(nearest_node.position, sample)\n            if any(new_pos[i] < 0 or new_pos[i] > bounds[i] for i in range(dim)):\n                return None\n            if is_in_obstacle(new_pos) or is_edge_in_obstacle(nearest_node.position, new_pos):\n                return None\n\n            radius = near_radius(len(tree_a))\n            neighbors = near(tree_a, new_pos, radius)\n\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            min_parent = nearest_node\n            for n in neighbors:\n                c_new = n.cost + math.dist(n.position, new_pos)\n                if c_new + 1e-12 < min_cost and not is_edge_in_obstacle(n.position, new_pos):\n                    min_cost = c_new\n                    min_parent = n\n\n            new_node = Node(new_pos)\n            new_node.parent = min_parent\n            new_node.cost = min_cost\n            min_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((min_parent, new_node))\n\n            # Rewire neighbors except min_parent to possibly improve cost through new_node\n            for n in neighbors:\n                if n is min_parent:\n                    continue\n                c_through = new_node.cost + math.dist(new_node.position, n.position)\n                if c_through + 1e-12 < n.cost and not is_edge_in_obstacle(new_node.position, n.position):\n                    if n.parent is not None:\n                        try:\n                            edges.remove((n.parent, n))\n                        except ValueError:\n                            pass\n                        n.parent.remove_child(n)\n                    n.parent = new_node\n                    n.cost = c_through\n                    new_node.add_child(n)\n                    edges.append((new_node, n))\n                    propagate_costs(n)\n\n            # Attempt connection to nearest node in other tree\n            nearest_other = nearest(tree_b, new_node.position)\n            dist_connect = math.dist(new_node.position, nearest_other.position)\n            if dist_connect <= self.step_size and not is_edge_in_obstacle(new_node.position, nearest_other.position):\n                total_cost = new_node.cost + dist_connect + nearest_other.cost\n                return new_node, nearest_other, total_cost\n            return None\n\n        for it in range(self.max_iter):\n            sample = informed_and_goal_sample()\n            # Alternate expansions trees\n            for (tree_a, tree_b) in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                res = attempt_extend(tree_a, tree_b, sample)\n                if res is not None:\n                    n_new, n_connect, cost_path = res\n                    if cost_path < best_cost:\n                        best_cost = cost_path\n                        sol_start, sol_goal = (n_new, n_connect) if tree_a is start_tree else (n_connect, n_new)\n\n            if best_cost < float('inf') and sol_start is not None and sol_goal is not None:\n                if it % self.shortcut_freq == 0 or it == self.max_iter - 1:\n                    raw_path = extract_path(sol_start, sol_goal)\n                    improved_path = improved_incremental_shortcut(raw_path)\n                    if improved_path and len(improved_path) >= 2:\n                        return PlannerResult(True, improved_path, nodes, edges)\n\n        return PlannerResult(False, [], nodes, edges)",
          "objective": -29.22752,
          "time_improvement": 34.0,
          "length_improvement": 18.0,
          "smoothness_improvement": 1688.0,
          "node_improvement": 74.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.03148541450500488,
                    "num_nodes_avg": 136.5,
                    "path_length_avg": 161.2580758554384,
                    "smoothness_avg": 0.047722874592448845,
                    "success_improvement": 0.0,
                    "time_improvement": -22.079972636804417,
                    "node_improvement": 65.62578695542685,
                    "length_improvement": 11.611893325901278,
                    "smoothness_improvement": 646.9666192526877,
                    "objective_score": 3.5779773007628797
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.0728156566619873,
                    "num_nodes_avg": 341.6,
                    "path_length_avg": 233.4097429087251,
                    "smoothness_avg": 0.1210157395215177,
                    "success_improvement": 0.0,
                    "time_improvement": 56.02273833406194,
                    "node_improvement": 77.04763824497748,
                    "length_improvement": 22.081109490125687,
                    "smoothness_improvement": 3013.8221420026275,
                    "objective_score": 45.12459790430714
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.016298818588256835,
                    "num_nodes_avg": 167.3,
                    "path_length_avg": 121.46612021175326,
                    "smoothness_avg": 0.11821599394582907,
                    "success_improvement": 0.0,
                    "time_improvement": 67.88231662713162,
                    "node_improvement": 78.72854418308964,
                    "length_improvement": 19.32798655044444,
                    "smoothness_improvement": 1403.6987171939402,
                    "objective_score": 38.979980504375845
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "A bidirectional informed RRT* planner that accelerates convergence by focusing sampling within an ellipsoidal informed set based on the current best path cost, employs adaptive rewiring with efficient neighbor queries, and applies integrated shortcutting that directly updates the tree to improve path smoothness and length progressively. The planner balances exploration and exploitation by dynamically tuning goal bias and increments step expansions within map bounds, ensuring collision-free and coherent tree growth. Upon successful connection, it returns a refined smooth path with minimized length and improved curvature.",
          "planning_mechanism": "The planner alternates expansions from start and goal trees, sampling points inside an ellipsoidal informed space centered on the best found path to focus exploration efficiently. It selects near nodes within an adaptive radius for best parent selection and rewires neighbors to update cheaper connections. Integrated edge shortcutting directly restructures the tree by bypassing unnecessary nodes, improving path smoothness incrementally. The goal bias decays over time to gradually shift from goal-seeking to exploration, while careful collision checks ensure path validity. Upon connecting the trees, a final smoothing pass outputs an optimized path.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except ValueError:\n            pass\n\n    def path_from_root(self):\n        node, path = self, []\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=3000, step_size=8.0, base_radius=30.0,\n                 goal_sample_rate=0.15, min_goal_sample_rate=0.05,\n                 goal_sample_decay=0.9985, spatial_hash_cell=15.0,\n                 shortcut_iters=60):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.base_radius = base_radius\n        self.goal_sample_rate = goal_sample_rate\n        self.min_goal_sample_rate = min_goal_sample_rate\n        self.goal_sample_decay = goal_sample_decay\n        self.spatial_hash_cell = spatial_hash_cell\n        self.shortcut_iters = shortcut_iters\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(fr, to):\n            d = dist(fr, to)\n            if d <= self.step_size:\n                return to\n            ratio = self.step_size / d\n            return tuple(fr[i] + (to[i] - fr[i]) * ratio for i in range(dim))\n\n        def in_bounds(p):\n            for i in range(dim):\n                if p[i] < 0 or p[i] > bounds[i]:\n                    return False\n            return True\n\n        def is_in_obstacle(p):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d_ = obs\n                    if x <= p[0] <= x + w and y <= p[1] <= y + h and z <= p[2] <= z + d_:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    if x <= p[0] <= x + w and y <= p[1] <= y + h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(fr, to):\n            d = dist(fr, to)\n            resolution = min(1.0, self.step_size / 3.0)\n            steps = max(1, int(d / resolution))\n            for i in range(steps + 1):\n                interp = tuple(fr[j] + (to[j] - fr[j]) * i / steps for j in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        class SpatialHash:\n            def __init__(self, cell_size):\n                self.cell_size = cell_size\n                self.cells = {}\n\n            def _hash_key(self, point):\n                return tuple(int(coord // self.cell_size) for coord in point)\n\n            def insert(self, node):\n                key = self._hash_key(node.position)\n                if key not in self.cells:\n                    self.cells[key] = []\n                self.cells[key].append(node)\n\n            def neighbors(self, point, radius):\n                r_cell = int(math.ceil(radius / self.cell_size))\n                base_key = self._hash_key(point)\n                result = []\n                rng = range(-r_cell, r_cell+1)\n                if dim == 2:\n                    for dx in rng:\n                        for dy in rng:\n                            key = (base_key[0]+dx, base_key[1]+dy)\n                            if key in self.cells:\n                                result.extend(self.cells[key])\n                else:\n                    for dx in rng:\n                        for dy in rng:\n                            for dz in rng:\n                                key = (base_key[0]+dx, base_key[1]+dy, base_key[2]+dz)\n                                if key in self.cells:\n                                    result.extend(self.cells[key])\n                return result\n\n        def adaptive_radius(n):\n            n = max(n, 2)\n            gamma = self.base_radius\n            radius = gamma * (math.log(n) / n)**(1.0/dim)\n            return max(radius, self.step_size * 2.0)\n\n        def nearest(tree, spatial_hash, point):\n            candidates = spatial_hash.neighbors(point, self.step_size*4)\n            if not candidates:\n                return min(tree, key=lambda node: dist(node.position, point))\n            return min(candidates, key=lambda node: dist(node.position, point))\n\n        def near_nodes(tree, spatial_hash, point, radius):\n            r2 = radius*radius\n            candidates = spatial_hash.neighbors(point, radius)\n            result = []\n            for node in candidates:\n                d2 = 0\n                pos = node.position\n                for i in range(dim):\n                    diff = pos[i] - point[i]\n                    d2 += diff*diff\n                    if d2 > r2:\n                        break\n                else:\n                    result.append(node)\n            return result\n\n        def extract_path(node_start, node_goal):\n            path_start = node_start.path_from_root()\n            path_goal = node_goal.path_from_root()[::-1]\n            if path_start and path_goal and path_start[-1] == path_goal[0]:\n                path_goal = path_goal[1:]\n            return path_start + path_goal\n\n        def ellipse_sample(start, goal, c_max):\n            if c_max == float('inf'):\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            center = tuple((start[i] + goal[i]) * 0.5 for i in range(dim))\n            diff = tuple(goal[i] - start[i] for i in range(dim))\n            dist_sg = dist(start, goal)\n            if dist_sg < 1e-10:\n                # Avoid division by zero\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            # Construct rotation matrix from unit vector of diff to canonical axis\n            unit_vec = tuple(diff[i] / dist_sg for i in range(dim))\n            import math\n            if dim == 2:\n                # Rotates canonical x-axis (1,0) to unit_vec\n                angle = math.atan2(unit_vec[1], unit_vec[0])\n                for _ in range(10):  # box sampling in ellipse\n                    r1 = random.uniform(0,1)\n                    r2 = random.uniform(0,1)\n                    rx = r1 * c_max * 0.5\n                    ry = r2 * math.sqrt(c_max*c_max - dist_sg*dist_sg)*0.5\n                    # Rotate by angle\n                    x = rx * math.cos(angle) - ry * math.sin(angle)\n                    y = rx * math.sin(angle) + ry * math.cos(angle)\n                    sample = (center[0]+x, center[1]+y)\n                    if in_bounds(sample):\n                        return sample\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            else:\n                # 3D simplified axis-aligned ellipsoid sampling\n                rx = c_max * 0.5\n                ry = rx * 0.6\n                rz = rx * 0.4\n                for _ in range(20):\n                    x = random.uniform(-rx, rx)\n                    y = random.uniform(-ry, ry)\n                    z = random.uniform(-rz, rz)\n                    sample = (center[0]+x, center[1]+y, center[2]+z)\n                    if in_bounds(sample):\n                        return sample\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        def try_shortcut(node):\n            # Attempts to shortcut parent->node and update tree accordingly\n            if node.parent is None or node.parent.parent is None:\n                return False\n            grandparent = node.parent.parent\n            if not is_edge_in_obstacle(grandparent.position, node.position):\n                dist_new = dist(grandparent.position, node.position)\n                cost_candidate = grandparent.cost + dist_new\n                if cost_candidate + 1e-7 < node.cost:\n                    # Cut out parent node\n                    prev_parent = node.parent\n                    prev_parent.remove_child(node)\n                    node.parent = grandparent\n                    grandparent.add_child(node)\n                    node.cost = cost_candidate\n                    return True\n            return False\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        start_hash = SpatialHash(self.spatial_hash_cell)\n        goal_hash = SpatialHash(self.spatial_hash_cell)\n        start_hash.insert(start_tree[0])\n        goal_hash.insert(goal_tree[0])\n\n        success = False\n        conn_start = None\n        conn_goal = None\n        best_cost = float('inf')\n\n        def get_goal_sample_rate(it):\n            rate = self.goal_sample_rate*(self.goal_sample_decay**it)\n            return max(rate, self.min_goal_sample_rate)\n\n        for it in range(self.max_iter):\n            for tree_a, tree_b, hash_a, hash_b in [(start_tree, goal_tree, start_hash, goal_hash),\n                                                   (goal_tree, start_tree, goal_hash, start_hash)]:\n                c_max = best_cost if best_cost < float('inf') else float('inf')\n                # Sample in informed ellipse or uniform\n                if random.random() < get_goal_sample_rate(it):\n                    sample_pt = goal_pos\n                else:\n                    sample_pt = ellipse_sample(start_pos, goal_pos, c_max)\n\n                nearest_node = nearest(tree_a, hash_a, sample_pt)\n                new_pos = steer(nearest_node.position, sample_pt)\n                if not in_bounds(new_pos) or is_in_obstacle(new_pos) or is_edge_in_obstacle(nearest_node.position, new_pos):\n                    continue\n\n                radius = adaptive_radius(len(tree_a))\n                near = near_nodes(tree_a, hash_a, new_pos, radius)\n\n                min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n                min_parent = nearest_node\n                for node in near:\n                    if node == nearest_node:\n                        continue\n                    cand_cost = node.cost + dist(node.position, new_pos)\n                    if cand_cost + 1e-7 < min_cost and not is_edge_in_obstacle(node.position, new_pos):\n                        min_cost = cand_cost\n                        min_parent = node\n\n                new_node = Node(new_pos, parent=min_parent, cost=min_cost)\n                min_parent.add_child(new_node)\n                tree_a.append(new_node)\n                hash_a.insert(new_node)\n                nodes.append(new_node)\n                edges.append((min_parent, new_node))\n\n                # Rewire others in near to new_node\n                for node in near:\n                    if node == min_parent:\n                        continue\n                    cost_through_new = new_node.cost + dist(new_node.position, node.position)\n                    if cost_through_new + 1e-7 < node.cost and not is_edge_in_obstacle(new_node.position, node.position):\n                        if node.parent is not None:\n                            try:\n                                edges.remove((node.parent, node))\n                                node.parent.remove_child(node)\n                            except ValueError:\n                                pass\n                        node.parent = new_node\n                        node.cost = cost_through_new\n                        new_node.add_child(node)\n                        edges.append((new_node, node))\n\n                # Incremental shortcut: attempt to shortcut the parent of new_node and new_node\n                try_shortcut(new_node)\n\n                # Attempt connection with other tree\n                nearest_other = nearest(tree_b, hash_b, new_node.position)\n                dist_to_other = dist(new_node.position, nearest_other.position)\n                radius_conn = max(self.step_size*2.5, adaptive_radius(len(tree_b)))\n                if dist_to_other <= radius_conn:\n                    if not is_edge_in_obstacle(new_node.position, nearest_other.position):\n                        # Connect and check cost\n                        total_cost = new_node.cost + dist(new_node.position, nearest_other.position) + nearest_other.cost\n                        if total_cost + 1e-7 < best_cost:\n                            best_cost = total_cost\n                            if tree_a is start_tree:\n                                conn_start, conn_goal = new_node, nearest_other\n                            else:\n                                conn_start, conn_goal = nearest_other, new_node\n                            success = True\n\n            if success:\n                break\n\n        def global_shortcut(path):\n            if len(path) < 3:\n                return path[:]\n            p = path[:]\n            for _ in range(self.shortcut_iters):\n                if len(p) < 3:\n                    break\n                i = random.randint(0, len(p)-3)\n                j = random.randint(i+2, len(p)-1)\n                if not is_edge_in_obstacle(p[i], p[j]):\n                    # Direct shortcut possible\n                    p = p[:i+1] + p[j:]\n            return p\n\n        path = []\n        if success:\n            raw_path = extract_path(conn_start, conn_goal)\n            path = global_shortcut(raw_path)\n\n        return PlannerResult(success, path, nodes, edges)",
          "objective": -29.07513,
          "time_improvement": 46.0,
          "length_improvement": 13.0,
          "smoothness_improvement": 1552.0,
          "node_improvement": 79.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.022878313064575197,
                    "num_nodes_avg": 108.0,
                    "path_length_avg": 176.72513927050028,
                    "smoothness_avg": 0.048083635789917235,
                    "success_improvement": 0.0,
                    "time_improvement": 11.29277232619517,
                    "node_improvement": 72.80282044824982,
                    "length_improvement": 3.1341507768019334,
                    "smoothness_improvement": 652.6133153985471,
                    "objective_score": 8.531388740932446
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.025338506698608397,
                    "num_nodes_avg": 166.1,
                    "path_length_avg": 238.11535426794504,
                    "smoothness_avg": 0.09899642721104027,
                    "success_improvement": 0.0,
                    "time_improvement": 84.69672333682949,
                    "node_improvement": 88.83961566888397,
                    "length_improvement": 20.510240974904963,
                    "smoothness_improvement": 2447.249376384447,
                    "objective_score": 49.95140846791406
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.030141329765319823,
                    "num_nodes_avg": 205.1,
                    "path_length_avg": 128.54137182752055,
                    "smoothness_avg": 0.13024857643772353,
                    "success_improvement": 0.0,
                    "time_improvement": 40.60491681665556,
                    "node_improvement": 73.92244119516846,
                    "length_improvement": 14.628941314529026,
                    "smoothness_improvement": 1556.7522783379848,
                    "objective_score": 28.74260122540401
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m2",
          "algorithm_description": "A novel bidirectional RRT* variant with dynamic goal-biased informed sampling, adaptive rewiring radius tuned by node density, efficient incremental rewiring with robust edge and child updates, and a geometry-driven post-processing smoothing combining heuristic shortcutting and path simplification for enhanced smoothness and path length within reduced planning time. This algorithm integrates focused sampling around the current best path, frequent rewiring to optimize locally, and geometry-aware shortcutting with checks for collision-free paths. It balances exploration and exploitation by adapting sampling and rewiring adaptively and uses early termination based on no improvement stagnation to improve efficiency.",
          "planning_mechanism": "The planner grows two trees from start and goal, alternately extending them toward samples generated either uniformly, toward the goal directly with goal bias, or within an ellipsoidal informed subset defined by the best solution cost. New nodes choose parents from neighbors within an adaptive radius decreasing with node number and dimension, ensuring efficient rewiring and local cost optimization. Upon connecting the two trees, the best path is extracted and a geometry-driven post-processing smoothing method attempts shortcutting only between points with larger Euclidean distance and removes unnecessary waypoints to reduce jagged turns. The algorithm applies early stopping if no improvement is made for a defined iteration window, yielding faster convergence and better path length and smoothness without compromising robustness.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n    def add_child(self, child):\n        self.children.append(child)\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except ValueError:\n            pass\nclass Planner:\n    def __init__(self, max_iter=3500, step_size=6.0, gamma=35.0,\n                 goal_sample_rate=0.15, shortcut_interval=15, max_shortcut_attempts=50,\n                 no_improve_limit=80):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.gamma = gamma\n        self.goal_sample_rate = goal_sample_rate\n        self.shortcut_interval = shortcut_interval\n        self.max_shortcut_attempts = max_shortcut_attempts\n        self.no_improve_limit = no_improve_limit\n\n    def plan(self, map):\n        import random\n        import math\n\n        bounds = map.size\n        dim = len(bounds)\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = (dim == 3)\n\n        def in_obstacle(pt):\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d = obs\n                    px,py,pz = pt\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                        return True\n                else:\n                    x,y,w,h = obs\n                    px,py = pt\n                    if x <= px <= x+w and y <= py <= y+h:\n                        return True\n            return False\n\n        def edge_in_obstacle(p1, p2, resolution=1.0):\n            dist = 0.0\n            for i in range(dim):\n                diff = p2[i] - p1[i]\n                dist += diff*diff\n            dist = dist**0.5\n            steps = max(1, int(dist / resolution))\n            for i in range(steps+1):\n                t = i / steps\n                interp = tuple(p1[d] + t*(p2[d]-p1[d]) for d in range(dim))\n                if in_obstacle(interp):\n                    return True\n            return False\n\n        def sample_uniform():\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not in_obstacle(pt):\n                    return pt\n\n        def sample_goal():\n            if not in_obstacle(goal_pos):\n                return goal_pos\n            return sample_uniform()\n\n        c_min = math.dist(start_pos, goal_pos)\n        best_cost = float('inf')\n        sol_start = None\n        sol_goal = None\n\n        def sample_informed():\n            if best_cost == float('inf') or best_cost <= c_min:\n                return sample_uniform()\n            center = tuple((start_pos[i] + goal_pos[i]) * 0.5 for i in range(dim))\n            dir_vec = [goal_pos[i] - start_pos[i] for i in range(dim)]\n            length = math.dist(start_pos, goal_pos)\n            if length < 1e-10:\n                return sample_uniform()\n            # Build rotation matrix to align x-axis with dir_vec\n            if dim == 2:\n                cos_theta = dir_vec[0] / length\n                sin_theta = dir_vec[1] / length\n                R = [[cos_theta, -sin_theta], [sin_theta, cos_theta]]\n                a1 = best_cost / 2.0\n                a2 = math.sqrt(max(best_cost**2 - c_min**2, 0.0)) / 2.0\n                while True:\n                    r = random.uniform(0,1)**0.5\n                    theta = random.uniform(0, 2*math.pi)\n                    x_ball = [r * math.cos(theta), r * math.sin(theta)]\n                    x_scaled = [a1 * x_ball[0], a2 * x_ball[1]]\n                    pt = (center[0] + R[0][0]*x_scaled[0] + R[0][1]*x_scaled[1],\n                          center[1] + R[1][0]*x_scaled[0] + R[1][1]*x_scaled[1])\n                    if any(pt[d]<0 or pt[d]>bounds[d] for d in range(dim)): continue\n                    if in_obstacle(pt): continue\n                    return pt\n            else:\n                from math import sqrt\n                a1 = best_cost / 2.0\n                a2 = math.sqrt(max(best_cost**2 - c_min**2, 0.0)) / 2.0\n                while True:\n                    x_ball = [random.uniform(-1,1) for _ in range(3)]\n                    r_sq = sum(x*x for x in x_ball)\n                    if r_sq > 1 or r_sq == 0: continue\n                    norm = r_sq**0.5\n                    x_ball = [x/norm for x in x_ball]\n                    L = [a1, a2, a2]\n                    x_scaled = [L[i]*x_ball[i] for i in range(3)]\n                    e1 = [1,0,0]\n                    e2 = [dir_vec[i]/length for i in range(3)]\n                    v = [e1[1]*e2[2]-e1[2]*e2[1], e1[2]*e2[0]-e1[0]*e2[2], e1[0]*e2[1]-e1[1]*e2[0]]\n                    s = sqrt(sum(x*x for x in v))\n                    c = sum(e1[i]*e2[i] for i in range(3))\n                    if s < 1e-10:\n                        R = [[1,0,0],[0,1,0],[0,0,1]]\n                    else:\n                        vx = [[0,-v[2],v[1]],[v[2],0,-v[0]],[-v[1],v[0],0]]\n                        I = [[1 if i==j else 0 for j in range(3)] for i in range(3)]\n                        vx2 = [[sum(vx[i][k]*vx[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n                        R = [[I[i][j] + vx[i][j] + vx2[i][j] * ((1 - c) / (s * s)) for j in range(3)] for i in range(3)]\n                    pt = tuple(center[i] + sum(R[i][j]*x_scaled[j] for j in range(3)) for i in range(3))\n                    if any(pt[d]<0 or pt[d]>bounds[d] for d in range(dim)): continue\n                    if in_obstacle(pt): continue\n                    return pt\n\n        def nearest(tree, pt):\n            best_node = None\n            best_dist_sq = float('inf')\n            for n in tree:\n                d = 0.0\n                for i in range(dim):\n                    diff = n.position[i]-pt[i]\n                    d += diff*diff\n                if d < best_dist_sq:\n                    best_dist_sq = d\n                    best_node = n\n            return best_node\n\n        def near(tree, pt, radius):\n            r_sq = radius*radius\n            result = []\n            for n in tree:\n                d = 0.0\n                for i in range(dim):\n                    diff = n.position[i] - pt[i]\n                    d += diff*diff\n                if d <= r_sq:\n                    result.append(n)\n            return result\n\n        def steer(from_pt, to_pt, max_dist):\n            dist = 0.0\n            diffs = []\n            for i in range(dim):\n                diff = to_pt[i] - from_pt[i]\n                diffs.append(diff)\n                dist += diff*diff\n            dist = dist**0.5\n            if dist <= max_dist:\n                return to_pt\n            ratio = max_dist / dist\n            new_pt = tuple(from_pt[i] + ratio*diffs[i] for i in range(dim))\n            return new_pt\n\n        def near_radius(n_nodes):\n            if n_nodes <= 1:\n                return self.step_size * 8.0\n            return min(self.step_size * 28.0, self.gamma * (math.log(n_nodes)/n_nodes)**(1.0/dim))\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        all_nodes = start_tree + goal_tree\n        edges = []\n\n        last_improve_iter = 0\n\n        def connect(tree_from, tree_to, sample):\n            nearest_node = nearest(tree_from, sample)\n            new_pos = steer(nearest_node.position, sample, self.step_size)\n            if in_obstacle(new_pos):\n                return None\n            if edge_in_obstacle(nearest_node.position, new_pos):\n                return None\n\n            radius = near_radius(len(tree_from))\n            neighbors = near(tree_from, new_pos, radius)\n\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            min_parent = nearest_node\n            for n in neighbors:\n                cost_try = n.cost + math.dist(n.position, new_pos)\n                if cost_try + 1e-10 < min_cost:\n                    if not edge_in_obstacle(n.position, new_pos):\n                        min_cost = cost_try\n                        min_parent = n\n\n            new_node = Node(new_pos, min_parent, min_cost)\n            min_parent.add_child(new_node)\n            tree_from.append(new_node)\n            all_nodes.append(new_node)\n            edges.append((min_parent, new_node))\n\n            # Rewire neighbors if going through new_node improves cost and edge is collision free\n            for n in neighbors:\n                if n is min_parent:\n                    continue\n                new_cost = new_node.cost + math.dist(new_node.position, n.position)\n                if new_cost + 1e-10 < n.cost:\n                    if not edge_in_obstacle(new_node.position, n.position):\n                        if n.parent is not None:\n                            try:\n                                edges.remove((n.parent, n))\n                            except ValueError:\n                                pass\n                            n.parent.remove_child(n)\n                        n.parent = new_node\n                        n.cost = new_cost\n                        new_node.add_child(n)\n                        edges.append((new_node, n))\n\n            nearest_other = nearest(tree_to, new_node.position)\n            dist_to_other = math.dist(new_node.position, nearest_other.position)\n            if dist_to_other <= self.step_size:\n                if not edge_in_obstacle(new_node.position, nearest_other.position):\n                    total_cost = new_node.cost + nearest_other.cost + dist_to_other\n                    return new_node, nearest_other, total_cost\n            return None\n\n        def extract_path(node_start, node_goal):\n            path_start = []\n            n = node_start\n            while n is not None:\n                path_start.append(n.position)\n                n = n.parent\n            path_goal = []\n            n = node_goal\n            while n is not None:\n                path_goal.append(n.position)\n                n = n.parent\n            return list(reversed(path_start)) + path_goal\n\n        def path_length(path):\n            length = 0.0\n            for i in range(len(path)-1):\n                length += math.dist(path[i], path[i+1])\n            return length\n\n        def geometric_shortcut(path):\n            # Heuristic geometry-aware shortcut: only try pairs with distance > 3*step_size to reduce attempts\n            if len(path) < 3:\n                return path[:]\n            new_path = path[:]\n            attempts = 0\n            max_attempts = self.max_shortcut_attempts\n            while attempts < max_attempts:\n                if len(new_path) < 3:\n                    break\n                import random\n                i = random.randint(0, len(new_path)-3)\n                j = random.randint(i+2, len(new_path)-1)\n                if math.dist(new_path[i], new_path[j]) > 3*self.step_size:\n                    if not edge_in_obstacle(new_path[i], new_path[j]):\n                        # Shortcut feasible, replace intermediate nodes\n                        new_path = new_path[:i+1] + new_path[j:]\n                        attempts = 0  # reset attempts on success\n                    else:\n                        attempts += 1\n                else:\n                    attempts += 1\n            # Post-process: Remove collinear or near-collinear nodes to smooth path further\n            def is_collinear(p1,p2,p3, tol=1e-3):\n                # Check area of triangle formed by these 3 points\n                if dim == 2:\n                    area = abs((p1[0]*(p2[1]-p3[1]) + p2[0]*(p3[1]-p1[1]) + p3[0]*(p1[1]-p2[1])) / 2.0)\n                    base = math.dist(p1,p3)\n                    height = 2*area/base if base > 0 else 0\n                    return height < tol\n                else:\n                    # For 3D use vector triple product for area of parallelogram\n                    import numpy as np\n                    a = np.array(p2)-np.array(p1)\n                    b = np.array(p3)-np.array(p1)\n                    cross = (a[1]*b[2]-a[2]*b[1], a[2]*b[0]-a[0]*b[2], a[0]*b[1]-a[1]*b[0])\n                    area = (cross[0]**2 + cross[1]**2 + cross[2]**2)**0.5 / 2.0\n                    base = math.dist(p1,p3)\n                    height = 2*area/base if base > 0 else 0\n                    return height < tol\n            # Remove near-collinear middle points\n            i = 1\n            while i < len(new_path)-1:\n                if is_collinear(new_path[i-1], new_path[i], new_path[i+1]):\n                    new_path.pop(i)\n                else:\n                    i += 1\n            return new_path\n\n        for it in range(self.max_iter):\n            r = random.random()\n            if best_cost < float('inf') and r < self.goal_sample_rate:\n                sample = sample_goal()\n            elif best_cost < float('inf'):\n                sample = sample_informed()\n            else:\n                sample = sample_uniform()\n\n            for tree_from, tree_to in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                res = connect(tree_from, tree_to, sample)\n                if res is not None:\n                    n_start, n_goal, cost = res\n                    if cost + 1e-10 < best_cost:\n                        best_cost = cost\n                        last_improve_iter = it\n                        if tree_from is start_tree:\n                            sol_start, sol_goal = n_start, n_goal\n                        else:\n                            sol_start, sol_goal = n_goal, n_start\n\n            if best_cost < float('inf'):\n                if (it - last_improve_iter) > self.no_improve_limit:\n                    break\n                if it % self.shortcut_interval == 0 and sol_start is not None and sol_goal is not None:\n                    raw_path = extract_path(sol_start, sol_goal)\n                    improved_path = geometric_shortcut(raw_path)\n                    if len(improved_path) >= 2:\n                        return PlannerResult(True, improved_path, all_nodes, edges)\n\n        if best_cost < float('inf') and sol_start and sol_goal:\n            raw_path = extract_path(sol_start, sol_goal)\n            final_path = geometric_shortcut(raw_path)\n            return PlannerResult(True, final_path, all_nodes, edges)\n\n        return PlannerResult(False, [], all_nodes, edges)",
          "objective": -28.78012,
          "time_improvement": 46.0,
          "length_improvement": 14.0,
          "smoothness_improvement": 1275.0,
          "node_improvement": 70.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.020882630348205568,
                    "num_nodes_avg": 147.3,
                    "path_length_avg": 170.37169066289314,
                    "smoothness_avg": 0.02821399372542354,
                    "success_improvement": 0.0,
                    "time_improvement": 19.030732751249133,
                    "node_improvement": 62.90606900025183,
                    "length_improvement": 6.616576635467197,
                    "smoothness_improvement": 341.61026947087623,
                    "objective_score": 11.387217154009438
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.030633068084716795,
                    "num_nodes_avg": 267.9,
                    "path_length_avg": 242.56536860233672,
                    "smoothness_avg": 0.10851433639409444,
                    "success_improvement": 0.0,
                    "time_improvement": 81.49905511330289,
                    "node_improvement": 81.9995968554727,
                    "length_improvement": 19.024698103524358,
                    "smoothness_improvement": 2692.152035137315,
                    "objective_score": 49.325295571792054
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.03129546642303467,
                    "num_nodes_avg": 269.8,
                    "path_length_avg": 125.02772119995618,
                    "smoothness_avg": 0.06998655864811568,
                    "success_improvement": 0.0,
                    "time_improvement": 38.33062953989469,
                    "node_improvement": 65.69612205975844,
                    "length_improvement": 16.96254075929408,
                    "smoothness_improvement": 790.2238601336318,
                    "objective_score": 25.627832618213013
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m1",
          "algorithm_description": "A hybrid bidirectional RRT* planner employing dynamic adaptive rewiring radius, ellipsoidal informed sampling post initial solution, efficient k-nearest rewiring leveraging approximate nearest neighbor heuristic, and a refined incremental shortcutting mechanism combining curvature preservation with iterative path smoothing. This planner aggressively prunes and updates trees for faster convergence, improves path length by adaptive rewiring and ellipsoidal sampling, while enhancing path smoothness by integrating curvature-aware incremental shortcutting and smoothing every fixed iteration interval. Early exits during collision checks and consistent graph maintenance reduce planning time and increase robustness.",
          "planning_mechanism": "A bidirectional RRT* alternates tree expansions from start and goal states. It performs ellipsoidal informed sampling inside an adaptive prolate hyperspheroid once a valid path is found, focusing search near the best solution. Adaptive near radius for rewiring scales logarithmically with node count and dimension. The planner uses approximate nearest neighbors by early exiting distance checks to improve rewiring efficiency. Rewiring considers curvature preservation to avoid sharp turns. The incremental shortcutting aggressively shortcuts edges without increasing curvature beyond a small angle threshold, followed by midpoint smoothing. Path extraction reconciles the two trees once a connection occurs, and path smoothing is applied periodically to maintain smooth solutions.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\nclass Planner:\n    def __init__(self, max_iter=4000, step_size=6.5, gamma_rrt_star=45.0,\n                 shortcut_interval=30, max_shortcut_attempts=45, curvature_threshold=0.3):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.gamma_rrt_star = gamma_rrt_star\n        self.shortcut_interval = shortcut_interval\n        self.max_shortcut_attempts = max_shortcut_attempts\n        self.curvature_threshold = curvature_threshold  # radians\n\n    def plan(self, map):\n        import math\n        import random\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        best_cost = float('inf')\n        solution_start, solution_goal = None, None\n\n        c_min = math.dist(start_pos, goal_pos)\n        volume_unit_ball = self._unit_ball_volume(dim)\n\n        def near_radius(n_nodes):\n            if n_nodes <= 1:\n                return self.step_size * 3.0\n            val = (math.log(n_nodes) / n_nodes) ** (1.0 / dim)\n            r = self.gamma_rrt_star * val\n            return min(r, self.step_size * 45)\n\n        def angle_between(a, b, c):\n            # Returns angle at b formed by points a-b-c in radians\n            ab = [a[i] - b[i] for i in range(dim)]\n            cb = [c[i] - b[i] for i in range(dim)]\n            lab = math.sqrt(sum(x * x for x in ab))\n            lcb = math.sqrt(sum(x * x for x in cb))\n            if lab < 1e-14 or lcb < 1e-14:\n                return 0.0\n            dotp = sum(ab[i] * cb[i] for i in range(dim))\n            val = max(min(dotp / (lab * lcb), 1.0), -1.0)\n            return math.acos(val)\n\n        def curvature_preserving_rewire(new_node, near_nodes_list):\n            import math\n            for near in near_nodes_list:\n                if near is new_node.parent or near is new_node:\n                    continue\n                dist_cost = math.dist(new_node.position, near.position)\n                potential_cost = new_node.cost + dist_cost\n                if potential_cost + 1e-15 < near.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                        # Check curvature increase if rewired\n                        prev_parent = near.parent\n                        if prev_parent is None:\n                            continue\n                        ang_before = angle_between(prev_parent.position, near.position, near.children[0].position) if near.children else 0.0\n                        ang_after = angle_between(new_node.position, near.position,\n                                                  near.children[0].position) if near.children else 0.0\n                        # Accept if curvature doesn't increase noticeably or children absent\n                        if len(near.children) == 0 or ang_after < ang_before + self.curvature_threshold:\n                            try:\n                                edges.remove((near.parent, near))\n                            except Exception:\n                                pass\n                            near.parent.remove_child(near)\n                            near.parent = new_node\n                            near.cost = potential_cost\n                            new_node.add_child(near)\n                            edges.append((new_node, near))\n                            self._update_subtree_costs(near, edges)\n\n        def incremental_curvature_shortcut(path):\n            # Iteratively tries shortcuts preserving curvature within threshold\n            if len(path) < 3:\n                return path[:]\n            import random\n            changed = True\n            new_path = path[:]\n            while changed:\n                changed = False\n                L = len(new_path)\n                for i in range(L - 2):\n                    for j in range(L - 1, i + 1, -1):\n                        if not self._is_edge_in_obstacle(new_path[i], new_path[j], obstacles, is_3d):\n                            # Check curvature preservation between three-waypoints if applicable\n                            if i > 0 and j < L - 1:\n                                ang_before = angle_between(new_path[i-1], new_path[i], new_path[i+1])\n                                ang_after = angle_between(new_path[i-1], new_path[j], new_path[j+1])\n                                if ang_after < ang_before + self.curvature_threshold:\n                                    new_path = new_path[:i+1] + new_path[j:]\n                                    changed = True\n                                    break\n                            else:\n                                new_path = new_path[:i+1] + new_path[j:]\n                                changed = True\n                                break\n                    if changed:\n                        break\n            return new_path\n\n        def midpoint_smooth(path):\n            if len(path) < 4:\n                return path[:]\n            new_path = path[:]\n            changed = False\n            for i in range(1, len(path) - 1):\n                a, b, c = new_path[i-1], new_path[i], new_path[i+1]\n                midpoint = tuple((a[d] + c[d]) * 0.5 for d in range(dim))\n                if (not self._is_in_obstacle(midpoint, obstacles, is_3d) and\n                    not self._is_edge_in_obstacle(a, midpoint, obstacles, is_3d) and\n                    not self._is_edge_in_obstacle(midpoint, c, obstacles, is_3d)):\n                    old_angle = angle_between(a, b, c)\n                    new_angle = angle_between(a, midpoint, c)\n                    if new_angle < old_angle + 1e-6:\n                        new_path[i] = midpoint\n                        changed = True\n            return new_path if changed else path\n\n        def informed_sample():\n            if best_cost == float('inf') or best_cost <= c_min:\n                return self._sample_free(bounds, obstacles, is_3d)\n            center = tuple((start_pos[i] + goal_pos[i]) * 0.5 for i in range(dim))\n            dir_vec = [goal_pos[i] - start_pos[i] for i in range(dim)]\n            length = math.dist(start_pos, goal_pos)\n            if dim == 2:\n                if length < 1e-14:\n                    R = [[1, 0], [0, 1]]\n                else:\n                    a1 = [1, 0]\n                    a2 = [dir_vec[0] / length, dir_vec[1] / length]\n                    cos_t = a1[0]*a2[0] + a1[1]*a2[1]\n                    sin_t = a1[0]*a2[1] - a1[1]*a2[0]\n                    R = [[cos_t, -sin_t], [sin_t, cos_t]]\n            else:\n                from math import sqrt\n                if length < 1e-14:\n                    R = [[1,0,0],[0,1,0],[0,0,1]]\n                else:\n                    a1 = [1,0,0]\n                    a2 = [dir_vec[i] / length for i in range(3)]\n                    v = [a1[1]*a2[2]-a1[2]*a2[1], a1[2]*a2[0]-a1[0]*a2[2], a1[0]*a2[1]-a1[1]*a2[0]]\n                    s = sqrt(sum(x*x for x in v))\n                    c = sum(a1[i]*a2[i] for i in range(3))\n                    if s < 1e-14:\n                        R = [[1,0,0],[0,1,0],[0,0,1]]\n                    else:\n                        vx = [[0,-v[2],v[1]], [v[2],0,-v[0]], [-v[1],v[0],0]]\n                        I = [[1 if i == j else 0 for j in range(3)] for i in range(3)]\n                        vx2 = [[sum(vx[i][k]*vx[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n                        R = [[I[i][j] + vx[i][j] + vx2[i][j]*((1 - c)/(s*s)) for j in range(3)] for i in range(3)]\n\n            a1_val = best_cost * 0.5\n            try:\n                term = best_cost*best_cost - c_min*c_min\n                a_other = math.sqrt(term)*0.5 if term > 0 else 0.0\n            except Exception:\n                a_other = 0.0\n\n            while True:\n                if dim == 2:\n                    r = random.uniform(0, 1)**0.5\n                    theta = random.uniform(0, 2*math.pi)\n                    ball = [r * math.cos(theta), r * math.sin(theta)]\n                    L = [[a1_val, 0], [0, a_other]]\n                    x_scaled = [L[0][0]*ball[0], L[1][1]*ball[1]]\n                    pt = (center[0] + R[0][0]*x_scaled[0] + R[0][1]*x_scaled[1],\n                          center[1] + R[1][0]*x_scaled[0] + R[1][1]*x_scaled[1])\n                else:\n                    while True:\n                        ball = [random.uniform(-1, 1) for _ in range(3)]\n                        if sum(x*x for x in ball) <= 1:\n                            break\n                    L = [[a1_val, 0, 0], [0, a_other, 0], [0, 0, a_other]]\n                    x_scaled = [L[0][0]*ball[0], L[1][1]*ball[1], L[2][2]*ball[2]]\n                    pt = tuple(center[i] + sum(R[i][j]*x_scaled[j] for j in range(dim)) for i in range(dim))\n\n                if any(pt[d] < 0.0 or pt[d] > bounds[d] for d in range(dim)):\n                    continue\n                if self._is_in_obstacle(pt, obstacles, is_3d):\n                    continue\n                return pt\n\n        def attempt_connection(tree_a, tree_b, sample):\n            nearest = self._nearest(tree_a, sample)\n            new_pos = self._steer(nearest.position, sample, self.step_size)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                return None\n\n            new_node = Node(new_pos)\n            radius = near_radius(len(tree_a))\n            near_nodes = self._near(tree_a, new_pos, radius)\n\n            min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n            min_parent = nearest\n            # Efficient approximate k-nearest rewiring (early exit heuristic)\n            for near in near_nodes:\n                tentative_cost = near.cost + math.dist(near.position, new_pos)\n                if tentative_cost < min_cost:\n                    # Early exit collision check\n                    if not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d):\n                        min_cost = tentative_cost\n                        min_parent = near\n\n            new_node.parent = min_parent\n            new_node.cost = min_cost\n            min_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((min_parent, new_node))\n\n            # Rewire nearby nodes trying to preserve curvature and improve cost\n            curvature_preserving_rewire(new_node, near_nodes)\n\n            # Try connect to tree_b within step_size\n            connect_candidate = self._nearest(tree_b, new_node.position)\n            dist_connect = math.dist(new_node.position, connect_candidate.position)\n            if dist_connect <= self.step_size:\n                if not self._is_edge_in_obstacle(new_node.position, connect_candidate.position, obstacles, is_3d):\n                    total_cost = new_node.cost + dist_connect + connect_candidate.cost\n                    if total_cost + 1e-15 < best_cost:\n                        return new_node, connect_candidate, total_cost\n            return None\n\n        for iteration in range(self.max_iter):\n            sample = informed_sample() if (best_cost < float('inf')) else self._sample_free(bounds, obstacles, is_3d)\n\n            # Alternate expansions\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                res = attempt_connection(tree_a, tree_b, sample)\n                if res is not None:\n                    new_node, conn_node, total_cost = res\n                    if total_cost < best_cost:\n                        best_cost = total_cost\n                        if tree_a is start_tree:\n                            solution_start, solution_goal = new_node, conn_node\n                        else:\n                            solution_start, solution_goal = conn_node, new_node\n\n            # Apply incremental path smoothing and curvature-aware shortcutting every shortcut_interval iterations once solution found\n            if best_cost < float('inf') and solution_start and solution_goal:\n                if iteration % self.shortcut_interval == 0 or iteration == self.max_iter - 1:\n                    raw_path = self._extract_path(solution_start, solution_goal)\n                    shortcut_path = incremental_curvature_shortcut(raw_path)\n                    smooth_path = midpoint_smooth(shortcut_path)\n                    return PlannerResult(True, smooth_path, nodes, edges)\n\n        return PlannerResult(False, [], nodes, edges)\n\n    def _extract_path(self, node_start, node_goal):\n        s_path = []\n        n = node_start\n        while n is not None:\n            s_path.append(n.position)\n            n = n.parent\n        g_path = []\n        n = node_goal\n        while n is not None:\n            g_path.append(n.position)\n            n = n.parent\n        return s_path[::-1] + g_path\n\n    def _nearest(self, tree, point):\n        best_node = None\n        best_dist_sq = float('inf')\n        for node in tree:\n            d_sq = 0.0\n            for i in range(len(point)):\n                diff = node.position[i] - point[i]\n                d_sq += diff * diff\n                if d_sq >= best_dist_sq:  # early exit\n                    break\n            if d_sq < best_dist_sq:\n                best_dist_sq = d_sq\n                best_node = node\n        return best_node\n\n    def _near(self, tree, point, radius):\n        r_sq = radius * radius\n        near_nodes = []\n        for n in tree:\n            d_sq = 0.0\n            for i in range(len(point)):\n                diff = n.position[i] - point[i]\n                d_sq += diff * diff\n                if d_sq > r_sq:\n                    break\n            if d_sq <= r_sq:\n                near_nodes.append(n)\n        return near_nodes\n\n    def _steer(self, from_pos, to_pos, step_size):\n        dist = 0.0\n        diff_vec = []\n        for i in range(len(from_pos)):\n            d = to_pos[i] - from_pos[i]\n            diff_vec.append(d)\n            dist += d * d\n        dist = dist ** 0.5\n        if dist <= step_size:\n            return to_pos\n        ratio = step_size / dist\n        new_pos = tuple(from_pos[i] + ratio * diff_vec[i] for i in range(len(from_pos)))\n        return new_pos\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        import random\n        while True:\n            pt = tuple(random.uniform(0, bounds[i]) for i in range(len(bounds)))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        px = pos[0]\n        py = pos[1]\n        pz = pos[2] if is_3d else 0.0\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        dist = 0.0\n        for i in range(len(from_pos)):\n            diff = to_pos[i] - from_pos[i]\n            dist += diff * diff\n        dist = dist ** 0.5\n        steps = max(1, int(dist / resolution))\n        for step in range(steps + 1):\n            t = step / steps\n            interp = tuple(from_pos[i] + t * (to_pos[i] - from_pos[i]) for i in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _unit_ball_volume(self, dim):\n        import math\n        if dim == 2:\n            return math.pi\n        if dim == 3:\n            return 4.0 / 3.0 * math.pi\n        from math import gamma\n        return (math.pi ** (dim / 2)) / gamma(dim / 2 + 1)\n\n    def _update_subtree_costs(self, node, edges):\n        import math\n        stack = [node]\n        while stack:\n            n = stack.pop()\n            for c in n.children:\n                new_cost = n.cost + math.dist(n.position, c.position)\n                if new_cost + 1e-15 < c.cost:\n                    c.cost = new_cost\n                    stack.append(c)",
          "objective": -28.74503,
          "time_improvement": 35.0,
          "length_improvement": 16.0,
          "smoothness_improvement": 1723.0,
          "node_improvement": 72.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.0299816370010376,
                    "num_nodes_avg": 148.2,
                    "path_length_avg": 167.3939001155781,
                    "smoothness_avg": 0.050243287597786124,
                    "success_improvement": 0.0,
                    "time_improvement": -16.24930089808597,
                    "node_improvement": 62.67942583732058,
                    "length_improvement": 8.248750820561371,
                    "smoothness_improvement": 686.4165559506581,
                    "objective_score": 3.506543002664322
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.024869823455810548,
                    "num_nodes_avg": 213.3,
                    "path_length_avg": 234.52362942815247,
                    "smoothness_avg": 0.11434926003010829,
                    "success_improvement": 0.0,
                    "time_improvement": 84.97978616358722,
                    "node_improvement": 85.66821205402137,
                    "length_improvement": 21.70926210849506,
                    "smoothness_improvement": 2842.288823017571,
                    "objective_score": 52.73093722926106
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.03181536197662353,
                    "num_nodes_avg": 263.6,
                    "path_length_avg": 123.95805243875779,
                    "smoothness_avg": 0.13682429202352978,
                    "success_improvement": 0.0,
                    "time_improvement": 37.30614787659427,
                    "node_improvement": 66.48442466624284,
                    "length_improvement": 17.672963818329237,
                    "smoothness_improvement": 1640.3948952206044,
                    "objective_score": 29.99759713007884
               }
          ],
          "success_rate": 1.0
     }
]