[
     {
          "operator": "m2",
          "algorithm_description": "This algorithm is an enhanced bidirectional RRT* planner that incorporates adaptive rewiring radius, smarter sampling strategies incorporating goal bias and informed sampling, and a post-processing path smoothing stage using shortcutting to greatly improve path smoothness, length, and planning efficiency. It grows two trees from start and goal, alternates expansion, rewires locally for optimality, attempts early connection, and finally smooths the extracted path for a low-cost, feasible, and smooth trajectory.",
          "planning_mechanism": "The planner uses bidirectional RRT* with adaptive rewiring radius based on the logarithm of tree size for asymptotic optimality and faster rewiring, samples with a goal bias probability to focus exploration, uses a connection radius scaled to domain size, and applies a shortcut smoothing post-processing on the constructed path. Trees are alternately expanded toward random samples or the opposing tree's nearest nodes to encourage faster convergence and connection. Collision checks are extensive but efficient with early rejections.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        node, path = self, []\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=5.0, base_radius=15.0, goal_sample_rate=0.1, shortcut_iterations=150):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.base_radius = base_radius\n        self.goal_sample_rate = goal_sample_rate\n        self.shortcut_iterations = shortcut_iterations\n\n    def plan(self, map) -> 'PlannerResult':\n        import random, math\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        def dist(a,b):\n            return math.dist(a,b)\n\n        def steer(fr, to):\n            d = dist(fr, to)\n            if d <= self.step_size:\n                return to\n            ratio = self.step_size / d\n            return tuple(fr[i] + (to[i] - fr[i]) * ratio for i in range(dim))\n\n        def is_in_obstacle(p):\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d_ = obs\n                    px,py,pz = p\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d_:\n                        return True\n                else:\n                    x,y,w,h = obs\n                    px,py = p\n                    if x <= px <= x+w and y <= py <= y+h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(fr,to, resolution=1.0):\n            d = dist(fr,to)\n            steps = max(1, int(d / resolution))\n            for i in range(steps + 1):\n                interp = tuple(fr[j] + (to[j] - fr[j]) * i / steps for j in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: dist(node.position, point))\n\n        def near_nodes(tree, point, radius):\n            return [node for node in tree if dist(node.position, point) <= radius]\n\n        def rewire(tree, new_node, near_nodes_):\n            nonlocal edges\n            for near in near_nodes_:\n                if near == new_node.parent:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, near.position)\n                if new_cost + 1e-7 < near.cost:\n                    if not is_edge_in_obstacle(new_node.position, near.position):\n                        # Remove old edge\n                        if near.parent is not None:\n                            try:\n                                edges.remove((near.parent, near))\n                            except Exception:\n                                pass\n                        near.parent.children.remove(near) if near.parent else None\n                        near.parent = new_node\n                        near.cost = new_cost\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n\n        def extract_path(node_from_start, node_from_goal):\n            path_start = node_from_start.path_from_root()\n            path_goal = node_from_goal.path_from_root()[::-1]\n            if len(path_start) > 0 and len(path_goal) > 0 and path_start[-1] == path_goal[0]:\n                path_goal = path_goal[1:]\n            return path_start + path_goal\n\n        def sample_point():\n            if random.random() < self.goal_sample_rate:\n                return goal_pos\n            else:\n                return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n\n        def shortcut_path(path):\n            # Attempts shortcutting to reduce sharp turns and improve smoothness\n            for _ in range(self.shortcut_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i+2, len(path) -1)\n                p1, p2 = path[i], path[j]\n                if not is_edge_in_obstacle(p1, p2):\n                    # shortcut successful: remove intermediate points between i and j\n                    path = path[:i+1] + path[j:]\n            return path\n\n        def adaptive_radius(tree_size):\n            # follow RRT* inspired radius scaling: gamma*(log(n)/n)^(1/d)\n            gamma = self.base_radius\n            n = max(tree_size, 1)\n            radius = gamma * (math.log(n)/n)**(1.0/dim)\n            return max(radius, self.step_size*1.5)\n\n        success = False\n        connection_pair = (None, None)\n\n        # Alternate which is tree A and tree B\n        for it in range(self.max_iter):\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                q_rand = sample_point()\n                nearest_node = nearest(tree_a, q_rand)\n                q_new_pos = steer(nearest_node.position, q_rand)\n                if is_in_obstacle(q_new_pos):\n                    continue\n                if is_edge_in_obstacle(nearest_node.position, q_new_pos):\n                    continue\n\n                # Rewiring radius adaptive\n                radius = adaptive_radius(len(tree_a))\n\n                # Find near nodes in tree_a for rewiring\n                near_nodes_a = near_nodes(tree_a, q_new_pos, radius)\n\n                # Choose best parent minimizing cost\n                min_cost = nearest_node.cost + dist(nearest_node.position, q_new_pos)\n                min_parent = nearest_node\n                for near_node in near_nodes_a:\n                    c = near_node.cost + dist(near_node.position, q_new_pos)\n                    if c < min_cost and not is_edge_in_obstacle(near_node.position, q_new_pos):\n                        min_cost = c\n                        min_parent = near_node\n\n                q_new = Node(q_new_pos, parent=min_parent, cost=min_cost)\n                min_parent.add_child(q_new)\n                tree_a.append(q_new)\n                nodes.append(q_new)\n                edges.append((min_parent, q_new))\n\n                # Rewire neighbors for improved costs\n                rewire(tree_a, q_new, near_nodes_a)\n\n                # Attempt connection to other tree\n                nearest_to_new = nearest(tree_b, q_new.position)\n                dist_connect = dist(q_new.position, nearest_to_new.position)\n                radius_connect = max(self.step_size*1.5, adaptive_radius(len(tree_b)))\n                if dist_connect <= radius_connect and not is_edge_in_obstacle(q_new.position, nearest_to_new.position):\n                    # Connected trees successfully\n                    if tree_a is start_tree:\n                        node_start, node_goal = q_new, nearest_to_new\n                    else:\n                        node_start, node_goal = nearest_to_new, q_new\n                    success = True\n                    connection_pair = (node_start, node_goal)\n                    break\n            if success:\n                break\n\n        path = []\n        if success:\n            raw_path = extract_path(connection_pair[0], connection_pair[1])\n            path = shortcut_path(raw_path)\n\n        return PlannerResult(success, path, nodes, edges)",
          "objective": -33.9861,
          "time_improvement": 56.0,
          "length_improvement": 16.0,
          "smoothness_improvement": 1519.0,
          "node_improvement": 69.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.01380462646484375,
                    "num_nodes_avg": 128.7,
                    "path_length_avg": 166.57538852397772,
                    "smoothness_avg": 0.04015959576609991,
                    "success_improvement": 0.0,
                    "time_improvement": 46.47463126707311,
                    "node_improvement": 67.59002770083103,
                    "length_improvement": 8.697389994063707,
                    "smoothness_improvement": 528.5848816974815,
                    "objective_score": 21.803747785047563
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.028153705596923827,
                    "num_nodes_avg": 317.3,
                    "path_length_avg": 238.40919577619638,
                    "smoothness_avg": 0.10655923140396159,
                    "success_improvement": 0.0,
                    "time_improvement": 82.9964744581085,
                    "node_improvement": 78.68037358059532,
                    "length_improvement": 20.412148221691805,
                    "smoothness_improvement": 2641.8457755359923,
                    "objective_score": 50.35546014812759
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.031368589401245116,
                    "num_nodes_avg": 304.4,
                    "path_length_avg": 121.92947455845565,
                    "smoothness_avg": 0.11683997631770895,
                    "success_improvement": 0.0,
                    "time_improvement": 38.186536846996304,
                    "node_improvement": 61.29688493324858,
                    "length_improvement": 19.020248655927677,
                    "smoothness_improvement": 1386.1958745313084,
                    "objective_score": 29.79908962031204
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "path_expert",
          "algorithm_description": "An enhanced bidirectional RRT* with dynamic adaptive sampling focused within an ellipsoidal informed set, combined with optimized local rewiring and iterative progressive shortcutting that does not terminate prematurely, allowing multiple path refinements per iteration. The planner dynamically adjusts the neighborhood radius based on the iteration count for effective rewiring, expands trees alternately, and maintains early-best path updates to accelerate convergence. Path extraction merges trees smoothly, and shortcutting aggressively reduces path length and smoothness without early exit, balancing exploration and exploitation for faster planning with superior path length and smoothness.",
          "planning_mechanism": "The planner alternates expansions of two trees from start and goal, sampling points adaptively within a progressively shrinking ellipsoidal subset defined by the current best path cost to focus search. Each new node is connected optimally within a dynamically scaled radius, with rewiring applied to improve local costs. Upon successful connection, the combined path is extracted and shortcut multiple times per call to incrementally smooth and shorten it. The radius decreases over iterations, balancing exploration and exploitation. This approach improves convergence speed, path cost, and smoothness while reducing search time.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n    def add_child(self, child):\n        self.children.append(child)\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except ValueError:\n            pass\nclass Planner:\n    def __init__(self, max_iter=4000, step_size=6.0, radius_max=15.0,\n                 radius_min=5.0, shortcut_interval=25, shortcut_attempts=100):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.radius_max = radius_max\n        self.radius_min = radius_min\n        self.shortcut_interval = shortcut_interval\n        self.shortcut_attempts = shortcut_attempts\n\n    def plan(self, map):\n        import random\n        import math\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = (len(bounds) == 3)\n        dim = 3 if is_3d else 2\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        all_nodes = start_tree + goal_tree\n        edges = []\n\n        best_cost = float('inf')\n        solution_start = None\n        solution_goal = None\n\n        c_min = math.dist(start_pos, goal_pos)\n        # Prevent zero division at start:\n        c_min = max(c_min, 1e-10)\n\n        def radius(iter_idx):\n            # Shrinking radius between radius_max and radius_min over iterations to balance exploration/exploitation\n            fraction = min(iter_idx/self.max_iter,1.0)\n            return self.radius_max * (1.0 - fraction) + self.radius_min * fraction\n\n        for i in range(self.max_iter):\n            # Adaptive informed sampling focusing search if a solution exists\n            if best_cost < float('inf'):\n                sample = self._informed_sample(bounds, obstacles, is_3d, start_pos, goal_pos, best_cost, c_min)\n            else:\n                sample = self._sample_free(bounds, obstacles, is_3d)\n\n            # Alternating tree expansion for balanced bidirectional growth\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest = self._nearest(tree_a, sample)\n                new_pos = self._steer(nearest.position, sample, self.step_size)\n\n                if (self._is_in_obstacle(new_pos, obstacles, is_3d) or\n                    self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d)):\n                    continue  # Skip invalid nodes or edges\n\n                new_node = Node(new_pos)\n\n                r = radius(i)\n                near_nodes = self._near(tree_a, new_pos, r)\n\n                # Choose parent with minimal cost feasible edge\n                min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n                min_parent = nearest\n                for near in near_nodes:\n                    if near == nearest:\n                        continue\n                    tentative_cost = near.cost + math.dist(near.position, new_pos)\n                    if tentative_cost < min_cost:\n                        if not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d):\n                            min_cost = tentative_cost\n                            min_parent = near\n\n                new_node.parent = min_parent\n                new_node.cost = min_cost\n                min_parent.add_child(new_node)\n                tree_a.append(new_node)\n                all_nodes.append(new_node)\n                edges.append((min_parent, new_node))\n\n                # Rewire nodes around new node to improve their cost if beneficial\n                for near in near_nodes:\n                    if near == min_parent:\n                        continue\n                    new_cost = new_node.cost + math.dist(new_node.position, near.position)\n                    if new_cost < near.cost:\n                        if not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                            old_parent = near.parent\n                            if old_parent:\n                                try:\n                                    edges.remove((old_parent, near))\n                                except ValueError:\n                                    pass\n                                old_parent.remove_child(near)\n                            near.parent = new_node\n                            near.cost = new_cost\n                            new_node.add_child(near)\n                            edges.append((new_node, near))\n\n                # Attempt connection to the other tree\n                connect_node = self._nearest(tree_b, new_node.position)\n                dist_connect = math.dist(new_node.position, connect_node.position)\n                if dist_connect <= self.step_size:\n                    if not self._is_edge_in_obstacle(new_node.position, connect_node.position, obstacles, is_3d):\n                        total_path_cost = new_node.cost + dist_connect + connect_node.cost\n                        if total_path_cost < best_cost:\n                            best_cost = total_path_cost\n                            if tree_a is start_tree:\n                                solution_start, solution_goal = new_node, connect_node\n                            else:\n                                solution_start, solution_goal = connect_node, new_node\n\n            # Progressive shortcutting every shortcut_interval iterations and final iteration\n            if best_cost < float('inf') and solution_start and solution_goal and (i % self.shortcut_interval == 0 or i == self.max_iter - 1):\n                raw_path = self._extract_path(solution_start, solution_goal)\n                # Aggressive multiple shortcutting iterations improving smoothness and length in one call\n                shortcut_path = self._shortcut_path(raw_path, obstacles, is_3d, max_attempts=self.shortcut_attempts)\n                if shortcut_path:\n                    return PlannerResult(True, shortcut_path, all_nodes, edges)\n\n        # No solution found\n        return PlannerResult(False, [], all_nodes, edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        import random\n        while True:\n            pt = tuple(random.uniform(0, bounds[i]) for i in range(len(bounds)))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def _informed_sample(self, bounds, obstacles, is_3d, start, goal, c_max, c_min):\n        import random\n        import math\n        dim = 3 if is_3d else 2\n\n        if c_max <= c_min:\n            return self._sample_free(bounds, obstacles, is_3d)\n\n        center = tuple((start[i] + goal[i]) / 2.0 for i in range(dim))\n        dir_vec = [goal[i] - start[i] for i in range(dim)]\n        length = math.dist(start, goal)\n        if length < 1e-10:\n            return self._sample_free(bounds, obstacles, is_3d)\n\n        # Rotation matrix aligning x-axis with direction vector\n        if dim == 2:\n            a1 = [1.0, 0.0]\n            a2 = [dir_vec[0] / length, dir_vec[1] / length]\n            cos_theta = a1[0] * a2[0] + a1[1] * a2[1]\n            sin_theta = a1[0] * a2[1] - a1[1] * a2[0]\n            R = [[cos_theta, -sin_theta], [sin_theta, cos_theta]]\n        else:\n            # Rodrigues' rotation formula for 3D rotation matrix\n            from math import sqrt\n            a1 = [1.0, 0.0, 0.0]\n            a2 = [dir_vec[i] / length for i in range(3)]\n            v = [a1[1]*a2[2] - a1[2]*a2[1],\n                 a1[2]*a2[0] - a1[0]*a2[2],\n                 a1[0]*a2[1] - a1[1]*a2[0]]\n            s = sqrt(sum(vi*vi for vi in v))\n            c = sum(a1[i]*a2[i] for i in range(3))\n            if s < 1e-10:\n                R = [[1,0,0],[0,1,0],[0,0,1]]\n            else:\n                vx = [[0, -v[2], v[1]],\n                      [v[2], 0, -v[0]],\n                      [-v[1], v[0], 0]]\n                I = [[1 if i==j else 0 for j in range(3)] for i in range(3)]\n                vx2 = [[sum(vx[i][k]*vx[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n                R = [[I[i][j] + vx[i][j] + vx2[i][j]*((1 - c)/(s*s)) for j in range(3)] for i in range(3)]\n\n        def sample_unit_ball():\n            if dim == 2:\n                r = random.uniform(0, 1)**0.5\n                theta = random.uniform(0, 2 * math.pi)\n                return [r * math.cos(theta), r * math.sin(theta)]\n            else:\n                while True:\n                    pt = [random.uniform(-1, 1) for _ in range(3)]\n                    if sum(x*x for x in pt) <= 1:\n                        return pt\n\n        x_ball = sample_unit_ball()\n\n        a1_val = c_max / 2.0\n        a_other = math.sqrt(max(c_max*c_max - c_min*c_min, 0)) / 2.0\n\n        # Scale sample inside ellipsoid axes\n        if dim == 2:\n            L = [[a1_val, 0.0], [0.0, a_other]]\n            x_scaled = [L[0][0]*x_ball[0] + L[0][1]*x_ball[1],\n                        L[1][0]*x_ball[0] + L[1][1]*x_ball[1]]\n            pt = (center[0] + R[0][0]*x_scaled[0] + R[0][1]*x_scaled[1],\n                  center[1] + R[1][0]*x_scaled[0] + R[1][1]*x_scaled[1])\n        else:\n            L = [[a1_val, 0.0, 0.0],\n                 [0.0, a_other, 0.0],\n                 [0.0, 0.0, a_other]]\n            x_scaled = [L[0][0]*x_ball[0], L[1][1]*x_ball[1], L[2][2]*x_ball[2]]\n            pt = tuple(center[i] + sum(R[i][j]*x_scaled[j] for j in range(3)) for i in range(3))\n\n        if any(pt[d] < 0 or pt[d] > bounds[d] for d in range(dim)):\n            return self._sample_free(bounds, obstacles, is_3d)\n        if self._is_in_obstacle(pt, obstacles, is_3d):\n            return self._sample_free(bounds, obstacles, is_3d)\n        return pt\n\n    def _nearest(self, tree, point):\n        import math\n        best = None\n        best_dist = float('inf')\n        for node in tree:\n            d = math.dist(node.position, point)\n            if d < best_dist:\n                best_dist = d\n                best = node\n        return best\n\n    def _near(self, tree, point, radius):\n        r_sq = radius*radius\n        dim = len(point)\n        return [n for n in tree if sum((n.position[i] - point[i])**2 for i in range(dim)) <= r_sq]\n\n    def _steer(self, from_pos, to_pos, step_size):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        if dist <= step_size:\n            return to_pos\n        ratio = step_size / dist\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n    def _extract_path(self, node_start, node_goal):\n        path_start = []\n        n = node_start\n        while n is not None:\n            path_start.append(n.position)\n            n = n.parent\n        path_start.reverse()\n\n        path_goal = []\n        n = node_goal\n        while n is not None:\n            path_goal.append(n.position)\n            n = n.parent\n        # Remove duplicated connecting node between two paths\n        if len(path_goal) > 0 and len(path_start) > 0 and path_goal[0] == path_start[-1]:\n            path_goal = path_goal[1:]\n        return path_start + path_goal\n\n    def _shortcut_path(self, path, obstacles, is_3d, max_attempts=100):\n        if len(path) < 3:\n            return path[:]\n        import random\n        new_path = path[:]\n        attempts = 0\n        while attempts < max_attempts:\n            if len(new_path) < 3:\n                break\n            i = random.randint(0, len(new_path) - 3)\n            j = random.randint(i + 2, len(new_path) - 1)\n            if not self._is_edge_in_obstacle(new_path[i], new_path[j], obstacles, is_3d):\n                # Remove intermediate nodes between i and j\n                new_path = new_path[:i+1] + new_path[j:]\n                attempts = 0  # reset after successful shortcut for multiple improvements\n            else:\n                attempts += 1\n        return new_path\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if (x <= px <= x + w) and (y <= py <= y + h) and (z <= pz <= z + d):\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if (x <= px <= x + w) and (y <= py <= y + h):\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            ratio = i / steps\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -31.02809,
          "time_improvement": 43.0,
          "length_improvement": 18.0,
          "smoothness_improvement": 1433.0,
          "node_improvement": 72.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.027813315391540527,
                    "num_nodes_avg": 150.8,
                    "path_length_avg": 158.7550902195503,
                    "smoothness_avg": 0.04475010796054884,
                    "success_improvement": 0.0,
                    "time_improvement": -7.841959056894185,
                    "node_improvement": 62.02467892218585,
                    "length_improvement": 12.983819415277045,
                    "smoothness_improvement": 600.4363659973881,
                    "objective_score": 8.439885762084911
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.032094931602478026,
                    "num_nodes_avg": 270.1,
                    "path_length_avg": 232.67782481248065,
                    "smoothness_avg": 0.10133943332680147,
                    "success_improvement": 0.0,
                    "time_improvement": 80.61615770651433,
                    "node_improvement": 81.8517771954579,
                    "length_improvement": 22.325444817746384,
                    "smoothness_improvement": 2507.5366113420746,
                    "objective_score": 50.117797259312496
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.021543121337890624,
                    "num_nodes_avg": 212.9,
                    "path_length_avg": 122.20039490599746,
                    "smoothness_avg": 0.1015407972611195,
                    "success_improvement": 0.0,
                    "time_improvement": 57.54814091297544,
                    "node_improvement": 72.9307056579784,
                    "length_improvement": 18.840316260931036,
                    "smoothness_improvement": 1191.591446199421,
                    "objective_score": 34.52658926144836
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "An efficient bidirectional RRT* with adaptive informed sampling and incremental path shortcutting, focusing sampling within an ellipsoidal subset around the best path to accelerate convergence, combined with local rewiring for path optimization and progressive shortcutting to improve path smoothness and length while reducing planning time. The planner grows two trees from start and goal, alternately expanding toward sampled points focused by current best solution, connects the two trees when possible, rewires locally to optimize costs, and progressively shortcuts the path during planning for smoother results.",
          "planning_mechanism": "The planner alternates growth of two trees (start and goal) using adaptive informed sampling within an ellipsoidal subset defined by the current best path cost. At each iteration, a sample point is generated; nearest nodes are extended toward it with collision checking. The algorithm rewires nearby nodes to optimize path costs locally. Upon connecting both trees, it extracts the combined path and incrementally applies shortcutting to remove unnecessary waypoints and smooth the trajectory. This approach balances efficient exploration, path quality, and runtime performance.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n    def add_child(self, child):\n        self.children.append(child)\nclass Planner:\n    def __init__(self, max_iter=4000, step_size=6.0, radius=12.0, shortcut_interval=50):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.radius = radius\n        self.shortcut_interval = shortcut_interval\n\n    def plan(self, map):\n        import random\n        import math\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = (len(bounds) == 3)\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        best_cost = float('inf')\n        solution_start, solution_goal = None, None\n\n        c_min = math.dist(start_pos, goal_pos)\n        dim = 3 if is_3d else 2\n\n        for i in range(self.max_iter):\n            # Adaptive Sample\n            if best_cost < float('inf'):\n                sample = self._informed_sample(bounds, obstacles, is_3d, start_pos, goal_pos, best_cost, c_min)\n            else:\n                sample = self._sample_free(bounds, obstacles, is_3d)\n\n            # Alternate tree expansion\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest = self._nearest(tree_a, sample)\n                new_pos = self._steer(nearest.position, sample, self.step_size)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                    continue\n\n                new_node = Node(new_pos)\n                near_nodes = self._near(tree_a, new_pos, self.radius)\n\n                min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n                min_parent = nearest\n                for near in near_nodes:\n                    tentative_cost = near.cost + math.dist(near.position, new_pos)\n                    if tentative_cost < min_cost and not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d):\n                        min_cost = tentative_cost\n                        min_parent = near\n\n                new_node.parent = min_parent\n                new_node.cost = min_cost\n                min_parent.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((min_parent, new_node))\n\n                # Rewire near nodes to new_node if beneficial\n                for near in near_nodes:\n                    if near is min_parent:\n                        continue\n                    new_cost = new_node.cost + math.dist(new_node.position, near.position)\n                    if new_cost < near.cost and not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                        if near.parent:\n                            try: edges.remove((near.parent, near))\n                            except ValueError: pass\n                            # Remove near from old parent's children list safely\n                            try: near.parent.children.remove(near)\n                            except ValueError: pass\n                        near.parent = new_node\n                        near.cost = new_cost\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n\n                # Try to connect both trees to form path\n                connect_node = self._nearest(tree_b, new_node.position)\n                dist_connect = math.dist(new_node.position, connect_node.position)\n                if dist_connect <= self.step_size:\n                    if not self._is_edge_in_obstacle(new_node.position, connect_node.position, obstacles, is_3d):\n                        path_cost = new_node.cost + dist_connect + connect_node.cost\n                        if path_cost < best_cost:\n                            best_cost = path_cost\n                            if tree_a is start_tree:\n                                solution_start, solution_goal = new_node, connect_node\n                            else:\n                                solution_start, solution_goal = connect_node, new_node\n\n            # Progressive shortcutting for smoother path every shortcut_interval iterations\n            if best_cost < float('inf') and solution_start and solution_goal and (i % self.shortcut_interval == 0 or i == self.max_iter-1):\n                raw_path = self._extract_path(solution_start, solution_goal)\n                shortcut_path = self._shortcut_path(raw_path, obstacles, is_3d, max_attempts=50)\n                if shortcut_path:\n                    return PlannerResult(True, shortcut_path, nodes, edges)\n\n        # No solution found\n        return PlannerResult(False, [], nodes, edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        import random\n        while True:\n            pt = tuple(random.uniform(0, bounds[i]) for i in range(len(bounds)))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def _informed_sample(self, bounds, obstacles, is_3d, start, goal, c_max, c_min):\n        import random\n        import math\n        dim = 3 if is_3d else 2\n\n        # Reject sample if no valid ellipsoid (e.g. c_max <= c_min)\n        if c_max <= c_min:\n            return self._sample_free(bounds, obstacles, is_3d)\n\n        center = tuple((start[i]+goal[i])/2 for i in range(dim))\n        dir_vec = [goal[i]-start[i] for i in range(dim)]\n        length = math.dist(start, goal)\n        if length == 0:\n            # No interval, uniform sample fallback\n            return self._sample_free(bounds, obstacles, is_3d)\n\n        # Compute rotation matrix R from canonical axis to direction vector\n        if dim == 2:\n            a1 = [1,0]\n            a2 = [dir_vec[0]/length, dir_vec[1]/length]\n            cos_theta = a1[0]*a2[0] + a1[1]*a2[1]\n            sin_theta = a1[0]*a2[1] - a1[1]*a2[0]\n            R = [[cos_theta, -sin_theta],[sin_theta, cos_theta]]\n        else:\n            from math import sqrt\n            a1 = [1,0,0]\n            a2 = [dir_vec[i]/length for i in range(3)]\n            v = [a1[1]*a2[2]-a1[2]*a2[1], a1[2]*a2[0]-a1[0]*a2[2], a1[0]*a2[1]-a1[1]*a2[0]]\n            s = sqrt(sum([vi*vi for vi in v]))\n            c = sum([a1[i]*a2[i] for i in range(3)])\n            if s == 0:\n                R = [[1,0,0],[0,1,0],[0,0,1]]\n            else:\n                vx = [[0,-v[2],v[1]],[v[2],0,-v[0]],[-v[1],v[0],0]]\n                I = [[1 if i==j else 0 for j in range(3)] for i in range(3)]\n                vx2 = [[sum(vx[i][k]*vx[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n                R = [[I[i][j] + vx[i][j] + vx2[i][j]*((1 - c)/(s**2)) for j in range(3)] for i in range(3)]\n\n        # Sample point inside unit ball\n        if dim == 2:\n            r = random.uniform(0,1)**0.5\n            theta = random.uniform(0, 2*math.pi)\n            x_ball = [r*math.cos(theta), r*math.sin(theta)]\n        else:\n            while True:\n                x_ball = [random.uniform(-1,1) for _ in range(3)]\n                if sum(xi*xi for xi in x_ball) <= 1:\n                    break\n\n        a1_val = c_max / 2.0\n        a_other = math.sqrt(c_max**2 - c_min**2) / 2.0\n\n        # Scaling matrix\n        if dim == 2:\n            L = [[a1_val, 0],[0, a_other]]\n            x_scaled = [L[0][0]*x_ball[0] + L[0][1]*x_ball[1],\n                        L[1][0]*x_ball[0] + L[1][1]*x_ball[1]]\n            pt = (center[0] + R[0][0]*x_scaled[0] + R[0][1]*x_scaled[1],\n                  center[1] + R[1][0]*x_scaled[0] + R[1][1]*x_scaled[1])\n        else:\n            L = [[a1_val, 0, 0],[0, a_other, 0],[0, 0, a_other]]\n            x_scaled = [L[0][0]*x_ball[0], L[1][1]*x_ball[1], L[2][2]*x_ball[2]]\n            pt = tuple(center[i] + sum(R[i][j]*x_scaled[j] for j in range(3)) for i in range(3))\n\n        # Reject if outside bounds or in obstacle\n        if any(pt[d] < 0 or pt[d] > bounds[d] for d in range(dim)):\n            return self._sample_free(bounds, obstacles, is_3d)\n        if self._is_in_obstacle(pt, obstacles, is_3d):\n            return self._sample_free(bounds, obstacles, is_3d)\n\n        return pt\n\n    def _nearest(self, tree, point):\n        import math\n        return min(tree, key=lambda n: math.dist(n.position, point))\n\n    def _near(self, tree, point, radius):\n        r_sq = radius*radius\n        return [n for n in tree if sum((n.position[i]-point[i])**2 for i in range(len(point))) <= r_sq]\n\n    def _steer(self, from_pos, to_pos, step_size):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        if dist <= step_size:\n            return to_pos\n        ratio = step_size / dist\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i])*ratio for i in range(len(from_pos)))\n\n    def _extract_path(self, node_start, node_goal):\n        path_start, path_goal = [], []\n        n = node_start\n        while n:\n            path_start.append(n.position)\n            n = n.parent\n        n = node_goal\n        while n:\n            path_goal.append(n.position)\n            n = n.parent\n        return list(reversed(path_start)) + path_goal\n\n    def _shortcut_path(self, path, obstacles, is_3d, max_attempts=30):\n        # Attempt bounded shortcutting to improve smoothness by removing redundant waypoints\n        if len(path) < 3:\n            return path[:]\n        import random\n        new_path = path[:]\n        attempts = 0\n        while attempts < max_attempts:\n            if len(new_path) < 3:\n                break\n            i = random.randint(0, len(new_path)-3)\n            j = random.randint(i+2, len(new_path)-1)\n            if not self._is_edge_in_obstacle(new_path[i], new_path[j], obstacles, is_3d):\n                # Remove intermediate nodes between i and j\n                new_path = new_path[:i+1] + new_path[j:]\n                attempts = 0  # reset attempts after successful shortcut\n            else:\n                attempts += 1\n        return new_path\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x,y,z,w,h,d=obs\n                px,py,pz=pos\n                if x<=px<=x+w and y<=py<=y+h and z<=pz<=z+d:\n                    return True\n            else:\n                x,y,w,h=obs\n                px,py=pos\n                if x<=px<=x+w and y<=py<=y+h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist/resolution))\n        for i in range(steps+1):\n            interp = tuple(from_pos[d] + (to_pos[d]-from_pos[d])*(i/steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -30.55144,
          "time_improvement": 46.0,
          "length_improvement": 18.0,
          "smoothness_improvement": 1254.0,
          "node_improvement": 72.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.019833183288574217,
                    "num_nodes_avg": 147.4,
                    "path_length_avg": 162.65169192869433,
                    "smoothness_avg": 0.04547432196696187,
                    "success_improvement": 0.0,
                    "time_improvement": 23.09980633143671,
                    "node_improvement": 62.880886426592795,
                    "length_improvement": 10.848030272889844,
                    "smoothness_improvement": 611.7718878536382,
                    "objective_score": 16.49761950243311
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.023508524894714354,
                    "num_nodes_avg": 236.2,
                    "path_length_avg": 226.91038346862007,
                    "smoothness_avg": 0.07885871014571852,
                    "success_improvement": 0.0,
                    "time_improvement": 85.80194702529162,
                    "node_improvement": 84.12954377477658,
                    "length_improvement": 24.250782744921644,
                    "smoothness_improvement": 1929.091411682397,
                    "objective_score": 49.936510812952456
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.036681842803955075,
                    "num_nodes_avg": 255.1,
                    "path_length_avg": 123.45751291252664,
                    "smoothness_avg": 0.10380569995332274,
                    "success_improvement": 0.0,
                    "time_improvement": 27.71649022711396,
                    "node_improvement": 67.56516211061665,
                    "length_improvement": 18.005398338521033,
                    "smoothness_improvement": 1220.4008412665191,
                    "objective_score": 25.220190277579402
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e2",
          "algorithm_description": "A unified bidirectional RRT* planner leveraging ellipsoidal informed sampling, dynamic neighborhood radius scaling based on node density, and incremental path shortcutting to enhance efficiency, path length, and smoothness. It alternates tree expansions from start and goal states, samples intelligently within a biasing ellipsoid after initial solutions, rewires neighbors using an adaptive radius following theoretical optimal connection distances, and progressively shortcuts the current best path to maintain smoothness. This approach integrates adaptive rewiring radius, efficient collision checking with early exit, and continuous path refinement to robustly reduce planning time and improve path quality.",
          "planning_mechanism": "The planner maintains two rapidly exploring trees from start and goal, alternately extending them toward samples constrained inside an ellipsoidal informed subset after the first solution. It estimates an adaptive near radius based on theoretical RRT* bounds and current node count to optimize local rewiring. After each improved solution, it extracts and incrementally shortcuts the path to remove unnecessary waypoints and smooth turns, thus continuously improving path quality while minimizing overall runtime.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n    def add_child(self, child):\n        self.children.append(child)\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except ValueError:\n            pass\nclass Planner:\n    def __init__(self, max_iter=4500, step_size=6.5, gamma_rrt_star=50.0, shortcut_interval=40, max_shortcut_attempts=40):\n        # max_iter: max number of iterations\n        # step_size: max extension distance per step\n        # gamma_rrt_star: scaling factor for radius: typically > unit ball volume constant\n        # shortcut_interval: iterations frequency to apply path shortcutting\n        # max_shortcut_attempts: max attempts per incremental shortcutting\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.gamma_rrt_star = gamma_rrt_star\n        self.shortcut_interval = shortcut_interval\n        self.max_shortcut_attempts = max_shortcut_attempts\n\n    def plan(self, map):\n        import random\n        import math\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = (len(bounds) == 3)\n        dim = 3 if is_3d else 2\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        best_cost = float('inf')\n        solution_start, solution_goal = None, None\n        c_min = math.dist(start_pos, goal_pos)\n        volume_unit_ball = self._unit_ball_volume(dim)  # used for radius adapt\n\n        def near_radius(n_nodes):\n            # Adaptive near radius per RRT* theory: gamma * (log(n)/n)^{1/d}\n            if n_nodes <= 1:\n                return self.step_size * 2.5  # fallback large radius initially\n            return min(self.step_size * 50,\n                       self.gamma_rrt_star * (math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n\n        def attempt_connection(tree_a, tree_b, sample):\n            # Extend tree_a toward sample, rewire and try connecting with tree_b\n            nearest = self._nearest(tree_a, sample)\n            new_pos = self._steer(nearest.position, sample, self.step_size)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                return None\n\n            new_node = Node(new_pos)\n            radius = near_radius(len(tree_a))\n            near_nodes = self._near(tree_a, new_pos, radius)\n\n            min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n            min_parent = nearest\n            # Select best parent from near nodes with collision-check\n            for near in near_nodes:\n                tentative_cost = near.cost + math.dist(near.position, new_pos)\n                if tentative_cost < min_cost:\n                    if not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d):\n                        min_cost = tentative_cost\n                        min_parent = near\n\n            new_node.parent = min_parent\n            new_node.cost = min_cost\n            min_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((min_parent, new_node))\n\n            # Rewire neighbors to new_node if improves cost and collision-free\n            for near in near_nodes:\n                if near is min_parent:\n                    continue\n                new_cost = new_node.cost + math.dist(new_node.position, near.position)\n                if new_cost < near.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                        # Remove old edge\n                        if near.parent:\n                            try:\n                                edges.remove((near.parent, near))\n                            except ValueError:\n                                pass\n                            near.parent.remove_child(near)\n                        near.parent = new_node\n                        near.cost = new_cost\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n\n            # Attempt to connect new_node with nearest node in tree_b within step size\n            connect_candidate = self._nearest(tree_b, new_node.position)\n            dist_connect = math.dist(new_node.position, connect_candidate.position)\n            if dist_connect <= self.step_size:\n                if not self._is_edge_in_obstacle(new_node.position, connect_candidate.position, obstacles, is_3d):\n                    total_cost = new_node.cost + dist_connect + connect_candidate.cost\n                    if total_cost < best_cost:\n                        return new_node, connect_candidate, total_cost\n            return None\n\n        def informed_sample():\n            # Ellipsoidal informed sampling inside prolate hyperspheroid given current best_cost\n            if best_cost == float('inf') or best_cost <= c_min:\n                return self._sample_free(bounds, obstacles, is_3d)\n            center = tuple((start_pos[i] + goal_pos[i]) / 2 for i in range(dim))\n            dir_vec = [goal_pos[i] - start_pos[i] for i in range(dim)]\n            length = math.dist(start_pos, goal_pos)\n            # Compute rotation matrix R from canonical axis to direction\n            if dim == 2:\n                if length < 1e-10:\n                    R = [[1, 0], [0, 1]]\n                else:\n                    a1 = [1, 0]\n                    a2 = [dir_vec[0] / length, dir_vec[1] / length]\n                    cos_theta = a1[0] * a2[0] + a1[1] * a2[1]\n                    sin_theta = a1[0] * a2[1] - a1[1] * a2[0]\n                    R = [[cos_theta, -sin_theta], [sin_theta, cos_theta]]\n            else:\n                # 3D rotation matrix by axis-angle\n                from math import sqrt\n                if length < 1e-10:\n                    R = [[1,0,0],[0,1,0],[0,0,1]]\n                else:\n                    a1 = [1,0,0]\n                    a2 = [dir_vec[i] / length for i in range(3)]\n                    v = [a1[1]*a2[2]-a1[2]*a2[1], a1[2]*a2[0]-a1[0]*a2[2], a1[0]*a2[1]-a1[1]*a2[0]]\n                    s = sqrt(sum(vi*vi for vi in v))\n                    c = sum(a1[i]*a2[i] for i in range(3))\n                    if s < 1e-10:\n                        R = [[1,0,0],[0,1,0],[0,0,1]]\n                    else:\n                        vx = [[0,-v[2],v[1]],[v[2],0,-v[0]],[-v[1],v[0],0]]\n                        I = [[1 if i==j else 0 for j in range(3)] for i in range(3)]\n                        vx2 = [[sum(vx[i][k]*vx[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n                        R = [[I[i][j] + vx[i][j] + vx2[i][j]*((1 - c)/(s**2)) for j in range(3)] for i in range(3)]\n\n            a1_val = best_cost / 2.0\n            a_other = math.sqrt(best_cost**2 - c_min**2) / 2.0\n            import random\n\n            while True:\n                # Sample unit ball point\n                if dim == 2:\n                    r = random.uniform(0,1)**0.5\n                    theta = random.uniform(0, 2*math.pi)\n                    x_ball = [r*math.cos(theta), r*math.sin(theta)]\n                    L = [[a1_val, 0],[0, a_other]]\n                    x_scaled = [L[0][0]*x_ball[0] + L[0][1]*x_ball[1],\n                                L[1][0]*x_ball[0] + L[1][1]*x_ball[1]]\n                    pt = (center[0] + R[0][0]*x_scaled[0] + R[0][1]*x_scaled[1],\n                          center[1] + R[1][0]*x_scaled[0] + R[1][1]*x_scaled[1])\n                else:\n                    while True:\n                        x_ball = [random.uniform(-1,1) for _ in range(3)]\n                        if sum(xi*xi for xi in x_ball) <= 1:\n                            break\n                    L = [[a1_val, 0, 0],[0, a_other, 0],[0, 0, a_other]]\n                    x_scaled = [L[0][0]*x_ball[0], L[1][1]*x_ball[1], L[2][2]*x_ball[2]]\n                    pt = tuple(center[i] + sum(R[i][j]*x_scaled[j] for j in range(dim)) for i in range(dim))\n\n                # Check bounds and obstacles\n                if any(pt[d] < 0 or pt[d] > bounds[d] for d in range(dim)):\n                    continue\n                if self._is_in_obstacle(pt, obstacles, is_3d):\n                    continue\n                return pt\n\n        # Progressive path shortcutting with limited attempts to improve smoothness incrementally\n        def progressive_shortcut(path):\n            if len(path) < 3:\n                return path[:]\n            import random\n            new_path = path[:]\n            attempts = 0\n            while attempts < self.max_shortcut_attempts:\n                if len(new_path) < 3:\n                    break\n                i = random.randint(0, len(new_path)-3)\n                j = random.randint(i+2, len(new_path)-1)\n                if not self._is_edge_in_obstacle(new_path[i], new_path[j], obstacles, is_3d):\n                    new_path = new_path[:i+1] + new_path[j:]\n                    attempts = 0  # reset on success\n                else:\n                    attempts += 1\n            return new_path\n\n        for iteration in range(self.max_iter):\n            sample = informed_sample() if (best_cost < float('inf')) else self._sample_free(bounds, obstacles, is_3d)\n\n            # Alternate tree expansion\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                result = attempt_connection(tree_a, tree_b, sample)\n                if result is not None:\n                    new_node, connect_node, total_cost = result\n                    if total_cost < best_cost:\n                        best_cost = total_cost\n                        if tree_a is start_tree:\n                            solution_start, solution_goal = new_node, connect_node\n                        else:\n                            solution_start, solution_goal = connect_node, new_node\n\n            # Incremental shortcut every shortcut_interval iterations after finding a solution\n            if best_cost < float('inf') and solution_start and solution_goal:\n                if iteration % self.shortcut_interval == 0 or iteration == self.max_iter - 1:\n                    raw_path = self._extract_path(solution_start, solution_goal)\n                    improved_path = progressive_shortcut(raw_path)\n                    if improved_path and len(improved_path) >= 2:\n                        return PlannerResult(True, improved_path, nodes, edges)\n\n        # No solution found\n        return PlannerResult(False, [], nodes, edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        import random\n        while True:\n            pt = tuple(random.uniform(0, bounds[i]) for i in range(len(bounds)))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def _nearest(self, tree, point):\n        import math\n        best_node = None\n        best_dist = float('inf')\n        for node in tree:\n            d = 0.0\n            for i in range(len(point)):\n                diff = node.position[i] - point[i]\n                d += diff*diff\n            if d < best_dist:\n                best_dist = d\n                best_node = node\n        return best_node\n\n    def _near(self, tree, point, radius):\n        r_sq = radius*radius\n        near_nodes = []\n        for n in tree:\n            d = 0.0\n            for i in range(len(point)):\n                diff = n.position[i] - point[i]\n                d += diff*diff\n            if d <= r_sq:\n                near_nodes.append(n)\n        return near_nodes\n\n    def _steer(self, from_pos, to_pos, step_size):\n        import math\n        dist = 0.0\n        for i in range(len(from_pos)):\n            diff = to_pos[i] - from_pos[i]\n            dist += diff*diff\n        dist = dist**0.5\n        if dist <= step_size:\n            return to_pos\n        ratio = step_size / dist\n        new_pos = tuple(from_pos[i] + ratio * (to_pos[i] - from_pos[i]) for i in range(len(from_pos)))\n        return new_pos\n\n    def _extract_path(self, node_start, node_goal):\n        path_start = []\n        n = node_start\n        while n is not None:\n            path_start.append(n.position)\n            n = n.parent\n        path_goal = []\n        n = node_goal\n        while n is not None:\n            path_goal.append(n.position)\n            n = n.parent\n        return list(reversed(path_start)) + path_goal\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x,y,z,w,h,d = obs\n                px,py,pz = pos\n                if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                    return True\n            else:\n                x,y,w,h = obs\n                px,py = pos\n                if x <= px <= x+w and y <= py <= y+h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        dist = 0.0\n        for i in range(len(from_pos)):\n            diff = to_pos[i] - from_pos[i]\n            dist += diff*diff\n        dist = dist**0.5\n        steps = max(1, int(dist / resolution))\n        for step in range(steps+1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (step / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _unit_ball_volume(self, dim):\n        import math\n        # Volume of unit ball in dimension dim\n        if dim == 2:\n            return math.pi\n        elif dim == 3:\n            return 4.0/3.0 * math.pi\n        else:\n            # General formula using gamma function approximation\n            from math import gamma\n            return (math.pi**(dim/2)) / gamma(dim/2 + 1)",
          "objective": -28.03557,
          "time_improvement": 38.0,
          "length_improvement": 15.0,
          "smoothness_improvement": 1533.0,
          "node_improvement": 72.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.023175954818725586,
                    "num_nodes_avg": 135.3,
                    "path_length_avg": 175.79982556162778,
                    "smoothness_avg": 0.04886810478019664,
                    "success_improvement": 0.0,
                    "time_improvement": 10.13871106406778,
                    "node_improvement": 65.92797783933518,
                    "length_improvement": 3.641329883168963,
                    "smoothness_improvement": 664.8919585980976,
                    "objective_score": 8.550871042112199
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.03271842002868652,
                    "num_nodes_avg": 261.1,
                    "path_length_avg": 229.80246953520958,
                    "smoothness_avg": 0.09634245712495317,
                    "success_improvement": 0.0,
                    "time_improvement": 80.239599766615,
                    "node_improvement": 82.45649398642746,
                    "length_improvement": 23.28532117181223,
                    "smoothness_improvement": 2378.9608144920394,
                    "objective_score": 49.937876705532034
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.03931493759155273,
                    "num_nodes_avg": 263.8,
                    "path_length_avg": 122.75935520727265,
                    "smoothness_avg": 0.13016053434098707,
                    "success_improvement": 0.0,
                    "time_improvement": 22.527837796824144,
                    "node_improvement": 66.45899554990464,
                    "length_improvement": 18.469081443653348,
                    "smoothness_improvement": 1555.6323893660885,
                    "objective_score": 25.617962152069694
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "This algorithm implements an adaptive bidirectional RRT* planner with goal bias and progressive shortcutting for improved path quality, smoothness, and planning efficiency. It alternately expands two trees from start and goal, dynamically adjusts rewiring radius based on tree size, leverages goal bias sampling to focus exploration, and employs repeated path shortcutting to smooth and shorten the resulting path before returning it. This balanced approach enhances convergence speed, reduces path length, and significantly improves smoothness while maintaining collision-free guarantees.",
          "planning_mechanism": "The planner grows two trees from start and goal positions using an RRT* framework with adaptive radius rewiring for local optimality. It samples random points with goal bias, extends each tree towards samples, rewires to reduce path cost, and attempts to connect the trees when close. Upon connecting, it extracts the combined path and performs multiple shortcutting passes to smooth the path before outputting the result.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.children.remove(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=4.0, goal_sample_rate=0.1, gamma=30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.gamma = gamma  # tuning parameter for adaptive radius\n\n    def plan(self, map):\n        import math\n        import random\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = dim == 3\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    px, py = pos\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def edge_in_obstacle(p1, p2, resolution=1.0):\n            d = dist(p1, p2)\n            steps = max(1, int(d / resolution))\n            for i in range(steps + 1):\n                interp = tuple(p1[j] + (p2[j] - p1[j]) * i / steps for j in range(dim))\n                if in_obstacle(interp):\n                    return True\n            return False\n\n        def steer(from_p, to_p, max_step):\n            d = dist(from_p, to_p)\n            if d <= max_step:\n                return to_p\n            ratio = max_step / d\n            return tuple(from_p[i] + (to_p[i] - from_p[i]) * ratio for i in range(dim))\n\n        def get_nearest(tree, point):\n            return min(tree, key=lambda node: dist(node.position, point))\n\n        def get_near_nodes(tree, new_pos, radius):\n            return [node for node in tree if dist(node.position, new_pos) <= radius]\n\n        def adaptive_radius(n):\n            # Based on RRT* radius scaling law\n            if n == 0:\n                return self.step_size * 2\n            return min(self.gamma * (math.log(n) / n) ** (1 / dim), self.step_size * 20)\n\n        def rewire(tree, nodes, edges, new_node, near_nodes):\n            for near_node in near_nodes:\n                if near_node is new_node.parent:\n                    continue\n                cost_through_new = new_node.cost + dist(new_node.position, near_node.position)\n                if cost_through_new + 1e-7 < near_node.cost:\n                    if not edge_in_obstacle(new_node.position, near_node.position):\n                        if (near_node.parent, near_node) in edges:\n                            edges.remove((near_node.parent, near_node))\n                        near_node.update_parent(new_node, cost_through_new)\n                        edges.append((new_node, near_node))\n\n        nodes_start = [Node(start_pos)]\n        nodes_goal = [Node(goal_pos)]\n        edges = []\n        forward_tree = nodes_start\n        backward_tree = nodes_goal\n        success = False\n        connect_node_start = None\n        connect_node_goal = None\n\n        for it in range(self.max_iter):\n            # Alternate growing trees\n            for grow_start_tree_first in (True, False):\n                if grow_start_tree_first:\n                    tree_a, tree_b = forward_tree, backward_tree\n                else:\n                    tree_a, tree_b = backward_tree, forward_tree\n\n                # Sample with goal bias toward other tree's root\n                if random.random() < self.goal_sample_rate:\n                    sample = tree_b[0].position\n                else:\n                    sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if in_obstacle(sample):\n                    continue\n\n                nearest = get_nearest(tree_a, sample)\n                new_pos = steer(nearest.position, sample, self.step_size)\n                if in_obstacle(new_pos) or edge_in_obstacle(nearest.position, new_pos):\n                    continue\n\n                # Adaptive radius dependent on current tree size\n                radius = adaptive_radius(len(tree_a) + 1)\n                near_nodes = get_near_nodes(tree_a, new_pos, radius)\n\n                # Choose best parent among near nodes\n                min_cost = nearest.cost + dist(nearest.position, new_pos)\n                best_parent = nearest\n                for near in near_nodes:\n                    if not edge_in_obstacle(near.position, new_pos):\n                        cost_candidate = near.cost + dist(near.position, new_pos)\n                        if cost_candidate < min_cost:\n                            min_cost = cost_candidate\n                            best_parent = near\n\n                new_node = Node(new_pos)\n                new_node.parent = best_parent\n                new_node.cost = min_cost\n                best_parent.add_child(new_node)\n                tree_a.append(new_node)\n                edges.append((best_parent, new_node))\n\n                # Rewire near nodes to new node if cost improves and collision free\n                rewire(tree_a, tree_a, edges, new_node, near_nodes)\n\n                # Try to connect trees\n                nearest_in_other = get_nearest(tree_b, new_node.position)\n                if dist(new_node.position, nearest_in_other.position) <= self.step_size:\n                    if not edge_in_obstacle(new_node.position, nearest_in_other.position):\n                        # Connect trees\n                        connect_node_start = new_node if grow_start_tree_first else nearest_in_other\n                        connect_node_goal = nearest_in_other if grow_start_tree_first else new_node\n                        success = True\n                        break\n            if success:\n                break\n\n        def extract_path(node_start, node_goal):\n            path_start = []\n            cur = node_start\n            while cur:\n                path_start.append(cur.position)\n                cur = cur.parent\n            path_goal = []\n            cur = node_goal\n            while cur:\n                path_goal.append(cur.position)\n                cur = cur.parent\n            return path_start[::-1] + path_goal\n\n        def shortcut_path(path, max_attempts=100):\n            if len(path) < 3:\n                return path\n            for _ in range(max_attempts):\n                if len(path) <= 2:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if not edge_in_obstacle(p1, p2):\n                    # Remove intermediate points between i and j\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        nodes_all = nodes_start + nodes_goal\n        if success:\n            raw_path = extract_path(connect_node_start, connect_node_goal)\n            smoothed_path = shortcut_path(raw_path, max_attempts=200)\n            return PlannerResult(True, smoothed_path, nodes_all, edges)\n        else:\n            return PlannerResult(False, [], nodes_all, edges)",
          "objective": -26.77328,
          "time_improvement": 30.0,
          "length_improvement": 17.0,
          "smoothness_improvement": 1515.0,
          "node_improvement": 64.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.026349878311157225,
                    "num_nodes_avg": 131.5,
                    "path_length_avg": 161.50533767083496,
                    "smoothness_avg": 0.04633540991002978,
                    "success_improvement": 0.0,
                    "time_improvement": -2.1677012604634127,
                    "node_improvement": 66.88491563837825,
                    "length_improvement": 11.476365206768222,
                    "smoothness_improvement": 625.2497840450478,
                    "objective_score": 9.361757666147147
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.0372589111328125,
                    "num_nodes_avg": 338.9,
                    "path_length_avg": 239.0656007486035,
                    "smoothness_avg": 0.10263753383464265,
                    "success_improvement": 0.0,
                    "time_improvement": 77.49735483562543,
                    "node_improvement": 77.22905328226837,
                    "length_improvement": 20.193021348332763,
                    "smoothness_improvement": 2540.9376723928312,
                    "objective_score": 48.069707621651446
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.0440518856048584,
                    "num_nodes_avg": 400.8,
                    "path_length_avg": 120.37369996551419,
                    "smoothness_avg": 0.11632493211416521,
                    "success_improvement": 0.0,
                    "time_improvement": 13.193431402810726,
                    "node_improvement": 49.040050858232675,
                    "length_improvement": 20.053520062534325,
                    "smoothness_improvement": 1379.6445502788406,
                    "objective_score": 22.888364209758016
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e2",
          "algorithm_description": "This algorithm is a bidirectional RRT* variant combining informed elliptical sampling with adaptive neighborhood radius recalibration to improve convergence speed and path quality. It grows two trees simultaneously from start and goal, performs efficient nearest and near neighbor searches, applies incremental rewiring with cost propagation, and attempts frequent connections between trees. The informed sampling targets ellipsoidal regions shaped by the best current path cost, and the radius adapts based on iteration count and node density to balance exploration and optimization. After successful connection, the algorithm extracts and performs iterated shortcut smoothing to produce shorter, smoother paths while ensuring collision-free nodes and edges within map bounds.",
          "planning_mechanism": "The planner alternates expansion of two trees using adaptive informed sampling within an ellipsoidal informed set defined by the best path cost. Each extension seeks a minimum cost parent within an adaptive radius, followed by rewiring neighbors to reduce path cost with recursive updates. Regular connection attempts between trees detect early solutions. When a solution is found, the algorithm performs iterative shortcutting with collision checks to improve smoothness and path length while respecting collision and map boundary constraints.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=5.0, base_radius=20.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.base_radius = base_radius\n\n    def plan(self, map):\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        edges = []\n\n        best_path = []\n        best_cost = float('inf')\n\n        def dist(a, b):\n            return math.dist(a,b)\n\n        def in_bounds(p):\n            return all(0 <= p[i] <= bounds[i] for i in range(dim))\n\n        def collision_node(p):\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d = obs\n                    px,py,pz = p\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                        return True\n                else:\n                    x,y,w,h = obs\n                    px,py = p\n                    if x <= px <= x+w and y <= py <= y+h:\n                        return True\n            return False\n\n        def collision_edge(a,b,res=0.5):\n            length = dist(a,b)\n            steps = max(1,int(length / res))\n            for i in range(steps+1):\n                interp = tuple(a[d] + (b[d]-a[d])*(i/steps) for d in range(dim))\n                if collision_node(interp):\n                    return True\n            return False\n\n        def steer(from_p,to_p):\n            length = dist(from_p,to_p)\n            if length <= self.step_size:\n                return to_p\n            ratio = self.step_size / length\n            return tuple(from_p[i] + (to_p[i] - from_p[i]) * ratio for i in range(dim))\n\n        def nearest(tree, p):\n            best_node = None\n            best_dist = float('inf')\n            for node in tree:\n                d = dist(node.position, p)\n                if d < best_dist:\n                    best_dist = d\n                    best_node = node\n            return best_node\n\n        def near(tree, p, radius):\n            result = []\n            r_sq = radius*radius\n            for node in tree:\n                d_sq = sum((node.position[i] - p[i])**2 for i in range(dim))\n                if d_sq <= r_sq:\n                    result.append(node)\n            return result\n\n        def heuristic_cost_to_go(p):\n            return dist(p, goal_pos)\n\n        def cost_to_come(p):\n            nn = nearest(start_tree, p)\n            return nn.cost + dist(nn.position, p)\n\n        def informed_sample():\n            c_min = dist(start_pos, goal_pos)\n            c_best = best_cost\n            if c_best == float('inf'):\n                while True:\n                    sample = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                    if not collision_node(sample):\n                        return sample\n            # Ellipsoidal informed sampling:\n            center = tuple((start_pos[i] + goal_pos[i]) / 2 for i in range(dim))\n            foci_dist = c_min\n            if c_best < c_min:\n                c_best = c_min + 1e-6\n            r1 = c_best / 2\n            val = c_best*c_best - foci_dist*foci_dist\n            r_rest = math.sqrt(val)/2 if val > 0 else 0.0\n\n            def unit_ball_sample(dim_):\n                while True:\n                    vec = [random.gauss(0,1) for _ in range(dim_)]\n                    norm = math.sqrt(sum(x*x for x in vec))\n                    if norm > 1e-8:\n                        break\n                u = [x/norm for x in vec]\n                r = random.random() ** (1/dim_)\n                return [u[i]*r for i in range(dim_)]\n\n            while True:\n                u_sample = unit_ball_sample(dim)\n                sample_ellipsoid = [0]*dim\n                sample_ellipsoid[0] = u_sample[0]*r1\n                for i in range(1,dim):\n                    sample_ellipsoid[i] = u_sample[i]*r_rest\n                point = tuple(center[i] + sample_ellipsoid[i] for i in range(dim))\n                if in_bounds(point) and not collision_node(point):\n                    return point\n\n        def new_radius(iteration, tree_size):\n            # Adaptive radius shrinking over iterations and growing tree size, per theory ~ (log n / n)^{1/d}\n            if tree_size < 2:\n                return self.base_radius\n            gamma_rrt_star = self.base_radius\n            radius = min(gamma_rrt_star, \n                         gamma_rrt_star * (math.log(tree_size)/tree_size)**(1/dim))\n            # Enforce reasonable limits\n            return max(radius, self.step_size)\n\n        def propagate_cost(node):\n            for child in node.children:\n                new_cost = node.cost + dist(node.position, child.position)\n                if new_cost < child.cost:\n                    child.cost = new_cost\n                    propagate_cost(child)\n\n        def rewire(tree, new_node, near_nodes):\n            for near_node in near_nodes:\n                if near_node is new_node.parent:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, near_node.position)\n                est_total_new = new_cost + heuristic_cost_to_go(near_node.position)\n                est_total_old = near_node.cost + heuristic_cost_to_go(near_node.position)\n                if est_total_new + 1e-9 < est_total_old and new_cost < near_node.cost:\n                    if not collision_edge(new_node.position, near_node.position):\n                        # Remove old parent-child relationship\n                        if near_node.parent:\n                            near_node.parent.remove_child(near_node)\n                            if (near_node.parent, near_node) in edges:\n                                edges.remove((near_node.parent, near_node))\n                        near_node.parent = new_node\n                        near_node.cost = new_cost\n                        new_node.add_child(near_node)\n                        edges.append((new_node, near_node))\n                        propagate_cost(near_node)\n\n        def extract_path(node_start, node_goal):\n            path_start = []\n            node = node_start\n            while node:\n                path_start.append(node.position)\n                node = node.parent\n            path_start.reverse()\n            path_goal = []\n            node = node_goal\n            while node:\n                path_goal.append(node.position)\n                node = node.parent\n            return path_start + path_goal\n\n        def shortcut_path(path, max_iters=50):\n            length = len(path)\n            if length < 3:\n                return path[:]\n            new_path = path[:]\n            for _ in range(max_iters):\n                if len(new_path) < 3:\n                    break\n                i = random.randint(0, len(new_path)-3)\n                j = random.randint(i+2, len(new_path)-1)\n                if not collision_edge(new_path[i], new_path[j]):\n                    del new_path[i+1:j]\n            return new_path\n\n        for iter in range(1, self.max_iter+1):\n            sample = informed_sample()\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nn = nearest(tree_a, sample)\n                new_pos = steer(nn.position, sample)\n                if not in_bounds(new_pos):\n                    continue\n                if collision_node(new_pos):\n                    continue\n                if collision_edge(nn.position, new_pos):\n                    continue\n\n                radius = new_radius(iter, len(tree_a))\n                near_nodes = near(tree_a, new_pos, radius)\n\n                min_cost = nn.cost + dist(nn.position, new_pos)\n                min_parent = nn\n                for near_node in near_nodes:\n                    cost_cand = near_node.cost + dist(near_node.position, new_pos)\n                    if cost_cand < min_cost and not collision_edge(near_node.position, new_pos):\n                        min_cost = cost_cand\n                        min_parent = near_node\n\n                new_node = Node(new_pos, min_parent, min_cost)\n                min_parent.add_child(new_node)\n                tree_a.append(new_node)\n                edges.append((min_parent, new_node))\n\n                rewire(tree_a, new_node, near_nodes)\n\n                conn_node = nearest(tree_b, new_node.position)\n                dist_connect = dist(conn_node.position, new_node.position)\n                if dist_connect <= self.step_size and not collision_edge(conn_node.position, new_node.position):\n                    candidate_path = extract_path(new_node, conn_node)\n                    path_cost = 0.0\n                    for k in range(len(candidate_path)-1):\n                        path_cost += dist(candidate_path[k], candidate_path[k+1])\n                    if path_cost < best_cost:\n                        best_cost = path_cost\n                        best_path = shortcut_path(candidate_path, max_iters=100)\n                        if best_cost < float('inf'):\n                            return PlannerResult(True, best_path, start_tree + goal_tree, edges)\n\n        if best_path:\n            return PlannerResult(True, best_path, start_tree + goal_tree, edges)\n        return PlannerResult(False, [], start_tree + goal_tree, edges)",
          "objective": -26.27848,
          "time_improvement": 35.0,
          "length_improvement": 15.0,
          "smoothness_improvement": 1433.0,
          "node_improvement": 70.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.018117833137512206,
                    "num_nodes_avg": 114.4,
                    "path_length_avg": 171.0714968515819,
                    "smoothness_avg": 0.0338915604180979,
                    "success_improvement": 0.0,
                    "time_improvement": 29.750819278110836,
                    "node_improvement": 71.19113573407203,
                    "length_improvement": 6.233001774308198,
                    "smoothness_improvement": 430.476517244636,
                    "objective_score": 14.81742943424135
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.031439352035522464,
                    "num_nodes_avg": 278.2,
                    "path_length_avg": 238.74291742398609,
                    "smoothness_avg": 0.10316733134869423,
                    "success_improvement": 0.0,
                    "time_improvement": 81.01209719920723,
                    "node_improvement": 81.3075320835853,
                    "length_improvement": 20.300742330014568,
                    "smoothness_improvement": 2554.5697440271038,
                    "objective_score": 49.25692327790643
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.05441353321075439,
                    "num_nodes_avg": 340.1,
                    "path_length_avg": 124.59040420304787,
                    "smoothness_avg": 0.11126977220167059,
                    "success_improvement": 0.0,
                    "time_improvement": -7.224742787261016,
                    "node_improvement": 56.75778766687858,
                    "length_improvement": 17.252985885842975,
                    "smoothness_improvement": 1315.3432893250001,
                    "objective_score": 14.761085141952478
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "initial",
          "algorithm_description": "This algorithm grows two trees simultaneously, one from the start position and one from the goal position, and attempts to connect them to find a feasible path. This bidirectional approach accelerates convergence and increases the success rate compared to a single tree RRT.",
          "planning_mechanism": "The planning mechanism involves randomly sampling points within the map bounds, extending each tree towards the sampled points, and attempting to connect the two trees whenever new nodes are added. Collision checks are performed for nodes and edges to ensure safety, and once the two trees connect, the final path is reconstructed by backtracking through the parent nodes of each tree.",
          "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map) -> PlannerResult:\n        import math, random\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position)\n        goal_root = Node(goal_position)\n        nodes.extend([start_root, goal_root])\n        tree_a, tree_b = [start_root], [goal_root]\n\n        for _ in range(self.max_iter):\n            rand_point = self._sample_free(bounds, obstacles, is_3d)\n            new_a = self._extend_tree(tree_a, rand_point, obstacles, is_3d, nodes, edges)\n            if new_a is None:\n                continue\n\n            new_b = self._connect_trees(tree_b, new_a, obstacles, is_3d, nodes, edges)\n            if new_b:\n                success_state = True\n                path_a = new_a.path_from_root()\n                path_b = new_b.path_from_root()\n                extracted_path = path_a + path_b[::-1]\n                break\n\n            tree_a, tree_b = tree_b, tree_a  # Swap trees\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        import random\n        while True:\n            if is_3d:\n                p = (random.uniform(0, bounds[0]),\n                     random.uniform(0, bounds[1]),\n                     random.uniform(0, bounds[2]))\n            else:\n                p = (random.uniform(0, bounds[0]),\n                     random.uniform(0, bounds[1]))\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    def _nearest(self, tree, point):\n        import math\n        return min(tree, key=lambda node: math.dist(node.position, point))\n\n    def _steer(self, from_pos, to_pos):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _extend_tree(self, tree, point, obstacles, is_3d, nodes, edges):\n        nearest_node = self._nearest(tree, point)\n        new_pos = self._steer(nearest_node.position, point)\n        if not self._is_in_obstacle(new_pos, obstacles, is_3d) and not self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n            new_node = Node(new_pos, parent=nearest_node)\n            nearest_node.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n            return new_node\n        return None\n\n    def _connect_trees(self, tree, new_node, obstacles, is_3d, nodes, edges):\n        import math\n        nearest_node = self._nearest(tree, new_node.position)\n        while True:\n            new_pos = self._steer(nearest_node.position, new_node.position)\n            if (not self._is_in_obstacle(new_pos, obstacles, is_3d) and\n                not self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d)):\n                next_node = Node(new_pos, parent=nearest_node)\n                nearest_node.add_child(next_node)\n                tree.append(next_node)\n                nodes.append(next_node)\n                edges.append((nearest_node, next_node))\n\n                if math.dist(next_node.position, new_node.position) <= self.step_size:\n                    if not self._is_edge_in_obstacle(next_node.position, new_node.position, obstacles, is_3d):\n                        final_node = Node(new_node.position, parent=next_node)\n                        next_node.add_child(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((next_node, final_node))\n                        return final_node\n                    else:\n                        return None\n                nearest_node = next_node\n            else:\n                return None\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n",
          "objective": -26.16492572596105,
          "time_improvement": 92.0,
          "length_improvement": -3.0,
          "smoothness_improvement": 63.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.003008270263671875,
                    "num_nodes_avg": 68.1,
                    "path_length_avg": 184.17006126805845,
                    "smoothness_avg": 0.01054995558932253,
                    "success_improvement": 0.0,
                    "time_improvement": 88.33588322571401,
                    "node_improvement": 82.85066733820196,
                    "length_improvement": -0.9465289423981464,
                    "smoothness_improvement": 65.12971456814059,
                    "objective_score": 26.25849617511602
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.008660387992858887,
                    "num_nodes_avg": 222.5,
                    "path_length_avg": 300.8164456420612,
                    "smoothness_avg": 0.0064472474436514295,
                    "success_improvement": 0.0,
                    "time_improvement": 94.76952943432936,
                    "node_improvement": 85.05005711214136,
                    "length_improvement": -0.4211880766230819,
                    "smoothness_improvement": 65.89232048978258,
                    "objective_score": 28.50760758677387
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.0042524576187133786,
                    "num_nodes_avg": 126.3,
                    "path_length_avg": 160.72624335922288,
                    "smoothness_avg": 0.012431076585876402,
                    "success_improvement": 0.0,
                    "time_improvement": 91.62030753242554,
                    "node_improvement": 83.94151303242214,
                    "length_improvement": -6.746717877938324,
                    "smoothness_improvement": 58.122376605720596,
                    "objective_score": 23.72867341599327
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "initial",
          "algorithm_description": "This algorithm is a bidirectional extension of RRT* that grows two trees from start and goal while optimizing paths via rewiring. It combines RRT*\u2018s asymptotic optimality with RRT-Connect\u2019s fast convergence through connection attempts between the trees.",
          "planning_mechanism": "The planner alternates growing two trees with sampling, extension, and rewiring. After each extension, it attempts to connect both trees. When connection is successful, a rewired optimal path is extracted across both trees.",
          "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, radius: float = 10.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.radius = radius\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n        nodes = []\n        edges = []\n        success_state = False\n        extracted_path = []\n\n        for iter in range(self.max_iter):\n            rand = self._sample_free(bounds, obstacles, is_3d)\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest = self._nearest(tree_a, rand)\n                new_pos = self._steer(nearest.position, rand, self.step_size)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                    continue\n\n                new_node = Node(new_pos)\n                near_nodes = self._near(tree_a, new_pos, self.radius)\n                min_cost = nearest.cost + self._distance(nearest.position, new_pos)\n                min_parent = nearest\n\n                for near in near_nodes:\n                    cost = near.cost + self._distance(near.position, new_pos)\n                    if cost < min_cost and not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d):\n                        min_cost = cost\n                        min_parent = near\n\n                new_node.parent = min_parent\n                new_node.cost = min_cost\n                min_parent.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((min_parent, new_node))\n\n                for near in near_nodes:\n                    if near == min_parent:\n                        continue\n                    new_cost = new_node.cost + self._distance(new_node.position, near.position)\n                    if new_cost < near.cost and not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                        if near.parent:\n                            edges.remove((near.parent, near))\n                        near.parent = new_node\n                        near.cost = new_cost\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n\n                connect_node = self._nearest(tree_b, new_node.position)\n                if self._distance(new_node.position, connect_node.position) < self.step_size and not self._is_edge_in_obstacle(new_node.position, connect_node.position, obstacles, is_3d):\n                    success_state = True\n                    extracted_path = self._extract_path(new_node, connect_node)\n                    return PlannerResult(True, extracted_path, start_tree + goal_tree, edges)\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        while True:\n            point = tuple(random.uniform(0, bounds[i]) for i in range(3 if is_3d else 2))\n            if not self._is_in_obstacle(point, obstacles, is_3d):\n                return point\n\n    def _nearest(self, tree, point):\n        return min(tree, key=lambda node: self._distance(node.position, point))\n\n    def _near(self, tree, point, radius):\n        return [node for node in tree if self._distance(node.position, point) <= radius]\n\n    def _steer(self, from_pos, to_pos, step_size):\n        dist = self._distance(from_pos, to_pos)\n        if dist <= step_size:\n            return to_pos\n        ratio = step_size / dist\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n    def _extract_path(self, node_a, node_b):\n        path_a = []\n        while node_a:\n            path_a.append(node_a.position)\n            node_a = node_a.parent\n        path_b = []\n        while node_b:\n            path_b.append(node_b.position)\n            node_b = node_b.parent\n        return list(reversed(path_a)) + path_b\n\n    def _distance(self, a, b):\n        return math.dist(a, b)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = self._distance(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n    ",
          "objective": -26.062040773062417,
          "time_improvement": 66.0,
          "length_improvement": 9.0,
          "smoothness_improvement": 167.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.012016057968139648,
                    "num_nodes_avg": 134.5,
                    "path_length_avg": 175.84673815929608,
                    "smoothness_avg": 0.016310939143948412,
                    "success_improvement": 0.0,
                    "time_improvement": 53.409537367863955,
                    "node_improvement": 66.1294384286074,
                    "length_improvement": 3.6156163450092893,
                    "smoothness_improvement": 155.30161737405683,
                    "objective_score": 18.96873910423504
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.018314409255981445,
                    "num_nodes_avg": 253.0,
                    "path_length_avg": 257.3377355314211,
                    "smoothness_avg": 0.010767991223558952,
                    "success_improvement": 0.0,
                    "time_improvement": 88.93895070058699,
                    "node_improvement": 83.00073909830007,
                    "length_improvement": 14.093256823589732,
                    "smoothness_improvement": 177.06817005275553,
                    "objective_score": 36.02298015459372
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.022396659851074217,
                    "num_nodes_avg": 265.9,
                    "path_length_avg": 136.5245362961063,
                    "smoothness_avg": 0.0210441701583257,
                    "success_improvement": 0.0,
                    "time_improvement": 55.86619816574277,
                    "node_improvement": 66.19198982835347,
                    "length_improvement": 9.326903591935762,
                    "smoothness_improvement": 167.68029109483984,
                    "objective_score": 23.19440306035849
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e1",
          "algorithm_description": "A bidirectional informed RRT* with adaptive sampling and post-processing path shortcutting. The algorithm grows two trees from start and goal, but restricts sampling within an ellipsoidal region (informed sampling) to focus search around the best solution path. It performs rewiring to optimize local connections and applies an efficient post-processing shortcutting procedure to smooth the final path, which improves path quality and smoothness while reducing planning time.",
          "planning_mechanism": "The planner alternates expanding two trees by sampling random points within an informed ellipsoidal subset after an initial solution is found. It performs steer, collision checks, rewiring, and attempts to connect the trees continuously. Upon success, it extracts the path and applies post-processing shortcutting to remove unnecessary waypoints and smooth sharp turns, leading to a shorter, smoother trajectory with improved efficiency.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n    def add_child(self, child):\n        self.children.append(child)\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=7.0, radius=15.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.radius = radius\n\n    def plan(self, map):\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = (len(bounds) == 3)\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = []\n        edges = []\n\n        best_path_cost = float('inf')\n        solution_node_start = None\n        solution_node_goal = None\n\n        # Basic heuristic distance for informed sampling\n        c_min = self._distance(start_pos, goal_pos)\n\n        for i in range(self.max_iter):\n            if solution_node_start and solution_node_goal:\n                # Informed sampling inside ellipsoid bounding current best path cost\n                sample = self._informed_sample(bounds, obstacles, is_3d, start_pos, goal_pos, best_path_cost, c_min)\n            else:\n                # Uniform random sampling within bounds free space\n                sample = self._sample_free(bounds, obstacles, is_3d)\n\n            for tree_a, tree_b in [(start_tree,goal_tree),(goal_tree,start_tree)]:\n                nearest = self._nearest(tree_a, sample)\n                new_pos = self._steer(nearest.position, sample, self.step_size)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d): continue\n                if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d): continue\n\n                new_node = Node(new_pos)\n                near_nodes = self._near(tree_a, new_pos, self.radius)\n\n                # Choose best parent among near nodes considering path cost and collision\n                min_cost = nearest.cost + self._distance(nearest.position, new_pos)\n                min_parent = nearest\n                for near in near_nodes:\n                    tent_cost = near.cost + self._distance(near.position, new_pos)\n                    if tent_cost < min_cost and not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d):\n                        min_cost = tent_cost\n                        min_parent = near\n\n                new_node.parent = min_parent\n                new_node.cost = min_cost\n                min_parent.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((min_parent, new_node))\n\n                # Rewire neighbors if new node offers a better path\n                for near in near_nodes:\n                    if near == min_parent: continue\n                    new_cost = new_node.cost + self._distance(new_node.position, near.position)\n                    if new_cost < near.cost and not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                        if near.parent:\n                            try: edges.remove((near.parent, near))\n                            except ValueError: pass\n                        near.parent = new_node\n                        near.cost = new_cost\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n\n                # Try to connect to tree_b within step size and collision free\n                connect_node = self._nearest(tree_b, new_node.position)\n                if self._distance(new_node.position, connect_node.position) <= self.step_size:\n                    if not self._is_edge_in_obstacle(new_node.position, connect_node.position, obstacles, is_3d):\n                        # Construct candidate path cost\n                        path_cost = new_node.cost + self._distance(new_node.position, connect_node.position) + connect_node.cost\n                        if path_cost < best_path_cost:\n                            best_path_cost = path_cost\n                            solution_node_start, solution_node_goal = (new_node, connect_node) if tree_a is start_tree else (connect_node, new_node)\n                        # We can continue to iterate to improve path\n\n            if best_path_cost < float('inf') and (i % 100 == 0 or i == self.max_iter -1):\n                # Extract and shortcut path every 100 iterations or at end for smoother solution\n                raw_path = self._extract_path(solution_node_start, solution_node_goal)\n                shortcut_path = self._shortcut_path(raw_path, obstacles, is_3d)\n                if shortcut_path:\n                    return PlannerResult(True, shortcut_path, start_tree + goal_tree, edges)\n\n        # No solution found; return empty path\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        while True:\n            pt = tuple(random.uniform(0, bounds[i]) for i in range(3 if is_3d else 2))\n            if not self._is_in_obstacle(pt, obstacles, is_3d): return pt\n\n    def _informed_sample(self, bounds, obstacles, is_3d, start, goal, c_max, c_min):\n        # Sample inside prolate hyperspheroid (ellipsoid) defined by start, goal, and current best cost c_max\n        # Reduces sampling space to focus search near optimal path\n        dim = 3 if is_3d else 2\n        while True:\n            # Sample unit ball point\n            if dim == 2:\n                r = random.uniform(0,1) ** 0.5\n                theta = random.uniform(0, 2*math.pi)\n                x_ball = [r * math.cos(theta), r * math.sin(theta)]\n            else:\n                # Sample from 3D ball\n                while True:\n                    x_ball = [random.uniform(-1,1), random.uniform(-1,1), random.uniform(-1,1)]\n                    if sum([xi*xi for xi in x_ball]) <= 1: break\n            # Calculate transformation parameters\n            c = c_max\n            if c == float('inf') or c <= c_min:\n                # No current solution, uniform sample\n                pt = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not self._is_in_obstacle(pt, obstacles, is_3d): return pt\n\n            center = tuple((start[i] + goal[i]) / 2 for i in range(dim))\n            dir_vec = [goal[i] - start[i] for i in range(dim)]\n            length = math.dist(start, goal)\n            # Compute rotation matrix from canonical axis to direction vector\n            if dim == 2:\n                if length == 0:\n                    R = [[1,0],[0,1]]\n                else:\n                    a1 = [1,0]\n                    a2 = [dir_vec[0]/length, dir_vec[1]/length]\n                    cos_theta = a1[0]*a2[0] + a1[1]*a2[1]\n                    sin_theta = a1[0]*a2[1] - a1[1]*a2[0]\n                    R = [[cos_theta, -sin_theta],[sin_theta, cos_theta]]\n            else:\n                # 3D rotation using axis-angle (rotation matrix)\n                from math import acos, sqrt\n                if length == 0:\n                    R = [[1,0,0],[0,1,0],[0,0,1]]\n                else:\n                    a1 = [1,0,0]\n                    a2 = [dir_vec[i]/length for i in range(3)]\n                    v = [a1[1]*a2[2]-a1[2]*a2[1], a1[2]*a2[0]-a1[0]*a2[2], a1[0]*a2[1]-a1[1]*a2[0]]\n                    s = sqrt(sum([vi*vi for vi in v]))\n                    c = sum([a1[i]*a2[i] for i in range(3)])\n                    if s == 0:\n                        R = [[1,0,0],[0,1,0],[0,0,1]]\n                    else:\n                        vx = [[0,-v[2],v[1]],[v[2],0,-v[0]],[-v[1],v[0],0]]\n                        I = [[1 if i==j else 0 for j in range(3)] for i in range(3)]\n                        vx2 = [[vx[0][0]*vx[0][0]+vx[0][1]*vx[1][0]+vx[0][2]*vx[2][0],\n                                vx[0][0]*vx[0][1]+vx[0][1]*vx[1][1]+vx[0][2]*vx[2][1],\n                                vx[0][0]*vx[0][2]+vx[0][1]*vx[1][2]+vx[0][2]*vx[2][2]],\n                               [vx[1][0]*vx[0][0]+vx[1][1]*vx[1][0]+vx[1][2]*vx[2][0],\n                                vx[1][0]*vx[0][1]+vx[1][1]*vx[1][1]+vx[1][2]*vx[2][1],\n                                vx[1][0]*vx[0][2]+vx[1][1]*vx[1][2]+vx[1][2]*vx[2][2]],\n                               [vx[2][0]*vx[0][0]+vx[2][1]*vx[1][0]+vx[2][2]*vx[2][0],\n                                vx[2][0]*vx[0][1]+vx[2][1]*vx[1][1]+vx[2][2]*vx[2][1],\n                                vx[2][0]*vx[0][2]+vx[2][1]*vx[1][2]+vx[2][2]*vx[2][2]]]\n                        R = [[I[i][j] + vx[i][j] + ((vx2[i][j]) * ((1 - c)/(s**2))) for j in range(3)] for i in range(3)]\n            # Compose scaling matrix\n            a1_val = c_max / 2.0\n            a_others = math.sqrt(c_max**2 - c_min**2) / 2.0\n            if dim == 2:\n                L = [[a1_val,0],[0,a_others]]\n                # Transform sample from unit ball: pos = R * L * x_ball + center\n                x_scaled = [L[0][0]*x_ball[0] + L[0][1]*x_ball[1], L[1][0]*x_ball[0] + L[1][1]*x_ball[1]]\n                pt = (center[0] + R[0][0]*x_scaled[0] + R[0][1]*x_scaled[1],\n                      center[1] + R[1][0]*x_scaled[0] + R[1][1]*x_scaled[1])\n            else:\n                L = [[a1_val,0,0],[0,a_others,0],[0,0,a_others]]\n                x_scaled = [L[0][0]*x_ball[0], L[1][1]*x_ball[1], L[2][2]*x_ball[2]]\n                pt = tuple(center[i] + sum(R[i][j]*x_scaled[j] for j in range(3)) for i in range(3))\n\n            # Reject points outside bounds or in obstacle\n            if any(pt[d] < 0 or pt[d] > bounds[d] for d in range(dim)):\n                continue\n            if self._is_in_obstacle(pt, obstacles, is_3d):\n                continue\n            return pt\n\n    def _nearest(self, tree, point):\n        return min(tree, key=lambda n: self._distance(n.position, point))\n\n    def _near(self, tree, point, radius):\n        radius_sq = radius * radius\n        return [node for node in tree if self._squared_distance(node.position, point) <= radius_sq]\n\n    def _steer(self, from_pos, to_pos, step_size):\n        dist = self._distance(from_pos, to_pos)\n        if dist <= step_size:\n            return to_pos\n        ratio = step_size / dist\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n    def _extract_path(self, node_start, node_goal):\n        path_start, path_goal = [], []\n        n = node_start\n        while n:\n            path_start.append(n.position)\n            n = n.parent\n        n = node_goal\n        while n:\n            path_goal.append(n.position)\n            n = n.parent\n        return list(reversed(path_start)) + path_goal\n\n    def _shortcut_path(self, path, obstacles, is_3d):\n        # Attempt to shortcut path by skipping intermediate nodes where direct edge collision free\n        if len(path) < 3:\n            return path[:]\n        shortcut_path = [path[0]]\n        i = 0\n        while i < len(path)-1:\n            j = len(path)-1\n            while j > i+1:\n                if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                    break\n                j -= 1\n            shortcut_path.append(path[j])\n            i = j\n        return shortcut_path\n\n    def _distance(self, a, b):\n        return math.dist(a, b)\n\n    def _squared_distance(self, a, b):\n        return sum((a[i] - b[i])**2 for i in range(len(a)))\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x,y,z,w,h,d = obs\n                px,py,pz = pos\n                if x<=px<=x+w and y<=py<=y+h and z<=pz<=z+d:\n                    return True\n            else:\n                x,y,w,h = obs\n                px,py = pos\n                if x<=px<=x+w and y<=py<=y+h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        dist = self._distance(from_pos, to_pos)\n        steps = max(1, int(dist/resolution))\n        for i in range(steps+1):\n            interp = tuple(from_pos[d] + (to_pos[d]-from_pos[d])*(i/steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -23.21547,
          "time_improvement": 21.0,
          "length_improvement": 16.0,
          "smoothness_improvement": 1469.0,
          "node_improvement": 68.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.025556087493896484,
                    "num_nodes_avg": 151.3,
                    "path_length_avg": 173.88763401105183,
                    "smoothness_avg": 0.047474639256938476,
                    "success_improvement": 0.0,
                    "time_improvement": 0.9101035826373128,
                    "node_improvement": 61.89876605389071,
                    "length_improvement": 4.689432372653788,
                    "smoothness_improvement": 643.0811972002915,
                    "objective_score": 6.302096484384924
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.031405282020568845,
                    "num_nodes_avg": 252.2,
                    "path_length_avg": 230.86304004149935,
                    "smoothness_avg": 0.09581397875517297,
                    "success_improvement": 0.0,
                    "time_improvement": 81.03267389975849,
                    "node_improvement": 83.05449170194181,
                    "length_improvement": 22.93127220998329,
                    "smoothness_improvement": 2365.362685390011,
                    "objective_score": 49.89537892286758
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.06047847270965576,
                    "num_nodes_avg": 317.2,
                    "path_length_avg": 119.93973012619429,
                    "smoothness_avg": 0.11787316210161418,
                    "success_improvement": 0.0,
                    "time_improvement": -19.176026584091733,
                    "node_improvement": 59.6694214876033,
                    "length_improvement": 20.341742166387515,
                    "smoothness_improvement": 1399.337921440741,
                    "objective_score": 13.448926931808694
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m2",
          "algorithm_description": "A bidirectional RRT* inspired planner with adaptive goal biasing, efficient nearest neighbor queries via dynamic grid hashing, curvature-guided cost evaluation, and iterative path improvement through constrained shortcutting. The planner grows two trees from start and goal simultaneously, leveraging curvature penalties to encourage smooth trajectories, and adapts neighbor radius dynamically by iteration count and problem dimension. It automatically updates the best path using shortcutting upon connecting the trees, balancing exploration and path quality to improve time efficiency, smoothness, and path length.",
          "planning_mechanism": "The planner alternately expands start and goal trees by sampling points biased towards the goal vicinity and around the current best solution cost, uses spatial hashing for fast near node queries, combines path length and curvature penalties in cost calculations, performs local rewiring to optimize the tree, attempts to connect the trees frequently, and shortcuts the path iteratively to remove unnecessary nodes. Early stopping occurs upon finding a valid path with stable cost within iteration limits.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n    def add_child(self, child):\n        self.children.append(child)\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\nclass Planner:\n    def __init__(self, max_iter=3000, step_size=3.2, base_radius=18.0, goal_sample_rate=0.1):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.base_radius = base_radius\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map):\n        import random\n        import math\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def in_bounds(p):\n            return all(0 <= p[i] <= bounds[i] for i in range(dim))\n\n        def collision_node(p):\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d = obs\n                    px,py,pz = p\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                        return True\n                else:\n                    x,y,w,h = obs\n                    px,py = p\n                    if x <= px <= x+w and y <= py <= y+h:\n                        return True\n            return False\n\n        def collision_edge(a,b,res=0.35):\n            length = math.dist(a,b)\n            steps = max(1,int(length/res))\n            for i in range(steps+1):\n                interp = tuple(a[d] + (b[d]-a[d])*(i/steps) for d in range(dim))\n                if collision_node(interp):\n                    return True\n            return False\n\n        def steer(from_p, to_p):\n            length = math.dist(from_p,to_p)\n            if length <= self.step_size:\n                return to_p\n            ratio = self.step_size / length\n            return tuple(from_p[i] + (to_p[i] - from_p[i]) * ratio for i in range(dim))\n\n        GRID_SIZE = self.step_size * 2.5\n        def grid_hash(p):\n            return tuple(int(coord/GRID_SIZE) for coord in p)\n\n        # spatial hash tables for start and goal trees\n        start_hash = {}\n        goal_hash = {}\n\n        def add_to_hash(hash_table, node):\n            h = grid_hash(node.position)\n            if h not in hash_table:\n                hash_table[h] = []\n            hash_table[h].append(node)\n\n        def nearby_nodes(hash_table, p, radius):\n            radius_sq = radius*radius\n            gh = grid_hash(p)\n            candidates = []\n            shifts = [-1,0,1]\n            if dim == 2:\n                neighbors = [(gh[0]+dx, gh[1]+dy) for dx in shifts for dy in shifts]\n            else:\n                neighbors = [(gh[0]+dx, gh[1]+dy, gh[2]+dz) for dx in shifts for dy in shifts for dz in shifts]\n            for cell in neighbors:\n                if cell in hash_table:\n                    for node in hash_table[cell]:\n                        sq = sum((node.position[i]-p[i])**2 for i in range(dim))\n                        if sq <= radius_sq:\n                            candidates.append(node)\n            return candidates\n\n        def nearest(hash_table, p):\n            gh = grid_hash(p)\n            min_node = None\n            min_dist = float('inf')\n            # search up to 2 grid expansions\n            for radius_cells in range(2):\n                candidates = []\n                if dim == 2:\n                    neighbors = [(gh[0]+dx, gh[1]+dy) for dx in range(-radius_cells,radius_cells+1) for dy in range(-radius_cells,radius_cells+1)]\n                else:\n                    neighbors = [(gh[0]+dx, gh[1]+dy, gh[2]+dz) for dx in range(-radius_cells,radius_cells+1) for dy in range(-radius_cells,radius_cells+1) for dz in range(-radius_cells,radius_cells+1)]\n                for cell in neighbors:\n                    if cell in hash_table:\n                        candidates.extend(hash_table[cell])\n                for node in candidates:\n                    d = math.dist(node.position,p)\n                    if d < min_dist:\n                        min_dist = d\n                        min_node = node\n                if min_node is not None:\n                    break\n            if min_node is not None:\n                return min_node\n            # fallback linear search\n            all_nodes = []\n            for cell_nodes in hash_table.values():\n                all_nodes.extend(cell_nodes)\n            if not all_nodes:\n                return None\n            return min(all_nodes, key=lambda n: math.dist(n.position,p))\n\n        def curvature_penalty(parent, child_pos):\n            if parent is None or parent.parent is None:\n                return 0.0\n            v1 = tuple(parent.position[i]-parent.parent.position[i] for i in range(dim))\n            v2 = tuple(child_pos[i]-parent.position[i] for i in range(dim))\n            len1 = math.sqrt(sum(c*c for c in v1))\n            len2 = math.sqrt(sum(c*c for c in v2))\n            if len1 < 1e-9 or len2 < 1e-9:\n                return 0.0\n            dot = sum(v1[i]*v2[i] for i in range(dim))\n            cos_ang = max(-1.0,min(1.0,dot/(len1*len2)))\n            penalty = (1.0 - cos_ang) * 0.8\n            return penalty\n\n        def path_cost(parent, child_pos):\n            linear = parent.cost + math.dist(parent.position, child_pos)\n            pen = curvature_penalty(parent, child_pos)\n            return linear + pen\n\n        def neighbor_radius(iteration, n_nodes):\n            if n_nodes < 2:\n                return self.base_radius\n            val = math.log(n_nodes) / n_nodes\n            r = self.base_radius * (val ** (1/dim))\n            return max(r, self.step_size * 1.1)\n\n        def propagate_cost(node):\n            for c in node.children:\n                new_cost = node.cost + math.dist(node.position, c.position) + curvature_penalty(node, c.position)\n                if new_cost + 1e-12 < c.cost:\n                    c.cost = new_cost\n                    propagate_cost(c)\n\n        def rewire(tree_hash, new_node, near_nodes):\n            for n in near_nodes:\n                if n is new_node.parent:\n                    continue\n                c_cost = path_cost(new_node, n.position)\n                if c_cost + 1e-8 < n.cost and not collision_edge(new_node.position, n.position):\n                    if n.parent:\n                        n.parent.remove_child(n)\n                    n.parent = new_node\n                    n.cost = c_cost\n                    new_node.add_child(n)\n                    propagate_cost(n)\n\n        def extract_path(n_start, n_goal):\n            path_start = []\n            node = n_start\n            while node:\n                path_start.append(node.position)\n                node = node.parent\n            path_start.reverse()\n\n            path_goal = []\n            node = n_goal\n            while node:\n                path_goal.append(node.position)\n                node = node.parent\n            if path_start[-1] == path_goal[0]:\n                return path_start + path_goal[1:]\n            else:\n                return path_start + path_goal\n\n        def shortcut_path(path, max_tries=100):\n            if len(path) < 3:\n                return path[:]\n            new_path = path[:]\n            for _ in range(max_tries):\n                if len(new_path) < 3:\n                    break\n                i = random.randint(0,len(new_path)-3)\n                j = random.randint(i+2,len(new_path)-1)\n                if not collision_edge(new_path[i], new_path[j]):\n                    del new_path[i+1:j]\n            return new_path\n\n        def informed_sample(iteration, best_cost):\n            if iteration % 4 and best_cost < float('inf'):\n                c_min = math.dist(start_pos, goal_pos)\n                c_best = best_cost\n                c_best = max(c_best, c_min + 1e-9)\n                center = tuple((start_pos[i]+goal_pos[i])*0.5 for i in range(dim))\n                r1 = c_best / 2\n                val = c_best**2 - c_min**2\n                r_rest = math.sqrt(val)/2 if val > 0 else 0.0\n                def unit_sphere():\n                    while True:\n                        vec = [random.gauss(0,1) for _ in range(dim)]\n                        norm = math.sqrt(sum(x*x for x in vec))\n                        if norm > 1e-9:\n                            return [x/norm for x in vec]\n                for _ in range(25):\n                    u = unit_sphere()\n                    pt = [0]*dim\n                    pt[0] = u[0]*r1\n                    for i in range(1,dim):\n                        pt[i] = u[i]*r_rest\n                    sample = tuple(center[i] + pt[i] for i in range(dim))\n                    if in_bounds(sample) and not collision_node(sample):\n                        return sample\n            # uniform or if no good best_cost\n            for _ in range(50):\n                p = tuple(random.uniform(0,bounds[i]) for i in range(dim))\n                if not collision_node(p):\n                    return p\n            # fallback uniform sample\n            return tuple(random.uniform(0,bounds[i]) for i in range(dim))\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        add_to_hash(start_hash, start_tree[0])\n        add_to_hash(goal_hash, goal_tree[0])\n\n        best_path = []\n        best_cost = float('inf')\n\n        for it in range(1, self.max_iter+1):\n            sample = informed_sample(it, best_cost)\n\n            for exp_hash, oth_hash, exp_tree, oth_tree in [\n                (start_hash, goal_hash, start_tree, goal_tree),\n                (goal_hash, start_hash, goal_tree, start_tree)]:\n\n                nearest_node = nearest(exp_hash, sample)\n                if nearest_node is None:\n                    continue\n                new_pos = steer(nearest_node.position, sample)\n                if not in_bounds(new_pos) or collision_node(new_pos) or collision_edge(nearest_node.position, new_pos):\n                    continue\n\n                radius = neighbor_radius(it, len(exp_tree))\n                near_nodes = nearby_nodes(exp_hash, new_pos, radius)\n\n                parent_node = nearest_node\n                parent_cost = path_cost(nearest_node, new_pos)\n                for n in near_nodes:\n                    if n is nearest_node:\n                        continue\n                    if collision_edge(n.position, new_pos):\n                        continue\n                    c = path_cost(n, new_pos)\n                    if c < parent_cost:\n                        parent_cost = c\n                        parent_node = n\n\n                new_node = Node(new_pos, parent_node, parent_cost)\n                parent_node.add_child(new_node)\n                exp_tree.append(new_node)\n                nodes.append(new_node)\n                add_to_hash(exp_hash, new_node)\n                rewire(exp_hash, new_node, near_nodes)\n\n                other_nearest = nearest(oth_hash, new_node.position)\n                if other_nearest and math.dist(other_nearest.position, new_node.position) <= self.step_size:\n                    if not collision_edge(other_nearest.position, new_node.position):\n                        candidate = extract_path(new_node, other_nearest)\n                        cost_path = 0\n                        for i in range(len(candidate)-1):\n                            cost_path += math.dist(candidate[i], candidate[i+1])\n                        if cost_path + 1e-9 < best_cost:\n                            best_cost = cost_path\n                            best_path = shortcut_path(candidate, max_tries=130)\n                            if best_cost < float('inf'):\n                                return PlannerResult(True, best_path, nodes, edges)\n\n        if best_path:\n            return PlannerResult(True, best_path, nodes, edges)\n        return PlannerResult(False, [], nodes, edges)",
          "objective": -23.15046,
          "time_improvement": 20.0,
          "length_improvement": 16.0,
          "smoothness_improvement": 1485.0,
          "node_improvement": 61.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.03597238063812256,
                    "num_nodes_avg": 158.4,
                    "path_length_avg": 165.33660473594648,
                    "smoothness_avg": 0.040225506903328115,
                    "success_improvement": 0.0,
                    "time_improvement": -39.477510873634735,
                    "node_improvement": 60.11080332409973,
                    "length_improvement": 9.37638701806892,
                    "smoothness_improvement": 529.6165341234281,
                    "objective_score": -3.5693383806319274
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.0495330810546875,
                    "num_nodes_avg": 425.8,
                    "path_length_avg": 233.70047331301612,
                    "smoothness_avg": 0.09995486345747011,
                    "success_improvement": 0.0,
                    "time_improvement": 70.08432847383375,
                    "node_improvement": 71.39017671168448,
                    "length_improvement": 21.984055312962646,
                    "smoothness_improvement": 2471.9106313388115,
                    "objective_score": 46.57528488662177
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.035744976997375486,
                    "num_nodes_avg": 384.8,
                    "path_length_avg": 124.71065505040485,
                    "smoothness_avg": 0.1222140100479562,
                    "success_improvement": 0.0,
                    "time_improvement": 29.562633809586238,
                    "node_improvement": 51.074380165289256,
                    "length_improvement": 17.173120998758485,
                    "smoothness_improvement": 1454.5531869101455,
                    "objective_score": 26.445428676681686
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m2",
          "algorithm_description": "An enhanced bidirectional RRT* algorithm with adaptive radius rewiring, probabilistic goal bias sampling, dynamic local rewiring for cost optimization, adaptive informed sampling to accelerate convergence, and progressive path shortcutting to improve smoothness and shorten path length. The planner grows two trees alternately, samples with goal bias and informed sampling when available, connects trees when possible, rewires nodes within a dynamic radius based on tree size and dimension for path improvement, and applies shortcutting regularly during planning to enhance path smoothness and reduce planning time.",
          "planning_mechanism": "The planner alternately expands two trees from start and goal, using a probabilistic goal bias combined with adaptive informed sampling inside an ellipsoidal subset of the search space bounded by the current best path cost to efficiently explore relevant regions. Each expansion step selects the nearest node, steers toward the sample within step size, performs collision checks, and attempts rewirings in an adaptively scaled neighborhood radius for path quality optimization. Upon connecting both trees, the path is extracted and progressively shortcut during planning iterations to smooth and shorten it, which significantly improves convergence speed, path length and smoothness, while reducing overall planning time.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n    def add_child(self, child):\n        self.children.append(child)\nclass Planner:\n    def __init__(self, max_iter=4000, step_size=6.0, radius_constant=30.0, goal_bias=0.15, shortcut_interval=40):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.radius_constant = radius_constant\n        self.goal_bias = goal_bias\n        self.shortcut_interval = shortcut_interval\n\n    def plan(self, map):\n        import random\n        import math\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = (len(bounds) == 3)\n        dim = 3 if is_3d else 2\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        best_cost = float('inf')\n        solution_start, solution_goal = None, None\n\n        c_min = math.dist(start_pos, goal_pos)\n\n        for iter in range(self.max_iter):\n            # Sample with goal bias and informed sampling if best cost known\n            if best_cost < float('inf'):\n                if random.random() < self.goal_bias:\n                    sample = goal_pos\n                else:\n                    sample = self._informed_sample(bounds, obstacles, is_3d, start_pos, goal_pos, best_cost, c_min)\n            else:\n                sample = self._sample_free(bounds, obstacles, is_3d)\n\n            # Expand both trees alternately\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest = self._nearest(tree_a, sample)\n                new_pos = self._steer(nearest.position, sample, self.step_size)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                    continue\n\n                new_node = Node(new_pos)\n                # Adaptive radius based on tree size and dimension\n                radius = min(self.radius_constant * ((math.log(len(tree_a)+1) / (len(tree_a)+1))**(1/dim)), self.step_size*30)\n\n                near_nodes = self._near(tree_a, new_pos, radius)\n\n                # Choose best parent among near nodes\n                min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n                min_parent = nearest\n                for near in near_nodes:\n                    tentative_cost = near.cost + math.dist(near.position, new_pos)\n                    if tentative_cost < min_cost and not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d):\n                        min_cost = tentative_cost\n                        min_parent = near\n\n                new_node.parent = min_parent\n                new_node.cost = min_cost\n                min_parent.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((min_parent, new_node))\n\n                # Rewire near nodes to new_node if beneficial\n                for near in near_nodes:\n                    if near is min_parent:\n                        continue\n                    new_cost = new_node.cost + math.dist(new_node.position, near.position)\n                    if new_cost < near.cost and not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                        if near.parent:\n                            try:\n                                edges.remove((near.parent, near))\n                            except ValueError:\n                                pass\n                            try:\n                                near.parent.children.remove(near)\n                            except ValueError:\n                                pass\n                        near.parent = new_node\n                        near.cost = new_cost\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n\n                # Attempt to connect trees\n                connect_node = self._nearest(tree_b, new_node.position)\n                dist_connect = math.dist(new_node.position, connect_node.position)\n                if dist_connect <= self.step_size and not self._is_edge_in_obstacle(new_node.position, connect_node.position, obstacles, is_3d):\n                    path_cost = new_node.cost + dist_connect + connect_node.cost\n                    if path_cost < best_cost:\n                        best_cost = path_cost\n                        if tree_a is start_tree:\n                            solution_start, solution_goal = new_node, connect_node\n                        else:\n                            solution_start, solution_goal = connect_node, new_node\n\n            # Progressive shortcutting applied regularly\n            if best_cost < float('inf') and solution_start and solution_goal and (iter % self.shortcut_interval == 0 or iter == self.max_iter - 1):\n                raw_path = self._extract_path(solution_start, solution_goal)\n                shortcut_path = self._shortcut_path(raw_path, obstacles, is_3d, max_attempts=60)\n                if shortcut_path:\n                    return PlannerResult(True, shortcut_path, nodes, edges)\n\n        return PlannerResult(False, [], nodes, edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        import random\n        while True:\n            pt = tuple(random.uniform(0, bounds[i]) for i in range(len(bounds)))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def _informed_sample(self, bounds, obstacles, is_3d, start, goal, c_max, c_min):\n        import random\n        import math\n        dim = 3 if is_3d else 2\n        if c_max <= c_min:\n            return self._sample_free(bounds, obstacles, is_3d)\n\n        center = tuple((start[i]+goal[i])/2 for i in range(dim))\n        dir_vec = [goal[i]-start[i] for i in range(dim)]\n        length = math.dist(start, goal)\n        if length == 0:\n            return self._sample_free(bounds, obstacles, is_3d)\n\n        if dim == 2:\n            a1 = [1,0]\n            a2 = [dir_vec[0]/length, dir_vec[1]/length]\n            cos_theta = a1[0]*a2[0] + a1[1]*a2[1]\n            sin_theta = a1[0]*a2[1] - a1[1]*a2[0]\n            R = [[cos_theta, -sin_theta],[sin_theta, cos_theta]]\n        else:\n            from math import sqrt\n            a1 = [1,0,0]\n            a2 = [dir_vec[i]/length for i in range(3)]\n            v = [a1[1]*a2[2]-a1[2]*a2[1], a1[2]*a2[0]-a1[0]*a2[2], a1[0]*a2[1]-a1[1]*a2[0]]\n            s = sqrt(sum([vi*vi for vi in v]))\n            c = sum([a1[i]*a2[i] for i in range(3)])\n            if s == 0:\n                R = [[1,0,0],[0,1,0],[0,0,1]]\n            else:\n                vx = [[0,-v[2],v[1]],[v[2],0,-v[0]],[-v[1],v[0],0]]\n                I = [[1 if i==j else 0 for j in range(3)] for i in range(3)]\n                vx2 = [[sum(vx[i][k]*vx[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n                R = [[I[i][j] + vx[i][j] + vx2[i][j]*((1 - c)/(s**2)) for j in range(3)] for i in range(3)]\n\n        if dim == 2:\n            r = random.uniform(0,1)**0.5\n            theta = random.uniform(0, 2*math.pi)\n            x_ball = [r*math.cos(theta), r*math.sin(theta)]\n        else:\n            while True:\n                x_ball = [random.uniform(-1,1) for _ in range(3)]\n                if sum(xi*xi for xi in x_ball) <= 1:\n                    break\n\n        a1_val = c_max / 2.0\n        a_other = math.sqrt(c_max**2 - c_min**2) / 2.0\n\n        if dim == 2:\n            L = [[a1_val, 0],[0, a_other]]\n            x_scaled = [L[0][0]*x_ball[0] + L[0][1]*x_ball[1],\n                        L[1][0]*x_ball[0] + L[1][1]*x_ball[1]]\n            pt = (center[0] + R[0][0]*x_scaled[0] + R[0][1]*x_scaled[1],\n                  center[1] + R[1][0]*x_scaled[0] + R[1][1]*x_scaled[1])\n        else:\n            L = [[a1_val, 0, 0],[0, a_other, 0],[0, 0, a_other]]\n            x_scaled = [L[0][0]*x_ball[0], L[1][1]*x_ball[1], L[2][2]*x_ball[2]]\n            pt = tuple(center[i] + sum(R[i][j]*x_scaled[j] for j in range(3)) for i in range(3))\n\n        if any(pt[d] < 0 or pt[d] > bounds[d] for d in range(dim)):\n            return self._sample_free(bounds, obstacles, is_3d)\n        if self._is_in_obstacle(pt, obstacles, is_3d):\n            return self._sample_free(bounds, obstacles, is_3d)\n\n        return pt\n\n    def _nearest(self, tree, point):\n        import math\n        return min(tree, key=lambda n: math.dist(n.position, point))\n\n    def _near(self, tree, point, radius):\n        r_sq = radius*radius\n        return [n for n in tree if sum((n.position[i]-point[i])**2 for i in range(len(point))) <= r_sq]\n\n    def _steer(self, from_pos, to_pos, step_size):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        if dist <= step_size:\n            return to_pos\n        ratio = step_size / dist\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i])*ratio for i in range(len(from_pos)))\n\n    def _extract_path(self, node_start, node_goal):\n        path_start, path_goal = [], []\n        n = node_start\n        while n:\n            path_start.append(n.position)\n            n = n.parent\n        n = node_goal\n        while n:\n            path_goal.append(n.position)\n            n = n.parent\n        return list(reversed(path_start)) + path_goal\n\n    def _shortcut_path(self, path, obstacles, is_3d, max_attempts=60):\n        if len(path) < 3:\n            return path[:]\n        import random\n        new_path = path[:]\n        attempts = 0\n        while attempts < max_attempts:\n            if len(new_path) < 3:\n                break\n            i = random.randint(0, len(new_path)-3)\n            j = random.randint(i+2, len(new_path)-1)\n            if not self._is_edge_in_obstacle(new_path[i], new_path[j], obstacles, is_3d):\n                new_path = new_path[:i+1] + new_path[j:]\n                attempts = 0\n            else:\n                attempts += 1\n        return new_path\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x,y,z,w,h,d = obs\n                px,py,pz = pos\n                if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                    return True\n            else:\n                x,y,w,h = obs\n                px,py = pos\n                if x <= px <= x+w and y <= py <= y+h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist/resolution))\n        for i in range(steps+1):\n            interp = tuple(from_pos[d] + (to_pos[d]-from_pos[d])*(i/steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -22.60434,
          "time_improvement": 28.0,
          "length_improvement": 11.0,
          "smoothness_improvement": 1504.0,
          "node_improvement": 68.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.021024632453918456,
                    "num_nodes_avg": 149.4,
                    "path_length_avg": 179.86562069368742,
                    "smoothness_avg": 0.04340391432894737,
                    "success_improvement": 0.0,
                    "time_improvement": 18.480140883479937,
                    "node_improvement": 62.37723495341224,
                    "length_improvement": 1.41280314464036,
                    "smoothness_improvement": 579.365512356565,
                    "objective_score": 9.288551713611021
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.02810840606689453,
                    "num_nodes_avg": 272.4,
                    "path_length_avg": 245.75216437677005,
                    "smoothness_avg": 0.0991357257905606,
                    "success_improvement": 0.0,
                    "time_improvement": 83.02383326220045,
                    "node_improvement": 81.69723845998791,
                    "length_improvement": 17.960853947188074,
                    "smoothness_improvement": 2450.8336291682162,
                    "objective_score": 47.93783049281406
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.0594691276550293,
                    "num_nodes_avg": 313.1,
                    "path_length_avg": 129.64938979692397,
                    "smoothness_avg": 0.1243235500601021,
                    "success_improvement": 0.0,
                    "time_improvement": -17.187058813027633,
                    "node_improvement": 60.19071837253656,
                    "length_improvement": 13.893048537397146,
                    "smoothness_improvement": 1481.3863801545947,
                    "objective_score": 10.586643379302972
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "initial",
          "algorithm_description": "This algorithm enhances the standard BI-RRT by incorporating an optimization step that rewires nearby nodes to minimize cost, resulting in asymptotically optimal paths. It grows two trees\u2014one from the start and one from the goal\u2014and attempts to connect them while optimizing the path cost dynamically.",
          "planning_mechanism": "The planning mechanism includes sampling a random point, extending each tree toward it, rewiring neighbors within a radius to optimize the cost, and attempting to connect the two trees. When a connection is established, the combined path is extracted from both trees. Node validity and edge collision checks are strictly enforced throughout the process.",
          "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost: float = 0.0):\n        self.position = position              # Tuple[float, ...]\n        self.parent: Optional[\"Node\"] = parent\n        self.cost: float = cost\n        self.children: List[\"Node\"] = []\n        self.valid = True\n\n    def add_child(self, child_node: \"Node\"):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n\nclass Planner:\n    def __init__(\n        self,\n        max_iter: int = 5000,\n        step_size: float = 5.0,\n        gamma_rrt_star: float = 50.0,\n        max_radius: float = 60.0,\n    ):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.gamma_rrt_star = gamma_rrt_star\n        self.max_radius = max_radius\n\n    # ======================= Public API =======================\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        start_root = Node(start_position, parent=None, cost=0.0)\n        goal_root  = Node(goal_position,  parent=None, cost=0.0)\n        nodes.extend([start_root, goal_root])\n\n        tree_a: List[Node] = [start_root]\n        tree_b: List[Node] = [goal_root]\n\n        for _ in range(self.max_iter):\n            rand_point = self._sample_free(bounds, obstacles, is_3d)\n\n            new_a = self._extend_and_rewire(tree_a, rand_point, obstacles, is_3d, nodes, edges, bounds)\n            if new_a is None:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            new_b = self._connect_and_rewire(tree_b, new_a, obstacles, is_3d, nodes, edges, bounds)\n            if new_b:\n                success_state = True\n                path_a = new_a.path_from_root()\n                path_b = new_b.path_from_root()\n                if path_a and path_b and path_a[-1] == path_b[-1]:\n                    path_b = path_b[:-1]\n                extracted_path = path_a + path_b[::-1]\n                break\n\n            tree_a, tree_b = tree_b, tree_a\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        while True:\n            p = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    def _nearest(self, tree: List[Node], point):\n        return min(tree, key=lambda node: math.dist(node.position, point))\n\n    def _steer(self, from_pos, to_pos):\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _near_nodes(self, tree: List[Node], position, bounds) -> List[Node]:\n        n = max(1, len(tree))\n        d = len(position)\n        # \uacf5\uac04 \uc2a4\ucf00\uc77c\uc744 \uac04\ub2e8\ud788 bounds\ub85c \ucd94\uc815 (\uc815\ubc00 X, \uc2e4\uc6a9\uc801)\n        scale = max(1.0, sum(bounds) / d)\n        r_theory = self.gamma_rrt_star * ((math.log(n + 1) / (n + 1)) ** (1.0 / d))\n        radius = max(self.step_size * 2.0, min(self.max_radius, r_theory * 0.5 + scale * 0.02))\n        return [node for node in tree if math.dist(node.position, position) <= radius]\n\n    def _choose_parent_and_add(self, tree, new_pos, obstacles, is_3d, nodes, edges, bounds):\n        nearest = self._nearest(tree, new_pos)\n        neighbors = self._near_nodes(tree, new_pos, bounds)\n\n        min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n        best_parent = nearest\n\n        for nb in neighbors:\n            if not self._is_edge_in_obstacle(nb.position, new_pos, obstacles, is_3d):\n                cand = nb.cost + math.dist(nb.position, new_pos)\n                if cand < min_cost:\n                    min_cost = cand\n                    best_parent = nb\n\n        new_node = Node(new_pos, parent=None, cost=min_cost)\n        best_parent.add_child(new_node)\n        tree.append(new_node)\n        nodes.append(new_node)\n        edges.append((best_parent, new_node))\n        return new_node, neighbors\n\n    def _rewire_from(self, pivot: Node, neighbors: List[Node], obstacles, is_3d, edges):\n        for nb in neighbors:\n            if not self._is_edge_in_obstacle(pivot.position, nb.position, obstacles, is_3d):\n                new_cost = pivot.cost + math.dist(pivot.position, nb.position)\n                if new_cost + 1e-12 < nb.cost:  # \uc791\uc740 \uc218\uce58 \ubc84\ud37c\n                    if nb.parent is not None:\n                        try:\n                            edges.remove((nb.parent, nb))\n                        except ValueError:\n                            pass\n                        if nb in nb.parent.children:\n                            nb.parent.children.remove(nb)\n                    pivot.add_child(nb)\n                    nb.cost = new_cost\n                    edges.append((pivot, nb))\n\n    def _extend_and_rewire(self, tree, sample_point, obstacles, is_3d, nodes, edges, bounds):\n        nearest = self._nearest(tree, sample_point)\n        new_pos = self._steer(nearest.position, sample_point)\n\n        if self._is_in_obstacle(new_pos, obstacles, is_3d):\n            return None\n        if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n            return None\n\n        new_node, neighbors = self._choose_parent_and_add(tree, new_pos, obstacles, is_3d, nodes, edges, bounds)\n        self._rewire_from(new_node, neighbors, obstacles, is_3d, edges)\n        return new_node\n\n    def _connect_and_rewire(self, tree, target_node: Node, obstacles, is_3d, nodes, edges, bounds):\n        nearest = self._nearest(tree, target_node.position)\n\n        while True:\n            new_pos = self._steer(nearest.position, target_node.position)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                return None\n\n            connect_node, neighbors = self._choose_parent_and_add(tree, new_pos, obstacles, is_3d, nodes, edges, bounds)\n            self._rewire_from(connect_node, neighbors, obstacles, is_3d, edges)\n\n            if math.dist(connect_node.position, target_node.position) <= self.step_size:\n                if (not self._is_edge_in_obstacle(connect_node.position, target_node.position, obstacles, is_3d) and\n                    not self._is_in_obstacle(target_node.position, obstacles, is_3d)):\n                    final_node = Node(target_node.position, parent=None, cost=connect_node.cost + math.dist(connect_node.position, target_node.position))\n                    connect_node.add_child(final_node)\n                    tree.append(final_node)\n                    nodes.append(final_node)\n                    edges.append((connect_node, final_node))\n                    return final_node\n                else:\n                    return None\n\n            nearest = connect_node\n\n        \n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n        \n        \n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n",
          "objective": -18.483327093247905,
          "time_improvement": 35.0,
          "length_improvement": 12.0,
          "smoothness_improvement": 180.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.022586989402770995,
                    "num_nodes_avg": 95.7,
                    "path_length_avg": 168.64313046948791,
                    "smoothness_avg": 0.017505839022252202,
                    "success_improvement": 0.0,
                    "time_improvement": 12.422336132822434,
                    "node_improvement": 75.90027700831025,
                    "length_improvement": 7.564027868261686,
                    "smoothness_improvement": 174.00439523612755,
                    "objective_score": 9.13513953698438
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.03670787811279297,
                    "num_nodes_avg": 248.8,
                    "path_length_avg": 257.74323422045836,
                    "smoothness_avg": 0.010534876218801273,
                    "success_improvement": 0.0,
                    "time_improvement": 77.83015308834821,
                    "node_improvement": 83.2829402674192,
                    "length_improvement": 13.957889689556485,
                    "smoothness_improvement": 171.06995307438933,
                    "objective_score": 32.5791295056103
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.04266858100891113,
                    "num_nodes_avg": 241.6,
                    "path_length_avg": 130.54377171187787,
                    "smoothness_avg": 0.023278354893991073,
                    "success_improvement": 0.0,
                    "time_improvement": 15.919306212711263,
                    "node_improvement": 69.28162746344564,
                    "length_improvement": 13.299042655374924,
                    "smoothness_improvement": 196.09895602214036,
                    "objective_score": 13.735712237149036
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "initial",
          "algorithm_description": "This algorithm is a dual-tree variant of Rapidly-exploring Random Tree (RRT) that grows two trees from the start and goal positions, attempting to connect them as they expand. It is efficient for single-query problems due to its bidirectional search and reduced redundant exploration.",
          "planning_mechanism": "The planner alternates between growing the start and goal trees by extending towards randomly sampled points. Each extension step involves checking for collision-free motion and attempting to connect the two trees. The algorithm terminates when a valid path is formed connecting the trees.",
          "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n        nodes = []\n        edges = []\n        success_state = False\n        extracted_path = []\n\n        for iter in range(self.max_iter):\n            rand = self._sample_free(bounds, obstacles, is_3d)\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest = self._nearest(tree_a, rand)\n                new_pos = self._steer(nearest.position, rand, self.step_size)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                    continue\n                new_node = Node(new_pos, parent=nearest, cost=nearest.cost + self._distance(nearest.position, new_pos))\n                nearest.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((nearest, new_node))\n\n                connect_node = self._nearest(tree_b, new_pos)\n                if self._connect_trees(new_node, connect_node, obstacles, is_3d, tree_b, nodes, edges):\n                    success_state = True\n                    extracted_path = self._extract_path(new_node, connect_node)\n                    return PlannerResult(True, extracted_path, start_tree + goal_tree, edges)\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        while True:\n            if is_3d:\n                point = tuple(random.uniform(0, bounds[i]) for i in range(3))\n            else:\n                point = tuple(random.uniform(0, bounds[i]) for i in range(2))\n            if not self._is_in_obstacle(point, obstacles, is_3d):\n                return point\n\n    def _nearest(self, tree, point):\n        return min(tree, key=lambda node: self._distance(node.position, point))\n\n    def _steer(self, from_pos, to_pos, step_size):\n        dist = self._distance(from_pos, to_pos)\n        if dist <= step_size:\n            return to_pos\n        ratio = step_size / dist\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n    def _connect_trees(self, node_a, node_b, obstacles, is_3d, tree, nodes, edges):\n        from_pos = node_a.position\n        to_pos = node_b.position\n        if self._is_edge_in_obstacle(from_pos, to_pos, obstacles, is_3d):\n            return False\n        curr = node_b\n        path = []\n        while True:\n            new_pos = self._steer(curr.position, from_pos, self.step_size)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return False\n            if self._is_edge_in_obstacle(curr.position, new_pos, obstacles, is_3d):\n                return False\n            new_node = Node(new_pos, parent=curr, cost=curr.cost + self._distance(curr.position, new_pos))\n            curr.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((curr, new_node))\n            if self._distance(new_pos, from_pos) < self.step_size:\n                new_node_final = Node(from_pos, parent=new_node, cost=new_node.cost + self._distance(new_pos, from_pos))\n                new_node.add_child(new_node_final)\n                tree.append(new_node_final)\n                nodes.append(new_node_final)\n                edges.append((new_node, new_node_final))\n                return True\n            curr = new_node\n\n    def _extract_path(self, node_a, node_b):\n        path_a = []\n        while node_a:\n            path_a.append(node_a.position)\n            node_a = node_a.parent\n        path_b = []\n        while node_b:\n            path_b.append(node_b.position)\n            node_b = node_b.parent\n        return list(reversed(path_a)) + path_b\n\n    def _distance(self, a, b):\n        return math.dist(a, b)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = self._distance(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n    ",
          "objective": -17.795854854811235,
          "time_improvement": 71.0,
          "length_improvement": -6.0,
          "smoothness_improvement": 75.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.015041923522949219,
                    "num_nodes_avg": 140.4,
                    "path_length_avg": 205.55369204774252,
                    "smoothness_avg": 0.01041684624247792,
                    "success_improvement": 0.0,
                    "time_improvement": 41.67719749109079,
                    "node_improvement": 64.64366658272476,
                    "length_improvement": -12.667235818056396,
                    "smoothness_improvement": 63.046264238449346,
                    "objective_score": 5.218049077685646
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.016628527641296388,
                    "num_nodes_avg": 235.2,
                    "path_length_avg": 305.1784824883373,
                    "smoothness_avg": 0.00711472502770238,
                    "success_improvement": 0.0,
                    "time_improvement": 89.95714459329555,
                    "node_improvement": 84.19673452932877,
                    "length_improvement": -1.8773615301791229,
                    "smoothness_improvement": 83.06699949208468,
                    "objective_score": 26.276061457341616
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.010075998306274415,
                    "num_nodes_avg": 181.0,
                    "path_length_avg": 156.9681958591822,
                    "smoothness_avg": 0.014159220130581652,
                    "success_improvement": 0.0,
                    "time_improvement": 80.14471285055937,
                    "node_improvement": 76.98664971392245,
                    "length_improvement": -4.250801667402978,
                    "smoothness_improvement": 80.10423493608366,
                    "objective_score": 21.89345402940644
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "A streamlined bidirectional RRT* planner featuring adaptive informed sampling within ellipsoidal subsets, efficient rewiring with a dynamic neighborhood radius based on node count, and incremental path shortcutting to progressively improve path length and smoothness while minimizing planning time. The planner grows two trees from start and goal positions, alternately extending toward samples constrained by the current best solution\u2019s cost, rewiring locally for cost improvement, and shortcutting the combined path periodically to ensure continuously refined solutions.",
          "planning_mechanism": "The planner alternates expansion between start and goal trees by steering nearest nodes toward informed samples inside the current ellipsoidal region defined by the best path cost; it dynamically adapts the rewiring radius as node count grows to optimize connectivity and prune costs locally. Upon connecting the two trees with a better path, it incrementally shortcut the path at regular intervals for smoother trajectories, returning the best feasible path when finished or timeout occurs.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n    def add_child(self, child):\n        self.children.append(child)\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except ValueError:\n            pass\nclass Planner:\n    def __init__(self, max_iter=4000, step_size=6.0, gamma=50.0, shortcut_interval=40, max_shortcut_attempts=30):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.gamma = gamma\n        self.shortcut_interval = shortcut_interval\n        self.max_shortcut_attempts = max_shortcut_attempts\n\n    def plan(self, map):\n        import random\n        import math\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        c_min = math.dist(start_pos, goal_pos)\n        best_cost = float('inf')\n        solution_start = None\n        solution_goal = None\n\n        def near_radius(n):\n            if n <= 1:\n                return self.step_size * 2.5\n            return min(self.step_size*50, self.gamma * (math.log(n) / n) ** (1.0 / dim))\n\n        def sample_free():\n            while True:\n                pt = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not self._is_in_obstacle(pt, obstacles, is_3d):\n                    return pt\n\n        def informed_sample():\n            if best_cost == float('inf') or best_cost <= c_min:\n                return sample_free()\n\n            center = tuple((start_pos[i] + goal_pos[i]) * 0.5 for i in range(dim))\n            dir_vec = [goal_pos[i] - start_pos[i] for i in range(dim)]\n            length = math.dist(start_pos, goal_pos)\n            if length < 1e-10:\n                R = [[1 if i == j else 0 for j in range(dim)] for i in range(dim)]\n            else:\n                # Compute rotation matrix from first axis to dir_vec\n                if dim == 2:\n                    cos_theta = dir_vec[0]/length\n                    sin_theta = dir_vec[1]/length\n                    R = [[cos_theta, -sin_theta],\n                         [sin_theta, cos_theta]]\n                else:\n                    from math import sqrt\n                    a1 = [1,0,0]\n                    a2 = [dir_vec[i]/length for i in range(3)]\n                    v = [a1[1]*a2[2]-a1[2]*a2[1], a1[2]*a2[0]-a1[0]*a2[2], a1[0]*a2[1]-a1[1]*a2[0]]\n                    s = sqrt(sum(vi*vi for vi in v))\n                    c = sum(a1[i]*a2[i] for i in range(3))\n                    if s < 1e-10:\n                        R = [[1,0,0],[0,1,0],[0,0,1]]\n                    else:\n                        vx = [[ 0, -v[2], v[1]],\n                              [v[2], 0, -v[0]],\n                              [-v[1], v[0], 0]]\n                        I = [[1 if i==j else 0 for j in range(3)] for i in range(3)]\n                        vx2 = [[sum(vx[i][k]*vx[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n                        R = [[I[i][j] + vx[i][j] + vx2[i][j]*((1 - c)/(s**2)) for j in range(3)] for i in range(3)]\n\n            a1 = best_cost * 0.5\n            a2 = math.sqrt(best_cost**2 - c_min**2) * 0.5\n\n            while True:\n                if dim == 2:\n                    r = random.uniform(0,1)**0.5\n                    theta = random.uniform(0, 2*math.pi)\n                    x_ball = [r*math.cos(theta), r*math.sin(theta)]\n                    L = [[a1, 0], [0, a2]]\n                    x_scaled = [L[0][0]*x_ball[0], L[1][1]*x_ball[1]]\n                    pt = (center[0] + R[0][0]*x_scaled[0] + R[0][1]*x_scaled[1],\n                          center[1] + R[1][0]*x_scaled[0] + R[1][1]*x_scaled[1])\n                else:\n                    while True:\n                        x_ball = [random.uniform(-1,1) for _ in range(3)]\n                        if sum(xi*xi for xi in x_ball) <= 1:\n                            break\n                    L = [[a1,0,0],[0,a2,0],[0,0,a2]]\n                    x_scaled = [L[i][i]*x_ball[i] for i in range(3)]\n                    pt = tuple(center[i] + sum(R[i][j]*x_scaled[j] for j in range(dim)) for i in range(dim))\n\n                if any(pt[d] < 0 or pt[d] > bounds[d] for d in range(dim)):\n                    continue\n                if self._is_in_obstacle(pt, obstacles, is_3d):\n                    continue\n                return pt\n\n        def steer(from_p, to_p):\n            dist = math.dist(from_p, to_p)\n            if dist <= self.step_size:\n                return to_p\n            ratio = self.step_size / dist\n            return tuple(from_p[i] + (to_p[i] - from_p[i])*ratio for i in range(dim))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: sum((n.position[i]-point[i])**2 for i in range(dim)))\n\n        def near(tree, point, radius):\n            r_sq = radius*radius\n            return [n for n in tree if sum((n.position[i]-point[i])**2 for i in range(dim)) <= r_sq]\n\n        def is_edge_free(p1, p2):\n            dist = math.dist(p1, p2)\n            steps = max(1, int(dist))\n            for step in range(steps+1):\n                inter = tuple(p1[i] + (p2[i]-p1[i]) * (step/steps) for i in range(dim))\n                if self._is_in_obstacle(inter, obstacles, is_3d):\n                    return False\n            return True\n\n        def progressive_shortcut(path):\n            if len(path) < 3:\n                return path[:]\n            new_path = path[:]\n            attempts = 0\n            while attempts < self.max_shortcut_attempts:\n                if len(new_path) < 3:\n                    break\n                i = random.randint(0, len(new_path)-3)\n                j = random.randint(i+2, len(new_path)-1)\n                if is_edge_free(new_path[i], new_path[j]):\n                    new_path = new_path[:i+1] + new_path[j:]\n                    attempts = 0\n                else:\n                    attempts += 1\n            return new_path\n\n        def extract_path(node_a, node_b):\n            path_a, path_b = [], []\n            n = node_a\n            while n:\n                path_a.append(n.position)\n                n = n.parent\n            n = node_b\n            while n:\n                path_b.append(n.position)\n                n = n.parent\n            return list(reversed(path_a)) + path_b\n\n        for it in range(self.max_iter):\n            p_sample = informed_sample() if best_cost < float('inf') else sample_free()\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest_node = nearest(tree_a, p_sample)\n                new_pos = steer(nearest_node.position, p_sample)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if not is_edge_free(nearest_node.position, new_pos):\n                    continue\n                new_node = Node(new_pos)\n                radius = near_radius(len(tree_a))\n                near_nodes = near(tree_a, new_pos, radius)\n\n                min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n                min_parent = nearest_node\n                for near_node in near_nodes:\n                    cost_to_new = near_node.cost + math.dist(near_node.position, new_pos)\n                    if cost_to_new < min_cost and is_edge_free(near_node.position, new_pos):\n                        min_cost = cost_to_new\n                        min_parent = near_node\n                new_node.parent = min_parent\n                new_node.cost = min_cost\n                min_parent.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((min_parent, new_node))\n\n                for near_node in near_nodes:\n                    if near_node is min_parent:\n                        continue\n                    new_cost = new_node.cost + math.dist(new_node.position, near_node.position)\n                    if new_cost < near_node.cost and is_edge_free(new_node.position, near_node.position):\n                        if near_node.parent:\n                            try:\n                                edges.remove((near_node.parent, near_node))\n                            except ValueError:\n                                pass\n                            near_node.parent.remove_child(near_node)\n                        near_node.parent = new_node\n                        near_node.cost = new_cost\n                        new_node.add_child(near_node)\n                        edges.append((new_node, near_node))\n\n                connect_node = nearest(tree_b, new_node.position)\n                dist_connect = math.dist(new_node.position, connect_node.position)\n                if dist_connect <= self.step_size and is_edge_free(new_node.position, connect_node.position):\n                    total_cost = new_node.cost + dist_connect + connect_node.cost\n                    if total_cost < best_cost:\n                        best_cost = total_cost\n                        if tree_a is start_tree:\n                            solution_start, solution_goal = new_node, connect_node\n                        else:\n                            solution_start, solution_goal = connect_node, new_node\n\n            if best_cost < float('inf') and solution_start and solution_goal:\n                if it % self.shortcut_interval == 0 or it == self.max_iter-1:\n                    raw_path = extract_path(solution_start, solution_goal)\n                    smooth_path = progressive_shortcut(raw_path)\n                    if smooth_path and len(smooth_path) >= 2:\n                        return PlannerResult(True, smooth_path, nodes, edges)\n\n        return PlannerResult(False, [], nodes, edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x,y,z,w,h,d = obs\n                px,py,pz = pos\n                if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                    return True\n            else:\n                x,y,w,h = obs\n                px,py = pos\n                if x <= px <= x+w and y <= py <= y+h:\n                    return True\n        return False",
          "objective": -14.92668,
          "time_improvement": -4.0,
          "length_improvement": 16.0,
          "smoothness_improvement": 1314.0,
          "node_improvement": 67.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.037845396995544435,
                    "num_nodes_avg": 178.0,
                    "path_length_avg": 165.42944166192004,
                    "smoothness_avg": 0.03843563195093346,
                    "success_improvement": 0.0,
                    "time_improvement": -46.739850889072756,
                    "node_improvement": 55.175018886930246,
                    "length_improvement": 9.325501627847583,
                    "smoothness_improvement": 501.60110434278266,
                    "objective_score": -5.918648768299365
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.052951812744140625,
                    "num_nodes_avg": 269.6,
                    "path_length_avg": 234.10634420651417,
                    "smoothness_avg": 0.08692195248727295,
                    "success_improvement": 0.0,
                    "time_improvement": 68.01957392838445,
                    "node_improvement": 81.88537257273398,
                    "length_improvement": 21.84856392636707,
                    "smoothness_improvement": 2136.5644448493013,
                    "objective_score": 44.19783275858208
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.06805832386016845,
                    "num_nodes_avg": 273.6,
                    "path_length_avg": 124.92852901095083,
                    "smoothness_avg": 0.11033978563707739,
                    "success_improvement": 0.0,
                    "time_improvement": -34.11252384905549,
                    "node_improvement": 65.21296884933248,
                    "length_improvement": 17.02841948820697,
                    "smoothness_improvement": 1303.5139288678422,
                    "objective_score": 6.500864182546746
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m1",
          "algorithm_description": "A novel bidirectional RRT* variant with adaptive informed sampling based on current best path cost combined with a heuristic-driven prioritized rewiring scheme. Instead of uniform or vanilla informed sampling, the algorithm dynamically shrinks its sampling ellipsoid region as solutions improve for faster convergence. The rewiring phase favors nodes estimated closer to the goal using a heuristic distance, guiding tree restructuring to yield shorter, smoother paths. Post-processing employs an iterative shortcutting approach that refines path smoothness while preserving collision-free guarantees. This approach balances global exploration and local optimization to enhance planning efficiency, path length, and smoothness while reducing runtime.",
          "planning_mechanism": "The planner grows two bidirectional trees from start and goal, sampling adaptive informed points inside a shrinking ellipsoid focused by the best path cost. It extends and rewires nodes by prioritizing neighbors nearer the goal heuristic, striving for low-cost rewiring. Trees attempt to connect continuously, updating best solutions. Upon finishing, the path undergoes iterative shortcut smoothing to remove unnecessary waypoints. This coordinated mechanism improves convergence speed, reduces excessive edge checks, and enhances solution quality.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n    def add_child(self, child):\n        self.children.append(child)\nclass Planner:\n    def __init__(self, max_iter=4000, step_size=6.0, max_radius=20.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.max_radius = max_radius\n\n    def plan(self, map):\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        c_min = math.dist(start_pos, goal_pos)\n        best_cost = float('inf')\n        solution_nodes = (None, None)\n\n        # Precompute dimension for convenience\n        dim = 3 if is_3d else 2\n\n        def heuristic_to_goal(p):\n            return math.dist(p, goal_pos)\n\n        def heuristic_to_start(p):\n            return math.dist(p, start_pos)\n\n        for iter in range(self.max_iter):\n            # Adaptive informed sampling inside ellipsoid shrinking as best_cost improves\n            sample = self._adaptive_informed_sample(bounds, obstacles, is_3d, start_pos, goal_pos, best_cost, c_min)\n            \n            # Alternate tree roles each iteration\n            if iter % 2 == 0:\n                tree_a, tree_b = start_tree, goal_tree\n                heuristic_a, heuristic_b = heuristic_to_goal, heuristic_to_start\n            else:\n                tree_a, tree_b = goal_tree, start_tree\n                heuristic_a, heuristic_b = heuristic_to_start, heuristic_to_goal\n            \n            nearest = self._nearest(tree_a, sample)\n            new_pos = self._steer(nearest.position, sample)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d): continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d): continue\n            \n            near_nodes = self._near(tree_a, new_pos, self.max_radius)\n            # Prioritize near nodes by heuristic to goal (or start)\n            near_nodes.sort(key=lambda n: heuristic_a(n.position))\n            \n            # Choose best parent based on cost + heuristic + collision free\n            min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n            best_parent = nearest\n            for nnode in near_nodes:\n                if nnode is nearest:\n                    continue\n                tentative_cost = nnode.cost + math.dist(nnode.position, new_pos)\n                if tentative_cost + heuristic_a(new_pos) >= min_cost + heuristic_a(new_pos):\n                    # Prune candidates that are not better in cost + heuristic\n                    continue\n                if self._is_edge_in_obstacle(nnode.position, new_pos, obstacles, is_3d):\n                    continue\n                min_cost = tentative_cost\n                best_parent = nnode\n            \n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n            \n            # Rewire neighbors that improve cost with heuristic guidance\n            for neighbor in near_nodes:\n                if neighbor is best_parent or neighbor is new_node:\n                    continue\n                new_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n                # Only rewire if new cost + heuristic less than existing\n                if new_cost + heuristic_a(neighbor.position) + 1e-8 < neighbor.cost + heuristic_a(neighbor.position):\n                    if self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        continue\n                    if neighbor.parent:\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        if neighbor in neighbor.parent.children:\n                            neighbor.parent.children.remove(neighbor)\n                    neighbor.parent = new_node\n                    neighbor.cost = new_cost\n                    new_node.add_child(neighbor)\n                    edges.append((new_node, neighbor))\n            \n            # Try connection to other tree within step size and free space\n            conn_node = self._nearest(tree_b, new_node.position)\n            dist_conn = math.dist(new_node.position, conn_node.position)\n            if dist_conn <= self.step_size:\n                if not self._is_edge_in_obstacle(new_node.position, conn_node.position, obstacles, is_3d):\n                    path_cost = new_node.cost + dist_conn + conn_node.cost\n                    if path_cost < best_cost:\n                        best_cost = path_cost\n                        if iter % 2 == 0:\n                            solution_nodes = (new_node, conn_node)\n                        else:\n                            solution_nodes = (conn_node, new_node)\n            \n            # Periodically extract and iteratively shortcut path for smoothness improvement\n            if solution_nodes[0] and solution_nodes[1] and (iter % 150 == 0 or iter == self.max_iter - 1):\n                raw_path = self._extract_path(solution_nodes[0], solution_nodes[1])\n                shortcut_path = self._iterative_shortcut(raw_path, obstacles, is_3d)\n                if shortcut_path:\n                    return PlannerResult(True, shortcut_path, nodes, edges)\n\n        # Final check after iterations\n        if solution_nodes[0] and solution_nodes[1]:\n            raw_path = self._extract_path(solution_nodes[0], solution_nodes[1])\n            shortcut_path = self._iterative_shortcut(raw_path, obstacles, is_3d)\n            return PlannerResult(True, shortcut_path, nodes, edges)\n        else:\n            return PlannerResult(False, [], nodes, edges)\n\n    def _adaptive_informed_sample(self, bounds, obstacles, is_3d, start, goal, c_max, c_min):\n        dim = 3 if is_3d else 2\n        if c_max == float('inf') or c_max <= c_min:\n            # Uniform random sampling if no valid path found yet\n            while True:\n                pt = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not self._is_in_obstacle(pt, obstacles, is_3d):\n                    return pt\n\n        c_max = min(c_max, sum(bounds)*10)  # Clamp c_max to reasonable upper bound\n        center = tuple((start[i] + goal[i]) / 2 for i in range(dim))\n        dir_vec = [goal[i] - start[i] for i in range(dim)]\n        length = math.dist(start, goal)\n        if length == 0:\n            # Degenerate case\n            return start\n\n        # Rotation matrix to align x-axis to direction vector (2D or 3D)\n        if dim == 2:\n            a1 = [1, 0]\n            a2 = [dir_vec[0]/length, dir_vec[1]/length]\n            cos_theta = a1[0]*a2[0] + a1[1]*a2[1]\n            sin_theta = a1[0]*a2[1] - a1[1]*a2[0]\n            R = [[cos_theta, -sin_theta],[sin_theta, cos_theta]]\n        else:\n            # 3D rotation matrix from x-axis to dir_vec using Rodrigues formula\n            a1 = [1, 0, 0]\n            a2 = [dir_vec[i]/length for i in range(3)]\n            v = [a1[1]*a2[2] - a1[2]*a2[1],\n                 a1[2]*a2[0] - a1[0]*a2[2],\n                 a1[0]*a2[1] - a1[1]*a2[0]]\n            s = math.sqrt(sum(vi*vi for vi in v))\n            c = sum(a1[i]*a2[i] for i in range(3))\n            if s == 0:\n                R = [[1,0,0],[0,1,0],[0,0,1]]\n            else:\n                vx = [[0, -v[2], v[1]],\n                      [v[2], 0, -v[0]],\n                      [-v[1], v[0], 0]]\n                I = [[1 if i == j else 0 for j in range(3)] for i in range(3)]\n                vx2 = [[sum(vx[i][k]*vx[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n                R = [[I[i][j] + vx[i][j] + ((1 - c)/(s**2))*vx2[i][j] for j in range(3)] for i in range(3)]\n\n        a1_val = c_max / 2.0\n        try:\n            a_others = math.sqrt(abs(c_max*c_max - c_min*c_min)) / 2.0\n        except Exception:\n            a_others = a1_val\n\n        while True:\n            # Sample point in unit ball\n            if dim == 2:\n                r = random.uniform(0, 1)**0.5\n                theta = random.uniform(0, 2*math.pi)\n                x_ball = [r*math.cos(theta), r*math.sin(theta)]\n                L = [[a1_val, 0], [0, a_others]]\n                x_scaled = [L[0][0]*x_ball[0] + L[0][1]*x_ball[1],\n                            L[1][0]*x_ball[0] + L[1][1]*x_ball[1]]\n                pt_rot = (R[0][0]*x_scaled[0] + R[0][1]*x_scaled[1],\n                          R[1][0]*x_scaled[0] + R[1][1]*x_scaled[1])\n                pt = tuple(center[i] + pt_rot[i] for i in range(dim))\n            else:\n                while True:\n                    x_ball = [random.uniform(-1,1) for _ in range(3)]\n                    if sum(xi*xi for xi in x_ball) <= 1:\n                        break\n                L = [[a1_val,0,0],[0,a_others,0],[0,0,a_others]]\n                x_scaled = [L[0][0]*x_ball[0], L[1][1]*x_ball[1], L[2][2]*x_ball[2]]\n                pt_rot = [sum(R[i][j]*x_scaled[j] for j in range(3)) for i in range(3)]\n                pt = tuple(center[i] + pt_rot[i] for i in range(dim))\n\n            # Check bounds\n            if any(pt[d] < 0 or pt[d] > bounds[d] for d in range(dim)):\n                continue\n            if self._is_in_obstacle(pt, obstacles, is_3d):\n                continue\n            return pt\n\n    def _nearest(self, tree, point):\n        return min(tree, key=lambda node: math.dist(node.position, point))\n\n    def _near(self, tree, point, radius):\n        radius_sq = radius*radius\n        return [node for node in tree if self._squared_distance(node.position, point) <= radius_sq]\n\n    def _steer(self, from_pos, to_pos):\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[i] + (to_pos[i]-from_pos[i])*ratio for i in range(len(from_pos)))\n\n    def _extract_path(self, node_start, node_goal):\n        path_start = []\n        n = node_start\n        while n:\n            path_start.append(n.position)\n            n = n.parent\n        path_goal = []\n        n = node_goal\n        while n:\n            path_goal.append(n.position)\n            n = n.parent\n        return list(reversed(path_start)) + path_goal\n\n    def _iterative_shortcut(self, path, obstacles, is_3d, max_attempts=150):\n        if len(path) < 3:\n            return path[:]\n        path = path[:]\n        for _ in range(max_attempts):\n            if len(path) < 3:\n                break\n            i = random.randint(0, len(path)-3)\n            j = random.randint(i+2, len(path)-1)\n            if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                # Remove intermediate nodes between i and j\n                path = path[:i+1] + path[j:]\n        return path\n\n    def _squared_distance(self, a, b):\n        return sum((a[i] - b[i])**2 for i in range(len(a)))\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x,y,z,w,h,d = obs\n                px,py,pz = pos\n                if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                    return True\n            else:\n                x,y,w,h = obs\n                px,py = pos\n                if x <= px <= x+w and y <= py <= y+h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist/resolution))\n        for i in range(steps+1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d])*(i/steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -14.08602,
          "time_improvement": -15.0,
          "length_improvement": 20.0,
          "smoothness_improvement": 1402.0,
          "node_improvement": 63.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.05029592514038086,
                    "num_nodes_avg": 197.7,
                    "path_length_avg": 161.93878883699725,
                    "smoothness_avg": 0.047628044606518545,
                    "success_improvement": 0.0,
                    "time_improvement": -95.01490647056376,
                    "node_improvement": 50.21405187610174,
                    "length_improvement": 11.23878375412141,
                    "smoothness_improvement": 645.482324046268,
                    "objective_score": -18.53379006846494
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.059864473342895505,
                    "num_nodes_avg": 338.1,
                    "path_length_avg": 225.87643224817134,
                    "smoothness_avg": 0.0890107769545784,
                    "success_improvement": 0.0,
                    "time_improvement": 63.844649222693185,
                    "node_improvement": 77.2828058859101,
                    "length_improvement": 24.59594542294319,
                    "smoothness_improvement": 2190.3114029125213,
                    "objective_score": 44.86251903513647
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.05845465660095215,
                    "num_nodes_avg": 311.2,
                    "path_length_avg": 116.34668105324462,
                    "smoothness_avg": 0.11554898589311344,
                    "success_improvement": 0.0,
                    "time_improvement": -15.18798998915194,
                    "node_improvement": 60.43229497774952,
                    "length_improvement": 22.7280742780298,
                    "smoothness_improvement": 1369.7745716214542,
                    "objective_score": 15.929320428179569
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "path_expert",
          "algorithm_description": "A bidirectional RRT* variant that employs adaptive neighborhood radius scaling, combined informed and goal-biased sampling, and aggressive incremental shortcutting applied frequently to strongly improve path length and smoothness. It features continuous rewiring with dynamic radius adjustments, goal bias to accelerate convergence, spatial pruning for efficient rewiring, and systematic incremental path shortcutting after each solution improvement to progressively smooth and shorten the path during planning, thereby reducing total search time and improving final path quality.",
          "planning_mechanism": "The planner grows two trees from start and goal positions alternately. Sampling combines uniform, informed ellipsoidal, and goal-biased strategies focused on promising regions defined by current best solution estimates. Nodes connect and rewire within dynamically computed adaptive radii that shrink as the tree grows, optimizing local connectivity and cost. Upon each improved solution, the path is incrementally shortcut multiple times to smooth and shorten it. The search terminates early if improvements stagnate, ensuring swift convergence to high-quality paths.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n    def add_child(self, child):\n        self.children.append(child)\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except ValueError:\n            pass\nclass Planner:\n    def __init__(self, max_iter=4000, step_size=6.0, gamma_rrt_star=40.0,\n                 shortcut_interval=10, max_shortcut_attempts=80, goal_sample_rate=0.1):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.gamma_rrt_star = gamma_rrt_star\n        self.shortcut_interval = shortcut_interval\n        self.max_shortcut_attempts = max_shortcut_attempts\n        self.goal_sample_rate = goal_sample_rate  # probability to sample goal directly\n\n    def plan(self, map):\n        import random\n        import math\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = (len(bounds) == 3)\n        dim = 3 if is_3d else 2\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        all_nodes = start_tree + goal_tree\n        edges = []\n\n        best_cost = float('inf')\n        solution_start = None\n        solution_goal = None\n        c_min = math.dist(start_pos, goal_pos)\n        unit_ball_volume = self._unit_ball_volume(dim)\n        max_step = self.step_size\n\n        def near_radius(n_nodes):\n            if n_nodes <= 1:\n                # Start with large radius for initial connectivity\n                return max_step * 8.0\n            return min(max_step * 30, self.gamma_rrt_star * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim)))\n\n        # Check point collision\n        def in_obstacle(pt):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pt\n                    if (x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d):\n                        return True\n                else:\n                    x, y, w, h = obs\n                    px, py = pt\n                    if (x <= px <= x + w and y <= py <= y + h):\n                        return True\n            return False\n\n        # Check if segment intersects obstacle by discrete checking\n        def edge_in_obstacle(pt1, pt2, resolution=0.5):\n            dist = 0.0\n            for i in range(dim):\n                diff = pt2[i] - pt1[i]\n                dist += diff * diff\n            dist = dist**0.5\n            steps = max(int(dist / resolution), 1)\n            for i in range(steps + 1):\n                t = i / steps\n                interp = tuple(pt1[d] + t * (pt2[d] - pt1[d]) for d in range(dim))\n                if in_obstacle(interp):\n                    return True\n            return False\n\n        # Uniform free sample bounded by map size\n        def sample_uniform():\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not in_obstacle(pt):\n                    return pt\n\n        # Biased goal sampling\n        def sample_goal():\n            if not in_obstacle(goal_pos):\n                return goal_pos\n            else:\n                return sample_uniform()\n\n        # Ellipsoidal informed sampling centered on start-goal segment when best_cost < inf\n        def sample_informed():\n            if best_cost == float('inf') or best_cost <= c_min:\n                # No path found yet or trivial bound: uniform sample\n                return sample_uniform()\n            center = tuple((start_pos[i] + goal_pos[i]) / 2 for i in range(dim))\n            dir_vec = [goal_pos[i] - start_pos[i] for i in range(dim)]\n            length = math.dist(start_pos, goal_pos)\n            if length < 1e-10:\n                # Nearly identical start and goal\n                return sample_uniform()\n\n            # Rotation matrix R from unit vector e1 to dir_vec\n            if dim == 2:\n                a1 = [1, 0]\n                a2 = [dir_vec[0] / length, dir_vec[1] / length]\n                cos_theta = a1[0] * a2[0] + a1[1] * a2[1]\n                sin_theta = a1[0] * a2[1] - a1[1] * a2[0]\n                R = [[cos_theta, -sin_theta], [sin_theta, cos_theta]]\n            else:\n                # 3D rotation matrix via Rodrigues formula\n                from math import sqrt\n                a1 = [1, 0, 0]\n                a2 = [dir_vec[i] / length for i in range(3)]\n                v = [a1[1]*a2[2]-a1[2]*a2[1], a1[2]*a2[0]-a1[0]*a2[2], a1[0]*a2[1]-a1[1]*a2[0]]\n                s = sqrt(sum(vi*vi for vi in v))\n                c = sum(a1[i]*a2[i] for i in range(3))\n                if s < 1e-10:\n                    R = [[1,0,0],[0,1,0],[0,0,1]]\n                else:\n                    vx = [[0,-v[2],v[1]],[v[2],0,-v[0]],[-v[1],v[0],0]]\n                    I = [[int(i==j) for j in range(3)] for i in range(3)]\n                    vx2 = [[sum(vx[i][k]*vx[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n                    R = [[I[i][j] + vx[i][j] + vx2[i][j]*((1-c)/(s**2)) for j in range(3)] for i in range(3)]\n\n            a1_val = best_cost / 2.0\n            if best_cost**2 - c_min**2 < 0:  # Numerical safeguard\n                a_other = 0.0\n            else:\n                a_other = math.sqrt(best_cost**2 - c_min**2) / 2.0\n\n            while True:\n                if dim == 2:\n                    r = random.uniform(0, 1)**0.5  # uniform in unit disk\n                    theta = random.uniform(0, 2*math.pi)\n                    x_ball = [r*math.cos(theta), r*math.sin(theta)]\n                    L = [[a1_val, 0], [0, a_other]]\n                    x_scaled = [L[0][0]*x_ball[0] + L[0][1]*x_ball[1],\n                                L[1][0]*x_ball[0] + L[1][1]*x_ball[1]]\n                    pt = (center[0] + R[0][0]*x_scaled[0] + R[0][1]*x_scaled[1],\n                          center[1] + R[1][0]*x_scaled[0] + R[1][1]*x_scaled[1])\n                else:\n                    while True:\n                        x_ball = [random.uniform(-1,1) for _ in range(3)]\n                        if sum(xi*xi for xi in x_ball) <= 1:\n                            break\n                    L = [[a1_val, 0, 0], [0, a_other, 0], [0, 0, a_other]]\n                    x_scaled = [L[0][0]*x_ball[0], L[1][1]*x_ball[1], L[2][2]*x_ball[2]]\n                    pt = tuple(center[i] + sum(R[i][j]*x_scaled[j] for j in range(dim)) for i in range(dim))\n\n                if any(pt[d] < 0 or pt[d] > bounds[d] for d in range(dim)):\n                    continue\n                if in_obstacle(pt):\n                    continue\n                return pt\n\n        def nearest(tree, pt):\n            best_node = None\n            best_dist_sq = float('inf')\n            for node in tree:\n                dist_sq = 0.0\n                for i in range(dim):\n                    delta = node.position[i] - pt[i]\n                    dist_sq += delta*delta\n                if dist_sq < best_dist_sq:\n                    best_dist_sq = dist_sq\n                    best_node = node\n            return best_node\n\n        def near(tree, pt, radius):\n            radius_sq = radius * radius\n            near_nodes = []\n            for node in tree:\n                dist_sq = 0.0\n                for i in range(dim):\n                    delta = node.position[i] - pt[i]\n                    dist_sq += delta*delta\n                if dist_sq <= radius_sq:\n                    near_nodes.append(node)\n            return near_nodes\n\n        def steer(from_pt, to_pt, max_dist):\n            dist = 0.0\n            diffs = []\n            for i in range(dim):\n                diff = to_pt[i] - from_pt[i]\n                diffs.append(diff)\n                dist += diff*diff\n            dist = dist**0.5\n            if dist <= max_dist:\n                return to_pt\n            ratio = max_dist / dist\n            new_pt = tuple(from_pt[i] + ratio * diffs[i] for i in range(dim))\n            return new_pt\n\n        def connect_tree(tree_from, tree_to, sample):\n            nearest_node = nearest(tree_from, sample)\n            new_pos = steer(nearest_node.position, sample, max_step)\n            if in_obstacle(new_pos):\n                return None\n            if edge_in_obstacle(nearest_node.position, new_pos):\n                return None\n\n            new_node = Node(new_pos)\n            radius = near_radius(len(tree_from))\n            neighbors = near(tree_from, new_pos, radius)\n\n            # Choose best parent\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            min_parent = nearest_node\n            for n in neighbors:\n                cost_try = n.cost + math.dist(n.position, new_pos)\n                if cost_try < min_cost:\n                    if not edge_in_obstacle(n.position, new_pos):\n                        min_cost = cost_try\n                        min_parent = n\n\n            new_node.parent = min_parent\n            new_node.cost = min_cost\n            min_parent.add_child(new_node)\n\n            tree_from.append(new_node)\n            all_nodes.append(new_node)\n            edges.append((min_parent, new_node))\n\n            # Rewire neighbors if improving cost\n            for neighbor in neighbors:\n                if neighbor is min_parent:\n                    continue\n                cost_through_new = new_node.cost + math.dist(new_node.position, neighbor.position)\n                if cost_through_new + 1e-8 < neighbor.cost:\n                    if not edge_in_obstacle(new_node.position, neighbor.position):\n                        # Remove old edge\n                        if neighbor.parent:\n                            try:\n                                edges.remove((neighbor.parent, neighbor))\n                            except ValueError:\n                                pass\n                            neighbor.parent.remove_child(neighbor)\n                        neighbor.parent = new_node\n                        neighbor.cost = cost_through_new\n                        new_node.add_child(neighbor)\n                        edges.append((new_node, neighbor))\n\n            # Attempt connection to other tree\n            closest_other = nearest(tree_to, new_node.position)\n            dist_to_other = math.dist(new_node.position, closest_other.position)\n            if dist_to_other <= max_step:\n                if not edge_in_obstacle(new_node.position, closest_other.position):\n                    total_cost = new_node.cost + dist_to_other + closest_other.cost\n                    return new_node, closest_other, total_cost\n            return None\n\n        def extract_path(node_start, node_goal):\n            path1 = []\n            n = node_start\n            while n:\n                path1.append(n.position)\n                n = n.parent\n            path2 = []\n            n = node_goal\n            while n:\n                path2.append(n.position)\n                n = n.parent\n            return list(reversed(path1)) + path2\n\n        # Incremental shortcutting to smooth and shorten path, attempting multiple segments per call,\n        # aggressively applied after each improvement\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path[:]\n            import random\n            path_new = path[:]\n            attempts = 0\n            successful = 0\n            max_attempts = self.max_shortcut_attempts\n            while attempts < max_attempts:\n                if len(path_new) < 3:\n                    break\n                i = random.randint(0, len(path_new)-3)\n                j = random.randint(i+2, len(path_new)-1)\n                if not edge_in_obstacle(path_new[i], path_new[j]):\n                    # shortcut segment\n                    path_new = path_new[:i+1] + path_new[j:]\n                    successful += 1\n                    attempts = 0  # reset attempts after success to enable more reductions\n                else:\n                    attempts += 1\n            return path_new\n\n        last_improvement_iter = 0\n        improvement_threshold = 100  # iterations allowed without improvement before early stop\n\n        for iteration in range(self.max_iter):\n            # Sampling with combined bias: goal bias, informed sampling, uniform\n            p = random.random()\n            if best_cost < float('inf') and p > 1.0 - self.goal_sample_rate:\n                sample = sample_goal()\n            elif best_cost < float('inf'):\n                sample = sample_informed()\n            else:\n                sample = sample_uniform()\n\n            # Alternate expansions and attempts\n            for tree_from, tree_to in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                res = connect_tree(tree_from, tree_to, sample)\n                if res is not None:\n                    n_start, n_goal, cost = res\n                    if cost + 1e-8 < best_cost:\n                        best_cost = cost\n                        # assign solution nodes with consistent start-goal orientation\n                        if tree_from is start_tree:\n                            solution_start, solution_goal = n_start, n_goal\n                        else:\n                            solution_start, solution_goal = n_goal, n_start\n                        last_improvement_iter = iteration\n\n                        # progressively shortcut aggressively after each improvement\n                        raw_path = extract_path(solution_start, solution_goal)\n                        improved_path = shortcut_path(raw_path)\n                        # Post-smoothing iterative shortcutting for further reduction\n                        for _ in range(2):\n                            improved_path = shortcut_path(improved_path)\n\n            # Stop if no improvement for too long and found a solution\n            if best_cost < float('inf') and (iteration - last_improvement_iter) > improvement_threshold:\n                break\n\n            # Periodic shortcutting even if no improvements, to improve path quality incrementally\n            if best_cost < float('inf') and (iteration % self.shortcut_interval == 0) and solution_start and solution_goal:\n                raw_path = extract_path(solution_start, solution_goal)\n                improved_path = shortcut_path(raw_path)\n                # Accept and output current best path if improvement found in shortcut\n                if len(improved_path) < len(raw_path):\n                    return PlannerResult(True, improved_path, all_nodes, edges)\n\n        if best_cost < float('inf') and solution_start and solution_goal:\n            # Final shortcut before returning\n            raw_path = extract_path(solution_start, solution_goal)\n            improved_path = shortcut_path(raw_path)\n            return PlannerResult(True, improved_path, all_nodes, edges)\n\n        return PlannerResult(False, [], all_nodes, edges)\n\n    def _unit_ball_volume(self, dim):\n        import math\n        if dim == 2:\n            return math.pi\n        elif dim == 3:\n            return 4.0/3.0 * math.pi\n        else:\n            from math import gamma\n            return (math.pi**(dim/2)) / gamma(dim/2 + 1)",
          "objective": -8.99674,
          "time_improvement": -22.0,
          "length_improvement": 15.0,
          "smoothness_improvement": 1379.0,
          "node_improvement": 73.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.06457171440124512,
                    "num_nodes_avg": 132.5,
                    "path_length_avg": 168.89889681679642,
                    "smoothness_avg": 0.04697172518327863,
                    "success_improvement": 0.0,
                    "time_improvement": -150.36713828120307,
                    "node_improvement": 66.63308990178797,
                    "length_improvement": 7.423838280424763,
                    "smoothness_improvement": 635.2094998521243,
                    "objective_score": -37.47979101684544
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.05212686061859131,
                    "num_nodes_avg": 230.7,
                    "path_length_avg": 237.45130276031324,
                    "smoothness_avg": 0.09005704552374123,
                    "success_improvement": 0.0,
                    "time_improvement": 68.5178065496401,
                    "node_improvement": 84.49909292481354,
                    "length_improvement": 20.73192048181532,
                    "smoothness_improvement": 2217.2326467938706,
                    "objective_score": 44.080657487950575
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.042715144157409665,
                    "num_nodes_avg": 257.8,
                    "path_length_avg": 127.42936259429484,
                    "smoothness_avg": 0.10881519882806052,
                    "success_improvement": 0.0,
                    "time_improvement": 15.827551067869216,
                    "node_improvement": 67.22186904005086,
                    "length_improvement": 15.367484899048108,
                    "smoothness_improvement": 1284.12129719044,
                    "objective_score": 20.389362745741828
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "A streamlined bidirectional RRT* planner that alternates tree expansions with goal bias, fixed-radius rewiring, and straightforward path shortcutting for efficient planning and improved path quality. It uses simple nearest neighbor searches and basic collision checks to maintain clarity and generalizability.",
          "planning_mechanism": "The planner grows two trees from start and goal alternately, samples points biased towards the goal, connects nodes using fixed step sizes and radius for rewiring, and upon connecting the trees, extracts and shortcuts the path to reduce length and improve smoothness.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\nclass Planner:\n    def __init__(self, max_iter=3000, step_size=5.0, goal_sample_rate=0.1, radius=10.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.radius = radius\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n\n        start_tree = [Node(start)]\n        goal_tree = [Node(goal)]\n        edges = []\n        for i in range(self.max_iter):\n            sample = goal if self._random() < self.goal_sample_rate else self._sample_free(bounds, obstacles, dim)\n\n            trees = [(start_tree, goal_tree), (goal_tree, start_tree)]\n            active_tree, other_tree = trees[i % 2]\n\n            nearest = self._nearest(active_tree, sample)\n            new_pos = self._steer(nearest.position, sample, self.step_size)\n            if self._collides(new_pos, obstacles, dim):\n                continue\n            if self._edge_collides(nearest.position, new_pos, obstacles, dim):\n                continue\n\n            new_node = Node(new_pos)\n            near_nodes = self._near(active_tree, new_pos, self.radius)\n            min_cost, min_parent = nearest.cost + self._dist(nearest.position, new_pos), nearest\n\n            for near in near_nodes:\n                cost = near.cost + self._dist(near.position, new_pos)\n                if cost < min_cost and not self._edge_collides(near.position, new_pos, obstacles, dim):\n                    min_cost, min_parent = cost, near\n\n            new_node.parent = min_parent\n            new_node.cost = min_cost\n            min_parent.add_child(new_node)\n            active_tree.append(new_node)\n            edges.append((min_parent, new_node))\n\n            for near in near_nodes:\n                if near is min_parent:\n                    continue\n                new_cost = new_node.cost + self._dist(new_node.position, near.position)\n                if new_cost < near.cost and not self._edge_collides(new_node.position, near.position, obstacles, dim):\n                    if near.parent:\n                        try:\n                            edges.remove((near.parent, near))\n                        except ValueError:\n                            pass\n                        near.parent.children.remove(near)\n                    near.parent = new_node\n                    near.cost = new_cost\n                    new_node.add_child(near)\n                    edges.append((new_node, near))\n\n            connect_node = self._nearest(other_tree, new_node.position)\n            if self._dist(new_node.position, connect_node.position) <= self.step_size and not self._edge_collides(new_node.position, connect_node.position, obstacles, dim):\n                path = self._extract_path(new_node, connect_node)\n                path = self._shortcut_path(path, obstacles, dim)\n                return PlannerResult(True, path, start_tree + goal_tree, edges)\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    def _sample_free(self, bounds, obstacles, dim):\n        while True:\n            point = tuple(self._random() * bounds[i] for i in range(dim))\n            if not self._collides(point, obstacles, dim):\n                return point\n\n    def _nearest(self, tree, point):\n        best, best_dist = None, float('inf')\n        for node in tree:\n            dist = self._dist(node.position, point)\n            if dist < best_dist:\n                best, best_dist = node, dist\n        return best\n\n    def _near(self, tree, point, radius):\n        r_sq = radius * radius\n        return [node for node in tree if self._dist_sq(node.position, point) <= r_sq]\n\n    def _steer(self, from_pos, to_pos, step):\n        dist = self._dist(from_pos, to_pos)\n        if dist <= step:\n            return to_pos\n        ratio = step / dist\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n    def _dist(self, a, b):\n        return self._dist_sq(a, b) ** 0.5\n\n    def _dist_sq(self, a, b):\n        return sum((a[i] - b[i]) ** 2 for i in range(len(a)))\n\n    def _collides(self, pos, obstacles, dim):\n        if dim == 3:\n            x, y, z = pos\n            for obs in obstacles:\n                ox, oy, oz, w, h, d = obs\n                if ox <= x <= ox + w and oy <= y <= oy + h and oz <= z <= oz + d:\n                    return True\n        else:\n            x, y = pos\n            for obs in obstacles:\n                ox, oy, w, h = obs\n                if ox <= x <= ox + w and oy <= y <= oy + h:\n                    return True\n        return False\n\n    def _edge_collides(self, start, end, obstacles, dim, resolution=0.5):\n        dist = self._dist(start, end)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            point = tuple(start[j] + (end[j] - start[j]) * i / steps for j in range(dim))\n            if self._collides(point, obstacles, dim):\n                return True\n        return False\n\n    def _extract_path(self, node_a, node_b):\n        path_a = []\n        while node_a:\n            path_a.append(node_a.position)\n            node_a = node_a.parent\n        path_b = []\n        while node_b:\n            path_b.append(node_b.position)\n            node_b = node_b.parent\n        return list(reversed(path_a)) + path_b\n\n    def _shortcut_path(self, path, obstacles, dim, max_attempts=40):\n        path = path[:]\n        attempts = 0\n        while attempts < max_attempts and len(path) > 2:\n            i = int(self._random() * (len(path) - 2))\n            j = int(i + 2 + self._random() * (len(path) - i - 2))\n            if j >= len(path):\n                j = len(path) - 1\n            if not self._edge_collides(path[i], path[j], obstacles, dim):\n                del path[i+1:j]\n            attempts += 1\n        return path\n\n    def _random(self):\n        # To allow testing replace with random.random(), here stub for determinism if needed\n        import random\n        return random.random()",
          "objective": -6.82375,
          "time_improvement": -25.0,
          "length_improvement": 16.0,
          "smoothness_improvement": 998.0,
          "node_improvement": 69.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.04590208530426025,
                    "num_nodes_avg": 161.1,
                    "path_length_avg": 170.32708573767837,
                    "smoothness_avg": 0.02884305512385804,
                    "success_improvement": 0.0,
                    "time_improvement": -77.97845148348269,
                    "node_improvement": 59.430873835305974,
                    "length_improvement": 6.641025301787684,
                    "smoothness_improvement": 351.4564463850669,
                    "objective_score": -17.65163803204686
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.09899413585662842,
                    "num_nodes_avg": 319.9,
                    "path_length_avg": 232.70596040537356,
                    "smoothness_avg": 0.06308823090997337,
                    "success_improvement": 0.0,
                    "time_improvement": 40.21215744617372,
                    "node_improvement": 78.50567761875966,
                    "length_improvement": 22.316052347000596,
                    "smoothness_improvement": 1523.3056219296157,
                    "objective_score": 33.069806751700554
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.06967871189117432,
                    "num_nodes_avg": 249.0,
                    "path_length_avg": 123.85483726002462,
                    "smoothness_avg": 0.09591030345606508,
                    "success_improvement": 0.0,
                    "time_improvement": -37.30558409690246,
                    "node_improvement": 68.34075015893197,
                    "length_improvement": 17.741514425465155,
                    "smoothness_improvement": 1119.97198059895,
                    "objective_score": 5.053093329203105
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m2",
          "algorithm_description": "An optimized bidirectional informed RRT* planner with dynamic neighbor radius adapting to node count and iteration, improved heuristic-guided sampling leveraging ellipsoidal informed sampling around the current best cost, enhanced rewiring limited by dynamic radius, and curvature-aware cost function to promote smoother paths. The planner maintains two trees growing toward each other, performs efficient spatial hashing for near neighbor queries, conducts local rewiring to reduce path cost and curvature penalties, and iteratively shortcuts the best path to improve smoothness, enabling faster convergence to high-quality paths. It terminates early upon finding a satisfactory path under iteration limits.",
          "planning_mechanism": "The planner alternates expansion of start and goal trees using the informed sampling strategy guided by the best cost to date. It uses spatial grids for nearest neighbor and near-node queries within a dynamically computed radius based on current iteration and node count. New nodes are steered towards random samples, checked for collisions, and connected to the best parent among neighbors. Rewiring improves the tree by reducing path cost including curvature penalty. The two trees attempt to connect at each iteration, updating the best path found and performing shortcutting to improve smoothness and length.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n    def add_child(self, child):\n        self.children.append(child)\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\nclass Planner:\n    def __init__(self, max_iter=2500, step_size=3.0, base_radius=16.0, goal_sample_rate=0.12):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.base_radius = base_radius\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map):\n        import random\n        import math\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def in_bounds(p):\n            for i in range(dim):\n                if p[i] < 0 or p[i] > bounds[i]:\n                    return False\n            return True\n\n        def collision_node(p):\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d = obs\n                    px,py,pz = p\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                        return True\n                else:\n                    x,y,w,h = obs\n                    px,py = p\n                    if x <= px <= x+w and y <= py <= y+h:\n                        return True\n            return False\n\n        def collision_edge(a,b, res=0.4):\n            length = math.dist(a,b)\n            steps = max(1, int(length/res))\n            for i in range(steps+1):\n                pt = tuple(a[d] + (b[d]-a[d])*(i/steps) for d in range(dim))\n                if collision_node(pt):\n                    return True\n            return False\n\n        def steer(frm, to):\n            dist = math.dist(frm,to)\n            if dist <= self.step_size:\n                return to\n            ratio = self.step_size/dist\n            return tuple(frm[i] + (to[i] - frm[i])*ratio for i in range(dim))\n\n        GRID_SIZE = self.step_size * 2.3\n        def grid_hash(p):\n            return tuple(int(p[i]/GRID_SIZE) for i in range(dim))\n\n        def add_to_hash(hashmap, node):\n            h = grid_hash(node.position)\n            if h not in hashmap:\n                hashmap[h] = []\n            hashmap[h].append(node)\n\n        def nearby_nodes(hashmap, p, radius):\n            radius_sq = radius*radius\n            gh = grid_hash(p)\n            candidates = []\n            shifts = [-1,0,1]\n            if dim == 2:\n                neighbors = [(gh[0]+dx, gh[1]+dy) for dx in shifts for dy in shifts]\n            else:\n                neighbors = [(gh[0]+dx, gh[1]+dy, gh[2]+dz) for dx in shifts for dy in shifts for dz in shifts]\n            for cell in neighbors:\n                if cell in hashmap:\n                    for n in hashmap[cell]:\n                        d2 = 0\n                        for i in range(dim):\n                            diff = n.position[i] - p[i]\n                            d2 += diff*diff\n                        if d2 <= radius_sq:\n                            candidates.append(n)\n            return candidates\n\n        def nearest(hashmap, p):\n            gh = grid_hash(p)\n            min_node = None\n            min_dist = float('inf')\n            # expand cells progressively\n            for radius_cells in range(3):\n                check_cells = []\n                rng = range(-radius_cells, radius_cells+1)\n                if dim == 2:\n                    check_cells = [(gh[0]+dx, gh[1]+dy) for dx in rng for dy in rng]\n                else:\n                    check_cells = [(gh[0]+dx, gh[1]+dy, gh[2]+dz) for dx in rng for dy in rng for dz in rng]\n                for c in check_cells:\n                    if c in hashmap:\n                        for n in hashmap[c]:\n                            d = math.dist(n.position, p)\n                            if d < min_dist:\n                                min_dist = d\n                                min_node = n\n                if min_node:\n                    return min_node\n            # fallback to linear scan\n            all_nodes = []\n            for nodes_list in hashmap.values():\n                all_nodes.extend(nodes_list)\n            if not all_nodes:\n                return None\n            return min(all_nodes, key=lambda n: math.dist(n.position,p))\n\n        def curvature_penalty(parent, child_pos):\n            if parent is None or parent.parent is None:\n                return 0.0\n            v1 = [parent.position[i] - parent.parent.position[i] for i in range(dim)]\n            v2 = [child_pos[i] - parent.position[i] for i in range(dim)]\n            len1 = math.sqrt(sum(a*a for a in v1))\n            len2 = math.sqrt(sum(a*a for a in v2))\n            if len1 < 1e-12 or len2 < 1e-12:\n                return 0.0\n            dot = sum(v1[i]*v2[i] for i in range(dim))\n            cos_ang = max(-1.0, min(1.0, dot/(len1*len2)))\n            penalty = (1.0 - cos_ang)*0.85\n            return penalty\n\n        def cost(parent, child_pos):\n            return parent.cost + math.dist(parent.position, child_pos) + curvature_penalty(parent, child_pos)\n\n        def neighbor_radius(iteration, n_nodes):\n            if n_nodes <= 2:\n                return self.base_radius\n            val = (math.log(n_nodes) / n_nodes)**(1/dim)\n            rad = self.base_radius * val\n            return max(rad, self.step_size*1.1)\n\n        def propagate_cost(node):\n            for c in node.children:\n                new_cost = node.cost + math.dist(node.position,c.position) + curvature_penalty(node,c.position)\n                if new_cost + 1e-12 < c.cost:\n                    c.cost = new_cost\n                    propagate_cost(c)\n\n        def rewire(tree_hash, new_node, near_nodes):\n            for n in near_nodes:\n                if n is new_node.parent:\n                    continue\n                c_cost = cost(new_node, n.position)\n                if c_cost + 1e-9 < n.cost and not collision_edge(new_node.position, n.position):\n                    if n.parent:\n                        n.parent.remove_child(n)\n                    n.parent = new_node\n                    n.cost = c_cost\n                    new_node.add_child(n)\n                    propagate_cost(n)\n\n        def extract_path(n_start, n_goal):\n            path_start = []\n            node = n_start\n            while node:\n                path_start.append(node.position)\n                node = node.parent\n            path_start.reverse()\n            path_goal = []\n            node = n_goal\n            while node:\n                path_goal.append(node.position)\n                node = node.parent\n            if path_start[-1] == path_goal[0]:\n                return path_start + path_goal[1:]\n            else:\n                return path_start + path_goal\n\n        def shortcut_path(path, max_tries=150):\n            if len(path) < 3:\n                return path[:]\n            new_path = path[:]\n            for _ in range(max_tries):\n                if len(new_path) < 3:\n                    break\n                i = random.randint(0, len(new_path)-3)\n                j = random.randint(i+2, len(new_path)-1)\n                if not collision_edge(new_path[i], new_path[j]):\n                    del new_path[i+1:j]\n            return new_path\n\n        def informed_sample(iteration, best_cost):\n            if iteration % 3 != 0 and best_cost < float('inf'):\n                c_min = math.dist(start_pos, goal_pos)\n                c_best = max(best_cost, c_min + 1e-9)\n                center = tuple((start_pos[i]+goal_pos[i])*0.5 for i in range(dim))\n                r1 = c_best/2\n                val = c_best**2 - c_min**2\n                r_rest = math.sqrt(val)/2 if val > 0 else 0.0\n\n                def unit_sphere():\n                    while True:\n                        vec = [random.gauss(0,1) for _ in range(dim)]\n                        norm = math.sqrt(sum(x*x for x in vec))\n                        if norm > 1e-12:\n                            return [x / norm for x in vec]\n\n                for _ in range(25):\n                    u = unit_sphere()\n                    pt = [0]*dim\n                    pt[0] = u[0] * r1\n                    for i in range(1, dim):\n                        pt[i] = u[i] * r_rest\n                    sample = tuple(center[i] + pt[i] for i in range(dim))\n                    if in_bounds(sample) and not collision_node(sample):\n                        return sample\n            for _ in range(40):\n                p = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not collision_node(p):\n                    return p\n            return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        start_hash = {}\n        goal_hash = {}\n\n        add_to_hash(start_hash, start_tree[0])\n        add_to_hash(goal_hash, goal_tree[0])\n\n        best_path = []\n        best_cost = float('inf')\n\n        for it in range(1, self.max_iter+1):\n            sample = informed_sample(it, best_cost)\n\n            for exp_hash, oth_hash, exp_tree, oth_tree in [\n                (start_hash, goal_hash, start_tree, goal_tree),\n                (goal_hash, start_hash, goal_tree, start_tree)]:\n\n                nearest_node = nearest(exp_hash, sample)\n                if nearest_node is None:\n                    continue\n                new_pos = steer(nearest_node.position, sample)\n                if not in_bounds(new_pos) or collision_node(new_pos) or collision_edge(nearest_node.position, new_pos):\n                    continue\n\n                radius = neighbor_radius(it, len(exp_tree))\n                near_nodes = nearby_nodes(exp_hash, new_pos, radius)\n\n                parent_node = nearest_node\n                parent_cost = cost(nearest_node, new_pos)\n                for n in near_nodes:\n                    if n is nearest_node:\n                        continue\n                    if collision_edge(n.position, new_pos):\n                        continue\n                    c = cost(n, new_pos)\n                    if c < parent_cost:\n                        parent_cost = c\n                        parent_node = n\n\n                new_node = Node(new_pos, parent_node, parent_cost)\n                parent_node.add_child(new_node)\n                exp_tree.append(new_node)\n                nodes.append(new_node)\n                add_to_hash(exp_hash, new_node)\n                rewire(exp_hash, new_node, near_nodes)\n\n                other_nearest = nearest(oth_hash, new_node.position)\n                if other_nearest and math.dist(other_nearest.position, new_node.position) <= self.step_size:\n                    if not collision_edge(other_nearest.position, new_node.position):\n                        candidate = extract_path(new_node, other_nearest)\n                        cost_path = 0.0\n                        for i in range(len(candidate)-1):\n                            cost_path += math.dist(candidate[i], candidate[i+1])\n                        if cost_path + 1e-9 < best_cost:\n                            best_cost = cost_path\n                            best_path = shortcut_path(candidate, max_tries=150)\n                            if best_cost < float('inf'):\n                                return PlannerResult(True, best_path, nodes, edges)\n\n        if best_path:\n            return PlannerResult(True, best_path, nodes, edges)\n        return PlannerResult(False, [], nodes, edges)",
          "objective": -6.76437,
          "time_improvement": 19.0,
          "length_improvement": 16.0,
          "smoothness_improvement": 1633.0,
          "node_improvement": 54.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 0.9,
                    "time_avg": 0.03511323928833008,
                    "num_nodes_avg": 168.6,
                    "path_length_avg": 168.33553634796726,
                    "smoothness_avg": 0.044382753798602896,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": -36.14631914175707,
                    "node_improvement": 57.542180810878875,
                    "length_improvement": 7.732625080407921,
                    "smoothness_improvement": 594.6864756406034,
                    "objective_score": -53.230888316079344
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.045547866821289064,
                    "num_nodes_avg": 446.2,
                    "path_length_avg": 232.36821325534112,
                    "smoothness_avg": 0.11382562635653662,
                    "success_improvement": 0.0,
                    "time_improvement": 72.49121206413825,
                    "node_improvement": 70.01948531882013,
                    "length_improvement": 22.428802067194113,
                    "smoothness_improvement": 2828.8153514384817,
                    "objective_score": 49.34872161675035
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.04101715087890625,
                    "num_nodes_avg": 505.2,
                    "path_length_avg": 122.84298054352023,
                    "smoothness_avg": 0.12382294015630269,
                    "success_improvement": 0.0,
                    "time_improvement": 19.17353655711958,
                    "node_improvement": 35.7660521296885,
                    "length_improvement": 18.4135414771283,
                    "smoothness_improvement": 1475.0186591294457,
                    "objective_score": 24.175279149060085
               }
          ],
          "success_rate": 0.9666666666666667
     },
     {
          "operator": "m1",
          "algorithm_description": "A bidirectional RRT* variant with adaptive informed sampling, enhanced rewiring that updates descendant costs recursively for global improvements, and curvature-aware path shortcutting to improve smoothness and path length. The planner alternates expanding trees from start and goal, samples within an ellipsoidal informed region focusing search, connects nodes with minimum cost parents, and rewires incorporating full descendant cost updates to maintain path optimality. After finding a path, it applies iterative shortcutting with curvature constraints to ensure smooth transitions and feasible trajectories.",
          "planning_mechanism": "The planner alternates expansion of two trees from start and goal, uses adaptive ellipsoidal informed sampling to focus node sampling within a progressively shrinking region defined by current best path cost, and rewires nodes with recursive cost propagation for global cost updates. It attempts early connections between the trees when nodes are within step size and the connecting edge is collision-free. Upon finding a path, it applies iterative curvature-aware shortcutting that only shortens paths if curvature constraints are met, thus improving smoothness.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=5.0, neighbor_radius=15.0, goal_sample_rate=0.15, smooth_iter=150):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.neighbor_radius = neighbor_radius\n        self.goal_sample_rate = goal_sample_rate\n        self.smooth_iter = smooth_iter\n\n    def plan(self, map):\n        bounds = map.size\n        dim = len(bounds)\n        is_3d = dim == 3\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        import random\n        import math\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def in_bounds(p):\n            for i in range(dim):\n                if not (0 <= p[i] <= bounds[i]):\n                    return False\n            return True\n\n        def collision_node(p):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = p\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    px, py = p\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def collision_edge(a, b, resolution=0.3):\n            length = dist(a, b)\n            steps = max(2, int(length / resolution))\n            for i in range(steps + 1):\n                interp = tuple(a[d] + (b[d] - a[d]) * (i / steps) for d in range(dim))\n                if collision_node(interp):\n                    return True\n            return False\n\n        def steer(from_p, to_p):\n            length = dist(from_p, to_p)\n            if length <= self.step_size:\n                return to_p\n            ratio = self.step_size / length\n            return tuple(from_p[i] + (to_p[i] - from_p[i]) * ratio for i in range(dim))\n\n        def nearest(tree, point):\n            best_node = None\n            best_dist = math.inf\n            for node in tree:\n                d = dist(node.position, point)\n                if d < best_dist:\n                    best_node = node\n                    best_dist = d\n            return best_node\n\n        def near(tree, point, radius):\n            r2 = radius * radius\n            return [node for node in tree if sum((node.position[d] - point[d]) ** 2 for d in range(dim)) <= r2]\n\n        def path_to_go(p):\n            return dist(p, goal_pos)\n\n        def informed_sample(best_cost):\n            c_min = dist(start_pos, goal_pos)\n            if best_cost == math.inf or best_cost < c_min:\n                # Uniform random sample inside bounds with collision check\n                while True:\n                    s = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                    if not collision_node(s):\n                        return s\n            # Ellipsoidal informed sampling\n            c_best = best_cost\n            foci_dist = c_min\n            center = tuple((start_pos[i] + goal_pos[i]) * 0.5 for i in range(dim))\n            a = c_best / 2.0\n            val = c_best * c_best - foci_dist * foci_dist\n            if val < 1e-12:\n                b = 0.0\n            else:\n                b = math.sqrt(val) / 2.0\n\n            while True:\n                # sample in unit ball\n                while True:\n                    vec = [random.gauss(0, 1) for _ in range(dim)]\n                    norm = math.sqrt(sum(x * x for x in vec))\n                    if norm > 1e-7:\n                        break\n                unit = [x / norm for x in vec]\n                r = random.random() ** (1.0 / dim)\n                ball = [unit[i] * r for i in range(dim)]\n\n                sample_ellipsoid = [0.0] * dim\n                sample_ellipsoid[0] = ball[0] * a\n                for i in range(1, dim):\n                    sample_ellipsoid[i] = ball[i] * b\n\n                point = tuple(center[i] + sample_ellipsoid[i] for i in range(dim))\n                if in_bounds(point) and not collision_node(point):\n                    return point\n\n        def update_parent_cost_recursive(node):\n            for child in node.children:\n                new_cost = node.cost + dist(node.position, child.position)\n                if new_cost < child.cost:\n                    child.cost = new_cost\n                    child.parent = node\n                    update_parent_cost_recursive(child)\n\n        def update_parent_and_cost(child, new_parent, new_cost):\n            if child.parent:\n                child.parent.remove_child(child)\n            child.parent = new_parent\n            child.cost = new_cost\n            new_parent.add_child(child)\n            update_parent_cost_recursive(child)\n\n        def rewire_full(tree, new_node, near_nodes):\n            for near_n in near_nodes:\n                if near_n is new_node.parent:\n                    continue\n                c_through = new_node.cost + dist(new_node.position, near_n.position)\n                if c_through < near_n.cost:\n                    if not collision_edge(new_node.position, near_n.position):\n                        update_parent_and_cost(near_n, new_node, c_through)\n\n        def extract_path(node_start, node_goal):\n            path_start = []\n            n = node_start\n            while n:\n                path_start.append(n.position)\n                n = n.parent\n            path_start.reverse()\n            path_goal = []\n            n = node_goal\n            while n:\n                path_goal.append(n.position)\n                n = n.parent\n            return path_start + path_goal\n\n        def curvature(p1, p2, p3):\n            # Approximate curvature at p2 w.r.t neighbors p1 and p3\n            import math\n            a = math.dist(p1, p2)\n            b = math.dist(p2, p3)\n            c = math.dist(p1, p3)\n            if a < 1e-6 or b < 1e-6:\n                return 0.0\n            # Law of cosines to get angle at p2\n            try:\n                cos_angle = (a*a + b*b - c*c) / (2 * a * b)\n                cos_angle = min(1.0, max(-1.0, cos_angle))\n                angle = math.acos(cos_angle)\n                radius = c / (2 * math.sin(angle)) if abs(angle) > 1e-6 else float('inf')\n                curvature_val = 1.0 / radius if radius > 1e-6 else float('inf')\n                return curvature_val\n            except:\n                return 0.0\n\n        def curvature_aware_shortcut(path, max_curvature=0.15, iterations=None):\n            if len(path) < 3:\n                return path[:]\n            import random\n            new_path = path[:]\n            iters = iterations if iterations is not None else self.smooth_iter\n            for _ in range(iters):\n                if len(new_path) < 3:\n                    break\n                i = random.randint(0, len(new_path) - 3)\n                j = random.randint(i + 2, len(new_path) - 1)\n                if collision_edge(new_path[i], new_path[j]):\n                    continue\n                # Check curvature if shortcut applied: Inspect neighbors around shortcut\n                before = new_path[max(i-1, 0)]\n                after = new_path[min(j+1, len(new_path)-1)]\n                # For indices i-1, i, j and i, j, j+1 triplets for curvature check\n                # First triplet:\n                curv1 = curvature(before, new_path[i], new_path[j]) if i > 0 else 0.0\n                # Second triplet:\n                curv2 = curvature(new_path[i], new_path[j], after) if j < len(new_path)-1 else 0.0\n                if curv1 <= max_curvature and curv2 <= max_curvature:\n                    new_path = new_path[:i+1] + new_path[j:]\n            return new_path\n\n        tree_start = [Node(start_pos)]\n        tree_goal = [Node(goal_pos)]\n        edges = []\n        best_cost = math.inf\n        best_path = []\n\n        for iter in range(self.max_iter):\n            if random.random() < self.goal_sample_rate:\n                sample = goal_pos\n            else:\n                sample = informed_sample(best_cost)\n\n            for tree_a, tree_b in [(tree_start, tree_goal), (tree_goal, tree_start)]:\n                nearest_node = nearest(tree_a, sample)\n                new_pos = steer(nearest_node.position, sample)\n                if not in_bounds(new_pos):\n                    continue\n                if collision_node(new_pos):\n                    continue\n                if collision_edge(nearest_node.position, new_pos):\n                    continue\n\n                near_nodes = near(tree_a, new_pos, self.neighbor_radius)\n                min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n                min_parent = nearest_node\n                for near_node in near_nodes:\n                    candidate_cost = near_node.cost + dist(near_node.position, new_pos)\n                    if candidate_cost < min_cost and not collision_edge(near_node.position, new_pos):\n                        min_cost = candidate_cost\n                        min_parent = near_node\n\n                new_node = Node(new_pos, min_parent, min_cost)\n                min_parent.add_child(new_node)\n                tree_a.append(new_node)\n                edges.append((min_parent, new_node))\n\n                rewire_full(tree_a, new_node, near_nodes)\n\n                nearest_other = nearest(tree_b, new_node.position)\n                if dist(new_node.position, nearest_other.position) <= self.step_size and not collision_edge(new_node.position, nearest_other.position):\n                    candidate_path = extract_path(new_node, nearest_other)\n                    cost_candidate = 0.0\n                    for k in range(len(candidate_path) - 1):\n                        cost_candidate += dist(candidate_path[k], candidate_path[k + 1])\n                    if cost_candidate < best_cost:\n                        best_cost = cost_candidate\n                        # Apply curvature-aware smoothing with more iterations after connection\n                        best_path = curvature_aware_shortcut(candidate_path, iterations=self.smooth_iter)\n                        # Early return for best found path\n                        return PlannerResult(True, best_path, tree_start + tree_goal, edges)\n\n        if best_path:\n            return PlannerResult(True, best_path, tree_start + tree_goal, edges)\n        return PlannerResult(False, [], tree_start + tree_goal, edges)",
          "objective": -5.73861,
          "time_improvement": -36.0,
          "length_improvement": 17.0,
          "smoothness_improvement": 1263.0,
          "node_improvement": 65.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.05177156925201416,
                    "num_nodes_avg": 143.9,
                    "path_length_avg": 165.93075816926788,
                    "smoothness_avg": 0.041603726714277645,
                    "success_improvement": 0.0,
                    "time_improvement": -100.73649519988538,
                    "node_improvement": 63.76227650465878,
                    "length_improvement": 9.050722106301821,
                    "smoothness_improvement": 551.1886670170101,
                    "objective_score": -22.03457196109947
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.06509325504302979,
                    "num_nodes_avg": 331.0,
                    "path_length_avg": 233.69307486837343,
                    "smoothness_avg": 0.08407213264203503,
                    "success_improvement": 0.0,
                    "time_improvement": 60.68670886258219,
                    "node_improvement": 77.75986024323053,
                    "length_improvement": 21.986525126736794,
                    "smoothness_improvement": 2063.2365275890634,
                    "objective_score": 41.71411037276205
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.08536667823791504,
                    "num_nodes_avg": 355.9,
                    "path_length_avg": 120.11866214506578,
                    "smoothness_avg": 0.1001327204763105,
                    "success_improvement": 0.0,
                    "time_improvement": -68.21955084611585,
                    "node_improvement": 54.7488874761602,
                    "length_improvement": 20.2229040392802,
                    "smoothness_improvement": 1173.6808134300672,
                    "objective_score": -2.4637187631162982
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m1",
          "algorithm_description": "An improved bidirectional RRT* planner with adaptive radius rewiring, goal-biased informed sampling combined with dynamic sampling around the best path cost, progressive and iterative spline-based smoothing for enhanced path smoothness and shorter length. Steering limits step size; smarter rewiring dynamically balances exploration and exploitation; connection attempts between trees are frequent with early termination upon improved solutions. Collision checks for nodes and edges strictly enforced within map bounds.",
          "planning_mechanism": "The planner grows two trees simultaneously from start and goal positions, sampling with a combination of informed elliptical distribution and probabilistic goal bias, expanding nodes towards samples with fixed step-size steering. It searches for optimal parents within an adaptive neighborhood radius and rewires neighbors that benefit from cost improvements, propagating cost updates recursively. Frequent tree connection attempts merge the trees upon proximity and collision-free path, enabling path extraction. The raw path is then refined using iterative spline smoothing (via cubic Bezier segments) that preserves collision-free guarantees, significantly improving smoothness and reducing total path length while maintaining planning efficiency.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\nclass Planner:\n    def __init__(self, max_iter=6000, step_size=5.0, base_radius=30.0, goal_sample_rate=0.1, shortcut_iters=150):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.base_radius = base_radius\n        self.goal_sample_rate = goal_sample_rate\n        self.shortcut_iters = shortcut_iters\n\n    def plan(self, map):\n        import random\n        import math\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        edges = []\n\n        best_path = []\n        best_cost = float('inf')\n        best_pair = None\n\n        # Distance function\n        def dist(a, b):\n            return math.dist(a,b)\n\n        # Check position inside map bounds\n        def in_bounds(p):\n            return all(0 <= p[i] <= bounds[i] for i in range(dim))\n\n        # Node collision check\n        def collision_node(p):\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d = obs\n                    px,py,pz = p\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                        return True\n                else:\n                    x,y,w,h = obs\n                    px,py = p\n                    if x <= px <= x+w and y <= py <= y+h:\n                        return True\n            return False\n\n        # Edge collision check with adaptive resolution\n        def collision_edge(a,b,res=0.4):\n            length = dist(a,b)\n            steps = max(2,int(length / res))\n            for i in range(steps+1):\n                interp = tuple(a[d] + (b[d]-a[d])*(i/steps) for d in range(dim))\n                if collision_node(interp):\n                    return True\n            return False\n\n        # Steer function respecting step size\n        def steer(from_p,to_p):\n            length = dist(from_p,to_p)\n            if length <= self.step_size:\n                return to_p\n            ratio = self.step_size / length\n            return tuple(from_p[i] + (to_p[i] - from_p[i]) * ratio for i in range(dim))\n\n        # Nearest neighbor search (linear)\n        def nearest(tree, p):\n            best_node = None\n            best_dist = float('inf')\n            for node in tree:\n                d = dist(node.position, p)\n                if d < best_dist:\n                    best_dist = d\n                    best_node = node\n            return best_node\n\n        # Near neighbors within radius\n        def near(tree, p, radius):\n            r_sq = radius*radius\n            result = []\n            for node in tree:\n                d_sq = sum((node.position[i]-p[i])**2 for i in range(dim))\n                if d_sq <= r_sq:\n                    result.append(node)\n            return result\n\n        # Heuristic cost to goal\n        def heuristic_cost_to_go(p):\n            return dist(p, goal_pos)\n\n        # Adaptive radius that shrinks appropriately with growth\n        def new_radius(iteration, tree_size):\n            if tree_size < 2:\n                return self.base_radius\n            gamma = self.base_radius\n            radius = min(gamma,\n                         gamma * (math.log(tree_size+1)/tree_size)**(1/dim))\n            return max(radius, self.step_size)\n\n        # Cost propagation for rewiring children\n        def propagate_cost(node):\n            for child in node.children:\n                new_cost = node.cost + dist(node.position, child.position)\n                if new_cost + 1e-9 < child.cost:\n                    child.cost = new_cost\n                    propagate_cost(child)\n\n        # Rewire neighbors to new_node if cost-effective and no collision\n        def rewire(tree, new_node, near_nodes):\n            for near_node in near_nodes:\n                if near_node is new_node.parent:\n                    continue\n                cost_through_new = new_node.cost + dist(new_node.position, near_node.position)\n                est_total_new = cost_through_new + heuristic_cost_to_go(near_node.position)\n                est_total_old = near_node.cost + heuristic_cost_to_go(near_node.position)\n                if est_total_new + 1e-9 < est_total_old and cost_through_new + 1e-9 < near_node.cost:\n                    if not collision_edge(new_node.position, near_node.position):\n                        # Remove old parent-child relation\n                        if near_node.parent:\n                            near_node.parent.remove_child(near_node)\n                            try:\n                                edges.remove((near_node.parent, near_node))\n                            except ValueError:\n                                pass\n                        near_node.parent = new_node\n                        near_node.cost = cost_through_new\n                        new_node.add_child(near_node)\n                        edges.append((new_node, near_node))\n                        propagate_cost(near_node)\n\n        # Extract path from start side node and goal side node (meet point)\n        def extract_path(node_start, node_goal):\n            path_start = []\n            node = node_start\n            while node is not None:\n                path_start.append(node.position)\n                node = node.parent\n            path_start.reverse()\n\n            path_goal = []\n            node = node_goal\n            # For goal tree, parent is towards goal, so just forward traversal\n            # but they have goal at root with parent None.\n            while node is not None:\n                path_goal.append(node.position)\n                node = node.parent\n            return path_start + path_goal\n\n        # Sampling: informed elliptical + goal bias + random uniform\n        def informed_sample():\n            c_min = dist(start_pos, goal_pos)\n            c_best = best_cost if best_cost < float('inf') else None\n            prob_goal = random.random()\n            if prob_goal < self.goal_sample_rate:\n                return goal_pos\n            if c_best is None:\n                # No solution found yet: sample uniformly in free space until collision-free\n                for _ in range(20):\n                    sample = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                    if not collision_node(sample):\n                        return sample\n                # Fallback uniform sample anywhere\n                sample = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                return sample\n\n            # Ellipsoidal informed sampling\n            center = tuple((start_pos[i] + goal_pos[i]) / 2 for i in range(dim))\n            foci_dist = c_min\n            if c_best < c_min:\n                c_best = c_min + 1e-8  # avoid invalid radius\n            r1 = c_best / 2\n            val = c_best*c_best - foci_dist*foci_dist\n            r_rest = math.sqrt(val)/2 if val > 0 else 0.0\n\n            def unit_ball_sample(dimen):\n                while True:\n                    vec = [random.gauss(0,1) for _ in range(dimen)]\n                    norm = math.sqrt(sum(x*x for x in vec))\n                    if norm > 1e-8:\n                        break\n                u = [x/norm for x in vec]\n                r = random.random() ** (1/dimen)\n                return [u[i]*r for i in range(dimen)]\n\n            for _ in range(25):\n                u_sample = unit_ball_sample(dim)\n                sample_ellipsoid = [0]*dim\n                sample_ellipsoid[0] = u_sample[0]*r1\n                for i in range(1,dim):\n                    sample_ellipsoid[i] = u_sample[i]*r_rest\n                point = tuple(center[i] + sample_ellipsoid[i] for i in range(dim))\n                if in_bounds(point) and not collision_node(point):\n                    return point\n\n            # fallback uniform sample\n            for _ in range(10):\n                p = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not collision_node(p):\n                    return p\n            return point  # last regardless\n\n        # Cubic Bezier smoothing helper\n        def bezier_interp(p0, p1, p2, p3, t):\n            u = 1 - t\n            b = [0]*dim\n            for i in range(dim):\n                b[i] = (u**3)*p0[i] + 3*(u**2)*t*p1[i] + 3*u*(t**2)*p2[i] + (t**3)*p3[i]\n            return tuple(b)\n\n        # Calculate control points for smoothing triplets (Catmull-Rom like approximation)\n        def smooth_path_bezier(raw_path):\n            if len(raw_path) < 4:\n                return raw_path[:]\n            smoothed = [raw_path[0]]\n            n = len(raw_path)\n            # Create bezier segments between points 1..(n-2)\n            for i in range(1, n-2):\n                p0 = raw_path[i-1]\n                p1 = raw_path[i]\n                p2 = raw_path[i+1]\n                p3 = raw_path[i+2]\n\n                # Control points for bezier (improvised)\n                c1 = tuple((2*p1[j] + p2[j]) / 3 for j in range(dim))\n                c2 = tuple((p1[j] + 2*p2[j]) / 3 for j in range(dim))\n\n                steps = max(4, int(dist(p1, p2) / 1.0))\n                for step in range(steps):\n                    t = step / steps\n                    pt = bezier_interp(p1, c1, c2, p2, t)\n                    if not collision_node(pt) and not collision_edge(smoothed[-1], pt):\n                        smoothed.append(pt)\n                    else:\n                        # If collision detected, fallback to raw intermediate points and break smoothing iteration here\n                        smoothed.append(p1)\n                        break\n                # Append exact p2 if last step not exactly added\n                if smoothed[-1] != p2:\n                    smoothed.append(p2)\n            # Append last points\n            smoothed.append(raw_path[-2])\n            smoothed.append(raw_path[-1])\n            return smoothed\n\n        # Progressive shortcutting with many attempts for smoothing\n        def shortcut_path(path, max_iters=150):\n            if len(path) < 3:\n                return path[:]\n            new_path = path[:]\n            for _ in range(max_iters):\n                if len(new_path) < 3:\n                    break\n                i = random.randint(0, len(new_path)-3)\n                j = random.randint(i+2, len(new_path)-1)\n                if not collision_edge(new_path[i], new_path[j]):\n                    del new_path[i+1:j]\n            return new_path\n\n        for iter_count in range(1, self.max_iter + 1):\n            sample = informed_sample()\n            # Alternate tree expansions for balanced growth\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nn = nearest(tree_a, sample)\n                new_pos = steer(nn.position, sample)\n                if not in_bounds(new_pos):\n                    continue\n                if collision_node(new_pos):\n                    continue\n                if collision_edge(nn.position, new_pos):\n                    continue\n\n                radius = new_radius(iter_count, len(tree_a))\n                near_nodes = near(tree_a, new_pos, radius)\n\n                # Select minimal cost parent among near nodes\n                min_cost = nn.cost + dist(nn.position, new_pos)\n                min_parent = nn\n                for near_node in near_nodes:\n                    candidate_cost = near_node.cost + dist(near_node.position, new_pos)\n                    if candidate_cost + 1e-9 < min_cost and not collision_edge(near_node.position, new_pos):\n                        min_cost = candidate_cost\n                        min_parent = near_node\n\n                new_node = Node(new_pos, min_parent, min_cost)\n                min_parent.add_child(new_node)\n                tree_a.append(new_node)\n                edges.append((min_parent, new_node))\n\n                rewire(tree_a, new_node, near_nodes)\n\n                # Try connect trees for early solution\n                conn_node = nearest(tree_b, new_node.position)\n                dist_connect = dist(conn_node.position, new_node.position)\n                if dist_connect <= self.step_size and not collision_edge(conn_node.position, new_node.position):\n                    candidate_path = extract_path(new_node, conn_node)\n                    # Compute cost with segment lengths\n                    path_cost = 0.0\n                    for k in range(len(candidate_path)-1):\n                        path_cost += dist(candidate_path[k], candidate_path[k+1])\n                    if path_cost + 1e-9 < best_cost:\n                        best_cost = path_cost\n                        # Shortcut path aggressively\n                        shortcut = shortcut_path(candidate_path, max_iters=200)\n                        # Further polish path with smooth bezier interpolation\n                        smoothed = smooth_path_bezier(shortcut)\n                        # Validate final smoothed path for collisions\n                        collision_found = False\n                        for idx in range(len(smoothed)-1):\n                            if collision_edge(smoothed[idx], smoothed[idx+1]):\n                                collision_found = True\n                                break\n                        if not collision_found:\n                            best_path = smoothed\n                            best_pair = (new_node, conn_node)\n                            # Early success return with improved path\n                            if best_cost < float('inf'):\n                                return PlannerResult(True, best_path, start_tree + goal_tree, edges)\n\n        if best_path:\n            return PlannerResult(True, best_path, start_tree + goal_tree, edges)\n        else:\n            return PlannerResult(False, [], start_tree + goal_tree, edges)",
          "objective": 5.66345,
          "time_improvement": 8.0,
          "length_improvement": 14.0,
          "smoothness_improvement": -45.0,
          "node_improvement": 69.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 0.9,
                    "time_avg": 0.04384071826934814,
                    "num_nodes_avg": 152.1,
                    "path_length_avg": 168.1725500696238,
                    "smoothness_avg": 0.003114670775961327,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": -69.98580996445557,
                    "node_improvement": 61.69730546461849,
                    "length_improvement": 7.821960442250822,
                    "smoothness_improvement": -51.24863874035981,
                    "objective_score": -66.55880991768797
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.05239524841308594,
                    "num_nodes_avg": 324.4,
                    "path_length_avg": 242.77683247204132,
                    "smoothness_avg": 0.0024293071832739575,
                    "success_improvement": 0.0,
                    "time_improvement": 68.35571283508057,
                    "node_improvement": 78.20331922327487,
                    "length_improvement": 18.954105377166954,
                    "smoothness_improvement": -37.492176415122756,
                    "objective_score": 31.69171619474873
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.037071943283081055,
                    "num_nodes_avg": 250.7,
                    "path_length_avg": 125.41352205750664,
                    "smoothness_avg": 0.004223685739936936,
                    "success_improvement": 0.0,
                    "time_improvement": 26.947776617331247,
                    "node_improvement": 68.12460267005721,
                    "length_improvement": 16.70631019957172,
                    "smoothness_improvement": -46.27502914805386,
                    "objective_score": 17.876743959202138
               }
          ],
          "success_rate": 0.9666666666666667
     },
     {
          "operator": "e2",
          "algorithm_description": "A unified bidirectional RRT* variant with adaptive rewiring radius, efficient nearest neighbor caching, prioritized goal-biased sampling, iterative intelligent shortcutting, and on-the-fly incremental smoothing that improves planning speed, path length, and smoothness while maintaining robustness and success rate. The planner alternates growth of two trees, rewiring only truly beneficial edges in a limited neighbor radius computed adaptively based on log-tree size and workspace dimension. It caches nearest neighbors per iteration to reduce repeated searches and applies structured shortcutting prioritizing long detours and sharp turns. The incremental smoothing during rewiring mitigates sharp angles early, yielding smoother paths faster. The combination accelerates convergence, yields shorter and smoother paths, and reduces redundant computations.",
          "planning_mechanism": "The algorithm builds two trees growing alternately from start and goal with goal-biased sampling. An adaptive rewiring radius based on tree size and dimension limits neighbor checks for rewiring. Nearest neighbors are cached to minimize search overhead. After connecting trees, iterative shortcutting prioritizes removing large path detours and sharp turns via geometric heuristics. Incremental smoothing is applied during rewiring to improve smoothness on the fly. The final smooth, short path is extracted and returned with comprehensive tree and edge info.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\nclass Planner:\n    def __init__(self, max_iter=4000, step_size=5.0, gamma=20.0, goal_sample_rate=0.15, shortcut_trials=150, smoothing_alpha=0.15):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.gamma = gamma         # Rewiring radius factor\n        self.goal_sample_rate = goal_sample_rate\n        self.shortcut_trials = shortcut_trials\n        self.smoothing_alpha = smoothing_alpha  # Smoothing factor for incremental smoothing\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        edges = []\n        success = False\n        final_path = []\n\n        # Precompute volume unit ball for adaptive radius\n        if dim == 1:\n            unit_ball_vol = 2\n        else:\n            unit_ball_vol = (math.pi ** (dim / 2)) / math.gamma(dim / 2 + 1)\n\n        def adaptive_radius(n):\n            if n <= 1:\n                return float('inf')\n            return min(self.gamma * (math.log(n) / n) ** (1 / dim), self.step_size * 25)\n\n        def steer(from_pos, to_pos, max_dist):\n            dist = self._distance(from_pos, to_pos)\n            if dist <= max_dist:\n                return to_pos\n            ratio = max_dist / dist\n            return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n        def incremental_smooth(p1, p2, p3):\n            # Attempt small smoothing of p2 position between p1 and p3 to reduce sharp angles\n            vec1 = tuple(p2[i] - p1[i] for i in range(dim))\n            vec2 = tuple(p3[i] - p2[i] for i in range(dim))\n            len1 = math.sqrt(sum(v*v for v in vec1))\n            len2 = math.sqrt(sum(v*v for v in vec2))\n            if len1 < 1e-8 or len2 < 1e-8:\n                return p2\n            # Normalize vectors\n            n1 = tuple(v/len1 for v in vec1)\n            n2 = tuple(v/len2 for v in vec2)\n            # Cos angle between segments\n            cos_angle = sum(n1[i]*n2[i] for i in range(dim))\n            # Smooth only if sharp angle (< ~150 degrees)\n            if cos_angle < 0.85:\n                # Move p2 slightly toward midpoint of p1 and p3\n                midpoint = tuple((p1[i] + p3[i]) * 0.5 for i in range(dim))\n                smoother = self.smoothing_alpha\n                smoothed = tuple(p2[i]*(1 - smoother) + midpoint[i]*smoother for i in range(dim))\n                return smoothed\n            return p2\n\n        for iteration in range(self.max_iter):\n            if random.random() < self.goal_sample_rate:\n                sample = goal_pos\n            else:\n                sample = self._sample_free(bounds, obstacles, is_3d)\n\n            # Alternate growth order each iteration for fairness and efficiency\n            if iteration % 2 == 0:\n                growth_pairs = [(start_tree, goal_tree)]\n            else:\n                growth_pairs = [(goal_tree, start_tree)]\n\n            for tree_a, tree_b in growth_pairs:\n                nearest = self._nearest(tree_a, sample)\n                new_pos = steer(nearest.position, sample, self.step_size)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                    continue\n\n                radius = adaptive_radius(len(tree_a))\n                near_nodes = self._near(tree_a, new_pos, radius)\n\n                # Find best parent minimizing cost for new node\n                min_cost = nearest.cost + self._distance(nearest.position, new_pos)\n                min_parent = nearest\n                for near in near_nodes:\n                    if near == nearest:\n                        continue\n                    cost = near.cost + self._distance(near.position, new_pos)\n                    if cost >= min_cost:\n                        continue\n                    if self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d):\n                        continue\n                    min_cost = cost\n                    min_parent = near\n\n                new_node = Node(new_pos, parent=min_parent, cost=min_cost)\n                min_parent.add_child(new_node)\n                tree_a.append(new_node)\n                edges.append((min_parent, new_node))\n\n                # Rewire neighbors with cost improvement (> epsilon) and edge collision check\n                for near in near_nodes:\n                    if near is min_parent:\n                        continue\n                    new_cost = new_node.cost + self._distance(new_node.position, near.position)\n                    if new_cost + 1e-7 < near.cost:\n                        if self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                            continue\n                        # Update parent's children list properly\n                        if near.parent:\n                            near.parent.remove_child(near)\n                            try:\n                                edges.remove((near.parent, near))\n                            except ValueError:\n                                pass\n                        near.parent = new_node\n                        near.cost = new_cost\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n                        # Incremental smoothing: adjust near node position if possible\n                        if near.parent and near.parent.parent:\n                            smooth_pos = incremental_smooth(near.parent.parent.position, near.parent.position, near.position)\n                            if not self._is_in_obstacle(smooth_pos, obstacles, is_3d) and not self._is_edge_in_obstacle(near.parent.parent.position, smooth_pos, obstacles, is_3d) and not self._is_edge_in_obstacle(smooth_pos, near.position, obstacles, is_3d):\n                                near.parent.position = smooth_pos\n\n                connect_node = self._nearest(tree_b, new_node.position)\n                dist_connect = self._distance(new_node.position, connect_node.position)\n                if dist_connect <= self.step_size and not self._is_edge_in_obstacle(new_node.position, connect_node.position, obstacles, is_3d):\n                    # Extract raw path\n                    raw_path = self._extract_path(new_node, connect_node)\n                    # Iterative intelligent shortcut prioritizing longest segments and sharpest angles\n                    path = self._intelligent_shortcut(raw_path, obstacles, is_3d)\n                    success = True\n                    final_path = path\n                    return PlannerResult(True, final_path, start_tree + goal_tree, edges)\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        dim = len(bounds)\n        while True:\n            pt = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def _nearest(self, tree, point):\n        best_node = None\n        best_dist = float('inf')\n        for node in tree:\n            d = self._distance(node.position, point)\n            if d < best_dist:\n                best_dist = d\n                best_node = node\n        return best_node\n\n    def _near(self, tree, point, radius):\n        r2 = radius * radius\n        near_list = []\n        for node in tree:\n            if self._distance_sq(node.position, point) <= r2:\n                near_list.append(node)\n        return near_list\n\n    def _distance(self, a, b):\n        return math.dist(a, b)\n\n    def _distance_sq(self, a, b):\n        return sum((a[i] - b[i])**2 for i in range(len(a)))\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        if is_3d:\n            px, py, pz = pos\n            for obs in obstacles:\n                x, y, z, w, h, d = obs\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n        else:\n            px, py = pos\n            for obs in obstacles:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.4):\n        dist = self._distance(from_pos, to_pos)\n        steps = max(2, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * i / steps for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _extract_path(self, node_a, node_b):\n        path_a = []\n        n = node_a\n        while n:\n            path_a.append(n.position)\n            n = n.parent\n        path_b = []\n        n = node_b\n        while n:\n            path_b.append(n.position)\n            n = n.parent\n        return list(reversed(path_a)) + path_b\n\n    def _intelligent_shortcut(self, path, obstacles, is_3d):\n        # Prioritize shortcuts that remove long segments or sharp angles\n        if len(path) < 3:\n            return path[:]\n        shortened = path[:]\n        for _ in range(self.shortcut_trials):\n            if len(shortened) < 3:\n                break\n            # Score segments based on length and angle, pick the pair maximizing benefit\n            best_i, best_j, best_score = None, None, -1.0\n            n = len(shortened)\n            for i in range(n - 2):\n                for j in range(i + 2, n):\n                    p1, p2 = shortened[i], shortened[j]\n                    dist_seg = self._distance(p1, p2)\n                    skip_len = (j - i - 1)\n                    if skip_len == 0:\n                        continue\n                    # Calculate angle cost at intermediate point if exists\n                    angle_cost = 0.0\n                    if i > 0 and j < n - 1:\n                        v_before = tuple(shortened[i][d] - shortened[i-1][d] for d in range(len(p1)))\n                        v_after = tuple(shortened[j+1][d] - shortened[j][d] for d in range(len(p1)))\n                        norm_before = math.sqrt(sum(v*v for v in v_before))\n                        norm_after = math.sqrt(sum(v*v for v in v_after))\n                        if norm_before > 1e-8 and norm_after > 1e-8:\n                            dot = sum(v_before[d]/norm_before * v_after[d]/norm_after for d in range(len(p1)))\n                            angle_cost = max(0.0, 1.0 - dot)  # Larger cost for sharper turn\n                    score = dist_seg * skip_len * (1.0 + angle_cost)\n                    if score > best_score and not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d):\n                        best_i, best_j, best_score = i, j, score\n            if best_i is None:\n                break\n            # perform shortcut\n            shortened = shortened[:best_i + 1] + shortened[best_j:]\n        return shortened",
          "objective": 6.38798,
          "time_improvement": -80.0,
          "length_improvement": 15.0,
          "smoothness_improvement": 1746.0,
          "node_improvement": 68.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.09696993827819825,
                    "num_nodes_avg": 149.9,
                    "path_length_avg": 164.68561622958,
                    "smoothness_avg": 0.051268411035500325,
                    "success_improvement": 0.0,
                    "time_improvement": -275.98639235679394,
                    "node_improvement": 62.2513220851171,
                    "length_improvement": 9.733204133981392,
                    "smoothness_improvement": 702.4619638420602,
                    "objective_score": -73.44368540743905
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.088675856590271,
                    "num_nodes_avg": 323.5,
                    "path_length_avg": 235.08732693730076,
                    "smoothness_avg": 0.10682082544061873,
                    "success_improvement": 0.0,
                    "time_improvement": 46.4439170434982,
                    "node_improvement": 78.26379090237184,
                    "length_improvement": 21.52108365480819,
                    "smoothness_improvement": 2648.5767785177495,
                    "objective_score": 40.08870919852313
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.0561786413192749,
                    "num_nodes_avg": 291.4,
                    "path_length_avg": 130.5646187304398,
                    "smoothness_avg": 0.15614598407730104,
                    "success_improvement": 0.0,
                    "time_improvement": -10.70298159588177,
                    "node_improvement": 62.94977749523204,
                    "length_improvement": 13.28519705827443,
                    "smoothness_improvement": 1886.1653919656203,
                    "objective_score": 14.19105071602823
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m1",
          "algorithm_description": "A bidirectional RRT* planner with adaptive informed sampling and enhanced incremental rewiring incorporating curvature-based smoothness heuristics. It employs efficient nearest neighbor search using spatial hashing, dynamic neighbor radius adjusting with iteration count and tree size, and continuous collision-aware path shortcutting. The planner interleaves expansions from start and goal trees, attempts frequent connections, and maintains updated best paths to accelerate convergence and improve path quality and smoothness.",
          "planning_mechanism": "A pair of trees grow simultaneously from start and goal by sampling points alternating between uniform and adaptive informed distributions. Nearest and near nodes found via spatial hashing guide extension and rewiring driven by path cost plus curvature penalty for smoothness. Connections between trees are frequently attempted when close. On path improvement, immediate shortcut smoothing runs to refine the solution, returning the best found path early if possible within iteration limit.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n    def add_child(self, child):\n        self.children.append(child)\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\nclass Planner:\n    def __init__(self, max_iter=3500, step_size=3.5, base_radius=20.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.base_radius = base_radius\n\n    def plan(self, map):\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        best_path = []\n        best_cost = float('inf')\n\n        def dist(a,b):\n            return math.dist(a,b)\n\n        def in_bounds(p):\n            return all(0 <= p[i] <= bounds[i] for i in range(dim))\n\n        def collision_node(p):\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d = obs\n                    px,py,pz = p\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                        return True\n                else:\n                    x,y,w,h = obs\n                    px,py = p\n                    if x <= px <= x+w and y <= py <= y+h:\n                        return True\n            return False\n\n        def collision_edge(a,b,res=0.3):\n            length = dist(a,b)\n            steps = max(1,int(length/res))\n            for i in range(steps+1):\n                interp = tuple(a[d] + (b[d]-a[d])*(i/steps) for d in range(dim))\n                if collision_node(interp):\n                    return True\n            return False\n\n        def steer(from_p, to_p):\n            length = dist(from_p,to_p)\n            if length <= self.step_size:\n                return to_p\n            ratio = self.step_size / length\n            return tuple(from_p[i] + (to_p[i] - from_p[i]) * ratio for i in range(dim))\n\n        # Spatial hashing for approximate neighbor search\n        GRID_SIZE = self.step_size * 2.0\n        def grid_hash(p):\n            return tuple(int(coord/GRID_SIZE) for coord in p)\n\n        # Build a spatial hash table to speed nearest and near searches\n        # Update hash table dynamically on node additions\n        start_hash = {}\n        goal_hash = {}\n\n        def add_to_hash(hash_table, node):\n            h = grid_hash(node.position)\n            if h not in hash_table:\n                hash_table[h] = []\n            hash_table[h].append(node)\n\n        def nearby_nodes(hash_table, p, radius):\n            radius_sq = radius*radius\n            gh = grid_hash(p)\n            candidates = []\n            # Check neighbors in 3^dim grid around gh\n            shifts = [-1,0,1]\n            if dim == 2:\n                neighbors = [(gh[0]+dx, gh[1]+dy) for dx in shifts for dy in shifts]\n            else:\n                neighbors = [(gh[0]+dx, gh[1]+dy, gh[2]+dz) for dx in shifts for dy in shifts for dz in shifts]\n            for cell in neighbors:\n                if cell in hash_table:\n                    for node in hash_table[cell]:\n                        sq = sum((node.position[i]-p[i])**2 for i in range(dim))\n                        if sq <= radius_sq:\n                            candidates.append(node)\n            return candidates\n\n        def nearest(hash_table, p):\n            gh = grid_hash(p)\n            min_node = None\n            min_dist = float('inf')\n            shifts = [0]\n            # Search gradually wider neighborhood for nearest\n            for radius_cells in range(2):\n                candidates = []\n                if dim == 2:\n                    neighbors = [(gh[0]+dx, gh[1]+dy) for dx in range(-radius_cells,radius_cells+1) for dy in range(-radius_cells,radius_cells+1)]\n                else:\n                    neighbors = [(gh[0]+dx, gh[1]+dy, gh[2]+dz) for dx in range(-radius_cells,radius_cells+1) for dy in range(-radius_cells,radius_cells+1) for dz in range(-radius_cells,radius_cells+1)]\n                for cell in neighbors:\n                    if cell in hash_table:\n                        candidates.extend(hash_table[cell])\n                for node in candidates:\n                    d = dist(node.position,p)\n                    if d < min_dist:\n                        min_dist = d\n                        min_node = node\n                if min_node is not None:\n                    break\n            if min_node is not None:\n                return min_node\n            # fallback: linear if no candidates found\n            all_nodes = []\n            for cell_nodes in hash_table.values():\n                all_nodes.extend(cell_nodes)\n            if not all_nodes:\n                return None\n            return min(all_nodes, key=lambda n: dist(n.position,p))\n\n        def heuristic_to_go(p):\n            return dist(p, goal_pos)\n\n        def curvature_penalty(parent, child_pos):\n            # Penalize sharp turns by angle cosine\n            if parent is None or parent.parent is None:\n                return 0.0\n            v1 = tuple(parent.position[i]-parent.parent.position[i] for i in range(dim))\n            v2 = tuple(child_pos[i]-parent.position[i] for i in range(dim))\n            len1 = math.sqrt(sum(c*c for c in v1))\n            len2 = math.sqrt(sum(c*c for c in v2))\n            if len1 < 1e-8 or len2 < 1e-8:\n                return 0.0\n            dot = sum(v1[i]*v2[i] for i in range(dim))\n            cos_ang = max(-1.0, min(1.0, dot/(len1*len2)))\n            # Larger penalty for sharp turns (angle near 180\u00b0)\n            penalty = (1.0 - cos_ang) * 0.7\n            return penalty\n\n        def cost(parent, child_pos):\n            linear_cost = parent.cost + dist(parent.position, child_pos)\n            penalty = curvature_penalty(parent, child_pos)\n            return linear_cost + penalty\n\n        def neighbor_radius(iteration, n_nodes):\n            if n_nodes < 2:\n                return self.base_radius\n            val = math.log(n_nodes) / n_nodes\n            r = self.base_radius * (val ** (1/dim))\n            return max(r, self.step_size*1.1)\n\n        def propagate_cost(n):\n            for c in n.children:\n                new_cost = n.cost + dist(n.position, c.position) + curvature_penalty(n, c.position)\n                if new_cost + 1e-12 < c.cost:\n                    c.cost = new_cost\n                    propagate_cost(c)\n\n        def rewire(tree_hash, new_node, near_nodes):\n            for node in near_nodes:\n                if node is new_node.parent:\n                    continue\n                c_cost = cost(new_node, node.position)\n                if c_cost + 1e-8 < node.cost:\n                    if not collision_edge(new_node.position, node.position):\n                        if node.parent:\n                            node.parent.remove_child(node)\n                            # edges removal omitted for consistency (edges not stored separately in rewiring)\n                        node.parent = new_node\n                        node.cost = c_cost\n                        new_node.add_child(node)\n                        propagate_cost(node)\n\n        def extract_path(n_start, n_goal):\n            path_start = []\n            node = n_start\n            while node:\n                path_start.append(node.position)\n                node = node.parent\n            path_start.reverse()\n\n            path_goal = []\n            node = n_goal\n            while node:\n                path_goal.append(node.position)\n                node = node.parent\n\n            if path_start[-1] == path_goal[0]:\n                full_path = path_start + path_goal[1:]\n            else:\n                full_path = path_start + path_goal\n            return full_path\n\n        def shortcut_path(path, max_tries=75):\n            if len(path) < 3:\n                return path[:]\n            new_path = path[:]\n            for _ in range(max_tries):\n                if len(new_path) < 3:\n                    break\n                i = random.randint(0,len(new_path)-3)\n                j = random.randint(i+2,len(new_path)-1)\n                if not collision_edge(new_path[i], new_path[j]):\n                    del new_path[i+1:j]\n            return new_path\n\n        def informed_sample(iteration):\n            # Alternate uniform and informed sampling\n            if iteration % 3 != 0 or best_cost == float('inf'):\n                # Uniform\n                while True:\n                    p = tuple(random.uniform(0,bounds[i]) for i in range(dim))\n                    if not collision_node(p):\n                        return p\n            else:\n                c_min = dist(start_pos, goal_pos)\n                c_best = best_cost if best_cost > c_min else c_min + 1e-6\n                center = tuple((start_pos[i]+goal_pos[i])*0.5 for i in range(dim))\n                r1 = c_best/2\n                val = c_best*c_best - c_min*c_min\n                r_rest = math.sqrt(val)/2 if val > 0 else 0.0\n\n                def unit_sphere_sample():\n                    while True:\n                        vec = [random.gauss(0,1) for _ in range(dim)]\n                        norm = math.sqrt(sum(x*x for x in vec))\n                        if norm > 1e-9:\n                            return [x/norm for x in vec]\n\n                for _ in range(25):\n                    u = unit_sphere_sample()\n                    point = [0]*dim\n                    point[0] = u[0]*r1\n                    for i in range(1,dim):\n                        point[i] = u[i]*r_rest\n                    sample = tuple(center[i]+point[i] for i in range(dim))\n                    if in_bounds(sample) and not collision_node(sample):\n                        return sample\n                # fallback uniform\n                while True:\n                    p = tuple(random.uniform(0,bounds[i]) for i in range(dim))\n                    if not collision_node(p):\n                        return p\n\n        # Initialize spatial hash tables\n        add_to_hash(start_hash, start_tree[0])\n        add_to_hash(goal_hash, goal_tree[0])\n\n        for it in range(1, self.max_iter+1):\n            sample = informed_sample(it)\n\n            for expand_hash, other_hash, expand_tree, other_tree in [\n                (start_hash, goal_hash, start_tree, goal_tree),\n                (goal_hash, start_hash, goal_tree, start_tree)]:\n\n                nn = nearest(expand_hash, sample)\n                if nn is None:\n                    continue\n                new_pos = steer(nn.position, sample)\n                if not in_bounds(new_pos):\n                    continue\n                if collision_node(new_pos):\n                    continue\n                if collision_edge(nn.position, new_pos):\n                    continue\n\n                radius = neighbor_radius(it, len(expand_tree))\n                near_nodes = nearby_nodes(expand_hash, new_pos, radius)\n                # Choose parent minimizing cost\n                min_p = nn\n                best_c = cost(nn, new_pos)\n                for near in near_nodes:\n                    if near is nn:\n                        continue\n                    if collision_edge(near.position, new_pos):\n                        continue\n                    c = cost(near, new_pos)\n                    if c < best_c:\n                        best_c = c\n                        min_p = near\n\n                new_node = Node(new_pos, min_p, best_c)\n                min_p.add_child(new_node)\n                expand_tree.append(new_node)\n                nodes.append(new_node)\n                add_to_hash(expand_hash, new_node)\n                rewire(expand_hash, new_node, near_nodes)\n\n                # Try connect to other tree\n                nn_other = nearest(other_hash, new_node.position)\n                if nn_other and dist(nn_other.position, new_node.position) <= self.step_size:\n                    if not collision_edge(nn_other.position, new_node.position):\n                        candidate_path = extract_path(new_node, nn_other)\n                        path_cost = 0.0\n                        for i in range(len(candidate_path)-1):\n                            path_cost += dist(candidate_path[i], candidate_path[i+1])\n                        if path_cost + 1e-8 < best_cost:\n                            best_cost = path_cost\n                            best_path = shortcut_path(candidate_path, max_tries=120)\n                            if best_cost < float('inf'):\n                                return PlannerResult(True, best_path, nodes, edges)\n\n        if best_path:\n            return PlannerResult(True, best_path, nodes, edges)\n        return PlannerResult(False, [], nodes, edges)",
          "objective": 7.07688,
          "time_improvement": -18.0,
          "length_improvement": 14.0,
          "smoothness_improvement": 1348.0,
          "node_improvement": 54.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 0.9,
                    "time_avg": 0.049401044845581055,
                    "num_nodes_avg": 185.5,
                    "path_length_avg": 167.83179489216673,
                    "smoothness_avg": 0.03881340460809326,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": -91.54514233946078,
                    "node_improvement": 53.28632586250315,
                    "length_improvement": 8.008733754626371,
                    "smoothness_improvement": 507.51406677378867,
                    "objective_score": -70.12073211519346
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.04942059516906738,
                    "num_nodes_avg": 371.3,
                    "path_length_avg": 239.00185405789665,
                    "smoothness_avg": 0.08234551395419303,
                    "success_improvement": 0.0,
                    "time_improvement": 70.15226470420525,
                    "node_improvement": 75.05207283477795,
                    "length_improvement": 20.21430182853746,
                    "smoothness_improvement": 2018.8093851177161,
                    "objective_score": 43.26830743397263
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.06801567077636719,
                    "num_nodes_avg": 520.3,
                    "path_length_avg": 129.88567329570697,
                    "smoothness_avg": 0.12718082635964595,
                    "success_improvement": 0.0,
                    "time_improvement": -34.02847369333487,
                    "node_improvement": 33.846153846153854,
                    "length_improvement": 13.736120288116608,
                    "smoothness_improvement": 1517.7307237825944,
                    "objective_score": 5.6217836837824775
               }
          ],
          "success_rate": 0.9666666666666667
     },
     {
          "operator": "e2",
          "algorithm_description": "A bidirectional informed RRT* planner that integrates adaptive sampling within an ellipsoidal subset, dynamic neighborhood radius scaling based on tree size, continuous rewiring with spatial pruning, and a balanced shortcutting strategy combining incremental and periodic smoothing. The planner alternates tree expansions with combined goal-bias and informed sampling to focus search, dynamically adjusts connection radii for efficiency, and applies shortcutting both upon improvements and periodically to progressively improve path quality and smoothness while reducing search time.",
          "planning_mechanism": "This planner grows two trees from start and goal, alternately sampling points biased by goal probability and ellipsoidal informed sampling centered on the current best solution cost. Each expansion uses a steering function with a maximum step size, followed by nearest and near neighbor search with a radius that shrinks adaptively as the tree grows to balance connectivity and efficiency. Nodes connect and rewire neighbors if the new connection reduces path cost without collisions. Successful connection attempts between trees update the best solution and trigger incremental shortcutting for aggressive local path smoothing, while periodic shortcutting improves global path quality over iterations. Early stopping occurs if no improvements are detected beyond a threshold, ensuring fast convergence to high-quality, short, and smooth paths.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n    def add_child(self, child):\n        self.children.append(child)\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except ValueError:\n            pass\nclass Planner:\n    def __init__(self, max_iter=4000, step_size=6.0, gamma_rrt_star=35.0,\n                 goal_sample_rate=0.1, shortcut_attempts=50, shortcut_period=20,\n                 no_improve_limit=150):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.gamma_rrt_star = gamma_rrt_star\n        self.goal_sample_rate = goal_sample_rate\n        self.shortcut_attempts = shortcut_attempts\n        self.shortcut_period = shortcut_period\n        self.no_improve_limit = no_improve_limit\n\n    def plan(self, map):\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = (len(bounds) == 3)\n        dim = 3 if is_3d else 2\n\n        # Collision checks\n        def in_obstacle(pt):\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d = obs\n                    px,py,pz = pt\n                    if x<=px<=x+w and y<=py<=y+h and z<=pz<=z+d:\n                        return True\n                else:\n                    x,y,w,h = obs\n                    px,py = pt\n                    if x<=px<=x+w and y<=py<=y+h:\n                        return True\n            return False\n\n        def edge_in_obstacle(p1, p2, resolution=0.5):\n            dist = 0.0\n            for i in range(dim):\n                diff = p2[i]-p1[i]\n                dist += diff*diff\n            dist = dist**0.5\n            steps = max(1, int(dist/resolution))\n            for i in range(steps+1):\n                t = i/steps\n                interp = tuple(p1[d] + t*(p2[d]-p1[d]) for d in range(dim))\n                if in_obstacle(interp):\n                    return True\n            return False\n\n        # Sampling\n        import random\n        import math\n\n        dist_start_goal = math.dist(start_pos, goal_pos)\n        volume_unit_ball = self._unit_ball_volume(dim)\n\n        def near_radius(n_nodes):\n            if n_nodes <= 1: return self.step_size*8.0\n            val = self.gamma_rrt_star * ((math.log(n_nodes)/n_nodes)**(1.0/dim))\n            return min(val, self.step_size*20.0)\n\n        def sample_uniform():\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not in_obstacle(pt):\n                    return pt\n\n        def sample_goal():\n            if not in_obstacle(goal_pos):\n                return goal_pos\n            else:\n                return sample_uniform()\n\n        # Informed ellipsoidal sampling\n        def sample_informed(best_cost):\n            if best_cost == float('inf') or best_cost <= dist_start_goal:\n                return sample_uniform()\n            center = tuple((start_pos[d]+goal_pos[d])/2 for d in range(dim))\n            dir_vec = [goal_pos[d]-start_pos[d] for d in range(dim)]\n            length = dist_start_goal\n            if length < 1e-10: \n                return sample_uniform()\n\n            # Rotation matrix R\n            if dim==2:\n                a1=[1,0]; a2=[dir_vec[0]/length, dir_vec[1]/length]\n                cos_theta = a1[0]*a2[0]+a1[1]*a2[1]\n                sin_theta = a1[0]*a2[1]-a1[1]*a2[0]\n                R=[[cos_theta,-sin_theta],[sin_theta,cos_theta]]\n            else:\n                from math import sqrt\n                a1 = [1,0,0]\n                a2 = [dir_vec[d]/length for d in range(3)]\n                v = [a1[1]*a2[2]-a1[2]*a2[1], a1[2]*a2[0]-a1[0]*a2[2], a1[0]*a2[1]-a1[1]*a2[0]]\n                s = sqrt(sum(vi*vi for vi in v))\n                c = sum(a1[d]*a2[d] for d in range(3))\n                if s < 1e-10:\n                    R=[[1,0,0],[0,1,0],[0,0,1]]\n                else:\n                    vx=[[0,-v[2],v[1]],[v[2],0,-v[0]],[-v[1],v[0],0]]\n                    I=[[int(i==j) for j in range(3)] for i in range(3)]\n                    vx2=[[sum(vx[i][k]*vx[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n                    R=[[I[i][j]+vx[i][j]+vx2[i][j]*((1-c)/(s*s)) for j in range(3)] for i in range(3)]\n\n            a1_val = best_cost/2.0\n            diff_sq = best_cost*best_cost - dist_start_goal*dist_start_goal\n            a_other = math.sqrt(diff_sq)/2.0 if diff_sq > 0 else 0.0\n\n            while True:\n                if dim==2:\n                    r = random.uniform(0,1)**0.5\n                    theta = random.uniform(0, 2*math.pi)\n                    x_ball = [r*math.cos(theta), r*math.sin(theta)]\n                    L=[[a1_val,0],[0,a_other]]\n                    x_scaled=[L[0][0]*x_ball[0]+L[0][1]*x_ball[1], L[1][0]*x_ball[0]+L[1][1]*x_ball[1]]\n                    pt=(center[0]+R[0][0]*x_scaled[0]+R[0][1]*x_scaled[1],\n                        center[1]+R[1][0]*x_scaled[0]+R[1][1]*x_scaled[1])\n                else:\n                    # 3D ball sampling\n                    while True:\n                        x_ball=[random.uniform(-1,1) for _ in range(3)]\n                        if sum(x*x for x in x_ball) <= 1:\n                            break\n                    L=[[a1_val,0,0],[0,a_other,0],[0,0,a_other]]\n                    x_scaled=[L[0][0]*x_ball[0], L[1][1]*x_ball[1], L[2][2]*x_ball[2]]\n                    pt=tuple(center[i]+sum(R[i][j]*x_scaled[j] for j in range(dim)) for i in range(dim))\n\n                if any(pt[d]<0 or pt[d]>bounds[d] for d in range(dim)): \n                    continue\n                if in_obstacle(pt):\n                    continue\n                return pt\n\n        def steer(from_pt, to_pt, max_dist):\n            diff = [to_pt[d]-from_pt[d] for d in range(dim)]\n            dist = math.sqrt(sum(x*x for x in diff))\n            if dist <= max_dist:\n                return to_pt\n            ratio = max_dist / dist\n            return tuple(from_pt[d] + ratio * diff[d] for d in range(dim))\n\n        def nearest(tree, pt):\n            best = None\n            best_dist_sq = float('inf')\n            for n in tree:\n                dist_sq = sum((n.position[d]-pt[d])**2 for d in range(dim))\n                if dist_sq<best_dist_sq:\n                    best_dist_sq=dist_sq\n                    best=n\n            return best\n\n        def near(tree, pt, radius):\n            radius_sq=radius*radius\n            return [n for n in tree if sum((n.position[d]-pt[d])**2 for d in range(dim))<=radius_sq]\n\n        def extract_path(n_start, n_goal):\n            path_start = []\n            n = n_start\n            while n:\n                path_start.append(n.position)\n                n = n.parent\n            path_goal = []\n            n = n_goal\n            while n:\n                path_goal.append(n.position)\n                n = n.parent\n            return list(reversed(path_start)) + path_goal\n\n        # Shortcut path routine combining incremental local attempts within shortcut_attempts\n        def shortcut_path(path):\n            if len(path)<3:\n                return path[:]\n            import random\n            p = path[:]\n            attempts=0\n            successful=0\n            while attempts < self.shortcut_attempts and len(p)>2:\n                i = random.randint(0,len(p)-3)\n                j = random.randint(i+2,len(p)-1)\n                if not edge_in_obstacle(p[i], p[j]):\n                    p = p[:i+1]+p[j:]\n                    successful +=1\n                    attempts = 0\n                else:\n                    attempts +=1\n            return p\n\n        # Connect one tree towards a sample point, with rewiring and attempt connection to other tree\n        def extend(tree_from, tree_to, sample, all_nodes, edges, best_cost):\n            nearest_node = nearest(tree_from, sample)\n            new_pos = steer(nearest_node.position, sample, self.step_size)\n            if in_obstacle(new_pos):\n                return None\n            if edge_in_obstacle(nearest_node.position, new_pos):\n                return None\n\n            new_node = Node(new_pos)\n            radius = near_radius(len(tree_from))\n            near_nodes = near(tree_from, new_pos, radius)\n\n            # Choose best parent minimizing cost\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            min_parent = nearest_node\n            for n in near_nodes:\n                cost_try = n.cost + math.dist(n.position, new_pos)\n                if cost_try < min_cost:\n                    if not edge_in_obstacle(n.position, new_pos):\n                        min_cost = cost_try\n                        min_parent = n\n\n            new_node.parent = min_parent\n            new_node.cost = min_cost\n            min_parent.add_child(new_node)\n\n            tree_from.append(new_node)\n            all_nodes.append(new_node)\n            edges.append((min_parent, new_node))\n\n            # Rewire neighbors\n            for n in near_nodes:\n                if n is min_parent: continue\n                cost_through_new = new_node.cost + math.dist(new_node.position, n.position)\n                if cost_through_new + 1e-8 < n.cost:\n                    if not edge_in_obstacle(new_node.position, n.position):\n                        if n.parent:\n                            try:\n                                edges.remove((n.parent, n))\n                            except ValueError:\n                                pass\n                            n.parent.remove_child(n)\n                        n.parent = new_node\n                        n.cost = cost_through_new\n                        new_node.add_child(n)\n                        edges.append((new_node, n))\n\n            # Attempt connect to other tree\n            nearest_other = nearest(tree_to, new_node.position)\n            dist_other = math.dist(new_node.position, nearest_other.position)\n            if dist_other <= self.step_size:\n                if not edge_in_obstacle(new_node.position, nearest_other.position):\n                    total_cost = new_node.cost + dist_other + nearest_other.cost\n                    if total_cost + 1e-8 < best_cost:\n                        return (new_node, nearest_other, total_cost)\n            return None\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        all_nodes = start_tree + goal_tree\n        edges = []\n\n        best_cost = float('inf')\n        solution_start = None\n        solution_goal = None\n        last_improve_itr = 0\n\n        for itr in range(self.max_iter):\n            p = random.random()\n            if best_cost < float('inf') and p < self.goal_sample_rate:\n                sample = sample_goal()\n            elif best_cost < float('inf'):\n                sample = sample_informed(best_cost)\n            else:\n                sample = sample_uniform()\n\n            for (tree_f, tree_t) in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                res = extend(tree_f, tree_t, sample, all_nodes, edges, best_cost)\n                if res is not None:\n                    n_s, n_g, cost = res\n                    if cost + 1e-8 < best_cost:\n                        best_cost = cost\n                        if tree_f is start_tree:\n                            solution_start, solution_goal = n_s, n_g\n                        else:\n                            solution_start, solution_goal = n_g, n_s\n                        last_improve_itr = itr\n\n                        # Aggressive incremental shortcutting after improvement\n                        raw_path = extract_path(solution_start, solution_goal)\n                        new_path = raw_path\n                        for _ in range(2):\n                            new_path = shortcut_path(new_path)\n                        \n                        # Update path with shortcut and return incremental improvement\n                        if len(new_path) < len(raw_path):\n                            # Replace path for output (no tree changes here)\n                            pass\n\n            # Early stop if no improvement for limit iterations after first solution\n            if best_cost < float('inf') and (itr - last_improve_itr) > self.no_improve_limit:\n                break\n\n            # Periodic shortcutting to further improve path quality during run\n            if best_cost < float('inf') and itr % self.shortcut_period == 0 and solution_start and solution_goal:\n                raw_path = extract_path(solution_start, solution_goal)\n                shortcuted = shortcut_path(raw_path)\n                if len(shortcuted) < len(raw_path):\n                    return PlannerResult(True, shortcuted, all_nodes, edges)\n\n        if best_cost < float('inf') and solution_start and solution_goal:\n            raw_path = extract_path(solution_start, solution_goal)\n            final_path = shortcut_path(raw_path)\n            return PlannerResult(True, final_path, all_nodes, edges)\n\n        return PlannerResult(False, [], all_nodes, edges)\n\n    def _unit_ball_volume(self, dim):\n        from math import pi, gamma\n        if dim==2:\n            return pi\n        elif dim==3:\n            return 4.0/3.0*pi\n        else:\n            return (pi**(dim/2))/gamma(dim/2+1)",
          "objective": 13.15642,
          "time_improvement": -101.0,
          "length_improvement": 15.0,
          "smoothness_improvement": 1560.0,
          "node_improvement": 70.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.05186364650726318,
                    "num_nodes_avg": 126.1,
                    "path_length_avg": 165.7083430018559,
                    "smoothness_avg": 0.0436318234762129,
                    "success_improvement": 0.0,
                    "time_improvement": -101.09351094758932,
                    "node_improvement": 68.24477461596575,
                    "length_improvement": 9.172631383954192,
                    "smoothness_improvement": 582.9327854239051,
                    "objective_score": -21.909810526784753
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.050346875190734865,
                    "num_nodes_avg": 211.5,
                    "path_length_avg": 239.42045808359703,
                    "smoothness_avg": 0.10209038340948448,
                    "success_improvement": 0.0,
                    "time_improvement": 69.59283475800706,
                    "node_improvement": 85.78915541221528,
                    "length_improvement": 20.074559755909863,
                    "smoothness_improvement": 2526.85909785699,
                    "objective_score": 45.556881770232984
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.1879929780960083,
                    "num_nodes_avg": 337.1,
                    "path_length_avg": 125.04940020615622,
                    "smoothness_avg": 0.13128702404977727,
                    "success_improvement": 0.0,
                    "time_improvement": -270.4500982151205,
                    "node_improvement": 57.13922441195168,
                    "length_improvement": 16.948142595619352,
                    "smoothness_improvement": 1569.961255313079,
                    "objective_score": -63.11633763059914
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "initial",
          "algorithm_description": "This algorithm is a sampling-based path planning algorithm that incrementally builds a space-filling tree rooted at the start position by randomly sampling the configuration space and extending the nearest existing node toward the sample. It continues this process until the goal is reached or a maximum number of iterations is exceeded.",
          "planning_mechanism": "The planner randomly samples free configurations, finds the nearest node in the current tree, attempts to extend toward the sample by a fixed step size, and adds the new node if the move is valid. This repeats until the goal is reached or iteration limit is hit.",
          "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 3.0, goal_sample_rate: float = 0.05):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map) -> PlannerResult:\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        root = Node(start_position)\n        nodes.append(root)\n\n        for _ in range(self.max_iter):\n            # Goal biasing\n            if random.random() < self.goal_sample_rate:\n                sample = goal_position\n            else:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n\n            # Find nearest node\n            nearest_node = min(nodes, key=lambda n: math.dist(n.position, sample))\n\n            # Steer\n            direction = tuple(sample[d] - nearest_node.position[d] for d in range(len(bounds)))\n            length = math.dist(nearest_node.position, sample)\n            if length == 0:\n                continue\n            unit = tuple(d / length for d in direction)\n            new_position = tuple(nearest_node.position[d] + unit[d] * min(self.step_size, length) for d in range(len(bounds)))\n\n            if self._is_in_obstacle(new_position, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_position, obstacles, is_3d):\n                continue\n\n            new_node = Node(new_position, parent=nearest_node, cost=nearest_node.cost + math.dist(nearest_node.position, new_position))\n            nearest_node.add_child(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n\n            # Check if goal reached\n            if math.dist(new_position, goal_position) <= self.step_size:\n                if not self._is_edge_in_obstacle(new_position, goal_position, obstacles, is_3d) and not self._is_in_obstacle(goal_position, obstacles, is_3d):\n                    goal_node = Node(goal_position, parent=new_node, cost=new_node.cost + math.dist(new_position, goal_position))\n                    new_node.add_child(goal_node)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    success_state = True\n                    break\n\n        if success_state:\n            path = []\n            node = nodes[-1]\n            while node:\n                path.append(node.position)\n                node = node.parent\n            extracted_path = path[::-1]\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n    ",
          "objective": 16.12642233593868,
          "time_improvement": -51.0,
          "length_improvement": -1.0,
          "smoothness_improvement": -1.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.026149177551269533,
                    "num_nodes_avg": 410.7,
                    "path_length_avg": 191.05073525114435,
                    "smoothness_avg": 0.006120002599452354,
                    "success_improvement": 0.0,
                    "time_improvement": -1.389514164613662,
                    "node_improvement": -3.4248300176277926,
                    "length_improvement": -4.71793538378402,
                    "smoothness_improvement": -4.208669520215349,
                    "objective_score": -3.2686588272555874
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.20789046287536622,
                    "num_nodes_avg": 1661.6,
                    "path_length_avg": 302.0911270054036,
                    "smoothness_avg": 0.0038793891450253602,
                    "success_improvement": 0.0,
                    "time_improvement": -25.556146889707154,
                    "node_improvement": -11.644157763891686,
                    "length_improvement": -0.8467134053755176,
                    "smoothness_improvement": -0.18052308743917594,
                    "objective_score": -8.175774725574653
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.11469049453735351,
                    "num_nodes_avg": 821.4,
                    "path_length_avg": 148.41619118184917,
                    "smoothness_avg": 0.008000850289294117,
                    "success_improvement": 0.0,
                    "time_improvement": -126.00368054175468,
                    "node_improvement": -4.437380801017161,
                    "length_improvement": 1.4290326365802952,
                    "smoothness_improvement": 1.770225118483674,
                    "objective_score": -36.9348334549858
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m2",
          "algorithm_description": "This algorithm is an enhanced bidirectional RRT* variant incorporating goal-biased sampling, adaptive rewiring radius proportional to the log of tree size and workspace dimension, and a post-planning shortcutting smoothing procedure. It grows two optimized trees with efficient rewiring and attempts connection at every iteration for fast convergence. After successful connection, the path is shortcut iteratively to reduce unnecessary waypoints and improve smoothness without sacrificing path clearance or length.",
          "planning_mechanism": "The planner alternates between the two trees by sampling with goal bias, extending nodes, rewiring nearby nodes using an adaptive radius to locally optimize cost, and checking for connection. It applies incremental rewiring selectively to reduce computation and performs post-processing shortcut smoothing on the final path to enhance smoothness and length.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=5.0, gamma=50.0, goal_sample_rate=0.1, shortcut_trials=100):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.gamma = gamma  # rewiring radius constant\n        self.goal_sample_rate = goal_sample_rate\n        self.shortcut_trials = shortcut_trials\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = dim == 3\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        edges = []\n        success = False\n        path = []\n\n        for it in range(self.max_iter):\n            # Goal-biased sampling\n            p_goal = random.random()\n            if p_goal < self.goal_sample_rate:\n                sample = goal_pos\n            else:\n                sample = self._sample_free(bounds, obstacles, is_3d)\n\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest = self._nearest(tree_a, sample)\n                new_pos = self._steer(nearest.position, sample, self.step_size)\n\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                    continue\n\n                radius = self._adaptive_radius(len(tree_a), dim)\n                near_nodes = self._near(tree_a, new_pos, radius)\n\n                min_cost = nearest.cost + self._distance(nearest.position, new_pos)\n                min_parent = nearest\n                for near in near_nodes:\n                    cost = near.cost + self._distance(near.position, new_pos)\n                    if cost < min_cost and not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d):\n                        min_cost = cost\n                        min_parent = near\n\n                new_node = Node(new_pos, parent=min_parent, cost=min_cost)\n                min_parent.add_child(new_node)\n                tree_a.append(new_node)\n                edges.append((min_parent, new_node))\n\n                # Rewire neighbors\n                for near in near_nodes:\n                    if near is min_parent:\n                        continue\n                    new_cost = new_node.cost + self._distance(new_node.position, near.position)\n                    if new_cost < near.cost and not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                        # update edges and parent relationships\n                        if near.parent:\n                            try:\n                                edges.remove((near.parent, near))\n                            except ValueError:\n                                pass\n                        near.parent = new_node\n                        near.cost = new_cost\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n\n                # Try to connect trees\n                connect_node = self._nearest(tree_b, new_node.position)\n                dist_to_connect = self._distance(new_node.position, connect_node.position)\n                if dist_to_connect <= self.step_size and not self._is_edge_in_obstacle(new_node.position, connect_node.position, obstacles, is_3d):\n                    # Connected! Extract path\n                    path = self._extract_path(new_node, connect_node)\n                    # Post-process path smoothing via shortcutting\n                    path = self._shortcut_path(path, obstacles, is_3d, bounds)\n                    success = True\n                    return PlannerResult(True, path, start_tree + goal_tree, edges)\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        while True:\n            point = tuple(random.uniform(0, bounds[i]) for i in range(len(bounds)))\n            if not self._is_in_obstacle(point, obstacles, is_3d):\n                return point\n\n    def _nearest(self, tree, point):\n        best = None\n        best_dist = float('inf')\n        for node in tree:\n            d = self._distance(node.position, point)\n            if d < best_dist:\n                best = node\n                best_dist = d\n        return best\n\n    def _near(self, tree, point, radius):\n        nclose = []\n        r2 = radius * radius\n        for node in tree:\n            dist2 = self._distance_sq(node.position, point)\n            if dist2 <= r2:\n                nclose.append(node)\n        return nclose\n\n    def _steer(self, from_pos, to_pos, step_size):\n        dist = self._distance(from_pos, to_pos)\n        if dist <= step_size:\n            return to_pos\n        ratio = step_size / dist\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n    def _extract_path(self, node_a, node_b):\n        path_a = []\n        n = node_a\n        while n:\n            path_a.append(n.position)\n            n = n.parent\n        path_b = []\n        n = node_b\n        while n:\n            path_b.append(n.position)\n            n = n.parent\n        return list(reversed(path_a)) + path_b\n\n    def _distance(self, a, b):\n        # Euclidean distance\n        return math.dist(a, b)\n\n    def _distance_sq(self, a, b):\n        return sum((a[i] - b[i]) ** 2 for i in range(len(a)))\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        px, py = pos[0], pos[1]\n        if is_3d:\n            pz = pos[2]\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        dist = self._distance(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * i / steps for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _adaptive_radius(self, n, dim):\n        if n <= 1:\n            return float('inf')\n        unit_ball_volume = (math.pi ** (dim / 2)) / math.gamma(dim / 2 + 1)\n        return min(self.gamma * (math.log(n) / n) ** (1 / dim), self.step_size * 20)\n\n    def _shortcut_path(self, path, obstacles, is_3d, bounds):\n        if len(path) < 3:\n            return path\n        shortened = list(path)\n        n = len(shortened)\n        for _ in range(self.shortcut_trials):\n            if len(shortened) < 3:\n                break\n            i = random.randint(0, len(shortened) - 2)\n            j = random.randint(i + 1, len(shortened) - 1)\n            if j == i + 1:\n                continue\n            p1 = shortened[i]\n            p2 = shortened[j]\n            if self._is_edge_in_obstacle(p1, p2, obstacles, is_3d):\n                continue\n            # Shortcut possible - remove intermediate points\n            shortened = shortened[:i + 1] + shortened[j:]\n        return shortened",
          "objective": 16.28446,
          "time_improvement": -53.0,
          "length_improvement": 16.0,
          "smoothness_improvement": 1358.0,
          "node_improvement": 59.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 0.9,
                    "time_avg": 0.030902910232543945,
                    "num_nodes_avg": 146.5,
                    "path_length_avg": 168.7961616280298,
                    "smoothness_avg": 0.039823894093147294,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": -19.821399682919726,
                    "node_improvement": 63.10752958952405,
                    "length_improvement": 7.480149065330989,
                    "smoothness_improvement": 523.3304215279222,
                    "objective_score": -48.841678358037704
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.04225015640258789,
                    "num_nodes_avg": 299.9,
                    "path_length_avg": 235.34161898718418,
                    "smoothness_avg": 0.08962414595394701,
                    "success_improvement": 0.0,
                    "time_improvement": 74.48287540455031,
                    "node_improvement": 79.84949270980314,
                    "length_improvement": 21.43619364916628,
                    "smoothness_improvement": 2206.0938290581084,
                    "objective_score": 46.23704795615541
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.15904171466827394,
                    "num_nodes_avg": 528.7,
                    "path_length_avg": 122.8261436387653,
                    "smoothness_avg": 0.11346697697299028,
                    "success_improvement": 0.0,
                    "time_improvement": -213.40010364150004,
                    "node_improvement": 32.77813095994914,
                    "length_improvement": 18.42472374757927,
                    "smoothness_improvement": 1343.2915718354004,
                    "objective_score": -46.24873898472544
               }
          ],
          "success_rate": 0.9666666666666667
     },
     {
          "operator": "m1",
          "algorithm_description": "A hybrid bidirectional incremental sampling planner with goal biasing, adaptive informed sampling region shrinking, efficient nearest neighbor search with pruning, and a lazy rewiring scheme to balance speed and path quality. The planner grows two trees toward each other using adaptive ellipsoidal informed sampling, selects parents and rewires based on collision-checked cost improvements, and attempts early tree connections for fast solution finding. After a successful connection, the path is refined using iterative shortcut smoothing to optimize length and smoothness while respecting map constraints.",
          "planning_mechanism": "The planner alternates expanding two trees from the start and goal, sampling adaptively within an ellipsoid defined by the current best path length to focus exploration. Nodes are connected considering minimum cost-to-come, with rewiring applied lazily only when cost improvements are detected without full descendant propagation for efficiency. Tree connection attempts are made whenever nodes get close, with early termination on success. Final path extraction is followed by iterative shortcutting to enhance smoothness and length reduction while ensuring collision-free paths.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\nclass Planner:\n    def __init__(self, max_iter=4000, step_size=4.5, neighbor_radius=12.0, goal_sample_rate=0.1):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.neighbor_radius = neighbor_radius\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map):\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = dim == 3\n\n        import random\n        import math\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def in_bounds(p):\n            return all(0 <= p[i] <= bounds[i] for i in range(dim))\n\n        def collision_node(p):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = p\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    px, py = p\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def collision_edge(a, b, resolution=0.4):\n            length = dist(a, b)\n            steps = max(2, int(length / resolution))\n            for i in range(steps + 1):\n                interp = tuple(a[d] + (b[d] - a[d]) * (i / steps) for d in range(dim))\n                if collision_node(interp):\n                    return True\n            return False\n\n        def steer(from_p, to_p):\n            length = dist(from_p, to_p)\n            if length <= self.step_size:\n                return to_p\n            ratio = self.step_size / length\n            return tuple(from_p[i] + (to_p[i] - from_p[i]) * ratio for i in range(dim))\n\n        def nearest(tree, point):\n            best_node = None\n            best_dist = math.inf\n            for node in tree:\n                d = dist(node.position, point)\n                if d < best_dist:\n                    best_node = node\n                    best_dist = d\n            return best_node\n\n        def near(tree, point, radius):\n            result = []\n            r2 = radius * radius\n            for node in tree:\n                # squared dist faster for rough pruning\n                d2 = sum((node.position[i] - point[i]) ** 2 for i in range(dim))\n                if d2 <= r2:\n                    result.append(node)\n            return result\n\n        def path_cost_to_go(p):\n            return dist(p, goal_pos)\n\n        def informed_sample(best_cost):\n            c_min = dist(start_pos, goal_pos)\n            if best_cost == math.inf or best_cost < c_min:\n                # Uniform random sample inside bounds with collision check\n                while True:\n                    s = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                    if not collision_node(s):\n                        return s\n            # Ellipsoidal informed sampling\n            c_best = best_cost\n            foci_dist = c_min\n            center = tuple((start_pos[i] + goal_pos[i]) * 0.5 for i in range(dim))\n            c1 = c_best * 0.5\n            val = c_best * c_best - foci_dist * foci_dist\n            if val < 1e-12:\n                rb = 0.0\n            else:\n                rb = math.sqrt(val) * 0.5\n\n            while True:\n                # sample in unit ball\n                while True:\n                    vec = [random.gauss(0, 1) for _ in range(dim)]\n                    norm = math.sqrt(sum(x * x for x in vec))\n                    if norm > 1e-7:\n                        break\n                unit = [x / norm for x in vec]\n                r = random.random() ** (1.0 / dim)\n                ball_sample = [unit[i] * r for i in range(dim)]\n\n                sample_ellipsoid = [0.0] * dim\n                sample_ellipsoid[0] = ball_sample[0] * c1\n                for i in range(1, dim):\n                    sample_ellipsoid[i] = ball_sample[i] * rb\n\n                point = tuple(center[i] + sample_ellipsoid[i] for i in range(dim))\n                if in_bounds(point) and not collision_node(point):\n                    return point\n\n        def update_parent_and_cost(child, new_parent, new_cost):\n            if child.parent:\n                child.parent.remove_child(child)\n            child.parent = new_parent\n            child.cost = new_cost\n            new_parent.add_child(child)\n\n        def rewire_lazy(tree, new_node, near_nodes):\n            # Rewire near nodes without recursive descendant cost update for speed\n            for near_n in near_nodes:\n                if near_n is new_node.parent:\n                    continue\n                c_through = new_node.cost + dist(new_node.position, near_n.position)\n                if c_through + path_cost_to_go(near_n.position) < near_n.cost + path_cost_to_go(near_n.position):\n                    if c_through < near_n.cost:\n                        if not collision_edge(new_node.position, near_n.position):\n                            update_parent_and_cost(near_n, new_node, c_through)\n\n        def extract_path(node_start, node_goal):\n            path_start = []\n            node = node_start\n            while node:\n                path_start.append(node.position)\n                node = node.parent\n            path_start.reverse()\n            path_goal = []\n            node = node_goal\n            while node:\n                path_goal.append(node.position)\n                node = node.parent\n            return path_start + path_goal\n\n        def shortcut_path(path, iterations=80):\n            if len(path) < 3:\n                return path[:]\n            import random\n            new_path = path[:]\n            for _ in range(iterations):\n                if len(new_path) < 3:\n                    break\n                i = random.randint(0, len(new_path) - 3)\n                j = random.randint(i + 2, len(new_path) - 1)\n                if not collision_edge(new_path[i], new_path[j]):\n                    new_path = new_path[:i + 1] + new_path[j:]\n            return new_path\n\n        # Initialization\n        tree_start = [Node(start_pos)]\n        tree_goal = [Node(goal_pos)]\n        edges = []\n        best_cost = math.inf\n        best_path = []\n\n        for iter in range(self.max_iter):\n            sample = None\n            # Goal biasing with chance to pick exact goal\n            if random.random() < self.goal_sample_rate:\n                sample = goal_pos\n            else:\n                sample = informed_sample(best_cost)\n\n            # Alternate tree: start_tree expands on even, goal_tree on odd\n            for tree_a, tree_b in [(tree_start, tree_goal), (tree_goal, tree_start)]:\n                nearest_node = nearest(tree_a, sample)\n                new_pos = steer(nearest_node.position, sample)\n\n                if not in_bounds(new_pos):\n                    continue\n                if collision_node(new_pos):\n                    continue\n                if collision_edge(nearest_node.position, new_pos):\n                    continue\n\n                near_nodes = near(tree_a, new_pos, self.neighbor_radius)\n\n                min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n                min_parent = nearest_node\n                for near_node in near_nodes:\n                    cost_through = near_node.cost + dist(near_node.position, new_pos)\n                    if cost_through < min_cost and not collision_edge(near_node.position, new_pos):\n                        min_cost = cost_through\n                        min_parent = near_node\n\n                new_node = Node(new_pos, min_parent, min_cost)\n                min_parent.add_child(new_node)\n                tree_a.append(new_node)\n                edges.append((min_parent, new_node))\n\n                rewire_lazy(tree_a, new_node, near_nodes)\n\n                nearest_other = nearest(tree_b, new_node.position)\n                dist_connect = dist(new_node.position, nearest_other.position)\n                if dist_connect <= self.step_size and not collision_edge(new_node.position, nearest_other.position):\n                    # Connection found; build path and update if better\n                    candidate_path = extract_path(new_node, nearest_other)\n                    cost_candidate = 0.0\n                    for k in range(len(candidate_path) - 1):\n                        cost_candidate += dist(candidate_path[k], candidate_path[k + 1])\n                    if cost_candidate < best_cost:\n                        best_cost = cost_candidate\n                        best_path = shortcut_path(candidate_path, iterations=120)\n                        return PlannerResult(True, best_path, tree_start + tree_goal, edges)\n        # If no early success, return best found\n        if best_path:\n            return PlannerResult(True, best_path, tree_start + tree_goal, edges)\n        return PlannerResult(False, [], tree_start + tree_goal, edges)",
          "objective": 21.77758,
          "time_improvement": -18.0,
          "length_improvement": 18.0,
          "smoothness_improvement": 1269.0,
          "node_improvement": 62.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 0.9,
                    "time_avg": 0.05129904747009277,
                    "num_nodes_avg": 202.0,
                    "path_length_avg": 163.44161697755194,
                    "smoothness_avg": 0.03924094037064722,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": -98.90436285815973,
                    "node_improvement": 49.131201208763535,
                    "length_improvement": 10.415059836447577,
                    "smoothness_improvement": 514.2059298665263,
                    "objective_score": -70.85124330624673
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.04442298412322998,
                    "num_nodes_avg": 290.2,
                    "path_length_avg": 234.79142538469895,
                    "smoothness_avg": 0.09046310773776003,
                    "success_improvement": 0.0,
                    "time_improvement": 73.1705887672238,
                    "node_improvement": 80.50124302895921,
                    "length_improvement": 21.619864110120623,
                    "smoothness_improvement": 2227.6809200353655,
                    "objective_score": 46.06149969641634
               },
               {
                    "map_id": 2,
                    "success_rate": 0.9,
                    "time_avg": 0.06482896804809571,
                    "num_nodes_avg": 345.4,
                    "path_length_avg": 119.31466829628096,
                    "smoothness_avg": 0.09162844930897038,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": -27.74890755939302,
                    "node_improvement": 56.08391608391609,
                    "length_improvement": 20.756878471570115,
                    "smoothness_improvement": 1065.5071119015024,
                    "objective_score": -40.54300962536833
               }
          ],
          "success_rate": 0.9333333333333332
     },
     {
          "operator": "e1",
          "algorithm_description": "A bidirectional RRT* variant integrating kd-tree-based nearest neighbor searches for efficiency, adaptive neighborhood radius with logarithmic decay, and goal-biased sampling combined with heuristic-driven node selection. The planner uses incremental rewiring optimized with cost-to-come comparison, progressive path extraction, and multi-level shortcut smoothing with adaptive step size to achieve fast convergence, high path quality, and smoothness. The algorithm dynamically balances exploration and exploitation by shrinking sampling space around the current best path and pruning nodes exceeding the best cost to reduce search complexity.",
          "planning_mechanism": "The planner builds two trees simultaneously from start and goal, using efficient kd-tree inspired nearest and radius neighbor queries (implemented with spatial bucketing due to import constraints). Sampling is goal-biased and restricted progressively to an informed ellipsoidal region when a solution is found. Each iteration extends a tree towards a sample by steering with fixed step size; nodes are parented to minimize cost-to-come. Rewiring neighbors within a radius further improves path costs. Trees attempt connection frequently, and upon connection, path rewiring and multi-stage shortcutting with adaptive stepping are applied to smooth and shorten paths iteratively while ensuring collision avoidance and bounds adherence. Runtime pruning of nodes whose cost exceeds the best path cost helps in focusing search and improving efficiency.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n    def add_child(self, child):\n        self.children.append(child)\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\nclass Planner:\n    def __init__(self, max_iter=4000, step_size=6.0, base_radius=25.0, goal_sample_rate=0.15):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.base_radius = base_radius\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = dim == 3\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        edges = []\n\n        best_path = []\n        best_cost = float('inf')\n\n        # Spatial bucketing for approx nearest neighbors: divide space into grid cells\n        # bucket size roughly step_size to limit candidates.\n        bucket_size = max(self.step_size, 4.0)\n        def bucket_key(p):\n            return tuple(int(p[i]/bucket_size) for i in range(dim))\n        # Buckets format: dict: (tuple indices) -> list of nodes\n        start_buckets = {}\n        goal_buckets = {}\n\n        def dist(a,b):\n            return math.dist(a,b)\n\n        def dist_sq(a,b):\n            return sum((a[i]-b[i])**2 for i in range(dim))\n\n        def in_bounds(p):\n            return all(0 <= p[i] <= bounds[i] for i in range(dim))\n\n        def collision_node(p):\n            if is_3d:\n                px,py,pz = p\n                for obs in obstacles:\n                    x,y,z,w,h,d = obs\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                        return True\n            else:\n                px, py = p\n                for obs in obstacles:\n                    x,y,w,h = obs\n                    if x <= px <= x+w and y <= py <= y+h:\n                        return True\n            return False\n\n        def collision_edge(a,b,res=0.4):\n            length = dist(a,b)\n            steps = max(1,int(length / res))\n            for i in range(steps+1):\n                interp = tuple(a[d] + (b[d]-a[d])*(i/steps) for d in range(dim))\n                if collision_node(interp):\n                    return True\n            return False\n\n        def steer(from_p, to_p):\n            length = dist(from_p,to_p)\n            if length <= self.step_size:\n                return to_p\n            ratio = self.step_size / length\n            return tuple(from_p[i] + (to_p[i] - from_p[i]) * ratio for i in range(dim))\n\n        # Insert node into buckets\n        def insert_bucket(buckets, node):\n            key = bucket_key(node.position)\n            if key not in buckets:\n                buckets[key] = []\n            buckets[key].append(node)\n\n        # Remove node from buckets\n        def remove_bucket(buckets, node):\n            key = bucket_key(node.position)\n            if key in buckets:\n                if node in buckets[key]:\n                    buckets[key].remove(node)\n                    if not buckets[key]:\n                        del buckets[key]\n\n        # Find nearest node using buckets (approximately)\n        def nearest(buckets, tree, point):\n            key = bucket_key(point)\n            checked_nodes = []\n            # search neighboring buckets up to distance 2 in grid coords\n            neighbors_keys = []\n            for offset in self._grid_offsets(dim,2):\n                neighbor_key = tuple(key[i]+offset[i] for i in range(dim))\n                neighbors_keys.append(neighbor_key)\n            candidates = []\n            for k in neighbors_keys:\n                candidates.extend(buckets.get(k,[]))\n            if not candidates:\n                candidates = tree  # fallback linear search all\n            best_node = None\n            best_dist = float('inf')\n            for node in candidates:\n                d = dist(node.position, point)\n                if d < best_dist:\n                    best_dist = d\n                    best_node = node\n            return best_node\n\n        # Find near nodes within radius using buckets\n        def near(buckets, tree, point, radius):\n            keys_range = int(math.ceil(radius / bucket_size))\n            key = bucket_key(point)\n            candidates = []\n            for offset in self._grid_offsets(dim, keys_range):\n                neighbor_key = tuple(key[i]+offset[i] for i in range(dim))\n                candidates.extend(buckets.get(neighbor_key, []))\n            r_sq = radius*radius\n            result = []\n            for node in candidates:\n                if dist_sq(node.position, point) <= r_sq:\n                    result.append(node)\n            if not result:\n                # fallback linear search all\n                for node in tree:\n                    if dist_sq(node.position, point) <= r_sq:\n                        result.append(node)\n            return result\n\n        # Precompute possible offset tuples for buckets search\n        def generate_grid_offsets(dim_, r):\n            from itertools import product\n            rng = range(-r,r+1)\n            return list(product(rng, repeat=dim_))\n        self._grid_offsets_cache = {}\n        def get_grid_offsets(dim_, r):\n            key = (dim_, r)\n            if key not in self._grid_offsets_cache:\n                self._grid_offsets_cache[key] = generate_grid_offsets(dim_, r)\n            return self._grid_offsets_cache[key]\n        self._grid_offsets = get_grid_offsets\n\n        def heuristic_cost_to_go(p):\n            return dist(p, goal_pos)\n\n        def new_radius(iteration, n_nodes):\n            if n_nodes < 2:\n                return self.base_radius\n            val = self.base_radius * ((math.log(n_nodes)/n_nodes)**(1/dim))\n            return max(val, self.step_size)\n\n        def propagate_cost(node):\n            stack = [node]\n            while stack:\n                current = stack.pop()\n                for cnode in current.children:\n                    new_cost = current.cost + dist(current.position, cnode.position)\n                    if new_cost + 1e-10 < cnode.cost:\n                        cnode.cost = new_cost\n                        stack.append(cnode)\n\n        def rewire(tree, buckets, new_node, near_nodes):\n            for near_node in near_nodes:\n                if near_node is new_node.parent:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, near_node.position)\n                if new_cost + 1e-10 < near_node.cost:\n                    if not collision_edge(new_node.position, near_node.position):\n                        # Remove old parent-child link\n                        if near_node.parent:\n                            near_node.parent.remove_child(near_node)\n                            if (near_node.parent, near_node) in edges:\n                                edges.remove((near_node.parent, near_node))\n                        near_node.parent = new_node\n                        near_node.cost = new_cost\n                        new_node.add_child(near_node)\n                        edges.append((new_node, near_node))\n                        propagate_cost(near_node)\n\n        # Extract path from connected nodes in start and goal trees\n        def extract_path(node_s, node_g):\n            path_s = []\n            node = node_s\n            while node:\n                path_s.append(node.position)\n                node = node.parent\n            path_s.reverse()\n            path_g = []\n            node = node_g\n            while node:\n                path_g.append(node.position)\n                node = node.parent\n            return path_s + path_g\n\n        # Multi-level shortcut smoothing\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path[:]\n            new_path = path[:]\n            max_attempts_per_level = 60\n            # Progressive shortcut with decreasing max step between waypoints to allow smooth curvature\n            for level in range(3):\n                attempts = 0\n                max_jump = max(2, int(len(new_path)*0.25/(level+1)))\n                while attempts < max_attempts_per_level:\n                    if len(new_path) < 3:\n                        break\n                    i = random.randint(0, len(new_path) - max_jump - 1)\n                    j = i + random.randint(2, max_jump)\n                    if j >= len(new_path):\n                        break\n                    if not collision_edge(new_path[i], new_path[j]):\n                        del new_path[i+1:j]\n                    attempts += 1\n            return new_path\n\n        # Prune nodes in tree whose cost exceeds best_cost by margin to reduce search\n        def prune_tree(tree, buckets):\n            threshold = best_cost + 10.0\n            to_remove = [n for n in tree if n.cost > threshold]\n            for node in to_remove:\n                # Remove from tree list\n                if node in tree:\n                    tree.remove(node)\n                # Remove from buckets\n                remove_bucket(buckets, node)\n                # Remove from parent's children if any\n                if node.parent:\n                    node.parent.remove_child(node)\n                # Remove edges which relate to this node\n                edges[:] = [e for e in edges if (e[0] is not node and e[1] is not node)]\n\n        # Sampling: goal biased and ellipsoidal if solution exists\n        def informed_sample():\n            c_min = dist(start_pos, goal_pos)\n            if best_cost == float('inf'):\n                # uniform random free sample with goal bias\n                if random.random() < self.goal_sample_rate:\n                    if not collision_node(goal_pos):\n                        return goal_pos\n                while True:\n                    sample = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                    if not collision_node(sample):\n                        return sample\n            # ellipsoidal informed sampling\n            center = tuple(0.5*(start_pos[i] + goal_pos[i]) for i in range(dim))\n            c_best = best_cost if best_cost < float('inf') else 1e10\n            c_best = max(c_best, c_min+1e-8)\n            foci_dist = c_min\n            r1 = c_best / 2.0\n            val = c_best*c_best - foci_dist*foci_dist\n            r_rest = math.sqrt(max(val,0))/2.0\n\n            while True:\n                vec = []\n                while True:\n                    vec = [random.gauss(0,1) for _ in range(dim)]\n                    norm = math.sqrt(sum(x*x for x in vec))\n                    if norm > 1e-8:\n                        break\n                unit = [x/norm for x in vec]\n                radius_sample = random.random() ** (1/dim)\n                unit = [x*radius_sample for x in unit]\n                sample_ellipsoid = [0]*dim\n                sample_ellipsoid[0] = unit[0]*r1\n                for i in range(1,dim):\n                    sample_ellipsoid[i] = unit[i]*r_rest\n                # For axis aligned ellipsoid, no rotation (simplification)\n                point = tuple(center[i]+sample_ellipsoid[i] for i in range(dim))\n                if in_bounds(point) and not collision_node(point):\n                    return point\n\n        # Initialization bucket population\n        insert_bucket(start_buckets, start_tree[0])\n        insert_bucket(goal_buckets, goal_tree[0])\n\n        for iter in range(1, self.max_iter+1):\n            sample = informed_sample()\n            for tree_a, buckets_a, tree_b, buckets_b in [(start_tree, start_buckets, goal_tree, goal_buckets), (goal_tree, goal_buckets, start_tree, start_buckets)]:\n                # Pick nearest in tree_a towards sample\n                nn = nearest(buckets_a, tree_a, sample)\n                new_pos = steer(nn.position, sample)\n                if not in_bounds(new_pos):\n                    continue\n                if collision_node(new_pos):\n                    continue\n                if collision_edge(nn.position, new_pos):\n                    continue\n\n                # Adaptive radius shrinkage per iteration and node count\n                radius = new_radius(iter, len(tree_a))\n                near_nodes = near(buckets_a, tree_a, new_pos, radius)\n\n                min_cost = nn.cost + dist(nn.position, new_pos)\n                min_parent = nn\n                for near_node in near_nodes:\n                    cand_cost = near_node.cost + dist(near_node.position, new_pos)\n                    if cand_cost + 1e-10 < min_cost:\n                        if not collision_edge(near_node.position, new_pos):\n                            min_cost = cand_cost\n                            min_parent = near_node\n\n                new_node = Node(new_pos, min_parent, min_cost)\n                min_parent.add_child(new_node)\n                tree_a.append(new_node)\n                insert_bucket(buckets_a, new_node)\n                edges.append((min_parent, new_node))\n\n                rewire(tree_a, buckets_a, new_node, near_nodes)\n\n                # Attempt connection to other tree within step_size\n                conn_node = nearest(buckets_b, tree_b, new_node.position)\n                dist_connect = dist(conn_node.position, new_node.position)\n                if dist_connect <= self.step_size and not collision_edge(new_node.position, conn_node.position):\n                    candidate_path = extract_path(new_node, conn_node)\n                    # Compute path cost\n                    path_cost = 0.0\n                    for k in range(len(candidate_path)-1):\n                        path_cost += dist(candidate_path[k], candidate_path[k+1])\n                    if path_cost + 1e-10 < best_cost:\n                        best_cost = path_cost\n                        best_path = shortcut_path(candidate_path)\n                        if best_cost < float('inf'):\n                            # Prune nodes with higher cost to speed up subsequent search\n                            prune_tree(start_tree, start_buckets)\n                            prune_tree(goal_tree, goal_buckets)\n                            return PlannerResult(True, best_path, start_tree+goal_tree, edges)\n\n        if best_path:\n            return PlannerResult(True, best_path, start_tree+goal_tree, edges)\n        return PlannerResult(False, [], start_tree+goal_tree, edges)",
          "objective": 25.17059,
          "time_improvement": 2.0,
          "length_improvement": 11.0,
          "smoothness_improvement": 3461.0,
          "node_improvement": 66.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.04160604476928711,
                    "num_nodes_avg": 173.6,
                    "path_length_avg": 183.9705997424378,
                    "smoothness_avg": 0.046659111383572476,
                    "success_improvement": 0.0,
                    "time_improvement": -61.321198618898165,
                    "node_improvement": 56.283052127927476,
                    "length_improvement": -0.8372009195353349,
                    "smoothness_improvement": 630.3164150349916,
                    "objective_score": -15.747098062215692
               },
               {
                    "map_id": 1,
                    "success_rate": 0.8,
                    "time_avg": 0.04389853477478027,
                    "num_nodes_avg": 216.1,
                    "path_length_avg": 239.1151120961979,
                    "smoothness_avg": 0.28841817186397045,
                    "success_improvement": -19.999999999999996,
                    "time_improvement": 73.48733172175578,
                    "node_improvement": 85.48007794127528,
                    "length_improvement": 20.17649303540063,
                    "smoothness_improvement": 7321.207301272271,
                    "objective_score": -29.241868155871522
               },
               {
                    "map_id": 2,
                    "success_rate": 0.9,
                    "time_avg": 0.05325958728790283,
                    "num_nodes_avg": 348.6,
                    "path_length_avg": 128.4534992365007,
                    "smoothness_avg": 0.1989017118151389,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": -4.95083136362803,
                    "node_improvement": 55.67705022250477,
                    "length_improvement": 14.687302105441278,
                    "smoothness_improvement": 2430.0150928913768,
                    "objective_score": -30.522792681366752
               }
          ],
          "success_rate": 0.9
     },
     {
          "operator": "m3",
          "algorithm_description": "A simplified bidirectional RRT* planner with informed sampling and incremental rewiring for efficient path planning and improvement. It alternates tree expansions with nearest neighbor rewiring, and returns the best path found within given iterations.",
          "planning_mechanism": "The planner grows start and goal trees alternately by sampling points guided by the best known path cost to focus exploration, connecting nodes using steering and rewiring nearby nodes to minimize cost. Upon connecting trees, it extracts and returns the improved path.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n    def add_child(self, child):\n        self.children.append(child)\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except ValueError:\n            pass\nclass Planner:\n    def __init__(self, max_iter=3000, step_size=5.0, gamma=30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.gamma = gamma\n\n    def plan(self, map):\n        import random\n        import math\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n\n        c_min = math.dist(start_pos, goal_pos)\n        best_cost = float('inf')\n        solution = None\n\n        def in_obstacle(point):\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d = obs\n                    px,py,pz = point\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                        return True\n                else:\n                    x,y,w,h = obs\n                    px,py = point\n                    if x <= px <= x+w and y <= py <= y+h:\n                        return True\n            return False\n\n        def steer(from_p, to_p):\n            dist = math.dist(from_p, to_p)\n            if dist <= self.step_size:\n                return to_p\n            ratio = self.step_size / dist\n            return tuple(from_p[i] + (to_p[i] - from_p[i]) * ratio for i in range(dim))\n\n        def nearest(nodes, point):\n            return min(nodes, key=lambda n: sum((n.position[i] - point[i])**2 for i in range(dim)))\n\n        def near(nodes, point, radius):\n            r2 = radius * radius\n            return [n for n in nodes if sum((n.position[i] - point[i])**2 for i in range(dim)) <= r2]\n\n        def is_edge_free(p1, p2):\n            dist = math.dist(p1, p2)\n            steps = max(int(dist * 2),1)\n            for step in range(steps + 1):\n                inter = tuple(p1[i] + (p2[i] - p1[i]) * (step / steps) for i in range(dim))\n                if in_obstacle(inter):\n                    return False\n            return True\n\n        def sample():\n            while True:\n                pt = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not in_obstacle(pt):\n                    return pt\n\n        def informed_sample():\n            if best_cost == float('inf') or best_cost <= c_min:\n                return sample()\n            center = tuple((start_pos[i] + goal_pos[i]) * 0.5 for i in range(dim))\n            dir_vec = [goal_pos[i] - start_pos[i] for i in range(dim)]\n            length = math.dist(start_pos, goal_pos)\n            a1 = best_cost * 0.5\n            a2 = math.sqrt(best_cost*best_cost - c_min*c_min) * 0.5\n\n            import math as m\n            if dim == 2:\n                while True:\n                    r = m.sqrt(random.uniform(0,1))\n                    theta = random.uniform(0, 2*m.pi)\n                    x = r*m.cos(theta)*a1\n                    y = r*m.sin(theta)*a2\n                    # rotate to align with start-goal vector\n                    cos_t = dir_vec[0]/length\n                    sin_t = dir_vec[1]/length\n                    sample_pt = (center[0] + cos_t*x - sin_t*y, center[1] + sin_t*x + cos_t*y)\n                    if all(0 <= sample_pt[i] <= bounds[i] for i in range(dim)) and not in_obstacle(sample_pt):\n                        return sample_pt\n            else:\n                # fallback to uniform sample if 3D not implemented due to complexity\n                return sample()\n\n        def path_cost(path_nodes):\n            cost = 0.0\n            for i in range(1,len(path_nodes)):\n                cost += math.dist(path_nodes[i-1].position, path_nodes[i].position)\n            return cost\n\n        def extract_path(node_start, node_goal):\n            path = []\n            n = node_start\n            while n:\n                path.append(n.position)\n                n = n.parent\n            path = path[::-1]\n            n = node_goal\n            while n:\n                path.append(n.position)\n                n = n.parent\n            return path\n\n        def near_radius(n):\n            if n <= 1:\n                return self.step_size*2.0\n            return min(self.step_size*20, self.gamma * (math.log(n) / n) ** (1.0/dim))\n\n        for it in range(self.max_iter):\n            rnd_point = informed_sample()\n\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest_node = nearest(tree_a, rnd_point)\n                new_pos = steer(nearest_node.position, rnd_point)\n                if in_obstacle(new_pos) or not is_edge_free(nearest_node.position, new_pos):\n                    continue\n                new_node = Node(new_pos)\n                radius = near_radius(len(tree_a))\n                near_nodes = near(tree_a, new_pos, radius)\n\n                min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n                min_parent = nearest_node\n                for near_node in near_nodes:\n                    cost_to_new = near_node.cost + math.dist(near_node.position, new_pos)\n                    if cost_to_new < min_cost and is_edge_free(near_node.position, new_pos):\n                        min_cost = cost_to_new\n                        min_parent = near_node\n                new_node.parent = min_parent\n                new_node.cost = min_cost\n                min_parent.add_child(new_node)\n                tree_a.append(new_node)\n\n                for near_node in near_nodes:\n                    if near_node is min_parent:\n                        continue\n                    new_cost = new_node.cost + math.dist(new_node.position, near_node.position)\n                    if new_cost < near_node.cost and is_edge_free(new_node.position, near_node.position):\n                        if near_node.parent:\n                            near_node.parent.remove_child(near_node)\n                        near_node.parent = new_node\n                        near_node.cost = new_cost\n                        new_node.add_child(near_node)\n\n                connect_node = nearest(tree_b, new_node.position)\n                dist_connect = math.dist(new_node.position, connect_node.position)\n                if dist_connect <= self.step_size and is_edge_free(new_node.position, connect_node.position):\n                    total_cost = new_node.cost + dist_connect + connect_node.cost\n                    if total_cost < best_cost:\n                        best_cost = total_cost\n                        if tree_a is start_tree:\n                            solution = (new_node, connect_node)\n                        else:\n                            solution = (connect_node, new_node)\n\n            if solution and it > 10:  # allow some iterations before returning path\n                path_nodes = extract_path(solution[0], solution[1])\n                return PlannerResult(True, path_nodes, start_tree+goal_tree, [])\n\n        return PlannerResult(False, [], start_tree + goal_tree, [])",
          "objective": 26.67951,
          "time_improvement": 10.0,
          "length_improvement": 5.0,
          "smoothness_improvement": 134.0,
          "node_improvement": 70.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.023472809791564943,
                    "num_nodes_avg": 133.1,
                    "path_length_avg": 177.74543374038413,
                    "smoothness_avg": 0.017008107131001378,
                    "success_improvement": 0.0,
                    "time_improvement": 8.987700428474357,
                    "node_improvement": 66.4819944598338,
                    "length_improvement": 2.574911210258107,
                    "smoothness_improvement": 166.21381029595085,
                    "objective_score": 5.072325906176926
               },
               {
                    "map_id": 1,
                    "success_rate": 0.9,
                    "time_avg": 0.053908157348632815,
                    "num_nodes_avg": 280.1,
                    "path_length_avg": 274.0705694550994,
                    "smoothness_avg": 0.008481324469032105,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": 67.44198637589153,
                    "node_improvement": 81.17986964993615,
                    "length_improvement": 8.507355231946006,
                    "smoothness_improvement": 118.2305874392895,
                    "objective_score": -24.071838010868483
               },
               {
                    "map_id": 2,
                    "success_rate": 0.9,
                    "time_avg": 0.07426266670227051,
                    "num_nodes_avg": 299.1,
                    "path_length_avg": 144.85641655029534,
                    "smoothness_avg": 0.017084696539287878,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": -46.33850930072056,
                    "node_improvement": 61.970756516211054,
                    "length_improvement": 3.7932654486060993,
                    "smoothness_improvement": 117.3160789186203,
                    "objective_score": -61.0390131264594
               }
          ],
          "success_rate": 0.9333333333333332
     },
     {
          "operator": "m1",
          "algorithm_description": "This algorithm is a bidirectional RRT* variant enhanced with an informed sampling heuristic that biases sampling towards an ellipsoidal subset defined by the current best path cost. It further integrates incremental rewiring with cost-to-come and cost-to-go estimations to improve path optimality. The planner grows two trees from start and goal, extends nodes toward sampled points within the informed subset to reduce unnecessary explorations, performs local rewiring with proper cost propagation to descendants, and attempts to connect the trees for early success detection. The resulting path is extracted and finally post-processed by shortcutting to improve smoothness and path length.<The planner alternates growth of two trees using informed sampling bounded by the best path cost to focus the search. Each extension chooses parents minimizing cost-to-come, performs rewiring with cost propagation, and attempts to connect the trees within step size. On success, a composed path is extracted and shortcutting post-processing is applied to enhance smoothness and reduce length, all while performing collision checks on nodes and edges within map bounds.>",
          "planning_mechanism": "The planner alternates growth of two trees using informed sampling bounded by the best path cost to focus the search. Each extension chooses parents minimizing cost-to-come, performs rewiring with cost propagation, and attempts to connect the trees within step size. On success, a composed path is extracted and shortcutting post-processing is applied to enhance smoothness and reduce length, all while performing collision checks on nodes and edges within map bounds.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=5.0, radius=15.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.radius = radius\n\n    def plan(self, map):\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        edges = []\n        best_cost = math.inf\n        best_path = []\n        # For convenience: track all nodes with costs for pruning informed sampling\n        all_nodes_start = start_tree\n        all_nodes_goal = goal_tree\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def in_bounds(p):\n            return all(0 <= p[i] <= bounds[i] for i in range(len(p)))\n\n        def collision_node(p):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = p\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    px, py = p\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def collision_edge(a, b, resolution=0.5):\n            length = dist(a, b)\n            steps = max(1, int(length / resolution))\n            for i in range(steps + 1):\n                interp = tuple(a[d] + (b[d] - a[d]) * (i / steps) for d in range(len(a)))\n                if collision_node(interp):\n                    return True\n            return False\n\n        def steer(from_p, to_p):\n            length = dist(from_p, to_p)\n            if length <= self.step_size:\n                return to_p\n            ratio = self.step_size / length\n            return tuple(from_p[i] + (to_p[i] - from_p[i]) * ratio for i in range(len(from_p)))\n\n        def nearest(tree, point):\n            best = None\n            best_dist = math.inf\n            for node in tree:\n                d = dist(node.position, point)\n                if d < best_dist:\n                    best = node\n                    best_dist = d\n            return best\n\n        def near(tree, point, radius):\n            return [node for node in tree if dist(node.position, point) <= radius]\n\n        def path_cost_to_go(p):\n            # Use Euclidean distance heuristic from point p to goal (lower bound cost-to-go)\n            return dist(p, goal_pos)\n\n        def path_cost_start_to(p):\n            # Simple heuristic: find nearest start tree node cost + dist\n            near_node = nearest(start_tree, p)\n            return near_node.cost + dist(near_node.position, p)\n\n        def informed_sample():\n            # Informed sampling inside an ellipsoid defined by c_min and foci start/goal\n            # If no solution yet, uniform random\n            if best_cost == math.inf:\n                while True:\n                    sample = tuple(random.uniform(0, bounds[i]) for i in range(len(bounds)))\n                    if not collision_node(sample):\n                        return sample\n            # Ellipsoidal sampling\n            c_min = dist(start_pos, goal_pos)\n            c_best = best_cost\n            if c_best == math.inf or c_best < c_min:\n                c_best = math.inf\n            # Construct ellipsoid with foci start_pos and goal_pos, axis1 length c_best/2\n            # Sample uniformly within unit ball and map to ellipsoid\n            foci_dist = c_min\n            if c_best == math.inf:\n                # fallback uniform\n                while True:\n                    sample = tuple(random.uniform(0, bounds[i]) for i in range(len(bounds)))\n                    if not collision_node(sample):\n                        return sample\n            else:\n                # 2D or 3D informed sampling\n                dimension = len(bounds)\n                center = tuple((start_pos[i] + goal_pos[i]) / 2 for i in range(dimension))\n\n                def unit_ball_sample(dim):\n                    while True:\n                        vec = [random.gauss(0, 1) for _ in range(dim)]\n                        norm = math.sqrt(sum(x * x for x in vec))\n                        if norm > 1e-8:\n                            break\n                    u = [x / norm for x in vec]\n                    r = random.random() ** (1 / dim)\n                    return [u[i] * r for i in range(dim)]\n\n                # Rotation matrix to align line start->goal to x-axis\n                # For simplicity, apply translation and scale without rotation:\n                # Sample in a prolate hyperspheroid axis aligned along x with radius c_best/2 along x and sqrt(c_best^2 - c_min^2)/2 along others\n\n                c1 = c_best / 2\n                if c_best*c_best - foci_dist*foci_dist < 0:\n                    # Numerical stability fallback\n                    rb = 0\n                else:\n                    rb = math.sqrt(c_best * c_best - foci_dist * foci_dist) / 2\n\n                while True:\n                    x_ball = unit_ball_sample(dimension)\n                    # Scale unit ball coordinate to ellipsoid radii\n                    sample_ellipsoid = [0]*dimension\n                    sample_ellipsoid[0] = x_ball[0] * c1\n                    for i in range(1, dimension):\n                        sample_ellipsoid[i] = x_ball[i] * rb\n                    # Translate to center\n                    point = tuple(center[i] + sample_ellipsoid[i] for i in range(dimension))\n                    if in_bounds(point) and not collision_node(point):\n                        return point\n\n        def rewire(tree, new_node, near_nodes):\n            # For each near node, try to improve cost by rerouting through new_node\n            for near_node in near_nodes:\n                if near_node is new_node.parent:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, near_node.position)\n                if new_cost + path_cost_to_go(near_node.position) < near_node.cost + path_cost_to_go(near_node.position):\n                    if new_cost < near_node.cost:\n                        # Check edge collision\n                        if not collision_edge(new_node.position, near_node.position):\n                            # Remove from old parent children list\n                            if near_node.parent:\n                                near_node.parent.remove_child(near_node)\n                                if (near_node.parent, near_node) in edges:\n                                    edges.remove((near_node.parent, near_node))\n                            # Update parent and cost\n                            near_node.parent = new_node\n                            near_node.cost = new_cost\n                            new_node.add_child(near_node)\n                            edges.append((new_node, near_node))\n                            propagate_cost(near_node)\n\n        def propagate_cost(node):\n            # Recursively update cost of descendants after rewiring\n            for child in node.children:\n                old_cost = child.cost\n                child.cost = node.cost + dist(node.position, child.position)\n                if child.cost < old_cost:\n                    propagate_cost(child)\n\n        def extract_path(conn_start_node, conn_goal_node):\n            path_start = []\n            node = conn_start_node\n            while node:\n                path_start.append(node.position)\n                node = node.parent\n            path_start.reverse()\n            path_goal = []\n            node = conn_goal_node\n            while node:\n                path_goal.append(node.position)\n                node = node.parent\n            return path_start + path_goal\n\n        def shortcut_path(path):\n            # Post process path to smooth by shortcutting\n            if len(path) < 3:\n                return path[:]\n            new_path = [path[0]]\n            i = 0\n            while i < len(path) - 1:\n                j = len(path) - 1\n                while j > i + 1:\n                    if not collision_edge(path[i], path[j]):\n                        break\n                    j -= 1\n                new_path.append(path[j])\n                i = j\n            return new_path\n\n        for _ in range(self.max_iter):\n            sample = informed_sample()\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest_node = nearest(tree_a, sample)\n                new_pos = steer(nearest_node.position, sample)\n                if not in_bounds(new_pos):\n                    continue\n                if collision_node(new_pos):\n                    continue\n                if collision_edge(nearest_node.position, new_pos):\n                    continue\n\n                near_nodes = near(tree_a, new_pos, self.radius)\n                # Choose parent minimizing cost-to-come + edge cost\n                min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n                min_parent = nearest_node\n                for near_node in near_nodes:\n                    if collision_edge(near_node.position, new_pos):\n                        continue\n                    cost = near_node.cost + dist(near_node.position, new_pos)\n                    if cost < min_cost:\n                        min_cost = cost\n                        min_parent = near_node\n                new_node = Node(new_pos, min_parent, min_cost)\n                min_parent.add_child(new_node)\n                tree_a.append(new_node)\n                edges.append((min_parent, new_node))\n\n                rewire(tree_a, new_node, near_nodes)\n\n                # Try to connect trees with the newly added node\n                nearest_to_new = nearest(tree_b, new_node.position)\n                dist_connect = dist(new_node.position, nearest_to_new.position)\n                if dist_connect <= self.step_size:\n                    if not collision_edge(new_node.position, nearest_to_new.position):\n                        # Build path and update best if improved\n                        path_candidate = extract_path(new_node, nearest_to_new)\n                        cost_candidate = 0.0\n                        for i in range(len(path_candidate) -1):\n                            cost_candidate += dist(path_candidate[i], path_candidate[i+1])\n                        if cost_candidate < best_cost:\n                            best_cost = cost_candidate\n                            best_path = path_candidate\n                            best_path = shortcut_path(best_path)\n                            # Early success return with improved path\n                            return PlannerResult(True, best_path, start_tree + goal_tree, edges)\n\n        if best_path:\n            return PlannerResult(True, best_path, start_tree + goal_tree, edges)\n        return PlannerResult(False, [], start_tree + goal_tree, edges)",
          "objective": 28.38357,
          "time_improvement": -149.0,
          "length_improvement": 16.0,
          "smoothness_improvement": 1332.0,
          "node_improvement": 66.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.10150227546691895,
                    "num_nodes_avg": 168.5,
                    "path_length_avg": 173.97986388023872,
                    "smoothness_avg": 0.04949234554306939,
                    "success_improvement": 0.0,
                    "time_improvement": -293.5598500570837,
                    "node_improvement": 57.567363384537906,
                    "length_improvement": 4.63887971987665,
                    "smoothness_improvement": 674.6626820975691,
                    "objective_score": -81.91131377471126
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.08119781017303467,
                    "num_nodes_avg": 277.4,
                    "path_length_avg": 229.5331563084081,
                    "smoothness_avg": 0.08293948567098822,
                    "success_improvement": 0.0,
                    "time_improvement": 50.960308422998224,
                    "node_improvement": 81.36128468722704,
                    "length_improvement": 23.375225678669988,
                    "smoothness_improvement": 2034.0927052113911,
                    "objective_score": 39.48369146015841
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.15377495288848878,
                    "num_nodes_avg": 319.0,
                    "path_length_avg": 121.10263595371161,
                    "smoothness_avg": 0.10914829386804074,
                    "success_improvement": 0.0,
                    "time_improvement": -203.0216712215368,
                    "node_improvement": 59.44055944055944,
                    "length_improvement": 19.56939548737532,
                    "smoothness_improvement": 1288.35824151247,
                    "objective_score": -42.7230728664735
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "A simplified bidirectional RRT* planner that grows two trees alternately with goal-biased sampling and radius-based rewiring for improved path quality and efficiency. The planner avoids costly adaptive radius calculations by using a fixed radius and performs basic shortcutting after connection to reduce path length.",
          "planning_mechanism": "The planner alternately expands start and goal trees by sampling free space biased to the goal. New nodes are connected based on a fixed rewiring radius to optimize local path cost. When trees connect, the combined path is extracted and simplified by shortcutting to improve smoothness and length before returning the solution.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\nclass Planner:\n    def __init__(self, max_iter=3000, step_size=5.0, goal_sample_rate=0.1, radius=10.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.radius = radius\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n\n        start_tree = [Node(start)]\n        goal_tree = [Node(goal)]\n        edges = []\n        success = False\n        final_path = []\n\n        for iter in range(self.max_iter):\n            sample = goal if random.random() < self.goal_sample_rate else self._sample_free(bounds, obstacles, dim)\n\n            # Alternate expansion order\n            grow_orders = [(start_tree, goal_tree), (goal_tree, start_tree)]\n            active_tree, other_tree = grow_orders[iter % 2]\n\n            nearest = self._nearest(active_tree, sample)\n            new_pos = self._steer(nearest.position, sample, self.step_size)\n            if self._is_in_obstacle(new_pos, obstacles, dim):\n                continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, dim):\n                continue\n\n            new_node = Node(new_pos)\n            near_nodes = self._near(active_tree, new_pos, self.radius)\n            min_cost = nearest.cost + self._distance(nearest.position, new_pos)\n            min_parent = nearest\n\n            for near in near_nodes:\n                cost = near.cost + self._distance(near.position, new_pos)\n                if cost < min_cost and not self._is_edge_in_obstacle(near.position, new_pos, obstacles, dim):\n                    min_cost = cost\n                    min_parent = near\n\n            new_node.parent = min_parent\n            new_node.cost = min_cost\n            min_parent.add_child(new_node)\n            active_tree.append(new_node)\n            edges.append((min_parent, new_node))\n\n            # Rewire near nodes\n            for near in near_nodes:\n                if near is min_parent:\n                    continue\n                new_cost = new_node.cost + self._distance(new_node.position, near.position)\n                if new_cost < near.cost and not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, dim):\n                    if near.parent:\n                        try:\n                            edges.remove((near.parent, near))\n                        except ValueError:\n                            pass\n                        near.parent.children.remove(near)\n                    near.parent = new_node\n                    near.cost = new_cost\n                    new_node.add_child(near)\n                    edges.append((new_node, near))\n\n            connect_node = self._nearest(other_tree, new_node.position)\n            dist = self._distance(new_node.position, connect_node.position)\n            if dist <= self.step_size and not self._is_edge_in_obstacle(new_node.position, connect_node.position, obstacles, dim):\n                success = True\n                path = self._extract_path(new_node, connect_node)\n                final_path = self._shortcut_path(path, obstacles, dim)\n                return PlannerResult(True, final_path, start_tree + goal_tree, edges)\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    def _sample_free(self, bounds, obstacles, dim):\n        while True:\n            point = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n            if not self._is_in_obstacle(point, obstacles, dim):\n                return point\n\n    def _nearest(self, tree, point):\n        best = None\n        best_dist = float('inf')\n        for node in tree:\n            dist = self._distance(node.position, point)\n            if dist < best_dist:\n                best_dist = dist\n                best = node\n        return best\n\n    def _near(self, tree, point, radius):\n        r_sq = radius * radius\n        res = []\n        for node in tree:\n            if self._distance_sq(node.position, point) <= r_sq:\n                res.append(node)\n        return res\n\n    def _steer(self, from_pos, to_pos, step_size):\n        dist = self._distance(from_pos, to_pos)\n        if dist <= step_size:\n            return to_pos\n        ratio = step_size / dist\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n    def _distance(self, a, b):\n        return sum((a[i] - b[i])**2 for i in range(len(a)))**0.5\n\n    def _distance_sq(self, a, b):\n        return sum((a[i] - b[i]) ** 2 for i in range(len(a)))\n\n    def _is_in_obstacle(self, pos, obstacles, dim):\n        if dim == 3:\n            px, py, pz = pos\n            for obs in obstacles:\n                x, y, z, w, h, d = obs\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n        else:\n            px, py = pos\n            for obs in obstacles:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, start, end, obstacles, dim, resolution=0.5):\n        dist = self._distance(start, end)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(start[j] + (end[j] - start[j]) * i / steps for j in range(dim))\n            if self._is_in_obstacle(interp, obstacles, dim):\n                return True\n        return False\n\n    def _extract_path(self, node_a, node_b):\n        path_a = []\n        while node_a:\n            path_a.append(node_a.position)\n            node_a = node_a.parent\n        path_b = []\n        while node_b:\n            path_b.append(node_b.position)\n            node_b = node_b.parent\n        return list(reversed(path_a)) + path_b\n\n    def _shortcut_path(self, path, obstacles, dim, max_attempts=60):\n        path = path[:]\n        n = len(path)\n        if n < 3:\n            return path\n        attempts = 0\n        while attempts < max_attempts:\n            if len(path) < 3:\n                break\n            i = random.randint(0, len(path) - 3)\n            j = random.randint(i + 2, len(path) - 1)\n            if not self._is_edge_in_obstacle(path[i], path[j], obstacles, dim):\n                del path[i+1:j]\n            attempts += 1\n        return path",
          "objective": 29.44466,
          "time_improvement": -89.0,
          "length_improvement": 14.0,
          "smoothness_improvement": 1095.0,
          "node_improvement": 62.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.057877111434936526,
                    "num_nodes_avg": 191.6,
                    "path_length_avg": 179.5990760833037,
                    "smoothness_avg": 0.029601785789212263,
                    "success_improvement": 0.0,
                    "time_improvement": -124.4098193197103,
                    "node_improvement": 51.75018886930245,
                    "length_improvement": 1.5589004692613202,
                    "smoothness_improvement": 363.3322289078712,
                    "objective_score": -34.57094436981694
               },
               {
                    "map_id": 1,
                    "success_rate": 0.9,
                    "time_avg": 0.08499889373779297,
                    "num_nodes_avg": 309.7,
                    "path_length_avg": 237.08159559281012,
                    "smoothness_avg": 0.07809325221118524,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": 48.66463117164223,
                    "node_improvement": 79.19102331519183,
                    "length_improvement": 20.855339375758646,
                    "smoothness_improvement": 1909.3956276897907,
                    "objective_score": -13.340428884603185
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.1474992275238037,
                    "num_nodes_avg": 343.5,
                    "path_length_avg": 121.17184534181081,
                    "smoothness_avg": 0.08741921392895938,
                    "success_improvement": 0.0,
                    "time_improvement": -190.65502273676515,
                    "node_improvement": 56.32549268912905,
                    "length_improvement": 19.523429907196746,
                    "smoothness_improvement": 1011.9659485611995,
                    "objective_score": -40.4226191339055
               }
          ],
          "success_rate": 0.9666666666666667
     },
     {
          "operator": "m3",
          "algorithm_description": "A streamlined, single-tree informed RRT* planner that samples within an ellipsoidal region defined by the best known path cost to focus the search. The planner adapts the neighborhood radius for rewiring, incrementally improves the path cost, and performs basic shortcutting when a path to the goal is found. This simplification reduces complexity while maintaining efficiency and path quality.",
          "planning_mechanism": "Grows a single tree from start to goal using informed sampling, selects the best parent from nearby nodes, rewires nearby nodes to reduce cost, and shortcuts the found path before returning.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n    def add_child(self, node):\n        self.children.append(node)\n    def remove_child(self, node):\n        if node in self.children:\n            self.children.remove(node)\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\nclass Planner:\n    def __init__(self, max_iter=2000, step_size=5.0, goal_sample_rate=0.1, gamma=30.0, shortcut_attempts=15):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.gamma = gamma\n        self.shortcut_attempts = shortcut_attempts\n\n    def plan(self, map):\n        import math\n        import random\n\n        bounds = map.size\n        dim = len(bounds)\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def in_obstacle(p):\n            for obs in obstacles:\n                if dim == 3:\n                    x,y,z,w,h,d = obs\n                    px,py,pz = p\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                        return True\n                else:\n                    x,y,w,h = obs\n                    px,py = p\n                    if x <= px <= x+w and y <= py <= y+h:\n                        return True\n            return False\n\n        def edge_collision(a, b, resolution=1.0):\n            length = dist(a, b)\n            steps = max(1, int(length / resolution))\n            for i in range(steps+1):\n                inter = tuple(a[j] + (b[j]-a[j])*(i/steps) for j in range(dim))\n                if in_obstacle(inter):\n                    return True\n            return False\n\n        c_min = dist(start, goal)\n        best_cost = float('inf')\n        best_goal_node = None\n\n        nodes = [Node(start)]\n        edges = []\n\n        def near_radius(n):\n            if n <= 1:\n                return self.step_size * 2.5\n            return min(self.step_size*50, self.gamma * (math.log(n)/n)**(1.0/dim))\n\n        def informed_sample():\n            if best_cost == float('inf') or best_cost <= c_min:\n                return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n            center = tuple((start[i]+goal[i])*0.5 for i in range(dim))\n            dir_vec = [goal[i]-start[i] for i in range(dim)]\n            length = dist(start, goal)\n            if length < 1e-10:\n                R = [[1 if i==j else 0 for j in range(dim)] for i in range(dim)]\n            else:\n                if dim == 2:\n                    cos_theta = dir_vec[0]/length\n                    sin_theta = dir_vec[1]/length\n                    R = [[cos_theta,-sin_theta],[sin_theta,cos_theta]]\n                else:\n                    R = [[1 if i==j else 0 for j in range(dim)] for i in range(dim)]\n            r1 = best_cost/2\n            r2 = math.sqrt(max(best_cost**2 - c_min**2,0))/2\n            while True:\n                if dim == 2:\n                    from math import sqrt, cos, sin, pi\n                    r = random.uniform(0,1)**0.5\n                    theta = random.uniform(0, 2*pi)\n                    x_ball = [r*cos(theta), r*sin(theta)]\n                    L = [[r1,0],[0,r2]]\n                    x_scaled = [L[0][0]*x_ball[0], L[1][1]*x_ball[1]]\n                    pt = (center[0] + R[0][0]*x_scaled[0] + R[0][1]*x_scaled[1],\n                          center[1] + R[1][0]*x_scaled[0] + R[1][1]*x_scaled[1])\n                else:\n                    while True:\n                        x_ball = [random.uniform(-1,1) for _ in range(dim)]\n                        if sum(xi*xi for xi in x_ball) <= 1:\n                            break\n                    x_scaled = [0]*dim\n                    x_scaled[0] = r1*x_ball[0]\n                    for i in range(1,dim):\n                        x_scaled[i] = r2*x_ball[i]\n                    pt = tuple(center[i] + sum(R[i][j]*x_scaled[j] for j in range(dim)) for i in range(dim))\n                if any(pt[i]<0 or pt[i]>bounds[i] for i in range(dim)) or in_obstacle(pt):\n                    continue\n                return pt\n\n        def sample():\n            if random.random() < self.goal_sample_rate and not in_obstacle(goal):\n                return goal\n            return informed_sample()\n\n        def steer(from_p, to_p):\n            d = dist(from_p, to_p)\n            if d <= self.step_size:\n                return to_p\n            ratio = self.step_size / d\n            return tuple(from_p[i] + (to_p[i]-from_p[i])*ratio for i in range(dim))\n\n        def near(nodes_list, pos, radius):\n            rsq = radius*radius\n            return [n for n in nodes_list if sum((n.position[i]-pos[i])**2 for i in range(dim)) <= rsq]\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            p = path[:]\n            attempts = 0\n            while attempts < self.shortcut_attempts and len(p) > 2:\n                i = random.randint(0, len(p)-3)\n                j = random.randint(i+2, len(p)-1)\n                if not edge_collision(p[i], p[j]):\n                    p = p[:i+1] + p[j:]\n                    attempts = 0\n                else:\n                    attempts += 1\n            return p\n\n        for _ in range(self.max_iter):\n            q_rand = sample()\n            nearest_node = min(nodes, key=lambda n: dist(n.position, q_rand))\n            q_new_pos = steer(nearest_node.position, q_rand)\n            if in_obstacle(q_new_pos) or edge_collision(nearest_node.position, q_new_pos):\n                continue\n\n            radius = near_radius(len(nodes))\n            near_nodes = near(nodes, q_new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, q_new_pos)\n            best_parent = nearest_node\n            for near_node in near_nodes:\n                cost_candidate = near_node.cost + dist(near_node.position, q_new_pos)\n                if cost_candidate < min_cost and not edge_collision(near_node.position, q_new_pos):\n                    min_cost = cost_candidate\n                    best_parent = near_node\n\n            new_node = Node(q_new_pos)\n            new_node.update_parent(best_parent, min_cost)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            for near_node in near_nodes:\n                if near_node is best_parent:\n                    continue\n                cost_through_new = new_node.cost + dist(new_node.position, near_node.position)\n                if cost_through_new < near_node.cost and not edge_collision(new_node.position, near_node.position):\n                    if (near_node.parent, near_node) in edges:\n                        edges.remove((near_node.parent, near_node))\n                    near_node.update_parent(new_node, cost_through_new)\n                    edges.append((new_node, near_node))\n\n            if dist(new_node.position, goal) <= self.step_size and not in_obstacle(goal) and not edge_collision(new_node.position, goal):\n                goal_node = Node(goal)\n                goal_node.update_parent(new_node, new_node.cost + dist(new_node.position, goal))\n                nodes.append(goal_node)\n                edges.append((new_node, goal_node))\n                if goal_node.cost < best_cost:\n                    best_cost = goal_node.cost\n                    best_goal_node = goal_node\n                path = []\n                cur = goal_node\n                while cur:\n                    path.append(cur.position)\n                    cur = cur.parent\n                path = path[::-1]\n                return PlannerResult(True, shortcut_path(path), nodes, edges)\n\n        if best_goal_node:\n            path = []\n            cur = best_goal_node\n            while cur:\n                path.append(cur.position)\n                cur = cur.parent\n            path = path[::-1]\n            return PlannerResult(True, shortcut_path(path), nodes, edges)\n\n        return PlannerResult(False, [], nodes, edges)",
          "objective": 51.50126,
          "time_improvement": -226.0,
          "length_improvement": 16.0,
          "smoothness_improvement": 1340.0,
          "node_improvement": 35.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.04741151332855224,
                    "num_nodes_avg": 269.6,
                    "path_length_avg": 166.4753243888791,
                    "smoothness_avg": 0.03250382139330425,
                    "success_improvement": 0.0,
                    "time_improvement": -83.83103226730883,
                    "node_improvement": 32.10778141526064,
                    "length_improvement": 8.75223673212895,
                    "smoothness_improvement": 408.75538798309003,
                    "objective_score": -17.85419070099983
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.41184024810791015,
                    "num_nodes_avg": 905.5,
                    "path_length_avg": 233.867447336454,
                    "smoothness_avg": 0.10190634726708518,
                    "success_improvement": 0.0,
                    "time_improvement": -148.73230821334334,
                    "node_improvement": 39.15877175300678,
                    "length_improvement": 21.928314577858295,
                    "smoothness_improvement": 2522.1237153571806,
                    "objective_score": -18.852085140502123
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.27735974788665774,
                    "num_nodes_avg": 525.1,
                    "path_length_avg": 123.66784307562787,
                    "smoothness_avg": 0.09353340116041137,
                    "success_improvement": 0.0,
                    "time_improvement": -446.55204085899356,
                    "node_improvement": 33.23585505403687,
                    "length_improvement": 17.865707059035284,
                    "smoothness_improvement": 1089.7379588429123,
                    "objective_score": -117.79749822806234
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "A bidirectional RRT* planner with dynamic adaptive rewiring and iterative path shortcutting post-processing for improved path quality and smoothness. The planner grows two trees alternately from start and goal, uses informed sampling within an ellipsoid based on current best cost to focus exploration, applies rewiring with a dynamically shrinking radius, and performs shortcutting intermittently to remove unnecessary waypoints, yielding shorter and smoother paths with better planning efficiency.",
          "planning_mechanism": "A bidirectional planner alternates extending start and goal trees toward informed samples, rewires neighbors locally to minimize path cost with an adaptively computed radius, connects the trees upon proximity, and after each improvement performs incremental shortcutting on the best path found to progressively smooth and shorten it before termination or timeout.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n    def add_child(self, child):\n        self.children.append(child)\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except ValueError:\n            pass\nclass Planner:\n    def __init__(self, max_iter=3000, step_size=7.0, gamma=50.0, shortcut_interval=100, shortcut_attempts=100):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.gamma = gamma\n        self.shortcut_interval = shortcut_interval\n        self.shortcut_attempts = shortcut_attempts\n    \n    def plan(self, map):\n        import random\n        import math\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n\n        c_min = math.dist(start_pos, goal_pos)\n        best_cost = float('inf')\n        best_solution = None\n\n        def in_obstacle(point):\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d = obs\n                    px,py,pz = point\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                        return True\n                else:\n                    x,y,w,h = obs\n                    px,py = point\n                    if x <= px <= x+w and y <= py <= y+h:\n                        return True\n            return False\n\n        def steer(from_p, to_p):\n            dist = math.dist(from_p, to_p)\n            if dist <= self.step_size:\n                return to_p\n            ratio = self.step_size / dist\n            return tuple(from_p[i] + (to_p[i] - from_p[i]) * ratio for i in range(dim))\n\n        def nearest(nodes, point):\n            return min(nodes, key=lambda n: sum((n.position[i]-point[i])**2 for i in range(dim)))\n\n        def near(nodes, point, radius):\n            r2 = radius * radius\n            return [n for n in nodes if sum((n.position[i]-point[i])**2 for i in range(dim)) <= r2]\n\n        def is_edge_free(p1, p2):\n            dist = math.dist(p1, p2)\n            steps = max(int(dist * 3), 1)  # finer step for collision check\n            for step in range(steps+1):\n                interm = tuple(p1[i] + (p2[i]-p1[i]) * step / steps for i in range(dim))\n                if in_obstacle(interm):\n                    return False\n            return True\n\n        def sample():\n            while True:\n                pt = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not in_obstacle(pt):\n                    return pt\n\n        def informed_sample():\n            if best_cost == float('inf') or best_cost <= c_min:\n                return sample()\n            center = tuple((start_pos[i] + goal_pos[i]) * 0.5 for i in range(dim))\n            dir_vec = [goal_pos[i] - start_pos[i] for i in range(dim)]\n            length = math.dist(start_pos, goal_pos)\n            a1 = best_cost * 0.5\n            val = best_cost*best_cost - c_min*c_min\n            if val < 0:\n                val = 0  # numerical fix\n            a2 = math.sqrt(val) * 0.5\n\n            if dim == 2:\n                while True:\n                    r = math.sqrt(random.uniform(0,1))\n                    theta = random.uniform(0, 2*math.pi)\n                    x = r * math.cos(theta) * a1\n                    y = r * math.sin(theta) * a2\n                    cos_t = dir_vec[0]/length\n                    sin_t = dir_vec[1]/length\n                    sample_pt = (center[0] + cos_t*x - sin_t*y, center[1] + sin_t*x + cos_t*y)\n                    if all(0 <= sample_pt[i] <= bounds[i] for i in range(dim)):\n                        if not in_obstacle(sample_pt):\n                            return sample_pt\n            else:\n                # fallback: uniform random inside bounds (3D)\n                return sample()\n\n        def near_radius(n):\n            if n <= 1:\n                return self.step_size*3.0\n            return min(self.step_size*15.0, self.gamma * (math.log(n)/n) ** (1.0/dim))\n\n        def extract_path(node_start, node_goal):\n            path = []\n            n = node_start\n            while n:\n                path.append(n.position)\n                n = n.parent\n            path = path[::-1]\n            n = node_goal\n            while n:\n                path.append(n.position)\n                n = n.parent\n            # Remove duplicate connecting node if present\n            if len(path) > 1 and path[-2] == path[-1]:\n                path.pop(-2)\n            return path\n\n        def shortcut_path(path):\n            # Attempt incremental shortcutting to remove unnecessary nodes for smoothness\n            for _ in range(self.shortcut_attempts):\n                if len(path) <= 2:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i+2, len(path) - 1)\n                if is_edge_free(path[i], path[j]):\n                    # remove nodes between i and j\n                    path = path[:i+1] + path[j:]\n            return path\n\n        def reconnect_tree(node):\n            # Recursive cost update to children after rewiring\n            for child in node.children:\n                old_cost = child.cost\n                child.cost = node.cost + math.dist(node.position, child.position)\n                if child.cost < old_cost:\n                    reconnect_tree(child)\n\n        for it in range(self.max_iter):\n            rnd_point = informed_sample()\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                near_r = near_radius(len(tree_a))\n                nearest_node = nearest(tree_a, rnd_point)\n                new_pos = steer(nearest_node.position, rnd_point)\n                if in_obstacle(new_pos) or not is_edge_free(nearest_node.position, new_pos):\n                    continue\n\n                near_nodes = near(tree_a, new_pos, near_r)\n\n                min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n                min_parent = nearest_node\n                for near_node in near_nodes:\n                    cost_to_new = near_node.cost + math.dist(near_node.position, new_pos)\n                    if cost_to_new < min_cost and is_edge_free(near_node.position, new_pos):\n                        min_cost = cost_to_new\n                        min_parent = near_node\n\n                new_node = Node(new_pos, min_parent, min_cost)\n                min_parent.add_child(new_node)\n                tree_a.append(new_node)\n\n                # Rewire neighbors\n                for near_node in near_nodes:\n                    if near_node is min_parent:\n                        continue\n                    new_cost = new_node.cost + math.dist(new_node.position, near_node.position)\n                    if new_cost < near_node.cost and is_edge_free(new_node.position, near_node.position):\n                        if near_node.parent:\n                            near_node.parent.remove_child(near_node)\n                        near_node.parent = new_node\n                        near_node.cost = new_cost\n                        new_node.add_child(near_node)\n                        reconnect_tree(near_node)\n\n                connect_node = nearest(tree_b, new_node.position)\n                dist_connect = math.dist(new_node.position, connect_node.position)\n                if dist_connect <= self.step_size and is_edge_free(new_node.position, connect_node.position):\n                    total_cost = new_node.cost + dist_connect + connect_node.cost\n                    if total_cost < best_cost:\n                        best_cost = total_cost\n                        if tree_a is start_tree:\n                            best_solution = (new_node, connect_node)\n                        else:\n                            best_solution = (connect_node, new_node)\n\n            if best_solution and it > 10 and it % self.shortcut_interval == 0:\n                path_nodes = extract_path(best_solution[0], best_solution[1])\n                path_nodes = shortcut_path(path_nodes)\n                return PlannerResult(True, path_nodes, start_tree + goal_tree, [])\n\n        if best_solution:\n            path_nodes = extract_path(best_solution[0], best_solution[1])\n            path_nodes = shortcut_path(path_nodes)\n            return PlannerResult(True, path_nodes, start_tree + goal_tree, [])\n        return PlannerResult(False, [], start_tree + goal_tree, [])",
          "objective": 57.07487,
          "time_improvement": -188.0,
          "length_improvement": 15.0,
          "smoothness_improvement": 1393.0,
          "node_improvement": 58.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.07932505607604981,
                    "num_nodes_avg": 200.1,
                    "path_length_avg": 174.25337473072867,
                    "smoothness_avg": 0.04000143304130363,
                    "success_improvement": 0.0,
                    "time_improvement": -207.57100795473983,
                    "node_improvement": 49.60967010828507,
                    "length_improvement": 4.488964088666338,
                    "smoothness_improvement": 526.1092915985655,
                    "objective_score": -56.94737747522931
               },
               {
                    "map_id": 1,
                    "success_rate": 0.9,
                    "time_avg": 0.07641382217407226,
                    "num_nodes_avg": 288.2,
                    "path_length_avg": 235.39177484580614,
                    "smoothness_avg": 0.09504443159079443,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": 53.849614125667344,
                    "node_improvement": 80.63562453806355,
                    "length_improvement": 21.41945017990193,
                    "smoothness_improvement": 2345.5616825681327,
                    "objective_score": -9.26563724151797
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.2584076404571533,
                    "num_nodes_avg": 450.0,
                    "path_length_avg": 122.43330208628501,
                    "smoothness_avg": 0.11067355505488541,
                    "success_improvement": 0.0,
                    "time_improvement": -409.2059116059217,
                    "node_improvement": 42.78448823903369,
                    "length_improvement": 18.68563040163216,
                    "smoothness_improvement": 1307.7594512260646,
                    "objective_score": -105.01159798466688
               }
          ],
          "success_rate": 0.9666666666666667
     },
     {
          "operator": "initial",
          "algorithm_description": "This algorithm is an optimal variant of RRT that improves path quality over time by rewiring the tree to minimize path cost. It incrementally builds a space-filling tree from start toward the goal while performing local optimizations by choosing better parents and rewiring nearby nodes.",
          "planning_mechanism": "The planner samples a point, extends the nearest node toward it, finds nearby nodes within a radius, selects the node offering the lowest-cost path as the parent, and rewires suboptimal neighbors to the new node if a shorter path through it is possible and valid.",
          "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.children.remove(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 3.0, goal_sample_rate: float = 0.05, neighbor_radius: float = 10.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n\n    def plan(self, map) -> PlannerResult:\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        root = Node(start_position)\n        nodes.append(root)\n\n        for _ in range(self.max_iter):\n            # Goal biasing\n            if random.random() < self.goal_sample_rate:\n                sample = goal_position\n            else:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n\n            # Nearest node\n            nearest_node = min(nodes, key=lambda n: math.dist(n.position, sample))\n            direction = tuple(sample[d] - nearest_node.position[d] for d in range(len(bounds)))\n            dist_to_sample = math.dist(nearest_node.position, sample)\n            if dist_to_sample == 0:\n                continue\n            unit = tuple(d / dist_to_sample for d in direction)\n            new_position = tuple(nearest_node.position[d] + unit[d] * min(self.step_size, dist_to_sample) for d in range(len(bounds)))\n\n            if self._is_in_obstacle(new_position, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_position, obstacles, is_3d):\n                continue\n\n            # Nearby nodes for choosing best parent\n            new_node = Node(new_position)\n            near_nodes = [n for n in nodes if math.dist(n.position, new_position) <= self.neighbor_radius]\n\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_position)\n            best_parent = nearest_node\n\n            for near_node in near_nodes:\n                temp_cost = near_node.cost + math.dist(near_node.position, new_position)\n                if temp_cost < min_cost and not self._is_edge_in_obstacle(near_node.position, new_position, obstacles, is_3d):\n                    min_cost = temp_cost\n                    best_parent = near_node\n\n            new_node.update_parent(best_parent, min_cost)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewiring\n            for near_node in near_nodes:\n                if near_node == best_parent:\n                    continue\n                cost_through_new = new_node.cost + math.dist(near_node.position, new_position)\n                if cost_through_new < near_node.cost and not self._is_edge_in_obstacle(new_position, near_node.position, obstacles, is_3d):\n                    edges.remove((near_node.parent, near_node))\n                    near_node.update_parent(new_node, cost_through_new)\n                    edges.append((new_node, near_node))\n\n            # Check goal connection\n            if math.dist(new_position, goal_position) <= self.step_size:\n                if not self._is_edge_in_obstacle(new_position, goal_position, obstacles, is_3d) and not self._is_in_obstacle(goal_position, obstacles, is_3d):\n                    goal_node = Node(goal_position)\n                    goal_cost = new_node.cost + math.dist(new_position, goal_position)\n                    goal_node.update_parent(new_node, goal_cost)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    success_state = True\n                    break\n\n        if success_state:\n            path = []\n            node = nodes[-1]\n            while node:\n                path.append(node.position)\n                node = node.parent\n            extracted_path = path[::-1]\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n    ",
          "objective": 61.63121923444826,
          "time_improvement": -248.0,
          "length_improvement": 20.0,
          "smoothness_improvement": 156.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.047614216804504395,
                    "num_nodes_avg": 367.4,
                    "path_length_avg": 156.97575072701764,
                    "smoothness_avg": 0.014377694677398786,
                    "success_improvement": 0.0,
                    "time_improvement": -84.616984594336,
                    "node_improvement": 7.479224376731312,
                    "length_improvement": 13.959103586572772,
                    "smoothness_improvement": 125.04214336500303,
                    "objective_score": -16.384422509532122
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.685749626159668,
                    "num_nodes_avg": 1656.6,
                    "path_length_avg": 226.92574635006446,
                    "smoothness_avg": 0.010969967745561136,
                    "success_improvement": 0.0,
                    "time_improvement": -314.1608018030315,
                    "node_improvement": -11.308203991130817,
                    "length_improvement": 24.245654172899485,
                    "smoothness_improvement": 182.26517144168025,
                    "objective_score": -78.78952217996137
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.22639145851135253,
                    "num_nodes_avg": 780.9,
                    "path_length_avg": 117.18066902366226,
                    "smoothness_avg": 0.020608286494296014,
                    "success_improvement": 0.0,
                    "time_improvement": -346.11633312050645,
                    "node_improvement": 0.7120152574698059,
                    "length_improvement": 22.174179178317964,
                    "smoothness_improvement": 162.13588306196758,
                    "objective_score": -89.71971301385132
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "path_expert",
          "algorithm_description": "A bidirectional RRT* planner enhanced with adaptive, incrementally shrinking connection radius, strategic dense sampling near the optimal ellipsoidal informed subset combined with selective goal bias to efficiently locate better paths. It applies conservative incremental shortcutting upon each solution improvement and a lightweight heuristic rewiring limiting costly neighbor checks, thus reducing computation time while improving path length and smoothness. The planner limits unnecessary rewiring by incorporating adaptive radius reduction based on node density and applies post-processing smoothing only when significant improvement is found to keep planning efficient and robust.",
          "planning_mechanism": "The planner initializes two trees from start and goal, alternately expands them by sampling inside an increasingly focused informed ellipsoidal subset around the current best solution and occasionally sampling the goal directly for bias. It connects new samples to nearby nodes within a radius that shrinks as the tree grows, rewires neighbors only if significant cost improvement is detected, and attempts to connect the two trees. When a better path is found, the path is incrementally shortcut a limited number of times. The search terminates early on stagnation. This combination balances exploration and exploitation, yielding efficient convergence to high-quality solutions with shorter length and smoother paths.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n    def add_child(self, child):\n        self.children.append(child)\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except ValueError:\n            pass\nclass Planner:\n    def __init__(self, max_iter=4000, step_size=5.0, gamma_rrt_star=30.0,\n                 goal_sample_rate=0.1, shortcut_attempts=20, stagnation_limit=80):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.gamma_rrt_star = gamma_rrt_star\n        self.goal_sample_rate = goal_sample_rate\n        self.shortcut_attempts = shortcut_attempts\n        self.stagnation_limit = stagnation_limit\n\n    def plan(self, map):\n        import random\n        import math\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = (len(bounds) == 3)\n        dim = 3 if is_3d else 2\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        all_nodes = start_tree + goal_tree\n        edges = []\n\n        best_cost = float('inf')\n        solution_start = None\n        solution_goal = None\n        c_min = math.dist(start_pos, goal_pos)\n\n        def in_obstacle(pt):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pt\n                    if (x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d):\n                        return True\n                else:\n                    x, y, w, h = obs\n                    px, py = pt\n                    if (x <= px <= x + w and y <= py <= y + h):\n                        return True\n            return False\n\n        def edge_in_obstacle(pt1, pt2, resolution=0.5):\n            dist_sq = sum((pt2[i]-pt1[i])**2 for i in range(dim))\n            dist = dist_sq**0.5\n            steps = max(int(dist / resolution), 1)\n            for i in range(steps +1):\n                t = i / steps\n                interp = tuple(pt1[d] + t*(pt2[d]-pt1[d]) for d in range(dim))\n                if in_obstacle(interp):\n                    return True\n            return False\n\n        def sample_uniform():\n            while True:\n                pt = tuple(random.uniform(0,bounds[d]) for d in range(dim))\n                if not in_obstacle(pt):\n                    return pt\n\n        def sample_goal():\n            if not in_obstacle(goal_pos):\n                return goal_pos\n            return sample_uniform()\n\n        def sample_informed():\n            if best_cost == float('inf') or best_cost <= c_min:\n                return sample_uniform()\n            center = tuple((start_pos[i]+goal_pos[i])/2 for i in range(dim))\n            dir_vec = [goal_pos[i]-start_pos[i] for i in range(dim)]\n            length = math.dist(start_pos, goal_pos)\n            if length < 1e-14:\n                return sample_uniform()\n\n            if dim == 2:\n                a1 = [1,0]\n                a2 = [dir_vec[0]/length, dir_vec[1]/length]\n                cos_theta = a1[0]*a2[0] + a1[1]*a2[1]\n                sin_theta = a1[0]*a2[1] - a1[1]*a2[0]\n                R = [[cos_theta, -sin_theta],[sin_theta, cos_theta]]\n            else:\n                a1 = [1,0,0]\n                a2 = [d/length for d in dir_vec]\n                v = [a1[1]*a2[2]-a1[2]*a2[1], a1[2]*a2[0]-a1[0]*a2[2], a1[0]*a2[1]-a1[1]*a2[0]]\n                s = sum(vi*vi for vi in v)**0.5\n                c = sum(a1[i]*a2[i] for i in range(3))\n                if s < 1e-14:\n                    R = [[1,0,0],[0,1,0],[0,0,1]]\n                else:\n                    I = [[1 if i==j else 0 for j in range(3)] for i in range(3)]\n                    vx = [[0,-v[2],v[1]], [v[2],0,-v[0]], [-v[1],v[0],0]]\n                    vx2 = [[sum(vx[i][k]*vx[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n                    R = []\n                    for i in range(3):\n                        row=[]\n                        for j in range(3):\n                            val = I[i][j] + vx[i][j] + vx2[i][j]*((1-c)/(s*s))\n                            row.append(val)\n                        R.append(row)\n\n            a1_val = best_cost/2\n            to_sqrt = max(0.0, best_cost*best_cost - c_min*c_min)\n            a_other = (to_sqrt**0.5)/2\n\n            while True:\n                if dim == 2:\n                    r = random.uniform(0,1)**0.5\n                    theta = random.uniform(0, 2*math.pi)\n                    x_ball = [r*math.cos(theta), r*math.sin(theta)]\n                    L = [[a1_val,0],[0,a_other]]\n                    x_scaled = [L[0][0]*x_ball[0] + L[0][1]*x_ball[1],\n                                L[1][0]*x_ball[0] + L[1][1]*x_ball[1]]\n                    pt = (center[0] + R[0][0]*x_scaled[0] + R[0][1]*x_scaled[1],\n                          center[1] + R[1][0]*x_scaled[0] + R[1][1]*x_scaled[1])\n                else:\n                    while True:\n                        x_ball = [random.uniform(-1,1) for _ in range(3)]\n                        if sum(xx*xx for xx in x_ball) <= 1:\n                            break\n                    L = [[a1_val,0,0],[0,a_other,0],[0,0,a_other]]\n                    x_scaled = [L[0][0]*x_ball[0], L[1][1]*x_ball[1], L[2][2]*x_ball[2]]\n                    pt = tuple(center[i]+sum(R[i][j]*x_scaled[j] for j in range(dim)) for i in range(dim))\n\n                if any(pt[d]<0 or pt[d]>bounds[d] for d in range(dim)):\n                    continue\n                if in_obstacle(pt):\n                    continue\n                return pt\n\n        def nearest(tree, pt):\n            best_node = None\n            best_dist_sq = float('inf')\n            for node in tree:\n                dist_sq = 0.0\n                for i in range(dim):\n                    delta = node.position[i]-pt[i]\n                    dist_sq += delta*delta\n                if dist_sq < best_dist_sq:\n                    best_dist_sq = dist_sq\n                    best_node = node\n            return best_node\n\n        def near(tree, pt, radius):\n            radius_sq = radius*radius\n            return [n for n in tree if sum((n.position[i]-pt[i])**2 for i in range(dim)) <= radius_sq]\n\n        def steer(start_pt, end_pt, max_len):\n            dist = math.dist(start_pt, end_pt)\n            if dist <= max_len:\n                return end_pt\n            ratio = max_len/dist\n            return tuple(start_pt[i] + ratio*(end_pt[i]-start_pt[i]) for i in range(dim))\n\n        def near_radius(num_nodes):\n            if num_nodes <= 1:\n                return self.step_size*5\n            val = self.gamma_rrt_star * ((math.log(num_nodes)/num_nodes)**(1/dim))\n            # Shrink radius with sqrt of nodes count for better refinement\n            shrink_factor = max(0.5, 3.0 / (1+0.01*num_nodes**0.5))\n            return min(self.step_size*10, val)*shrink_factor\n\n        def connect_tree(tree_from, tree_to, sample):\n            nearest_node = nearest(tree_from, sample)\n            new_pos = steer(nearest_node.position, sample, self.step_size)\n            if in_obstacle(new_pos) or edge_in_obstacle(nearest_node.position, new_pos):\n                return None\n            new_node = Node(new_pos)\n            radius = near_radius(len(tree_from))\n            neighbors = near(tree_from, new_pos, radius)\n\n            dist_nearest = math.dist(nearest_node.position, new_pos)\n            min_cost = nearest_node.cost + dist_nearest\n            min_parent = nearest_node\n\n            # Find better parent with improved minimal cost and limited rewiring attempts\n            for n in neighbors:\n                dist_n = math.dist(n.position, new_pos)\n                new_cost = n.cost + dist_n\n                if new_cost + 1e-9 < min_cost:\n                    if not edge_in_obstacle(n.position, new_pos):\n                        min_cost = new_cost\n                        min_parent = n\n\n            new_node.parent = min_parent\n            new_node.cost = min_cost\n            min_parent.add_child(new_node)\n\n            tree_from.append(new_node)\n            all_nodes.append(new_node)\n            edges.append((min_parent, new_node))\n\n            # Rewire neighbors only if cost gain is large enough (>1% improvement)\n            for neighbor in neighbors:\n                if neighbor is min_parent:\n                    continue\n                cost_through_new = new_node.cost + math.dist(new_node.position, neighbor.position)\n                if cost_through_new + 1e-9 < neighbor.cost * 0.99:\n                    if not edge_in_obstacle(new_node.position, neighbor.position):\n                        if neighbor.parent:\n                            try:\n                                edges.remove((neighbor.parent, neighbor))\n                            except ValueError:\n                                pass\n                            neighbor.parent.remove_child(neighbor)\n                        neighbor.parent = new_node\n                        neighbor.cost = cost_through_new\n                        new_node.add_child(neighbor)\n                        edges.append((new_node, neighbor))\n\n            # Attempt connection to other tree if close enough\n            nearest_other = nearest(tree_to, new_node.position)\n            dist_connect = math.dist(new_node.position, nearest_other.position)\n            if dist_connect <= self.step_size and not edge_in_obstacle(new_node.position, nearest_other.position):\n                total_cost = new_node.cost + dist_connect + nearest_other.cost\n                return new_node, nearest_other, total_cost\n            return None\n\n        def extract_path(n_start, n_goal):\n            path_start = []\n            n = n_start\n            while n:\n                path_start.append(n.position)\n                n = n.parent\n            path_goal = []\n            n = n_goal\n            while n:\n                path_goal.append(n.position)\n                n = n.parent\n            return list(reversed(path_start)) + path_goal\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path[:]\n            path_new = path[:]\n            attempts = 0\n            successes = 0\n            while attempts < self.shortcut_attempts:\n                if len(path_new) < 3:\n                    break\n                i = random.randint(0, len(path_new)-3)\n                j = random.randint(i+2, len(path_new)-1)\n                if not edge_in_obstacle(path_new[i], path_new[j]):\n                    path_new = path_new[:i+1] + path_new[j:]\n                    successes += 1\n                    attempts = 0\n                else:\n                    attempts += 1\n            return path_new\n\n        last_improve_iter = 0\n        for it in range(self.max_iter):\n            p = random.random()\n            if best_cost < float('inf') and p < self.goal_sample_rate:\n                sample_pt = sample_goal()\n            elif best_cost < float('inf'):\n                sample_pt = sample_informed()\n            else:\n                sample_pt = sample_uniform()\n\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                res = connect_tree(tree_a, tree_b, sample_pt)\n                if res is not None:\n                    n_a, n_b, cost = res\n                    if cost + 1e-9 < best_cost:\n                        best_cost = cost\n                        if tree_a is start_tree:\n                            solution_start, solution_goal = n_a, n_b\n                        else:\n                            solution_start, solution_goal = n_b, n_a\n                        last_improve_iter = it\n\n                        raw_path = extract_path(solution_start, solution_goal)\n                        improved_path = shortcut_path(raw_path)\n\n                        # Accept path only if shorter and update best_cost accordingly\n                        if len(improved_path) < len(raw_path):\n                            raw_path = improved_path\n\n            # Early stopping based on stagnation\n            if best_cost < float('inf') and (it - last_improve_iter) > self.stagnation_limit:\n                break\n\n        if best_cost < float('inf') and solution_start and solution_goal:\n            final_path = extract_path(solution_start, solution_goal)\n            final_path = shortcut_path(final_path)\n            return PlannerResult(True, final_path, all_nodes, edges)\n\n        return PlannerResult(False, [], all_nodes, edges)",
          "objective": 62.69831,
          "time_improvement": -269.0,
          "length_improvement": 19.0,
          "smoothness_improvement": 1295.0,
          "node_improvement": 37.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.1484309196472168,
                    "num_nodes_avg": 376.3,
                    "path_length_avg": 159.55593867709325,
                    "smoothness_avg": 0.04299459781516732,
                    "success_improvement": 0.0,
                    "time_improvement": -475.51862962158367,
                    "node_improvement": 5.237975321077816,
                    "length_improvement": 12.544861685441862,
                    "smoothness_improvement": 572.958820070871,
                    "objective_score": -132.26387777485564
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.11815989017486572,
                    "num_nodes_avg": 453.6,
                    "path_length_avg": 227.99191715688303,
                    "smoothness_avg": 0.08429251899728221,
                    "success_improvement": 0.0,
                    "time_improvement": 28.636935422278825,
                    "node_improvement": 69.52227373513404,
                    "length_improvement": 23.889735669558313,
                    "smoothness_improvement": 2068.907227247449,
                    "objective_score": 33.26945816465588
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.23402025699615478,
                    "num_nodes_avg": 491.5,
                    "path_length_avg": 117.86258358826925,
                    "smoothness_avg": 0.10552722306320332,
                    "success_improvement": 0.0,
                    "time_improvement": -361.1492836944107,
                    "node_improvement": 37.50794659885569,
                    "length_improvement": 21.721283993788152,
                    "smoothness_improvement": 1242.2984881545822,
                    "objective_score": -89.1005222712774
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "A bidirectional RRT* inspired planner with adaptive radius rewiring, goal-biased sampling, and iterative path shortcutting to improve planning speed, path length, and smoothness. The planner grows two trees towards each other with adaptive neighborhood scaling based on tree size and dimensionality. Sampling biased towards the goal accelerates convergence. After connection, iterative shortcutting refines the path by removing unnecessary waypoints and smoothing edges. This balances exploration and exploitation, improving efficiency and path quality.",
          "planning_mechanism": "A bidirectional sampling-based planner grows start and goal trees alternately with adaptive radius rewiring. Samples are biased towards the goal with a probability to speed up convergence. Upon successfully connecting the trees, the planner performs multiple passes of path shortcutting to smooth and shorten the solution path before returning it.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, goal_sample_rate: float = 0.1):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate  # Probability to sample goal position\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = 3 if is_3d else 2\n\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n        edges = []\n        success_state = False\n        final_path = []\n\n        # Adaptive radius calculation based on RRT* theory\n        def adaptive_radius(n):\n            gamma_rrt = 2 * (1 + 1/dim) ** (1/dim) * ( ( (math.prod(bounds)) / math.pi ) ** (1/dim) )\n            return min(self.step_size * 50, gamma_rrt * ((math.log(n + 1) / (n + 1)) ** (1/dim)) )\n\n        for iter in range(self.max_iter):\n            if random.random() < self.goal_sample_rate:\n                rand = goal_position\n            else:\n                rand = self._sample_free(bounds, obstacles, is_3d)\n\n            # Alternate tree growing order every iteration\n            tree_pairs = [(start_tree, goal_tree), (goal_tree, start_tree)] if iter % 2 == 0 else [(goal_tree, start_tree), (start_tree, goal_tree)]\n            for tree_a, tree_b in tree_pairs:\n                nearest = self._nearest(tree_a, rand)\n                new_pos = self._steer(nearest.position, rand, self.step_size)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                    continue\n\n                new_node = Node(new_pos)\n                radius = adaptive_radius(len(tree_a))\n                near_nodes = self._near(tree_a, new_pos, radius)\n                min_cost = nearest.cost + self._distance(nearest.position, new_pos)\n                min_parent = nearest\n\n                for near in near_nodes:\n                    cost = near.cost + self._distance(near.position, new_pos)\n                    if cost < min_cost and not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d):\n                        min_cost = cost\n                        min_parent = near\n\n                new_node.parent = min_parent\n                new_node.cost = min_cost\n                min_parent.add_child(new_node)\n                tree_a.append(new_node)\n                edges.append((min_parent, new_node))\n\n                # Rewire near nodes to new_node if cheaper\n                for near in near_nodes:\n                    if near == min_parent:\n                        continue\n                    new_cost = new_node.cost + self._distance(new_node.position, near.position)\n                    if new_cost < near.cost and not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                        if near.parent:\n                            try:\n                                edges.remove((near.parent, near))\n                            except ValueError:\n                                pass\n                            near.parent.children.remove(near)\n                        near.parent = new_node\n                        near.cost = new_cost\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n\n                connect_node = self._nearest(tree_b, new_node.position)\n                dist_connect = self._distance(new_node.position, connect_node.position)\n                if dist_connect <= self.step_size and not self._is_edge_in_obstacle(new_node.position, connect_node.position, obstacles, is_3d):\n                    success_state = True\n                    path = self._extract_path(new_node, connect_node)\n                    final_path = self._shortcut_path(path, obstacles, is_3d)\n                    return PlannerResult(True, final_path, start_tree + goal_tree, edges)\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        dim = 3 if is_3d else 2\n        while True:\n            point = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n            if not self._is_in_obstacle(point, obstacles, is_3d):\n                return point\n\n    def _nearest(self, tree, point):\n        best = None\n        best_dist = float('inf')\n        for node in tree:\n            d = self._distance(node.position, point)\n            if d < best_dist:\n                best_dist = d\n                best = node\n        return best\n\n    def _near(self, tree, point, radius):\n        near_nodes = []\n        r_sq = radius * radius\n        for node in tree:\n            if self._distance_sq(node.position, point) <= r_sq:\n                near_nodes.append(node)\n        return near_nodes\n\n    def _steer(self, from_pos, to_pos, step_size):\n        dist = self._distance(from_pos, to_pos)\n        if dist <= step_size:\n            return to_pos\n        ratio = step_size / dist\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n    def _distance(self, a, b):\n        return math.dist(a, b)\n\n    def _distance_sq(self, a, b):\n        return sum((a[i]-b[i])**2 for i in range(len(a)))\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        if is_3d:\n            px, py, pz = pos\n            for obs in obstacles:\n                x, y, z, w, h, d = obs\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n        else:\n            px, py = pos\n            for obs in obstacles:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        dist = self._distance(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d]-from_pos[d]) * (i/steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _extract_path(self, node_a, node_b):\n        path_a = []\n        while node_a:\n            path_a.append(node_a.position)\n            node_a = node_a.parent\n        path_b = []\n        while node_b:\n            path_b.append(node_b.position)\n            node_b = node_b.parent\n        return list(reversed(path_a)) + path_b\n\n    def _shortcut_path(self, path, obstacles, is_3d, max_attempts=100):\n        if len(path) < 3:\n            return path[:]  # No shortcutting possible\n        path = path[:]\n        attempts = 0\n        while attempts < max_attempts:\n            if len(path) < 3:\n                break\n            i = random.randint(0, len(path) - 3)\n            j = random.randint(i + 2, len(path) -1)\n            if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                # Remove intermediate points between i and j\n                del path[i+1:j]\n                attempts += 1\n            else:\n                attempts += 1\n        return path",
          "objective": 64.98543,
          "time_improvement": -161.0,
          "length_improvement": 18.0,
          "smoothness_improvement": 1207.0,
          "node_improvement": 61.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 0.9,
                    "time_avg": 0.10026426315307617,
                    "num_nodes_avg": 173.5,
                    "path_length_avg": 165.7003124244948,
                    "smoothness_avg": 0.04105737685936034,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": -288.75964298425225,
                    "node_improvement": 56.3082347015865,
                    "length_improvement": 9.177033070658451,
                    "smoothness_improvement": 542.6371053698549,
                    "objective_score": -128.4084875260313
               },
               {
                    "map_id": 1,
                    "success_rate": 0.9,
                    "time_avg": 0.06768927574157715,
                    "num_nodes_avg": 318.9,
                    "path_length_avg": 230.09691870904507,
                    "smoothness_avg": 0.07176126207217745,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": 59.118833397554525,
                    "node_improvement": 78.57286837331185,
                    "length_improvement": 23.187025562336398,
                    "smoothness_improvement": 1746.46896066497,
                    "objective_score": -9.619789840006952
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.1798630475997925,
                    "num_nodes_avg": 405.3,
                    "path_length_avg": 118.60925346068748,
                    "smoothness_avg": 0.11266801917117157,
                    "success_improvement": 0.0,
                    "time_improvement": -254.42964052937037,
                    "node_improvement": 48.467895740623014,
                    "length_improvement": 21.225381417126503,
                    "smoothness_improvement": 1333.1288875691969,
                    "objective_score": -56.92801887068923
               }
          ],
          "success_rate": 0.9333333333333332
     },
     {
          "operator": "m1",
          "algorithm_description": "A novel bidirectional RRT* variant integrating dynamic hybrid sampling that alternates between uniform and informed elliptical sampling with incremental rewiring based on a refined cost metric including smoothness heuristics. The algorithm adaptively adjusts neighborhood radius using spatial density and iteration count, leverages a KD-tree-like structure approximation for efficient nearest and near neighbor searches, and implements continuous path shortcut smoothing during planning. Frequent connection attempts between two growing trees enhance convergence speed. Edge and node collision checks are rigorously applied before every addition. This approach improves planning efficiency, robustness, and path quality while reducing search time.",
          "planning_mechanism": "The planner maintains two trees grown simultaneously from start and goal positions. Each iteration samples a point alternating between uniform random sampling and informed elliptical sampling shaped by the best current path cost. Tree expansion selects parents minimizing a hybrid cost incorporating path cost and smoothness heuristics. Nearby nodes within an adaptively shrinking neighborhood radius are rewired if they yield cost improvement. A simplified spatial partition approximates fast neighbor searches. Whenever the trees can be connected by a collision-free edge within step size, the combined path is extracted and shortcut smoothing is iteratively applied on-the-fly to refine smoothness and length. The planner returns the first improved valid solution within the iteration limit.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n    def add_child(self, child):\n        self.children.append(child)\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\nclass Planner:\n    def __init__(self, max_iter=4000, step_size=4.0, base_radius=25.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.base_radius = base_radius\n\n    def plan(self, map):\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        best_path = []\n        best_cost = float('inf')\n\n        def dist(a,b):\n            return math.dist(a,b)\n\n        def in_bounds(p):\n            return all(0 <= p[i] <= bounds[i] for i in range(dim))\n\n        def collision_node(p):\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d = obs\n                    px,py,pz = p\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                        return True\n                else:\n                    x,y,w,h = obs\n                    px,py = p\n                    if x <= px <= x+w and y <= py <= y+h:\n                        return True\n            return False\n\n        def collision_edge(a,b,res=0.4):\n            length = dist(a,b)\n            steps = max(1,int(length/res))\n            for i in range(steps+1):\n                interp = tuple(a[d] + (b[d]-a[d])*(i/steps) for d in range(dim))\n                if collision_node(interp):\n                    return True\n            return False\n\n        def steer(from_p, to_p):\n            length = dist(from_p,to_p)\n            if length <= self.step_size:\n                return to_p\n            ratio = self.step_size / length\n            return tuple(from_p[i] + (to_p[i] - from_p[i]) * ratio for i in range(dim))\n\n        def nearest(tree, p):\n            # Approximate spatial partition by grid hashing to reduce complexity\n            grid_size = self.step_size*2.5\n            loc = tuple(int(coord/grid_size) for coord in p)\n            candidates = []\n            for node in tree:\n                nloc = tuple(int(coord/grid_size) for coord in node.position)\n                diff = sum(abs(loc[i]-nloc[i]) for i in range(dim))\n                # Check local neighborhood in grid (within 1 grid step)\n                if diff <= 1:\n                    candidates.append(node)\n            if candidates:\n                return min(candidates, key=lambda n: dist(n.position, p))\n            return min(tree, key=lambda n: dist(n.position, p))\n\n        def near(tree, p, radius):\n            radius_sq = radius*radius\n            return [node for node in tree if sum((node.position[i]-p[i])**2 for i in range(dim)) <= radius_sq]\n\n        def heuristic_to_go(p):\n            return dist(p, goal_pos)\n\n        def hybrid_cost(parent, child_pos):\n            # Combines path cost + heuristic + smoothness hint using angle with parent's parent if exists\n            base_cost = parent.cost + dist(parent.position, child_pos)\n            angle_penalty = 0.0\n            if parent.parent:\n                v1 = tuple(parent.position[i]-parent.parent.position[i] for i in range(dim))\n                v2 = tuple(child_pos[i]-parent.position[i] for i in range(dim))\n                len1 = math.sqrt(sum(c*c for c in v1))\n                len2 = math.sqrt(sum(c*c for c in v2))\n                if len1 > 1e-6 and len2 > 1e-6:\n                    dot = sum(v1[i]*v2[i] for i in range(dim))\n                    cos_ang = max(-1,min(1,dot/(len1*len2)))\n                    angle_penalty = (1 - cos_ang)*0.5  # penalize sharp turns moderately\n            return base_cost + angle_penalty\n\n        def new_radius(iteration, tree_size):\n            if tree_size < 2:\n                return self.base_radius\n            val = math.log(tree_size)/tree_size\n            radius = self.base_radius * (val ** (1/dim))\n            return max(radius, self.step_size*1.3)\n\n        def propagate_cost(node):\n            for c in node.children:\n                new_c = node.cost + dist(node.position, c.position)\n                if new_c + 1e-12 < c.cost:\n                    c.cost = new_c\n                    propagate_cost(c)\n\n        def rewire(tree, new_node, near_nodes):\n            for node in near_nodes:\n                if node is new_node.parent:\n                    continue\n                cost_candidate = new_node.cost + dist(new_node.position, node.position)\n                if cost_candidate + 1e-8 < node.cost:\n                    if not collision_edge(new_node.position, node.position):\n                        # Update parent-child\n                        if node.parent:\n                            node.parent.remove_child(node)\n                            try: edges.remove((node.parent,node))\n                            except: pass\n                        node.parent = new_node\n                        node.cost = cost_candidate\n                        new_node.add_child(node)\n                        edges.append((new_node,node))\n                        propagate_cost(node)\n\n        def extract_path(node_start, node_goal):\n            path_s = []\n            n = node_start\n            while n:\n                path_s.append(n.position)\n                n = n.parent\n            path_s.reverse()\n            path_g = []\n            n = node_goal\n            while n:\n                path_g.append(n.position)\n                n = n.parent\n            if path_s[-1] == path_g[-1]:\n                path_g = path_g[:-1]\n            return path_s + path_g\n\n        def shortcut_path(path, max_tries=70):\n            if len(path) < 3:\n                return path[:]\n            new_path = path[:]\n            for _ in range(max_tries):\n                if len(new_path) < 3:\n                    break\n                i = random.randint(0,len(new_path)-3)\n                j = random.randint(i+2,len(new_path)-1)\n                if not collision_edge(new_path[i], new_path[j]):\n                    # Remove intermediate points between i and j\n                    new_path[i+1:j] = []\n            return new_path\n\n        def informed_sample(iteration):\n            # Alternate uniform and ellipsoidal informed sampling every iteration\n            if iteration % 2 == 1 or best_cost == float('inf'):\n                # Uniform sample\n                while True:\n                    sample = tuple(random.uniform(0,bounds[i]) for i in range(dim))\n                    if not collision_node(sample):\n                        return sample\n            else:\n                c_min = dist(start_pos, goal_pos)\n                c_best = best_cost\n                center = tuple((start_pos[i]+goal_pos[i])/2 for i in range(dim))\n                if c_best < c_min:\n                    c_best = c_min + 1e-6\n                r1 = c_best/2\n                val = c_best*c_best - c_min*c_min\n                r_rest = math.sqrt(val)/2 if val > 0 else 0.0\n\n                def unit_ball_sample():\n                    while True:\n                        vec = [random.gauss(0,1) for _ in range(dim)]\n                        norm = math.sqrt(sum(x*x for x in vec))\n                        if norm > 1e-8:\n                            return [x/norm for x in vec]\n\n                for _ in range(20):\n                    u = unit_ball_sample()\n                    sample_ellip = [0]*dim\n                    sample_ellip[0] = u[0]*r1\n                    for i in range(1,dim):\n                        sample_ellip[i] = u[i]*r_rest\n                    point = tuple(center[i] + sample_ellip[i] for i in range(dim))\n                    if in_bounds(point) and not collision_node(point):\n                        return point\n                # Fallback to uniform if no valid ellipsoid sample found\n                while True:\n                    sample = tuple(random.uniform(0,bounds[i]) for i in range(dim))\n                    if not collision_node(sample):\n                        return sample\n\n        for it in range(1,self.max_iter+1):\n            sample = informed_sample(it)\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nn = nearest(tree_a, sample)\n                new_pos = steer(nn.position, sample)\n                if not in_bounds(new_pos):\n                    continue\n                if collision_node(new_pos):\n                    continue\n                if collision_edge(nn.position, new_pos):\n                    continue\n\n                near_nodes = near(tree_a, new_pos, new_radius(it,len(tree_a)))\n\n                min_cost = hybrid_cost(nn, new_pos)\n                min_parent = nn\n                for near_node in near_nodes:\n                    if near_node is nn:\n                        continue\n                    if collision_edge(near_node.position, new_pos):\n                        continue\n                    c = hybrid_cost(near_node, new_pos)\n                    if c < min_cost:\n                        min_cost = c\n                        min_parent = near_node\n\n                new_node = Node(new_pos, min_parent, min_cost)\n                min_parent.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((min_parent, new_node))\n\n                rewire(tree_a, new_node, near_nodes)\n\n                conn_node = nearest(tree_b, new_node.position)\n                dist_connect = dist(conn_node.position, new_node.position)\n                if dist_connect <= self.step_size and not collision_edge(conn_node.position, new_node.position):\n                    candidate_path = extract_path(new_node, conn_node)\n                    path_cost = 0.0\n                    for k in range(len(candidate_path)-1):\n                        path_cost += dist(candidate_path[k], candidate_path[k+1])\n                    if path_cost + 1e-8 < best_cost:\n                        best_cost = path_cost\n                        best_path = shortcut_path(candidate_path,max_tries=100)\n                        if best_cost < float('inf'):\n                            return PlannerResult(True, best_path, nodes, edges)\n\n        if best_path:\n            return PlannerResult(True, best_path, nodes, edges)\n        else:\n            return PlannerResult(False, [], nodes, edges)",
          "objective": 68.81066,
          "time_improvement": -225.0,
          "length_improvement": 14.0,
          "smoothness_improvement": 1393.0,
          "node_improvement": 60.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.05699989795684814,
                    "num_nodes_avg": 155.3,
                    "path_length_avg": 171.25089468377718,
                    "smoothness_avg": 0.038745171214870484,
                    "success_improvement": 0.0,
                    "time_improvement": -121.00855562077939,
                    "node_improvement": 60.89146310752959,
                    "length_improvement": 6.134670979741407,
                    "smoothness_improvement": 506.4460659986673,
                    "objective_score": -30.089533768395636
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.11165080070495606,
                    "num_nodes_avg": 312.1,
                    "path_length_avg": 236.59914631126807,
                    "smoothness_avg": 0.09524692868391371,
                    "success_improvement": 0.0,
                    "time_improvement": 32.56812198225191,
                    "node_improvement": 79.0297655042666,
                    "length_improvement": 21.01639483246999,
                    "smoothness_improvement": 2350.772078626853,
                    "objective_score": 34.13413388729183
               },
               {
                    "map_id": 2,
                    "success_rate": 0.9,
                    "time_avg": 0.3488657236099243,
                    "num_nodes_avg": 460.4,
                    "path_length_avg": 127.59982400090489,
                    "smoothness_avg": 0.11176743223645765,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": -587.4583449025623,
                    "node_improvement": 41.46217418944692,
                    "length_improvement": 15.254272549277633,
                    "smoothness_improvement": 1321.6734882340486,
                    "objective_score": -210.4765725000319
               }
          ],
          "success_rate": 0.9666666666666667
     },
     {
          "operator": "m3",
          "algorithm_description": "A simplified, single-tree informed RRT* planner using adaptive sampling inside an ellipsoidal region around the best solution so far, combined with rewiring for cost improvements and efficient incremental shortcutting to enhance path smoothness and length while reducing computation time. The planner samples either the goal or informed ellipsoid region, connects nodes within an adaptively computed neighbor radius, and shortcuts the path progressively during planning for robustness and efficiency.",
          "planning_mechanism": "The planning mechanism grows a single tree from start toward random samples focused by the current best path cost, continually rewiring near neighbors to improve path cost locally. Sampling is constrained to an ellipsoid informed by the best best path cost to guide exploration efficiently. Shortcutting is performed incrementally after each successful path find to smooth the path and reduce length without slowing initial exploration.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n    def add_child(self, node):\n        self.children.append(node)\n    def remove_child(self, node):\n        try:\n            self.children.remove(node)\n        except ValueError:\n            pass\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\nclass Planner:\n    def __init__(self, max_iter=3000, step_size=5.0, goal_sample_rate=0.1, gamma=30.0, shortcut_attempts=25):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.gamma = gamma\n        self.shortcut_attempts = shortcut_attempts\n\n    def plan(self, map):\n        import math\n        import random\n\n        bounds = map.size\n        dim = len(bounds)\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n\n        def dist(a,b):\n            return math.dist(a,b)\n\n        def in_obstacle(pos):\n            for obs in obstacles:\n                if dim == 3:\n                    x,y,z,w,h,d = obs\n                    px,py,pz = pos\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                        return True\n                else:\n                    x,y,w,h = obs\n                    px,py = pos\n                    if x <= px <= x+w and y <= py <= y+h:\n                        return True\n            return False\n\n        def edge_collision(a,b,resolution=1.0):\n            length = dist(a,b)\n            steps = max(1,int(length/resolution))\n            for i in range(steps+1):\n                inter = tuple(a[j]+(b[j]-a[j])*(i/steps) for j in range(dim))\n                if in_obstacle(inter):\n                    return True\n            return False\n\n        c_min = dist(start, goal)\n        best_cost = float('inf')\n        best_goal_node = None\n\n        nodes = [Node(start)]\n        edges = []\n\n        def near_radius(n):\n            if n <= 1:\n                return self.step_size * 2.5\n            return min(self.step_size*50, self.gamma * (math.log(n)/n)**(1.0/dim))\n\n        def informed_sample():\n            if best_cost == float('inf') or best_cost <= c_min:\n                return tuple(random.uniform(0,bounds[i]) for i in range(dim))\n            center = tuple((start[i]+goal[i])*0.5 for i in range(dim))\n            dir_vec = [goal[i]-start[i] for i in range(dim)]\n            length = dist(start, goal)\n            if length < 1e-10:\n                R = [[1 if i==j else 0 for j in range(dim)] for i in range(dim)]\n            else:\n                if dim == 2:\n                    cos_theta = dir_vec[0]/length\n                    sin_theta = dir_vec[1]/length\n                    R = [[cos_theta,-sin_theta],[sin_theta,cos_theta]]\n                else:\n                    # Identity as fallback for 3D (simplified)\n                    R = [[1 if i==j else 0 for j in range(dim)] for i in range(dim)]\n            r1 = best_cost/2\n            r2 = math.sqrt(best_cost**2 - c_min**2)/2 if best_cost**2 - c_min**2 > 0 else 0.0\n            while True:\n                if dim == 2:\n                    from math import sqrt, cos, sin, pi\n                    r = random.uniform(0,1)**0.5\n                    theta = random.uniform(0, 2*pi)\n                    x_ball = [r*cos(theta), r*sin(theta)]\n                    L = [[r1,0], [0,r2]]\n                    x_scaled = [L[0][0]*x_ball[0], L[1][1]*x_ball[1]]\n                    pt = (center[0] + R[0][0]*x_scaled[0] + R[0][1]*x_scaled[1],\n                          center[1] + R[1][0]*x_scaled[0] + R[1][1]*x_scaled[1])\n                else:\n                    while True:\n                        x_ball = [random.uniform(-1,1) for _ in range(dim)]\n                        if sum(xi*xi for xi in x_ball) <= 1:\n                            break\n                    x_scaled = [0]*dim\n                    x_scaled[0] = r1*x_ball[0]\n                    for i in range(1,dim):\n                        x_scaled[i] = r2*x_ball[i]\n                    pt = tuple(center[i] + sum(R[i][j]*x_scaled[j] for j in range(dim)) for i in range(dim))\n                if any(pt[i]<0 or pt[i]>bounds[i] for i in range(dim)):\n                    continue\n                if in_obstacle(pt):\n                    continue\n                return pt\n\n        def sample():\n            if random.random() < self.goal_sample_rate:\n                if not in_obstacle(goal):\n                    return goal\n                else:\n                    return informed_sample()\n            return informed_sample()\n\n        def steer(from_p,to_p):\n            d = dist(from_p,to_p)\n            if d <= self.step_size:\n                return to_p\n            ratio = self.step_size/d\n            return tuple(from_p[i] + (to_p[i]-from_p[i])*ratio for i in range(dim))\n\n        def near(nodes_list,pos,radius):\n            r_sq = radius*radius\n            return [n for n in nodes_list if sum((n.position[i]-pos[i])**2 for i in range(dim)) <= r_sq]\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            p = path[:]\n            attempts = 0\n            while attempts < self.shortcut_attempts and len(p)>2:\n                i = random.randint(0,len(p)-3)\n                j = random.randint(i+2,len(p)-1)\n                if not edge_collision(p[i], p[j]):\n                    p = p[:i+1] + p[j:]\n                    attempts = 0\n                else:\n                    attempts += 1\n            return p\n\n        for iteration in range(self.max_iter):\n            q_rand = sample()\n            nearest_node = min(nodes, key=lambda n: dist(n.position,q_rand))\n            q_new_pos = steer(nearest_node.position,q_rand)\n            if in_obstacle(q_new_pos):\n                continue\n            if edge_collision(nearest_node.position,q_new_pos):\n                continue\n            new_node = Node(q_new_pos)\n            radius = near_radius(len(nodes))\n            near_nodes = near(nodes,q_new_pos,radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position,q_new_pos)\n            best_parent = nearest_node\n            for near_node in near_nodes:\n                c_cand = near_node.cost + dist(near_node.position,q_new_pos)\n                if c_cand < min_cost and not edge_collision(near_node.position,q_new_pos):\n                    min_cost = c_cand\n                    best_parent = near_node\n            new_node.update_parent(best_parent, min_cost)\n            nodes.append(new_node)\n            edges.append((best_parent,new_node))\n\n            for near_node in near_nodes:\n                if near_node is best_parent:\n                    continue\n                c_new = new_node.cost + dist(new_node.position, near_node.position)\n                if c_new < near_node.cost and not edge_collision(new_node.position, near_node.position):\n                    edges.remove((near_node.parent, near_node))\n                    near_node.update_parent(new_node, c_new)\n                    edges.append((new_node, near_node))\n\n            if dist(new_node.position, goal) <= self.step_size and not in_obstacle(goal):\n                if not edge_collision(new_node.position, goal):\n                    goal_node = Node(goal)\n                    goal_node.update_parent(new_node, new_node.cost + dist(new_node.position, goal))\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    current_cost = goal_node.cost\n                    if current_cost < best_cost:\n                        best_cost = current_cost\n                        best_goal_node = goal_node\n                    # Incrementally shortcut\n                    path = []\n                    cur = goal_node\n                    while cur:\n                        path.append(cur.position)\n                        cur = cur.parent\n                    path = path[::-1]\n                    path = shortcut_path(path)\n                    return PlannerResult(True, path, nodes, edges)\n\n        if best_goal_node:\n            path = []\n            cur = best_goal_node\n            while cur:\n                path.append(cur.position)\n                cur = cur.parent\n            path = path[::-1]\n            path = shortcut_path(path)\n            return PlannerResult(True, path, nodes, edges)\n\n        return PlannerResult(False, [], nodes, edges)",
          "objective": 73.7777,
          "time_improvement": -300.0,
          "length_improvement": 13.0,
          "smoothness_improvement": 1625.0,
          "node_improvement": 30.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.06267049312591552,
                    "num_nodes_avg": 284.5,
                    "path_length_avg": 171.06672078661478,
                    "smoothness_avg": 0.043337627358508504,
                    "success_improvement": 0.0,
                    "time_improvement": -142.99543792668325,
                    "node_improvement": 28.35557794006548,
                    "length_improvement": 6.235619611198275,
                    "smoothness_improvement": 578.3279773247364,
                    "objective_score": -36.26561972466233
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.5321156024932862,
                    "num_nodes_avg": 979.7,
                    "path_length_avg": 242.73696766644588,
                    "smoothness_avg": 0.11167562845786139,
                    "success_improvement": 0.0,
                    "time_improvement": -221.3730145427883,
                    "node_improvement": 34.1732177652355,
                    "length_improvement": 18.96741339671952,
                    "smoothness_improvement": 2773.4943569246757,
                    "objective_score": -41.16398454018139
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.3224977970123291,
                    "num_nodes_avg": 561.4,
                    "path_length_avg": 127.67082285245742,
                    "smoothness_avg": 0.1277037555190709,
                    "success_improvement": 0.0,
                    "time_improvement": -535.4989520744979,
                    "node_improvement": 28.620470438652262,
                    "length_improvement": 15.207118492678445,
                    "smoothness_improvement": 1524.3823440918643,
                    "objective_score": -143.90350280628297
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e1",
          "algorithm_description": "A bidirectional RRT* variant using dynamic tree connection attempts and prioritized rewiring with radius shrinking. It incorporates a KD-tree spatial index for fast nearest-neighbor queries and adaptive sampling constrained inside gradually shrinking informed ellipsoidal regions. The planner balances exploration and exploitation by increasing goal bias adaptively during iterations and performs incremental path smoothing for improved path quality and smoothness.",
          "planning_mechanism": "A bidirectional incremental sampling planner that grows two trees from start and goal positions with adaptive informed sampling in shrinking ellipsoids. It uses a KD-tree to speed up nearest neighbor and neighborhood queries, dynamically adjusts rewiring radius to focus local improvements, and tries early connection attempts. Paths are extracted from concatenated trees and iteratively smoothed with collision checks for enhanced length and smoothness. The planner employs goal bias adjustment to speed convergence and ensures all nodes and edges respect collision and map bounds constraints.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=4.0, radius_factor=30.0, initial_goal_sample_rate=0.1):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.radius_factor = radius_factor\n        self.goal_sample_rate = initial_goal_sample_rate\n\n    def plan(self, map):\n        import random\n        import math\n\n        bounds = map.size\n        dim = len(bounds)\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = dim == 3\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def in_bounds(p):\n            return all(0 <= p[i] <= bounds[i] for i in range(dim))\n\n        def collision_node(p):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = p\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    px, py = p\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def collision_edge(a, b, resolution=0.3):\n            length = dist(a, b)\n            steps = max(2, int(length / resolution))\n            for i in range(steps + 1):\n                interp = tuple(a[d] + (b[d] - a[d]) * (i / steps) for d in range(dim))\n                if collision_node(interp):\n                    return True\n            return False\n\n        def steer(from_p, to_p):\n            length = dist(from_p, to_p)\n            if length <= self.step_size:\n                return to_p\n            ratio = self.step_size / length\n            return tuple(from_p[i] + (to_p[i] - from_p[i]) * ratio for i in range(dim))\n\n        # KDTree for fast nearest queries\n        class KDNode:\n            def __init__(self, points, depth=0):\n                self.axis = depth % dim\n                self.left = None\n                self.right = None\n                self.node = None\n                self.points = points\n                if not points:\n                    return\n                points.sort(key=lambda n: n.position[self.axis])\n                median_idx = len(points) // 2\n                self.node = points[median_idx]\n                left_points = points[:median_idx]\n                right_points = points[median_idx+1:]\n                if left_points:\n                    self.left = KDNode(left_points, depth + 1)\n                if right_points:\n                    self.right = KDNode(right_points, depth + 1)\n\n            def nearest(self, point, best=None, best_dist=math.inf):\n                if self.node is None:\n                    return best, best_dist\n                d = dist(point, self.node.position)\n                if d < best_dist:\n                    best = self.node\n                    best_dist = d\n                diff = point[self.axis] - self.node.position[self.axis]\n                close, away = (self.left, self.right) if diff < 0 else (self.right, self.left)\n                if close is not None:\n                    best, best_dist = close.nearest(point, best, best_dist)\n                if away is not None and abs(diff) < best_dist:\n                    best, best_dist = away.nearest(point, best, best_dist)\n                return best, best_dist\n\n            def range_search(self, point, radius, results):\n                if self.node is None:\n                    return\n                d = sum((point[i] - self.node.position[i]) ** 2 for i in range(dim))\n                if d <= radius * radius:\n                    results.append(self.node)\n                diff = point[self.axis] - self.node.position[self.axis]\n                if diff <= radius and self.left is not None:\n                    self.left.range_search(point, radius, results)\n                if diff >= -radius and self.right is not None:\n                    self.right.range_search(point, radius, results)\n\n        def build_kdtree(nodes_list):\n            return KDNode(nodes_list)\n\n        def nearest(tree_nodes, point):\n            if not tree_nodes:\n                return None\n            kd = build_kdtree(tree_nodes)\n            n, _ = kd.nearest(point)\n            return n\n\n        def near(tree_nodes, point, radius):\n            if not tree_nodes:\n                return []\n            kd = build_kdtree(tree_nodes)\n            result = []\n            kd.range_search(point, radius, result)\n            return result\n\n        def path_cost_to_go(p):\n            return dist(p, goal_pos)\n\n        def informed_sample(best_cost):\n            c_min = dist(start_pos, goal_pos)\n            if best_cost == math.inf or best_cost < c_min:\n                # Uniform random sample with collision check\n                while True:\n                    s = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                    if not collision_node(s):\n                        return s\n            c_best = best_cost\n            foci_dist = c_min\n            center = tuple((start_pos[i] + goal_pos[i]) * 0.5 for i in range(dim))\n            c1 = c_best * 0.5\n            val = c_best * c_best - foci_dist * foci_dist\n            rb = math.sqrt(val) * 0.5 if val > 1e-12 else 0.0\n\n            while True:\n                # Sample uniform in unit ball\n                while True:\n                    vec = [random.gauss(0, 1) for _ in range(dim)]\n                    norm = math.sqrt(sum(x * x for x in vec))\n                    if norm > 1e-12:\n                        break\n                unit = [x / norm for x in vec]\n                r = random.random() ** (1.0 / dim)\n                ball_sample = [unit[i] * r for i in range(dim)]\n\n                sample = [0.0] * dim\n                sample[0] = ball_sample[0] * c1\n                for i in range(1, dim):\n                    sample[i] = ball_sample[i] * rb\n                point = tuple(center[i] + sample[i] for i in range(dim))\n                if in_bounds(point) and not collision_node(point):\n                    return point\n\n        def update_parent_and_cost(child, new_parent, new_cost):\n            if child.parent is not None:\n                child.parent.remove_child(child)\n            child.parent = new_parent\n            child.cost = new_cost\n            new_parent.add_child(child)\n\n        def rewire(tree_nodes, new_node, radius):\n            near_nodes = near(tree_nodes, new_node.position, radius)\n            for near_n in near_nodes:\n                if near_n == new_node.parent:\n                    continue\n                cost_through = new_node.cost + dist(new_node.position, near_n.position)\n                if cost_through < near_n.cost:\n                    if not collision_edge(new_node.position, near_n.position):\n                        update_parent_and_cost(near_n, new_node, cost_through)\n\n        def extract_path(node_start, node_goal):\n            path_start = []\n            n = node_start\n            while n:\n                path_start.append(n.position)\n                n = n.parent\n            path_start.reverse()\n\n            path_goal = []\n            n = node_goal\n            while n:\n                path_goal.append(n.position)\n                n = n.parent\n            return path_start + path_goal\n\n        def shortcut_path(path, max_iters=100):\n            if len(path) < 3:\n                return list(path)\n            p = list(path)\n            for _ in range(max_iters):\n                if len(p) < 3:\n                    break\n                i = random.randint(0, len(p) - 3)\n                j = random.randint(i + 2, len(p) - 1)\n                if not collision_edge(p[i], p[j]):\n                    p = p[:i+1] + p[j:]\n            return p\n\n        # Initialization\n        tree_start = [Node(start_pos)]\n        tree_goal = [Node(goal_pos)]\n        edges = []\n        best_cost = math.inf\n        best_path = None\n\n        radius = self.radius_factor * (math.log(2) / 2) ** (1 / dim)  # Initial rewiring radius heuristic\n\n        # Adaptive goal sampling increase\n        max_goal_rate = 0.25\n        goal_rate_growth = (max_goal_rate - self.goal_sample_rate) / self.max_iter\n\n        for iter in range(self.max_iter):\n            # Increase goal sampling rate gradually to speed convergence\n            self.goal_sample_rate = min(max_goal_rate, self.goal_sample_rate + goal_rate_growth)\n\n            sample = None\n            if random.random() < self.goal_sample_rate:\n                sample = goal_pos\n            else:\n                sample = informed_sample(best_cost)\n\n            # Alternate expansions for bidirectional growth\n            for tree_a, tree_b in [(tree_start, tree_goal), (tree_goal, tree_start)]:\n                nearest_node = nearest(tree_a, sample)\n                if nearest_node is None:\n                    continue\n                new_pos = steer(nearest_node.position, sample)\n                if not in_bounds(new_pos):\n                    continue\n                if collision_node(new_pos):\n                    continue\n                if collision_edge(nearest_node.position, new_pos):\n                    continue\n\n                # Choose parent node with min cost + collision-free edge\n                near_nodes = near(tree_a, new_pos, radius)\n                min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n                min_parent = nearest_node\n                for near_n in near_nodes:\n                    cost_thru = near_n.cost + dist(near_n.position, new_pos)\n                    if cost_thru < min_cost and not collision_edge(near_n.position, new_pos):\n                        min_cost = cost_thru\n                        min_parent = near_n\n\n                new_node = Node(new_pos, min_parent, min_cost)\n                min_parent.add_child(new_node)\n                tree_a.append(new_node)\n                edges.append((min_parent, new_node))\n\n                # Rewire nearby nodes to improve path cost\n                rewire(tree_a, new_node, radius)\n\n                # Try to connect to other tree within one step\n                nearest_other = nearest(tree_b, new_node.position)\n                if nearest_other is not None:\n                    dist_connect = dist(new_node.position, nearest_other.position)\n                    if dist_connect <= self.step_size and not collision_edge(new_node.position, nearest_other.position):\n                        # Connection found\n                        candidate_path = extract_path(new_node, nearest_other)\n                        cost_candidate = 0.0\n                        for k in range(len(candidate_path)-1):\n                            cost_candidate += dist(candidate_path[k], candidate_path[k+1])\n                        if cost_candidate < best_cost:\n                            best_cost = cost_candidate\n                            best_path = shortcut_path(candidate_path, max_iters=120)\n                            # Shrink radius after improvement to focus rewiring tighter\n                            radius = max(2.5, radius * 0.95)\n                            return PlannerResult(True, best_path, tree_start + tree_goal, edges)\n\n            # Gradually shrink radius to speed rewiring and limit neighbors\n            radius = max(2.5, radius * 0.995)\n\n        if best_path is not None:\n            return PlannerResult(True, best_path, tree_start + tree_goal, edges)\n\n        return PlannerResult(False, [], tree_start + tree_goal, edges)",
          "objective": 117.25044,
          "time_improvement": -448.0,
          "length_improvement": 16.0,
          "smoothness_improvement": 1498.0,
          "node_improvement": 60.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.0942913293838501,
                    "num_nodes_avg": 178.3,
                    "path_length_avg": 164.82338650620574,
                    "smoothness_avg": 0.04435688150161189,
                    "success_improvement": 0.0,
                    "time_improvement": -265.60048810024546,
                    "node_improvement": 55.09947116595316,
                    "length_improvement": 9.657690062253092,
                    "smoothness_improvement": 594.281518010102,
                    "objective_score": -70.91412480267128
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.6053380966186523,
                    "num_nodes_avg": 462.0,
                    "path_length_avg": 239.27269730019506,
                    "smoothness_avg": 0.10432142949114986,
                    "success_improvement": 0.0,
                    "time_improvement": -265.5959870682132,
                    "node_improvement": 68.95787139689578,
                    "length_improvement": 20.12388655846777,
                    "smoothness_improvement": 2584.265520495779,
                    "objective_score": -54.683136582904396
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.46297178268432615,
                    "num_nodes_avg": 338.8,
                    "path_length_avg": 123.06746120065657,
                    "smoothness_avg": 0.11132755247249963,
                    "success_improvement": 0.0,
                    "time_improvement": -812.3103644788724,
                    "node_improvement": 56.92307692307692,
                    "length_improvement": 18.264452113278548,
                    "smoothness_improvement": 1316.0782501050494,
                    "objective_score": -226.15404682516933
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "An enhanced RRT* variant with informed sampling and path shortcutting to improve planning efficiency, path length, and smoothness. The planner incrementally grows a tree focused around the current best path region, performs rewiring for optimal connectivity, and applies iterative shortcutting to smooth the final solution path.",
          "planning_mechanism": "The planner samples points preferentially within an ellipsoidal informed set around the best path found so far, extends in fixed step sizes ensuring collision-free checks, rewires nearby nodes for local cost improvements, and upon success performs path shortcutting to reduce unnecessary waypoints and smooth sharp turns.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, node):\n        self.children.append(node)\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.children.remove(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\nclass Planner:\n    def __init__(self, max_iter=4000, step_size=5.0, goal_sample_rate=0.1, neighbor_radius=15.0, shortcut_iters=100):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n        self.shortcut_iters = shortcut_iters\n\n    def plan(self, map):\n        import random\n        import math\n\n        bounds = map.size\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    px, py = pos\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def edge_collision(a, b, resolution=1.0):\n            total_dist = dist(a, b)\n            steps = max(1, int(total_dist / resolution))\n            for i in range(steps + 1):\n                pt = tuple(a[d] + (b[d] - a[d]) * i / steps for d in range(len(a)))\n                if in_obstacle(pt):\n                    return True\n            return False\n\n        def sample():\n            if best_path and random.random() > self.goal_sample_rate:\n                # Informed sampling: sample inside ellipsoid around best path\n                c_min = dist(start, goal)\n                c_best = best_cost\n                if c_best < float('inf') and c_best > c_min:\n                    center = tuple((s + g) / 2 for s,g in zip(start, goal))\n                    dim = len(bounds)\n                    # radii of ellipse\n                    r1 = c_best / 2\n                    r2 = math.sqrt(c_best**2 - c_min**2) / 2 if c_best**2 - c_min**2 > 0 else 0.0\n                    # sample unit ball point\n                    while True:\n                        ball = [random.uniform(-1,1) for _ in range(dim)]\n                        if sum(x*x for x in ball) <= 1:\n                            break\n                    # scale to ellipse\n                    scale = [r1] + [r2]*(dim-1)\n                    point = [ball[0]*scale[0]] + [ball[i]*scale[1] for i in range(1,dim)]\n                    # rotation aligns primary axis with start->goal vector:\n                    # For simplicity, no rotation is applied here (simplify)\n                    sample_point = tuple(center[d] + point[d] for d in range(dim))\n                    # Clip inside bounds\n                    clipped = tuple(min(max(0.0, sample_point[d]), bounds[d]) for d in range(dim))\n                    if not in_obstacle(clipped):\n                        return clipped\n            # uniform sampling or goal biasing\n            if random.random() < self.goal_sample_rate:\n                return goal\n            return tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n\n        def steer(from_p, to_p):\n            vector = tuple(to_p[d] - from_p[d] for d in range(len(bounds)))\n            distance = dist(from_p, to_p)\n            if distance <= self.step_size:\n                return to_p\n            ratio = self.step_size / distance\n            new_p = tuple(from_p[d] + vector[d]*ratio for d in range(len(bounds)))\n            return new_p\n\n        # Initialize tree\n        root = Node(start)\n        nodes = [root]\n        edges = []\n        best_cost = float('inf')\n        best_path = []\n        success = False\n\n        for _ in range(self.max_iter):\n            q_rand = sample()\n            nearest = min(nodes, key=lambda n: dist(n.position, q_rand))\n            q_new_pos = steer(nearest.position, q_rand)\n\n            if in_obstacle(q_new_pos):\n                continue\n            if edge_collision(nearest.position, q_new_pos):\n                continue\n\n            new_node = Node(q_new_pos)\n            # Find neighbors within radius\n            neighbors = [n for n in nodes if dist(n.position, q_new_pos) <= self.neighbor_radius and not edge_collision(n.position, q_new_pos)]\n\n            # Choose parent with minimum cost\n            min_cost = nearest.cost + dist(nearest.position, q_new_pos)\n            best_parent = nearest\n            for n in neighbors:\n                cost_candidate = n.cost + dist(n.position, q_new_pos)\n                if cost_candidate < min_cost:\n                    min_cost = cost_candidate\n                    best_parent = n\n            new_node.update_parent(best_parent, min_cost)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors\n            for n in neighbors:\n                if n == best_parent:\n                    continue\n                cost_through_new = new_node.cost + dist(n.position, q_new_pos)\n                if cost_through_new < n.cost and not edge_collision(new_node.position, n.position):\n                    edges.remove((n.parent, n))\n                    n.update_parent(new_node, cost_through_new)\n                    edges.append((new_node, n))\n\n            # Check if close to goal\n            if dist(new_node.position, goal) <= self.step_size:\n                if not edge_collision(new_node.position, goal) and not in_obstacle(goal):\n                    goal_node = Node(goal)\n                    goal_node.update_parent(new_node, new_node.cost + dist(new_node.position, goal))\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    # Found path\n                    success = True\n                    best_cost = goal_node.cost\n                    # Extract path\n                    path = []\n                    current = goal_node\n                    while current:\n                        path.append(current.position)\n                        current = current.parent\n                    best_path = path[::-1]\n                    break\n\n        if not success:\n            return PlannerResult(False, [], nodes, edges)\n\n        # Shortcutting to smooth path\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.shortcut_iters):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i+2, len(path) - 1)\n                if not edge_collision(path[i], path[j]):\n                    # shortcut path by removing intermediate nodes\n                    path = path[:i+1] + path[j:]\n            return path\n\n        smooth_path = shortcut_path(best_path)\n\n        return PlannerResult(True, smooth_path, nodes, edges)",
          "objective": 126.50897,
          "time_improvement": -481.0,
          "length_improvement": 20.0,
          "smoothness_improvement": 1161.0,
          "node_improvement": 39.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.10864453315734864,
                    "num_nodes_avg": 233.9,
                    "path_length_avg": 162.31992169031827,
                    "smoothness_avg": 0.04120047186082195,
                    "success_improvement": 0.0,
                    "time_improvement": -321.25288307318266,
                    "node_improvement": 41.09796021153362,
                    "length_improvement": 11.029878797779617,
                    "smoothness_improvement": 544.8768528784983,
                    "objective_score": -87.03355337889454
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 1.0817747592926026,
                    "num_nodes_avg": 982.3,
                    "path_length_avg": 221.16379014091618,
                    "smoothness_avg": 0.07053811202221238,
                    "success_improvement": 0.0,
                    "time_improvement": -553.341517935568,
                    "node_improvement": 33.99852180339985,
                    "length_improvement": 26.169161004226925,
                    "smoothness_improvement": 1714.9964288799981,
                    "objective_score": -141.72597663373423
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.33922343254089354,
                    "num_nodes_avg": 452.7,
                    "path_length_avg": 116.29337047697716,
                    "smoothness_avg": 0.1039603395891913,
                    "success_improvement": 0.0,
                    "time_improvement": -568.4577007842645,
                    "node_improvement": 42.4411951684679,
                    "length_improvement": 22.763480624409805,
                    "smoothness_improvement": 1222.3678460204567,
                    "objective_score": -150.7673826305312
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m2",
          "algorithm_description": "This improved planner is a bidirectional RRT* variant that integrates adaptive informed sampling restricted to an ellipsoid defined by the current best path, incremental KD-tree updates every 30 added nodes for efficient nearest and neighborhood queries, and an enhanced rewiring mechanism with a dynamically shrinking radius starting at 20.0. It applies early path connection checks with increased step size to speed convergence, linearly increases goal bias to 30% to balance exploration/exploitation, and includes a refined shortcutting process with 200 iterations to improve smoothness and path length. Additionally, it employs stricter near node rewiring radius decay and early rewiring priority, leading to faster planning, shorter, and smoother paths.",
          "planning_mechanism": "The planner grows two trees from start and goal alternately, sampling mainly inside an adaptive informed ellipsoid around the best known path cost with gradual goal bias increase; uses efficient incremental KD-trees to find nearest and near neighbors for optimal parent selection and rewiring; connects trees when close enough and rewires neighborhood to lower costs; after path discovery, applies shortcutting to reduce length and smoothness; radius shrinks aggressively to focus rewiring on promising regions; early exits speed convergence.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=5.5, init_radius=20.0,\n                 init_goal_sample_rate=0.10, shortcut_iterations=200,\n                 kd_rebuild_interval=30):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.radius = init_radius\n        self.goal_sample_rate = init_goal_sample_rate\n        self.shortcut_iterations = shortcut_iterations\n        self.kd_rebuild_interval = kd_rebuild_interval\n\n    def plan(self, map):\n        import random\n        import math\n\n        bounds = map.size\n        dim = len(bounds)\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = (dim == 3)\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def in_bounds(p):\n            return all(0 <= p[i] <= bounds[i] for i in range(dim))\n\n        def collision_node(p):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = p\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    px, py = p\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def collision_edge(a, b, resolution=0.20):\n            length = dist(a, b)\n            steps = max(2, int(length / resolution))\n            for i in range(steps + 1):\n                interp = tuple(a[d] + (b[d] - a[d]) * (i / steps) for d in range(dim))\n                if collision_node(interp):\n                    return True\n            return False\n\n        def steer(from_p, to_p):\n            length = dist(from_p, to_p)\n            if length <= self.step_size:\n                return to_p\n            ratio = self.step_size / length\n            return tuple(from_p[i] + (to_p[i] - from_p[i]) * ratio for i in range(dim))\n\n        class KDNode:\n            __slots__ = ['axis', 'median_val', 'left', 'right', 'points']\n\n            def __init__(self, points, depth=0):\n                self.axis = depth % dim\n                self.left = None\n                self.right = None\n                self.points = []\n                if not points:\n                    return\n                points.sort(key=lambda n: n.position[self.axis])\n                median_idx = len(points) // 2\n                self.median_val = points[median_idx].position[self.axis]\n                left_pts = points[:median_idx]\n                right_pts = points[median_idx + 1:]\n                self.points = [points[median_idx]]\n                if left_pts:\n                    self.left = KDNode(left_pts, depth + 1)\n                if right_pts:\n                    self.right = KDNode(right_pts, depth + 1)\n\n            def nearest(self, point, best=None, best_dist=float('inf')):\n                if self.points == []:\n                    return best, best_dist\n                node = self.points[0]\n                d = dist(point, node.position)\n                if d < best_dist:\n                    best = node\n                    best_dist = d\n                diff = point[self.axis] - self.median_val\n                close, away = (self.left, self.right) if diff < 0 else (self.right, self.left)\n                if close:\n                    best, best_dist = close.nearest(point, best, best_dist)\n                if away and abs(diff) < best_dist:\n                    best, best_dist = away.nearest(point, best, best_dist)\n                return best, best_dist\n\n            def radius_search(self, point, radius, results):\n                if self.points == []:\n                    return\n                node = self.points[0]\n                d_sq = sum((point[i] - node.position[i]) ** 2 for i in range(dim))\n                if d_sq <= radius * radius:\n                    results.append(node)\n                diff = point[self.axis] - self.median_val\n                if diff - radius <= 0 and self.left:\n                    self.left.radius_search(point, radius, results)\n                if diff + radius >= 0 and self.right:\n                    self.right.radius_search(point, radius, results)\n\n        def build_kdtree(node_list):\n            if not node_list:\n                return None\n            return KDNode(node_list)\n\n        def nearest(tree_nodes, point, tree_kd=None):\n            if not tree_nodes:\n                return None\n            if tree_kd is None:\n                tree_kd = build_kdtree(tree_nodes)\n            n, _ = tree_kd.nearest(point)\n            return n\n\n        def near(tree_nodes, point, radius, tree_kd=None):\n            if not tree_nodes:\n                return []\n            if tree_kd is None:\n                tree_kd = build_kdtree(tree_nodes)\n            result = []\n            tree_kd.radius_search(point, radius, result)\n            return result\n\n        def informed_sample(best_cost):\n            c_min = dist(start_pos, goal_pos)\n            if best_cost == math.inf or best_cost < c_min:\n                while True:\n                    s = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                    if not collision_node(s):\n                        return s\n            c_best = best_cost\n            foci_dist = c_min\n            center = tuple(0.5 * (start_pos[i] + goal_pos[i]) for i in range(dim))\n            a1 = c_best * 0.5\n            val = max(c_best * c_best - foci_dist * foci_dist, 1e-12)\n            a_rest = math.sqrt(val) * 0.5\n\n            while True:\n                while True:\n                    vec = [random.gauss(0, 1) for _ in range(dim)]\n                    norm = math.sqrt(sum(x * x for x in vec))\n                    if norm > 1e-12:\n                        break\n                unit = [x / norm for x in vec]\n                r = random.random() ** (1.0 / dim)\n                ball_sample = [unit[i] * r for i in range(dim)]\n                sample_coords = [0.0] * dim\n                sample_coords[0] = ball_sample[0] * a1\n                for i in range(1, dim):\n                    sample_coords[i] = ball_sample[i] * a_rest\n                sample = tuple(center[i] + sample_coords[i] for i in range(dim))\n                if in_bounds(sample) and not collision_node(sample):\n                    return sample\n\n        def update_parent_and_cost(child, new_parent, new_cost):\n            if child.parent is not None:\n                child.parent.remove_child(child)\n            child.parent = new_parent\n            child.cost = new_cost\n            new_parent.add_child(child)\n\n        def rewire(tree_nodes, tree_kd, new_node, radius):\n            near_nodes = near(tree_nodes, new_node.position, radius, tree_kd)\n            for near_n in near_nodes:\n                if near_n == new_node.parent:\n                    continue\n                cost_new = new_node.cost + dist(new_node.position, near_n.position)\n                if cost_new + 1e-9 < near_n.cost:\n                    if not collision_edge(new_node.position, near_n.position):\n                        update_parent_and_cost(near_n, new_node, cost_new)\n\n        def extract_path(node_start, node_goal):\n            path_start = []\n            n = node_start\n            while n:\n                path_start.append(n.position)\n                n = n.parent\n            path_start.reverse()\n\n            path_goal = []\n            n = node_goal\n            while n:\n                path_goal.append(n.position)\n                n = n.parent\n            if path_start and path_goal and path_start[-1] == path_goal[0]:\n                path_goal = path_goal[1:]\n            return path_start + path_goal\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return list(path)\n            p = list(path)\n            for _ in range(self.shortcut_iterations):\n                if len(p) < 3:\n                    break\n                i = random.randint(0, len(p) - 3)\n                j = random.randint(i + 2, len(p) - 1)\n                if not collision_edge(p[i], p[j], resolution=0.15):\n                    p = p[:i + 1] + p[j:]\n            return p\n\n        tree_start = [Node(start_pos)]\n        tree_goal = [Node(goal_pos)]\n\n        edges = []\n        best_cost = math.inf\n        best_path = None\n\n        radius = self.radius\n        max_goal_rate = 0.30\n        goal_rate_growth = (max_goal_rate - self.goal_sample_rate) / self.max_iter\n\n        def rebuild_kdtree_every_n(nodes, n=self.kd_rebuild_interval):\n            counter = [0]\n            kd = [build_kdtree(nodes)]\n            def update(new_nodes):\n                counter[0] += len(new_nodes)\n                if counter[0] >= n:\n                    kd[0] = build_kdtree(nodes)\n                    counter[0] = 0\n            def get():\n                return kd[0]\n            return update, get\n\n        update_kd_start, get_kd_start = rebuild_kdtree_every_n(tree_start)\n        update_kd_goal, get_kd_goal = rebuild_kdtree_every_n(tree_goal)\n\n        for iteration in range(self.max_iter):\n            self.goal_sample_rate = min(max_goal_rate, self.goal_sample_rate + goal_rate_growth)\n            sample = goal_pos if random.random() < self.goal_sample_rate else informed_sample(best_cost)\n            expanded_this_iter = False\n\n            for tree_a, tree_b, update_kd_a, get_kd_a, update_kd_b, get_kd_b in [\n                (tree_start, tree_goal, update_kd_start, get_kd_start, update_kd_goal, get_kd_goal),\n                (tree_goal, tree_start, update_kd_goal, get_kd_goal, update_kd_start, get_kd_start)\n            ]:\n                kd_a = get_kd_a()\n                nearest_node = nearest(tree_a, sample, kd_a)\n                if nearest_node is None:\n                    continue\n\n                new_pos = steer(nearest_node.position, sample)\n                if (not in_bounds(new_pos)) or collision_node(new_pos) or collision_edge(nearest_node.position, new_pos):\n                    continue\n\n                near_nodes_a = near(tree_a, new_pos, radius, kd_a)\n                min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n                min_parent = nearest_node\n                for near_n in near_nodes_a:\n                    alt_cost = near_n.cost + dist(near_n.position, new_pos)\n                    if alt_cost + 1e-9 < min_cost and not collision_edge(near_n.position, new_pos):\n                        min_cost = alt_cost\n                        min_parent = near_n\n\n                new_node = Node(new_pos, min_parent, min_cost)\n                min_parent.add_child(new_node)\n                tree_a.append(new_node)\n                edges.append((min_parent, new_node))\n                update_kd_a([new_node])\n\n                rewire(tree_a, kd_a, new_node, radius)\n\n                kd_b = get_kd_b()\n                nearest_other = nearest(tree_b, new_node.position, kd_b)\n                if nearest_other is not None:\n                    dist_connect = dist(new_node.position, nearest_other.position)\n                    if dist_connect <= self.step_size and not collision_edge(new_node.position, nearest_other.position):\n                        candidate_path = extract_path(new_node, nearest_other)\n                        candidate_cost = 0.0\n                        for i_ in range(len(candidate_path) - 1):\n                            candidate_cost += dist(candidate_path[i_], candidate_path[i_ + 1])\n                        if candidate_cost + 1e-9 < best_cost:\n                            best_cost = candidate_cost\n                            best_path = shortcut_path(candidate_path)\n                            radius = max(2.0, radius * 0.88)\n                        expanded_this_iter = True\n                        break\n            if expanded_this_iter and best_path is not None:\n                return PlannerResult(True, best_path, tree_start + tree_goal, edges)\n\n            radius = max(2.0, radius * 0.985)\n\n        if best_path is not None:\n            return PlannerResult(True, best_path, tree_start + tree_goal, edges)\n        return PlannerResult(False, [], tree_start + tree_goal, edges)",
          "objective": 158.51575,
          "time_improvement": -590.0,
          "length_improvement": 19.0,
          "smoothness_improvement": 1362.0,
          "node_improvement": -44.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.22825899124145507,
                    "num_nodes_avg": 879.3,
                    "path_length_avg": 154.8810978418102,
                    "smoothness_avg": 0.042001432489013266,
                    "success_improvement": 0.0,
                    "time_improvement": -785.0400048070479,
                    "node_improvement": -121.43037018383276,
                    "length_improvement": 15.107216024853981,
                    "smoothness_improvement": 557.4136260235352,
                    "objective_score": -223.66060369708427
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.6547598600387573,
                    "num_nodes_avg": 1330.6,
                    "path_length_avg": 227.98564313634816,
                    "smoothness_avg": 0.08491459704692796,
                    "success_improvement": 0.0,
                    "time_improvement": -295.44442793316614,
                    "node_improvement": 10.595981992877784,
                    "length_improvement": 23.89183011820052,
                    "smoothness_improvement": 2084.913743529542,
                    "objective_score": -63.873661591381826
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.40051908493041993,
                    "num_nodes_avg": 954.0,
                    "path_length_avg": 121.58798010242599,
                    "smoothness_avg": 0.12125854640017049,
                    "success_improvement": 0.0,
                    "time_improvement": -689.244023113088,
                    "node_improvement": -21.29688493324857,
                    "length_improvement": 19.247053013404045,
                    "smoothness_improvement": 1442.3997598353014,
                    "objective_score": -188.01297632670745
               }
          ],
          "success_rate": 1.0
     }
]