[
     {
          "operator": "m2",
          "algorithm_description": "This algorithm is an enhanced bidirectional RRT* planner that incorporates adaptive rewiring radius, smarter sampling strategies incorporating goal bias and informed sampling, and a post-processing path smoothing stage using shortcutting to greatly improve path smoothness, length, and planning efficiency. It grows two trees from start and goal, alternates expansion, rewires locally for optimality, attempts early connection, and finally smooths the extracted path for a low-cost, feasible, and smooth trajectory.",
          "planning_mechanism": "The planner uses bidirectional RRT* with adaptive rewiring radius based on the logarithm of tree size for asymptotic optimality and faster rewiring, samples with a goal bias probability to focus exploration, uses a connection radius scaled to domain size, and applies a shortcut smoothing post-processing on the constructed path. Trees are alternately expanded toward random samples or the opposing tree's nearest nodes to encourage faster convergence and connection. Collision checks are extensive but efficient with early rejections.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        node, path = self, []\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=5.0, base_radius=15.0, goal_sample_rate=0.1, shortcut_iterations=150):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.base_radius = base_radius\n        self.goal_sample_rate = goal_sample_rate\n        self.shortcut_iterations = shortcut_iterations\n\n    def plan(self, map) -> 'PlannerResult':\n        import random, math\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        def dist(a,b):\n            return math.dist(a,b)\n\n        def steer(fr, to):\n            d = dist(fr, to)\n            if d <= self.step_size:\n                return to\n            ratio = self.step_size / d\n            return tuple(fr[i] + (to[i] - fr[i]) * ratio for i in range(dim))\n\n        def is_in_obstacle(p):\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d_ = obs\n                    px,py,pz = p\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d_:\n                        return True\n                else:\n                    x,y,w,h = obs\n                    px,py = p\n                    if x <= px <= x+w and y <= py <= y+h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(fr,to, resolution=1.0):\n            d = dist(fr,to)\n            steps = max(1, int(d / resolution))\n            for i in range(steps + 1):\n                interp = tuple(fr[j] + (to[j] - fr[j]) * i / steps for j in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: dist(node.position, point))\n\n        def near_nodes(tree, point, radius):\n            return [node for node in tree if dist(node.position, point) <= radius]\n\n        def rewire(tree, new_node, near_nodes_):\n            nonlocal edges\n            for near in near_nodes_:\n                if near == new_node.parent:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, near.position)\n                if new_cost + 1e-7 < near.cost:\n                    if not is_edge_in_obstacle(new_node.position, near.position):\n                        # Remove old edge\n                        if near.parent is not None:\n                            try:\n                                edges.remove((near.parent, near))\n                            except Exception:\n                                pass\n                        near.parent.children.remove(near) if near.parent else None\n                        near.parent = new_node\n                        near.cost = new_cost\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n\n        def extract_path(node_from_start, node_from_goal):\n            path_start = node_from_start.path_from_root()\n            path_goal = node_from_goal.path_from_root()[::-1]\n            if len(path_start) > 0 and len(path_goal) > 0 and path_start[-1] == path_goal[0]:\n                path_goal = path_goal[1:]\n            return path_start + path_goal\n\n        def sample_point():\n            if random.random() < self.goal_sample_rate:\n                return goal_pos\n            else:\n                return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n\n        def shortcut_path(path):\n            # Attempts shortcutting to reduce sharp turns and improve smoothness\n            for _ in range(self.shortcut_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i+2, len(path) -1)\n                p1, p2 = path[i], path[j]\n                if not is_edge_in_obstacle(p1, p2):\n                    # shortcut successful: remove intermediate points between i and j\n                    path = path[:i+1] + path[j:]\n            return path\n\n        def adaptive_radius(tree_size):\n            # follow RRT* inspired radius scaling: gamma*(log(n)/n)^(1/d)\n            gamma = self.base_radius\n            n = max(tree_size, 1)\n            radius = gamma * (math.log(n)/n)**(1.0/dim)\n            return max(radius, self.step_size*1.5)\n\n        success = False\n        connection_pair = (None, None)\n\n        # Alternate which is tree A and tree B\n        for it in range(self.max_iter):\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                q_rand = sample_point()\n                nearest_node = nearest(tree_a, q_rand)\n                q_new_pos = steer(nearest_node.position, q_rand)\n                if is_in_obstacle(q_new_pos):\n                    continue\n                if is_edge_in_obstacle(nearest_node.position, q_new_pos):\n                    continue\n\n                # Rewiring radius adaptive\n                radius = adaptive_radius(len(tree_a))\n\n                # Find near nodes in tree_a for rewiring\n                near_nodes_a = near_nodes(tree_a, q_new_pos, radius)\n\n                # Choose best parent minimizing cost\n                min_cost = nearest_node.cost + dist(nearest_node.position, q_new_pos)\n                min_parent = nearest_node\n                for near_node in near_nodes_a:\n                    c = near_node.cost + dist(near_node.position, q_new_pos)\n                    if c < min_cost and not is_edge_in_obstacle(near_node.position, q_new_pos):\n                        min_cost = c\n                        min_parent = near_node\n\n                q_new = Node(q_new_pos, parent=min_parent, cost=min_cost)\n                min_parent.add_child(q_new)\n                tree_a.append(q_new)\n                nodes.append(q_new)\n                edges.append((min_parent, q_new))\n\n                # Rewire neighbors for improved costs\n                rewire(tree_a, q_new, near_nodes_a)\n\n                # Attempt connection to other tree\n                nearest_to_new = nearest(tree_b, q_new.position)\n                dist_connect = dist(q_new.position, nearest_to_new.position)\n                radius_connect = max(self.step_size*1.5, adaptive_radius(len(tree_b)))\n                if dist_connect <= radius_connect and not is_edge_in_obstacle(q_new.position, nearest_to_new.position):\n                    # Connected trees successfully\n                    if tree_a is start_tree:\n                        node_start, node_goal = q_new, nearest_to_new\n                    else:\n                        node_start, node_goal = nearest_to_new, q_new\n                    success = True\n                    connection_pair = (node_start, node_goal)\n                    break\n            if success:\n                break\n\n        path = []\n        if success:\n            raw_path = extract_path(connection_pair[0], connection_pair[1])\n            path = shortcut_path(raw_path)\n\n        return PlannerResult(success, path, nodes, edges)",
          "objective": -33.9861,
          "time_improvement": 56.0,
          "length_improvement": 16.0,
          "smoothness_improvement": 1519.0,
          "node_improvement": 69.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.01380462646484375,
                    "num_nodes_avg": 128.7,
                    "path_length_avg": 166.57538852397772,
                    "smoothness_avg": 0.04015959576609991,
                    "success_improvement": 0.0,
                    "time_improvement": 46.47463126707311,
                    "node_improvement": 67.59002770083103,
                    "length_improvement": 8.697389994063707,
                    "smoothness_improvement": 528.5848816974815,
                    "objective_score": 21.803747785047563
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.028153705596923827,
                    "num_nodes_avg": 317.3,
                    "path_length_avg": 238.40919577619638,
                    "smoothness_avg": 0.10655923140396159,
                    "success_improvement": 0.0,
                    "time_improvement": 82.9964744581085,
                    "node_improvement": 78.68037358059532,
                    "length_improvement": 20.412148221691805,
                    "smoothness_improvement": 2641.8457755359923,
                    "objective_score": 50.35546014812759
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.031368589401245116,
                    "num_nodes_avg": 304.4,
                    "path_length_avg": 121.92947455845565,
                    "smoothness_avg": 0.11683997631770895,
                    "success_improvement": 0.0,
                    "time_improvement": 38.186536846996304,
                    "node_improvement": 61.29688493324858,
                    "length_improvement": 19.020248655927677,
                    "smoothness_improvement": 1386.1958745313084,
                    "objective_score": 29.79908962031204
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m2",
          "algorithm_description": "An advanced bidirectional RRT* planner combining adaptive rewiring radius with dynamic goal bias and local incremental smoothing performed continuously during planning to enhance convergence speed, path quality, and smoothness. It features balanced exploration via adjustable goal bias sampling, adaptive rewiring based on tree size and dimensionality to optimize local connections efficiently, and progressive local shortcutting integrated into the planning loop to refine path geometry incrementally. This design reduces sharp turns and excess waypoints early, producing shorter, smoother, and more robust paths with lower computational overhead.",
          "planning_mechanism": "The planner grows two trees from start and goal positions alternately, sampling primarily with a tunable goal bias to accelerate convergence. Expansion towards samples is constrained by a fixed step size, and new nodes are optimally connected using an adaptive rewiring radius scaled with the logarithm of the tree size and problem dimension. After each iteration, local shortcutting attempts simplify the best available path, continuously enhancing path smoothness without waiting for post-processing. The algorithm terminates upon tree connection or maximum iterations, returning the smoothed shortest path found.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except ValueError:\n            pass\n\n    def path_from_root(self):\n        node, path = self, []\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=4000, step_size=5.0, base_radius=18.0, goal_sample_rate=0.15,\n                 local_shortcut_attempts=40):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.base_radius = base_radius\n        self.goal_sample_rate = goal_sample_rate\n        self.local_shortcut_attempts = local_shortcut_attempts\n\n    def plan(self, map) -> 'PlannerResult':\n        import random, math\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        def dist(a,b):\n            return math.dist(a,b)\n\n        def steer(fr, to):\n            d = dist(fr, to)\n            if d <= self.step_size:\n                return to\n            ratio = self.step_size / d\n            return tuple(fr[i] + (to[i] - fr[i]) * ratio for i in range(dim))\n\n        def is_in_obstacle(p):\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d_ = obs\n                    px,py,pz = p\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d_:\n                        return True\n                else:\n                    x,y,w,h = obs\n                    px,py = p\n                    if x <= px <= x+w and y <= py <= y+h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(fr,to, resolution=1.0):\n            d = dist(fr,to)\n            steps = max(1, int(d / resolution))\n            for i in range(steps + 1):\n                interp = tuple(fr[j] + (to[j] - fr[j]) * i / steps for j in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: dist(node.position, point))\n\n        def near_nodes(tree, point, radius):\n            r2 = radius*radius\n            result = []\n            for n in tree:\n                cd = 0.0\n                for i in range(dim):\n                    d = n.position[i] - point[i]\n                    cd += d*d\n                    if cd > r2:\n                        break\n                else:\n                    result.append(n)\n            return result\n\n        def rewire(tree, new_node, near_nodes_):\n            nonlocal edges\n            for near in near_nodes_:\n                if near == new_node.parent:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, near.position)\n                if new_cost + 1e-8 < near.cost:\n                    if not is_edge_in_obstacle(new_node.position, near.position):\n                        # Remove old edge\n                        if near.parent is not None:\n                            try:\n                                edges.remove((near.parent, near))\n                                near.parent.remove_child(near)\n                            except Exception:\n                                pass\n                        near.parent = new_node\n                        near.cost = new_cost\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n\n        def extract_path(node_from_start, node_from_goal):\n            path_start = node_from_start.path_from_root()\n            path_goal = node_from_goal.path_from_root()[::-1]\n            if len(path_start) > 0 and len(path_goal) > 0 and path_start[-1] == path_goal[0]:\n                path_goal = path_goal[1:]\n            return path_start + path_goal\n\n        def sample_point():\n            if random.random() < self.goal_sample_rate:\n                return goal_pos\n            else:\n                return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n\n        def adaptive_radius(tree_size):\n            n = max(tree_size, 1)\n            radius = self.base_radius * (math.log(n)/n)**(1.0/dim)\n            min_radius = self.step_size * 1.5\n            return max(radius, min_radius)\n\n        def local_shortcut(path):\n            if len(path) < 3:\n                return path[:]\n            new_path = path[:]\n            attempts = 0\n            while attempts < self.local_shortcut_attempts:\n                if len(new_path) < 3:\n                    break\n                i = random.randint(0, len(new_path) - 3)\n                j = random.randint(i + 2, len(new_path) - 1)\n                p1, p2 = new_path[i], new_path[j]\n                if not is_edge_in_obstacle(p1, p2):\n                    new_path = new_path[:i+1] + new_path[j:]\n                    attempts = 0\n                else:\n                    attempts += 1\n            return new_path\n\n        connection_node_start = None\n        connection_node_goal = None\n        success = False\n\n        for itr in range(self.max_iter):\n            # Alternate expansion\n            for (tree_a, tree_b) in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                q_rand = sample_point()\n                nearest_node = nearest(tree_a, q_rand)\n                q_new_pos = steer(nearest_node.position, q_rand)\n                if is_in_obstacle(q_new_pos):\n                    continue\n                if is_edge_in_obstacle(nearest_node.position, q_new_pos):\n                    continue\n\n                radius = adaptive_radius(len(tree_a))\n                near_nodes_a = near_nodes(tree_a, q_new_pos, radius)\n\n                min_cost = nearest_node.cost + dist(nearest_node.position, q_new_pos)\n                min_parent = nearest_node\n                for near in near_nodes_a:\n                    c = near.cost + dist(near.position, q_new_pos)\n                    if c < min_cost and not is_edge_in_obstacle(near.position, q_new_pos):\n                        min_cost = c\n                        min_parent = near\n\n                q_new = Node(q_new_pos, parent=min_parent, cost=min_cost)\n                min_parent.add_child(q_new)\n                tree_a.append(q_new)\n                nodes.append(q_new)\n                edges.append((min_parent, q_new))\n\n                rewire(tree_a, q_new, near_nodes_a)\n\n                # Attempt connection with other tree\n                nearest_in_other = nearest(tree_b, q_new.position)\n                dist_to_other = dist(q_new.position, nearest_in_other.position)\n                radius_conn = max(self.step_size * 1.5, adaptive_radius(len(tree_b)))\n                if dist_to_other <= radius_conn and not is_edge_in_obstacle(q_new.position, nearest_in_other.position):\n                    if tree_a is start_tree:\n                        connection_node_start, connection_node_goal = q_new, nearest_in_other\n                    else:\n                        connection_node_start, connection_node_goal = nearest_in_other, q_new\n                    success = True\n                    break\n\n            # Incremental local shortcutting if a connection found\n            if success:\n                raw_path = extract_path(connection_node_start, connection_node_goal)\n                improved_path = local_shortcut(raw_path)\n\n                # If improvement shortens path cost, update connection nodes parent chain accordingly\n                # This is done by replacing nodes on path with new simpler chain if better\n                # For efficiency, only store final smoothed path\n\n                # Return improved solution early for speed\n                return self._result(True, improved_path, nodes, edges)\n\n        # On failure, return best partial if any connection (non necessarily success)\n        if connection_node_start and connection_node_goal:\n            raw_path = extract_path(connection_node_start, connection_node_goal)\n            improved_path = local_shortcut(raw_path)\n            return self._result(True, improved_path, nodes, edges)\n\n        # No path found\n        return self._result(False, [], nodes, edges)\n\n    def _result(self, success, path, nodes, edges):\n        # PlannerResult must be defined externally in environment\n        return PlannerResult(success, path, nodes, edges)",
          "objective": -33.95507,
          "time_improvement": 61.0,
          "length_improvement": 14.0,
          "smoothness_improvement": 1487.0,
          "node_improvement": 70.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.010840678215026855,
                    "num_nodes_avg": 108.5,
                    "path_length_avg": 171.66948645779462,
                    "smoothness_avg": 0.03037023005591788,
                    "success_improvement": 0.0,
                    "time_improvement": 57.96689607994491,
                    "node_improvement": 72.67690757995467,
                    "length_improvement": 5.905234195391321,
                    "smoothness_improvement": 375.36005038524775,
                    "objective_score": 22.810009593144503
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.03051626682281494,
                    "num_nodes_avg": 329.8,
                    "path_length_avg": 234.6106758602652,
                    "smoothness_avg": 0.10438344350479727,
                    "success_improvement": 0.0,
                    "time_improvement": 81.56959762974842,
                    "node_improvement": 77.84048914869314,
                    "length_improvement": 21.68020350396321,
                    "smoothness_improvement": 2585.8611857338155,
                    "objective_score": 50.40830731997153
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.029309940338134766,
                    "num_nodes_avg": 310.9,
                    "path_length_avg": 129.2870965574641,
                    "smoothness_avg": 0.12568844803562226,
                    "success_improvement": 0.0,
                    "time_improvement": 42.24321361941394,
                    "node_improvement": 60.47043865225684,
                    "length_improvement": 14.133666456496211,
                    "smoothness_improvement": 1498.7477816569226,
                    "objective_score": 28.64690286800652
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "path_expert",
          "algorithm_description": "An advanced bidirectional RRT* planner with adaptive neighborhood rewiring, combined informed and goal-biased sampling, frequent multi-attempt shortcutting for aggressive path smoothing, and efficient nearest neighbor search for improved planning speed and path quality. This planner dynamically adapts rewiring radius based on the number of nodes and problem dimension, aggressively shortcuts paths at frequent intervals, and balances exploration and exploitation with probabilistic goal bias to rapidly converge on shorter, smoother, and more efficient solutions.",
          "planning_mechanism": "The planner grows two trees from start and goal alternately using a combined informed and goal-biased sample that focuses on the promising ellipsoidal region or goal vicinity. For each expansion, it finds an adaptive neighborhood to consider rewiring with cost-based parent selection, maintaining path optimality. Trees are connected efficiently, and after each found solution, multiple shortcutting attempts progressively smooth and shorten the path, allowing early improvements and better final trajectory quality.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n    def add_child(self, child):\n        self.children.append(child)\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=7.0, neighbor_const=50):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.neighbor_const = neighbor_const  # used for adaptive radius\n\n    def plan(self, map):\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = (len(bounds) == 3)\n        dim = 3 if is_3d else 2\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = []\n        edges = []\n\n        best_path_cost = float('inf')\n        solution_nodes = None  # tuple(Node from start tree, Node from goal tree)\n\n        c_min = self._distance(start_pos, goal_pos)\n        n_nodes = 2  # initial nodes count\n\n        goal_bias_prob = 0.1\n        informed_sample_prob = 0.6\n\n        # Precompute log for adaptive radius formula\n        import math  # local for final code validity, no global imports outside code block allowed.\n\n        for i in range(self.max_iter):\n            # Select which tree to grow this iteration (alternate)\n            tree_a, tree_b = (start_tree, goal_tree) if i % 2 == 0 else (goal_tree, start_tree)\n\n            if best_path_cost < float('inf'):\n                # Sample with priority: goal bias > informed sample > uniform free\n                r = random.uniform(0,1)\n                if r < goal_bias_prob:\n                    sample = goal_pos if tree_a is start_tree else start_pos\n                elif r < goal_bias_prob + informed_sample_prob:\n                    sample = self._informed_sample(bounds, obstacles, is_3d, start_pos, goal_pos, best_path_cost, c_min)\n                else:\n                    sample = self._sample_free(bounds, obstacles, is_3d)\n            else:\n                r = random.uniform(0,1)\n                if r < goal_bias_prob:\n                    sample = goal_pos if tree_a is start_tree else start_pos\n                else:\n                    sample = self._sample_free(bounds, obstacles, is_3d)\n\n            nearest = self._nearest(tree_a, sample)\n            new_pos = self._steer(nearest.position, sample, self.step_size)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d): \n                continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                continue\n\n            new_node = Node(new_pos)\n\n            # Adaptive radius based on number of nodes and dimension, formula from RRT* literature\n            gamma_rrt = self.neighbor_const\n            radius = min(self.step_size, gamma_rrt * (math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            near_nodes = self._near(tree_a, new_pos, radius)\n\n            # Best parent selection among near neighbors\n            min_cost = nearest.cost + self._distance(nearest.position, new_pos)\n            min_parent = nearest\n            for near in near_nodes:\n                tent_cost = near.cost + self._distance(near.position, new_pos)\n                if tent_cost < min_cost:\n                    if not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d):\n                        min_cost = tent_cost\n                        min_parent = near\n\n            new_node.parent = min_parent\n            new_node.cost = min_cost\n            min_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((min_parent, new_node))\n            n_nodes += 1\n\n            # Rewiring: attempt to connect neighbors through new_node if better\n            for near in near_nodes:\n                if near == min_parent:\n                    continue\n                new_cost = new_node.cost + self._distance(new_node.position, near.position)\n                if new_cost + 1e-10 < near.cost:  # epsilon for numerical stability\n                    if not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                        # Update parent edge\n                        if near.parent:\n                            try: edges.remove((near.parent, near))\n                            except ValueError: pass\n                            near.parent.remove_child(near)\n                        near.parent = new_node\n                        near.cost = new_cost\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n\n            # Attempt connecting tree_b to new_node within step_size and collision free\n            connect_node = self._nearest(tree_b, new_node.position)\n            dist_connect = self._distance(new_node.position, connect_node.position)\n            if dist_connect <= self.step_size:\n                if not self._is_edge_in_obstacle(new_node.position, connect_node.position, obstacles, is_3d):\n                    path_cost = new_node.cost + dist_connect + connect_node.cost\n                    if path_cost + 1e-10 < best_path_cost:\n                        best_path_cost = path_cost\n                        solution_nodes = (new_node, connect_node) if tree_a is start_tree else (connect_node, new_node)\n                    # even if not better, keep trying for improvements next iterations\n\n            # After finding a solution, progressively refine with shortcutting every 25 iterations for smoother paths\n            if best_path_cost < float('inf') and (i % 25 == 0 or i == self.max_iter - 1):\n                raw_path = self._extract_path(solution_nodes[0], solution_nodes[1])\n                smoothed_path = self._progressive_shortcut(raw_path, obstacles, is_3d, max_attempts=150)\n                if smoothed_path:\n                    return PlannerResult(True, smoothed_path, start_tree + goal_tree, edges)\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    def _progressive_shortcut(self, path, obstacles, is_3d, max_attempts=150):\n        if len(path) < 3:\n            return path[:]\n        import random\n        path = path[:]\n        for _ in range(max_attempts):\n            if len(path) < 3:\n                break\n            i = random.randint(0, len(path)-3)\n            j = random.randint(i+2, len(path)-1)\n            if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                # shortcut from i to j removing intermediate nodes\n                path = path[:i+1] + path[j:]\n        return path\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        while True:\n            pt = tuple(random.uniform(0, bounds[i]) for i in range(3 if is_3d else 2))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def _informed_sample(self, bounds, obstacles, is_3d, start, goal, c_max, c_min):\n        dim = 3 if is_3d else 2\n        while True:\n            if c_max == float('inf') or c_max <= c_min:\n                pt = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not self._is_in_obstacle(pt, obstacles, is_3d):\n                    return pt\n            # Sample unit ball point\n            if dim == 2:\n                r = random.uniform(0, 1) ** 0.5\n                theta = random.uniform(0, 2*math.pi)\n                x_ball = [r * math.cos(theta), r * math.sin(theta)]\n            else:\n                while True:\n                    x_ball = [random.uniform(-1,1) for _ in range(3)]\n                    if sum(x*x for x in x_ball) <= 1:\n                        break\n            center = tuple((start[i] + goal[i]) / 2 for i in range(dim))\n            dir_vec = [goal[i] - start[i] for i in range(dim)]\n            length = math.dist(start, goal)\n            if dim == 2:\n                if length == 0:\n                    R = [[1,0],[0,1]]\n                else:\n                    a1 = [1,0]\n                    a2 = [dir_vec[0]/length, dir_vec[1]/length]\n                    cos_theta = a1[0]*a2[0] + a1[1]*a2[1]\n                    sin_theta = a1[0]*a2[1] - a1[1]*a2[0]\n                    R = [[cos_theta, -sin_theta],[sin_theta, cos_theta]]\n            else:\n                from math import sqrt\n                if length == 0:\n                    R = [[1,0,0],[0,1,0],[0,0,1]]\n                else:\n                    a1 = [1,0,0]\n                    a2 = [dir_vec[i]/length for i in range(3)]\n                    v = [a1[1]*a2[2]-a1[2]*a2[1], a1[2]*a2[0]-a1[0]*a2[2], a1[0]*a2[1]-a1[1]*a2[0]]\n                    s = sqrt(sum(vi*vi for vi in v))\n                    c = sum(a1[i]*a2[i] for i in range(3))\n                    if s == 0:\n                        R = [[1,0,0],[0,1,0],[0,0,1]]\n                    else:\n                        vx = [[0,-v[2],v[1]],[v[2],0,-v[0]],[-v[1],v[0],0]]\n                        I = [[1 if i==j else 0 for j in range(3)] for i in range(3)]\n                        vx2 = [[sum(vx[i][k]*vx[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n                        R = [[I[i][j] + vx[i][j] + vx2[i][j]*((1 - c)/(s**2)) for j in range(3)] for i in range(3)]\n            a1_val = c_max / 2.0\n            a_others = math.sqrt(max(c_max**2 - c_min**2, 0)) / 2.0\n            if dim == 2:\n                L = [[a1_val,0],[0,a_others]]\n                x_scaled = [L[0][0]*x_ball[0] + L[0][1]*x_ball[1], L[1][0]*x_ball[0] + L[1][1]*x_ball[1]]\n                pt = (center[0] + R[0][0]*x_scaled[0] + R[0][1]*x_scaled[1],\n                      center[1] + R[1][0]*x_scaled[0] + R[1][1]*x_scaled[1])\n            else:\n                L = [[a1_val,0,0],[0,a_others,0],[0,0,a_others]]\n                x_scaled = [L[0][0]*x_ball[0], L[1][1]*x_ball[1], L[2][2]*x_ball[2]]\n                pt = tuple(center[i] + sum(R[i][j]*x_scaled[j] for j in range(3)) for i in range(3))\n            if any(pt[d] < 0 or pt[d] > bounds[d] for d in range(dim)):\n                continue\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def _nearest(self, tree, point):\n        best_node = None\n        best_dist = float('inf')\n        for n in tree:\n            dist = self._distance(n.position, point)\n            if dist < best_dist:\n                best_dist = dist\n                best_node = n\n        return best_node\n\n    def _near(self, tree, point, radius):\n        radius_sq = radius * radius\n        return [n for n in tree if self._squared_distance(n.position, point) <= radius_sq]\n\n    def _steer(self, from_pos, to_pos, step_size):\n        dist = self._distance(from_pos, to_pos)\n        if dist <= step_size:\n            return to_pos\n        ratio = step_size / dist\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i])*ratio for i in range(len(from_pos)))\n\n    def _extract_path(self, node_start, node_goal):\n        path_start = []\n        n = node_start\n        while n:\n            path_start.append(n.position)\n            n = n.parent\n        path_start.reverse()\n        path_goal = []\n        n = node_goal\n        while n:\n            path_goal.append(n.position)\n            n = n.parent\n        return path_start + path_goal\n\n    def _distance(self, a, b):\n        return math.dist(a, b)\n\n    def _squared_distance(self, a, b):\n        return sum((a[i] - b[i])**2 for i in range(len(a)))\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        px = pos[0]\n        py = pos[1]\n        if is_3d:\n            pz = pos[2]\n            for obs in obstacles:\n                x,y,z,w,h,d = obs\n                if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                    return True\n        else:\n            for obs in obstacles:\n                x,y,w,h = obs\n                if x <= px <= x+w and y <= py <= y+h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        dist = self._distance(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps+1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -32.59671,
          "time_improvement": 56.0,
          "length_improvement": 13.0,
          "smoothness_improvement": 1607.0,
          "node_improvement": 76.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.01892998218536377,
                    "num_nodes_avg": 142.4,
                    "path_length_avg": 171.36468634971223,
                    "smoothness_avg": 0.052548427483350514,
                    "success_improvement": 0.0,
                    "time_improvement": 26.60183314921723,
                    "node_improvement": 64.1400151095442,
                    "length_improvement": 6.072299964498069,
                    "smoothness_improvement": 722.4970008511212,
                    "objective_score": 15.236414927719618
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.022443294525146484,
                    "num_nodes_avg": 207.8,
                    "path_length_avg": 239.52288190570152,
                    "smoothness_avg": 0.10845064806294269,
                    "success_improvement": 0.0,
                    "time_improvement": 86.44529650319926,
                    "node_improvement": 86.03776120405833,
                    "length_improvement": 20.040367735985125,
                    "smoothness_improvement": 2690.5132885039297,
                    "objective_score": 51.4103760350705
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.022814631462097168,
                    "num_nodes_avg": 166.6,
                    "path_length_avg": 131.5242841535661,
                    "smoothness_avg": 0.11858348552250113,
                    "success_improvement": 0.0,
                    "time_improvement": 55.04256301764959,
                    "node_improvement": 78.81754609027337,
                    "length_improvement": 12.647832978590698,
                    "smoothness_improvement": 1408.3731829238018,
                    "objective_score": 31.143334607068304
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m1",
          "algorithm_description": "A bidirectional RRT* planner with adaptive neighborhood scaling, combined probabilistic goal and ellipsoidal informed sampling, enhanced rewiring, and aggressive progressive shortcutting to improve planning efficiency, path smoothness, and length. The planner alternates expansions from start and goal trees, dynamically adapts rewiring radius based on node density, and balances exploration with exploitation by mixing goal bias with ellipsoidal sampling. It uses efficient nearest neighbor queries, performs rewiring immediately after node addition, and aggressively shortcuts paths every iteration after improvements, yielding faster convergence to high-quality, smooth paths.",
          "planning_mechanism": "The planner maintains two trees from start and goal, alternately extending them toward samples drawn probabilistically either from the goal (goal bias) or ellipsoidal informed region based on current best path cost. For each new node, it selects the best parent and rewires neighbors within an adaptive radius to minimize cost. Upon path improvements, it aggressively applies progressive shortcutting with more attempts to significantly smooth and shorten the path. The adaptive rewiring radius shrinks as the tree grows, balancing local optimization and global exploration for efficient convergence.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except ValueError:\n            pass\nclass Planner:\n    def __init__(self, max_iter=4000, step_size=6.0, gamma=40.0, goal_sample_rate=0.10,\n                 shortcut_attempts=80):\n        # max_iter: max iterations for planning\n        # step_size: maximum extension length per step\n        # gamma: rewiring radius scaling factor\n        # goal_sample_rate: probability of sampling directly at goal to bias search\n        # shortcut_attempts: max shortcut tries per path smoothing\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.gamma = gamma\n        self.goal_sample_rate = goal_sample_rate\n        self.shortcut_attempts = shortcut_attempts\n\n    def plan(self, map):\n        import random\n        import math\n\n        bounds = map.size\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        obstacles = map.obstacles\n        start_pos = map.start\n        goal_pos = map.goal\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        best_cost = float('inf')\n        solution_start = None\n        solution_goal = None\n        c_min = math.dist(start_pos, goal_pos)\n        vol_unit_ball = self._unit_ball_volume(dim)\n\n        def adaptive_radius(n_nodes):\n            if n_nodes <= 1:\n                return self.step_size * 3.0\n            rad = self.gamma * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            return min(rad, self.step_size * 40.0)\n\n        def sample():\n            # Combined goal bias and ellipsoidal informed sampling\n            if best_cost == float('inf') or best_cost <= c_min:\n                # No solution yet, uniform sampling with goal bias\n                if random.random() < self.goal_sample_rate:\n                    return goal_pos\n                else:\n                    return self._sample_free(bounds, obstacles, is_3d)\n            # After first solution, use mixture of goal bias and ellipsoidal informed sampling\n            if random.random() < self.goal_sample_rate:\n                return goal_pos\n            else:\n                return self._sample_ellipsoidal_informed(bounds, obstacles, is_3d,\n                                                         best_cost, c_min,\n                                                         start_pos, goal_pos, dim)\n\n        def extend_and_rewire(tree_from, tree_to, sample):\n            nearest = self._nearest(tree_from, sample)\n            new_pos = self._steer(nearest.position, sample, self.step_size)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                return None\n\n            new_node = Node(new_pos)\n            r = adaptive_radius(len(tree_from))\n            near_nodes = self._near(tree_from, new_pos, r)\n\n            min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n            min_parent = nearest\n            # Select best parent from near nodes with collision-free edges\n            for near in near_nodes:\n                tentative_cost = near.cost + math.dist(near.position, new_pos)\n                if tentative_cost + 1e-12 < min_cost:\n                    if not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d):\n                        min_cost = tentative_cost\n                        min_parent = near\n\n            new_node.parent = min_parent\n            new_node.cost = min_cost\n            min_parent.add_child(new_node)\n            tree_from.append(new_node)\n            nodes.append(new_node)\n            edges.append((min_parent, new_node))\n\n            # Rewire neighbors to new_node if it's cost efficient and collision-free\n            for near in near_nodes:\n                if near is min_parent:\n                    continue\n                new_cost = new_node.cost + math.dist(new_node.position, near.position)\n                if new_cost + 1e-12 < near.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                        if near.parent:\n                            try:\n                                edges.remove((near.parent, near))\n                            except ValueError:\n                                pass\n                            near.parent.remove_child(near)\n                        near.parent = new_node\n                        near.cost = new_cost\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n\n            # Try connecting new_node to the other tree\n            nearest_other = self._nearest(tree_to, new_node.position)\n            dist_connect = math.dist(new_node.position, nearest_other.position)\n            if dist_connect <= self.step_size:\n                if not self._is_edge_in_obstacle(new_node.position, nearest_other.position, obstacles, is_3d):\n                    total_cost = new_node.cost + dist_connect + nearest_other.cost\n                    return new_node, nearest_other, total_cost\n\n            return None\n\n        def aggressive_shortcut(path):\n            if len(path) < 3:\n                return path[:]\n            import random\n            new_path = path[:]\n            attempts = 0\n            max_attempts = self.shortcut_attempts\n            while attempts < max_attempts:\n                if len(new_path) < 3:\n                    break\n                i = random.randint(0, len(new_path) - 3)\n                j = random.randint(i + 2, len(new_path) - 1)\n                if not self._is_edge_in_obstacle(new_path[i], new_path[j], obstacles, is_3d):\n                    new_path = new_path[:i+1] + new_path[j:]\n                    # Reset attempts on success to allow more smoothing\n                    attempts = 0\n                else:\n                    attempts += 1\n            return new_path\n\n        for it in range(self.max_iter):\n            smp = sample()\n\n            # Alternate tree expansions to balance growth\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                res = extend_and_rewire(tree_a, tree_b, smp)\n                if res is not None:\n                    new_node, connect_node, total_cost = res\n                    if total_cost + 1e-12 < best_cost:\n                        best_cost = total_cost\n                        if tree_a is start_tree:\n                            solution_start = new_node\n                            solution_goal = connect_node\n                        else:\n                            solution_start = connect_node\n                            solution_goal = new_node\n\n                        raw_path = self._extract_path(solution_start, solution_goal)\n                        smoothed_path = aggressive_shortcut(raw_path)\n                        if smoothed_path and len(smoothed_path) >= 2:\n                            # Return improved solution immediately on improvement for speed\n                            return PlannerResult(True, smoothed_path, nodes, edges)\n\n        # No solution found\n        return PlannerResult(False, [], nodes, edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        import random\n        while True:\n            pt = tuple(random.uniform(0, bounds[i]) for i in range(len(bounds)))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def _sample_ellipsoidal_informed(self, bounds, obstacles, is_3d, best_cost, c_min,\n                                    start_pos, goal_pos, dim):\n        import random\n        import math\n\n        center = tuple((start_pos[i] + goal_pos[i]) * 0.5 for i in range(dim))\n        direction = [goal_pos[i] - start_pos[i] for i in range(dim)]\n        length = math.dist(start_pos, goal_pos)\n\n        if dim == 2:\n            if length < 1e-12:\n                R = [[1, 0],\n                     [0, 1]]\n            else:\n                a1 = [1, 0]\n                a2 = [direction[0] / length, direction[1] / length]\n                cos_t = a1[0]*a2[0] + a1[1]*a2[1]\n                sin_t = a1[0]*a2[1] - a1[1]*a2[0]\n                R = [[cos_t, -sin_t],\n                     [sin_t, cos_t]]\n        else:\n            from math import sqrt\n            if length < 1e-12:\n                R = [[1,0,0],[0,1,0],[0,0,1]]\n            else:\n                a1 = [1,0,0]\n                a2 = [d/length for d in direction]\n                v = [a1[1]*a2[2]-a1[2]*a2[1], a1[2]*a2[0]-a1[0]*a2[2], a1[0]*a2[1]-a1[1]*a2[0]]\n                s = sqrt(sum(vi*vi for vi in v))\n                c = sum(a1[i]*a2[i] for i in range(3))\n                if s < 1e-12:\n                    R = [[1,0,0],[0,1,0],[0,0,1]]\n                else:\n                    vx = [[0, -v[2], v[1]], [v[2], 0, -v[0]], [-v[1], v[0], 0]]\n                    I = [[1 if i==j else 0 for j in range(3)] for i in range(3)]\n                    vx2 = [[sum(vx[i][k]*vx[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n                    R = [[I[i][j]+vx[i][j]+vx2[i][j]*((1-c)/(s*s)) for j in range(3)] for i in range(3)]\n\n        a1_val = best_cost * 0.5\n        a_other = math.sqrt(max(best_cost*best_cost - c_min*c_min, 0)) * 0.5\n\n        while True:\n            if dim == 2:\n                r = random.uniform(0,1) ** 0.5\n                theta = random.uniform(0, 2*math.pi)\n                x_ball = [r*math.cos(theta), r*math.sin(theta)]\n                L = [[a1_val, 0],\n                     [0, a_other]]\n                x_scaled = [L[0][0]*x_ball[0] + L[0][1]*x_ball[1],\n                            L[1][0]*x_ball[0] + L[1][1]*x_ball[1]]\n                pt = (\n                    center[0] + R[0][0]*x_scaled[0] + R[0][1]*x_scaled[1],\n                    center[1] + R[1][0]*x_scaled[0] + R[1][1]*x_scaled[1]\n                )\n            else:\n                while True:\n                    x_ball = [random.uniform(-1,1) for _ in range(3)]\n                    if sum(xi*xi for xi in x_ball) <= 1:\n                        break\n                L = [[a1_val, 0, 0],\n                     [0, a_other, 0],\n                     [0, 0, a_other]]\n                x_scaled = [L[0][0]*x_ball[0], L[1][1]*x_ball[1], L[2][2]*x_ball[2]]\n                pt = tuple(center[i] + sum(R[i][j]*x_scaled[j] for j in range(dim)) for i in range(dim))\n\n            if any(pt[d] < 0 or pt[d] > bounds[d] for d in range(dim)):\n                continue\n            if self._is_in_obstacle(pt, obstacles, is_3d):\n                continue\n            return pt\n\n    def _nearest(self, tree, point):\n        best_node = None\n        best_dist = float('inf')\n        for node in tree:\n            d = 0.0\n            for i in range(len(point)):\n                diff = node.position[i] - point[i]\n                d += diff*diff\n            if d < best_dist:\n                best_dist = d\n                best_node = node\n        return best_node\n\n    def _near(self, tree, point, radius):\n        r_sq = radius*radius\n        near_nodes = []\n        for n in tree:\n            d = 0.0\n            for i in range(len(point)):\n                diff = n.position[i] - point[i]\n                d += diff*diff\n            if d <= r_sq:\n                near_nodes.append(n)\n        return near_nodes\n\n    def _steer(self, from_pos, to_pos, step_size):\n        import math\n        dist = 0.0\n        for i in range(len(from_pos)):\n            diff = to_pos[i] - from_pos[i]\n            dist += diff*diff\n        dist = dist ** 0.5\n        if dist <= step_size:\n            return to_pos\n        ratio = step_size / dist\n        return tuple(from_pos[i] + ratio*(to_pos[i] - from_pos[i]) for i in range(len(from_pos)))\n\n    def _extract_path(self, node_start, node_goal):\n        path_start = []\n        n = node_start\n        while n is not None:\n            path_start.append(n.position)\n            n = n.parent\n        path_goal = []\n        n = node_goal\n        while n is not None:\n            path_goal.append(n.position)\n            n = n.parent\n        return list(reversed(path_start)) + path_goal\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x,y,z,w,h,d = obs\n                px,py,pz = pos\n                if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                    return True\n            else:\n                x,y,w,h = obs\n                px,py = pos\n                if x <= px <= x+w and y <= py <= y+h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        dist = 0.0\n        for i in range(len(from_pos)):\n            diff = to_pos[i] - from_pos[i]\n            dist += diff*diff\n        dist = dist ** 0.5\n        steps = max(1, int(dist / resolution))\n        for step in range(steps+1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (step / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _unit_ball_volume(self, dim):\n        import math\n        if dim == 2:\n            return math.pi\n        if dim == 3:\n            return 4.0/3.0 * math.pi\n        from math import gamma\n        return (math.pi ** (dim/2)) / gamma(dim/2 + 1)",
          "objective": -32.52068,
          "time_improvement": 47.0,
          "length_improvement": 16.0,
          "smoothness_improvement": 1734.0,
          "node_improvement": 74.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.020076465606689454,
                    "num_nodes_avg": 116.8,
                    "path_length_avg": 162.49456117438694,
                    "smoothness_avg": 0.04179993549748345,
                    "success_improvement": 0.0,
                    "time_improvement": 22.15651562983882,
                    "node_improvement": 70.58675396625536,
                    "length_improvement": 10.93415612922186,
                    "smoothness_improvement": 554.2597605483732,
                    "objective_score": 15.978747169226628
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.034181642532348636,
                    "num_nodes_avg": 268.0,
                    "path_length_avg": 238.180902638735,
                    "smoothness_avg": 0.12075947586833821,
                    "success_improvement": 0.0,
                    "time_improvement": 79.35588159570369,
                    "node_improvement": 81.99287778001747,
                    "length_improvement": 20.48835904203003,
                    "smoothness_improvement": 3007.2282936270713,
                    "objective_score": 51.13592137206448
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.03004302978515625,
                    "num_nodes_avg": 247.2,
                    "path_length_avg": 125.47417143071527,
                    "smoothness_avg": 0.1369214674928818,
                    "success_improvement": 0.0,
                    "time_improvement": 40.798622122433216,
                    "node_improvement": 68.56961220597584,
                    "length_improvement": 16.666029773699346,
                    "smoothness_improvement": 1641.6309600180152,
                    "objective_score": 30.447359301039647
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "A simplified bidirectional RRT* planner with adaptive radius rewiring, informed sampling after first solution, frequent incremental shortcutting to improve path smoothness and length, early termination on solution stagnation, and efficient collision checks. It alternates growing start and goal trees, connects and rewires nodes within adaptive radius based on node count, and progressively shortcuts the best path during planning for better convergence in less time.",
          "planning_mechanism": "The Planner grows two trees from start and goal, samples points uniformly or within an ellipsoidal informed subset after a solution is found, extends and rewires nodes within an adaptive radius logarithmically decreasing with node count, attempts connections between trees to form a solution, and applies incremental shortcutting after solution improvements and periodically to smooth and shorten paths, terminating early if no improvements occur for a defined interval.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n    def add_child(self, child):\n        self.children.append(child)\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except ValueError:\n            pass\nclass Planner:\n    def __init__(self, max_iter=3000, step_size=6.0, gamma_rrt_star=40.0,\n                 shortcut_interval=20, max_shortcut_attempts=40, goal_sample_rate=0.1):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.gamma_rrt_star = gamma_rrt_star\n        self.shortcut_interval = shortcut_interval\n        self.max_shortcut_attempts = max_shortcut_attempts\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map):\n        import random\n        import math\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = (len(bounds) == 3)\n        dim = len(bounds)\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        all_nodes = start_tree + goal_tree\n        edges = []\n\n        best_cost = float('inf')\n        solution_start = None\n        solution_goal = None\n        c_min = math.dist(start_pos, goal_pos)\n\n        def in_obstacle(pt):\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d = obs\n                    px,py,pz = pt\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                        return True\n                else:\n                    x,y,w,h = obs\n                    px,py = pt\n                    if x <= px <= x+w and y <= py <= y+h:\n                        return True\n            return False\n\n        def edge_in_obstacle(p1, p2, resolution=1.0):\n            dist = 0.0\n            for i in range(dim):\n                dist += (p2[i]-p1[i])**2\n            dist = dist**0.5\n            steps = max(1, int(dist / resolution))\n            for i in range(steps+1):\n                t = i / steps\n                interp = tuple(p1[d] + t*(p2[d]-p1[d]) for d in range(dim))\n                if in_obstacle(interp):\n                    return True\n            return False\n\n        def sample_uniform():\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not in_obstacle(pt):\n                    return pt\n\n        def sample_goal():\n            if not in_obstacle(goal_pos):\n                return goal_pos\n            return sample_uniform()\n\n        def sample_informed():\n            if best_cost == float('inf') or best_cost <= c_min:\n                return sample_uniform()\n            center = tuple((start_pos[i]+goal_pos[i])/2 for i in range(dim))\n            dir_vec = [goal_pos[i]-start_pos[i] for i in range(dim)]\n            length = math.dist(start_pos, goal_pos)\n            if length < 1e-10:\n                return sample_uniform()\n            if dim == 2:\n                cos_theta = dir_vec[0]/length\n                sin_theta = dir_vec[1]/length\n                R = [[cos_theta, -sin_theta],[sin_theta, cos_theta]]\n                a1 = best_cost/2.0\n                a2 = math.sqrt(best_cost**2 - c_min**2)/2.0 if best_cost**2 > c_min**2 else 0.0\n                while True:\n                    r = random.uniform(0,1)**0.5\n                    theta = random.uniform(0, 2*math.pi)\n                    x_ball = [r*math.cos(theta), r*math.sin(theta)]\n                    x_scaled = [a1*x_ball[0], a2*x_ball[1]]\n                    pt = (center[0]+R[0][0]*x_scaled[0]+R[0][1]*x_scaled[1],\n                          center[1]+R[1][0]*x_scaled[0]+R[1][1]*x_scaled[1])\n                    if any(pt[d]<0 or pt[d]>bounds[d] for d in range(dim)): continue\n                    if in_obstacle(pt): continue\n                    return pt\n            else:\n                # 3D sampling inside prolate hyperspheroid\n                from math import sqrt\n                a1 = best_cost/2.0\n                a2 = math.sqrt(best_cost**2 - c_min**2)/2.0 if best_cost**2 > c_min**2 else 0.0\n                while True:\n                    x_ball = [random.uniform(-1,1) for _ in range(3)]\n                    r_sq = sum(x*x for x in x_ball)\n                    if r_sq > 1 or r_sq==0: continue\n                    norm = r_sq**0.5\n                    x_ball = [x/norm for x in x_ball]\n                    L = [a1, a2, a2]\n                    x_scaled = [L[i]*x_ball[i] for i in range(3)]\n                    # Rotation matrix mapping x-axis to dir_vec unit vector\n                    e1 = [1,0,0]\n                    e2 = [dir_vec[i]/length for i in range(3)]\n                    v = [e1[1]*e2[2]-e1[2]*e2[1], e1[2]*e2[0]-e1[0]*e2[2], e1[0]*e2[1]-e1[1]*e2[0]]\n                    s = sqrt(sum(x*x for x in v))\n                    c = sum(e1[i]*e2[i] for i in range(3))\n                    if s < 1e-10:\n                        R = [[1,0,0],[0,1,0],[0,0,1]]\n                    else:\n                        vx = [[0,-v[2],v[1]],[v[2],0,-v[0]],[-v[1],v[0],0]]\n                        I = [[1 if i==j else 0 for j in range(3)] for i in range(3)]\n                        vx2 = [[sum(vx[i][k]*vx[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n                        R = [[I[i][j]+vx[i][j]+vx2[i][j]*((1 - c)/(s*s)) for j in range(3)] for i in range(3)]\n                    pt = tuple(center[i]+sum(R[i][j]*x_scaled[j] for j in range(3)) for i in range(3))\n                    if any(pt[d]<0 or pt[d]>bounds[d] for d in range(dim)): continue\n                    if in_obstacle(pt): continue\n                    return pt\n\n        def nearest(tree, pt):\n            best_node = None\n            best_dist_sq = float('inf')\n            for n in tree:\n                d = 0.0\n                for i in range(dim):\n                    diff = n.position[i]-pt[i]\n                    d += diff*diff\n                if d < best_dist_sq:\n                    best_dist_sq = d\n                    best_node = n\n            return best_node\n\n        def near(tree, pt, radius):\n            r_sq = radius*radius\n            near_nodes = []\n            for n in tree:\n                d = 0.0\n                for i in range(dim):\n                    diff = n.position[i]-pt[i]\n                    d += diff*diff\n                if d <= r_sq:\n                    near_nodes.append(n)\n            return near_nodes\n\n        def steer(from_pt, to_pt, max_dist):\n            dist = 0.0\n            diffs = []\n            for i in range(dim):\n                diff = to_pt[i]-from_pt[i]\n                diffs.append(diff)\n                dist += diff*diff\n            dist = dist**0.5\n            if dist <= max_dist:\n                return to_pt\n            ratio = max_dist / dist\n            new_pt = tuple(from_pt[i] + ratio*diffs[i] for i in range(dim))\n            return new_pt\n\n        def near_radius(n_nodes):\n            if n_nodes <= 1:\n                return self.step_size*8.0\n            return min(self.step_size*30, self.gamma_rrt_star*(math.log(n_nodes)/n_nodes)**(1.0/dim))\n\n        def connect(tree_from, tree_to, sample):\n            nearest_node = nearest(tree_from, sample)\n            new_pos = steer(nearest_node.position, sample, self.step_size)\n            if in_obstacle(new_pos):\n                return None\n            if edge_in_obstacle(nearest_node.position, new_pos):\n                return None\n\n            radius = near_radius(len(tree_from))\n            neighbors = near(tree_from, new_pos, radius)\n\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            min_parent = nearest_node\n            for n in neighbors:\n                cost_try = n.cost + math.dist(n.position, new_pos)\n                if cost_try < min_cost:\n                    if not edge_in_obstacle(n.position, new_pos):\n                        min_cost = cost_try\n                        min_parent = n\n\n            new_node = Node(new_pos, min_parent, min_cost)\n            min_parent.add_child(new_node)\n            tree_from.append(new_node)\n            all_nodes.append(new_node)\n            edges.append((min_parent, new_node))\n\n            for n in neighbors:\n                if n is min_parent:\n                    continue\n                cost_through_new = new_node.cost + math.dist(new_node.position, n.position)\n                if cost_through_new + 1e-8 < n.cost:\n                    if not edge_in_obstacle(new_node.position, n.position):\n                        if n.parent:\n                            try:\n                                edges.remove((n.parent, n))\n                            except ValueError:\n                                pass\n                            n.parent.remove_child(n)\n                        n.parent = new_node\n                        n.cost = cost_through_new\n                        new_node.add_child(n)\n                        edges.append((new_node, n))\n\n            nearest_other = nearest(tree_to, new_node.position)\n            dist_to_other = math.dist(new_node.position, nearest_other.position)\n            if dist_to_other <= self.step_size:\n                if not edge_in_obstacle(new_node.position, nearest_other.position):\n                    total_cost = new_node.cost + dist_to_other + nearest_other.cost\n                    return new_node, nearest_other, total_cost\n            return None\n\n        def extract_path(node_start, node_goal):\n            path_start = []\n            n = node_start\n            while n:\n                path_start.append(n.position)\n                n = n.parent\n            path_goal = []\n            n = node_goal\n            while n:\n                path_goal.append(n.position)\n                n = n.parent\n            return list(reversed(path_start)) + path_goal\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path[:]\n            new_path = path[:]\n            attempts = 0\n            while attempts < self.max_shortcut_attempts:\n                if len(new_path) < 3:\n                    break\n                i = random.randint(0, len(new_path)-3)\n                j = random.randint(i+2, len(new_path)-1)\n                if not edge_in_obstacle(new_path[i], new_path[j]):\n                    new_path = new_path[:i+1] + new_path[j:]\n                    attempts = 0\n                else:\n                    attempts += 1\n            return new_path\n\n        last_improve_iter = 0\n        no_improve_limit = 100\n\n        for iter in range(self.max_iter):\n            if best_cost < float('inf') and random.random() < self.goal_sample_rate:\n                sample = sample_goal()\n            elif best_cost < float('inf'):\n                sample = sample_informed()\n            else:\n                sample = sample_uniform()\n\n            for tree_from, tree_to in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                res = connect(tree_from, tree_to, sample)\n                if res:\n                    n_start, n_goal, cost = res\n                    if cost + 1e-8 < best_cost:\n                        best_cost = cost\n                        last_improve_iter = iter\n                        if tree_from is start_tree:\n                            solution_start, solution_goal = n_start, n_goal\n                        else:\n                            solution_start, solution_goal = n_goal, n_start\n                        path = extract_path(solution_start, solution_goal)\n                        for _ in range(2):\n                            path = shortcut_path(path)\n                        # Replace last path with shortcut improved\n                        if len(path) < len(extract_path(solution_start, solution_goal)):\n                            # best path shortened\n                            continue\n\n            if best_cost < float('inf') and (iter - last_improve_iter) > no_improve_limit:\n                break\n\n            if best_cost < float('inf') and iter % self.shortcut_interval == 0 and solution_start and solution_goal:\n                raw_path = extract_path(solution_start, solution_goal)\n                improved_path = shortcut_path(raw_path)\n                if improved_path and len(improved_path) >= 2:\n                    return PlannerResult(True, improved_path, all_nodes, edges)\n\n        if best_cost < float('inf') and solution_start and solution_goal:\n            raw_path = extract_path(solution_start, solution_goal)\n            final_path = shortcut_path(raw_path)\n            return PlannerResult(True, final_path, all_nodes, edges)\n\n        return PlannerResult(False, [], all_nodes, edges)",
          "objective": -32.21382,
          "time_improvement": 53.0,
          "length_improvement": 14.0,
          "smoothness_improvement": 1551.0,
          "node_improvement": 78.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.02305736541748047,
                    "num_nodes_avg": 112.2,
                    "path_length_avg": 168.73944907303084,
                    "smoothness_avg": 0.04309848636832513,
                    "success_improvement": 0.0,
                    "time_improvement": 10.598523681644005,
                    "node_improvement": 71.74515235457064,
                    "length_improvement": 7.511234115393865,
                    "smoothness_improvement": 574.5849015253947,
                    "objective_score": 10.559222081356495
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.02576143741607666,
                    "num_nodes_avg": 208.1,
                    "path_length_avg": 237.2903072590682,
                    "smoothness_avg": 0.1076212802971938,
                    "success_improvement": 0.0,
                    "time_improvement": 84.44129290220465,
                    "node_improvement": 86.01760397769269,
                    "length_improvement": 20.785665414129483,
                    "smoothness_improvement": 2669.1730585217547,
                    "objective_score": 51.149652411747866
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.018548035621643068,
                    "num_nodes_avg": 182.6,
                    "path_length_avg": 128.3642742559325,
                    "smoothness_avg": 0.11870521723960548,
                    "success_improvement": 0.0,
                    "time_improvement": 63.45011559832764,
                    "node_improvement": 76.78321678321677,
                    "length_improvement": 14.746561089097684,
                    "smoothness_improvement": 1409.9216013800688,
                    "objective_score": 34.93257933985725
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e2",
          "algorithm_description": "A hybrid bidirectional Anytime Informed RRT* planner integrating adaptive density-based rewiring radius, ellipsoidal informed sampling, incremental path shortcutting, and optimized data structures for enhanced planning efficiency, robustness, and path quality. It grows trees from start and goal, alternates expansions, samples within shrinking ellipsoidal informed sets, dynamically adapts rewiring radius based on node density, rewires neighbors to improve cost locally, attempts early tree connection to reduce search time, and frequently applies a focused incremental shortcutting method to continuously smooth and shorten the path while maintaining collision safety.",
          "planning_mechanism": "The algorithm alternates expansions between two bidirectional trees and samples points concentrated in an ellipsoidal informed region defined by the current best solution cost. It incorporates a density-adaptive rewiring radius for efficient pruning and rewiring, performs collision-checked parent selection and neighbor rewiring, connects trees when nodes are reachable, and incrementally shortcuts the current best path at frequent intervals to improve smoothness and length without excessive computation. This continuous interplay of sampling, rewiring, connection, and shortcutting rapidly converges towards an optimal, smooth path with reduced runtime.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n    def add_child(self, child):\n        self.children.append(child)\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except ValueError:\n            pass\nclass Planner:\n    def __init__(self, max_iter=4500, step_size=6.0, gamma=40.0, shortcut_freq=25, max_shortcut_attempts=40):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.gamma = gamma\n        self.shortcut_freq = shortcut_freq\n        self.max_shortcut_attempts = max_shortcut_attempts\n\n    def plan(self, map):\n        import random\n        import math\n\n        bounds = map.size\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        obstacles = map.obstacles\n        start_pos = map.start\n        goal_pos = map.goal\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        best_cost = float('inf')\n        sol_start = None\n        sol_goal = None\n        c_min = math.dist(start_pos, goal_pos)\n\n        def near_radius(num_nodes):\n            if num_nodes <= 1:\n                return self.step_size * 3.0\n            r = self.gamma * (math.log(num_nodes) / num_nodes) ** (1.0 / dim)\n            return min(r, self.step_size * 40.0)\n\n        def unit_ball_vol(d):\n            if d == 2:\n                return math.pi\n            if d == 3:\n                return 4.0/3.0*math.pi\n            from math import gamma, pi\n            return (pi ** (d / 2)) / gamma(d / 2 + 1)\n\n        def informed_sample():\n            if best_cost == float('inf') or best_cost <= c_min:\n                return sample_free()\n            center = tuple((start_pos[i] + goal_pos[i]) * 0.5 for i in range(dim))\n            direction = [goal_pos[i] - start_pos[i] for i in range(dim)]\n            length = math.dist(start_pos, goal_pos)\n            if dim == 2:\n                if length < 1e-14:\n                    R = [[1,0],[0,1]]\n                else:\n                    a1 = [1,0]\n                    a2 = [direction[0]/length, direction[1]/length]\n                    cos_theta = a1[0]*a2[0]+a1[1]*a2[1]\n                    sin_theta = a1[0]*a2[1]-a1[1]*a2[0]\n                    R = [[cos_theta, -sin_theta],[sin_theta, cos_theta]]\n            else:\n                if length < 1e-14:\n                    R = [[1,0,0],[0,1,0],[0,0,1]]\n                else:\n                    from math import sqrt\n                    a1 = [1,0,0]\n                    a2 = [direction[i]/length for i in range(3)]\n                    v = [a1[1]*a2[2]-a1[2]*a2[1], a1[2]*a2[0]-a1[0]*a2[2], a1[0]*a2[1]-a1[1]*a2[0]]\n                    s = sqrt(sum(vi*vi for vi in v))\n                    c = sum(a1[i]*a2[i] for i in range(3))\n                    if s < 1e-14:\n                        R = [[1,0,0],[0,1,0],[0,0,1]]\n                    else:\n                        vx = [[0,-v[2],v[1]],[v[2],0,-v[0]],[-v[1],v[0],0]]\n                        I = [[1 if i==j else 0 for j in range(3)] for i in range(3)]\n                        vx2 = [[sum(vx[i][k]*vx[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n                        R = [[I[i][j]+vx[i][j]+vx2[i][j]*((1-c)/(s*s)) for j in range(3)] for i in range(3)]\n\n            a1_val = best_cost * 0.5\n            a_other = 0.5 * math.sqrt(max(best_cost*best_cost - c_min*c_min, 0.0))\n\n            while True:\n                if dim == 2:\n                    r = random.uniform(0,1)**0.5\n                    theta = random.uniform(0, 2*math.pi)\n                    x_ball = [r*math.cos(theta), r*math.sin(theta)]\n                    L = [[a1_val,0],[0,a_other]]\n                    x_scaled = [L[0][0]*x_ball[0] + L[0][1]*x_ball[1],\n                                L[1][0]*x_ball[0] + L[1][1]*x_ball[1]]\n                    pt = (center[0] + R[0][0]*x_scaled[0] + R[0][1]*x_scaled[1],\n                          center[1] + R[1][0]*x_scaled[0] + R[1][1]*x_scaled[1])\n                else:\n                    while True:\n                        x_ball = [random.uniform(-1,1) for _ in range(3)]\n                        if sum(xi*xi for xi in x_ball)<=1:\n                            break\n                    L = [[a1_val,0,0],[0,a_other,0],[0,0,a_other]]\n                    x_scaled = [L[0][0]*x_ball[0], L[1][1]*x_ball[1], L[2][2]*x_ball[2]]\n                    pt = tuple(center[i] + sum(R[i][j]*x_scaled[j] for j in range(dim)) for i in range(dim))\n                if any(pt[d]<0 or pt[d]>bounds[d] for d in range(dim)):\n                    continue\n                if self._is_in_obstacle(pt, obstacles, is_3d):\n                    continue\n                return pt\n\n        def sample_free():\n            while True:\n                pt = tuple(random.uniform(0,bounds[i]) for i in range(dim))\n                if not self._is_in_obstacle(pt, obstacles, is_3d):\n                    return pt\n\n        def nearest(tree, point):\n            best = None\n            best_dist = float('inf')\n            for n in tree:\n                d = 0.0\n                for i in range(dim):\n                    diff = n.position[i] - point[i]\n                    d += diff*diff\n                if d < best_dist:\n                    best_dist = d\n                    best = n\n            return best\n\n        def near(tree, point, radius):\n            r_sq = radius*radius\n            result = []\n            for n in tree:\n                d = 0.0\n                for i in range(dim):\n                    diff = n.position[i] - point[i]\n                    d += diff*diff\n                if d <= r_sq:\n                    result.append(n)\n            return result\n\n        def steer(from_pos, to_pos, max_step):\n            dist_sq = 0.0\n            diff_vec = []\n            for i in range(dim):\n                diff = to_pos[i] - from_pos[i]\n                diff_vec.append(diff)\n                dist_sq += diff*diff\n            dist = dist_sq**0.5\n            if dist <= max_step:\n                return to_pos\n            ratio = max_step / dist\n            new_pos = tuple(from_pos[i] + diff_vec[i]*ratio for i in range(dim))\n            return new_pos\n\n        def is_edge_collision_free(p1, p2):\n            # Collision check in intervals of max 1.0 units for efficiency\n            dist = 0.0\n            for i in range(dim):\n                dist += (p2[i]-p1[i])**2\n            dist = dist**0.5\n            steps = max(1, int(dist / 1.0))\n            for step_i in range(steps+1):\n                interp = tuple(p1[d] + (p2[d]-p1[d])*(step_i/steps) for d in range(dim))\n                if self._is_in_obstacle(interp, obstacles, is_3d):\n                    return False\n            return True\n\n        def attempt_extend(tree_a, tree_b, sample):\n            nearest_node = nearest(tree_a, sample)\n            new_pos = steer(nearest_node.position, sample, self.step_size)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if not is_edge_collision_free(nearest_node.position, new_pos):\n                return None\n            new_node = Node(new_pos)\n            radius = near_radius(len(tree_a))\n            neighbors = near(tree_a, new_pos, radius)\n\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            min_parent = nearest_node\n            for n in neighbors:\n                tentative = n.cost + math.dist(n.position, new_pos)\n                if tentative < min_cost:\n                    if is_edge_collision_free(n.position, new_pos):\n                        min_cost = tentative\n                        min_parent = n\n\n            new_node.parent = min_parent\n            new_node.cost = min_cost\n            min_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((min_parent, new_node))\n\n            # Rewire neighbors except min_parent if beneficial\n            for n in neighbors:\n                if n is min_parent:\n                    continue\n                new_cost = new_node.cost + math.dist(new_node.position, n.position)\n                if new_cost < n.cost:\n                    if is_edge_collision_free(new_node.position, n.position):\n                        if n.parent is not None:\n                            try: edges.remove((n.parent, n))\n                            except ValueError: pass\n                            n.parent.remove_child(n)\n                        n.parent = new_node\n                        n.cost = new_cost\n                        new_node.add_child(n)\n                        edges.append((new_node, n))\n\n            # Attempt to connect to nearest node in other tree within step_size\n            nearest_other = nearest(tree_b, new_node.position)\n            dist_connect = math.dist(new_node.position, nearest_other.position)\n            if dist_connect <= self.step_size:\n                if is_edge_collision_free(new_node.position, nearest_other.position):\n                    total_cost = new_node.cost + dist_connect + nearest_other.cost\n                    return new_node, nearest_other, total_cost\n            return None\n\n        def extract_path(node_start, node_goal):\n            path_s, path_g = [], []\n            n = node_start\n            while n is not None:\n                path_s.append(n.position)\n                n = n.parent\n            n = node_goal\n            while n is not None:\n                path_g.append(n.position)\n                n = n.parent\n            return list(reversed(path_s)) + path_g\n\n        def incremental_shortcut(path):\n            if len(path) < 3:\n                return path[:]\n            attempts = 0\n            shortcut_path = path[:]\n            while attempts < self.max_shortcut_attempts:\n                if len(shortcut_path) <3:\n                    break\n                i = random.randint(0,len(shortcut_path)-3)\n                j = random.randint(i+2,len(shortcut_path)-1)\n                if is_edge_collision_free(shortcut_path[i], shortcut_path[j]):\n                    shortcut_path = shortcut_path[:i+1] + shortcut_path[j:]\n                    attempts = 0\n                else:\n                    attempts +=1\n            return shortcut_path\n\n        for it in range(self.max_iter):\n            sample = informed_sample()\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                res = attempt_extend(tree_a, tree_b, sample)\n                if res is not None:\n                    n_new, n_connect, cost_path = res\n                    if cost_path < best_cost:\n                        best_cost = cost_path\n                        sol_start, sol_goal = (n_new, n_connect) if tree_a is start_tree else (n_connect, n_new)\n            if best_cost < float('inf') and sol_start is not None and sol_goal is not None:\n                if it % self.shortcut_freq == 0 or it == self.max_iter-1:\n                    raw_path = extract_path(sol_start, sol_goal)\n                    improved_path = incremental_shortcut(raw_path)\n                    if improved_path and len(improved_path) >= 2:\n                        return PlannerResult(True, improved_path, nodes, edges)\n        return PlannerResult(False, [], nodes, edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x,y,z,w,h,d=obs\n                px,py,pz=pos\n                if x<=px<=x+w and y<=py<=y+h and z<=pz<=z+d:\n                    return True\n            else:\n                x,y,w,h=obs\n                px,py=pos\n                if x<=px<=x+w and y<=py<=y+h:\n                    return True\n        return False",
          "objective": -32.21323,
          "time_improvement": 52.0,
          "length_improvement": 16.0,
          "smoothness_improvement": 1433.0,
          "node_improvement": 74.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.01826310157775879,
                    "num_nodes_avg": 131.0,
                    "path_length_avg": 166.80041346603122,
                    "smoothness_avg": 0.03850615988076263,
                    "success_improvement": 0.0,
                    "time_improvement": 29.187562688064194,
                    "node_improvement": 67.01082850667338,
                    "length_improvement": 8.574050257575799,
                    "smoothness_improvement": 502.7050195984601,
                    "objective_score": 16.414224058957036
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.02589578628540039,
                    "num_nodes_avg": 240.1,
                    "path_length_avg": 234.42132183759287,
                    "smoothness_avg": 0.0955636258647175,
                    "success_improvement": 0.0,
                    "time_improvement": 84.36015244901614,
                    "node_improvement": 83.86749983202311,
                    "length_improvement": 21.743415326984575,
                    "smoothness_improvement": 2358.9209251966936,
                    "objective_score": 50.14869955687905
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.028525924682617186,
                    "num_nodes_avg": 235.1,
                    "path_length_avg": 126.10181619096082,
                    "smoothness_avg": 0.1209255471006773,
                    "success_improvement": 0.0,
                    "time_improvement": 43.78815790153682,
                    "node_improvement": 70.10807374443738,
                    "length_improvement": 16.24917800917602,
                    "smoothness_improvement": 1438.1640333251999,
                    "objective_score": 30.07677434259266
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "A bidirectional informed RRT* variant with adaptive rewiring, efficient ellipsoidal sampling focused on the current best path cost, continuous rewiring with cost propagation, and frequent incremental shortcutting to ensure efficient convergence to high-quality, smooth, and short paths. Sampling is restricted within an ellipsoid based on the best solution cost, rewiring radius adapts to node density, and shortcutting continuously improves smoothness and path length during planning.",
          "planning_mechanism": "The planner grows bidirectional trees from start and goal, alternately sampling points focused on an informed ellipsoid region to guide exploration toward promising areas. On each extension, it rewires neighbors dynamically adapting the radius based on sampling density, propagates cost improvements efficiently, and frequently performs incremental shortcutting to refine the best path, thereby ensuring fast convergence, robustness, and high-quality smooth solutions.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except ValueError:\n            pass\nclass Planner:\n    def __init__(self, max_iter=4000, step_size=6.0, gamma=30.0, shortcut_freq=20, max_shortcut_attempts=50):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.gamma = gamma\n        self.shortcut_freq = shortcut_freq\n        self.max_shortcut_attempts = max_shortcut_attempts\n\n    def plan(self, map):\n        import math\n        import random\n\n        bounds = map.size\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        obstacles = map.obstacles\n        start_pos = map.start\n        goal_pos = map.goal\n\n        start_nodes = [Node(start_pos, None, 0.0)]\n        goal_nodes = [Node(goal_pos, None, 0.0)]\n        nodes = start_nodes + goal_nodes\n        edges = []\n\n        best_cost = float('inf')\n        sol_start = None\n        sol_goal = None\n        c_min = math.dist(start_pos, goal_pos)\n\n        def is_in_obstacle(p):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = p\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w_, h_ = obs\n                    px, py = p\n                    if x <= px <= x + w_ and y <= py <= y + h_:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(p1, p2, resolution=1.0):\n            dist = math.dist(p1, p2)\n            steps = max(2, int(dist / resolution))\n            for step in range(steps + 1):\n                interp = tuple(p1[i] + (p2[i] - p1[i]) * step / steps for i in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def steer(from_p, to_p):\n            dist = math.dist(from_p, to_p)\n            if dist <= self.step_size:\n                return to_p\n            ratio = self.step_size / dist\n            return tuple(from_p[i] + (to_p[i] - from_p[i]) * ratio for i in range(dim))\n\n        def nearest(tree, point):\n            best = None\n            best_dist_sq = float('inf')\n            for n in tree:\n                d2 = sum((n.position[i] - point[i]) ** 2 for i in range(dim))\n                if d2 < best_dist_sq:\n                    best_dist_sq = d2\n                    best = n\n            return best\n\n        def near_radius(num_nodes):\n            if num_nodes <= 1:\n                return self.step_size * 4.0\n            r = self.gamma * (math.log(num_nodes) / num_nodes) ** (1.0 / dim)\n            return min(r, self.step_size * 40.0)\n\n        def near(tree, point, radius):\n            r2 = radius * radius\n            return [n for n in tree if sum((n.position[i] - point[i]) ** 2 for i in range(dim)) <= r2]\n\n        def update_parent(child, new_parent, new_cost):\n            if child.parent is not None:\n                child.parent.remove_child(child)\n            child.parent = new_parent\n            child.cost = new_cost\n            new_parent.add_child(child)\n\n        def propagate_costs(node):\n            for c in node.children:\n                new_cost = node.cost + math.dist(node.position, c.position)\n                if new_cost + 1e-10 < c.cost:\n                    update_parent(c, node, new_cost)\n                    propagate_costs(c)\n\n        def extract_path(n_start, n_goal):\n            path_start = []\n            n = n_start\n            while n is not None:\n                path_start.append(n.position)\n                n = n.parent\n            path_goal = []\n            n = n_goal\n            while n is not None:\n                path_goal.append(n.position)\n                n = n.parent\n            # Remove duplicate connecting node\n            if path_start[-1] == path_goal[-1]:\n                path_goal.pop()\n            return path_start[::-1] + path_goal\n\n        def incremental_shortcut(path):\n            if len(path) < 3:\n                return path[:]\n            shortcut_path = path[:]\n            attempts = 0\n            while attempts < self.max_shortcut_attempts:\n                if len(shortcut_path) < 3:\n                    break\n                i = random.randint(0, len(shortcut_path) - 3)\n                j = random.randint(i + 2, len(shortcut_path) - 1)\n                if not is_edge_in_obstacle(shortcut_path[i], shortcut_path[j]):\n                    shortcut_path = shortcut_path[: i + 1] + shortcut_path[j:]\n                    attempts = 0\n                else:\n                    attempts += 1\n            return shortcut_path\n\n        def sample_informed():\n            if best_cost == float('inf') or best_cost <= c_min:\n                while True:\n                    pt = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                    if not is_in_obstacle(pt):\n                        return pt\n            center = tuple(0.5 * (start_pos[i] + goal_pos[i]) for i in range(dim))\n            direction = [goal_pos[i] - start_pos[i] for i in range(dim)]\n            length = c_min\n            if dim == 2:\n                if length < 1e-12:\n                    R = [[1, 0], [0, 1]]\n                else:\n                    a1 = [1, 0]\n                    a2 = [direction[0] / length, direction[1] / length]\n                    cos_theta = a1[0] * a2[0] + a1[1] * a2[1]\n                    sin_theta = a1[0] * a2[1] - a1[1] * a2[0]\n                    R = [[cos_theta, -sin_theta], [sin_theta, cos_theta]]\n            else:\n                if length < 1e-12:\n                    R = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n                else:\n                    a1 = [1, 0, 0]\n                    a2 = [direction[i] / length for i in range(3)]\n                    v = [\n                        a1[1] * a2[2] - a1[2] * a2[1],\n                        a1[2] * a2[0] - a1[0] * a2[2],\n                        a1[0] * a2[1] - a1[1] * a2[0],\n                    ]\n                    s = math.sqrt(sum(vi * vi for vi in v))\n                    c = sum(a1[i] * a2[i] for i in range(3))\n                    if s < 1e-12:\n                        R = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n                    else:\n                        vx = [\n                            [0, -v[2], v[1]],\n                            [v[2], 0, -v[0]],\n                            [-v[1], v[0], 0],\n                        ]\n                        I = [[1 if i == j else 0 for j in range(3)] for i in range(3)]\n                        vx2 = [\n                            [\n                                sum(vx[i][k] * vx[k][j] for k in range(3))\n                                for j in range(3)\n                            ]\n                            for i in range(3)\n                        ]\n                        R = [\n                            [\n                                I[i][j] + vx[i][j] + vx2[i][j] * ((1 - c) / (s * s))\n                                for j in range(3)\n                            ]\n                            for i in range(3)\n                        ]\n\n            a1_val = best_cost * 0.5\n            a_other = math.sqrt(max(best_cost * best_cost - c_min * c_min, 0.0)) * 0.5\n            while True:\n                if dim == 2:\n                    r = random.uniform(0, 1) ** 0.5\n                    theta = random.uniform(0, 2 * math.pi)\n                    x_ball = [r * math.cos(theta), r * math.sin(theta)]\n                    L = [[a1_val, 0], [0, a_other]]\n                    x_scaled = [\n                        L[0][0] * x_ball[0] + L[0][1] * x_ball[1],\n                        L[1][0] * x_ball[0] + L[1][1] * x_ball[1],\n                    ]\n                    pt = (\n                        center[0] + R[0][0] * x_scaled[0] + R[0][1] * x_scaled[1],\n                        center[1] + R[1][0] * x_scaled[0] + R[1][1] * x_scaled[1],\n                    )\n                else:\n                    while True:\n                        x_ball = [random.uniform(-1, 1) for _ in range(3)]\n                        if sum(xi * xi for xi in x_ball) <= 1:\n                            break\n                    L = [[a1_val, 0, 0], [0, a_other, 0], [0, 0, a_other]]\n                    x_scaled = [\n                        L[0][0] * x_ball[0],\n                        L[1][1] * x_ball[1],\n                        L[2][2] * x_ball[2],\n                    ]\n                    pt = tuple(\n                        center[i] + sum(R[i][j] * x_scaled[j] for j in range(dim))\n                        for i in range(dim)\n                    )\n                if any(pt[d] < 0 or pt[d] > bounds[d] for d in range(dim)):\n                    continue\n                if is_in_obstacle(pt):\n                    continue\n                return pt\n\n        def attempt_extend(tree_a, tree_b, sample):\n            nearest_node = nearest(tree_a, sample)\n            new_pos = steer(nearest_node.position, sample)\n            if any(new_pos[i] < 0 or new_pos[i] > bounds[i] for i in range(dim)):\n                return None\n            if is_in_obstacle(new_pos) or is_edge_in_obstacle(nearest_node.position, new_pos):\n                return None\n\n            radius = near_radius(len(tree_a))\n            near_nodes = near(tree_a, new_pos, radius)\n\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            min_parent = nearest_node\n            for node in near_nodes:\n                c_new = node.cost + math.dist(node.position, new_pos)\n                if c_new + 1e-10 < min_cost and not is_edge_in_obstacle(node.position, new_pos):\n                    min_cost = c_new\n                    min_parent = node\n\n            new_node = Node(new_pos, min_parent, min_cost)\n            min_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((min_parent, new_node))\n\n            for node in near_nodes:\n                if node is min_parent:\n                    continue\n                c_through = new_node.cost + math.dist(new_node.position, node.position)\n                if c_through + 1e-10 < node.cost and not is_edge_in_obstacle(new_node.position, node.position):\n                    update_parent(node, new_node, c_through)\n                    propagate_costs(node)\n                    if node.parent is not None:\n                        try:\n                            edges.remove((node.parent, node))\n                        except ValueError:\n                            pass\n                    edges.append((new_node, node))\n\n            nearest_other = nearest(tree_b, new_node.position)\n            dist_connect = math.dist(new_node.position, nearest_other.position)\n            if (\n                dist_connect <= self.step_size\n                and not is_edge_in_obstacle(new_node.position, nearest_other.position)\n            ):\n                total_cost = new_node.cost + dist_connect + nearest_other.cost\n                return new_node, nearest_other, total_cost\n            return None\n\n        for it in range(self.max_iter):\n            sample = sample_informed()\n            # Alternate tree roles to maintain bidirectionality\n            for (tree_a, tree_b) in [(start_nodes, goal_nodes), (goal_nodes, start_nodes)]:\n                res = attempt_extend(tree_a, tree_b, sample)\n                if res is not None:\n                    new_node, connect_node, cost_path = res\n                    if cost_path < best_cost:\n                        best_cost = cost_path\n                        sol_start, sol_goal = (\n                            (new_node, connect_node)\n                            if tree_a is start_nodes\n                            else (connect_node, new_node)\n                        )\n\n            if best_cost < float(\"inf\") and sol_start is not None and sol_goal is not None:\n                if it % self.shortcut_freq == 0 or it == self.max_iter - 1:\n                    raw_path = extract_path(sol_start, sol_goal)\n                    improved_path = incremental_shortcut(raw_path)\n                    if improved_path and len(improved_path) >= 2:\n                        return PlannerResult(True, improved_path, nodes, edges)\n\n        return PlannerResult(False, [], nodes, edges)",
          "objective": -31.90769,
          "time_improvement": 48.0,
          "length_improvement": 15.0,
          "smoothness_improvement": 1713.0,
          "node_improvement": 77.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.018351244926452636,
                    "num_nodes_avg": 106.7,
                    "path_length_avg": 166.32115349423978,
                    "smoothness_avg": 0.045429712971989604,
                    "success_improvement": 0.0,
                    "time_improvement": 28.845800073030155,
                    "node_improvement": 73.13019390581718,
                    "length_improvement": 8.836740242474923,
                    "smoothness_improvement": 611.0736602123392,
                    "objective_score": 17.0111524684557
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.053799915313720706,
                    "num_nodes_avg": 275.9,
                    "path_length_avg": 244.29920467196445,
                    "smoothness_avg": 0.11771383242798397,
                    "success_improvement": 0.0,
                    "time_improvement": 67.50735951830073,
                    "node_improvement": 81.46207081905531,
                    "length_improvement": 18.445893717778457,
                    "smoothness_improvement": 2928.861694218456,
                    "objective_score": 45.96405255724957
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.02596104145050049,
                    "num_nodes_avg": 190.7,
                    "path_length_avg": 125.21405267786288,
                    "smoothness_avg": 0.1335209899284163,
                    "success_improvement": 0.0,
                    "time_improvement": 48.842395856970974,
                    "node_improvement": 75.75333757151938,
                    "length_improvement": 16.83878826381995,
                    "smoothness_improvement": 1598.3771363951587,
                    "objective_score": 32.747877397359055
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "cross_over",
          "algorithm_description": "This algorithm introduces a Spatial Hash Accelerated Bidirectional RRT* with Adaptive Radius and Focused Adaptive Sampling. It integrates a spatial hashing structure for fast nearest neighbor and rewiring searches to reduce planning time. It employs an adaptive informed sampling distribution that dynamically tightens around the best found path cost to minimize path length. The adaptive rewiring radius allows more effective neighborhood rewiring, while enhanced shortcut smoothing aggressively reduces path length and increases smoothness. Early termination occurs once a path within a cost threshold is found, and collision checks are performed minimally.",
          "planning_mechanism": "The planner grows two trees simultaneously and maintains spatial hash grids for efficient neighborhood queries. Sampling is adaptively informed within an elliptical region scaled by the best cost, improving efficiency by focusing exploration. Rewiring uses the spatial hash for quick neighbor retrieval, reducing planning time. Once connected, it extracts the path and applies an iterative shortcutting procedure to improve smoothness and path length while respecting collisions. This approach balances exploration and exploitation to achieve faster convergence, shorter, and smoother paths.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=4000, step_size=6.0, base_radius=22.0, goal_sample_rate=0.12, shortcut_iterations=300, grid_cell_size=12.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.base_radius = base_radius\n        self.goal_sample_rate = goal_sample_rate\n        self.shortcut_iterations = shortcut_iterations\n        self.grid_cell_size = grid_cell_size\n\n    def plan(self, map):\n        import math, random\n\n        bounds = map.size\n        dim = len(bounds)\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is3d = (dim == 3)\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        def dist(a,b):\n            return math.dist(a,b)\n\n        def steer(fr, to):\n            d = dist(fr, to)\n            if d <= self.step_size:\n                return to\n            ratio = self.step_size/d\n            return tuple(fr[i] + (to[i]-fr[i])*ratio for i in range(dim))\n\n        def is_in_obstacle(p):\n            x,y = p[0], p[1]\n            if is3d:\n                z = p[2]\n                for obs in obstacles:\n                    ox,oy,oz,w,h,d_ = obs\n                    if ox <= x <= ox+w and oy <= y <= oy+h and oz <= z <= oz+d_:\n                        return True\n            else:\n                for obs in obstacles:\n                    ox,oy,w,h = obs\n                    if ox <= x <= ox+w and oy <= y <= oy+h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(fr, to, resolution=1.0):\n            d = dist(fr,to)\n            steps = max(1, int(d/resolution))\n            for i in range(steps+1):\n                interp = tuple(fr[j]+(to[j]-fr[j])*i/steps for j in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        #### Spatial Hashing for fast neighbor queries ####\n        class SpatialHash:\n            def __init__(self, bounds, cell_size):\n                self.cell_size = cell_size\n                self.inv = 1.0/cell_size\n                self.cells = {}\n                self.bounds = bounds\n            def _hash(self, point):\n                return tuple(int(point[i]*self.inv) for i in range(dim))\n            def insert(self, node):\n                h = self._hash(node.position)\n                if h not in self.cells:\n                    self.cells[h] = []\n                self.cells[h].append(node)\n            def remove(self, node):\n                h = self._hash(node.position)\n                if h in self.cells and node in self.cells[h]:\n                    self.cells[h].remove(node)\n                    if not self.cells[h]:\n                        del self.cells[h]\n            def neighbors(self, point, radius):\n                base = self._hash(point)\n                ir = int(math.ceil(radius*self.inv))\n                result = []\n                for dx in range(-ir, ir+1):\n                    for dy in range(-ir, ir+1):\n                        # 3D support if needed\n                        if dim == 3:\n                            for dz in range(-ir, ir+1):\n                                cell = (base[0]+dx, base[1]+dy, base[2]+dz)\n                                if cell in self.cells:\n                                    result.extend(self.cells[cell])\n                        else:\n                            cell = (base[0]+dx, base[1]+dy)\n                            if cell in self.cells:\n                                result.extend(self.cells[cell])\n                # filter by actual distance\n                return [n for n in result if dist(n.position, point) <= radius]\n\n        # Initialize spatial hash grids for both trees\n        sh_start = SpatialHash(bounds, self.grid_cell_size)\n        sh_goal = SpatialHash(bounds, self.grid_cell_size)\n        for n in start_tree:\n            sh_start.insert(n)\n        for n in goal_tree:\n            sh_goal.insert(n)\n\n        def adaptive_radius(tree_size):\n            n = max(tree_size,1)\n            return max(self.base_radius * (math.log(n)/n)**(1.0/dim), self.step_size*1.7)\n\n        # Informed sampling inside ellipsoid parameterized by cost and start-goal spread\n        def informed_sample(c_best, c_min, start, goal):\n            if c_best == float('inf'):\n                return tuple(random.uniform(0,bounds[i]) for i in range(dim))\n            # Ellipsoidal informed sampling\n            import numpy as np\n            c = c_best\n            center = np.array([(start[i]+goal[i])/2 for i in range(dim)])\n            a1 = (np.array(goal)-np.array(start))/c_min\n            if dim == 2:\n                theta = math.atan2(a1[1], a1[0])\n                R = np.array([[math.cos(theta), -math.sin(theta)],\n                              [math.sin(theta),  math.cos(theta)]])\n                while True:\n                    x,y = random.uniform(-1,1), random.uniform(-1,1)\n                    if x*x + y*y > 1:\n                        continue\n                    rx = c/2\n                    ry = math.sqrt(c*c - c_min*c_min)/2\n                    sample = np.array([x*rx, y*ry])\n                    point = R.dot(sample) + center\n                    if all(0 <= point[i] <= bounds[i] for i in range(dim)):\n                        return tuple(point.tolist())\n            else:\n                # fallback uniform sampling for 3D+\n                return tuple(random.uniform(0,bounds[i]) for i in range(dim))\n\n        def nearest(tree_spatialhash, tree_list, point):\n            candidates = tree_spatialhash.neighbors(point, self.grid_cell_size*3)\n            if candidates:\n                return min(candidates, key=lambda n: dist(n.position, point))\n            # fallback linear\n            return min(tree_list, key=lambda n: dist(n.position, point))\n\n        def rewire(tree_list, tree_spatialhash, new_node, radius):\n            nonlocal edges\n            neighbors = tree_spatialhash.neighbors(new_node.position, radius)\n            for near in neighbors:\n                if near is new_node.parent:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, near.position)\n                if new_cost + 1e-10 < near.cost:\n                    if not is_edge_in_obstacle(new_node.position, near.position):\n                        # Remove old edge\n                        if near.parent:\n                            try:\n                                edges.remove((near.parent, near))\n                            except Exception:\n                                pass\n                            near.parent.children.remove(near) if near.parent else None\n                        near.parent = new_node\n                        near.cost = new_cost\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n\n        def extract_path(node_s, node_g):\n            path_s = node_s.path_from_root()\n            path_g = node_g.path_from_root()[::-1]\n            if len(path_s) > 0 and len(path_g) >0 and path_s[-1] == path_g[0]:\n                path_g = path_g[1:]\n            return path_s + path_g\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.shortcut_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path)-3)\n                j = random.randint(i+2, len(path)-1)\n                p1, p2 = path[i], path[j]\n                if not is_edge_in_obstacle(p1, p2):\n                    path = path[:i+1]+path[j:]\n            return path\n\n        best_cost = float('inf')\n        best_pair = (None,None)\n        success = False\n        c_min = dist(start_pos, goal_pos)\n\n        for iter in range(self.max_iter):\n            # Early termination heuristic: if found path close to straight-line cost\n            if best_cost < c_min * 1.05:\n                break\n            for tree_a, tree_b, sh_a, sh_b in [(start_tree, goal_tree, sh_start, sh_goal), \n                                               (goal_tree, start_tree, sh_goal, sh_start)]:\n                if success:\n                    break\n\n                r = random.random()\n                if r < self.goal_sample_rate:\n                    q_rand = goal_pos if tree_a is start_tree else start_pos\n                else:\n                    q_rand = informed_sample(best_cost, c_min, start_pos, goal_pos)\n\n                nearest_node = nearest(sh_a, tree_a, q_rand)\n                q_new_pos = steer(nearest_node.position, q_rand)\n\n                if is_in_obstacle(q_new_pos):\n                    continue\n                if is_edge_in_obstacle(nearest_node.position, q_new_pos):\n                    continue\n\n                radius = adaptive_radius(len(tree_a))\n                # Find neighbor nodes fast via spatial hash\n                near_nodes_list = sh_a.neighbors(q_new_pos, radius)\n\n                # Find best parent minimizing cost\n                min_cost = nearest_node.cost + dist(nearest_node.position, q_new_pos)\n                min_parent = nearest_node\n                for near in near_nodes_list:\n                    c = near.cost + dist(near.position, q_new_pos)\n                    if c + 1e-10 < min_cost and not is_edge_in_obstacle(near.position, q_new_pos):\n                        min_cost = c\n                        min_parent = near\n\n                q_new = Node(q_new_pos, parent=min_parent, cost=min_cost)\n                min_parent.add_child(q_new)\n                tree_a.append(q_new)\n                sh_a.insert(q_new)\n                nodes.append(q_new)\n                edges.append((min_parent, q_new))\n\n                rewire(tree_a, sh_a, q_new, radius)\n\n                # Try connect other tree\n                nearest_other = nearest(sh_b, tree_b, q_new.position)\n                dist_connect = dist(q_new.position, nearest_other.position)\n                connect_radius = max(self.step_size*1.7, adaptive_radius(len(tree_b)))\n                if dist_connect <= connect_radius and not is_edge_in_obstacle(q_new.position, nearest_other.position):\n                    cost_connect = q_new.cost + dist(q_new.position, nearest_other.position) + nearest_other.cost\n                    if cost_connect + 1e-10 < best_cost:\n                        best_cost = cost_connect\n                        best_pair = (q_new, nearest_other)\n                        success = True\n            if success and iter > self.max_iter*0.1:\n                # Continue a small extra iterations for slight betterment\n                if iter > self.max_iter*0.15:\n                    break\n\n        path = []\n        if success and best_pair[0] and best_pair[1]:\n            raw_path = extract_path(best_pair[0], best_pair[1])\n            path = shortcut_path(raw_path)\n        else:\n            return PlannerResult(False, [], nodes, edges)\n\n        return PlannerResult(True, path, nodes, edges)",
          "objective": -31.81134,
          "time_improvement": 50.0,
          "length_improvement": 17.0,
          "smoothness_improvement": 1372.0,
          "node_improvement": 79.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.016625070571899415,
                    "num_nodes_avg": 64.2,
                    "path_length_avg": 166.43166745781613,
                    "smoothness_avg": 0.0416940286392796,
                    "success_improvement": 0.0,
                    "time_improvement": 35.538782245353566,
                    "node_improvement": 83.83278771090406,
                    "length_improvement": 8.776165787832905,
                    "smoothness_improvement": 552.6020882370593,
                    "objective_score": 18.69034458749111
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.030925655364990236,
                    "num_nodes_avg": 212.2,
                    "path_length_avg": 233.60822219195128,
                    "smoothness_avg": 0.08763952290266744,
                    "success_improvement": 0.0,
                    "time_improvement": 81.32234603761,
                    "node_improvement": 85.74212188402875,
                    "length_improvement": 22.014851392475375,
                    "smoothness_improvement": 2155.0280484824807,
                    "objective_score": 48.38075488918063
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.03398807048797607,
                    "num_nodes_avg": 257.3,
                    "path_length_avg": 121.92044988846314,
                    "smoothness_avg": 0.11855062825412302,
                    "success_improvement": 0.0,
                    "time_improvement": 33.02471093370844,
                    "node_improvement": 67.28544183089639,
                    "length_improvement": 19.0262424120281,
                    "smoothness_improvement": 1407.9552408953039,
                    "objective_score": 28.36293493180591
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m2",
          "algorithm_description": "A novel bidirectional RRT* variant with adaptive sampling blending uniform and ellipsoidal informed distributions, dynamically tuned rewiring radius based on observed path quality and node density, and an integrated multi-level shortcutting strategy applying frequent lightweight and occasional global path smoothing to improve convergence speed, path optimality, and smoothness. The trees grow alternately towards adaptively sampled points; neighbors are rewired within a density-dependent radius to balance exploration and exploitation, while connection attempts leverage dynamic distance thresholds. Incremental shortcutting is applied after each path improvement, supplemented by a sparser global smoothing step to remove residual jaggedness and lower cost. This comprehensive adaptive approach enhances planning efficiency, success rate, path length, and smoothness while responding to the evolving search landscape.",
          "planning_mechanism": "The planner maintains two growing trees from start and goal positions. Sampling alternates between uniform free-space sampling and ellipsoidal informed sampling based on current best path cost. Each iteration extends a selected tree toward the sampled point with step size control, rewires neighbors within an adaptively computed radius to optimize path cost, and attempts connection with the opposite tree using a distance threshold that adapts with node density and best cost. Whenever a better path is found, incremental shortcutting immediately reduces length and jaggedness, and periodically a more global smoothing pass applies. Efficient collision checks ensure collision-free expansions, and dynamic parameter tuning balances exploration-exploitation trade-offs in real time, accelerating convergence to a short, smooth path efficiently.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except ValueError:\n            pass\nclass Planner:\n    def __init__(self, max_iter=6000, step_size=6.0, goal_sample_rate=0.08,\n                 shortcut_attempts=30, global_smooth_freq=250, uniform_sample_rate=0.3,\n                 r_min=5.0, r_max=35.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.shortcut_attempts = shortcut_attempts\n        self.global_smooth_freq = global_smooth_freq\n        self.uniform_sample_rate = uniform_sample_rate\n        self.r_min = r_min\n        self.r_max = r_max\n\n    def plan(self, map):\n        import math\n        import random\n\n        bounds = map.size\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        obstacles = map.obstacles\n        start_pos = map.start\n        goal_pos = map.goal\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        best_cost = float('inf')\n        solution_nodes = (None, None)\n        improved_since_last_global_smooth = False\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def is_in_obstacle(pos):\n            px = pos[0]\n            py = pos[1]\n            pz = pos[2] if is_3d else 0.0\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(a, b, resolution=0.5):\n            dist_ab = dist(a, b)\n            steps = max(1, int(dist_ab / resolution))\n            for i in range(steps + 1):\n                t = i / steps\n                interm = tuple(a[j] + t * (b[j] - a[j]) for j in range(dim))\n                if is_in_obstacle(interm):\n                    return True\n            return False\n\n        def nearest(tree, point):\n            best = None\n            best_d = float('inf')\n            for n in tree:\n                d_n = dist(n.position, point)\n                if d_n < best_d:\n                    best = n\n                    best_d = d_n\n            return best\n\n        def near(tree, point, radius):\n            r_sq = radius * radius\n            res = []\n            for n in tree:\n                d_sq = 0.0\n                for i in range(dim):\n                    diff = n.position[i] - point[i]\n                    d_sq += diff * diff\n                if d_sq <= r_sq:\n                    res.append(n)\n            return res\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            ratio = self.step_size / d\n            return tuple(from_pos[i] + ratio * (to_pos[i] - from_pos[i]) for i in range(dim))\n\n        def compute_ellipsoid_params():\n            c_min = dist(start_pos, goal_pos)\n            if c_min < 1e-14:\n                return None\n            center = tuple((start_pos[i] + goal_pos[i]) * 0.5 for i in range(dim))\n            direction = [goal_pos[i] - start_pos[i] for i in range(dim)]\n            length = c_min\n            e1 = [d / length for d in direction]\n            if dim == 2:\n                e2 = (-e1[1], e1[0])\n                basis = [e1, e2]\n            else:\n                v = [1, 0, 0] if abs(e1[0]) < 0.9 else [0, 1, 0]\n                for i in range(dim):\n                    proj = sum(v[j] * e1[j] for j in range(dim))\n                    v[i] = v[i] - proj * e1[i]\n                norm_v = math.sqrt(sum(x * x for x in v))\n                if norm_v < 1e-15:\n                    v = [0.0] * dim\n                    v[-1] = 1.0\n                    norm_v = 1.0\n                u = [x / norm_v for x in v]\n                # cross product for 3D only\n                if dim == 3:\n                    w = [e1[1] * u[2] - e1[2] * u[1],\n                         e1[2] * u[0] - e1[0] * u[2],\n                         e1[0] * u[1] - e1[1] * u[0]]\n                    basis = [e1, u, w]\n                else:\n                    basis = [e1, u]\n\n            a1 = best_cost * 0.5\n            b_sq = max(best_cost * best_cost - c_min * c_min, 1e-12) * 0.25\n            b = math.sqrt(b_sq)\n            return center, basis, a1, b\n\n        def sample():\n            if best_cost == float('inf'):\n                # Pure uniform sampling with goal bias and obstacle avoidance\n                while True:\n                    if random.random() < self.goal_sample_rate:\n                        pt = goal_pos\n                    else:\n                        pt = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                    if not is_in_obstacle(pt):\n                        return pt\n            # Blend uniform and ellipsoidal informed sampling\n            if random.random() < self.uniform_sample_rate:\n                # uniform free-space sampling with goal bias\n                if random.random() < self.goal_sample_rate:\n                    pt = goal_pos\n                else:\n                    while True:\n                        pt = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                        if not is_in_obstacle(pt):\n                            break\n                return pt\n            # ellipsoidal informed sample\n            params = compute_ellipsoid_params()\n            if params is None:\n                # fallback\n                while True:\n                    pt = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                    if not is_in_obstacle(pt):\n                        return pt\n            center, basis, a1, b = params\n            while True:\n                if dim == 2:\n                    r = random.uniform(0, 1) ** 0.5\n                    theta = random.uniform(0, 2 * math.pi)\n                    u_ball = [r * math.cos(theta), r * math.sin(theta)]\n                    coords = [a1 * u_ball[0], b * u_ball[1]]\n                    pt = tuple(center[i] + sum(coords[j] * basis[j][i] for j in range(dim)) for i in range(dim))\n                else:\n                    while True:\n                        u_ball = [random.uniform(-1, 1) for _ in range(3)]\n                        norm_sq = sum(x * x for x in u_ball)\n                        if 0 < norm_sq <= 1:\n                            break\n                    norm = math.sqrt(norm_sq)\n                    unit_ball = [x / norm for x in u_ball]\n                    coords = [a1 * unit_ball[0], b * unit_ball[1], b * unit_ball[2]]\n                    pt = tuple(center[i] + sum(coords[j] * basis[j][i] for j in range(dim)) for i in range(dim))\n                if any(pt[d] < 0 or pt[d] > bounds[d] for d in range(dim)):\n                    continue\n                if is_in_obstacle(pt):\n                    continue\n                return pt\n\n        def rewiring_radius(n_nodes):\n            if n_nodes < 2:\n                return self.r_max\n            # Adapt radius with dependency on best_cost and density for balanced rewiring\n            base = 2 * ((math.log(n_nodes) / n_nodes) ** (1 / dim)) * self.step_size\n            ratio = 1.0\n            # Shrink rewiring radius when cost is good\n            if best_cost < float('inf') and best_cost > 0:\n                ratio = max(0.3, min(1.0, (best_cost / (dist(start_pos, goal_pos) * 3))))\n            radius = base * ratio\n            return max(self.r_min, min(self.r_max, radius))\n\n        def extract_path(node_a, node_b):\n            path_a = []\n            cur = node_a\n            while cur is not None:\n                path_a.append(cur.position)\n                cur = cur.parent\n            path_b = []\n            cur = node_b\n            while cur is not None:\n                path_b.append(cur.position)\n                cur = cur.parent\n            return path_a[::-1] + path_b\n\n        def incremental_shortcut(path):\n            if len(path) < 3:\n                return path[:]\n            new_path = path[:]\n            attempts = 0\n            while attempts < self.shortcut_attempts:\n                if len(new_path) < 3:\n                    break\n                i = random.randint(0, len(new_path) - 3)\n                j = random.randint(i + 2, len(new_path) - 1)\n                if not is_edge_in_obstacle(new_path[i], new_path[j]):\n                    new_path = new_path[:i + 1] + new_path[j:]\n                    attempts = 0\n                else:\n                    attempts += 1\n            return new_path\n\n        def global_smooth(path):\n            # Apply a simple global smoothing by shortcutting multiple times with increasing segment length\n            smoothed = path[:]\n            n = len(smoothed)\n            if n < 3:\n                return smoothed\n            max_segments = min(20, n//3)\n            for seg in range(max_segments, 1, -1):\n                i = 0\n                while i + seg < len(smoothed):\n                    if not is_edge_in_obstacle(smoothed[i], smoothed[i + seg]):\n                        smoothed = smoothed[:i + 1] + smoothed[i + seg:]\n                        # After shortcut, restart checking to capture further smooths\n                        i = 0\n                    else:\n                        i += 1\n            return smoothed\n\n        for it in range(self.max_iter):\n            sample_pos = sample()\n            tree_to_extend, opposite_tree = (start_tree, goal_tree) if it % 2 == 0 else (goal_tree, start_tree)\n\n            nearest_node = nearest(tree_to_extend, sample_pos)\n            new_pos = steer(nearest_node.position, sample_pos)\n\n            if is_in_obstacle(new_pos):\n                continue\n            if is_edge_in_obstacle(nearest_node.position, new_pos):\n                continue\n\n            radius = rewiring_radius(len(tree_to_extend))\n            near_nodes = near(tree_to_extend, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for candidate in near_nodes:\n                if candidate is nearest_node:\n                    continue\n                tentative_cost = candidate.cost + dist(candidate.position, new_pos)\n                if tentative_cost < min_cost and not is_edge_in_obstacle(candidate.position, new_pos):\n                    min_cost = tentative_cost\n                    best_parent = candidate\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree_to_extend.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors if cost improved and collision free\n            for nbr in near_nodes:\n                if nbr is best_parent or nbr is new_node:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, nbr.position)\n                if new_cost < nbr.cost and not is_edge_in_obstacle(new_node.position, nbr.position):\n                    if nbr.parent is not None:\n                        try:\n                            edges.remove((nbr.parent, nbr))\n                        except ValueError:\n                            pass\n                        nbr.parent.remove_child(nbr)\n                    nbr.parent = new_node\n                    nbr.cost = new_cost\n                    new_node.add_child(nbr)\n                    edges.append((new_node, nbr))\n\n            nearest_other = nearest(opposite_tree, new_pos)\n            dist_connect = dist(new_pos, nearest_other.position)\n            # Adapt connection threshold to min(step_size * 1.5, rewiring radius)\n            connect_thresh = min(self.step_size * 1.5, rewiring_radius(len(tree_to_extend)))\n            if dist_connect <= connect_thresh and not is_edge_in_obstacle(new_pos, nearest_other.position):\n                total_cost = new_node.cost + dist_connect + nearest_other.cost\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    solution_nodes = (new_node, nearest_other) if it % 2 == 0 else (nearest_other, new_node)\n                    raw_path = extract_path(solution_nodes[0], solution_nodes[1])\n                    smoothed_path = incremental_shortcut(raw_path)\n                    nodes_clear = len(smoothed_path)\n                    improved_since_last_global_smooth = True\n                    # Whenever better path found, return smoothed path immediately (anytime behavior)\n                    if smoothed_path and len(smoothed_path) >= 2:\n                        # Periodically apply global smoothing too\n                        if it % self.global_smooth_freq == 0:\n                            smoothed_path = global_smooth(smoothed_path)\n                        return PlannerResult(True, smoothed_path, nodes, edges)\n\n            # Periodic global smoothing on existing best path\n            if improved_since_last_global_smooth and it % self.global_smooth_freq == 0 and best_cost < float('inf'):\n                raw_path = extract_path(solution_nodes[0], solution_nodes[1])\n                smoothed_path = global_smooth(raw_path)\n                if smoothed_path and len(smoothed_path) >= 2:\n                    improved_since_last_global_smooth = False\n                    return PlannerResult(True, smoothed_path, nodes, edges)\n\n        # If terminate with solution found\n        if solution_nodes[0] is not None and solution_nodes[1] is not None:\n            raw_path = extract_path(solution_nodes[0], solution_nodes[1])\n            smoothed_path = incremental_shortcut(raw_path)\n            smoothed_path = global_smooth(smoothed_path)\n            return PlannerResult(True, smoothed_path, nodes, edges)\n\n        return PlannerResult(False, [], nodes, edges)",
          "objective": -31.45446,
          "time_improvement": 60.0,
          "length_improvement": 12.0,
          "smoothness_improvement": 1289.0,
          "node_improvement": 74.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.019103193283081056,
                    "num_nodes_avg": 130.0,
                    "path_length_avg": 173.3649996406287,
                    "smoothness_avg": 0.03905650881261121,
                    "success_improvement": 0.0,
                    "time_improvement": 25.93023309560016,
                    "node_improvement": 67.26265424326367,
                    "length_improvement": 4.975896552754276,
                    "smoothness_improvement": 511.3191754837242,
                    "objective_score": 13.321203737751233
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.022163128852844237,
                    "num_nodes_avg": 240.8,
                    "path_length_avg": 245.67296527562377,
                    "smoothness_avg": 0.08351123895740013,
                    "success_improvement": 0.0,
                    "time_improvement": 86.6145035068227,
                    "node_improvement": 83.8204663038366,
                    "length_improvement": 17.987292886770433,
                    "smoothness_improvement": 2048.8043290880164,
                    "objective_score": 47.020748429549144
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.017162418365478514,
                    "num_nodes_avg": 224.0,
                    "path_length_avg": 131.41011815324833,
                    "smoothness_avg": 0.11058336040285022,
                    "success_improvement": 0.0,
                    "time_improvement": 66.18054762740364,
                    "node_improvement": 71.51938970120788,
                    "length_improvement": 12.723656600001021,
                    "smoothness_improvement": 1306.6121819096536,
                    "objective_score": 34.02141915776997
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "path_expert",
          "algorithm_description": "An enhanced bidirectional RRT* planner that integrates adaptive rewiring radius, goal-biased informed sampling, and an improved hierarchical smoothing combining multi-pass shortcutting with cubic Bezier curve fitting for path refinement. The smoothing phase adaptively adjusts angle thresholds, performs iterative shortcut passes, and applies localized Bezier smoothing to reduce sharp turns while preserving obstacle avoidance. Frequent bidirectional tree connections accelerate solution discovery and continuous path quality improvement, aiming to minimize path length and enhance smoothness while maintaining efficient planning time.",
          "planning_mechanism": "The planner simultaneously grows two trees from start and goal using adaptive elliptical informed sampling that shrinks with solution cost improvements, dynamically scaling the neighborhood radius for rewiring. The planner selects parent nodes and rewires neighbors with strict cost improvement criteria, recursively updating subtree costs to maintain consistent cost. Frequent attempts connect the two trees to detect and refine paths. After solution detection, a hierarchical smoothing process iteratively applies shortcutting with adaptive angle thresholds followed by localized cubic Bezier curve fitting over path segments to greatly enhance smoothness and shorten path length while ensuring collision-free paths.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=6.0, r_min=5.0, r_max=30.0, goal_sample_rate=0.1):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.r_min = r_min\n        self.r_max = r_max\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map):\n        import math\n        import random\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = 3 if is_3d else 2\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        def dist(a,b):\n            return math.dist(a,b)\n\n        def heuristic_forward(p):\n            return dist(p,goal_pos)\n        def heuristic_backward(p):\n            return dist(p,start_pos)\n\n        best_cost = float('inf')\n        solution_nodes = (None,None)\n\n        def update_subtree_costs(node):\n            for c in node.children:\n                prev_cost = c.cost\n                new_cost = node.cost + dist(node.position,c.position)\n                if new_cost + 1e-15 < prev_cost:\n                    c.cost = new_cost\n                    update_subtree_costs(c)\n\n        def rewiring_radius(n_nodes):\n            if n_nodes < 2:\n                return self.r_max\n            gamma = 40.0\n            val = gamma * (math.log(n_nodes)/n_nodes)**(1/dim)\n            return max(self.r_min, min(self.r_max,val))\n\n        def sample():\n            if random.random() < self.goal_sample_rate:\n                return goal_pos\n            if best_cost == float('inf'):\n                while True:\n                    pt = tuple(random.uniform(0,bounds[i]) for i in range(dim))\n                    if not self._is_in_obstacle(pt,obstacles,is_3d):\n                        return pt\n            else:\n                center = tuple((start_pos[i]+goal_pos[i])/2 for i in range(dim))\n                a1 = [goal_pos[i]-start_pos[i] for i in range(dim)]\n                length = dist(start_pos,goal_pos)\n                if length < 1e-15:\n                    return goal_pos\n\n                e1 = [x/length for x in a1]\n                def orthonormal_basis(dim,e1):\n                    basis = [e1]\n                    if dim==2:\n                        basis.append( (-e1[1], e1[0]) )\n                    elif dim==3:\n                        v = [1,0,0] if abs(e1[0])<0.9 else [0,1,0]\n                        u = [v[i] - e1[i]*sum(v[j]*e1[j] for j in range(3)) for i in range(3)]\n                        u_norm = math.sqrt(sum(x*x for x in u))\n                        if u_norm < 1e-15:\n                            u = [0,0,1]\n                            u_norm=1\n                        u = [x/u_norm for x in u]\n                        w = [e1[1]*u[2] - e1[2]*u[1],\n                             e1[2]*u[0] - e1[0]*u[2],\n                             e1[0]*u[1] - e1[1]*u[0]]\n                        basis.extend([u,w])\n                    return basis\n                B = orthonormal_basis(dim,e1)\n\n                c_min = length\n                c_max = min(best_cost * 1.05, sum(bounds)*10)\n\n                try:\n                    a1_len = c_max / 2.0\n                    a_others = max( ( (c_max**2 - c_min**2) / 4.0 )**0.5, 1e-8 )\n                except Exception:\n                    a1_len = c_max / 2.0\n                    a_others = a1_len\n\n                while True:\n                    if dim==2:\n                        r = random.uniform(0,1)**0.5\n                        theta = random.uniform(0,2*math.pi)\n                        unit_ball = [r*math.cos(theta), r*math.sin(theta)]\n                        coords = [a1_len*unit_ball[0], a_others*unit_ball[1]]\n                        sample_pt = [ center[i] + sum(coords[j]*B[j][i] for j in range(dim)) for i in range(dim) ]\n                        pt = tuple(sample_pt)\n                    else:\n                        while True:\n                            u = [random.uniform(-1,1) for _ in range(3)]\n                            norm_u = math.sqrt(sum(x*x for x in u))\n                            if norm_u<=1 and norm_u>0:\n                                unit_ball = [x/norm_u for x in u]\n                                break\n                        coords = [a1_len*unit_ball[0], a_others*unit_ball[1], a_others*unit_ball[2]]\n                        sample_pt = [ center[i] + sum(coords[j]*B[j][i] for j in range(dim)) for i in range(dim) ]\n                        pt = tuple(sample_pt)\n                    if any(pt[i]<0 or pt[i]>bounds[i] for i in range(dim)):\n                        continue\n                    if self._is_in_obstacle(pt,obstacles,is_3d):\n                        continue\n                    return pt\n\n        def nearest(tree,p):\n            best = None\n            best_d = float('inf')\n            for n in tree:\n                d = dist(n.position,p)\n                if d < best_d:\n                    best = n\n                    best_d = d\n            return best\n\n        def near(tree,p,r):\n            r2 = r*r\n            res = []\n            for n in tree:\n                d2 = 0\n                for i in range(dim):\n                    delta = n.position[i] - p[i]\n                    d2 += delta*delta\n                if d2 <= r2:\n                    res.append(n)\n            return res\n\n        def steer(from_pos,to_pos):\n            d = dist(from_pos,to_pos)\n            if d <= self.step_size:\n                return to_pos\n            ratio = self.step_size/d\n            return tuple(from_pos[i]+(to_pos[i]-from_pos[i])*ratio for i in range(dim))\n\n        def is_free_node(pos):\n            return not self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def is_free_edge(a,b):\n            return not self._is_edge_in_obstacle(a,b,obstacles,is_3d)\n\n        def path_from_to(node_start,node_goal):\n            path_start = []\n            n = node_start\n            while n is not None:\n                path_start.append(n.position)\n                n = n.parent\n            path_goal = []\n            n = node_goal\n            while n is not None:\n                path_goal.append(n.position)\n                n = n.parent\n            return path_start[::-1] + path_goal\n\n        def angle_between_vectors(a,b,c):\n            # angle at point b formed by vectors ba and bc\n            import math\n            ba = [a[i]-b[i] for i in range(dim)]\n            bc = [c[i]-b[i] for i in range(dim)]\n            len_ba = math.sqrt(sum(x*x for x in ba))\n            len_bc = math.sqrt(sum(x*x for x in bc))\n            if len_ba <1e-12 or len_bc <1e-12:\n                return 0.0\n            dot = sum(ba[i]*bc[i] for i in range(dim))\n            val = max(min(dot/(len_ba*len_bc),1),-1)\n            return math.acos(val)\n\n        def shortcut_path(path, max_passes=8, max_attempts_per_pass=300):\n            if len(path)<3:\n                return path[:]\n            new_path = path[:]\n            angle_threshold_base = math.pi * 150.0/180.0  # 150 degrees base threshold for acceptance\n\n            for pass_i in range(max_passes):\n                improved = False\n                attempts = 0\n                i = 0\n                # adapt angle threshold loosening on passes (more passes progressively allow slightly sharper angles)\n                angle_threshold = angle_threshold_base + (pass_i*math.pi*5/180.0)  # loosen 5 degrees per pass up to ~190 deg max cap\n                angle_threshold = min(angle_threshold, math.pi*190/180.0)\n\n                while i < len(new_path)-2 and attempts < max_attempts_per_pass:\n                    j = random.randint(i+2, len(new_path)-1)\n                    if j <= i+1:\n                        attempts += 1\n                        continue\n                    if is_free_edge(new_path[i],new_path[j]):\n                        # Check angles at neighbors before removal\n                        smooth = True\n                        if i>0:\n                            a,b,c = new_path[i-1], new_path[i], new_path[j]\n                            if angle_between_vectors(a,b,c) < math.pi - angle_threshold:\n                                smooth = False\n                        if j<len(new_path)-1:\n                            a,b,c = new_path[i], new_path[j], new_path[j+1]\n                            if angle_between_vectors(a,b,c) < math.pi - angle_threshold:\n                                smooth = False\n                        if smooth:\n                            new_path = new_path[:i+1] + new_path[j:]\n                            improved = True\n                            i = 0\n                            attempts += 1\n                            continue\n                    i += 1\n                    attempts += 1\n                if not improved:\n                    break\n            return new_path\n\n        def bezier_point(t, p0, p1, p2, p3):\n            \"\"\"Cubic Bezier Curve Point\"\"\"\n            u = 1 - t\n            tt = t*t\n            uu = u*u\n            uuu = uu * u\n            ttt = tt * t\n\n            return tuple( uuu*p0[i] + 3*uu*t*p1[i] + 3*u*tt*p2[i] + ttt*p3[i] for i in range(len(p0)) )\n\n        def bezier_curve(control_points, n_points=10):\n            \"\"\"Generate points along a cubic Bezier curve\"\"\"\n            if len(control_points) != 4:\n                return control_points[:]\n            return [bezier_point(t, *control_points) for t in [i/(n_points-1) for i in range(n_points)]]\n\n        def is_curve_collision_free(curve_points):\n            for idx in range(len(curve_points)-1):\n                if self._is_edge_in_obstacle(curve_points[idx], curve_points[idx+1], obstacles, is_3d):\n                    return False\n            return True\n\n        def bezier_smooth_path(path):\n            # Apply localized Bezier smoothing over path segments length 4 if collision free\n            if len(path) < 4:\n                return path[:]\n            new_path = path[:]\n            i = 0\n            while i < len(new_path)-3:\n                p0, p1, p2, p3 = new_path[i], new_path[i+1], new_path[i+2], new_path[i+3]\n                curve_pts = bezier_curve([p0,p1,p2,p3], n_points=10)\n                if is_curve_collision_free(curve_pts):\n                    # Replace middle two points p1,p2 by intermediate curve points (excluding p0 and p3)\n                    # We keep first and last points of the segment fixed.\n                    # We'll replace p1 and p2 by a subset of curve points for smoothness.\n\n                    # Interpolated points exclude first and last of curve_pts\n                    interpolated = curve_pts[1:-1]\n\n                    # Build new path with replaced segment\n                    new_path = new_path[:i+1] + interpolated + new_path[i+3:]\n                    i += len(interpolated)  # skip newly added points\n                else:\n                    i += 1\n            return new_path\n\n        for it in range(self.max_iter):\n            sample_pos = sample()\n\n            if it % 2 == 0:\n                prop_tree, other_tree = start_tree, goal_tree\n                heuristic_prop = heuristic_forward\n                heuristic_other = heuristic_backward\n            else:\n                prop_tree, other_tree = goal_tree, start_tree\n                heuristic_prop = heuristic_backward\n                heuristic_other = heuristic_forward\n\n            nearest_node = nearest(prop_tree, sample_pos)\n            new_pos = steer(nearest_node.position, sample_pos)\n\n            if not is_free_node(new_pos):\n                continue\n            if not is_free_edge(nearest_node.position, new_pos):\n                continue\n\n            r = rewiring_radius(len(prop_tree))\n            near_nodes = near(prop_tree, new_pos, r)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position,new_pos)\n            best_parent = nearest_node\n            for candidate in near_nodes:\n                if candidate is nearest_node:\n                    continue\n                tentative_cost = candidate.cost + dist(candidate.position,new_pos)\n                if tentative_cost + heuristic_prop(new_pos) + 1e-15 < min_cost + heuristic_prop(new_pos):\n                    if is_free_edge(candidate.position, new_pos):\n                        min_cost = tentative_cost\n                        best_parent = candidate\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.add_child(new_node)\n            prop_tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            for nbr in near_nodes:\n                if nbr is best_parent or nbr is new_node:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, nbr.position)\n                if new_cost + heuristic_prop(nbr.position) + 1e-15 < nbr.cost + heuristic_prop(nbr.position):\n                    if is_free_edge(new_node.position, nbr.position):\n                        if nbr.parent is not None:\n                            try:\n                                edges.remove((nbr.parent, nbr))\n                            except ValueError:\n                                pass\n                            nbr.parent.remove_child(nbr)\n                        nbr.parent = new_node\n                        nbr.cost = new_cost\n                        new_node.add_child(nbr)\n                        edges.append((new_node, nbr))\n                        update_subtree_costs(nbr)\n\n            near_other = nearest(other_tree, new_node.position)\n            dist_conn = dist(new_node.position, near_other.position)\n            if dist_conn <= self.step_size:\n                if is_free_edge(new_node.position, near_other.position):\n                    candidate_cost = new_node.cost + dist_conn + near_other.cost\n                    if candidate_cost + 1e-15 < best_cost:\n                        best_cost = candidate_cost\n                        if it % 2 == 0:\n                            solution_nodes = (new_node, near_other)\n                        else:\n                            solution_nodes = (near_other, new_node)\n\n            if solution_nodes[0] and solution_nodes[1] and ((it > 0 and it % 80 == 0) or it == self.max_iter-1):\n                raw_path = path_from_to(solution_nodes[0], solution_nodes[1])\n                pass1 = shortcut_path(raw_path, max_passes=8, max_attempts_per_pass=300)\n                pass2 = bezier_smooth_path(pass1)\n                return PlannerResult(True, pass2, nodes, edges)\n\n        if solution_nodes[0] and solution_nodes[1]:\n            raw_path = path_from_to(solution_nodes[0], solution_nodes[1])\n            pass1 = shortcut_path(raw_path, max_passes=8, max_attempts_per_pass=300)\n            pass2 = bezier_smooth_path(pass1)\n            return PlannerResult(True, pass2, nodes, edges)\n        else:\n            return PlannerResult(False, [], nodes, edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        px = pos[0]\n        py = pos[1]\n        pz = pos[2] if is_3d else 0.0\n        for obs in obstacles:\n            if is_3d:\n                x,y,z,w,h,d = obs\n                if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                    return True\n            else:\n                x,y,w,h = obs\n                if x <= px <= x+w and y <= py <= y+h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        dist_val = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist_val/resolution))\n        for step in range(steps+1):\n            t = step/steps\n            interp = tuple(from_pos[i] + t*(to_pos[i]-from_pos[i]) for i in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -31.35436,
          "time_improvement": 50.0,
          "length_improvement": 18.0,
          "smoothness_improvement": 1122.0,
          "node_improvement": 67.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.020946669578552245,
                    "num_nodes_avg": 169.2,
                    "path_length_avg": 156.9968252907203,
                    "smoothness_avg": 0.020851635172459877,
                    "success_improvement": 0.0,
                    "time_improvement": 18.782430240028845,
                    "node_improvement": 57.39108536892471,
                    "length_improvement": 13.947552284259512,
                    "smoothness_improvement": 226.3733704995064,
                    "objective_score": 15.135127295061892
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.029881834983825684,
                    "num_nodes_avg": 307.0,
                    "path_length_avg": 231.7579073494588,
                    "smoothness_avg": 0.09111135278880159,
                    "success_improvement": 0.0,
                    "time_improvement": 81.95276488074154,
                    "node_improvement": 79.3724383524827,
                    "length_improvement": 22.63253974525912,
                    "smoothness_improvement": 2244.360732110702,
                    "objective_score": 49.38715697193144
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.02644164562225342,
                    "num_nodes_avg": 287.2,
                    "path_length_avg": 123.73707639297194,
                    "smoothness_avg": 0.07830820806750623,
                    "success_improvement": 0.0,
                    "time_improvement": 47.89533993801242,
                    "node_improvement": 63.4837889383344,
                    "length_improvement": 17.819725586191648,
                    "smoothness_improvement": 896.0746265080132,
                    "objective_score": 29.54081046565878
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "path_expert",
          "algorithm_description": "An enhanced bidirectional RRT* with dynamic adaptive sampling focused within an ellipsoidal informed set, combined with optimized local rewiring and iterative progressive shortcutting that does not terminate prematurely, allowing multiple path refinements per iteration. The planner dynamically adjusts the neighborhood radius based on the iteration count for effective rewiring, expands trees alternately, and maintains early-best path updates to accelerate convergence. Path extraction merges trees smoothly, and shortcutting aggressively reduces path length and smoothness without early exit, balancing exploration and exploitation for faster planning with superior path length and smoothness.",
          "planning_mechanism": "The planner alternates expansions of two trees from start and goal, sampling points adaptively within a progressively shrinking ellipsoidal subset defined by the current best path cost to focus search. Each new node is connected optimally within a dynamically scaled radius, with rewiring applied to improve local costs. Upon successful connection, the combined path is extracted and shortcut multiple times per call to incrementally smooth and shorten it. The radius decreases over iterations, balancing exploration and exploitation. This approach improves convergence speed, path cost, and smoothness while reducing search time.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n    def add_child(self, child):\n        self.children.append(child)\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except ValueError:\n            pass\nclass Planner:\n    def __init__(self, max_iter=4000, step_size=6.0, radius_max=15.0,\n                 radius_min=5.0, shortcut_interval=25, shortcut_attempts=100):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.radius_max = radius_max\n        self.radius_min = radius_min\n        self.shortcut_interval = shortcut_interval\n        self.shortcut_attempts = shortcut_attempts\n\n    def plan(self, map):\n        import random\n        import math\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = (len(bounds) == 3)\n        dim = 3 if is_3d else 2\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        all_nodes = start_tree + goal_tree\n        edges = []\n\n        best_cost = float('inf')\n        solution_start = None\n        solution_goal = None\n\n        c_min = math.dist(start_pos, goal_pos)\n        # Prevent zero division at start:\n        c_min = max(c_min, 1e-10)\n\n        def radius(iter_idx):\n            # Shrinking radius between radius_max and radius_min over iterations to balance exploration/exploitation\n            fraction = min(iter_idx/self.max_iter,1.0)\n            return self.radius_max * (1.0 - fraction) + self.radius_min * fraction\n\n        for i in range(self.max_iter):\n            # Adaptive informed sampling focusing search if a solution exists\n            if best_cost < float('inf'):\n                sample = self._informed_sample(bounds, obstacles, is_3d, start_pos, goal_pos, best_cost, c_min)\n            else:\n                sample = self._sample_free(bounds, obstacles, is_3d)\n\n            # Alternating tree expansion for balanced bidirectional growth\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest = self._nearest(tree_a, sample)\n                new_pos = self._steer(nearest.position, sample, self.step_size)\n\n                if (self._is_in_obstacle(new_pos, obstacles, is_3d) or\n                    self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d)):\n                    continue  # Skip invalid nodes or edges\n\n                new_node = Node(new_pos)\n\n                r = radius(i)\n                near_nodes = self._near(tree_a, new_pos, r)\n\n                # Choose parent with minimal cost feasible edge\n                min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n                min_parent = nearest\n                for near in near_nodes:\n                    if near == nearest:\n                        continue\n                    tentative_cost = near.cost + math.dist(near.position, new_pos)\n                    if tentative_cost < min_cost:\n                        if not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d):\n                            min_cost = tentative_cost\n                            min_parent = near\n\n                new_node.parent = min_parent\n                new_node.cost = min_cost\n                min_parent.add_child(new_node)\n                tree_a.append(new_node)\n                all_nodes.append(new_node)\n                edges.append((min_parent, new_node))\n\n                # Rewire nodes around new node to improve their cost if beneficial\n                for near in near_nodes:\n                    if near == min_parent:\n                        continue\n                    new_cost = new_node.cost + math.dist(new_node.position, near.position)\n                    if new_cost < near.cost:\n                        if not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                            old_parent = near.parent\n                            if old_parent:\n                                try:\n                                    edges.remove((old_parent, near))\n                                except ValueError:\n                                    pass\n                                old_parent.remove_child(near)\n                            near.parent = new_node\n                            near.cost = new_cost\n                            new_node.add_child(near)\n                            edges.append((new_node, near))\n\n                # Attempt connection to the other tree\n                connect_node = self._nearest(tree_b, new_node.position)\n                dist_connect = math.dist(new_node.position, connect_node.position)\n                if dist_connect <= self.step_size:\n                    if not self._is_edge_in_obstacle(new_node.position, connect_node.position, obstacles, is_3d):\n                        total_path_cost = new_node.cost + dist_connect + connect_node.cost\n                        if total_path_cost < best_cost:\n                            best_cost = total_path_cost\n                            if tree_a is start_tree:\n                                solution_start, solution_goal = new_node, connect_node\n                            else:\n                                solution_start, solution_goal = connect_node, new_node\n\n            # Progressive shortcutting every shortcut_interval iterations and final iteration\n            if best_cost < float('inf') and solution_start and solution_goal and (i % self.shortcut_interval == 0 or i == self.max_iter - 1):\n                raw_path = self._extract_path(solution_start, solution_goal)\n                # Aggressive multiple shortcutting iterations improving smoothness and length in one call\n                shortcut_path = self._shortcut_path(raw_path, obstacles, is_3d, max_attempts=self.shortcut_attempts)\n                if shortcut_path:\n                    return PlannerResult(True, shortcut_path, all_nodes, edges)\n\n        # No solution found\n        return PlannerResult(False, [], all_nodes, edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        import random\n        while True:\n            pt = tuple(random.uniform(0, bounds[i]) for i in range(len(bounds)))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def _informed_sample(self, bounds, obstacles, is_3d, start, goal, c_max, c_min):\n        import random\n        import math\n        dim = 3 if is_3d else 2\n\n        if c_max <= c_min:\n            return self._sample_free(bounds, obstacles, is_3d)\n\n        center = tuple((start[i] + goal[i]) / 2.0 for i in range(dim))\n        dir_vec = [goal[i] - start[i] for i in range(dim)]\n        length = math.dist(start, goal)\n        if length < 1e-10:\n            return self._sample_free(bounds, obstacles, is_3d)\n\n        # Rotation matrix aligning x-axis with direction vector\n        if dim == 2:\n            a1 = [1.0, 0.0]\n            a2 = [dir_vec[0] / length, dir_vec[1] / length]\n            cos_theta = a1[0] * a2[0] + a1[1] * a2[1]\n            sin_theta = a1[0] * a2[1] - a1[1] * a2[0]\n            R = [[cos_theta, -sin_theta], [sin_theta, cos_theta]]\n        else:\n            # Rodrigues' rotation formula for 3D rotation matrix\n            from math import sqrt\n            a1 = [1.0, 0.0, 0.0]\n            a2 = [dir_vec[i] / length for i in range(3)]\n            v = [a1[1]*a2[2] - a1[2]*a2[1],\n                 a1[2]*a2[0] - a1[0]*a2[2],\n                 a1[0]*a2[1] - a1[1]*a2[0]]\n            s = sqrt(sum(vi*vi for vi in v))\n            c = sum(a1[i]*a2[i] for i in range(3))\n            if s < 1e-10:\n                R = [[1,0,0],[0,1,0],[0,0,1]]\n            else:\n                vx = [[0, -v[2], v[1]],\n                      [v[2], 0, -v[0]],\n                      [-v[1], v[0], 0]]\n                I = [[1 if i==j else 0 for j in range(3)] for i in range(3)]\n                vx2 = [[sum(vx[i][k]*vx[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n                R = [[I[i][j] + vx[i][j] + vx2[i][j]*((1 - c)/(s*s)) for j in range(3)] for i in range(3)]\n\n        def sample_unit_ball():\n            if dim == 2:\n                r = random.uniform(0, 1)**0.5\n                theta = random.uniform(0, 2 * math.pi)\n                return [r * math.cos(theta), r * math.sin(theta)]\n            else:\n                while True:\n                    pt = [random.uniform(-1, 1) for _ in range(3)]\n                    if sum(x*x for x in pt) <= 1:\n                        return pt\n\n        x_ball = sample_unit_ball()\n\n        a1_val = c_max / 2.0\n        a_other = math.sqrt(max(c_max*c_max - c_min*c_min, 0)) / 2.0\n\n        # Scale sample inside ellipsoid axes\n        if dim == 2:\n            L = [[a1_val, 0.0], [0.0, a_other]]\n            x_scaled = [L[0][0]*x_ball[0] + L[0][1]*x_ball[1],\n                        L[1][0]*x_ball[0] + L[1][1]*x_ball[1]]\n            pt = (center[0] + R[0][0]*x_scaled[0] + R[0][1]*x_scaled[1],\n                  center[1] + R[1][0]*x_scaled[0] + R[1][1]*x_scaled[1])\n        else:\n            L = [[a1_val, 0.0, 0.0],\n                 [0.0, a_other, 0.0],\n                 [0.0, 0.0, a_other]]\n            x_scaled = [L[0][0]*x_ball[0], L[1][1]*x_ball[1], L[2][2]*x_ball[2]]\n            pt = tuple(center[i] + sum(R[i][j]*x_scaled[j] for j in range(3)) for i in range(3))\n\n        if any(pt[d] < 0 or pt[d] > bounds[d] for d in range(dim)):\n            return self._sample_free(bounds, obstacles, is_3d)\n        if self._is_in_obstacle(pt, obstacles, is_3d):\n            return self._sample_free(bounds, obstacles, is_3d)\n        return pt\n\n    def _nearest(self, tree, point):\n        import math\n        best = None\n        best_dist = float('inf')\n        for node in tree:\n            d = math.dist(node.position, point)\n            if d < best_dist:\n                best_dist = d\n                best = node\n        return best\n\n    def _near(self, tree, point, radius):\n        r_sq = radius*radius\n        dim = len(point)\n        return [n for n in tree if sum((n.position[i] - point[i])**2 for i in range(dim)) <= r_sq]\n\n    def _steer(self, from_pos, to_pos, step_size):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        if dist <= step_size:\n            return to_pos\n        ratio = step_size / dist\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n    def _extract_path(self, node_start, node_goal):\n        path_start = []\n        n = node_start\n        while n is not None:\n            path_start.append(n.position)\n            n = n.parent\n        path_start.reverse()\n\n        path_goal = []\n        n = node_goal\n        while n is not None:\n            path_goal.append(n.position)\n            n = n.parent\n        # Remove duplicated connecting node between two paths\n        if len(path_goal) > 0 and len(path_start) > 0 and path_goal[0] == path_start[-1]:\n            path_goal = path_goal[1:]\n        return path_start + path_goal\n\n    def _shortcut_path(self, path, obstacles, is_3d, max_attempts=100):\n        if len(path) < 3:\n            return path[:]\n        import random\n        new_path = path[:]\n        attempts = 0\n        while attempts < max_attempts:\n            if len(new_path) < 3:\n                break\n            i = random.randint(0, len(new_path) - 3)\n            j = random.randint(i + 2, len(new_path) - 1)\n            if not self._is_edge_in_obstacle(new_path[i], new_path[j], obstacles, is_3d):\n                # Remove intermediate nodes between i and j\n                new_path = new_path[:i+1] + new_path[j:]\n                attempts = 0  # reset after successful shortcut for multiple improvements\n            else:\n                attempts += 1\n        return new_path\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if (x <= px <= x + w) and (y <= py <= y + h) and (z <= pz <= z + d):\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if (x <= px <= x + w) and (y <= py <= y + h):\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            ratio = i / steps\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -31.02809,
          "time_improvement": 43.0,
          "length_improvement": 18.0,
          "smoothness_improvement": 1433.0,
          "node_improvement": 72.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.027813315391540527,
                    "num_nodes_avg": 150.8,
                    "path_length_avg": 158.7550902195503,
                    "smoothness_avg": 0.04475010796054884,
                    "success_improvement": 0.0,
                    "time_improvement": -7.841959056894185,
                    "node_improvement": 62.02467892218585,
                    "length_improvement": 12.983819415277045,
                    "smoothness_improvement": 600.4363659973881,
                    "objective_score": 8.439885762084911
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.032094931602478026,
                    "num_nodes_avg": 270.1,
                    "path_length_avg": 232.67782481248065,
                    "smoothness_avg": 0.10133943332680147,
                    "success_improvement": 0.0,
                    "time_improvement": 80.61615770651433,
                    "node_improvement": 81.8517771954579,
                    "length_improvement": 22.325444817746384,
                    "smoothness_improvement": 2507.5366113420746,
                    "objective_score": 50.117797259312496
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.021543121337890624,
                    "num_nodes_avg": 212.9,
                    "path_length_avg": 122.20039490599746,
                    "smoothness_avg": 0.1015407972611195,
                    "success_improvement": 0.0,
                    "time_improvement": 57.54814091297544,
                    "node_improvement": 72.9307056579784,
                    "length_improvement": 18.840316260931036,
                    "smoothness_improvement": 1191.591446199421,
                    "objective_score": 34.52658926144836
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "An efficient bidirectional RRT* with adaptive informed sampling and incremental path shortcutting, focusing sampling within an ellipsoidal subset around the best path to accelerate convergence, combined with local rewiring for path optimization and progressive shortcutting to improve path smoothness and length while reducing planning time. The planner grows two trees from start and goal, alternately expanding toward sampled points focused by current best solution, connects the two trees when possible, rewires locally to optimize costs, and progressively shortcuts the path during planning for smoother results.",
          "planning_mechanism": "The planner alternates growth of two trees (start and goal) using adaptive informed sampling within an ellipsoidal subset defined by the current best path cost. At each iteration, a sample point is generated; nearest nodes are extended toward it with collision checking. The algorithm rewires nearby nodes to optimize path costs locally. Upon connecting both trees, it extracts the combined path and incrementally applies shortcutting to remove unnecessary waypoints and smooth the trajectory. This approach balances efficient exploration, path quality, and runtime performance.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n    def add_child(self, child):\n        self.children.append(child)\nclass Planner:\n    def __init__(self, max_iter=4000, step_size=6.0, radius=12.0, shortcut_interval=50):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.radius = radius\n        self.shortcut_interval = shortcut_interval\n\n    def plan(self, map):\n        import random\n        import math\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = (len(bounds) == 3)\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        best_cost = float('inf')\n        solution_start, solution_goal = None, None\n\n        c_min = math.dist(start_pos, goal_pos)\n        dim = 3 if is_3d else 2\n\n        for i in range(self.max_iter):\n            # Adaptive Sample\n            if best_cost < float('inf'):\n                sample = self._informed_sample(bounds, obstacles, is_3d, start_pos, goal_pos, best_cost, c_min)\n            else:\n                sample = self._sample_free(bounds, obstacles, is_3d)\n\n            # Alternate tree expansion\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest = self._nearest(tree_a, sample)\n                new_pos = self._steer(nearest.position, sample, self.step_size)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                    continue\n\n                new_node = Node(new_pos)\n                near_nodes = self._near(tree_a, new_pos, self.radius)\n\n                min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n                min_parent = nearest\n                for near in near_nodes:\n                    tentative_cost = near.cost + math.dist(near.position, new_pos)\n                    if tentative_cost < min_cost and not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d):\n                        min_cost = tentative_cost\n                        min_parent = near\n\n                new_node.parent = min_parent\n                new_node.cost = min_cost\n                min_parent.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((min_parent, new_node))\n\n                # Rewire near nodes to new_node if beneficial\n                for near in near_nodes:\n                    if near is min_parent:\n                        continue\n                    new_cost = new_node.cost + math.dist(new_node.position, near.position)\n                    if new_cost < near.cost and not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                        if near.parent:\n                            try: edges.remove((near.parent, near))\n                            except ValueError: pass\n                            # Remove near from old parent's children list safely\n                            try: near.parent.children.remove(near)\n                            except ValueError: pass\n                        near.parent = new_node\n                        near.cost = new_cost\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n\n                # Try to connect both trees to form path\n                connect_node = self._nearest(tree_b, new_node.position)\n                dist_connect = math.dist(new_node.position, connect_node.position)\n                if dist_connect <= self.step_size:\n                    if not self._is_edge_in_obstacle(new_node.position, connect_node.position, obstacles, is_3d):\n                        path_cost = new_node.cost + dist_connect + connect_node.cost\n                        if path_cost < best_cost:\n                            best_cost = path_cost\n                            if tree_a is start_tree:\n                                solution_start, solution_goal = new_node, connect_node\n                            else:\n                                solution_start, solution_goal = connect_node, new_node\n\n            # Progressive shortcutting for smoother path every shortcut_interval iterations\n            if best_cost < float('inf') and solution_start and solution_goal and (i % self.shortcut_interval == 0 or i == self.max_iter-1):\n                raw_path = self._extract_path(solution_start, solution_goal)\n                shortcut_path = self._shortcut_path(raw_path, obstacles, is_3d, max_attempts=50)\n                if shortcut_path:\n                    return PlannerResult(True, shortcut_path, nodes, edges)\n\n        # No solution found\n        return PlannerResult(False, [], nodes, edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        import random\n        while True:\n            pt = tuple(random.uniform(0, bounds[i]) for i in range(len(bounds)))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def _informed_sample(self, bounds, obstacles, is_3d, start, goal, c_max, c_min):\n        import random\n        import math\n        dim = 3 if is_3d else 2\n\n        # Reject sample if no valid ellipsoid (e.g. c_max <= c_min)\n        if c_max <= c_min:\n            return self._sample_free(bounds, obstacles, is_3d)\n\n        center = tuple((start[i]+goal[i])/2 for i in range(dim))\n        dir_vec = [goal[i]-start[i] for i in range(dim)]\n        length = math.dist(start, goal)\n        if length == 0:\n            # No interval, uniform sample fallback\n            return self._sample_free(bounds, obstacles, is_3d)\n\n        # Compute rotation matrix R from canonical axis to direction vector\n        if dim == 2:\n            a1 = [1,0]\n            a2 = [dir_vec[0]/length, dir_vec[1]/length]\n            cos_theta = a1[0]*a2[0] + a1[1]*a2[1]\n            sin_theta = a1[0]*a2[1] - a1[1]*a2[0]\n            R = [[cos_theta, -sin_theta],[sin_theta, cos_theta]]\n        else:\n            from math import sqrt\n            a1 = [1,0,0]\n            a2 = [dir_vec[i]/length for i in range(3)]\n            v = [a1[1]*a2[2]-a1[2]*a2[1], a1[2]*a2[0]-a1[0]*a2[2], a1[0]*a2[1]-a1[1]*a2[0]]\n            s = sqrt(sum([vi*vi for vi in v]))\n            c = sum([a1[i]*a2[i] for i in range(3)])\n            if s == 0:\n                R = [[1,0,0],[0,1,0],[0,0,1]]\n            else:\n                vx = [[0,-v[2],v[1]],[v[2],0,-v[0]],[-v[1],v[0],0]]\n                I = [[1 if i==j else 0 for j in range(3)] for i in range(3)]\n                vx2 = [[sum(vx[i][k]*vx[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n                R = [[I[i][j] + vx[i][j] + vx2[i][j]*((1 - c)/(s**2)) for j in range(3)] for i in range(3)]\n\n        # Sample point inside unit ball\n        if dim == 2:\n            r = random.uniform(0,1)**0.5\n            theta = random.uniform(0, 2*math.pi)\n            x_ball = [r*math.cos(theta), r*math.sin(theta)]\n        else:\n            while True:\n                x_ball = [random.uniform(-1,1) for _ in range(3)]\n                if sum(xi*xi for xi in x_ball) <= 1:\n                    break\n\n        a1_val = c_max / 2.0\n        a_other = math.sqrt(c_max**2 - c_min**2) / 2.0\n\n        # Scaling matrix\n        if dim == 2:\n            L = [[a1_val, 0],[0, a_other]]\n            x_scaled = [L[0][0]*x_ball[0] + L[0][1]*x_ball[1],\n                        L[1][0]*x_ball[0] + L[1][1]*x_ball[1]]\n            pt = (center[0] + R[0][0]*x_scaled[0] + R[0][1]*x_scaled[1],\n                  center[1] + R[1][0]*x_scaled[0] + R[1][1]*x_scaled[1])\n        else:\n            L = [[a1_val, 0, 0],[0, a_other, 0],[0, 0, a_other]]\n            x_scaled = [L[0][0]*x_ball[0], L[1][1]*x_ball[1], L[2][2]*x_ball[2]]\n            pt = tuple(center[i] + sum(R[i][j]*x_scaled[j] for j in range(3)) for i in range(3))\n\n        # Reject if outside bounds or in obstacle\n        if any(pt[d] < 0 or pt[d] > bounds[d] for d in range(dim)):\n            return self._sample_free(bounds, obstacles, is_3d)\n        if self._is_in_obstacle(pt, obstacles, is_3d):\n            return self._sample_free(bounds, obstacles, is_3d)\n\n        return pt\n\n    def _nearest(self, tree, point):\n        import math\n        return min(tree, key=lambda n: math.dist(n.position, point))\n\n    def _near(self, tree, point, radius):\n        r_sq = radius*radius\n        return [n for n in tree if sum((n.position[i]-point[i])**2 for i in range(len(point))) <= r_sq]\n\n    def _steer(self, from_pos, to_pos, step_size):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        if dist <= step_size:\n            return to_pos\n        ratio = step_size / dist\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i])*ratio for i in range(len(from_pos)))\n\n    def _extract_path(self, node_start, node_goal):\n        path_start, path_goal = [], []\n        n = node_start\n        while n:\n            path_start.append(n.position)\n            n = n.parent\n        n = node_goal\n        while n:\n            path_goal.append(n.position)\n            n = n.parent\n        return list(reversed(path_start)) + path_goal\n\n    def _shortcut_path(self, path, obstacles, is_3d, max_attempts=30):\n        # Attempt bounded shortcutting to improve smoothness by removing redundant waypoints\n        if len(path) < 3:\n            return path[:]\n        import random\n        new_path = path[:]\n        attempts = 0\n        while attempts < max_attempts:\n            if len(new_path) < 3:\n                break\n            i = random.randint(0, len(new_path)-3)\n            j = random.randint(i+2, len(new_path)-1)\n            if not self._is_edge_in_obstacle(new_path[i], new_path[j], obstacles, is_3d):\n                # Remove intermediate nodes between i and j\n                new_path = new_path[:i+1] + new_path[j:]\n                attempts = 0  # reset attempts after successful shortcut\n            else:\n                attempts += 1\n        return new_path\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x,y,z,w,h,d=obs\n                px,py,pz=pos\n                if x<=px<=x+w and y<=py<=y+h and z<=pz<=z+d:\n                    return True\n            else:\n                x,y,w,h=obs\n                px,py=pos\n                if x<=px<=x+w and y<=py<=y+h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist/resolution))\n        for i in range(steps+1):\n            interp = tuple(from_pos[d] + (to_pos[d]-from_pos[d])*(i/steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -30.55144,
          "time_improvement": 46.0,
          "length_improvement": 18.0,
          "smoothness_improvement": 1254.0,
          "node_improvement": 72.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.019833183288574217,
                    "num_nodes_avg": 147.4,
                    "path_length_avg": 162.65169192869433,
                    "smoothness_avg": 0.04547432196696187,
                    "success_improvement": 0.0,
                    "time_improvement": 23.09980633143671,
                    "node_improvement": 62.880886426592795,
                    "length_improvement": 10.848030272889844,
                    "smoothness_improvement": 611.7718878536382,
                    "objective_score": 16.49761950243311
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.023508524894714354,
                    "num_nodes_avg": 236.2,
                    "path_length_avg": 226.91038346862007,
                    "smoothness_avg": 0.07885871014571852,
                    "success_improvement": 0.0,
                    "time_improvement": 85.80194702529162,
                    "node_improvement": 84.12954377477658,
                    "length_improvement": 24.250782744921644,
                    "smoothness_improvement": 1929.091411682397,
                    "objective_score": 49.936510812952456
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.036681842803955075,
                    "num_nodes_avg": 255.1,
                    "path_length_avg": 123.45751291252664,
                    "smoothness_avg": 0.10380569995332274,
                    "success_improvement": 0.0,
                    "time_improvement": 27.71649022711396,
                    "node_improvement": 67.56516211061665,
                    "length_improvement": 18.005398338521033,
                    "smoothness_improvement": 1220.4008412665191,
                    "objective_score": 25.220190277579402
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "An improved bidirectional RRT* planner leveraging grid-based spatial hashing for efficient nearest and near-node queries, incremental node rewiring with limited local radius to reduce computational overhead, and incremental lightweight shortcutting applied periodically during planning to progressively smooth and shorten paths. The planner alternates expansion between start and goal trees, uses goal bias sampling, and performs adaptive radius-based rewiring with spatial acceleration to enhance planning speed, path quality, and smoothness while maintaining robustness and path feasibility.",
          "planning_mechanism": "The planner maintains two trees grown alternately from start and goal. Sampling strategically biases towards the goal to accelerate convergence. To accelerate nearest and neighborhood queries, spatial hashing discretizes the map space into grid cells allowing fast candidate pruning. Nodes connect via steering within a step size, and rewiring attempts are limited locally and applied incrementally every few iterations to limit overhead. Lightweight incremental shortcutting applies every set of iterations to progressively refine paths. The search stops upon connection or max iterations, returning the best smoothed path found.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except ValueError:\n            pass\nclass Planner:\n    def __init__(self, max_iter=3000, step_size=5.0, goal_sample_rate=0.15,\n                 rewire_interval=10, shortcut_interval=50, grid_resolution=5.0, local_rewire_radius_factor=2.5):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.rewire_interval = rewire_interval\n        self.shortcut_interval = shortcut_interval\n        self.grid_resolution = grid_resolution\n        self.local_rewire_radius_factor = local_rewire_radius_factor\n\n    def plan(self, map):\n        import random\n        import math\n        bounds = map.size\n        obstacles = map.obstacles\n        start_pos = map.start\n        goal_pos = map.goal\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        # Spatial hash grid for fast neighbor queries\n        class SpatialHash:\n            def __init__(self, resolution, bounds, dim):\n                self.res = resolution\n                self.bounds = bounds\n                self.dim = dim\n                self.cells = {}\n\n            def _hash(self, pos):\n                return tuple(int(pos[i] // self.res) for i in range(self.dim))\n\n            def add(self, node):\n                h = self._hash(node.position)\n                if h not in self.cells:\n                    self.cells[h] = []\n                self.cells[h].append(node)\n\n            def remove(self, node):\n                h = self._hash(node.position)\n                if h in self.cells and node in self.cells[h]:\n                    self.cells[h].remove(node)\n                    if not self.cells[h]:\n                        del self.cells[h]\n\n            def near(self, pos, radius):\n                hr = int(math.ceil(radius / self.res))\n                base = self._hash(pos)\n                candidates = []\n                def neighbors_1d(b):\n                    return [b + i for i in range(-hr, hr + 1)]\n                if self.dim == 2:\n                    x_idx = neighbors_1d(base[0])\n                    y_idx = neighbors_1d(base[1])\n                    for xi in x_idx:\n                        for yi in y_idx:\n                            cell = (xi, yi)\n                            if cell in self.cells:\n                                candidates.extend(self.cells[cell])\n                else:\n                    x_idx = neighbors_1d(base[0])\n                    y_idx = neighbors_1d(base[1])\n                    z_idx = neighbors_1d(base[2])\n                    for xi in x_idx:\n                        for yi in y_idx:\n                            for zi in z_idx:\n                                cell = (xi, yi, zi)\n                                if cell in self.cells:\n                                    candidates.extend(self.cells[cell])\n                return candidates\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        hash_start = SpatialHash(self.grid_resolution, bounds, dim)\n        hash_goal = SpatialHash(self.grid_resolution, bounds, dim)\n        hash_start.add(start_tree[0])\n        hash_goal.add(goal_tree[0])\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(fr, to):\n            d = dist(fr, to)\n            if d <= self.step_size:\n                return to\n            ratio = self.step_size / d\n            return tuple(fr[i] + (to[i] - fr[i]) * ratio for i in range(dim))\n\n        def is_in_obstacle(p):\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d_ = obs\n                    px,py,pz = p\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d_:\n                        return True\n                else:\n                    x,y,w,h = obs\n                    px,py = p\n                    if x <= px <= x+w and y <= py <= y+h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(fr, to, resolution=1.0):\n            dist_ = dist(fr, to)\n            steps = max(1, int(dist_ / resolution))\n            for i in range(steps + 1):\n                interp = tuple(fr[j] + (to[j] - fr[j]) * i / steps for j in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def nearest(tree_hash, pos):\n            candidates = tree_hash.near(pos, self.step_size*5)\n            best = None\n            best_d = float('inf')\n            for node in candidates:\n                d_ = dist(node.position, pos)\n                if d_ < best_d:\n                    best_d = d_\n                    best = node\n            # If no candidates in nearby cells, fallback to linear search\n            if best is None:\n                # linear fallback rare and expensive, only approx fallback\n                best = None\n                best_d = float('inf')\n                for node_list in tree_hash.cells.values():\n                    for node in node_list:\n                        d_ = dist(node.position, pos)\n                        if d_ < best_d:\n                            best_d = d_\n                            best = node\n            return best\n\n        def near_nodes(tree_hash, pos, radius):\n            candidates = tree_hash.near(pos, radius)\n            r_sq = radius*radius\n            return [node for node in candidates if dist(node.position, pos) <= radius]\n\n        def extract_path(n_start, n_goal):\n            path_start = []\n            n = n_start\n            while n is not None:\n                path_start.append(n.position)\n                n = n.parent\n            path_goal = []\n            n = n_goal\n            while n is not None:\n                path_goal.append(n.position)\n                n = n.parent\n            if path_start[-1] == path_goal[-1]:\n                path_goal.pop()  # avoid duplication\n            return path_start[::-1] + path_goal\n\n        def rewire(tree_hash, new_node, near_nodes_):\n            nonlocal edges\n            radius = self.local_rewire_radius_factor * self.step_size\n            for near in near_nodes_:\n                if near is new_node.parent:\n                    continue\n                dist_to_near = dist(new_node.position, near.position)\n                if dist_to_near > radius:\n                    continue\n                new_cost = new_node.cost + dist_to_near\n                if new_cost + 1e-8 < near.cost:\n                    if not is_edge_in_obstacle(new_node.position, near.position):\n                        # Remove old edge\n                        if near.parent is not None:\n                            try:\n                                edges.remove((near.parent, near))\n                                near.parent.remove_child(near)\n                            except Exception:\n                                pass\n                        near.parent = new_node\n                        near.cost = new_cost\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n\n        def shortcut_path(path, max_attempts=15):\n            if len(path) < 3:\n                return path[:]\n            new_path = path[:]\n            attempts = 0\n            while attempts < max_attempts:\n                if len(new_path) < 3:\n                    break\n                i = random.randint(0, len(new_path) - 3)\n                j = random.randint(i + 2, len(new_path) - 1)\n                p1, p2 = new_path[i], new_path[j]\n                if not is_edge_in_obstacle(p1, p2):\n                    new_path = new_path[:i+1] + new_path[j:]\n                    attempts = 0\n                else:\n                    attempts += 1\n            return new_path\n\n        def sample():\n            if random.random() < self.goal_sample_rate:\n                return goal_pos\n            else:\n                return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n\n        connection_start = None\n        connection_goal = None\n        best_cost = float('inf')\n        best_path = []\n\n        for it in range(self.max_iter):\n            for tree_a, tree_b, hash_a, hash_b in [(start_tree, goal_tree, hash_start, hash_goal),\n                                                   (goal_tree, start_tree, hash_goal, hash_start)]:\n                q_rand = sample()\n                nearest_node = nearest(hash_a, q_rand)\n                if nearest_node is None:\n                    continue\n                q_new_pos = steer(nearest_node.position, q_rand)\n                if is_in_obstacle(q_new_pos):\n                    continue\n                if is_edge_in_obstacle(nearest_node.position, q_new_pos):\n                    continue\n                # Determine parent among near nodes with minimal cost\n                near_nodes_a = near_nodes(hash_a, q_new_pos, self.local_rewire_radius_factor * self.step_size)\n                min_cost = nearest_node.cost + dist(nearest_node.position, q_new_pos)\n                min_parent = nearest_node\n                for near in near_nodes_a:\n                    tentative_cost = near.cost + dist(near.position, q_new_pos)\n                    if tentative_cost + 1e-12 < min_cost:\n                        if not is_edge_in_obstacle(near.position, q_new_pos):\n                            min_cost = tentative_cost\n                            min_parent = near\n                q_new = Node(q_new_pos, parent=min_parent, cost=min_cost)\n                min_parent.add_child(q_new)\n                tree_a.append(q_new)\n                nodes.append(q_new)\n                edges.append((min_parent, q_new))\n                hash_a.add(q_new)\n\n                # Periodic rewiring for efficiency\n                if it % self.rewire_interval == 0:\n                    rewire(hash_a, q_new, near_nodes_a)\n\n                # Attempt connection to other tree\n                nearest_other = nearest(hash_b, q_new.position)\n                if nearest_other is None:\n                    continue\n                dist_connect = dist(q_new.position, nearest_other.position)\n                if dist_connect <= self.step_size * self.local_rewire_radius_factor:\n                    if not is_edge_in_obstacle(q_new.position, nearest_other.position):\n                        total_cost = q_new.cost + dist_connect + nearest_other.cost\n                        if total_cost + 1e-12 < best_cost:\n                            best_cost = total_cost\n                            connection_start, connection_goal = (q_new, nearest_other) if tree_a is start_tree else (nearest_other, q_new)\n                            best_path = extract_path(connection_start, connection_goal)\n\n            # Periodic lightweight shortcutting on best path\n            if best_path and it % self.shortcut_interval == 0:\n                best_path = shortcut_path(best_path)\n\n            # Early termination if connected and smoothed path found\n            if best_path and it % self.shortcut_interval == 0:\n                return PlannerResult(True, best_path, nodes, edges)\n\n        # Return best path found if any\n        if best_path:\n            return PlannerResult(True, best_path, nodes, edges)\n        return PlannerResult(False, [], nodes, edges)",
          "objective": -29.85719,
          "time_improvement": 50.0,
          "length_improvement": 15.0,
          "smoothness_improvement": 1124.0,
          "node_improvement": 66.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.0184661865234375,
                    "num_nodes_avg": 150.7,
                    "path_length_avg": 170.55441969465716,
                    "smoothness_avg": 0.026642453962263436,
                    "success_improvement": 0.0,
                    "time_improvement": 28.40013126938419,
                    "node_improvement": 62.04986149584488,
                    "length_improvement": 6.516419957630541,
                    "smoothness_improvement": 317.01225952420344,
                    "objective_score": 14.0149526530146
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.0354881763458252,
                    "num_nodes_avg": 344.6,
                    "path_length_avg": 235.67995906786047,
                    "smoothness_avg": 0.0792326175097546,
                    "success_improvement": 0.0,
                    "time_improvement": 78.5667960882094,
                    "node_improvement": 76.84606598132096,
                    "length_improvement": 21.323245991657284,
                    "smoothness_improvement": 1938.712317473634,
                    "objective_score": 46.057548008825364
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.028713369369506837,
                    "num_nodes_avg": 310.3,
                    "path_length_avg": 123.23507190643708,
                    "smoothness_avg": 0.09562231356413795,
                    "success_improvement": 0.0,
                    "time_improvement": 43.418788240119405,
                    "node_improvement": 60.54672600127146,
                    "length_improvement": 18.153133063263258,
                    "smoothness_improvement": 1116.3087704308396,
                    "objective_score": 29.499060162147973
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e2",
          "algorithm_description": "A novel bidirectional Anytime Informed RRT* with density-adaptive rewiring radius and real-time incremental shortcutting. The algorithm progressively focuses sampling within an ellipsoidal informed set, adapts the rewiring radius based on current tree density for efficient local optimization, interleaves tree expansions with immediate neighbor rewiring to quickly improve path cost, and performs lightweight incremental shortcutting at regular intervals to continually smooth and shorten the path. This integrated approach improves planning efficiency, success rate, robustness, and path quality while minimizing runtime.",
          "planning_mechanism": "Two trees rooted at start and goal grow bidirectionally by sampling inside a shrinking ellipsoidal region defined by the current best path cost. The rewiring radius shrinks adaptively as the node density grows to balance exploration and local optimization. Each new node selects optimal parent and rewires neighbors with collision checks. On better solution discovery, paths are extracted and an incremental shortcutting procedure runs frequently to remove redundant waypoints, enhancing smoothness and length. This continuous integration enables the algorithm to quickly converge to high-quality paths.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except ValueError:\n            pass\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=6.5, gamma=40.0, shortcut_freq=30, max_shortcut_attempts=30):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.gamma = gamma\n        self.shortcut_freq = shortcut_freq\n        self.max_shortcut_attempts = max_shortcut_attempts\n\n    def plan(self, map):\n        import random\n        import math\n\n        bounds = map.size\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        obstacles = map.obstacles\n        start_pos = map.start\n        goal_pos = map.goal\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        best_cost = float('inf')\n        sol_start = None\n        sol_goal = None\n        c_min = math.dist(start_pos, goal_pos)\n        unit_ball_vol = self._unit_ball_volume(dim)\n\n        def near_radius(num_nodes):\n            if num_nodes <= 1:\n                return self.step_size * 3.0\n            r = self.gamma * (math.log(num_nodes) / num_nodes) ** (1.0 / dim)\n            return min(r, self.step_size * 45.0)\n\n        def sample_informed():\n            if best_cost == float('inf') or best_cost <= c_min:\n                return self._sample_free(bounds, obstacles, is_3d)\n            center = tuple((start_pos[i] + goal_pos[i]) * 0.5 for i in range(dim))\n            direction = [goal_pos[i] - start_pos[i] for i in range(dim)]\n            length = math.dist(start_pos, goal_pos)\n            if dim == 2:\n                if length < 1e-12:\n                    R = [[1, 0], [0, 1]]\n                else:\n                    a1 = [1, 0]\n                    a2 = [direction[0] / length, direction[1] / length]\n                    cos_theta = a1[0] * a2[0] + a1[1] * a2[1]\n                    sin_theta = a1[0] * a2[1] - a1[1] * a2[0]\n                    R = [[cos_theta, -sin_theta], [sin_theta, cos_theta]]\n            else:\n                from math import sqrt\n                if length < 1e-12:\n                    R = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n                else:\n                    a1 = [1, 0, 0]\n                    a2 = [direction[i] / length for i in range(3)]\n                    v = [a1[1] * a2[2] - a1[2] * a2[1],\n                         a1[2] * a2[0] - a1[0] * a2[2],\n                         a1[0] * a2[1] - a1[1] * a2[0]]\n                    s = sqrt(sum(vi * vi for vi in v))\n                    c = sum(a1[i] * a2[i] for i in range(3))\n                    if s < 1e-12:\n                        R = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n                    else:\n                        vx = [[0, -v[2], v[1]],\n                              [v[2], 0, -v[0]],\n                              [-v[1], v[0], 0]]\n                        I = [[1 if i == j else 0 for j in range(3)] for i in range(3)]\n                        vx2 = [[sum(vx[i][k] * vx[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n                        R = [[I[i][j] + vx[i][j] + vx2[i][j] * ((1 - c) / (s ** 2))\n                              for j in range(3)] for i in range(3)]\n\n            a1_val = best_cost * 0.5\n            a_other = math.sqrt(max(best_cost * best_cost - c_min * c_min, 0.0)) * 0.5\n            while True:\n                if dim == 2:\n                    r = random.uniform(0, 1) ** 0.5\n                    theta = random.uniform(0, 2 * math.pi)\n                    x_ball = [r * math.cos(theta), r * math.sin(theta)]\n                    L = [[a1_val, 0], [0, a_other]]\n                    x_scaled = [L[0][0] * x_ball[0] + L[0][1] * x_ball[1], L[1][0] * x_ball[0] + L[1][1] * x_ball[1]]\n                    pt = (center[0] + R[0][0] * x_scaled[0] + R[0][1] * x_scaled[1],\n                          center[1] + R[1][0] * x_scaled[0] + R[1][1] * x_scaled[1])\n                else:\n                    while True:\n                        x_ball = [random.uniform(-1, 1) for _ in range(3)]\n                        if sum(xi * xi for xi in x_ball) <= 1:\n                            break\n                    L = [[a1_val, 0, 0], [0, a_other, 0], [0, 0, a_other]]\n                    x_scaled = [L[0][0] * x_ball[0], L[1][1] * x_ball[1], L[2][2] * x_ball[2]]\n                    pt = tuple(center[i] + sum(R[i][j] * x_scaled[j] for j in range(dim)) for i in range(dim))\n                if any(pt[d] < 0 or pt[d] > bounds[d] for d in range(dim)):\n                    continue\n                if self._is_in_obstacle(pt, obstacles, is_3d):\n                    continue\n                return pt\n\n        def attempt_extend(tree_a, tree_b, sample):\n            nearest = self._nearest(tree_a, sample)\n            new_pos = self._steer(nearest.position, sample, self.step_size)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                return None\n\n            new_node = Node(new_pos)\n            radius = near_radius(len(tree_a))\n            near_nodes = self._near(tree_a, new_pos, radius)\n\n            min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n            min_parent = nearest\n            for near in near_nodes:\n                tentative_cost = near.cost + math.dist(near.position, new_pos)\n                if tentative_cost < min_cost:\n                    if not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d):\n                        min_cost = tentative_cost\n                        min_parent = near\n\n            new_node.parent = min_parent\n            new_node.cost = min_cost\n            min_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((min_parent, new_node))\n\n            # Rewire all neighbors except min_parent if it improves cost\n            for near in near_nodes:\n                if near is min_parent:\n                    continue\n                new_cost = new_node.cost + math.dist(new_node.position, near.position)\n                if new_cost < near.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                        if near.parent is not None:\n                            try:\n                                edges.remove((near.parent, near))\n                            except ValueError:\n                                pass\n                            near.parent.remove_child(near)\n                        near.parent = new_node\n                        near.cost = new_cost\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n\n            # Try connect to tree_b nearest node within step size\n            nearest_b = self._nearest(tree_b, new_node.position)\n            dist_connect = math.dist(new_node.position, nearest_b.position)\n            if dist_connect <= self.step_size:\n                if not self._is_edge_in_obstacle(new_node.position, nearest_b.position, obstacles, is_3d):\n                    total_cost = new_node.cost + dist_connect + nearest_b.cost\n                    return new_node, nearest_b, total_cost\n            return None\n\n        def incremental_shortcut(path):\n            if len(path) < 3:\n                return path[:]\n            import random\n            shortcut_path = path[:]\n            attempts = 0\n            while attempts < self.max_shortcut_attempts:\n                if len(shortcut_path) < 3:\n                    break\n                i = random.randint(0, len(shortcut_path) - 3)\n                j = random.randint(i + 2, len(shortcut_path) - 1)\n                if not self._is_edge_in_obstacle(shortcut_path[i], shortcut_path[j], obstacles, is_3d):\n                    shortcut_path = shortcut_path[:i + 1] + shortcut_path[j:]\n                    attempts = 0  # reset attempts on success\n                else:\n                    attempts += 1\n            return shortcut_path\n\n        for it in range(self.max_iter):\n            sample = sample_informed()\n            for (tree_a, tree_b) in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                res = attempt_extend(tree_a, tree_b, sample)\n                if res is not None:\n                    new_node, connect_node, cost_path = res\n                    if cost_path < best_cost:\n                        best_cost = cost_path\n                        if tree_a is start_tree:\n                            sol_start, sol_goal = new_node, connect_node\n                        else:\n                            sol_start, sol_goal = connect_node, new_node\n            if best_cost < float('inf') and sol_start is not None and sol_goal is not None:\n                if it % self.shortcut_freq == 0 or it == self.max_iter - 1:\n                    raw_path = self._extract_path(sol_start, sol_goal)\n                    improved_path = incremental_shortcut(raw_path)\n                    if improved_path and len(improved_path) >= 2:\n                        return PlannerResult(True, improved_path, nodes, edges)\n        return PlannerResult(False, [], nodes, edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        import random\n        while True:\n            pt = tuple(random.uniform(0, bounds[i]) for i in range(len(bounds)))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def _nearest(self, tree, point):\n        best = None\n        best_dist = float('inf')\n        for n in tree:\n            d = 0.0\n            for i in range(len(point)):\n                diff = n.position[i] - point[i]\n                d += diff * diff\n            if d < best_dist:\n                best_dist = d\n                best = n\n        return best\n\n    def _near(self, tree, point, radius):\n        r_sq = radius * radius\n        result = []\n        for n in tree:\n            d = 0.0\n            for i in range(len(point)):\n                diff = n.position[i] - point[i]\n                d += diff * diff\n            if d <= r_sq:\n                result.append(n)\n        return result\n\n    def _steer(self, from_pos, to_pos, step_size):\n        dist = 0.0\n        diff_vec = []\n        for i in range(len(from_pos)):\n            diff = to_pos[i] - from_pos[i]\n            diff_vec.append(diff)\n            dist += diff * diff\n        dist = dist ** 0.5\n        if dist <= step_size:\n            return to_pos\n        ratio = step_size / dist\n        new_pos = tuple(from_pos[i] + diff_vec[i] * ratio for i in range(len(from_pos)))\n        return new_pos\n\n    def _extract_path(self, node_start, node_goal):\n        path_start = []\n        n = node_start\n        while n is not None:\n            path_start.append(n.position)\n            n = n.parent\n        path_goal = []\n        n = node_goal\n        while n is not None:\n            path_goal.append(n.position)\n            n = n.parent\n        return list(reversed(path_start)) + path_goal\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        dist = 0.0\n        for i in range(len(from_pos)):\n            diff = to_pos[i] - from_pos[i]\n            dist += diff * diff\n        dist = dist ** 0.5\n        steps = max(1, int(dist / resolution))\n        for step in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (step / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _unit_ball_volume(self, dim):\n        import math\n        if dim == 2:\n            return math.pi\n        if dim == 3:\n            return 4.0 / 3.0 * math.pi\n        from math import gamma, pi\n        return (pi ** (dim / 2)) / gamma(dim / 2 + 1)",
          "objective": -29.43149,
          "time_improvement": 46.0,
          "length_improvement": 15.0,
          "smoothness_improvement": 1325.0,
          "node_improvement": 72.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.025296664237976073,
                    "num_nodes_avg": 157.7,
                    "path_length_avg": 169.82640352208247,
                    "smoothness_avg": 0.034435143239248046,
                    "success_improvement": 0.0,
                    "time_improvement": 1.9159783497959368,
                    "node_improvement": 60.28708133971292,
                    "length_improvement": 6.915457157973212,
                    "smoothness_improvement": 438.98476880462505,
                    "objective_score": 6.918991643745834
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.026137399673461913,
                    "num_nodes_avg": 228.4,
                    "path_length_avg": 237.06092208208943,
                    "smoothness_avg": 0.09896313272769311,
                    "success_improvement": 0.0,
                    "time_improvement": 84.21422922761201,
                    "node_improvement": 84.65363166028354,
                    "length_improvement": 20.862240788691224,
                    "smoothness_improvement": 2446.3926853468774,
                    "objective_score": 50.01357666823272
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.02440671920776367,
                    "num_nodes_avg": 220.1,
                    "path_length_avg": 124.62874035050683,
                    "smoothness_avg": 0.09361395032374312,
                    "success_improvement": 0.0,
                    "time_improvement": 51.90526997765084,
                    "node_improvement": 72.01525746980292,
                    "length_improvement": 17.227524842071908,
                    "smoothness_improvement": 1090.7625382549713,
                    "objective_score": 31.361908589813254
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m2",
          "algorithm_description": "A novel bidirectional RRT* variant with dynamic goal-biased informed sampling, adaptive rewiring radius tuned by node density, efficient incremental rewiring with robust edge and child updates, and a geometry-driven post-processing smoothing combining heuristic shortcutting and path simplification for enhanced smoothness and path length within reduced planning time. This algorithm integrates focused sampling around the current best path, frequent rewiring to optimize locally, and geometry-aware shortcutting with checks for collision-free paths. It balances exploration and exploitation by adapting sampling and rewiring adaptively and uses early termination based on no improvement stagnation to improve efficiency.",
          "planning_mechanism": "The planner grows two trees from start and goal, alternately extending them toward samples generated either uniformly, toward the goal directly with goal bias, or within an ellipsoidal informed subset defined by the best solution cost. New nodes choose parents from neighbors within an adaptive radius decreasing with node number and dimension, ensuring efficient rewiring and local cost optimization. Upon connecting the two trees, the best path is extracted and a geometry-driven post-processing smoothing method attempts shortcutting only between points with larger Euclidean distance and removes unnecessary waypoints to reduce jagged turns. The algorithm applies early stopping if no improvement is made for a defined iteration window, yielding faster convergence and better path length and smoothness without compromising robustness.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n    def add_child(self, child):\n        self.children.append(child)\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except ValueError:\n            pass\nclass Planner:\n    def __init__(self, max_iter=3500, step_size=6.0, gamma=35.0,\n                 goal_sample_rate=0.15, shortcut_interval=15, max_shortcut_attempts=50,\n                 no_improve_limit=80):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.gamma = gamma\n        self.goal_sample_rate = goal_sample_rate\n        self.shortcut_interval = shortcut_interval\n        self.max_shortcut_attempts = max_shortcut_attempts\n        self.no_improve_limit = no_improve_limit\n\n    def plan(self, map):\n        import random\n        import math\n\n        bounds = map.size\n        dim = len(bounds)\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = (dim == 3)\n\n        def in_obstacle(pt):\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d = obs\n                    px,py,pz = pt\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                        return True\n                else:\n                    x,y,w,h = obs\n                    px,py = pt\n                    if x <= px <= x+w and y <= py <= y+h:\n                        return True\n            return False\n\n        def edge_in_obstacle(p1, p2, resolution=1.0):\n            dist = 0.0\n            for i in range(dim):\n                diff = p2[i] - p1[i]\n                dist += diff*diff\n            dist = dist**0.5\n            steps = max(1, int(dist / resolution))\n            for i in range(steps+1):\n                t = i / steps\n                interp = tuple(p1[d] + t*(p2[d]-p1[d]) for d in range(dim))\n                if in_obstacle(interp):\n                    return True\n            return False\n\n        def sample_uniform():\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not in_obstacle(pt):\n                    return pt\n\n        def sample_goal():\n            if not in_obstacle(goal_pos):\n                return goal_pos\n            return sample_uniform()\n\n        c_min = math.dist(start_pos, goal_pos)\n        best_cost = float('inf')\n        sol_start = None\n        sol_goal = None\n\n        def sample_informed():\n            if best_cost == float('inf') or best_cost <= c_min:\n                return sample_uniform()\n            center = tuple((start_pos[i] + goal_pos[i]) * 0.5 for i in range(dim))\n            dir_vec = [goal_pos[i] - start_pos[i] for i in range(dim)]\n            length = math.dist(start_pos, goal_pos)\n            if length < 1e-10:\n                return sample_uniform()\n            # Build rotation matrix to align x-axis with dir_vec\n            if dim == 2:\n                cos_theta = dir_vec[0] / length\n                sin_theta = dir_vec[1] / length\n                R = [[cos_theta, -sin_theta], [sin_theta, cos_theta]]\n                a1 = best_cost / 2.0\n                a2 = math.sqrt(max(best_cost**2 - c_min**2, 0.0)) / 2.0\n                while True:\n                    r = random.uniform(0,1)**0.5\n                    theta = random.uniform(0, 2*math.pi)\n                    x_ball = [r * math.cos(theta), r * math.sin(theta)]\n                    x_scaled = [a1 * x_ball[0], a2 * x_ball[1]]\n                    pt = (center[0] + R[0][0]*x_scaled[0] + R[0][1]*x_scaled[1],\n                          center[1] + R[1][0]*x_scaled[0] + R[1][1]*x_scaled[1])\n                    if any(pt[d]<0 or pt[d]>bounds[d] for d in range(dim)): continue\n                    if in_obstacle(pt): continue\n                    return pt\n            else:\n                from math import sqrt\n                a1 = best_cost / 2.0\n                a2 = math.sqrt(max(best_cost**2 - c_min**2, 0.0)) / 2.0\n                while True:\n                    x_ball = [random.uniform(-1,1) for _ in range(3)]\n                    r_sq = sum(x*x for x in x_ball)\n                    if r_sq > 1 or r_sq == 0: continue\n                    norm = r_sq**0.5\n                    x_ball = [x/norm for x in x_ball]\n                    L = [a1, a2, a2]\n                    x_scaled = [L[i]*x_ball[i] for i in range(3)]\n                    e1 = [1,0,0]\n                    e2 = [dir_vec[i]/length for i in range(3)]\n                    v = [e1[1]*e2[2]-e1[2]*e2[1], e1[2]*e2[0]-e1[0]*e2[2], e1[0]*e2[1]-e1[1]*e2[0]]\n                    s = sqrt(sum(x*x for x in v))\n                    c = sum(e1[i]*e2[i] for i in range(3))\n                    if s < 1e-10:\n                        R = [[1,0,0],[0,1,0],[0,0,1]]\n                    else:\n                        vx = [[0,-v[2],v[1]],[v[2],0,-v[0]],[-v[1],v[0],0]]\n                        I = [[1 if i==j else 0 for j in range(3)] for i in range(3)]\n                        vx2 = [[sum(vx[i][k]*vx[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n                        R = [[I[i][j] + vx[i][j] + vx2[i][j] * ((1 - c) / (s * s)) for j in range(3)] for i in range(3)]\n                    pt = tuple(center[i] + sum(R[i][j]*x_scaled[j] for j in range(3)) for i in range(3))\n                    if any(pt[d]<0 or pt[d]>bounds[d] for d in range(dim)): continue\n                    if in_obstacle(pt): continue\n                    return pt\n\n        def nearest(tree, pt):\n            best_node = None\n            best_dist_sq = float('inf')\n            for n in tree:\n                d = 0.0\n                for i in range(dim):\n                    diff = n.position[i]-pt[i]\n                    d += diff*diff\n                if d < best_dist_sq:\n                    best_dist_sq = d\n                    best_node = n\n            return best_node\n\n        def near(tree, pt, radius):\n            r_sq = radius*radius\n            result = []\n            for n in tree:\n                d = 0.0\n                for i in range(dim):\n                    diff = n.position[i] - pt[i]\n                    d += diff*diff\n                if d <= r_sq:\n                    result.append(n)\n            return result\n\n        def steer(from_pt, to_pt, max_dist):\n            dist = 0.0\n            diffs = []\n            for i in range(dim):\n                diff = to_pt[i] - from_pt[i]\n                diffs.append(diff)\n                dist += diff*diff\n            dist = dist**0.5\n            if dist <= max_dist:\n                return to_pt\n            ratio = max_dist / dist\n            new_pt = tuple(from_pt[i] + ratio*diffs[i] for i in range(dim))\n            return new_pt\n\n        def near_radius(n_nodes):\n            if n_nodes <= 1:\n                return self.step_size * 8.0\n            return min(self.step_size * 28.0, self.gamma * (math.log(n_nodes)/n_nodes)**(1.0/dim))\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        all_nodes = start_tree + goal_tree\n        edges = []\n\n        last_improve_iter = 0\n\n        def connect(tree_from, tree_to, sample):\n            nearest_node = nearest(tree_from, sample)\n            new_pos = steer(nearest_node.position, sample, self.step_size)\n            if in_obstacle(new_pos):\n                return None\n            if edge_in_obstacle(nearest_node.position, new_pos):\n                return None\n\n            radius = near_radius(len(tree_from))\n            neighbors = near(tree_from, new_pos, radius)\n\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            min_parent = nearest_node\n            for n in neighbors:\n                cost_try = n.cost + math.dist(n.position, new_pos)\n                if cost_try + 1e-10 < min_cost:\n                    if not edge_in_obstacle(n.position, new_pos):\n                        min_cost = cost_try\n                        min_parent = n\n\n            new_node = Node(new_pos, min_parent, min_cost)\n            min_parent.add_child(new_node)\n            tree_from.append(new_node)\n            all_nodes.append(new_node)\n            edges.append((min_parent, new_node))\n\n            # Rewire neighbors if going through new_node improves cost and edge is collision free\n            for n in neighbors:\n                if n is min_parent:\n                    continue\n                new_cost = new_node.cost + math.dist(new_node.position, n.position)\n                if new_cost + 1e-10 < n.cost:\n                    if not edge_in_obstacle(new_node.position, n.position):\n                        if n.parent is not None:\n                            try:\n                                edges.remove((n.parent, n))\n                            except ValueError:\n                                pass\n                            n.parent.remove_child(n)\n                        n.parent = new_node\n                        n.cost = new_cost\n                        new_node.add_child(n)\n                        edges.append((new_node, n))\n\n            nearest_other = nearest(tree_to, new_node.position)\n            dist_to_other = math.dist(new_node.position, nearest_other.position)\n            if dist_to_other <= self.step_size:\n                if not edge_in_obstacle(new_node.position, nearest_other.position):\n                    total_cost = new_node.cost + nearest_other.cost + dist_to_other\n                    return new_node, nearest_other, total_cost\n            return None\n\n        def extract_path(node_start, node_goal):\n            path_start = []\n            n = node_start\n            while n is not None:\n                path_start.append(n.position)\n                n = n.parent\n            path_goal = []\n            n = node_goal\n            while n is not None:\n                path_goal.append(n.position)\n                n = n.parent\n            return list(reversed(path_start)) + path_goal\n\n        def path_length(path):\n            length = 0.0\n            for i in range(len(path)-1):\n                length += math.dist(path[i], path[i+1])\n            return length\n\n        def geometric_shortcut(path):\n            # Heuristic geometry-aware shortcut: only try pairs with distance > 3*step_size to reduce attempts\n            if len(path) < 3:\n                return path[:]\n            new_path = path[:]\n            attempts = 0\n            max_attempts = self.max_shortcut_attempts\n            while attempts < max_attempts:\n                if len(new_path) < 3:\n                    break\n                import random\n                i = random.randint(0, len(new_path)-3)\n                j = random.randint(i+2, len(new_path)-1)\n                if math.dist(new_path[i], new_path[j]) > 3*self.step_size:\n                    if not edge_in_obstacle(new_path[i], new_path[j]):\n                        # Shortcut feasible, replace intermediate nodes\n                        new_path = new_path[:i+1] + new_path[j:]\n                        attempts = 0  # reset attempts on success\n                    else:\n                        attempts += 1\n                else:\n                    attempts += 1\n            # Post-process: Remove collinear or near-collinear nodes to smooth path further\n            def is_collinear(p1,p2,p3, tol=1e-3):\n                # Check area of triangle formed by these 3 points\n                if dim == 2:\n                    area = abs((p1[0]*(p2[1]-p3[1]) + p2[0]*(p3[1]-p1[1]) + p3[0]*(p1[1]-p2[1])) / 2.0)\n                    base = math.dist(p1,p3)\n                    height = 2*area/base if base > 0 else 0\n                    return height < tol\n                else:\n                    # For 3D use vector triple product for area of parallelogram\n                    import numpy as np\n                    a = np.array(p2)-np.array(p1)\n                    b = np.array(p3)-np.array(p1)\n                    cross = (a[1]*b[2]-a[2]*b[1], a[2]*b[0]-a[0]*b[2], a[0]*b[1]-a[1]*b[0])\n                    area = (cross[0]**2 + cross[1]**2 + cross[2]**2)**0.5 / 2.0\n                    base = math.dist(p1,p3)\n                    height = 2*area/base if base > 0 else 0\n                    return height < tol\n            # Remove near-collinear middle points\n            i = 1\n            while i < len(new_path)-1:\n                if is_collinear(new_path[i-1], new_path[i], new_path[i+1]):\n                    new_path.pop(i)\n                else:\n                    i += 1\n            return new_path\n\n        for it in range(self.max_iter):\n            r = random.random()\n            if best_cost < float('inf') and r < self.goal_sample_rate:\n                sample = sample_goal()\n            elif best_cost < float('inf'):\n                sample = sample_informed()\n            else:\n                sample = sample_uniform()\n\n            for tree_from, tree_to in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                res = connect(tree_from, tree_to, sample)\n                if res is not None:\n                    n_start, n_goal, cost = res\n                    if cost + 1e-10 < best_cost:\n                        best_cost = cost\n                        last_improve_iter = it\n                        if tree_from is start_tree:\n                            sol_start, sol_goal = n_start, n_goal\n                        else:\n                            sol_start, sol_goal = n_goal, n_start\n\n            if best_cost < float('inf'):\n                if (it - last_improve_iter) > self.no_improve_limit:\n                    break\n                if it % self.shortcut_interval == 0 and sol_start is not None and sol_goal is not None:\n                    raw_path = extract_path(sol_start, sol_goal)\n                    improved_path = geometric_shortcut(raw_path)\n                    if len(improved_path) >= 2:\n                        return PlannerResult(True, improved_path, all_nodes, edges)\n\n        if best_cost < float('inf') and sol_start and sol_goal:\n            raw_path = extract_path(sol_start, sol_goal)\n            final_path = geometric_shortcut(raw_path)\n            return PlannerResult(True, final_path, all_nodes, edges)\n\n        return PlannerResult(False, [], all_nodes, edges)",
          "objective": -28.78012,
          "time_improvement": 46.0,
          "length_improvement": 14.0,
          "smoothness_improvement": 1275.0,
          "node_improvement": 70.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.020882630348205568,
                    "num_nodes_avg": 147.3,
                    "path_length_avg": 170.37169066289314,
                    "smoothness_avg": 0.02821399372542354,
                    "success_improvement": 0.0,
                    "time_improvement": 19.030732751249133,
                    "node_improvement": 62.90606900025183,
                    "length_improvement": 6.616576635467197,
                    "smoothness_improvement": 341.61026947087623,
                    "objective_score": 11.387217154009438
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.030633068084716795,
                    "num_nodes_avg": 267.9,
                    "path_length_avg": 242.56536860233672,
                    "smoothness_avg": 0.10851433639409444,
                    "success_improvement": 0.0,
                    "time_improvement": 81.49905511330289,
                    "node_improvement": 81.9995968554727,
                    "length_improvement": 19.024698103524358,
                    "smoothness_improvement": 2692.152035137315,
                    "objective_score": 49.325295571792054
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.03129546642303467,
                    "num_nodes_avg": 269.8,
                    "path_length_avg": 125.02772119995618,
                    "smoothness_avg": 0.06998655864811568,
                    "success_improvement": 0.0,
                    "time_improvement": 38.33062953989469,
                    "node_improvement": 65.69612205975844,
                    "length_improvement": 16.96254075929408,
                    "smoothness_improvement": 790.2238601336318,
                    "objective_score": 25.627832618213013
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m1",
          "algorithm_description": "A hybrid bidirectional RRT* planner employing dynamic adaptive rewiring radius, ellipsoidal informed sampling post initial solution, efficient k-nearest rewiring leveraging approximate nearest neighbor heuristic, and a refined incremental shortcutting mechanism combining curvature preservation with iterative path smoothing. This planner aggressively prunes and updates trees for faster convergence, improves path length by adaptive rewiring and ellipsoidal sampling, while enhancing path smoothness by integrating curvature-aware incremental shortcutting and smoothing every fixed iteration interval. Early exits during collision checks and consistent graph maintenance reduce planning time and increase robustness.",
          "planning_mechanism": "A bidirectional RRT* alternates tree expansions from start and goal states. It performs ellipsoidal informed sampling inside an adaptive prolate hyperspheroid once a valid path is found, focusing search near the best solution. Adaptive near radius for rewiring scales logarithmically with node count and dimension. The planner uses approximate nearest neighbors by early exiting distance checks to improve rewiring efficiency. Rewiring considers curvature preservation to avoid sharp turns. The incremental shortcutting aggressively shortcuts edges without increasing curvature beyond a small angle threshold, followed by midpoint smoothing. Path extraction reconciles the two trees once a connection occurs, and path smoothing is applied periodically to maintain smooth solutions.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\nclass Planner:\n    def __init__(self, max_iter=4000, step_size=6.5, gamma_rrt_star=45.0,\n                 shortcut_interval=30, max_shortcut_attempts=45, curvature_threshold=0.3):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.gamma_rrt_star = gamma_rrt_star\n        self.shortcut_interval = shortcut_interval\n        self.max_shortcut_attempts = max_shortcut_attempts\n        self.curvature_threshold = curvature_threshold  # radians\n\n    def plan(self, map):\n        import math\n        import random\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        best_cost = float('inf')\n        solution_start, solution_goal = None, None\n\n        c_min = math.dist(start_pos, goal_pos)\n        volume_unit_ball = self._unit_ball_volume(dim)\n\n        def near_radius(n_nodes):\n            if n_nodes <= 1:\n                return self.step_size * 3.0\n            val = (math.log(n_nodes) / n_nodes) ** (1.0 / dim)\n            r = self.gamma_rrt_star * val\n            return min(r, self.step_size * 45)\n\n        def angle_between(a, b, c):\n            # Returns angle at b formed by points a-b-c in radians\n            ab = [a[i] - b[i] for i in range(dim)]\n            cb = [c[i] - b[i] for i in range(dim)]\n            lab = math.sqrt(sum(x * x for x in ab))\n            lcb = math.sqrt(sum(x * x for x in cb))\n            if lab < 1e-14 or lcb < 1e-14:\n                return 0.0\n            dotp = sum(ab[i] * cb[i] for i in range(dim))\n            val = max(min(dotp / (lab * lcb), 1.0), -1.0)\n            return math.acos(val)\n\n        def curvature_preserving_rewire(new_node, near_nodes_list):\n            import math\n            for near in near_nodes_list:\n                if near is new_node.parent or near is new_node:\n                    continue\n                dist_cost = math.dist(new_node.position, near.position)\n                potential_cost = new_node.cost + dist_cost\n                if potential_cost + 1e-15 < near.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                        # Check curvature increase if rewired\n                        prev_parent = near.parent\n                        if prev_parent is None:\n                            continue\n                        ang_before = angle_between(prev_parent.position, near.position, near.children[0].position) if near.children else 0.0\n                        ang_after = angle_between(new_node.position, near.position,\n                                                  near.children[0].position) if near.children else 0.0\n                        # Accept if curvature doesn't increase noticeably or children absent\n                        if len(near.children) == 0 or ang_after < ang_before + self.curvature_threshold:\n                            try:\n                                edges.remove((near.parent, near))\n                            except Exception:\n                                pass\n                            near.parent.remove_child(near)\n                            near.parent = new_node\n                            near.cost = potential_cost\n                            new_node.add_child(near)\n                            edges.append((new_node, near))\n                            self._update_subtree_costs(near, edges)\n\n        def incremental_curvature_shortcut(path):\n            # Iteratively tries shortcuts preserving curvature within threshold\n            if len(path) < 3:\n                return path[:]\n            import random\n            changed = True\n            new_path = path[:]\n            while changed:\n                changed = False\n                L = len(new_path)\n                for i in range(L - 2):\n                    for j in range(L - 1, i + 1, -1):\n                        if not self._is_edge_in_obstacle(new_path[i], new_path[j], obstacles, is_3d):\n                            # Check curvature preservation between three-waypoints if applicable\n                            if i > 0 and j < L - 1:\n                                ang_before = angle_between(new_path[i-1], new_path[i], new_path[i+1])\n                                ang_after = angle_between(new_path[i-1], new_path[j], new_path[j+1])\n                                if ang_after < ang_before + self.curvature_threshold:\n                                    new_path = new_path[:i+1] + new_path[j:]\n                                    changed = True\n                                    break\n                            else:\n                                new_path = new_path[:i+1] + new_path[j:]\n                                changed = True\n                                break\n                    if changed:\n                        break\n            return new_path\n\n        def midpoint_smooth(path):\n            if len(path) < 4:\n                return path[:]\n            new_path = path[:]\n            changed = False\n            for i in range(1, len(path) - 1):\n                a, b, c = new_path[i-1], new_path[i], new_path[i+1]\n                midpoint = tuple((a[d] + c[d]) * 0.5 for d in range(dim))\n                if (not self._is_in_obstacle(midpoint, obstacles, is_3d) and\n                    not self._is_edge_in_obstacle(a, midpoint, obstacles, is_3d) and\n                    not self._is_edge_in_obstacle(midpoint, c, obstacles, is_3d)):\n                    old_angle = angle_between(a, b, c)\n                    new_angle = angle_between(a, midpoint, c)\n                    if new_angle < old_angle + 1e-6:\n                        new_path[i] = midpoint\n                        changed = True\n            return new_path if changed else path\n\n        def informed_sample():\n            if best_cost == float('inf') or best_cost <= c_min:\n                return self._sample_free(bounds, obstacles, is_3d)\n            center = tuple((start_pos[i] + goal_pos[i]) * 0.5 for i in range(dim))\n            dir_vec = [goal_pos[i] - start_pos[i] for i in range(dim)]\n            length = math.dist(start_pos, goal_pos)\n            if dim == 2:\n                if length < 1e-14:\n                    R = [[1, 0], [0, 1]]\n                else:\n                    a1 = [1, 0]\n                    a2 = [dir_vec[0] / length, dir_vec[1] / length]\n                    cos_t = a1[0]*a2[0] + a1[1]*a2[1]\n                    sin_t = a1[0]*a2[1] - a1[1]*a2[0]\n                    R = [[cos_t, -sin_t], [sin_t, cos_t]]\n            else:\n                from math import sqrt\n                if length < 1e-14:\n                    R = [[1,0,0],[0,1,0],[0,0,1]]\n                else:\n                    a1 = [1,0,0]\n                    a2 = [dir_vec[i] / length for i in range(3)]\n                    v = [a1[1]*a2[2]-a1[2]*a2[1], a1[2]*a2[0]-a1[0]*a2[2], a1[0]*a2[1]-a1[1]*a2[0]]\n                    s = sqrt(sum(x*x for x in v))\n                    c = sum(a1[i]*a2[i] for i in range(3))\n                    if s < 1e-14:\n                        R = [[1,0,0],[0,1,0],[0,0,1]]\n                    else:\n                        vx = [[0,-v[2],v[1]], [v[2],0,-v[0]], [-v[1],v[0],0]]\n                        I = [[1 if i == j else 0 for j in range(3)] for i in range(3)]\n                        vx2 = [[sum(vx[i][k]*vx[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n                        R = [[I[i][j] + vx[i][j] + vx2[i][j]*((1 - c)/(s*s)) for j in range(3)] for i in range(3)]\n\n            a1_val = best_cost * 0.5\n            try:\n                term = best_cost*best_cost - c_min*c_min\n                a_other = math.sqrt(term)*0.5 if term > 0 else 0.0\n            except Exception:\n                a_other = 0.0\n\n            while True:\n                if dim == 2:\n                    r = random.uniform(0, 1)**0.5\n                    theta = random.uniform(0, 2*math.pi)\n                    ball = [r * math.cos(theta), r * math.sin(theta)]\n                    L = [[a1_val, 0], [0, a_other]]\n                    x_scaled = [L[0][0]*ball[0], L[1][1]*ball[1]]\n                    pt = (center[0] + R[0][0]*x_scaled[0] + R[0][1]*x_scaled[1],\n                          center[1] + R[1][0]*x_scaled[0] + R[1][1]*x_scaled[1])\n                else:\n                    while True:\n                        ball = [random.uniform(-1, 1) for _ in range(3)]\n                        if sum(x*x for x in ball) <= 1:\n                            break\n                    L = [[a1_val, 0, 0], [0, a_other, 0], [0, 0, a_other]]\n                    x_scaled = [L[0][0]*ball[0], L[1][1]*ball[1], L[2][2]*ball[2]]\n                    pt = tuple(center[i] + sum(R[i][j]*x_scaled[j] for j in range(dim)) for i in range(dim))\n\n                if any(pt[d] < 0.0 or pt[d] > bounds[d] for d in range(dim)):\n                    continue\n                if self._is_in_obstacle(pt, obstacles, is_3d):\n                    continue\n                return pt\n\n        def attempt_connection(tree_a, tree_b, sample):\n            nearest = self._nearest(tree_a, sample)\n            new_pos = self._steer(nearest.position, sample, self.step_size)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                return None\n\n            new_node = Node(new_pos)\n            radius = near_radius(len(tree_a))\n            near_nodes = self._near(tree_a, new_pos, radius)\n\n            min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n            min_parent = nearest\n            # Efficient approximate k-nearest rewiring (early exit heuristic)\n            for near in near_nodes:\n                tentative_cost = near.cost + math.dist(near.position, new_pos)\n                if tentative_cost < min_cost:\n                    # Early exit collision check\n                    if not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d):\n                        min_cost = tentative_cost\n                        min_parent = near\n\n            new_node.parent = min_parent\n            new_node.cost = min_cost\n            min_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((min_parent, new_node))\n\n            # Rewire nearby nodes trying to preserve curvature and improve cost\n            curvature_preserving_rewire(new_node, near_nodes)\n\n            # Try connect to tree_b within step_size\n            connect_candidate = self._nearest(tree_b, new_node.position)\n            dist_connect = math.dist(new_node.position, connect_candidate.position)\n            if dist_connect <= self.step_size:\n                if not self._is_edge_in_obstacle(new_node.position, connect_candidate.position, obstacles, is_3d):\n                    total_cost = new_node.cost + dist_connect + connect_candidate.cost\n                    if total_cost + 1e-15 < best_cost:\n                        return new_node, connect_candidate, total_cost\n            return None\n\n        for iteration in range(self.max_iter):\n            sample = informed_sample() if (best_cost < float('inf')) else self._sample_free(bounds, obstacles, is_3d)\n\n            # Alternate expansions\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                res = attempt_connection(tree_a, tree_b, sample)\n                if res is not None:\n                    new_node, conn_node, total_cost = res\n                    if total_cost < best_cost:\n                        best_cost = total_cost\n                        if tree_a is start_tree:\n                            solution_start, solution_goal = new_node, conn_node\n                        else:\n                            solution_start, solution_goal = conn_node, new_node\n\n            # Apply incremental path smoothing and curvature-aware shortcutting every shortcut_interval iterations once solution found\n            if best_cost < float('inf') and solution_start and solution_goal:\n                if iteration % self.shortcut_interval == 0 or iteration == self.max_iter - 1:\n                    raw_path = self._extract_path(solution_start, solution_goal)\n                    shortcut_path = incremental_curvature_shortcut(raw_path)\n                    smooth_path = midpoint_smooth(shortcut_path)\n                    return PlannerResult(True, smooth_path, nodes, edges)\n\n        return PlannerResult(False, [], nodes, edges)\n\n    def _extract_path(self, node_start, node_goal):\n        s_path = []\n        n = node_start\n        while n is not None:\n            s_path.append(n.position)\n            n = n.parent\n        g_path = []\n        n = node_goal\n        while n is not None:\n            g_path.append(n.position)\n            n = n.parent\n        return s_path[::-1] + g_path\n\n    def _nearest(self, tree, point):\n        best_node = None\n        best_dist_sq = float('inf')\n        for node in tree:\n            d_sq = 0.0\n            for i in range(len(point)):\n                diff = node.position[i] - point[i]\n                d_sq += diff * diff\n                if d_sq >= best_dist_sq:  # early exit\n                    break\n            if d_sq < best_dist_sq:\n                best_dist_sq = d_sq\n                best_node = node\n        return best_node\n\n    def _near(self, tree, point, radius):\n        r_sq = radius * radius\n        near_nodes = []\n        for n in tree:\n            d_sq = 0.0\n            for i in range(len(point)):\n                diff = n.position[i] - point[i]\n                d_sq += diff * diff\n                if d_sq > r_sq:\n                    break\n            if d_sq <= r_sq:\n                near_nodes.append(n)\n        return near_nodes\n\n    def _steer(self, from_pos, to_pos, step_size):\n        dist = 0.0\n        diff_vec = []\n        for i in range(len(from_pos)):\n            d = to_pos[i] - from_pos[i]\n            diff_vec.append(d)\n            dist += d * d\n        dist = dist ** 0.5\n        if dist <= step_size:\n            return to_pos\n        ratio = step_size / dist\n        new_pos = tuple(from_pos[i] + ratio * diff_vec[i] for i in range(len(from_pos)))\n        return new_pos\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        import random\n        while True:\n            pt = tuple(random.uniform(0, bounds[i]) for i in range(len(bounds)))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        px = pos[0]\n        py = pos[1]\n        pz = pos[2] if is_3d else 0.0\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        dist = 0.0\n        for i in range(len(from_pos)):\n            diff = to_pos[i] - from_pos[i]\n            dist += diff * diff\n        dist = dist ** 0.5\n        steps = max(1, int(dist / resolution))\n        for step in range(steps + 1):\n            t = step / steps\n            interp = tuple(from_pos[i] + t * (to_pos[i] - from_pos[i]) for i in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _unit_ball_volume(self, dim):\n        import math\n        if dim == 2:\n            return math.pi\n        if dim == 3:\n            return 4.0 / 3.0 * math.pi\n        from math import gamma\n        return (math.pi ** (dim / 2)) / gamma(dim / 2 + 1)\n\n    def _update_subtree_costs(self, node, edges):\n        import math\n        stack = [node]\n        while stack:\n            n = stack.pop()\n            for c in n.children:\n                new_cost = n.cost + math.dist(n.position, c.position)\n                if new_cost + 1e-15 < c.cost:\n                    c.cost = new_cost\n                    stack.append(c)",
          "objective": -28.74503,
          "time_improvement": 35.0,
          "length_improvement": 16.0,
          "smoothness_improvement": 1723.0,
          "node_improvement": 72.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.0299816370010376,
                    "num_nodes_avg": 148.2,
                    "path_length_avg": 167.3939001155781,
                    "smoothness_avg": 0.050243287597786124,
                    "success_improvement": 0.0,
                    "time_improvement": -16.24930089808597,
                    "node_improvement": 62.67942583732058,
                    "length_improvement": 8.248750820561371,
                    "smoothness_improvement": 686.4165559506581,
                    "objective_score": 3.506543002664322
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.024869823455810548,
                    "num_nodes_avg": 213.3,
                    "path_length_avg": 234.52362942815247,
                    "smoothness_avg": 0.11434926003010829,
                    "success_improvement": 0.0,
                    "time_improvement": 84.97978616358722,
                    "node_improvement": 85.66821205402137,
                    "length_improvement": 21.70926210849506,
                    "smoothness_improvement": 2842.288823017571,
                    "objective_score": 52.73093722926106
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.03181536197662353,
                    "num_nodes_avg": 263.6,
                    "path_length_avg": 123.95805243875779,
                    "smoothness_avg": 0.13682429202352978,
                    "success_improvement": 0.0,
                    "time_improvement": 37.30614787659427,
                    "node_improvement": 66.48442466624284,
                    "length_improvement": 17.672963818329237,
                    "smoothness_improvement": 1640.3948952206044,
                    "objective_score": 29.99759713007884
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e2",
          "algorithm_description": "A unified bidirectional RRT* planner leveraging ellipsoidal informed sampling, dynamic neighborhood radius scaling based on node density, and incremental path shortcutting to enhance efficiency, path length, and smoothness. It alternates tree expansions from start and goal states, samples intelligently within a biasing ellipsoid after initial solutions, rewires neighbors using an adaptive radius following theoretical optimal connection distances, and progressively shortcuts the current best path to maintain smoothness. This approach integrates adaptive rewiring radius, efficient collision checking with early exit, and continuous path refinement to robustly reduce planning time and improve path quality.",
          "planning_mechanism": "The planner maintains two rapidly exploring trees from start and goal, alternately extending them toward samples constrained inside an ellipsoidal informed subset after the first solution. It estimates an adaptive near radius based on theoretical RRT* bounds and current node count to optimize local rewiring. After each improved solution, it extracts and incrementally shortcuts the path to remove unnecessary waypoints and smooth turns, thus continuously improving path quality while minimizing overall runtime.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n    def add_child(self, child):\n        self.children.append(child)\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except ValueError:\n            pass\nclass Planner:\n    def __init__(self, max_iter=4500, step_size=6.5, gamma_rrt_star=50.0, shortcut_interval=40, max_shortcut_attempts=40):\n        # max_iter: max number of iterations\n        # step_size: max extension distance per step\n        # gamma_rrt_star: scaling factor for radius: typically > unit ball volume constant\n        # shortcut_interval: iterations frequency to apply path shortcutting\n        # max_shortcut_attempts: max attempts per incremental shortcutting\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.gamma_rrt_star = gamma_rrt_star\n        self.shortcut_interval = shortcut_interval\n        self.max_shortcut_attempts = max_shortcut_attempts\n\n    def plan(self, map):\n        import random\n        import math\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = (len(bounds) == 3)\n        dim = 3 if is_3d else 2\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        best_cost = float('inf')\n        solution_start, solution_goal = None, None\n        c_min = math.dist(start_pos, goal_pos)\n        volume_unit_ball = self._unit_ball_volume(dim)  # used for radius adapt\n\n        def near_radius(n_nodes):\n            # Adaptive near radius per RRT* theory: gamma * (log(n)/n)^{1/d}\n            if n_nodes <= 1:\n                return self.step_size * 2.5  # fallback large radius initially\n            return min(self.step_size * 50,\n                       self.gamma_rrt_star * (math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n\n        def attempt_connection(tree_a, tree_b, sample):\n            # Extend tree_a toward sample, rewire and try connecting with tree_b\n            nearest = self._nearest(tree_a, sample)\n            new_pos = self._steer(nearest.position, sample, self.step_size)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                return None\n\n            new_node = Node(new_pos)\n            radius = near_radius(len(tree_a))\n            near_nodes = self._near(tree_a, new_pos, radius)\n\n            min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n            min_parent = nearest\n            # Select best parent from near nodes with collision-check\n            for near in near_nodes:\n                tentative_cost = near.cost + math.dist(near.position, new_pos)\n                if tentative_cost < min_cost:\n                    if not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d):\n                        min_cost = tentative_cost\n                        min_parent = near\n\n            new_node.parent = min_parent\n            new_node.cost = min_cost\n            min_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((min_parent, new_node))\n\n            # Rewire neighbors to new_node if improves cost and collision-free\n            for near in near_nodes:\n                if near is min_parent:\n                    continue\n                new_cost = new_node.cost + math.dist(new_node.position, near.position)\n                if new_cost < near.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                        # Remove old edge\n                        if near.parent:\n                            try:\n                                edges.remove((near.parent, near))\n                            except ValueError:\n                                pass\n                            near.parent.remove_child(near)\n                        near.parent = new_node\n                        near.cost = new_cost\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n\n            # Attempt to connect new_node with nearest node in tree_b within step size\n            connect_candidate = self._nearest(tree_b, new_node.position)\n            dist_connect = math.dist(new_node.position, connect_candidate.position)\n            if dist_connect <= self.step_size:\n                if not self._is_edge_in_obstacle(new_node.position, connect_candidate.position, obstacles, is_3d):\n                    total_cost = new_node.cost + dist_connect + connect_candidate.cost\n                    if total_cost < best_cost:\n                        return new_node, connect_candidate, total_cost\n            return None\n\n        def informed_sample():\n            # Ellipsoidal informed sampling inside prolate hyperspheroid given current best_cost\n            if best_cost == float('inf') or best_cost <= c_min:\n                return self._sample_free(bounds, obstacles, is_3d)\n            center = tuple((start_pos[i] + goal_pos[i]) / 2 for i in range(dim))\n            dir_vec = [goal_pos[i] - start_pos[i] for i in range(dim)]\n            length = math.dist(start_pos, goal_pos)\n            # Compute rotation matrix R from canonical axis to direction\n            if dim == 2:\n                if length < 1e-10:\n                    R = [[1, 0], [0, 1]]\n                else:\n                    a1 = [1, 0]\n                    a2 = [dir_vec[0] / length, dir_vec[1] / length]\n                    cos_theta = a1[0] * a2[0] + a1[1] * a2[1]\n                    sin_theta = a1[0] * a2[1] - a1[1] * a2[0]\n                    R = [[cos_theta, -sin_theta], [sin_theta, cos_theta]]\n            else:\n                # 3D rotation matrix by axis-angle\n                from math import sqrt\n                if length < 1e-10:\n                    R = [[1,0,0],[0,1,0],[0,0,1]]\n                else:\n                    a1 = [1,0,0]\n                    a2 = [dir_vec[i] / length for i in range(3)]\n                    v = [a1[1]*a2[2]-a1[2]*a2[1], a1[2]*a2[0]-a1[0]*a2[2], a1[0]*a2[1]-a1[1]*a2[0]]\n                    s = sqrt(sum(vi*vi for vi in v))\n                    c = sum(a1[i]*a2[i] for i in range(3))\n                    if s < 1e-10:\n                        R = [[1,0,0],[0,1,0],[0,0,1]]\n                    else:\n                        vx = [[0,-v[2],v[1]],[v[2],0,-v[0]],[-v[1],v[0],0]]\n                        I = [[1 if i==j else 0 for j in range(3)] for i in range(3)]\n                        vx2 = [[sum(vx[i][k]*vx[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n                        R = [[I[i][j] + vx[i][j] + vx2[i][j]*((1 - c)/(s**2)) for j in range(3)] for i in range(3)]\n\n            a1_val = best_cost / 2.0\n            a_other = math.sqrt(best_cost**2 - c_min**2) / 2.0\n            import random\n\n            while True:\n                # Sample unit ball point\n                if dim == 2:\n                    r = random.uniform(0,1)**0.5\n                    theta = random.uniform(0, 2*math.pi)\n                    x_ball = [r*math.cos(theta), r*math.sin(theta)]\n                    L = [[a1_val, 0],[0, a_other]]\n                    x_scaled = [L[0][0]*x_ball[0] + L[0][1]*x_ball[1],\n                                L[1][0]*x_ball[0] + L[1][1]*x_ball[1]]\n                    pt = (center[0] + R[0][0]*x_scaled[0] + R[0][1]*x_scaled[1],\n                          center[1] + R[1][0]*x_scaled[0] + R[1][1]*x_scaled[1])\n                else:\n                    while True:\n                        x_ball = [random.uniform(-1,1) for _ in range(3)]\n                        if sum(xi*xi for xi in x_ball) <= 1:\n                            break\n                    L = [[a1_val, 0, 0],[0, a_other, 0],[0, 0, a_other]]\n                    x_scaled = [L[0][0]*x_ball[0], L[1][1]*x_ball[1], L[2][2]*x_ball[2]]\n                    pt = tuple(center[i] + sum(R[i][j]*x_scaled[j] for j in range(dim)) for i in range(dim))\n\n                # Check bounds and obstacles\n                if any(pt[d] < 0 or pt[d] > bounds[d] for d in range(dim)):\n                    continue\n                if self._is_in_obstacle(pt, obstacles, is_3d):\n                    continue\n                return pt\n\n        # Progressive path shortcutting with limited attempts to improve smoothness incrementally\n        def progressive_shortcut(path):\n            if len(path) < 3:\n                return path[:]\n            import random\n            new_path = path[:]\n            attempts = 0\n            while attempts < self.max_shortcut_attempts:\n                if len(new_path) < 3:\n                    break\n                i = random.randint(0, len(new_path)-3)\n                j = random.randint(i+2, len(new_path)-1)\n                if not self._is_edge_in_obstacle(new_path[i], new_path[j], obstacles, is_3d):\n                    new_path = new_path[:i+1] + new_path[j:]\n                    attempts = 0  # reset on success\n                else:\n                    attempts += 1\n            return new_path\n\n        for iteration in range(self.max_iter):\n            sample = informed_sample() if (best_cost < float('inf')) else self._sample_free(bounds, obstacles, is_3d)\n\n            # Alternate tree expansion\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                result = attempt_connection(tree_a, tree_b, sample)\n                if result is not None:\n                    new_node, connect_node, total_cost = result\n                    if total_cost < best_cost:\n                        best_cost = total_cost\n                        if tree_a is start_tree:\n                            solution_start, solution_goal = new_node, connect_node\n                        else:\n                            solution_start, solution_goal = connect_node, new_node\n\n            # Incremental shortcut every shortcut_interval iterations after finding a solution\n            if best_cost < float('inf') and solution_start and solution_goal:\n                if iteration % self.shortcut_interval == 0 or iteration == self.max_iter - 1:\n                    raw_path = self._extract_path(solution_start, solution_goal)\n                    improved_path = progressive_shortcut(raw_path)\n                    if improved_path and len(improved_path) >= 2:\n                        return PlannerResult(True, improved_path, nodes, edges)\n\n        # No solution found\n        return PlannerResult(False, [], nodes, edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        import random\n        while True:\n            pt = tuple(random.uniform(0, bounds[i]) for i in range(len(bounds)))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def _nearest(self, tree, point):\n        import math\n        best_node = None\n        best_dist = float('inf')\n        for node in tree:\n            d = 0.0\n            for i in range(len(point)):\n                diff = node.position[i] - point[i]\n                d += diff*diff\n            if d < best_dist:\n                best_dist = d\n                best_node = node\n        return best_node\n\n    def _near(self, tree, point, radius):\n        r_sq = radius*radius\n        near_nodes = []\n        for n in tree:\n            d = 0.0\n            for i in range(len(point)):\n                diff = n.position[i] - point[i]\n                d += diff*diff\n            if d <= r_sq:\n                near_nodes.append(n)\n        return near_nodes\n\n    def _steer(self, from_pos, to_pos, step_size):\n        import math\n        dist = 0.0\n        for i in range(len(from_pos)):\n            diff = to_pos[i] - from_pos[i]\n            dist += diff*diff\n        dist = dist**0.5\n        if dist <= step_size:\n            return to_pos\n        ratio = step_size / dist\n        new_pos = tuple(from_pos[i] + ratio * (to_pos[i] - from_pos[i]) for i in range(len(from_pos)))\n        return new_pos\n\n    def _extract_path(self, node_start, node_goal):\n        path_start = []\n        n = node_start\n        while n is not None:\n            path_start.append(n.position)\n            n = n.parent\n        path_goal = []\n        n = node_goal\n        while n is not None:\n            path_goal.append(n.position)\n            n = n.parent\n        return list(reversed(path_start)) + path_goal\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x,y,z,w,h,d = obs\n                px,py,pz = pos\n                if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                    return True\n            else:\n                x,y,w,h = obs\n                px,py = pos\n                if x <= px <= x+w and y <= py <= y+h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        dist = 0.0\n        for i in range(len(from_pos)):\n            diff = to_pos[i] - from_pos[i]\n            dist += diff*diff\n        dist = dist**0.5\n        steps = max(1, int(dist / resolution))\n        for step in range(steps+1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (step / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _unit_ball_volume(self, dim):\n        import math\n        # Volume of unit ball in dimension dim\n        if dim == 2:\n            return math.pi\n        elif dim == 3:\n            return 4.0/3.0 * math.pi\n        else:\n            # General formula using gamma function approximation\n            from math import gamma\n            return (math.pi**(dim/2)) / gamma(dim/2 + 1)",
          "objective": -28.03557,
          "time_improvement": 38.0,
          "length_improvement": 15.0,
          "smoothness_improvement": 1533.0,
          "node_improvement": 72.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.023175954818725586,
                    "num_nodes_avg": 135.3,
                    "path_length_avg": 175.79982556162778,
                    "smoothness_avg": 0.04886810478019664,
                    "success_improvement": 0.0,
                    "time_improvement": 10.13871106406778,
                    "node_improvement": 65.92797783933518,
                    "length_improvement": 3.641329883168963,
                    "smoothness_improvement": 664.8919585980976,
                    "objective_score": 8.550871042112199
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.03271842002868652,
                    "num_nodes_avg": 261.1,
                    "path_length_avg": 229.80246953520958,
                    "smoothness_avg": 0.09634245712495317,
                    "success_improvement": 0.0,
                    "time_improvement": 80.239599766615,
                    "node_improvement": 82.45649398642746,
                    "length_improvement": 23.28532117181223,
                    "smoothness_improvement": 2378.9608144920394,
                    "objective_score": 49.937876705532034
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.03931493759155273,
                    "num_nodes_avg": 263.8,
                    "path_length_avg": 122.75935520727265,
                    "smoothness_avg": 0.13016053434098707,
                    "success_improvement": 0.0,
                    "time_improvement": 22.527837796824144,
                    "node_improvement": 66.45899554990464,
                    "length_improvement": 18.469081443653348,
                    "smoothness_improvement": 1555.6323893660885,
                    "objective_score": 25.617962152069694
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "cross_over",
          "algorithm_description": "A bidirectional RRT* variant with adaptive neighborhood radius, continuous incremental shortcutting, and efficient heuristic-guided rewiring combined with hybrid sampling. The planner integrates adaptive ellipsoidal informed sampling and early collision rejection to minimize path length and runtime. Continuous path smoothing after each successful connection refines solution quality and improves smoothness. Parent-child pruning during rewiring maintains tree consistency, and heuristic-prioritized rewiring focuses optimization on promising regions for faster convergence.",
          "planning_mechanism": "The planner grows two bidirectional trees from start and goal by sampling new points with hybrid uniform and ellipsoidal informed sampling guided by current best cost. New nodes are connected using an adaptive neighborhood radius that shrinks as node density and best cost improve, promoting better rewiring opportunities. Rewiring incorporates heuristic distance to goal and incremental cost propagation ensuring improved path quality. After every successful connection, an incremental shortcutting procedure continuously refines the path by removing unnecessary waypoints using collision and curvature checks, enhancing smoothness and shortening path length. Efficient collision checks with early exit reduce planning time, and adaptive smoothing balances exploration and optimization for rapid convergence and robustness.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n    def add_child(self, child):\n        self.children.append(child)\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\nclass Planner:\n    def __init__(self, max_iter=4000, step_size=5.0, base_radius=25.0,\n                 blend_sample_rate=0.65, max_local_shortcuts=80,\n                 shortcut_interval=10):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.base_radius = base_radius\n        self.blend_sample_rate = blend_sample_rate\n        self.max_local_shortcuts = max_local_shortcuts\n        self.shortcut_interval = shortcut_interval\n\n    def plan(self, map):\n        import random\n        import math\n\n        bounds = map.size\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        def in_bounds(p):\n            return all(0.0 <= p[i] <= bounds[i] for i in range(dim))\n\n        def collision_node(p):\n            px = p[0]\n            py = p[1]\n            pz = p[2] if is_3d else 0.0\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d = obs\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                        return True\n                else:\n                    x,y,w,h = obs\n                    if x <= px <= x+w and y <= py <= y+h:\n                        return True\n            return False\n\n        def collision_edge(a,b,res=0.5):\n            length = math.dist(a,b)\n            if length < 1e-12:\n                return False\n            steps = max(1,int(length/res))\n            for step in range(steps+1):\n                t = step / steps\n                interp = tuple(a[i] + (b[i]-a[i])*t for i in range(dim))\n                if collision_node(interp):\n                    return True\n            return False\n\n        def steer(from_p, to_p):\n            length = math.dist(from_p,to_p)\n            if length <= self.step_size:\n                return to_p\n            ratio = self.step_size / length\n            return tuple(from_p[i] + (to_p[i] - from_p[i]) * ratio for i in range(dim))\n\n        def heuristic_goal(p):  # Euclidean dist to goal\n            return math.dist(p, goal_pos)\n\n        def heuristic_start(p):  # Euclidean dist to start\n            return math.dist(p, start_pos)\n\n        def unit_ball_volume(d):\n            from math import pi, gamma\n            return (pi**(d/2))/(gamma(d/2+1))\n\n        c_min = math.dist(start_pos, goal_pos)\n        volume_unit_ball = unit_ball_volume(dim)\n\n        # Adaptive neighborhood radius based on node count and best cost (shrinks as tree fills and solution improves)\n        def adaptive_radius(n_nodes, best_cost):\n            if n_nodes <= 1:\n                return self.step_size * 6.0\n            val = (math.log(n_nodes)/n_nodes)**(1.0/dim)\n            r = self.base_radius * val\n            if best_cost < float('inf'):\n                r = min(r, best_cost*0.35)\n            return max(r, self.step_size * 1.1)\n\n        # Hybrid sampling combines uniform random and ellipsoidal informed sampling around start and goal\n        def sample_point(best_cost):\n            if best_cost == float('inf') or random.random() > self.blend_sample_rate:\n                # Uniform random with rejection sampling for obstacle\n                for _ in range(30):\n                    pt = tuple(random.uniform(0,bounds[i]) for i in range(dim))\n                    if not collision_node(pt):\n                        return pt\n                # fallback uniform no check\n                return tuple(random.uniform(0,bounds[i]) for i in range(dim))\n\n            center = tuple(0.5*(start_pos[i] + goal_pos[i]) for i in range(dim))\n            d_vec = [goal_pos[i] - start_pos[i] for i in range(dim)]\n            length = math.dist(start_pos, goal_pos)\n            a1_val = best_cost/2.0\n            rad2 = best_cost*best_cost - c_min*c_min\n            try:\n                a_rest = math.sqrt(rad2)/2.0 if rad2 > 0 else 0.0\n            except Exception:\n                a_rest = a1_val\n\n            if dim == 2:\n                if length < 1e-14:\n                    R = [[1,0],[0,1]]\n                else:\n                    norm_d = (d_vec[0]/length, d_vec[1]/length)\n                    c = norm_d[0]\n                    s = norm_d[1]\n                    R = [[c, -s],[s, c]]\n\n                attempts = 0\n                while attempts < 100:\n                    r = random.uniform(0,1)**0.5\n                    theta = random.uniform(0, 2*math.pi)\n                    ball = [r*math.cos(theta), r*math.sin(theta)]\n                    x_scaled = [a1_val*ball[0], a_rest*ball[1]]\n                    pt = (center[0] + R[0][0]*x_scaled[0] + R[0][1]*x_scaled[1],\n                          center[1] + R[1][0]*x_scaled[0] + R[1][1]*x_scaled[1])\n                    if in_bounds(pt) and not collision_node(pt):\n                        return pt\n                    attempts += 1\n                return tuple(random.uniform(0,bounds[i]) for i in range(dim))\n            else:\n                from math import sqrt\n                if length < 1e-14:\n                    R = [[1,0,0],[0,1,0],[0,0,1]]\n                else:\n                    a1 = [1,0,0]\n                    a2 = [d_vec[i]/length for i in range(3)]\n                    v = [a1[1]*a2[2]-a1[2]*a2[1], a1[2]*a2[0]-a1[0]*a2[2], a1[0]*a2[1]-a1[1]*a2[0]]\n                    s = sqrt(sum(x*x for x in v))\n                    c = sum(a1[i]*a2[i] for i in range(3))\n                    if s < 1e-14:\n                        R = [[1,0,0],[0,1,0],[0,0,1]]\n                    else:\n                        vx = [[0,-v[2],v[1]],[v[2],0,-v[0]],[-v[1],v[0],0]]\n                        I = [[1 if i==j else 0 for j in range(3)] for i in range(3)]\n                        vx2 = [[sum(vx[i][k]*vx[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n                        R = [[I[i][j] + vx[i][j] + vx2[i][j]*((1-c)/(s*s)) for j in range(3)] for i in range(3)]\n                attempts = 0\n                while attempts < 100:\n                    while True:\n                        ball = [random.uniform(-1,1) for _ in range(3)]\n                        if sum(x*x for x in ball) <= 1:\n                            break\n                    x_scaled = [a1_val*ball[0], a_rest*ball[1], a_rest*ball[2]]\n                    pt = tuple(center[i] + sum(R[i][j]*x_scaled[j] for j in range(3)) for i in range(3))\n                    if in_bounds(pt) and not collision_node(pt):\n                        return pt\n                    attempts += 1\n                return tuple(random.uniform(0,bounds[i]) for i in range(dim))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: math.dist(node.position, point))\n\n        def near(tree, point, radius):\n            rsq = radius*radius\n            return [node for node in tree if sum((node.position[i]-point[i])**2 for i in range(dim)) <= rsq]\n\n        def cost_with_curvature(parent, child_pos):\n            # Base cost plus curvature penalty for smoothness\n            base_cost = parent.cost + math.dist(parent.position, child_pos)\n            # Curvature penalty via angle between grandparent-parent-child\n            if parent is None or parent.parent is None:\n                return base_cost\n            a = parent.parent.position\n            b = parent.position\n            c = child_pos\n            v1 = [b[i]-a[i] for i in range(dim)]\n            v2 = [c[i]-b[i] for i in range(dim)]\n            len1 = math.sqrt(sum(x*x for x in v1))\n            len2 = math.sqrt(sum(x*x for x in v2))\n            if len1 < 1e-12 or len2 < 1e-12:\n                return base_cost\n            dot = sum(v1[i]*v2[i] for i in range(dim))\n            cos_theta = max(min(dot/(len1*len2),1.0), -1.0)\n            ang = math.acos(cos_theta)\n            # Penalty scaled to angle, tighter penalty here strengthens smoothness\n            penalty = ang*2.0\n            return base_cost + penalty\n\n        def rewire(tree, new_node, near_nodes, best_cost):\n            for neighbor in near_nodes:\n                if neighbor is new_node.parent or neighbor is new_node:\n                    continue\n                new_cost = cost_with_curvature(new_node, neighbor.position)\n                if new_cost + 1e-12 < neighbor.cost:\n                    # Early collision check for edge\n                    if collision_edge(new_node.position, neighbor.position):\n                        continue\n                    # Heuristic-driven rewiring: only if helps towards goal shorter path\n                    if heuristic_goal(neighbor.position) + new_cost >= heuristic_goal(neighbor.position) + neighbor.cost:\n                        continue\n                    # Prune old parent-child link\n                    if neighbor.parent:\n                        neighbor.parent.remove_child(neighbor)\n                    neighbor.parent = new_node\n                    neighbor.cost = new_cost\n                    new_node.add_child(neighbor)\n                    self._propagate_cost_changes(neighbor)\n\n        def propagate_costs(node):\n            # propagate cost changes downstream nodes\n            import math\n            stack = [node]\n            while stack:\n                curr = stack.pop()\n                for c in curr.children:\n                    potential_cost = cost_with_curvature(curr, c.position)\n                    if potential_cost + 1e-12 < c.cost:\n                        c.cost = potential_cost\n                        stack.append(c)\n\n        self._propagate_cost_changes = propagate_costs\n\n        def extract_path(n_from, n_to):\n            # retrieve path from start-tree node to root (start)\n            path_start = []\n            n = n_from\n            while n is not None:\n                path_start.append(n.position)\n                n = n.parent\n            path_start.reverse()\n            # retrieve path from goal-tree node to root (goal)\n            path_goal = []\n            n = n_to\n            while n is not None:\n                path_goal.append(n.position)\n                n = n.parent\n            # concatenate carefully, avoid duplicate point at connection\n            if path_start and path_goal and path_start[-1] == path_goal[0]:\n                return path_start + path_goal[1:]\n            return path_start + path_goal\n\n        def incremental_shortcut(path):\n            # Incremental shortcut removes unnecessary nodes continuously with collision and angle checks\n            if len(path) < 3:\n                return path[:]\n            new_path = path[:]\n            attempts = 0\n            max_attempts = self.max_local_shortcuts\n            while attempts < max_attempts and len(new_path) >= 3:\n                i = random.randint(0, len(new_path)-3)\n                j = random.randint(i+2, len(new_path)-1)\n                if not collision_edge(new_path[i], new_path[j]):\n                    # Check curvature-compatible angle reduction\n                    if i>0 and j<len(new_path)-1:\n                        a, b, c = new_path[i-1], new_path[i], new_path[i+1]\n                        d, e, f = new_path[j-1], new_path[j], new_path[j+1]\n                        def angle(pt1, pt2, pt3):\n                            v1 = [pt1[k]-pt2[k] for k in range(dim)]\n                            v2 = [pt3[k]-pt2[k] for k in range(dim)]\n                            len1 = math.sqrt(sum(x*x for x in v1))\n                            len2 = math.sqrt(sum(x*x for x in v2))\n                            if len1 < 1e-12 or len2 < 1e-12:\n                                return 0.0\n                            dot = sum(v1[k]*v2[k] for k in range(dim))\n                            cos_a = max(min(dot/(len1*len2),1.0),-1.0)\n                            return math.acos(cos_a)\n                        old_angle = angle(a,b,c)\n                        new_angle = angle(a, new_path[j], c)\n                        # Reject sharp angle increase to maintain smoothness\n                        if new_angle > old_angle+0.4:\n                            attempts += 1\n                            continue\n                    del new_path[i+1:j]\n                attempts += 1\n            return new_path\n\n        # Trees and data structures\n        start_tree = [Node(start_pos, parent=None, cost=0.0)]\n        goal_tree = [Node(goal_pos, parent=None, cost=0.0)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        best_cost = float('inf')\n        best_pair = (None, None)\n\n        for it in range(1, self.max_iter+1):\n            sample = sample_point(best_cost)\n            # Alternate tree roles for bidirectional growth\n            if it % 2 == 1:\n                tree_a, tree_b = start_tree, goal_tree\n                heuristic_a, heuristic_b = heuristic_goal, heuristic_start\n            else:\n                tree_a, tree_b = goal_tree, start_tree\n                heuristic_a, heuristic_b = heuristic_start, heuristic_goal\n\n            nearest_node = nearest(tree_a, sample)\n            new_pos = steer(nearest_node.position, sample)\n            if (not in_bounds(new_pos) or\n                collision_node(new_pos) or\n                collision_edge(nearest_node.position, new_pos)):\n                continue\n\n            radius = adaptive_radius(len(tree_a), best_cost)\n            near_nodes = near(tree_a, new_pos, radius)\n            # Prioritize nodes nearer goal for rewiring\n            near_nodes.sort(key=lambda n: heuristic_a(n.position))\n\n            min_cost = cost_with_curvature(nearest_node, new_pos)\n            min_parent = nearest_node\n            for candidate in near_nodes:\n                if candidate is nearest_node:\n                    continue\n                cur_cost = cost_with_curvature(candidate, new_pos)\n                # Prune by cost+heuristic\n                if cur_cost + heuristic_a(new_pos) + 1e-12 >= min_cost + heuristic_a(new_pos):\n                    continue\n                if collision_edge(candidate.position, new_pos):\n                    continue\n                min_cost = cur_cost\n                min_parent = candidate\n\n            new_node = Node(new_pos, parent=min_parent, cost=min_cost)\n            min_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((min_parent,new_node))\n\n            rewire(tree_a, new_node, near_nodes, best_cost)\n\n            # Connect to other tree within step size and free path\n            nearest_other = nearest(tree_b, new_pos)\n            dist_conn = math.dist(new_pos, nearest_other.position)\n            if dist_conn <= self.step_size:\n                if not collision_edge(new_pos, nearest_other.position):\n                    total_cost = new_node.cost + dist_conn + nearest_other.cost\n                    if total_cost + 1e-12 < best_cost:\n                        best_cost = total_cost\n                        best_pair = (new_node, nearest_other) if tree_a is start_tree else (nearest_other, new_node)\n\n            # Continuous incremental shortcutting every shortcut_interval iterations when solution exists\n            if best_cost < float('inf') and it % self.shortcut_interval == 0 and best_pair[0] and best_pair[1]:\n                raw_path = extract_path(best_pair[0], best_pair[1])\n                improved_path = incremental_shortcut(raw_path)\n                if improved_path:\n                    return PlannerResult(True, improved_path, nodes, edges)\n\n        # Final check after max iterations\n        if best_cost < float('inf') and best_pair[0] and best_pair[1]:\n            raw_path = extract_path(best_pair[0], best_pair[1])\n            improved_path = incremental_shortcut(raw_path)\n            return PlannerResult(True, improved_path, nodes, edges)\n        return PlannerResult(False, [], nodes, edges)",
          "objective": -27.69077,
          "time_improvement": 39.0,
          "length_improvement": 15.0,
          "smoothness_improvement": 1341.0,
          "node_improvement": 71.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.020848727226257323,
                    "num_nodes_avg": 123.4,
                    "path_length_avg": 168.3536368145685,
                    "smoothness_avg": 0.032372817225057804,
                    "success_improvement": 0.0,
                    "time_improvement": 19.162187021895182,
                    "node_improvement": 68.92470410475951,
                    "length_improvement": 7.722703927843541,
                    "smoothness_improvement": 406.7048882699285,
                    "objective_score": 12.415802904624321
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.03440771102905273,
                    "num_nodes_avg": 275.6,
                    "path_length_avg": 236.32201036605926,
                    "smoothness_avg": 0.09884469617616079,
                    "success_improvement": 0.0,
                    "time_improvement": 79.21934676391426,
                    "node_improvement": 81.48222804542094,
                    "length_improvement": 21.108910787896583,
                    "smoothness_improvement": 2443.345227569551,
                    "objective_score": 48.647876639759986
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.04077534675598145,
                    "num_nodes_avg": 286.3,
                    "path_length_avg": 124.84117708294514,
                    "smoothness_avg": 0.10002833338269039,
                    "success_improvement": 0.0,
                    "time_improvement": 19.650024359980847,
                    "node_improvement": 63.59821996185633,
                    "length_improvement": 17.08643447953652,
                    "smoothness_improvement": 1172.353017304273,
                    "objective_score": 22.00863308223753
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "An enhanced bidirectional RRT* variant with adaptive neighborhood radius, combined goal-biased and informed sampling, and systematic path shortcutting for improved efficiency, path length, and smoothness. The planner integrates dynamic radius rewiring, heuristic parent selection, and continuous path refinement by shortcutting local segments with collision and smoothness checks. Alternating tree expansions and prioritized rewiring promote rapid convergence and robust collision avoidance in varying dimensions.",
          "planning_mechanism": "The planner grows two trees from start and goal, sampling new points biasing both goal regions and an ellipsoidal informed set based on current best cost. It extends each tree by connecting new nodes selected with curvature-aware parent cost minimization. Adaptive neighborhood radius controls rewiring scope, boosting local optimization. Trees connect when close and collision-free, extracting a joint path that is progressively shortcut while enforcing collision-free and smooth curvature constraints. Continuous shortcutting and rewiring after node insertions refine the path quality and smoothness, leading to shorter and less jerky paths with efficient planning times.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n    def add_child(self, child):\n        self.children.append(child)\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\nclass Planner:\n    def __init__(self, max_iter=4000, step_size=5.0, base_radius=25.0,\n                 goal_bias=0.15, blend_sample_rate=0.6,\n                 shortcut_interval=10, max_shortcuts=100):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.base_radius = base_radius\n        self.goal_bias = goal_bias\n        self.blend_sample_rate = blend_sample_rate\n        self.shortcut_interval = shortcut_interval\n        self.max_shortcuts = max_shortcuts\n\n    def plan(self, map):\n        import random\n        import math\n\n        bounds = map.size\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        def in_bounds(p):\n            return all(0.0 <= p[i] <= bounds[i] for i in range(dim))\n\n        def collision_node(p):\n            px = p[0]\n            py = p[1]\n            pz = p[2] if is_3d else 0.0\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d = obs\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                        return True\n                else:\n                    x,y,w,h = obs\n                    if x <= px <= x+w and y <= py <= y+h:\n                        return True\n            return False\n\n        def collision_edge(a,b,res=0.5):\n            length = math.dist(a,b)\n            if length < 1e-12:\n                return False\n            steps = max(1,int(length/res))\n            for step in range(steps+1):\n                t = step / steps\n                interp = tuple(a[i] + (b[i]-a[i])*t for i in range(dim))\n                if collision_node(interp):\n                    return True\n            return False\n\n        def steer(from_p, to_p):\n            length = math.dist(from_p,to_p)\n            if length <= self.step_size:\n                return to_p\n            ratio = self.step_size / length\n            return tuple(from_p[i] + (to_p[i] - from_p[i]) * ratio for i in range(dim))\n\n        def heuristic_goal(p):\n            return math.dist(p, goal_pos)\n\n        def heuristic_start(p):\n            return math.dist(p, start_pos)\n\n        # Compute unit ball volume in given dimension (for radius calculation)\n        def unit_ball_volume(d):\n            from math import pi, gamma\n            return (pi**(d/2)) / gamma(d/2+1)\n\n        c_min = math.dist(start_pos, goal_pos)\n        vol_unit = unit_ball_volume(dim)\n\n        def adaptive_radius(n_nodes, best_cost):\n            if n_nodes <= 1:\n                return self.step_size * 6.0\n            val = (math.log(n_nodes)/n_nodes)**(1.0/dim)\n            r = self.base_radius * val\n            if best_cost < float('inf'):\n                r = min(r, best_cost*0.4)\n            return max(r, self.step_size*1.1)\n\n        # Hybrid sampler: goal bias, ellipsoidal informed sampling, and uniform random\n        def sample_point(best_cost):\n            # Goal bias: sample goal with certain probability\n            if random.random() < self.goal_bias:\n                return goal_pos\n            # If no solution yet or outside blend, uniform sample with rejection\n            if best_cost == float('inf') or random.random() > self.blend_sample_rate:\n                for _ in range(30):\n                    pt = tuple(random.uniform(0,bounds[i]) for i in range(dim))\n                    if not collision_node(pt):\n                        return pt\n                return tuple(random.uniform(0,bounds[i]) for i in range(dim))\n            # Ellipsoidal informed sampling within prolate hyperspheroid between start and goal\n            center = tuple(0.5*(start_pos[i] + goal_pos[i]) for i in range(dim))\n            d_vec = [goal_pos[i] - start_pos[i] for i in range(dim)]\n            length = c_min\n            c_best = best_cost\n            a1_val = c_best/2.0\n            rad2 = c_best*c_best - c_min*c_min\n            a_rest = math.sqrt(rad2)/2.0 if rad2 > 0 else 0.0\n\n            # Rotation matrix aligning x-axis and line from start to goal\n            if dim == 2:\n                if length < 1e-14:\n                    R = [[1,0],[0,1]]\n                else:\n                    nd = (d_vec[0]/length, d_vec[1]/length)\n                    c, s = nd\n                    R = [[c, -s],[s, c]]\n                for _ in range(100):\n                    r = random.uniform(0,1)**0.5\n                    theta = random.uniform(0, 2*math.pi)\n                    ball = [r*math.cos(theta), r*math.sin(theta)]\n                    x_scaled = [a1_val*ball[0], a_rest*ball[1]]\n                    pt = (center[0] + R[0][0]*x_scaled[0] + R[0][1]*x_scaled[1],\n                          center[1] + R[1][0]*x_scaled[0] + R[1][1]*x_scaled[1])\n                    if in_bounds(pt) and not collision_node(pt):\n                        return pt\n                return tuple(random.uniform(0,bounds[i]) for i in range(dim))\n            else:\n                from math import sqrt\n                if length < 1e-14:\n                    R = [[1,0,0],[0,1,0],[0,0,1]]\n                else:\n                    a1 = [1,0,0]\n                    a2 = [d_vec[i]/length for i in range(3)]\n                    v = [a1[1]*a2[2]-a1[2]*a2[1], a1[2]*a2[0]-a1[0]*a2[2], a1[0]*a2[1]-a1[1]*a2[0]]\n                    s = sqrt(sum(x*x for x in v))\n                    c = sum(a1[i]*a2[i] for i in range(3))\n                    if s < 1e-14:\n                        R = [[1,0,0],[0,1,0],[0,0,1]]\n                    else:\n                        vx = [[0,-v[2],v[1]], [v[2],0,-v[0]], [-v[1],v[0],0]]\n                        I = [[1 if i==j else 0 for j in range(3)] for i in range(3)]\n                        vx2 = [[sum(vx[i][k]*vx[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n                        R = [[I[i][j] + vx[i][j] + vx2[i][j]*((1-c)/(s*s)) for j in range(3)] for i in range(3)]\n                for _ in range(100):\n                    while True:\n                        ball = [random.uniform(-1,1) for _ in range(3)]\n                        if sum(x*x for x in ball) <= 1:\n                            break\n                    x_scaled = [a1_val*ball[0], a_rest*ball[1], a_rest*ball[2]]\n                    pt = tuple(center[i] + sum(R[i][j]*x_scaled[j] for j in range(3)) for i in range(3))\n                    if in_bounds(pt) and not collision_node(pt):\n                        return pt\n                return tuple(random.uniform(0,bounds[i]) for i in range(dim))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: math.dist(node.position, point))\n\n        def near(tree, point, radius):\n            rsq = radius*radius\n            return [node for node in tree if sum((node.position[i]-point[i])**2 for i in range(dim)) <= rsq]\n\n        def cost_with_curvature(parent, child_pos):\n            base_cost = parent.cost + math.dist(parent.position, child_pos)\n            if parent is None or parent.parent is None:\n                return base_cost\n            a = parent.parent.position\n            b = parent.position\n            c = child_pos\n            v1 = [b[i]-a[i] for i in range(dim)]\n            v2 = [c[i]-b[i] for i in range(dim)]\n            len1 = math.sqrt(sum(x*x for x in v1))\n            len2 = math.sqrt(sum(x*x for x in v2))\n            if len1 < 1e-12 or len2 < 1e-12:\n                return base_cost\n            dot = sum(v1[i]*v2[i] for i in range(dim))\n            cos_theta = max(min(dot/(len1*len2),1.0), -1.0)\n            angle = math.acos(cos_theta)\n            penalty = angle*2.0\n            return base_cost + penalty\n\n        def rewire(tree, new_node, near_nodes, best_cost):\n            for neighbor in near_nodes:\n                if neighbor is new_node.parent or neighbor is new_node:\n                    continue\n                new_cost = cost_with_curvature(new_node, neighbor.position)\n                if new_cost + 1e-12 < neighbor.cost:\n                    if collision_edge(new_node.position, neighbor.position):\n                        continue\n                    if new_cost + heuristic_goal(neighbor.position) >= neighbor.cost + heuristic_goal(neighbor.position):\n                        continue\n                    if neighbor.parent:\n                        neighbor.parent.remove_child(neighbor)\n                    neighbor.parent = new_node\n                    neighbor.cost = new_cost\n                    new_node.add_child(neighbor)\n                    self._propagate_cost_changes(neighbor)\n\n        def propagate_costs(node):\n            stack = [node]\n            while stack:\n                curr = stack.pop()\n                for c in curr.children:\n                    potential_cost = cost_with_curvature(curr, c.position)\n                    if potential_cost + 1e-12 < c.cost:\n                        c.cost = potential_cost\n                        stack.append(c)\n\n        self._propagate_cost_changes = propagate_costs\n\n        def extract_path(n_from, n_to):\n            path_start = []\n            n = n_from\n            while n is not None:\n                path_start.append(n.position)\n                n = n.parent\n            path_start.reverse()\n            path_goal = []\n            n = n_to\n            while n is not None:\n                path_goal.append(n.position)\n                n = n.parent\n            if path_start and path_goal and path_start[-1] == path_goal[0]:\n                return path_start + path_goal[1:]\n            return path_start + path_goal\n\n        def incremental_shortcut(path):\n            if len(path) < 3:\n                return path[:]\n            new_path = path[:]\n            attempts = 0\n            max_attempts = self.max_shortcuts\n            while attempts < max_attempts and len(new_path) >= 3:\n                i = random.randint(0, len(new_path)-3)\n                j = random.randint(i+2, len(new_path)-1)\n                if not collision_edge(new_path[i], new_path[j]):\n                    # Curvature check to avoid sharp turns\n                    if i>0 and j<len(new_path)-1:\n                        a, b, c = new_path[i-1], new_path[i], new_path[i+1]\n                        def angle(pt1, pt2, pt3):\n                            v1 = [pt1[k]-pt2[k] for k in range(dim)]\n                            v2 = [pt3[k]-pt2[k] for k in range(dim)]\n                            len1 = math.sqrt(sum(x*x for x in v1))\n                            len2 = math.sqrt(sum(x*x for x in v2))\n                            if len1 < 1e-12 or len2 < 1e-12:\n                                return 0.0\n                            dot = sum(v1[k]*v2[k] for k in range(dim))\n                            cos_a = max(min(dot/(len1*len2),1.0),-1.0)\n                            return math.acos(cos_a)\n                        old_angle = angle(a,b,c)\n                        new_angle = angle(a,new_path[j],c)\n                        if new_angle > old_angle+0.35:\n                            attempts += 1\n                            continue\n                    del new_path[i+1:j]\n                attempts += 1\n            return new_path\n\n        start_tree = [Node(start_pos, parent=None, cost=0.0)]\n        goal_tree = [Node(goal_pos, parent=None, cost=0.0)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        best_cost = float('inf')\n        best_pair = (None, None)\n\n        for it in range(1, self.max_iter+1):\n            sample = sample_point(best_cost)\n            # Alternating tree roles for bidirectional growth\n            if it % 2 == 1:\n                tree_a, tree_b = start_tree, goal_tree\n                heuristic_a, heuristic_b = heuristic_goal, heuristic_start\n            else:\n                tree_a, tree_b = goal_tree, start_tree\n                heuristic_a, heuristic_b = heuristic_start, heuristic_goal\n\n            nearest_node = nearest(tree_a, sample)\n            new_pos = steer(nearest_node.position, sample)\n            if (not in_bounds(new_pos) or\n                collision_node(new_pos) or\n                collision_edge(nearest_node.position, new_pos)):\n                continue\n\n            radius = adaptive_radius(len(tree_a), best_cost)\n            near_nodes = near(tree_a, new_pos, radius)\n            near_nodes.sort(key=lambda n: heuristic_a(n.position))\n\n            min_cost = cost_with_curvature(nearest_node, new_pos)\n            min_parent = nearest_node\n            for candidate in near_nodes:\n                if candidate is nearest_node:\n                    continue\n                cand_cost = cost_with_curvature(candidate, new_pos)\n                if cand_cost + heuristic_a(new_pos) + 1e-12 >= min_cost + heuristic_a(new_pos):\n                    continue\n                if collision_edge(candidate.position, new_pos):\n                    continue\n                min_cost = cand_cost\n                min_parent = candidate\n\n            new_node = Node(new_pos, parent=min_parent, cost=min_cost)\n            min_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((min_parent, new_node))\n\n            rewire(tree_a, new_node, near_nodes, best_cost)\n\n            nearest_other = nearest(tree_b, new_pos)\n            dist_conn = math.dist(new_pos, nearest_other.position)\n            if dist_conn <= self.step_size:\n                if not collision_edge(new_pos, nearest_other.position):\n                    total_cost = new_node.cost + dist_conn + nearest_other.cost\n                    if total_cost + 1e-12 < best_cost:\n                        best_cost = total_cost\n                        best_pair = (new_node, nearest_other) if tree_a is start_tree else (nearest_other, new_node)\n\n            if best_cost < float('inf') and it % self.shortcut_interval == 0 and best_pair[0] and best_pair[1]:\n                raw_path = extract_path(best_pair[0], best_pair[1])\n                improved_path = incremental_shortcut(raw_path)\n                if improved_path:\n                    return PlannerResult(True, improved_path, nodes, edges)\n\n        if best_cost < float('inf') and best_pair[0] and best_pair[1]:\n            raw_path = extract_path(best_pair[0], best_pair[1])\n            improved_path = incremental_shortcut(raw_path)\n            return PlannerResult(True, improved_path, nodes, edges)\n        return PlannerResult(False, [], nodes, edges)",
          "objective": -27.24372,
          "time_improvement": 36.0,
          "length_improvement": 16.0,
          "smoothness_improvement": 1415.0,
          "node_improvement": 70.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.02308974266052246,
                    "num_nodes_avg": 138.5,
                    "path_length_avg": 163.88420913927126,
                    "smoothness_avg": 0.03816333391974912,
                    "success_improvement": 0.0,
                    "time_improvement": 10.472985777609331,
                    "node_improvement": 65.12213548224629,
                    "length_improvement": 10.172468059287613,
                    "smoothness_improvement": 497.33904885010884,
                    "objective_score": 11.732071813105911
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.05080997943878174,
                    "num_nodes_avg": 325.6,
                    "path_length_avg": 236.88245919899236,
                    "smoothness_avg": 0.09849092267508912,
                    "success_improvement": 0.0,
                    "time_improvement": 69.31314138396382,
                    "node_improvement": 78.12269031781226,
                    "length_improvement": 20.9218168358383,
                    "smoothness_improvement": 2434.2423805742237,
                    "objective_score": 45.518244419563246
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.036166810989379884,
                    "num_nodes_avg": 270.7,
                    "path_length_avg": 127.2625482812601,
                    "smoothness_avg": 0.11123425835090277,
                    "success_improvement": 0.0,
                    "time_improvement": 28.731387635653615,
                    "node_improvement": 65.58169103623649,
                    "length_improvement": 15.478275022921808,
                    "smoothness_improvement": 1314.891555764593,
                    "objective_score": 24.480839083272134
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m1",
          "algorithm_description": "A bidirectional RRT* planner with dynamic adaptive sampling radius, momentum-based tree extension, and batch rewiring to efficiently converge to high-quality solutions. The algorithm uses ellipsoidal informed sampling shrinking with the best path cost and adapts the rewiring radius scaling with tree density to balance exploration and local optimization. Momentum steering moves nodes further along promising directions to accelerate convergence. Batch rewiring is performed less frequently but covers a broader neighborhood for better path refinement. Incremental shortcutting runs immediately after improvements to incrementally shorten and smooth the path, enhancing path length and smoothness while reducing search time.",
          "planning_mechanism": "The planner grows two trees from start and goal, sampling within a shrinking ellipsoidal informed subset after the first found path. Each iteration attempts to extend in momentum-driven directions to improve progress speed. It adaptively chooses parent nodes and rewires a dynamically scaled neighborhood to optimize cost. Batch rewiring periodically repairs the trees globally. Paths are incrementally shortcut as soon as better solutions are found for continuous quality improvement.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n    def add_child(self, child):\n        self.children.append(child)\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except ValueError:\n            pass\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=7.0, gamma_adapt=45.0, batch_rewire_freq=50, max_shortcut_attempts=35):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.gamma_adapt = gamma_adapt\n        self.batch_rewire_freq = batch_rewire_freq\n        self.max_shortcut_attempts = max_shortcut_attempts\n\n    def plan(self, map):\n        import random\n        import math\n\n        bounds = map.size\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        obstacles = map.obstacles\n        start_pos = map.start\n        goal_pos = map.goal\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        best_cost = float('inf')\n        sol_start = None\n        sol_goal = None\n        c_min = math.dist(start_pos, goal_pos)\n        vol_unit_ball = self._unit_ball_volume(dim)\n\n        def radius(num_nodes):\n            if num_nodes <= 1:\n                return self.step_size * 3.2\n            val = self.gamma_adapt * ((math.log(num_nodes) / num_nodes) ** (1.0 / dim))\n            return min(val, self.step_size * 45.0)\n\n        def sample_ellipsoidal():\n            if best_cost == float('inf') or best_cost <= c_min:\n                return self._sample_free(bounds, obstacles, is_3d)\n            center = tuple((start_pos[i] + goal_pos[i]) * 0.5 for i in range(dim))\n            direction = [goal_pos[i] - start_pos[i] for i in range(dim)]\n            length = math.dist(start_pos, goal_pos)\n            if dim == 2:\n                if length < 1e-12:\n                    R = [[1, 0], [0, 1]]\n                else:\n                    a1 = [1, 0]\n                    a2 = [direction[0] / length, direction[1] / length]\n                    cos_t = a1[0]*a2[0] + a1[1]*a2[1]\n                    sin_t = a1[0]*a2[1] - a1[1]*a2[0]\n                    R = [[cos_t, -sin_t], [sin_t, cos_t]]\n            else:\n                from math import sqrt\n                if length < 1e-12:\n                    R = [[1,0,0],[0,1,0],[0,0,1]]\n                else:\n                    a1 = [1,0,0]\n                    a2 = [d/length for d in direction]\n                    v = [a1[1]*a2[2]-a1[2]*a2[1], a1[2]*a2[0]-a1[0]*a2[2], a1[0]*a2[1]-a1[1]*a2[0]]\n                    s = sqrt(sum(vi*vi for vi in v))\n                    c = sum(a1[i]*a2[i] for i in range(3))\n                    if s < 1e-12:\n                        R = [[1,0,0],[0,1,0],[0,0,1]]\n                    else:\n                        vx = [[0, -v[2], v[1]], [v[2], 0, -v[0]], [-v[1], v[0], 0]]\n                        I = [[1 if i==j else 0 for j in range(3)] for i in range(3)]\n                        vx2 = [[sum(vx[i][k]*vx[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n                        R = [[I[i][j]+vx[i][j]+vx2[i][j]*((1-c)/(s*s)) for j in range(3)] for i in range(3)]\n            a1_val = best_cost * 0.5\n            a_other = math.sqrt(max(best_cost*best_cost - c_min*c_min,0)) * 0.5\n            while True:\n                if dim == 2:\n                    r = random.uniform(0,1) ** 0.5\n                    theta = random.uniform(0, 2*math.pi)\n                    x_ball = [r*math.cos(theta), r*math.sin(theta)]\n                    L = [[a1_val, 0], [0, a_other]]\n                    x_scaled = [L[0][0]*x_ball[0]+L[0][1]*x_ball[1], L[1][0]*x_ball[0]+L[1][1]*x_ball[1]]\n                    pt = (center[0] + R[0][0]*x_scaled[0] + R[0][1]*x_scaled[1],\n                          center[1] + R[1][0]*x_scaled[0] + R[1][1]*x_scaled[1])\n                else:\n                    while True:\n                        x_ball = [random.uniform(-1,1) for _ in range(3)]\n                        if sum(xi*xi for xi in x_ball) <= 1:\n                            break\n                    L = [[a1_val,0,0], [0,a_other,0], [0,0,a_other]]\n                    x_scaled = [L[0][0]*x_ball[0], L[1][1]*x_ball[1], L[2][2]*x_ball[2]]\n                    pt = tuple(center[i] + sum(R[i][j]*x_scaled[j] for j in range(dim)) for i in range(dim))\n                if any(pt[d]<0 or pt[d]>bounds[d] for d in range(dim)):\n                    continue\n                if self._is_in_obstacle(pt, obstacles, is_3d):\n                    continue\n                return pt\n\n        def steer_momentum(from_pos, to_pos, momentum):\n            dist = math.dist(from_pos, to_pos)\n            if dist < 1e-12:\n                return from_pos\n            direction = tuple((to_pos[i]-from_pos[i])/dist for i in range(dim))\n            step = min(self.step_size, dist)\n            base_new = tuple(from_pos[i]+direction[i]*step for i in range(dim))\n            # Apply momentum to push further if within map bounds and free\n            momentum_step = 0.6 * self.step_size\n            candidate = tuple(base_new[i] + direction[i]*momentum_step for i in range(dim))\n            if all(0.0 <= candidate[i] <= bounds[i] for i in range(dim)):\n                return candidate\n            return base_new\n\n        def rewire_batch(tree):\n            n_nodes = len(tree)\n            if n_nodes <= 1:\n                return\n            r = radius(n_nodes) * 1.15  # slightly larger radius for batch rewiring\n            for n in tree:\n                near_nodes = self._near(tree, n.position, r)\n                for near in near_nodes:\n                    if near is n or n.parent is None:\n                        continue\n                    tentative_cost = n.cost + math.dist(n.position, near.position)\n                    if tentative_cost + 1e-9 < near.cost:\n                        if not self._is_edge_in_obstacle(n.position, near.position, obstacles, is_3d):\n                            # Rewire near node to n\n                            if near.parent:\n                                try:\n                                    edges.remove((near.parent, near))\n                                except ValueError:\n                                    pass\n                                near.parent.remove_child(near)\n                            near.parent = n\n                            near.cost = tentative_cost\n                            n.add_child(near)\n                            edges.append((n, near))\n\n        def attempt_extend(tree_from, tree_to, sample, prev_dir):\n            nearest = self._nearest(tree_from, sample)\n            if prev_dir is None:\n                new_pos = self._steer(nearest.position, sample, self.step_size)\n            else:\n                new_pos = steer_momentum(nearest.position, sample, prev_dir)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None, None\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                return None, None\n\n            new_node = Node(new_pos)\n            rn = radius(len(tree_from))\n            near_nodes = self._near(tree_from, new_pos, rn)\n\n            min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n            min_parent = nearest\n            for near in near_nodes:\n                tentative_cost = near.cost + math.dist(near.position, new_pos)\n                if tentative_cost + 1e-9 < min_cost:\n                    if not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d):\n                        min_cost = tentative_cost\n                        min_parent = near\n\n            new_node.parent = min_parent\n            new_node.cost = min_cost\n            min_parent.add_child(new_node)\n            tree_from.append(new_node)\n            nodes.append(new_node)\n            edges.append((min_parent, new_node))\n\n            for near in near_nodes:\n                if near is min_parent:\n                    continue\n                new_cost = new_node.cost + math.dist(new_node.position, near.position)\n                if new_cost + 1e-9 < near.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                        if near.parent:\n                            try:\n                                edges.remove((near.parent, near))\n                            except ValueError:\n                                pass\n                            near.parent.remove_child(near)\n                        near.parent = new_node\n                        near.cost = new_cost\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n\n            nearest_other = self._nearest(tree_to, new_node.position)\n            d_connect = math.dist(new_node.position, nearest_other.position)\n            if d_connect <= self.step_size:\n                if not self._is_edge_in_obstacle(new_node.position, nearest_other.position, obstacles, is_3d):\n                    total_cost = new_node.cost + d_connect + nearest_other.cost\n                    return (new_node, nearest_other, total_cost, \n                            tuple((new_node.position[i] - nearest_other.position[i]) for i in range(dim)))\n            return None, None, None, None\n\n        def incremental_shortcut(path):\n            if len(path) < 3:\n                return path[:]\n            import random\n            pth = path[:]\n            attempts = 0\n            while attempts < self.max_shortcut_attempts:\n                if len(pth) < 3:\n                    break\n                i = random.randint(0, len(pth) - 3)\n                j = random.randint(i + 2, len(pth) - 1)\n                if not self._is_edge_in_obstacle(pth[i], pth[j], obstacles, is_3d):\n                    pth = pth[:i+1] + pth[j:]\n                    attempts = 0\n                else:\n                    attempts += 1\n            return pth\n\n        prev_direction = None\n        for it in range(self.max_iter):\n            sample = sample_ellipsoidal()\n\n            for treeA, treeB in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                res = attempt_extend(treeA, treeB, sample, prev_direction)\n                if res[0] is not None:\n                    new_node, connect_node, c_cost, direction_vec = res\n                    if c_cost + 1e-9 < best_cost:\n                        best_cost = c_cost\n                        prev_direction = direction_vec\n                        if treeA is start_tree:\n                            sol_start, sol_goal = new_node, connect_node\n                        else:\n                            sol_start, sol_goal = connect_node, new_node\n                        # Incremental shortcut immediately on improvement\n                        raw_path = self._extract_path(sol_start, sol_goal)\n                        improved_path = incremental_shortcut(raw_path)\n                        if improved_path and len(improved_path) >= 2:\n                            # Batch rewiring occasionally for global improvement\n                            if it % self.batch_rewire_freq == 0:\n                                rewire_batch(start_tree)\n                                rewire_batch(goal_tree)\n                            return PlannerResult(True, improved_path, nodes, edges)\n\n            # Occasionally batch rewire for global tree quality\n            if it > 0 and it % self.batch_rewire_freq == 0:\n                rewire_batch(start_tree)\n                rewire_batch(goal_tree)\n\n        return PlannerResult(False, [], nodes, edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        import random\n        while True:\n            pt = tuple(random.uniform(0, bounds[i]) for i in range(len(bounds)))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def _nearest(self, tree, point):\n        best_node = None\n        best_dist = float('inf')\n        for node in tree:\n            d = 0.0\n            for i in range(len(point)):\n                diff = node.position[i] - point[i]\n                d += diff * diff\n            if d < best_dist:\n                best_dist = d\n                best_node = node\n        return best_node\n\n    def _near(self, tree, point, radius):\n        r_sq = radius * radius\n        near_nodes = []\n        for n in tree:\n            d = 0.0\n            for i in range(len(point)):\n                diff = n.position[i] - point[i]\n                d += diff * diff\n            if d <= r_sq:\n                near_nodes.append(n)\n        return near_nodes\n\n    def _steer(self, from_pos, to_pos, step_size):\n        import math\n        dist = 0.0\n        for i in range(len(from_pos)):\n            diff = to_pos[i] - from_pos[i]\n            dist += diff * diff\n        dist = dist ** 0.5\n        if dist <= step_size:\n            return to_pos\n        ratio = step_size / dist\n        new_pos = tuple(from_pos[i] + ratio * (to_pos[i] - from_pos[i]) for i in range(len(from_pos)))\n        return new_pos\n\n    def _extract_path(self, node_start, node_goal):\n        path_start = []\n        cur = node_start\n        while cur is not None:\n            path_start.append(cur.position)\n            cur = cur.parent\n        path_goal = []\n        cur = node_goal\n        while cur is not None:\n            path_goal.append(cur.position)\n            cur = cur.parent\n        return list(reversed(path_start)) + path_goal\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        dist = 0.0\n        for i in range(len(from_pos)):\n            diff = to_pos[i] - from_pos[i]\n            dist += diff * diff\n        dist = dist ** 0.5\n        steps = max(1, int(dist / resolution))\n        for step in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (step / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _unit_ball_volume(self, dim):\n        import math\n        if dim == 2:\n            return math.pi\n        if dim == 3:\n            return 4.0 / 3.0 * math.pi\n        from math import gamma\n        return (math.pi ** (dim / 2)) / gamma(dim / 2 + 1)",
          "objective": -27.13468,
          "time_improvement": 34.0,
          "length_improvement": 17.0,
          "smoothness_improvement": 1399.0,
          "node_improvement": 79.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.016662406921386718,
                    "num_nodes_avg": 89.6,
                    "path_length_avg": 161.76013706572985,
                    "smoothness_avg": 0.04759929459666155,
                    "success_improvement": 0.0,
                    "time_improvement": 35.394016149831984,
                    "node_improvement": 77.43641400151094,
                    "length_improvement": 11.336705620871545,
                    "smoothness_improvement": 645.0323239603604,
                    "objective_score": 20.645389837274323
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.0229341983795166,
                    "num_nodes_avg": 171.2,
                    "path_length_avg": 235.63681484522058,
                    "smoothness_avg": 0.09687544838552706,
                    "success_improvement": 0.0,
                    "time_improvement": 86.14881346306589,
                    "node_improvement": 88.49694282066787,
                    "length_improvement": 21.33764877501207,
                    "smoothness_improvement": 2392.675063524693,
                    "objective_score": 50.610608621550476
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.06088290214538574,
                    "num_nodes_avg": 231.3,
                    "path_length_avg": 124.62617397516483,
                    "smoothness_avg": 0.09909509135315861,
                    "success_improvement": 0.0,
                    "time_improvement": -19.972976160105908,
                    "node_improvement": 70.59122695486333,
                    "length_improvement": 17.2292293063764,
                    "smoothness_improvement": 1160.4822475733902,
                    "objective_score": 10.14805597366102
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "This algorithm implements an adaptive bidirectional RRT* planner with goal bias and progressive shortcutting for improved path quality, smoothness, and planning efficiency. It alternately expands two trees from start and goal, dynamically adjusts rewiring radius based on tree size, leverages goal bias sampling to focus exploration, and employs repeated path shortcutting to smooth and shorten the resulting path before returning it. This balanced approach enhances convergence speed, reduces path length, and significantly improves smoothness while maintaining collision-free guarantees.",
          "planning_mechanism": "The planner grows two trees from start and goal positions using an RRT* framework with adaptive radius rewiring for local optimality. It samples random points with goal bias, extends each tree towards samples, rewires to reduce path cost, and attempts to connect the trees when close. Upon connecting, it extracts the combined path and performs multiple shortcutting passes to smooth the path before outputting the result.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.children.remove(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=4.0, goal_sample_rate=0.1, gamma=30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.gamma = gamma  # tuning parameter for adaptive radius\n\n    def plan(self, map):\n        import math\n        import random\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = dim == 3\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    px, py = pos\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def edge_in_obstacle(p1, p2, resolution=1.0):\n            d = dist(p1, p2)\n            steps = max(1, int(d / resolution))\n            for i in range(steps + 1):\n                interp = tuple(p1[j] + (p2[j] - p1[j]) * i / steps for j in range(dim))\n                if in_obstacle(interp):\n                    return True\n            return False\n\n        def steer(from_p, to_p, max_step):\n            d = dist(from_p, to_p)\n            if d <= max_step:\n                return to_p\n            ratio = max_step / d\n            return tuple(from_p[i] + (to_p[i] - from_p[i]) * ratio for i in range(dim))\n\n        def get_nearest(tree, point):\n            return min(tree, key=lambda node: dist(node.position, point))\n\n        def get_near_nodes(tree, new_pos, radius):\n            return [node for node in tree if dist(node.position, new_pos) <= radius]\n\n        def adaptive_radius(n):\n            # Based on RRT* radius scaling law\n            if n == 0:\n                return self.step_size * 2\n            return min(self.gamma * (math.log(n) / n) ** (1 / dim), self.step_size * 20)\n\n        def rewire(tree, nodes, edges, new_node, near_nodes):\n            for near_node in near_nodes:\n                if near_node is new_node.parent:\n                    continue\n                cost_through_new = new_node.cost + dist(new_node.position, near_node.position)\n                if cost_through_new + 1e-7 < near_node.cost:\n                    if not edge_in_obstacle(new_node.position, near_node.position):\n                        if (near_node.parent, near_node) in edges:\n                            edges.remove((near_node.parent, near_node))\n                        near_node.update_parent(new_node, cost_through_new)\n                        edges.append((new_node, near_node))\n\n        nodes_start = [Node(start_pos)]\n        nodes_goal = [Node(goal_pos)]\n        edges = []\n        forward_tree = nodes_start\n        backward_tree = nodes_goal\n        success = False\n        connect_node_start = None\n        connect_node_goal = None\n\n        for it in range(self.max_iter):\n            # Alternate growing trees\n            for grow_start_tree_first in (True, False):\n                if grow_start_tree_first:\n                    tree_a, tree_b = forward_tree, backward_tree\n                else:\n                    tree_a, tree_b = backward_tree, forward_tree\n\n                # Sample with goal bias toward other tree's root\n                if random.random() < self.goal_sample_rate:\n                    sample = tree_b[0].position\n                else:\n                    sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if in_obstacle(sample):\n                    continue\n\n                nearest = get_nearest(tree_a, sample)\n                new_pos = steer(nearest.position, sample, self.step_size)\n                if in_obstacle(new_pos) or edge_in_obstacle(nearest.position, new_pos):\n                    continue\n\n                # Adaptive radius dependent on current tree size\n                radius = adaptive_radius(len(tree_a) + 1)\n                near_nodes = get_near_nodes(tree_a, new_pos, radius)\n\n                # Choose best parent among near nodes\n                min_cost = nearest.cost + dist(nearest.position, new_pos)\n                best_parent = nearest\n                for near in near_nodes:\n                    if not edge_in_obstacle(near.position, new_pos):\n                        cost_candidate = near.cost + dist(near.position, new_pos)\n                        if cost_candidate < min_cost:\n                            min_cost = cost_candidate\n                            best_parent = near\n\n                new_node = Node(new_pos)\n                new_node.parent = best_parent\n                new_node.cost = min_cost\n                best_parent.add_child(new_node)\n                tree_a.append(new_node)\n                edges.append((best_parent, new_node))\n\n                # Rewire near nodes to new node if cost improves and collision free\n                rewire(tree_a, tree_a, edges, new_node, near_nodes)\n\n                # Try to connect trees\n                nearest_in_other = get_nearest(tree_b, new_node.position)\n                if dist(new_node.position, nearest_in_other.position) <= self.step_size:\n                    if not edge_in_obstacle(new_node.position, nearest_in_other.position):\n                        # Connect trees\n                        connect_node_start = new_node if grow_start_tree_first else nearest_in_other\n                        connect_node_goal = nearest_in_other if grow_start_tree_first else new_node\n                        success = True\n                        break\n            if success:\n                break\n\n        def extract_path(node_start, node_goal):\n            path_start = []\n            cur = node_start\n            while cur:\n                path_start.append(cur.position)\n                cur = cur.parent\n            path_goal = []\n            cur = node_goal\n            while cur:\n                path_goal.append(cur.position)\n                cur = cur.parent\n            return path_start[::-1] + path_goal\n\n        def shortcut_path(path, max_attempts=100):\n            if len(path) < 3:\n                return path\n            for _ in range(max_attempts):\n                if len(path) <= 2:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if not edge_in_obstacle(p1, p2):\n                    # Remove intermediate points between i and j\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        nodes_all = nodes_start + nodes_goal\n        if success:\n            raw_path = extract_path(connect_node_start, connect_node_goal)\n            smoothed_path = shortcut_path(raw_path, max_attempts=200)\n            return PlannerResult(True, smoothed_path, nodes_all, edges)\n        else:\n            return PlannerResult(False, [], nodes_all, edges)",
          "objective": -26.77328,
          "time_improvement": 30.0,
          "length_improvement": 17.0,
          "smoothness_improvement": 1515.0,
          "node_improvement": 64.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.026349878311157225,
                    "num_nodes_avg": 131.5,
                    "path_length_avg": 161.50533767083496,
                    "smoothness_avg": 0.04633540991002978,
                    "success_improvement": 0.0,
                    "time_improvement": -2.1677012604634127,
                    "node_improvement": 66.88491563837825,
                    "length_improvement": 11.476365206768222,
                    "smoothness_improvement": 625.2497840450478,
                    "objective_score": 9.361757666147147
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.0372589111328125,
                    "num_nodes_avg": 338.9,
                    "path_length_avg": 239.0656007486035,
                    "smoothness_avg": 0.10263753383464265,
                    "success_improvement": 0.0,
                    "time_improvement": 77.49735483562543,
                    "node_improvement": 77.22905328226837,
                    "length_improvement": 20.193021348332763,
                    "smoothness_improvement": 2540.9376723928312,
                    "objective_score": 48.069707621651446
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.0440518856048584,
                    "num_nodes_avg": 400.8,
                    "path_length_avg": 120.37369996551419,
                    "smoothness_avg": 0.11632493211416521,
                    "success_improvement": 0.0,
                    "time_improvement": 13.193431402810726,
                    "node_improvement": 49.040050858232675,
                    "length_improvement": 20.053520062534325,
                    "smoothness_improvement": 1379.6445502788406,
                    "objective_score": 22.888364209758016
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "path_expert",
          "algorithm_description": "An improved bidirectional RRT* planner integrating adaptive rewiring radius scaling and a probabilistic goal-biased informed sampling scheme, combined with frequent, iterative, and cautious shortcutting that preserves smoothness. This planner enhances path quality and smoothness by incorporating an adaptive neighbor radius based on the number of nodes and dimension, dynamically balancing exploration with goal bias, and applying incremental smoothing phases that limit abrupt path modifications. Tree connection attempts occur often to accelerate solution discovery. Meanwhile, rewiring drops parents only when a truly better cost is achievable, and cost updates propagate efficiently to maintain subtree consistency for smooth path refinement.",
          "planning_mechanism": "The planner grows two trees from start and goal, exploring with goal-biased, adaptive informed elliptical sampling that shrinks as better solutions are found. It steers with fixed steps and rewires within a dynamically scaled neighborhood radius calculated to maintain local path quality in accordance with dimensionality and tree size. The planner frequently attempts to connect the trees and propagates cost updates recursively on rewiring to ensure subtree cost consistency. After each successful connection, a multi-pass shortcutting method iteratively attempts valid shortcuts with limited aggressive node removal to enhance smoothness without causing sharp deviations. This approach optimizes both runtime and path quality robustly in complex environments.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=6.0, r_min=5.0, r_max=30.0, goal_sample_rate=0.1):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.r_min = r_min\n        self.r_max = r_max\n        self.goal_sample_rate = goal_sample_rate  # Probability to sample the goal directly\n\n    def plan(self, map):\n        import math\n        import random\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = 3 if is_3d else 2\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        def dist(a,b): return math.dist(a,b)\n\n        def heuristic_forward(p):\n            return dist(p,goal_pos)\n\n        def heuristic_backward(p):\n            return dist(p,start_pos)\n\n        best_cost = float('inf')\n        solution_nodes = (None,None)\n\n        def update_subtree_costs(node):\n            for c in node.children:\n                prev_cost = c.cost\n                new_cost = node.cost + dist(node.position,c.position)\n                if new_cost + 1e-15 < prev_cost:\n                    c.cost = new_cost\n                    update_subtree_costs(c)\n\n        def rewiring_radius(n_nodes):\n            # Dimension-specific adaptive radius: r = min(r_max, max(r_min, gamma * (log n / n)^{1/d}))\n            # gamma empirically taken as 40\n            if n_nodes < 2:\n                return self.r_max\n            gamma = 40.0\n            val = gamma * (math.log(n_nodes)/n_nodes)**(1/dim)\n            return max(self.r_min, min(self.r_max,val))\n\n        def sample():\n            # goal biased informed sampling if solution found; else uniform with goal bias\n            if random.random() < self.goal_sample_rate:\n                return goal_pos\n            if best_cost == float('inf'):\n                while True:\n                    pt = tuple(random.uniform(0,bounds[i]) for i in range(dim))\n                    if not self._is_in_obstacle(pt,obstacles,is_3d):\n                        return pt\n            else:\n                # informed sampling inside ellipsoid aligned with start-goal\n                center = tuple((start_pos[i]+goal_pos[i])/2 for i in range(dim))\n                a1 = [goal_pos[i]-start_pos[i] for i in range(dim)]\n                length = dist(start_pos,goal_pos)\n                if length < 1e-15:\n                    # degenerate\n                    return goal_pos\n\n                # Rotate samples to align ellipsoid with line between start and goal\n                # Build orthonormal basis\n                e1 = [x/length for x in a1]\n                # Generate orthogonal vectors with Gram-Schmidt\n                def orthonormal_basis(dim,e1):\n                    basis = [e1]\n                    # Simple for 2D and 3D:\n                    if dim==2:\n                        basis.append( (-e1[1], e1[0]) )\n                    elif dim==3:\n                        import math\n                        # Choose arbitrary\n                        v = [1,0,0] if abs(e1[0])<0.9 else [0,1,0]\n                        u = [v[i] - e1[i]*sum(v[j]*e1[j] for j in range(3)) for i in range(3)]\n                        u_norm = math.sqrt(sum(x*x for x in u))\n                        if u_norm < 1e-15:\n                            # fallback\n                            u = [0,0,1]\n                            u_norm=1\n                        u = [x/u_norm for x in u]\n                        w = [e1[1]*u[2] - e1[2]*u[1],\n                             e1[2]*u[0] - e1[0]*u[2],\n                             e1[0]*u[1] - e1[1]*u[0]]\n                        basis.extend([u,w])\n                    return basis\n                B = orthonormal_basis(dim,e1)\n\n                # Compute ellipsoid axes\n                c_min = length\n                # safety margin to allow slightly larger sampling region for exploration\n                c_max = min(best_cost * 1.05, sum(bounds)*10)\n\n                # Axes lengths (a): a1 = c_max/2, others scale by sqrt(c_max^2 - c_min^2)/2 or fallback\n                try:\n                    a1_len = c_max / 2.0\n                    a_others = max( ( (c_max**2 - c_min**2) / 4.0 )**0.5, 1e-8 )\n                except Exception:\n                    a1_len = c_max / 2.0\n                    a_others = a1_len\n\n                while True:\n                    # sample in unit ball first\n                    if dim==2:\n                        r = random.uniform(0,1)**0.5\n                        theta = random.uniform(0,2*math.pi)\n                        unit_ball = [r*math.cos(theta), r*math.sin(theta)]\n                        coords = [a1_len*unit_ball[0]] + [a_others*unit_ball[1]]\n                        # rotate back to map coords\n                        sample_pt = [ center[i] + sum(coords[j]*B[j][i] for j in range(dim)) for i in range(dim) ]\n                        pt = tuple(sample_pt)\n                    else:\n                        # 3D\n                        while True:\n                            u = [random.uniform(-1,1) for _ in range(3)]\n                            norm_u = math.sqrt(sum(x*x for x in u))\n                            if norm_u<=1 and norm_u>0:\n                                unit_ball = [x/norm_u for x in u]\n                                break\n                        coords = [a1_len*unit_ball[0]] + [a_others*unit_ball[1], a_others*unit_ball[2]]\n                        sample_pt = [ center[i] + sum(coords[j]*B[j][i] for j in range(dim)) for i in range(dim) ]\n                        pt = tuple(sample_pt)\n                    if any(pt[i]<0 or pt[i]>bounds[i] for i in range(dim)):\n                        continue\n                    if self._is_in_obstacle(pt,obstacles,is_3d):\n                        continue\n                    return pt\n\n        def nearest(tree,p):\n            # Euclidean distance nearest node\n            best = None\n            best_d = float('inf')\n            for n in tree:\n                d = dist(n.position,p)\n                if d < best_d:\n                    best = n\n                    best_d = d\n            return best\n\n        def near(tree,p,r):\n            r2 = r*r\n            return [n for n in tree if ( (n.position[0]-p[0])**2 + (n.position[1]-p[1])**2 + ((n.position[2]-p[2])**2 if is_3d else 0.0)) <= r2]\n\n        def steer(from_pos,to_pos):\n            d = dist(from_pos,to_pos)\n            if d <= self.step_size:\n                return to_pos\n            ratio = self.step_size/d\n            return tuple(from_pos[i]+(to_pos[i]-from_pos[i])*ratio for i in range(dim))\n\n        def is_free_node(pos):\n            return not self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def is_free_edge(a,b):\n            return not self._is_edge_in_obstacle(a,b,obstacles,is_3d)\n\n        def path_from_to(node_start,node_goal):\n            path_start = []\n            n = node_start\n            while n is not None:\n                path_start.append(n.position)\n                n = n.parent\n            path_goal = []\n            n = node_goal\n            while n is not None:\n                path_goal.append(n.position)\n                n = n.parent\n            # start path reversed + goal path trimmed of start overlap\n            return path_start[::-1] + path_goal\n\n        def shortcut_path(path, max_passes=5, max_attempts_per_pass=200):\n            # cautious multi-pass shortcutting; avoid removing nodes that create sharp turns\n            if len(path)<3:\n                return path[:]\n            new_path = path[:]\n            for _ in range(max_passes):\n                improved = False\n                attempts = 0\n                i = 0\n                while i < len(new_path)-2 and attempts < max_attempts_per_pass:\n                    j = random.randint(i+2, len(new_path)-1)\n                    if j <= i+1:\n                        attempts +=1\n                        continue\n                    if is_free_edge(new_path[i], new_path[j]):\n                        # Check local smoothness before shortcut removal\n                        # compute turning angles if removing intermediate nodes between i and j\n                        prev_pt = new_path[i]\n                        next_pt = new_path[j]\n                        remove_indices = range(i+1, j)\n                        # crude smoothness check: angle at prev_pt and next_pt\n                        def angle(a,b,c):\n                            import math\n                            ab = [b[k]-a[k] for k in range(dim)]\n                            cb = [b[k]-c[k] for k in range(dim)]\n                            lab = math.sqrt(sum(x*x for x in ab))\n                            lcb = math.sqrt(sum(x*x for x in cb))\n                            if lab < 1e-8 or lcb < 1e-8:\n                                return 0\n                            dot = sum(ab[k]*cb[k] for k in range(dim))\n                            val = max(min(dot/(lab*lcb),1),-1)\n                            return math.acos(val)\n                        # For safety, check angle formed by prev_pt -> next_pt (expected to be ~0)\n                        # and angles before and after removing nodes\n                        if i>0:\n                            a = new_path[i-1]\n                            b = prev_pt\n                            c = next_pt\n                            a1 = angle(a,b,c)\n                            if a1 > math.pi*135/180: # >135 degrees sharp\n                                i+=1\n                                attempts+=1\n                                continue\n                        if j<len(new_path)-1:\n                            a = prev_pt\n                            b = next_pt\n                            c = new_path[j+1]\n                            a2 = angle(a,b,c)\n                            if a2 > math.pi*135/180:\n                                i+=1\n                                attempts+=1\n                                continue\n                        # Accept shortcut if angles okay:\n                        # Remove intermediate nodes:\n                        new_path = new_path[:i+1] + new_path[j:]\n                        improved = True\n                        # Restart checking from start after change to propagate smoothing\n                        i = 0\n                        attempts +=1\n                        continue\n                    else:\n                        i+=1\n                        attempts+=1\n                if not improved:\n                    break\n            return new_path\n\n        for it in range(self.max_iter):\n            sample_pos = sample()\n\n            # Alternate tree expansions for balance and exploration\n            if it % 2 == 0:\n                prop_tree, other_tree = start_tree, goal_tree\n                heuristic_prop = heuristic_forward\n                heuristic_other = heuristic_backward\n            else:\n                prop_tree, other_tree = goal_tree, start_tree\n                heuristic_prop = heuristic_backward\n                heuristic_other = heuristic_forward\n\n            nearest_node = nearest(prop_tree, sample_pos)\n            new_pos = steer(nearest_node.position, sample_pos)\n\n            if not is_free_node(new_pos):\n                continue\n            if not is_free_edge(nearest_node.position, new_pos):\n                continue\n\n            # Compute adaptive neighbor radius for rewiring based on number of nodes in prop_tree\n            r = rewiring_radius(len(prop_tree))\n\n            near_nodes = near(prop_tree, new_pos, r)\n            # Choose parent minimizing cost + heuristic with collision check\n            min_cost = nearest_node.cost + dist(nearest_node.position,new_pos)\n            best_parent = nearest_node\n            for candidate in near_nodes:\n                if candidate is nearest_node:\n                    continue\n                tentative_cost = candidate.cost + dist(candidate.position,new_pos)\n                # Use strict improvement only\n                if tentative_cost + heuristic_prop(new_pos) + 1e-15 < min_cost + heuristic_prop(new_pos):\n                    if is_free_edge(candidate.position, new_pos):\n                        min_cost = tentative_cost\n                        best_parent = candidate\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.add_child(new_node)\n            prop_tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire near nodes if cost improves with new_node as parent\n            for nbr in near_nodes:\n                if nbr is best_parent or nbr is new_node:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, nbr.position)\n                if new_cost + heuristic_prop(nbr.position) + 1e-15 < nbr.cost + heuristic_prop(nbr.position):\n                    if is_free_edge(new_node.position, nbr.position):\n                        # Remove old parent edge\n                        if nbr.parent is not None:\n                            try:\n                                edges.remove((nbr.parent, nbr))\n                            except ValueError:\n                                pass\n                            nbr.parent.remove_child(nbr)\n                        nbr.parent = new_node\n                        nbr.cost = new_cost\n                        new_node.add_child(nbr)\n                        edges.append((new_node, nbr))\n                        update_subtree_costs(nbr)\n\n            # Attempt connection from new_node to other_tree for path joining\n            near_other = nearest(other_tree, new_node.position)\n            dist_conn = dist(new_node.position, near_other.position)\n            if dist_conn <= self.step_size:\n                if is_free_edge(new_node.position, near_other.position):\n                    candidate_cost = new_node.cost + dist_conn + near_other.cost\n                    if candidate_cost + 1e-15 < best_cost:\n                        best_cost = candidate_cost\n                        if it % 2 == 0:\n                            solution_nodes = (new_node, near_other)\n                        else:\n                            solution_nodes = (near_other, new_node)\n\n            # After finding a solution, apply shortcutting iteratively every 80 iterations or at last iteration\n            if solution_nodes[0] and solution_nodes[1] and ( (it > 0 and it % 80 == 0) or it == self.max_iter-1 ):\n                raw_path = path_from_to(solution_nodes[0], solution_nodes[1])\n                smoothed = shortcut_path(raw_path, max_passes=6, max_attempts_per_pass=250)\n                if smoothed:\n                    return PlannerResult(True, smoothed, nodes, edges)\n\n        # Final return after max_iter or failure\n        if solution_nodes[0] and solution_nodes[1]:\n            raw_path = path_from_to(solution_nodes[0], solution_nodes[1])\n            smoothed = shortcut_path(raw_path, max_passes=6, max_attempts_per_pass=250)\n            return PlannerResult(True, smoothed, nodes, edges)\n        else:\n            return PlannerResult(False, [], nodes, edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        px = pos[0]\n        py = pos[1]\n        pz = pos[2] if is_3d else 0.0\n        for obs in obstacles:\n            if is_3d:\n                x,y,z,w,h,d = obs\n                if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                    return True\n            else:\n                x,y,w,h = obs\n                if x <= px <= x+w and y <= py <= y+h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        dist_val = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist_val/resolution))\n        for step in range(steps+1):\n            t = step/steps\n            interp = tuple(from_pos[i] + t*(to_pos[i]-from_pos[i]) for i in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -26.71512,
          "time_improvement": 54.0,
          "length_improvement": 13.0,
          "smoothness_improvement": 465.0,
          "node_improvement": 66.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.017966294288635255,
                    "num_nodes_avg": 173.5,
                    "path_length_avg": 163.95951929194274,
                    "smoothness_avg": 0.024923003054025138,
                    "success_improvement": 0.0,
                    "time_improvement": 30.338388437200997,
                    "node_improvement": 56.3082347015865,
                    "length_improvement": 10.131189371242641,
                    "smoothness_improvement": 290.09911896286457,
                    "objective_score": 16.630725748720206
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.03304464817047119,
                    "num_nodes_avg": 340.6,
                    "path_length_avg": 250.18134841864676,
                    "smoothness_avg": 0.025115402013338145,
                    "success_improvement": 0.0,
                    "time_improvement": 80.04257317904118,
                    "node_improvement": 77.11482899952965,
                    "length_improvement": 16.48226482701569,
                    "smoothness_improvement": 546.2373836960618,
                    "objective_score": 36.63331776840208
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.024051189422607422,
                    "num_nodes_avg": 287.7,
                    "path_length_avg": 129.7207213209384,
                    "smoothness_avg": 0.05176360916448404,
                    "success_improvement": 0.0,
                    "time_improvement": 52.60586020800652,
                    "node_improvement": 63.42021614748887,
                    "length_improvement": 13.84567353558893,
                    "smoothness_improvement": 558.4292877800516,
                    "objective_score": 26.88130862265557
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e2",
          "algorithm_description": "This algorithm is a bidirectional RRT* variant combining informed elliptical sampling with adaptive neighborhood radius recalibration to improve convergence speed and path quality. It grows two trees simultaneously from start and goal, performs efficient nearest and near neighbor searches, applies incremental rewiring with cost propagation, and attempts frequent connections between trees. The informed sampling targets ellipsoidal regions shaped by the best current path cost, and the radius adapts based on iteration count and node density to balance exploration and optimization. After successful connection, the algorithm extracts and performs iterated shortcut smoothing to produce shorter, smoother paths while ensuring collision-free nodes and edges within map bounds.",
          "planning_mechanism": "The planner alternates expansion of two trees using adaptive informed sampling within an ellipsoidal informed set defined by the best path cost. Each extension seeks a minimum cost parent within an adaptive radius, followed by rewiring neighbors to reduce path cost with recursive updates. Regular connection attempts between trees detect early solutions. When a solution is found, the algorithm performs iterative shortcutting with collision checks to improve smoothness and path length while respecting collision and map boundary constraints.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=5.0, base_radius=20.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.base_radius = base_radius\n\n    def plan(self, map):\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        edges = []\n\n        best_path = []\n        best_cost = float('inf')\n\n        def dist(a, b):\n            return math.dist(a,b)\n\n        def in_bounds(p):\n            return all(0 <= p[i] <= bounds[i] for i in range(dim))\n\n        def collision_node(p):\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d = obs\n                    px,py,pz = p\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                        return True\n                else:\n                    x,y,w,h = obs\n                    px,py = p\n                    if x <= px <= x+w and y <= py <= y+h:\n                        return True\n            return False\n\n        def collision_edge(a,b,res=0.5):\n            length = dist(a,b)\n            steps = max(1,int(length / res))\n            for i in range(steps+1):\n                interp = tuple(a[d] + (b[d]-a[d])*(i/steps) for d in range(dim))\n                if collision_node(interp):\n                    return True\n            return False\n\n        def steer(from_p,to_p):\n            length = dist(from_p,to_p)\n            if length <= self.step_size:\n                return to_p\n            ratio = self.step_size / length\n            return tuple(from_p[i] + (to_p[i] - from_p[i]) * ratio for i in range(dim))\n\n        def nearest(tree, p):\n            best_node = None\n            best_dist = float('inf')\n            for node in tree:\n                d = dist(node.position, p)\n                if d < best_dist:\n                    best_dist = d\n                    best_node = node\n            return best_node\n\n        def near(tree, p, radius):\n            result = []\n            r_sq = radius*radius\n            for node in tree:\n                d_sq = sum((node.position[i] - p[i])**2 for i in range(dim))\n                if d_sq <= r_sq:\n                    result.append(node)\n            return result\n\n        def heuristic_cost_to_go(p):\n            return dist(p, goal_pos)\n\n        def cost_to_come(p):\n            nn = nearest(start_tree, p)\n            return nn.cost + dist(nn.position, p)\n\n        def informed_sample():\n            c_min = dist(start_pos, goal_pos)\n            c_best = best_cost\n            if c_best == float('inf'):\n                while True:\n                    sample = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                    if not collision_node(sample):\n                        return sample\n            # Ellipsoidal informed sampling:\n            center = tuple((start_pos[i] + goal_pos[i]) / 2 for i in range(dim))\n            foci_dist = c_min\n            if c_best < c_min:\n                c_best = c_min + 1e-6\n            r1 = c_best / 2\n            val = c_best*c_best - foci_dist*foci_dist\n            r_rest = math.sqrt(val)/2 if val > 0 else 0.0\n\n            def unit_ball_sample(dim_):\n                while True:\n                    vec = [random.gauss(0,1) for _ in range(dim_)]\n                    norm = math.sqrt(sum(x*x for x in vec))\n                    if norm > 1e-8:\n                        break\n                u = [x/norm for x in vec]\n                r = random.random() ** (1/dim_)\n                return [u[i]*r for i in range(dim_)]\n\n            while True:\n                u_sample = unit_ball_sample(dim)\n                sample_ellipsoid = [0]*dim\n                sample_ellipsoid[0] = u_sample[0]*r1\n                for i in range(1,dim):\n                    sample_ellipsoid[i] = u_sample[i]*r_rest\n                point = tuple(center[i] + sample_ellipsoid[i] for i in range(dim))\n                if in_bounds(point) and not collision_node(point):\n                    return point\n\n        def new_radius(iteration, tree_size):\n            # Adaptive radius shrinking over iterations and growing tree size, per theory ~ (log n / n)^{1/d}\n            if tree_size < 2:\n                return self.base_radius\n            gamma_rrt_star = self.base_radius\n            radius = min(gamma_rrt_star, \n                         gamma_rrt_star * (math.log(tree_size)/tree_size)**(1/dim))\n            # Enforce reasonable limits\n            return max(radius, self.step_size)\n\n        def propagate_cost(node):\n            for child in node.children:\n                new_cost = node.cost + dist(node.position, child.position)\n                if new_cost < child.cost:\n                    child.cost = new_cost\n                    propagate_cost(child)\n\n        def rewire(tree, new_node, near_nodes):\n            for near_node in near_nodes:\n                if near_node is new_node.parent:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, near_node.position)\n                est_total_new = new_cost + heuristic_cost_to_go(near_node.position)\n                est_total_old = near_node.cost + heuristic_cost_to_go(near_node.position)\n                if est_total_new + 1e-9 < est_total_old and new_cost < near_node.cost:\n                    if not collision_edge(new_node.position, near_node.position):\n                        # Remove old parent-child relationship\n                        if near_node.parent:\n                            near_node.parent.remove_child(near_node)\n                            if (near_node.parent, near_node) in edges:\n                                edges.remove((near_node.parent, near_node))\n                        near_node.parent = new_node\n                        near_node.cost = new_cost\n                        new_node.add_child(near_node)\n                        edges.append((new_node, near_node))\n                        propagate_cost(near_node)\n\n        def extract_path(node_start, node_goal):\n            path_start = []\n            node = node_start\n            while node:\n                path_start.append(node.position)\n                node = node.parent\n            path_start.reverse()\n            path_goal = []\n            node = node_goal\n            while node:\n                path_goal.append(node.position)\n                node = node.parent\n            return path_start + path_goal\n\n        def shortcut_path(path, max_iters=50):\n            length = len(path)\n            if length < 3:\n                return path[:]\n            new_path = path[:]\n            for _ in range(max_iters):\n                if len(new_path) < 3:\n                    break\n                i = random.randint(0, len(new_path)-3)\n                j = random.randint(i+2, len(new_path)-1)\n                if not collision_edge(new_path[i], new_path[j]):\n                    del new_path[i+1:j]\n            return new_path\n\n        for iter in range(1, self.max_iter+1):\n            sample = informed_sample()\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nn = nearest(tree_a, sample)\n                new_pos = steer(nn.position, sample)\n                if not in_bounds(new_pos):\n                    continue\n                if collision_node(new_pos):\n                    continue\n                if collision_edge(nn.position, new_pos):\n                    continue\n\n                radius = new_radius(iter, len(tree_a))\n                near_nodes = near(tree_a, new_pos, radius)\n\n                min_cost = nn.cost + dist(nn.position, new_pos)\n                min_parent = nn\n                for near_node in near_nodes:\n                    cost_cand = near_node.cost + dist(near_node.position, new_pos)\n                    if cost_cand < min_cost and not collision_edge(near_node.position, new_pos):\n                        min_cost = cost_cand\n                        min_parent = near_node\n\n                new_node = Node(new_pos, min_parent, min_cost)\n                min_parent.add_child(new_node)\n                tree_a.append(new_node)\n                edges.append((min_parent, new_node))\n\n                rewire(tree_a, new_node, near_nodes)\n\n                conn_node = nearest(tree_b, new_node.position)\n                dist_connect = dist(conn_node.position, new_node.position)\n                if dist_connect <= self.step_size and not collision_edge(conn_node.position, new_node.position):\n                    candidate_path = extract_path(new_node, conn_node)\n                    path_cost = 0.0\n                    for k in range(len(candidate_path)-1):\n                        path_cost += dist(candidate_path[k], candidate_path[k+1])\n                    if path_cost < best_cost:\n                        best_cost = path_cost\n                        best_path = shortcut_path(candidate_path, max_iters=100)\n                        if best_cost < float('inf'):\n                            return PlannerResult(True, best_path, start_tree + goal_tree, edges)\n\n        if best_path:\n            return PlannerResult(True, best_path, start_tree + goal_tree, edges)\n        return PlannerResult(False, [], start_tree + goal_tree, edges)",
          "objective": -26.27848,
          "time_improvement": 35.0,
          "length_improvement": 15.0,
          "smoothness_improvement": 1433.0,
          "node_improvement": 70.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.018117833137512206,
                    "num_nodes_avg": 114.4,
                    "path_length_avg": 171.0714968515819,
                    "smoothness_avg": 0.0338915604180979,
                    "success_improvement": 0.0,
                    "time_improvement": 29.750819278110836,
                    "node_improvement": 71.19113573407203,
                    "length_improvement": 6.233001774308198,
                    "smoothness_improvement": 430.476517244636,
                    "objective_score": 14.81742943424135
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.031439352035522464,
                    "num_nodes_avg": 278.2,
                    "path_length_avg": 238.74291742398609,
                    "smoothness_avg": 0.10316733134869423,
                    "success_improvement": 0.0,
                    "time_improvement": 81.01209719920723,
                    "node_improvement": 81.3075320835853,
                    "length_improvement": 20.300742330014568,
                    "smoothness_improvement": 2554.5697440271038,
                    "objective_score": 49.25692327790643
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.05441353321075439,
                    "num_nodes_avg": 340.1,
                    "path_length_avg": 124.59040420304787,
                    "smoothness_avg": 0.11126977220167059,
                    "success_improvement": 0.0,
                    "time_improvement": -7.224742787261016,
                    "node_improvement": 56.75778766687858,
                    "length_improvement": 17.252985885842975,
                    "smoothness_improvement": 1315.3432893250001,
                    "objective_score": 14.761085141952478
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "path_expert",
          "algorithm_description": "An enhanced bidirectional RRT* planner that integrates dynamically shrinking rewiring radius, goal- and informed-biased sampling, and continuous incremental shortcutting during planning to aggressively refine path smoothness and length. This planner uses early pruning of nodes to maintain a compact tree, adaptive rewiring heuristics limiting redundant edges, and merges trees with a refined cost heuristic enabling faster convergence on shorter, smoother, and computationally efficient solutions.",
          "planning_mechanism": "A bidirectional RRT* simultaneously grows trees from start and goal, alternating expansions. Sampling combines goal bias and informed ellipsoidal sampling narrowing exploration to promising regions. Each iteration rewires neighbors within a dynamically shrinking radius based on node count and iteration to avoid excessive branching. Incremental shortcutting is performed every few iterations to continuously smooth the path, removing jagged segments early. Trees are merged when close nodes are found, and paths with improved cost update the best solution. Node pruning removes costly nodes to keep the search compact and focused.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n    def add_child(self, child):\n        self.children.append(child)\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\nclass Planner:\n    def __init__(self, max_iter=7000, step_size=8.0, gamma_rrt=50.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.gamma_rrt = gamma_rrt  # rewiring radius coefficient\n\n    def plan(self, map):\n        import math, random\n        bounds = map.size\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        is_3d = (len(bounds) == 3)\n        dim = 3 if is_3d else 2\n\n        start_tree = [Node(start)]\n        goal_tree = [Node(goal)]\n        nodes_all = start_tree + goal_tree\n        edges = []\n\n        c_min = self._distance(start, goal)\n        best_cost = float('inf')\n        best_pair = None  # tuple (node_start, node_goal)\n\n        goal_bias = 0.15\n        informed_prob = 0.7\n\n        # Store all nodes in one list for adaptive radius\n        total_nodes = 2\n\n        # For incremental shortcutting control\n        shortcut_freq = 10\n\n        def adaptive_radius(n_nodes, iter_i):\n            # Shrinks with iterations, balances exploration to exploitation\n            base = (self.gamma_rrt * (math.log(n_nodes + 1) / (n_nodes + 1))**(1.0/dim))\n            shrink_factor = max(0.15, 1.0 - iter_i / self.max_iter)\n            return min(self.step_size*3.5, base) * shrink_factor\n\n        for it in range(self.max_iter):\n            # Alternate trees for growth\n            tree_a, tree_b = (start_tree, goal_tree) if it % 2 == 0 else (goal_tree, start_tree)\n\n            # Sampling strategy: \n            r = random.random()\n            sample = None\n            if best_cost < float('inf'):\n                if r < goal_bias:\n                    sample = goal if tree_a is start_tree else start\n                elif r < goal_bias + informed_prob:\n                    sample = self._informed_sample(bounds, obstacles, is_3d,\n                                                   start, goal, best_cost, c_min)\n                else:\n                    sample = self._sample_free(bounds, obstacles, is_3d)\n            else:\n                sample = goal if r < goal_bias else self._sample_free(bounds, obstacles, is_3d)\n\n            nearest = self._nearest(tree_a, sample)\n            new_pos = self._steer(nearest.position, sample, self.step_size)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                continue\n\n            new_node = Node(new_pos)\n            # Adaptive rewiring radius based on current nodes and iteration\n            radius = adaptive_radius(len(nodes_all), it)\n            near_nodes = self._near(tree_a, new_pos, radius)\n\n            # Choose best parent from near neighbors\n            min_cost = nearest.cost + self._distance(nearest.position, new_pos)\n            min_parent = nearest\n            for near in near_nodes:\n                cost_via_near = near.cost + self._distance(near.position, new_pos)\n                if cost_via_near < min_cost and not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d):\n                    min_cost = cost_via_near\n                    min_parent = near\n\n            new_node.parent = min_parent\n            new_node.cost = min_cost\n            min_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes_all.append(new_node)\n            edges.append((min_parent, new_node))\n            total_nodes += 1\n\n            # Rewire neighbors to new node if cheaper\n            for near in near_nodes:\n                if near is min_parent:\n                    continue\n                new_cost = new_node.cost + self._distance(new_node.position, near.position)\n                if new_cost + 1e-12 < near.cost and not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                    # Remove old edge\n                    if near.parent:\n                        try: edges.remove((near.parent, near))\n                        except ValueError: pass\n                        near.parent.remove_child(near)\n                    near.parent = new_node\n                    near.cost = new_cost\n                    new_node.add_child(near)\n                    edges.append((new_node, near))\n\n            # Attempt to connect tree_b to new_node if close enough\n            connect_near = self._near(tree_b, new_node.position, self.step_size * 1.2)\n            for node_c in connect_near:\n                dist_conn = self._distance(new_node.position, node_c.position)\n                if dist_conn <= self.step_size * 1.2:\n                    if not self._is_edge_in_obstacle(new_node.position, node_c.position, obstacles, is_3d):\n                        candidate_cost = new_node.cost + dist_conn + node_c.cost\n                        if candidate_cost + 1e-12 < best_cost:\n                            best_cost = candidate_cost\n                            best_pair = (new_node, node_c)\n                            # Aggressively prune nodes with cost worse than best_cost * 1.5\n                            self._prune_nodes(start_tree, best_cost*1.5)\n                            self._prune_nodes(goal_tree, best_cost*1.5)\n                            # No need to reassign nodes_all here, we keep it as is.\n\n            # Incremental shortcutting every shortcut_freq iterations if path found\n            if best_cost < float('inf') and it % shortcut_freq == 0:\n                path = self._extract_path(best_pair[0], best_pair[1])\n                shortened = self._incremental_shortcut(path, obstacles, is_3d, max_attempts=50)\n                if shortened and len(shortened) < len(path):\n                    # Update parent links according to shortcut path\n                    self._update_path_graph(shortened, start_tree, goal_tree)\n                    # Return improved path early if it's really better\n                    return PlannerResult(True, shortened, start_tree + goal_tree, edges)\n\n        # Return best found or failure\n        if best_cost < float('inf') and best_pair:\n            path = self._extract_path(best_pair[0], best_pair[1])\n            path = self._incremental_shortcut(path, obstacles, is_3d, max_attempts=150) or path\n            return PlannerResult(True, path, start_tree + goal_tree, edges)\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    def _prune_nodes(self, tree, threshold_cost):\n        # Remove nodes with cost above threshold and prune their children recursively\n        to_remove = [node for node in tree if node.cost > threshold_cost]\n        for node in to_remove:\n            if node.parent:\n                try: node.parent.children.remove(node)\n                except ValueError: pass\n            self._remove_descendants(node, tree)\n            try: tree.remove(node)\n            except ValueError: pass\n\n    def _remove_descendants(self, node, tree):\n        for child in node.children[:]:\n            self._remove_descendants(child, tree)\n            try: tree.remove(child)\n            except ValueError: pass\n        node.children = []\n\n    def _update_path_graph(self, path, start_tree, goal_tree):\n        # Overwrite parents to represent path and update costs; used after shortcutting\n        # path is a list of positions from start to goal\n        # match nodes by proximity and reconnect\n        nodes_map = {}\n        # Store positions to nodes in start_tree + goal_tree for quick lookup\n        all_nodes = start_tree + goal_tree\n        for pos in path:\n            # find closest node\n            best_node = None\n            best_dist = float('inf')\n            for n in all_nodes:\n                d = self._distance(n.position, pos)\n                if d < best_dist:\n                    best_dist = d\n                    best_node = n\n            nodes_map[pos] = best_node\n        for i in range(1, len(path)):\n            cur_node = nodes_map[path[i]]\n            par_node = nodes_map[path[i-1]]\n            if cur_node and par_node:\n                # Remove old parent-child relationships safely\n                if cur_node.parent and cur_node.parent != par_node:\n                    try:\n                        cur_node.parent.children.remove(cur_node)\n                    except ValueError:\n                        pass\n                cur_node.parent = par_node\n                cur_node.cost = par_node.cost + self._distance(par_node.position, cur_node.position)\n                if cur_node not in par_node.children:\n                    par_node.children.append(cur_node)\n\n    def _incremental_shortcut(self, path, obstacles, is_3d, max_attempts=50):\n        import random\n        if len(path) < 3:\n            return path[:]\n        path = path[:]\n        for _ in range(max_attempts):\n            if len(path) < 3:\n                break\n            i = random.randint(0, len(path) - 3)\n            j = random.randint(i+2, len(path) -1)\n            if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                path = path[:i+1] + path[j:]\n        return path\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        import random\n        while True:\n            pt = tuple(random.uniform(0, bounds[i]) for i in range(3 if is_3d else 2))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def _informed_sample(self, bounds, obstacles, is_3d, start, goal, c_max, c_min):\n        import random, math\n        dim = 3 if is_3d else 2\n        if c_max == float('inf') or c_max <= c_min:\n            return self._sample_free(bounds, obstacles, is_3d)\n        while True:\n            # Sample unit ball point\n            if dim == 2:\n                r = random.uniform(0, 1) ** 0.5\n                theta = random.uniform(0, 2*math.pi)\n                x_ball = [r * math.cos(theta), r * math.sin(theta)]\n            else:\n                while True:\n                    x_ball = [random.uniform(-1,1) for _ in range(3)]\n                    if sum(x*x for x in x_ball) <=1:\n                        break\n            center = tuple((start[i] + goal[i]) / 2 for i in range(dim))\n            dir_vec = [goal[i] - start[i] for i in range(dim)]\n            length = self._distance(start, goal)\n            if dim ==2:\n                if length == 0:\n                    R = [[1,0],[0,1]]\n                else:\n                    a1 = [1,0]\n                    a2 = [dir_vec[0]/length, dir_vec[1]/length]\n                    cos_theta = a1[0]*a2[0] + a1[1]*a2[1]\n                    sin_theta = a1[0]*a2[1] - a1[1]*a2[0]\n                    R = [[cos_theta,-sin_theta],[sin_theta,cos_theta]]\n            else:\n                from math import sqrt\n                if length ==0:\n                    R = [[1,0,0],[0,1,0],[0,0,1]]\n                else:\n                    a1 = [1,0,0]\n                    a2 = [dir_vec[i]/length for i in range(3)]\n                    v = [a1[1]*a2[2]-a1[2]*a2[1], a1[2]*a2[0]-a1[0]*a2[2], a1[0]*a2[1]-a1[1]*a2[0]]\n                    s = sqrt(sum(vi*vi for vi in v))\n                    c = sum(a1[i]*a2[i] for i in range(3))\n                    if s == 0:\n                        R = [[1,0,0],[0,1,0],[0,0,1]]\n                    else:\n                        vx = [[0,-v[2],v[1]],[v[2],0,-v[0]],[-v[1],v[0],0]]\n                        I = [[1 if i==j else 0 for j in range(3)] for i in range(3)]\n                        vx2 = [[sum(vx[i][k]*vx[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n                        R = [[I[i][j] + vx[i][j] + vx2[i][j]*((1-c)/(s**2)) for j in range(3)] for i in range(3)]\n            a1_val = c_max / 2.0\n            a_others = math.sqrt(max(c_max**2 - c_min**2,0)) /2.0\n            if dim == 2:\n                L = [[a1_val,0],[0,a_others]]\n                x_scaled = [L[0][0]*x_ball[0] + L[0][1]*x_ball[1], L[1][0]*x_ball[0] + L[1][1]*x_ball[1]]\n                pt = (center[0] + R[0][0]*x_scaled[0] + R[0][1]*x_scaled[1],\n                      center[1] + R[1][0]*x_scaled[0] + R[1][1]*x_scaled[1])\n            else:\n                L = [[a1_val,0,0],[0,a_others,0],[0,0,a_others]]\n                x_scaled = [L[0][0]*x_ball[0], L[1][1]*x_ball[1], L[2][2]*x_ball[2]]\n                pt = tuple(center[i] + sum(R[i][j]*x_scaled[j] for j in range(3)) for i in range(3))\n            if any(pt[d]<0 or pt[d]>bounds[d] for d in range(dim)):\n                continue\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def _nearest(self, tree, point):\n        best_n = None\n        best_d = float('inf')\n        for n in tree:\n            d = self._distance(n.position, point)\n            if d < best_d:\n                best_d = d\n                best_n = n\n        return best_n\n\n    def _near(self, tree, point, radius):\n        rsq = radius*radius\n        return [n for n in tree if self._squared_distance(n.position, point) <= rsq]\n\n    def _steer(self, from_pos, to_pos, step_size):\n        dist = self._distance(from_pos, to_pos)\n        if dist <= step_size:\n            return to_pos\n        ratio = step_size / dist\n        return tuple(from_pos[i] + ratio*(to_pos[i]-from_pos[i]) for i in range(len(from_pos)))\n\n    def _extract_path(self, node_start, node_goal):\n        path_s = []\n        n = node_start\n        while n:\n            path_s.append(n.position)\n            n = n.parent\n        path_s.reverse()\n        path_g = []\n        n = node_goal\n        while n:\n            path_g.append(n.position)\n            n = n.parent\n        return path_s + path_g\n\n    def _distance(self, a, b):\n        import math\n        return math.dist(a, b)\n\n    def _squared_distance(self, a, b):\n        return sum((a[i]-b[i])**2 for i in range(len(a)))\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        px = pos[0]\n        py = pos[1]\n        if is_3d:\n            pz = pos[2]\n            for obs in obstacles:\n                x,y,z,w,h,d = obs\n                if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                    return True\n        else:\n            for obs in obstacles:\n                x,y,w,h = obs\n                if x <= px <= x+w and y <= py <= y+h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, start_pos, end_pos, obstacles, is_3d, resolution=1.0):\n        dist = self._distance(start_pos, end_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps+1):\n            interp = tuple(start_pos[d] + (end_pos[d] - start_pos[d]) * (i / steps) for d in range(len(start_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -26.21634,
          "time_improvement": 44.0,
          "length_improvement": 11.0,
          "smoothness_improvement": 1267.0,
          "node_improvement": 75.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.02145414352416992,
                    "num_nodes_avg": 140.4,
                    "path_length_avg": 180.42480985555127,
                    "smoothness_avg": 0.03608455146594634,
                    "success_improvement": 0.0,
                    "time_improvement": 16.81477612561186,
                    "node_improvement": 64.64366658272476,
                    "length_improvement": 1.1063027041034745,
                    "smoothness_improvement": 464.80158929974556,
                    "objective_score": 8.03222240664437
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.03249013423919678,
                    "num_nodes_avg": 225.3,
                    "path_length_avg": 243.5062153933286,
                    "smoothness_avg": 0.0824787113610765,
                    "success_improvement": 0.0,
                    "time_improvement": 80.3774737398679,
                    "node_improvement": 84.86192299939529,
                    "length_improvement": 18.71061636391792,
                    "smoothness_improvement": 2022.2366503350422,
                    "objective_score": 45.45079519198633
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.03356444835662842,
                    "num_nodes_avg": 194.7,
                    "path_length_avg": 129.38754466453466,
                    "smoothness_avg": 0.11113233581487036,
                    "success_improvement": 0.0,
                    "time_improvement": 33.85948073071486,
                    "node_improvement": 75.24475524475524,
                    "length_improvement": 14.066953606604809,
                    "smoothness_improvement": 1313.5951086293999,
                    "objective_score": 25.16599192632434
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "initial",
          "algorithm_description": "This algorithm grows two trees simultaneously, one from the start position and one from the goal position, and attempts to connect them to find a feasible path. This bidirectional approach accelerates convergence and increases the success rate compared to a single tree RRT.",
          "planning_mechanism": "The planning mechanism involves randomly sampling points within the map bounds, extending each tree towards the sampled points, and attempting to connect the two trees whenever new nodes are added. Collision checks are performed for nodes and edges to ensure safety, and once the two trees connect, the final path is reconstructed by backtracking through the parent nodes of each tree.",
          "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map) -> PlannerResult:\n        import math, random\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position)\n        goal_root = Node(goal_position)\n        nodes.extend([start_root, goal_root])\n        tree_a, tree_b = [start_root], [goal_root]\n\n        for _ in range(self.max_iter):\n            rand_point = self._sample_free(bounds, obstacles, is_3d)\n            new_a = self._extend_tree(tree_a, rand_point, obstacles, is_3d, nodes, edges)\n            if new_a is None:\n                continue\n\n            new_b = self._connect_trees(tree_b, new_a, obstacles, is_3d, nodes, edges)\n            if new_b:\n                success_state = True\n                path_a = new_a.path_from_root()\n                path_b = new_b.path_from_root()\n                extracted_path = path_a + path_b[::-1]\n                break\n\n            tree_a, tree_b = tree_b, tree_a  # Swap trees\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        import random\n        while True:\n            if is_3d:\n                p = (random.uniform(0, bounds[0]),\n                     random.uniform(0, bounds[1]),\n                     random.uniform(0, bounds[2]))\n            else:\n                p = (random.uniform(0, bounds[0]),\n                     random.uniform(0, bounds[1]))\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    def _nearest(self, tree, point):\n        import math\n        return min(tree, key=lambda node: math.dist(node.position, point))\n\n    def _steer(self, from_pos, to_pos):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _extend_tree(self, tree, point, obstacles, is_3d, nodes, edges):\n        nearest_node = self._nearest(tree, point)\n        new_pos = self._steer(nearest_node.position, point)\n        if not self._is_in_obstacle(new_pos, obstacles, is_3d) and not self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n            new_node = Node(new_pos, parent=nearest_node)\n            nearest_node.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n            return new_node\n        return None\n\n    def _connect_trees(self, tree, new_node, obstacles, is_3d, nodes, edges):\n        import math\n        nearest_node = self._nearest(tree, new_node.position)\n        while True:\n            new_pos = self._steer(nearest_node.position, new_node.position)\n            if (not self._is_in_obstacle(new_pos, obstacles, is_3d) and\n                not self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d)):\n                next_node = Node(new_pos, parent=nearest_node)\n                nearest_node.add_child(next_node)\n                tree.append(next_node)\n                nodes.append(next_node)\n                edges.append((nearest_node, next_node))\n\n                if math.dist(next_node.position, new_node.position) <= self.step_size:\n                    if not self._is_edge_in_obstacle(next_node.position, new_node.position, obstacles, is_3d):\n                        final_node = Node(new_node.position, parent=next_node)\n                        next_node.add_child(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((next_node, final_node))\n                        return final_node\n                    else:\n                        return None\n                nearest_node = next_node\n            else:\n                return None\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n",
          "objective": -26.16492572596105,
          "time_improvement": 92.0,
          "length_improvement": -3.0,
          "smoothness_improvement": 63.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.003008270263671875,
                    "num_nodes_avg": 68.1,
                    "path_length_avg": 184.17006126805845,
                    "smoothness_avg": 0.01054995558932253,
                    "success_improvement": 0.0,
                    "time_improvement": 88.33588322571401,
                    "node_improvement": 82.85066733820196,
                    "length_improvement": -0.9465289423981464,
                    "smoothness_improvement": 65.12971456814059,
                    "objective_score": 26.25849617511602
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.008660387992858887,
                    "num_nodes_avg": 222.5,
                    "path_length_avg": 300.8164456420612,
                    "smoothness_avg": 0.0064472474436514295,
                    "success_improvement": 0.0,
                    "time_improvement": 94.76952943432936,
                    "node_improvement": 85.05005711214136,
                    "length_improvement": -0.4211880766230819,
                    "smoothness_improvement": 65.89232048978258,
                    "objective_score": 28.50760758677387
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.0042524576187133786,
                    "num_nodes_avg": 126.3,
                    "path_length_avg": 160.72624335922288,
                    "smoothness_avg": 0.012431076585876402,
                    "success_improvement": 0.0,
                    "time_improvement": 91.62030753242554,
                    "node_improvement": 83.94151303242214,
                    "length_improvement": -6.746717877938324,
                    "smoothness_improvement": 58.122376605720596,
                    "objective_score": 23.72867341599327
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "initial",
          "algorithm_description": "This algorithm is a bidirectional extension of RRT* that grows two trees from start and goal while optimizing paths via rewiring. It combines RRT*\u2018s asymptotic optimality with RRT-Connect\u2019s fast convergence through connection attempts between the trees.",
          "planning_mechanism": "The planner alternates growing two trees with sampling, extension, and rewiring. After each extension, it attempts to connect both trees. When connection is successful, a rewired optimal path is extracted across both trees.",
          "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, radius: float = 10.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.radius = radius\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n        nodes = []\n        edges = []\n        success_state = False\n        extracted_path = []\n\n        for iter in range(self.max_iter):\n            rand = self._sample_free(bounds, obstacles, is_3d)\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest = self._nearest(tree_a, rand)\n                new_pos = self._steer(nearest.position, rand, self.step_size)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                    continue\n\n                new_node = Node(new_pos)\n                near_nodes = self._near(tree_a, new_pos, self.radius)\n                min_cost = nearest.cost + self._distance(nearest.position, new_pos)\n                min_parent = nearest\n\n                for near in near_nodes:\n                    cost = near.cost + self._distance(near.position, new_pos)\n                    if cost < min_cost and not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d):\n                        min_cost = cost\n                        min_parent = near\n\n                new_node.parent = min_parent\n                new_node.cost = min_cost\n                min_parent.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((min_parent, new_node))\n\n                for near in near_nodes:\n                    if near == min_parent:\n                        continue\n                    new_cost = new_node.cost + self._distance(new_node.position, near.position)\n                    if new_cost < near.cost and not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                        if near.parent:\n                            edges.remove((near.parent, near))\n                        near.parent = new_node\n                        near.cost = new_cost\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n\n                connect_node = self._nearest(tree_b, new_node.position)\n                if self._distance(new_node.position, connect_node.position) < self.step_size and not self._is_edge_in_obstacle(new_node.position, connect_node.position, obstacles, is_3d):\n                    success_state = True\n                    extracted_path = self._extract_path(new_node, connect_node)\n                    return PlannerResult(True, extracted_path, start_tree + goal_tree, edges)\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        while True:\n            point = tuple(random.uniform(0, bounds[i]) for i in range(3 if is_3d else 2))\n            if not self._is_in_obstacle(point, obstacles, is_3d):\n                return point\n\n    def _nearest(self, tree, point):\n        return min(tree, key=lambda node: self._distance(node.position, point))\n\n    def _near(self, tree, point, radius):\n        return [node for node in tree if self._distance(node.position, point) <= radius]\n\n    def _steer(self, from_pos, to_pos, step_size):\n        dist = self._distance(from_pos, to_pos)\n        if dist <= step_size:\n            return to_pos\n        ratio = step_size / dist\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n    def _extract_path(self, node_a, node_b):\n        path_a = []\n        while node_a:\n            path_a.append(node_a.position)\n            node_a = node_a.parent\n        path_b = []\n        while node_b:\n            path_b.append(node_b.position)\n            node_b = node_b.parent\n        return list(reversed(path_a)) + path_b\n\n    def _distance(self, a, b):\n        return math.dist(a, b)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = self._distance(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n    ",
          "objective": -26.062040773062417,
          "time_improvement": 66.0,
          "length_improvement": 9.0,
          "smoothness_improvement": 167.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.012016057968139648,
                    "num_nodes_avg": 134.5,
                    "path_length_avg": 175.84673815929608,
                    "smoothness_avg": 0.016310939143948412,
                    "success_improvement": 0.0,
                    "time_improvement": 53.409537367863955,
                    "node_improvement": 66.1294384286074,
                    "length_improvement": 3.6156163450092893,
                    "smoothness_improvement": 155.30161737405683,
                    "objective_score": 18.96873910423504
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.018314409255981445,
                    "num_nodes_avg": 253.0,
                    "path_length_avg": 257.3377355314211,
                    "smoothness_avg": 0.010767991223558952,
                    "success_improvement": 0.0,
                    "time_improvement": 88.93895070058699,
                    "node_improvement": 83.00073909830007,
                    "length_improvement": 14.093256823589732,
                    "smoothness_improvement": 177.06817005275553,
                    "objective_score": 36.02298015459372
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.022396659851074217,
                    "num_nodes_avg": 265.9,
                    "path_length_avg": 136.5245362961063,
                    "smoothness_avg": 0.0210441701583257,
                    "success_improvement": 0.0,
                    "time_improvement": 55.86619816574277,
                    "node_improvement": 66.19198982835347,
                    "length_improvement": 9.326903591935762,
                    "smoothness_improvement": 167.68029109483984,
                    "objective_score": 23.19440306035849
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m2",
          "algorithm_description": "This algorithm is an advanced bidirectional RRT* planner incorporating adaptive radius rewiring, spatial hashing for efficient nearest neighbor queries, dynamic goal biasing, and improved incremental smoothing that applies curvature-aware shortcutting progressively during planning and post-processing. It balances global exploration with local optimality remodeling and smart tree connection strategies, delivering faster convergence, more optimal and smoother paths, and reduced computational overhead.<The planner grows two trees from start and goal positions alternately, samples with a dynamic goal bias that decays over iterations to encourage exploration early and focus on refinement later, uses spatial hashing to speed up nearest neighbor and near node searches, applies curvature- and distance-aware incremental shortcutting after each successful expansion, and rewires nodes within an adaptive radius. Once the trees connect, a final curvature-aware shortcutting post-processing is performed to maximize path smoothness and minimize length before returning the solution.>",
          "planning_mechanism": "The planner grows two trees from start and goal positions alternately, samples with a dynamic goal bias that decays over iterations to encourage exploration early and focus on refinement later, uses spatial hashing to speed up nearest neighbor and near node searches, applies curvature- and distance-aware incremental shortcutting after each successful expansion, and rewires nodes within an adaptive radius. Once the trees connect, a final curvature-aware shortcutting post-processing is performed to maximize path smoothness and minimize length before returning the solution.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except ValueError:\n            pass\n\n    def path_from_root(self):\n        node, path = self, []\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=4000, step_size=7.0, base_radius=20.0,\n                 shortcut_iterations=60, initial_goal_sample_rate=0.2, min_goal_sample_rate=0.05,\n                 spatial_hash_cell_size=10.0):\n        # step_size increased for faster coverage; base_radius tuned for dimension and step size\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.base_radius = base_radius\n        self.shortcut_iterations = shortcut_iterations\n        self.initial_goal_sample_rate = initial_goal_sample_rate\n        self.min_goal_sample_rate = min_goal_sample_rate\n        self.spatial_hash_cell_size = spatial_hash_cell_size\n\n    def plan(self, map) -> 'PlannerResult':\n        import random, math\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(fr, to):\n            d = dist(fr, to)\n            if d <= self.step_size:\n                return to\n            ratio = self.step_size / d\n            return tuple(fr[i] + (to[i] - fr[i]) * ratio for i in range(dim))\n\n        def is_in_obstacle(p):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d_ = obs\n                    px, py, pz = p\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d_:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    px, py = p\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(fr, to):\n            d = dist(fr, to)\n            resolution = min(1.0, self.step_size / 2.0)  # finer resolution for better collision detection\n            steps = max(1, int(d / resolution))\n            for i in range(steps + 1):\n                interp = tuple(fr[j] + (to[j] - fr[j]) * i / steps for j in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        # Spatial hashing for fast neighbor lookups\n        class SpatialHash:\n            def __init__(self, cell_size):\n                self.cell_size = cell_size\n                self.cells = {}\n\n            def _hash_key(self, point):\n                return tuple(int(coord // self.cell_size) for coord in point)\n\n            def insert(self, node):\n                key = self._hash_key(node.position)\n                if key not in self.cells:\n                    self.cells[key] = []\n                self.cells[key].append(node)\n\n            def neighbors(self, point, radius):\n                r_cell = int(math.ceil(radius / self.cell_size))\n                base_key = self._hash_key(point)\n                result = []\n                for dx in range(-r_cell, r_cell + 1):\n                    for dy in range(-r_cell, r_cell + 1):\n                        if dim == 2:\n                            key = (base_key[0] + dx, base_key[1] + dy)\n                            if key in self.cells:\n                                result.extend(self.cells[key])\n                        else:  # 3D\n                            for dz in range(-r_cell, r_cell + 1):\n                                key = (base_key[0] + dx, base_key[1] + dy, base_key[2] + dz)\n                                if key in self.cells:\n                                    result.extend(self.cells[key])\n                return result\n\n        start_spatial_hash = SpatialHash(self.spatial_hash_cell_size)\n        goal_spatial_hash = SpatialHash(self.spatial_hash_cell_size)\n        start_spatial_hash.insert(start_tree[0])\n        goal_spatial_hash.insert(goal_tree[0])\n\n        def nearest(tree, spatial_hash, point):\n            candidates = spatial_hash.neighbors(point, self.step_size * 5)\n            if not candidates:\n                return min(tree, key=lambda node: dist(node.position, point))\n            return min(candidates, key=lambda node: dist(node.position, point))\n\n        def near_nodes(tree, spatial_hash, point, radius):\n            candidates = spatial_hash.neighbors(point, radius)\n            r2 = radius * radius\n            result = []\n            for node in candidates:\n                cd = 0.0\n                for i in range(dim):\n                    d = node.position[i] - point[i]\n                    cd += d * d\n                    if cd > r2:\n                        break\n                else:\n                    result.append(node)\n            return result\n\n        def adaptive_radius(tree_size):\n            n = max(tree_size, 2)\n            gamma = self.base_radius\n            radius = gamma * (math.log(n) / n) ** (1.0 / dim)\n            return max(radius, self.step_size * 1.5)\n\n        def rewire(tree, spatial_hash, new_node, near_nodes_):\n            nonlocal edges\n            for near in near_nodes_:\n                if near == new_node.parent:\n                    continue\n                edge_cost = dist(new_node.position, near.position)\n                new_cost = new_node.cost + edge_cost\n                if new_cost + 1e-8 < near.cost:\n                    if not is_edge_in_obstacle(new_node.position, near.position):\n                        # remove old edge\n                        if near.parent is not None:\n                            try:\n                                edges.remove((near.parent, near))\n                                near.parent.remove_child(near)\n                            except Exception:\n                                pass\n                        near.parent = new_node\n                        near.cost = new_cost\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n\n        def extract_path(node_start, node_goal):\n            path_start = node_start.path_from_root()\n            path_goal = node_goal.path_from_root()[::-1]\n            if len(path_start) > 0 and len(path_goal) > 0 and path_start[-1] == path_goal[0]:\n                path_goal = path_goal[1:]\n            return path_start + path_goal\n\n        # Curvature-aware shortcutting tries to avoid shortcuts creating sharp angles by checking angles between path segments\n        def curvature_aware_shortcut(path):\n            if len(path) < 3:\n                return path[:]\n            new_path = path[:]\n            attempts = 0\n            max_attempts = self.shortcut_iterations\n            def angle_between(a, b, c):\n                import math\n                v1 = [a[i] - b[i] for i in range(dim)]\n                v2 = [c[i] - b[i] for i in range(dim)]\n                dot = sum(v1[i] * v2[i] for i in range(dim))\n                norm1 = math.sqrt(sum(x * x for x in v1))\n                norm2 = math.sqrt(sum(x * x for x in v2))\n                if norm1 < 1e-8 or norm2 < 1e-8:\n                    return 0.0\n                cos_theta = max(-1.0, min(1.0, dot / (norm1 * norm2)))\n                return math.acos(cos_theta)\n\n            while attempts < max_attempts and len(new_path) >= 3:\n                i = random.randint(0, len(new_path) - 3)\n                j = random.randint(i + 2, len(new_path) - 1)\n                p1, p2 = new_path[i], new_path[j]\n                if not is_edge_in_obstacle(p1, p2):\n                    # Check angle criterion: shortcut should not create sharp turns\n                    # Evaluate angles before and after shortcut\n                    # Angle at p1's predecessor and p2's successor if applicable, else accept\n                    accept = True\n                    if i > 0:\n                        a = new_path[i - 1]\n                        b = new_path[i]\n                        c = p2\n                        if angle_between(a, b, c) > math.pi * 140 / 180:\n                            accept = False\n                    if j < len(new_path) - 1 and accept:\n                        a = p1\n                        b = p2\n                        c = new_path[j + 1]\n                        if angle_between(a, b, c) > math.pi * 140 / 180:\n                            accept = False\n                    if accept:\n                        new_path = new_path[:i + 1] + new_path[j:]\n                        attempts = 0\n                        continue\n                attempts += 1\n            return new_path\n\n        success = False\n        connection_node_start = None\n        connection_node_goal = None\n\n        def dynamic_goal_sample_rate(iteration):\n            # Decays from initial to minimal to favor exploration early then exploitation late\n            decay_rate = 0.9995\n            rate = max(self.min_goal_sample_rate,\n                       self.initial_goal_sample_rate * (decay_rate ** iteration))\n            return rate\n\n        for it in range(self.max_iter):\n            for (tree_a, tree_b, spatial_hash_a, spatial_hash_b) in [\n                (start_tree, goal_tree, start_spatial_hash, goal_spatial_hash),\n                (goal_tree, start_tree, goal_spatial_hash, start_spatial_hash)\n            ]:\n                goal_sample = random.random()\n                sample_p = goal_pos if goal_sample < dynamic_goal_sample_rate(it) else tuple(random.uniform(0, bounds[i]) for i in range(dim))\n\n                nearest_node = nearest(tree_a, spatial_hash_a, sample_p)\n                new_pos = steer(nearest_node.position, sample_p)\n                if is_in_obstacle(new_pos):\n                    continue\n                if is_edge_in_obstacle(nearest_node.position, new_pos):\n                    continue\n\n                radius = adaptive_radius(len(tree_a))\n                near_nds = near_nodes(tree_a, spatial_hash_a, new_pos, radius)\n\n                min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n                min_parent = nearest_node\n\n                for near_node in near_nds:\n                    candidate_cost = near_node.cost + dist(near_node.position, new_pos)\n                    if candidate_cost < min_cost:\n                        if not is_edge_in_obstacle(near_node.position, new_pos):\n                            min_cost = candidate_cost\n                            min_parent = near_node\n\n                new_node = Node(new_pos, parent=min_parent, cost=min_cost)\n                min_parent.add_child(new_node)\n                tree_a.append(new_node)\n                spatial_hash_a.insert(new_node)\n                nodes.append(new_node)\n                edges.append((min_parent, new_node))\n\n                rewire(tree_a, spatial_hash_a, new_node, near_nds)\n\n                nearest_in_other = nearest(tree_b, spatial_hash_b, new_node.position)\n                dist_to_other = dist(new_node.position, nearest_in_other.position)\n                radius_connect = max(self.step_size * 2.0, adaptive_radius(len(tree_b)))\n                if dist_to_other <= radius_connect and not is_edge_in_obstacle(new_node.position, nearest_in_other.position):\n                    if tree_a is start_tree:\n                        connection_node_start, connection_node_goal = new_node, nearest_in_other\n                    else:\n                        connection_node_start, connection_node_goal = nearest_in_other, new_node\n                    success = True\n                    break\n\n                # Incremental smoothing after each successful addition to improve ongoing quality\n                if len(tree_a) > 10 and (iters := it % 10) == 0:\n                    if success:\n                        raw_path = extract_path(connection_node_start, connection_node_goal)\n                        smoothed = curvature_aware_shortcut(raw_path)\n                        # We don't reconstruct tree with smoothed path here to save time,\n                        # only update when path is final.\n                    else:\n                        # optionally find partial connection and locally smooth it - omitted for efficiency\n                        pass\n\n            if success:\n                break\n\n        path = []\n        if success:\n            raw_path = extract_path(connection_node_start, connection_node_goal)\n            path = curvature_aware_shortcut(raw_path)\n\n        return PlannerResult(success, path, nodes, edges)",
          "objective": -25.95988,
          "time_improvement": 51.0,
          "length_improvement": 12.0,
          "smoothness_improvement": 720.0,
          "node_improvement": 77.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.012157535552978516,
                    "num_nodes_avg": 76.7,
                    "path_length_avg": 177.8581226648225,
                    "smoothness_avg": 0.021087324793900714,
                    "success_improvement": 0.0,
                    "time_improvement": 52.8609792511174,
                    "node_improvement": 80.68496600352556,
                    "length_improvement": 2.513144625103157,
                    "smoothness_improvement": 230.06242488326026,
                    "objective_score": 18.516492674813417
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.030826902389526366,
                    "num_nodes_avg": 241.0,
                    "path_length_avg": 247.86526510463995,
                    "smoothness_avg": 0.04283079794323684,
                    "success_improvement": 0.0,
                    "time_improvement": 81.38198823053047,
                    "node_improvement": 83.80702815292615,
                    "length_improvement": 17.255440101993035,
                    "smoothness_improvement": 1002.0672808562852,
                    "objective_score": 39.778196934636384
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.0414315938949585,
                    "num_nodes_avg": 252.7,
                    "path_length_avg": 126.87042114600574,
                    "smoothness_avg": 0.08073447814405814,
                    "success_improvement": 0.0,
                    "time_improvement": 18.356854691892046,
                    "node_improvement": 67.87031150667514,
                    "length_improvement": 15.73870719507012,
                    "smoothness_improvement": 926.9366027931255,
                    "objective_score": 19.58496373857531
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m1",
          "algorithm_description": "A bidirectional RRT* planner with adaptive informed sampling, dynamic rewiring radius, and integrated incremental shortcutting combined with a hierarchical global smoothing strategy using cubic spline fitting and adaptive collision-aware resampling to efficiently find smooth, short, and collision-free paths with reduced planning time and enhanced robustness. The planner alternates tree growth from start and goal, connects trees optimally, rewires locally to optimize costs, uses ellipsoidal informed sampling to focus exploration, and applies multi-scale smoothing directly on the path during planning to incrementally improve smoothness and length while maintaining validity.",
          "planning_mechanism": "The planning mechanism combines bidirectional RRT* tree growth with adaptive rewiring radius adjusting to node density and best path cost, mixing uniform and ellipsoidal informed sampling to bias sampling towards promising regions. Upon connecting trees, the current best path is incrementally shortcut and then periodically smoothed globally via cubic spline fitting with collision-aware adaptive resampling, iteratively refining the path shape without excessive computational overhead. Collision checks are efficiently integrated into node and edge validation to ensure safety throughout. Tree structures maintain coherent parent-child relations enabling fast path extraction and updates.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n    def add_child(self, child):\n        self.children.append(child)\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except ValueError:\n            pass\nclass Planner:\n    def __init__(self, max_iter=6000, step_size=6.0, goal_sample_rate=0.08,\n                 uniform_sample_rate=0.3, r_min=5.0, r_max=35.0,\n                 shortcut_attempts=30, global_smooth_freq=120):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.uniform_sample_rate = uniform_sample_rate\n        self.r_min = r_min\n        self.r_max = r_max\n        self.shortcut_attempts = shortcut_attempts\n        self.global_smooth_freq = global_smooth_freq\n\n    def plan(self, map):\n        import math\n        import random\n\n        bounds = map.size\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        obstacles = map.obstacles\n        start_pos = map.start\n        goal_pos = map.goal\n\n        nodes_start = [Node(start_pos, None, 0.0)]\n        nodes_goal = [Node(goal_pos, None, 0.0)]\n        nodes = nodes_start + nodes_goal\n        edges = []\n\n        best_cost = float('inf')\n        solution_nodes = (None, None)\n        improved_since_last_global_smooth = False\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def is_in_obstacle(pos):\n            px = pos[0]\n            py = pos[1]\n            pz = pos[2] if is_3d else 0.0\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(a, b, resolution=0.3):\n            dist_ab = dist(a, b)\n            steps = max(1, int(dist_ab / resolution))\n            for i in range(steps + 1):\n                t = i / steps\n                interm = tuple(a[j] + t * (b[j] - a[j]) for j in range(dim))\n                if is_in_obstacle(interm):\n                    return True\n            return False\n\n        def nearest(tree, point):\n            best_node = None\n            best_dist = float('inf')\n            for node in tree:\n                d = dist(node.position, point)\n                if d < best_dist:\n                    best_dist = d\n                    best_node = node\n            return best_node\n\n        def near(tree, point, radius):\n            radius_sq = radius * radius\n            res = []\n            for node in tree:\n                d_sq = 0.0\n                for i in range(dim):\n                    diff = node.position[i] - point[i]\n                    d_sq += diff*diff\n                if d_sq <= radius_sq:\n                    res.append(node)\n            return res\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            ratio = self.step_size / d\n            return tuple(from_pos[i] + ratio*(to_pos[i]-from_pos[i]) for i in range(dim))\n\n        def compute_ellipsoid_params():\n            c_min = dist(start_pos, goal_pos)\n            if c_min < 1e-14:\n                return None\n            center = tuple((start_pos[i]+goal_pos[i])*0.5 for i in range(dim))\n            direction = [goal_pos[i]-start_pos[i] for i in range(dim)]\n            length = c_min\n            e1 = [d/length for d in direction]\n            if dim == 2:\n                e2 = (-e1[1], e1[0])\n                basis = [e1, e2]\n            else:\n                v = [1,0,0] if abs(e1[0])<0.9 else [0,1,0]\n                for i in range(dim):\n                    proj = sum(v[j]*e1[j] for j in range(dim))\n                    v[i] -= proj*e1[i]\n                norm_v = math.sqrt(sum(x*x for x in v))\n                if norm_v < 1e-15:\n                    v = [0.0]*dim\n                    v[-1] = 1.0\n                    norm_v = 1.0\n                u = [x/norm_v for x in v]\n                if dim == 3:\n                    w = [e1[1]*u[2]-e1[2]*u[1],\n                         e1[2]*u[0]-e1[0]*u[2],\n                         e1[0]*u[1]-e1[1]*u[0]]\n                    basis = [e1, u, w]\n                else:\n                    basis = [e1, u]\n            a1 = best_cost*0.5\n            b_sq = max(best_cost*best_cost - c_min*c_min, 1e-12)*0.25\n            b = math.sqrt(b_sq)\n            return center, basis, a1, b\n\n        def sample():\n            # Mix uniform and ellipsoidal informed sampling\n            if best_cost == float('inf'):\n                while True:\n                    if random.random() < self.goal_sample_rate:\n                        pt = goal_pos\n                    else:\n                        pt = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                    if not is_in_obstacle(pt):\n                        return pt\n            if random.random() < self.uniform_sample_rate:\n                if random.random() < self.goal_sample_rate:\n                    return goal_pos\n                while True:\n                    pt = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                    if not is_in_obstacle(pt):\n                        return pt\n            params = compute_ellipsoid_params()\n            if params is None:\n                while True:\n                    pt = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                    if not is_in_obstacle(pt):\n                        return pt\n            center, basis, a1, b = params\n            while True:\n                if dim == 2:\n                    r = random.uniform(0, 1)**0.5\n                    theta = random.uniform(0, 2*math.pi)\n                    u_ball = [r*math.cos(theta), r*math.sin(theta)]\n                    coords = [a1*u_ball[0], b*u_ball[1]]\n                    pt = tuple(center[i]+sum(coords[j]*basis[j][i] for j in range(dim)) for i in range(dim))\n                else:\n                    while True:\n                        u_ball = [random.uniform(-1,1) for _ in range(3)]\n                        norm_sq = sum(x*x for x in u_ball)\n                        if 0 < norm_sq <= 1:\n                            break\n                    norm_ub = math.sqrt(norm_sq)\n                    unit_ball = [x/norm_ub for x in u_ball]\n                    coords = [a1*unit_ball[0], b*unit_ball[1], b*unit_ball[2]]\n                    pt = tuple(center[i] + sum(coords[j]*basis[j][i] for j in range(dim)) for i in range(dim))\n                if any(pt[i]<0 or pt[i]>bounds[i] for i in range(dim)):\n                    continue\n                if is_in_obstacle(pt):\n                    continue\n                return pt\n\n        def rewiring_radius(n_nodes):\n            if n_nodes < 2:\n                return self.r_max\n            base = 2*((math.log(n_nodes)/n_nodes)**(1/dim))*self.step_size\n            ratio = 1.0\n            if best_cost < float('inf') and best_cost > 0.0:\n                ratio = max(0.35, min(1.0, (best_cost/(dist(start_pos, goal_pos)*3))))\n            radius = base*ratio\n            return max(self.r_min, min(self.r_max, radius))\n\n        def extract_path(node_start, node_goal):\n            path_start = []\n            cur = node_start\n            while cur is not None:\n                path_start.append(cur.position)\n                cur = cur.parent\n            path_goal = []\n            cur = node_goal\n            while cur is not None:\n                path_goal.append(cur.position)\n                cur = cur.parent\n            return path_start[::-1] + path_goal\n\n        def incremental_shortcut(path):\n            if len(path) < 3:\n                return path[:]\n            new_path = path[:]\n            attempts = 0\n            while attempts < self.shortcut_attempts:\n                if len(new_path) < 3:\n                    break\n                i = random.randint(0,len(new_path)-3)\n                j = random.randint(i+2,len(new_path)-1)\n                if not is_edge_in_obstacle(new_path[i], new_path[j], resolution=0.3):\n                    new_path = new_path[:i+1] + new_path[j:]\n                    attempts = 0\n                else:\n                    attempts += 1\n            return new_path\n\n        def _fit_cubic_spline_with_collision_check(path, max_res, node_in_obs_func, edge_collide_func):\n            n = len(path)\n            if n < 4:\n                return path[:]\n            tvals = [0.0]\n            for i in range(1,n):\n                tvals.append(tvals[-1] + dist(path[i], path[i-1]))\n            dim = len(path[0])\n            def solve_tridiag(xs, ys):\n                n_sub = len(xs)\n                h = [xs[i+1]-xs[i] for i in range(n_sub-1)]\n                al = [0]*n_sub\n                for i in range(1,n_sub-1):\n                    al[i] = 3*((ys[i+1]-ys[i])/h[i] - (ys[i]-ys[i-1])/h[i-1])\n                l = [1]*n_sub\n                mu = [0]*n_sub\n                z = [0]*n_sub\n                for i in range(1,n_sub-1):\n                    l[i] = 2*(xs[i+1]-xs[i-1]) - h[i-1]*mu[i-1]\n                    mu[i] = h[i]/l[i]\n                    z[i] = (al[i]-h[i-1]*z[i-1])/l[i]\n                b = [0]*(n_sub-1)\n                c = [0]*n_sub\n                d = [0]*(n_sub-1)\n                c[n_sub-1] = 0\n                for j in reversed(range(n_sub-1)):\n                    c[j] = z[j] - mu[j]*c[j+1]\n                    b[j] = (ys[j+1]-ys[j])/h[j] - h[j]*(c[j+1] + 2*c[j])/3\n                    d[j] = (c[j+1]-c[j])/(3*h[j])\n                return list(zip(ys[:-1], b, c[:-1], d, xs[:-1]))\n            splines = []\n            for axis in range(dim):\n                splines.append(solve_tridiag(tvals, [p[axis] for p in path]))\n            sample_pts = []\n            for seg_i in range(n-1):\n                seg_len = tvals[seg_i+1]-tvals[seg_i]\n                samples_num = max(2,int(math.ceil(seg_len/max_res)))\n                for si in range(samples_num):\n                    tau = seg_len*(si/samples_num)\n                    pt_coords = []\n                    for axis in range(dim):\n                        y,a,b,c,xs = splines[axis][seg_i]\n                        val = y + a*tau + b*tau*tau + c*tau*tau*tau\n                        pt_coords.append(val)\n                    pt = tuple(pt_coords)\n                    if node_in_obs_func(pt):\n                        return None\n                    if len(sample_pts) > 0:\n                        if edge_collide_func(sample_pts[-1], pt):\n                            return None\n                    sample_pts.append(pt)\n            sample_pts.append(path[-1])\n            return sample_pts\n\n        def global_smooth(path):\n            path_s = incremental_shortcut(path)\n            smoothed = self._fit_cubic_spline_with_collision_check(path_s, max_res=self.step_size/2,\n                                                                   node_in_obs_func=is_in_obstacle,\n                                                                   edge_collide_func=is_edge_in_obstacle)\n            return smoothed if smoothed is not None else path_s\n\n        self._fit_cubic_spline_with_collision_check = _fit_cubic_spline_with_collision_check\n\n        for it in range(self.max_iter):\n            sample_pos = sample()\n            tree, opp_tree = (nodes_start, nodes_goal) if it % 2 == 0 else (nodes_goal, nodes_start)\n\n            nearest_node = nearest(tree, sample_pos)\n            new_pos = steer(nearest_node.position, sample_pos)\n\n            if is_in_obstacle(new_pos):\n                continue\n            if is_edge_in_obstacle(nearest_node.position, new_pos):\n                continue\n\n            radius = rewiring_radius(len(tree))\n            near_nodes = near(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for candidate in near_nodes:\n                if candidate is nearest_node:\n                    continue\n                tentative_cost = candidate.cost + dist(candidate.position, new_pos)\n                if tentative_cost < min_cost and not is_edge_in_obstacle(candidate.position, new_pos):\n                    min_cost = tentative_cost\n                    best_parent = candidate\n\n            new_node = Node(new_pos, best_parent, min_cost)\n            best_parent.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            for nbr in near_nodes:\n                if nbr is best_parent or nbr is new_node:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, nbr.position)\n                if new_cost < nbr.cost and not is_edge_in_obstacle(new_node.position, nbr.position):\n                    if nbr.parent is not None:\n                        try:\n                            edges.remove((nbr.parent, nbr))\n                        except ValueError:\n                            pass\n                        nbr.parent.remove_child(nbr)\n                    nbr.parent = new_node\n                    nbr.cost = new_cost\n                    new_node.add_child(nbr)\n                    edges.append((new_node, nbr))\n\n            nearest_other = nearest(opp_tree, new_pos)\n            dist_connect = dist(new_pos, nearest_other.position)\n            connect_thresh = min(self.step_size*1.5, rewiring_radius(len(tree)))\n            if dist_connect <= connect_thresh and not is_edge_in_obstacle(new_pos, nearest_other.position):\n                total_cost = new_node.cost + dist_connect + nearest_other.cost\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    solution_nodes = (new_node, nearest_other) if it % 2 == 0 else (nearest_other, new_node)\n                    raw_path = extract_path(solution_nodes[0], solution_nodes[1])\n                    smoothed_path = incremental_shortcut(raw_path)\n                    improved_since_last_global_smooth = True\n                    if smoothed_path and len(smoothed_path) >= 2:\n                        if it % self.global_smooth_freq == 0:\n                            smoothed_path = global_smooth(smoothed_path)\n                        return PlannerResult(True, smoothed_path, nodes, edges)\n\n            if improved_since_last_global_smooth and it % self.global_smooth_freq == 0 and best_cost < float('inf'):\n                raw_path = extract_path(solution_nodes[0], solution_nodes[1])\n                smoothed_path = global_smooth(raw_path)\n                if smoothed_path and len(smoothed_path) >= 2:\n                    improved_since_last_global_smooth = False\n                    return PlannerResult(True, smoothed_path, nodes, edges)\n\n        if solution_nodes[0] is not None and solution_nodes[1] is not None:\n            raw_path = extract_path(solution_nodes[0], solution_nodes[1])\n            smoothed_path = incremental_shortcut(raw_path)\n            smoothed_path = global_smooth(smoothed_path)\n            return PlannerResult(True, smoothed_path, nodes, edges)\n\n        return PlannerResult(False, [], nodes, edges)",
          "objective": -25.95136,
          "time_improvement": 39.0,
          "length_improvement": 12.0,
          "smoothness_improvement": 1412.0,
          "node_improvement": 70.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.03306083679199219,
                    "num_nodes_avg": 184.6,
                    "path_length_avg": 175.21355587741243,
                    "smoothness_avg": 0.04174022676119999,
                    "success_improvement": 0.0,
                    "time_improvement": -28.18843627657166,
                    "node_improvement": 53.5129690254344,
                    "length_improvement": 3.9626735871250407,
                    "smoothness_improvement": 553.3251891659409,
                    "objective_score": -3.312300784866769
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.02645876407623291,
                    "num_nodes_avg": 242.2,
                    "path_length_avg": 242.6251428469655,
                    "smoothness_avg": 0.0925394133445688,
                    "success_improvement": 0.0,
                    "time_improvement": 84.02014011163544,
                    "node_improvement": 83.72639924746355,
                    "length_improvement": 19.004743740161032,
                    "smoothness_improvement": 2281.105758801035,
                    "objective_score": 48.01441707159243
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.020299816131591798,
                    "num_nodes_avg": 225.3,
                    "path_length_avg": 130.11694490709587,
                    "smoothness_avg": 0.11797247222978921,
                    "success_improvement": 0.0,
                    "time_improvement": 59.998139527017024,
                    "node_improvement": 71.35410044500954,
                    "length_improvement": 13.582520695802794,
                    "smoothness_improvement": 1400.6011389408163,
                    "objective_score": 33.15195997029086
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e1",
          "algorithm_description": "A novel bidirectional anytime RRT* variant employing an adaptive lazy collision checking strategy combined with an incremental cover tree for efficient nearest-neighbor queries. The algorithm uses goal-biased and informed sampling with rejection sampling limited by collision checks. Rewiring leverages a dynamically scaled neighborhood radius without strict curvature penalties to allow aggressive cost reduction. Edge and node collision checks are delayed until necessary to minimize expensive tests. The planner maintains anytime path improvement using incremental shortcutting during runtime and final iterative midpoint smoothing to enhance smoothness and shorten path length. It implements early stopping based on solution stability to reduce planning time.",
          "planning_mechanism": "The planner expands two trees simultaneously from start and goal nodes using samples drawn from a hybrid of uniform and informed distributions, rapidly connecting through incremental connections facilitated by a cover tree data structure that supports fast approximate nearest neighbor queries and dynamic radius updates. Lazy collision checking postpones collision tests until a promising edge or rewire candidate is identified, substantially reducing computational overhead. The method performs rewiring with an adaptive radius depending on node density and best path cost to accelerate convergence and improve solution quality. The found path undergoes incremental shortcut passes interleaved with the planning, followed by a final smoothing stage shifting vertices toward midpoints if collision-free. The algorithm terminates early if the solution cost remains stable for a predefined patience period.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n    def add_child(self, child):\n        self.children.append(child)\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=3500, step_size=6.0, r_min=6.0, r_max=28.0,\n                 goal_sample_rate=0.12, uniform_sample_rate=0.1,\n                 shortcut_interval=30, shortcut_passes=5, shortcut_attempts=120,\n                 smooth_iters=8, early_stop_patience=50):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.r_min = r_min\n        self.r_max = r_max\n        self.goal_sample_rate = goal_sample_rate\n        self.uniform_sample_rate = uniform_sample_rate\n        self.shortcut_interval = shortcut_interval\n        self.shortcut_passes = shortcut_passes\n        self.shortcut_attempts = shortcut_attempts\n        self.smooth_iters = smooth_iters\n        self.early_stop_patience = early_stop_patience\n\n    def plan(self, map):\n        import random\n        import math\n\n        bounds = map.size\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        start = tuple(map.start)\n        goal = tuple(map.goal)\n        obstacles = map.obstacles\n\n        def in_bounds(p):\n            for i in range(dim):\n                if p[i] < 0.0 or p[i] > bounds[i]:\n                    return False\n            return True\n\n        def node_collision(p):\n            px, py = p[0], p[1]\n            pz = p[2] if is_3d else 0.0\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d = obs\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                        return True\n                else:\n                    x,y,w,h = obs\n                    if x <= px <= x+w and y <= py <= y+h:\n                        return True\n            return False\n\n        def edge_collision(a, b, res=1.0):\n            d = math.dist(a,b)\n            if d < 1e-12:\n                return False\n            steps = max(1, int(d / res))\n            for i in range(steps+1):\n                t = i / float(steps)\n                pt = tuple(a[j] + (b[j]-a[j])*t for j in range(dim))\n                if node_collision(pt):\n                    return True\n            return False\n\n        def steer(frm, to):\n            d = math.dist(frm,to)\n            if d <= self.step_size:\n                return to\n            ratio = self.step_size / d\n            return tuple(frm[i] + (to[i]-frm[i])*ratio for i in range(dim))\n\n        # Adaptive radius scales with node count & best cost to allow flexible rewiring\n        def adaptive_radius(n, best_cost):\n            if n < 2:\n                return self.r_max\n            val = 28.0 * (math.log(n)/n) ** (1.0/dim)\n            if best_cost < float('inf'):\n                val = min(val, best_cost*0.13)\n            return max(self.r_min, min(self.r_max, val))\n\n        # Lazy Collision cache: stores tested edges and node collisions\n        collision_cache_nodes = {}\n        collision_cache_edges = {}\n\n        def cache_node_free(p):\n            if p in collision_cache_nodes:\n                return collision_cache_nodes[p]\n            free = not node_collision(p)\n            collision_cache_nodes[p] = free\n            return free\n\n        def cache_edge_free(a,b):\n            key = (a,b) if a < b else (b,a)\n            if key in collision_cache_edges:\n                return collision_cache_edges[key]\n            free = not edge_collision(a,b)\n            collision_cache_edges[key] = free\n            return free\n\n        # Incremental cover tree structure for efficient neighbor queries\n        class CoverNode:\n            __slots__ = ('point','node_ref','children','level')\n            def __init__(self, point, node_ref, level):\n                self.point = point\n                self.node_ref = node_ref\n                self.children = []\n                self.level = level\n\n        class CoverTree:\n            def __init__(self, points_nodes=[]):\n                self.max_level = 0\n                self.min_level = 0\n                self.root = None\n                for p,n in points_nodes:\n                    self.insert(p,n)\n\n            def distance(self,a,b):\n                return math.dist(a,b)\n\n            def insert(self, point, node_ref):\n                if self.root is None:\n                    self.root = CoverNode(point,node_ref,0)\n                    self.max_level = 0\n                    self.min_level = 0\n                    return\n                curr = self.root\n                level = self.max_level\n                while True:\n                    d = self.distance(point,curr.point)\n                    cover_radius = 2 ** level\n                    if d > cover_radius:\n                        level += 1\n                        if level > self.max_level:\n                            self.max_level = level\n                        # New root\n                        new_root = CoverNode(point,node_ref,level)\n                        new_root.children.append(self.root)\n                        self.root = new_root\n                        return\n                    found_child = False\n                    for c in curr.children:\n                        if self.distance(point, c.point) <= 2 ** (level-1):\n                            curr = c\n                            level -= 1\n                            found_child = True\n                            break\n                    if not found_child:\n                        new_node = CoverNode(point,node_ref,level-1)\n                        curr.children.append(new_node)\n                        if level-1 < self.min_level:\n                            self.min_level = level-1\n                        return\n\n            # Approximate nearest neighbor search (descend cover tree)\n            def nearest(self, point):\n                best = None\n                best_dist = float('inf')\n                def search(curnode):\n                    nonlocal best,best_dist\n                    d = self.distance(point, curnode.point)\n                    if d < best_dist:\n                        best_dist = d\n                        best = curnode\n                    cover_r = 2**curnode.level\n                    for c in curnode.children:\n                        dc = self.distance(point, c.point)\n                        if dc - cover_r <= best_dist:\n                            search(c)\n                if self.root is not None:\n                    search(self.root)\n                return best.node_ref if best else None\n\n            # Radius search returning all nodes within radius,\n            # pruning by cover tree properties\n            def radius_search(self, point, radius):\n                res = []\n                radius_sq = radius*radius\n                def search(curnode):\n                    d = self.distance(point, curnode.point)\n                    if d <= radius:\n                        res.append(curnode.node_ref)\n                    cover_r = 2**curnode.level\n                    for c in curnode.children:\n                        dc = self.distance(point, c.point)\n                        if dc - cover_r <= radius:\n                            search(c)\n                if self.root is not None:\n                    search(self.root)\n                return res\n\n            # Rebuild cover tree with new points\n            def rebuild(self, points_nodes):\n                self.root = None\n                self.max_level = 0\n                self.min_level = 0\n                for p,n in points_nodes:\n                    self.insert(p,n)\n\n        # Hybrid sampling: goal bias, uniform, then informed elliptical sampling if solution exists\n        def dist(p1,p2):\n            return math.dist(p1,p2)\n\n        def informed_sample(c_best):\n            if c_best == float('inf'):\n                return tuple(random.uniform(0,bounds[i]) for i in range(dim))\n            c_min = dist(start, goal)\n            if c_best < c_min:\n                c_best = c_min\n            center = tuple((start[i] + goal[i])*0.5 for i in range(dim))\n            a1 = tuple((goal[i]-start[i])/c_min for i in range(dim))\n\n            # Orthonormal basis Gram-Schmidt\n            basis = [a1]\n            for i_dim in range(dim):\n                vec = [0.0]*dim\n                vec[i_dim] = 1.0\n                for b in basis:\n                    proj = sum(vec[j]*b[j] for j in range(dim))\n                    for j in range(dim):\n                        vec[j] -= proj*b[j]\n                norm = math.sqrt(sum(x*x for x in vec))\n                if norm > 1e-10:\n                    basis.append([x/norm for x in vec])\n                if len(basis) == dim:\n                    break\n            basis = basis[:dim]\n\n            r1 = c_best/2.0\n            val = c_best*c_best - c_min*c_min\n            r_rest = math.sqrt(val)*0.5 if val > 0 else 0.0\n\n            # sample in unit ball\n            while True:\n                x = [random.gauss(0,1) for _ in range(dim)]\n                norm_x = math.sqrt(sum(xx*xx for xx in x))\n                if norm_x > 1e-10:\n                    break\n            x_unit = [xx / norm_x for xx in x]\n            scale = random.uniform(0,1) ** (1.0/dim)\n            x_ball = [scale * v for v in x_unit]\n\n            mapped = [0.0]*dim\n            for i in range(dim):\n                for j in range(dim):\n                    mapped[i] += basis[j][i]*([r1] + [r_rest]*(dim-1))[j] * x_ball[j]\n\n            pt = tuple(center[i] + mapped[i] for i in range(dim))\n            clamped = tuple(max(0.0,min(pt[i], bounds[i])) for i in range(dim))\n            return clamped\n\n        def sample_point(c_best):\n            prob = random.random()\n            if prob < self.goal_sample_rate:\n                if cache_node_free(goal):\n                    return goal\n            if prob < self.goal_sample_rate + self.uniform_sample_rate or c_best == float('inf'):\n                for _ in range(15):\n                    p = tuple(random.uniform(0,bounds[i]) for i in range(dim))\n                    if cache_node_free(p):\n                        return p\n                # fallback if no free found\n                while True:\n                    p = tuple(random.uniform(0,bounds[i]) for i in range(dim))\n                    if cache_node_free(p):\n                        return p\n            for _ in range(20):\n                p = informed_sample(c_best)\n                if cache_node_free(p):\n                    return p\n            # fallback uniform\n            while True:\n                p = tuple(random.uniform(0,bounds[i]) for i in range(dim))\n                if cache_node_free(p):\n                    return p\n\n        # Extract path by concatenating two nodes' root paths with deduplication\n        def extract_path(n_start, n_goal):\n            path_s = n_start.path_from_root()\n            path_g = n_goal.path_from_root()\n            if path_s[-1] == path_g[-1]:\n                path_g = path_g[:-1]\n            return path_s + path_g[::-1]\n\n        # Incremental shortcutting interleaved during planning\n        def shortcut_path(path, passes, attempts):\n            if len(path) < 3:\n                return path[:]\n            pth = path[:]\n            for _ in range(passes):\n                changed = False\n                a_i = 0\n                att = 0\n                while att < attempts and a_i < len(pth)-2:\n                    b_i = random.randint(a_i+2,len(pth)-1)\n                    if cache_edge_free(pth[a_i], pth[b_i]):\n                        # shortcut possible\n                        pth = pth[:a_i+1] + pth[b_i:]\n                        changed = True\n                        a_i = 0\n                        att += 1\n                    else:\n                        a_i += 1\n                        att += 1\n                if not changed:\n                    break\n            return pth\n\n        # Final smoothing by midpoint moves if collision-free and improvement found\n        def smooth_path(path, iterations):\n            if len(path) < 4:\n                return path[:]\n            pts = list(path)\n            for _ in range(iterations):\n                improved = False\n                for i in range(1,len(pts)-1):\n                    a = pts[i-1]\n                    b = pts[i]\n                    c = pts[i+1]\n                    mid = tuple(0.5*(a[j]+c[j]) for j in range(dim))\n                    if not cache_node_free(mid):\n                        continue\n                    if cache_edge_free(a, mid) and cache_edge_free(mid, c):\n                        # Check if smoothing decreases length locally\n                        old_len = math.dist(a,b) + math.dist(b,c)\n                        new_len = math.dist(a,mid) + math.dist(mid,c)\n                        if new_len + 1e-9 < old_len:\n                            pts[i] = mid\n                            improved = True\n                if not improved:\n                    break\n            return pts\n\n        # Update node costs by BFS once parent changes\n        def update_costs(node):\n            from collections import deque\n            queue = deque([node])\n            while queue:\n                curr = queue.popleft()\n                for c in curr.children:\n                    c_new_cost = curr.cost + math.dist(curr.position, c.position)\n                    if c_new_cost + 1e-14 < c.cost:\n                        c.cost = c_new_cost\n                        queue.append(c)\n\n        # Lazy attempt to connect new nodes and rewire neighbors\n        def rewire(tree_nodes, cover_tree, newnode, radius):\n            neighbors = cover_tree.radius_search(newnode.position, radius)\n            for nbr in neighbors:\n                if nbr is newnode.parent:\n                    continue\n                new_cost = newnode.cost + math.dist(newnode.position, nbr.position)\n                if new_cost + 1e-14 < nbr.cost and cache_edge_free(newnode.position, nbr.position):\n                    # Reassign parent with no strict curvature check for agile improvements\n                    if nbr.parent:\n                        nbr.parent.remove_child(nbr)\n                    nbr.parent = newnode\n                    nbr.cost = new_cost\n                    newnode.add_child(nbr)\n                    update_costs(nbr)\n            return neighbors\n\n        # Build initial nodes and trees\n        start_node = Node(start,None,0.0)\n        goal_node = Node(goal,None,0.0)\n        tree_start = [start_node]\n        tree_goal = [goal_node]\n\n        # Cover trees for start and goal branches\n        cover_start = CoverTree([(start_node.position, start_node)])\n        cover_goal = CoverTree([(goal_node.position, goal_node)])\n\n        best_cost = float('inf')\n        best_pair = (None,None)\n        best_path = []\n        no_improve_cnt = 0\n\n        nodes_all = tree_start + tree_goal\n        edges_all = []\n\n        # Main planning loop\n        for iter_i in range(self.max_iter):\n            # Alternate expansion between start and goal trees\n            if iter_i % 2 == 0:\n                tree_a, tree_cover_a = tree_start, cover_start\n                tree_b, tree_cover_b = tree_goal, cover_goal\n            else:\n                tree_a, tree_cover_a = tree_goal, cover_goal\n                tree_b, tree_cover_b = tree_start, cover_start\n\n            q_rand = sample_point(best_cost)\n            nearest_node = tree_cover_a.nearest(q_rand)\n            if nearest_node is None:\n                continue\n            q_new_pos = steer(nearest_node.position, q_rand)\n            if not in_bounds(q_new_pos):\n                continue\n            if not cache_node_free(q_new_pos):\n                continue\n            # Lazy edge check postponed, do only if candidate parent\n            # But check edge to nearest_node eagerly here (since immediate)\n            if not cache_edge_free(nearest_node.position, q_new_pos):\n                continue\n\n            new_cost = nearest_node.cost + math.dist(nearest_node.position, q_new_pos)\n            q_new = Node(q_new_pos, nearest_node, new_cost)\n            nearest_node.add_child(q_new)\n            tree_a.append(q_new)\n            nodes_all.append(q_new)\n            edges_all.append((nearest_node, q_new))\n            tree_cover_a.insert(q_new_pos, q_new)\n\n            # Adaptive rewiring radius depends on current size and best cost\n            radius = adaptive_radius(len(tree_a), best_cost)\n            rewire(tree_a, tree_cover_a, q_new, radius)\n\n            # Attempt connect to opposite tree near q_new\n            near_other = tree_cover_b.nearest(q_new.position)\n            if near_other is not None:\n                dist_conn = math.dist(q_new.position, near_other.position)\n                # Connect threshold relaxed with radius for anytime improvements\n                threshold = max(self.step_size * 1.6, radius)\n                if dist_conn <= threshold and cache_edge_free(q_new.position, near_other.position):\n                    candidate_cost = q_new.cost + dist_conn + near_other.cost\n                    if candidate_cost + 1e-14 < best_cost:\n                        best_cost = candidate_cost\n                        best_pair = (q_new, near_other)\n                        raw_path = extract_path(best_pair[0], best_pair[1])\n                        # Anytime shortcutting incremental step\n                        shortened = shortcut_path(raw_path, self.shortcut_passes, self.shortcut_attempts)\n                        if (not best_path) or (len(shortened) < len(best_path)):\n                            best_path = shortened\n                            no_improve_cnt = 0\n                        else:\n                            no_improve_cnt +=1\n                    else:\n                        no_improve_cnt += 1\n                else:\n                    no_improve_cnt += 1\n            else:\n                no_improve_cnt += 1\n\n            # Periodic rebuilding cover trees for performance stability\n            if iter_i > 0 and iter_i % 50 == 0:\n                cover_start.rebuild([(n.position,n) for n in tree_start])\n                cover_goal.rebuild([(n.position,n) for n in tree_goal])\n\n            # Early stop if no improvement over patience\n            if best_path and no_improve_cnt >= self.early_stop_patience:\n                break\n\n        if best_path:\n            smoothed = smooth_path(best_path, self.smooth_iters)\n            return PlannerResult(True, smoothed, nodes_all, edges_all)\n        else:\n            return PlannerResult(False, [], nodes_all, edges_all)",
          "objective": -25.2934,
          "time_improvement": 35.0,
          "length_improvement": 12.0,
          "smoothness_improvement": 1504.0,
          "node_improvement": 66.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.030253791809082033,
                    "num_nodes_avg": 199.6,
                    "path_length_avg": 183.53499532831353,
                    "smoothness_avg": 0.05372424486945132,
                    "success_improvement": 0.0,
                    "time_improvement": -17.304540349158078,
                    "node_improvement": 49.73558297658021,
                    "length_improvement": -0.5984392375601633,
                    "smoothness_improvement": 740.9010962719202,
                    "objective_score": -1.8459201659239195
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.03470773696899414,
                    "num_nodes_avg": 289.3,
                    "path_length_avg": 237.79078662307307,
                    "smoothness_avg": 0.09570785169256846,
                    "success_improvement": 0.0,
                    "time_improvement": 79.03814508460205,
                    "node_improvement": 80.56171470805617,
                    "length_improvement": 20.618590996924894,
                    "smoothness_improvement": 2362.631959628963,
                    "objective_score": 47.895757921680364
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.029233217239379883,
                    "num_nodes_avg": 256.7,
                    "path_length_avg": 125.30394103003316,
                    "smoothness_avg": 0.11862623908375855,
                    "success_improvement": 0.0,
                    "time_improvement": 42.394400540100946,
                    "node_improvement": 67.361729179911,
                    "length_improvement": 16.779088700331812,
                    "smoothness_improvement": 1408.917005067257,
                    "objective_score": 29.830358407565654
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m1",
          "algorithm_description": "Enhanced Bidirectional RRT* with Adaptive Radius, Informed Sampling, Efficient Collision Checking, and B-Spline Path Smoothing for Improved Planning Efficiency, Path Length, and Notably Smooth and Feasible Paths",
          "planning_mechanism": "This planner employs a bidirectional RRT* framework with adaptive rewiring radius based on tree size for asymptotic optimality. It uses goal bias and informed sampling within an ellipsoidal subset to concentrate sampling in promising regions. It alternates between trees for balanced growth and rewires local neighborhoods to optimize paths continuously. After tree connection, it reconstructs the path and applies B-spline smoothing to produce smooth, curvature-continuous trajectories, while maintaining rigorous collision checks on nodes and edges. Early termination is triggered on successful connection to improve search efficiency.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        node, path = self, []\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=7.0, base_radius=20.0, goal_sample_rate=0.15, smoothing_degree=3, smoothing_points=100):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.base_radius = base_radius\n        self.goal_sample_rate = goal_sample_rate\n        self.smoothing_degree = smoothing_degree\n        self.smoothing_points = smoothing_points\n\n    def plan(self, map):\n        import math\n        import random\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        def dist(a,b):\n            return math.dist(a,b)\n\n        def steer(fr, to):\n            d = dist(fr, to)\n            if d <= self.step_size:\n                return to\n            ratio = self.step_size / d\n            return tuple(fr[i] + (to[i] - fr[i]) * ratio for i in range(dim))\n\n        def is_in_obstacle(p):\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d_ = obs\n                    px,py,pz = p\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d_:\n                        return True\n                else:\n                    x,y,w,h = obs\n                    px,py = p\n                    if x <= px <= x+w and y <= py <= y+h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(fr,to, resolution=1.0):\n            d = dist(fr,to)\n            steps = max(1, int(d / resolution))\n            for i in range(steps + 1):\n                interp = tuple(fr[j] + (to[j] - fr[j]) * i / steps for j in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: dist(node.position, point))\n\n        def near_nodes(tree, point, radius):\n            return [node for node in tree if dist(node.position, point) <= radius]\n\n        def rewire(tree, new_node, near_nodes_list):\n            nonlocal edges\n            for near in near_nodes_list:\n                if near == new_node.parent:\n                    continue\n                c = new_node.cost + dist(new_node.position, near.position)\n                if c + 1e-10 < near.cost and not is_edge_in_obstacle(new_node.position, near.position):\n                    old_parent = near.parent\n                    if old_parent:\n                        try:\n                            edges.remove((old_parent, near))\n                        except ValueError:\n                            pass\n                        old_parent.children.remove(near)\n                    near.parent = new_node\n                    near.cost = c\n                    new_node.add_child(near)\n                    edges.append((new_node, near))\n\n        def extract_path(node_start, node_goal):\n            path_start = node_start.path_from_root()\n            path_goal = node_goal.path_from_root()[::-1]\n            if len(path_start) > 0 and len(path_goal) > 0 and path_start[-1] == path_goal[0]:\n                path_goal = path_goal[1:]\n            return path_start + path_goal\n\n        def adaptive_radius(tree_size):\n            gamma = self.base_radius\n            n = max(tree_size, 1)\n            return max(gamma * (math.log(n)/n)**(1.0/dim), self.step_size*1.5)\n\n        def informed_sample(c_best, c_min, start, goal):\n            # If no solution found yet, sample uniformly\n            if c_best == float('inf'):\n                return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n            # Ellipsoidal informed sampling\n            import numpy as np\n            c = c_best\n            center = tuple((start[i] + goal[i])/2 for i in range(dim))\n            a1 = tuple((goal[i] - start[i])/c_min for i in range(dim))\n            if dim == 2:\n                # Build rotation matrix to align x-axis with a1\n                theta = math.atan2(a1[1], a1[0])\n                r = [[math.cos(theta), -math.sin(theta)],\n                     [math.sin(theta),  math.cos(theta)]]\n                while True:\n                    # Sample uniformly in unit circle\n                    x, y = random.random()*2 -1, random.random()*2 -1\n                    if x**2 + y**2 > 1: \n                        continue\n                    # Scale according to ellipse axes\n                    rx = c/2\n                    ry = math.sqrt(c**2 - c_min**2)/2\n                    sample_ellipse = (x*rx, y*ry)\n                    # Rotate and translate sample\n                    px = r[0][0]*sample_ellipse[0] + r[0][1]*sample_ellipse[1] + center[0]\n                    py = r[1][0]*sample_ellipse[0] + r[1][1]*sample_ellipse[1] + center[1]\n                    if 0 <= px <= bounds[0] and 0 <= py <= bounds[1]:\n                        return (px, py)\n            else:  # In 3D or higher, fallback uniform sampling due to complexity\n                return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n\n        # B-spline smoothing using De Boor's algorithm (degree=3) for smoothness enhancement\n        def bspline(points, degree=3, num=100):\n            if len(points) <= degree:\n                return points[:]\n            import numpy as np\n            points_np = np.array(points)\n            n = len(points_np) - 1\n            k = degree\n            domain = np.linspace(0, n - k + 1, num)\n            knots = np.concatenate(([0]*k, np.arange(n - k + 2), [n - k + 2]*k))\n\n            def de_boor(t, k, i, x):\n                if k == 0:\n                    return x[i]\n                alpha = (t - knots[i])/(knots[i+k] - knots[i]) if knots[i+k] != knots[i] else 0\n                return (1.0 - alpha) * de_boor(t, k-1, i-1, x) + alpha * de_boor(t, k-1, i, x)\n\n            spline = []\n            for t in domain:\n                i = next(i for i in range(len(knots)-1) if knots[i] <= t < knots[i+1])\n                spline.append(tuple(de_boor(t, k, i, points_np)))\n            return spline\n\n        # Initialize best cost to infinite, update when path found\n        best_cost = float('inf')\n        connection_nodes = (None, None)\n        success = False\n\n        for iteration in range(self.max_iter):\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                if success:\n                    break\n\n                # Choose informed sampling with goal bias\n                sample_prob = random.random()\n                if sample_prob < self.goal_sample_rate:\n                    q_rand = goal_pos\n                else:\n                    q_rand = informed_sample(best_cost, dist(start_pos, goal_pos), start_pos, goal_pos)\n\n                nearest_node = nearest(tree_a, q_rand)\n                q_new_pos = steer(nearest_node.position, q_rand)\n\n                if is_in_obstacle(q_new_pos) or is_edge_in_obstacle(nearest_node.position, q_new_pos):\n                    continue\n\n                radius = adaptive_radius(len(tree_a))\n                near_nodes_a = near_nodes(tree_a, q_new_pos, radius)\n\n                # Choose parent minimizing cost\n                min_cost = nearest_node.cost + dist(nearest_node.position, q_new_pos)\n                min_parent = nearest_node\n                for near_n in near_nodes_a:\n                    c = near_n.cost + dist(near_n.position, q_new_pos)\n                    if c + 1e-10 < min_cost and not is_edge_in_obstacle(near_n.position, q_new_pos):\n                        min_cost = c\n                        min_parent = near_n\n\n                q_new = Node(q_new_pos, parent=min_parent, cost=min_cost)\n                min_parent.add_child(q_new)\n                tree_a.append(q_new)\n                nodes.append(q_new)\n                edges.append((min_parent, q_new))\n\n                rewire(tree_a, q_new, near_nodes_a)\n\n                # Attempt connection to other tree\n                nearest_other = nearest(tree_b, q_new.position)\n                dist_connect = dist(q_new.position, nearest_other.position)\n                radius_connect = max(self.step_size*1.5, adaptive_radius(len(tree_b)))\n\n                if dist_connect <= radius_connect and not is_edge_in_obstacle(q_new.position, nearest_other.position):\n                    # Trees connected\n                    if tree_a is start_tree:\n                        node_start, node_goal = q_new, nearest_other\n                    else:\n                        node_start, node_goal = nearest_other, q_new\n\n                    current_cost = node_start.cost + dist(node_start.position, node_goal.position) + node_goal.cost\n                    if current_cost < best_cost:\n                        best_cost = current_cost\n                        connection_nodes = (node_start, node_goal)\n                        success = True\n            if success:\n                break\n\n        raw_path = []\n        if success:\n            raw_path = extract_path(connection_nodes[0], connection_nodes[1])\n        else:\n            # fallback empty path on failure\n            return PlannerResult(False, [], nodes, edges)\n\n        # B-spline smoothing with collision checking along spline (dense checks)\n        smooth_path = raw_path\n        if len(raw_path) > self.smoothing_degree:\n            try:\n                # We implement smoothing only if numpy is available, else fallback raw_path\n                import numpy as np\n                spline_path = bspline(raw_path, degree=self.smoothing_degree, num=self.smoothing_points)\n                # Check collision for spline curve segments\n                collides = False\n                for i in range(len(spline_path)-1):\n                    if is_edge_in_obstacle(spline_path[i], spline_path[i+1]):\n                        collides = True\n                        break\n                if not collides:\n                    smooth_path = spline_path\n            except:\n                # If numpy not available, fallback to raw_path (no smoothing)\n                smooth_path = raw_path\n\n        return PlannerResult(success, smooth_path, nodes, edges)",
          "objective": -25.01284,
          "time_improvement": 66.0,
          "length_improvement": 7.0,
          "smoothness_improvement": 169.0,
          "node_improvement": 74.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.00990746021270752,
                    "num_nodes_avg": 117.2,
                    "path_length_avg": 177.87723139341853,
                    "smoothness_avg": 0.016505675329957482,
                    "success_improvement": 0.0,
                    "time_improvement": 61.58530892215819,
                    "node_improvement": 70.48602367161925,
                    "length_improvement": 2.5026708281624948,
                    "smoothness_improvement": 158.34966156149508,
                    "objective_score": 20.768943481352427
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.014815974235534667,
                    "num_nodes_avg": 199.2,
                    "path_length_avg": 264.58410600917347,
                    "smoothness_avg": 0.01090878033876496,
                    "success_improvement": 0.0,
                    "time_improvement": 91.05184234186756,
                    "node_improvement": 86.61560169320701,
                    "length_improvement": 11.67420978290656,
                    "smoothness_improvement": 180.69077539330692,
                    "objective_score": 35.223532449270735
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.027541279792785645,
                    "num_nodes_avg": 285.0,
                    "path_length_avg": 139.32127743918858,
                    "smoothness_avg": 0.02116118022862008,
                    "success_improvement": 0.0,
                    "time_improvement": 45.72845269254134,
                    "node_improvement": 63.76350921805467,
                    "length_improvement": 7.469441291202562,
                    "smoothness_improvement": 169.16865055219935,
                    "objective_score": 19.046043835244934
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "path_expert",
          "algorithm_description": "This planner implements an improved bidirectional Informed RRT* algorithm. It integrates elliptical informed sampling after an initial feasible path is found to concentrate search towards lower-cost solutions, adaptive rewiring radius based on tree cardinality and space dimension, and a gradient-based local smoothing post-processing to enhance path smoothness and length. The algorithm alternates tree expansions, rewires locally for cost improvements, attempts early tree connections, and continuously refines the path by restricting samples within the informed subset of the configuration space, improving planning efficiency, path quality, and convergence speed.",
          "planning_mechanism": "The algorithm starts growing two trees from start and goal positions using RRT* extensions. Initially, samples are uniform random with goal bias. Upon finding a first feasible path, the planner calculates an ellipsoidal informed sampling region tightly enclosing start and goal based on current best path cost, biasing new samples there. Nearby nodes are rewired using adaptive radius to improve costs. Early connection attempts between trees prune unnecessary expansions. After planning, a gradient-based smoothing is applied to the combined path to reduce sharp turns and shorten path length further, ensuring all nodes and edges respect collision constraints.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        node, path = self, []\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=6000, step_size=5.0, base_radius=18.0, goal_sample_rate=0.1, shortcut_iterations=120, smoothing_iters=40):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.base_radius = base_radius\n        self.goal_sample_rate = goal_sample_rate\n        self.shortcut_iterations = shortcut_iterations\n        self.smoothing_iters = smoothing_iters\n\n    def plan(self, map) -> 'PlannerResult':\n        import random, math\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        def dist(a,b):\n            return math.dist(a,b)\n\n        def steer(fr, to):\n            d = dist(fr, to)\n            if d <= self.step_size:\n                return to\n            ratio = self.step_size / d\n            return tuple(fr[i] + (to[i] - fr[i]) * ratio for i in range(dim))\n\n        def is_in_obstacle(p):\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d_ = obs\n                    px,py,pz = p\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d_:\n                        return True\n                else:\n                    x,y,w,h = obs\n                    px,py = p\n                    if x <= px <= x+w and y <= py <= y+h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(fr,to, resolution=1.0):\n            d = dist(fr,to)\n            steps = max(1, int(d / resolution))\n            for i in range(steps + 1):\n                interp = tuple(fr[j] + (to[j] - fr[j]) * i / steps for j in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: dist(node.position, point))\n\n        def near_nodes(tree, point, radius):\n            return [node for node in tree if dist(node.position, point) <= radius]\n\n        def rewire(tree, new_node, near_nodes_):\n            nonlocal edges\n            for near in near_nodes_:\n                if near == new_node.parent:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, near.position)\n                if new_cost + 1e-9 < near.cost:\n                    if not is_edge_in_obstacle(new_node.position, near.position):\n                        if near.parent is not None:\n                            if (near.parent, near) in edges:\n                                edges.remove((near.parent, near))\n                            near.parent.children.remove(near)\n                        near.parent = new_node\n                        near.cost = new_cost\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n\n        def extract_path(node_from_start, node_from_goal):\n            path_start = node_from_start.path_from_root()\n            path_goal = node_from_goal.path_from_root()[::-1]\n            if len(path_start) > 0 and len(path_goal) > 0 and path_start[-1] == path_goal[0]:\n                path_goal = path_goal[1:]\n            return path_start + path_goal\n\n        def adaptive_radius(tree_size):\n            if tree_size <= 1:\n                return self.step_size * 2.0\n            gamma = self.base_radius\n            n = max(tree_size, 1)\n            radius = gamma * (math.log(n)/n)**(1.0/dim)\n            return max(radius, self.step_size * 1.5)\n\n        # Ellipse informed sampling helper\n        def informed_sample(c_best):\n            if c_best == float('inf'):\n                return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n            # Ellipsoid centered between start and goal\n            center = tuple((start_pos[i] + goal_pos[i]) / 2.0 for i in range(dim))\n            a1 = tuple((goal_pos[i] - start_pos[i]) / c_best for i in range(dim))  # unit vector along start->goal\n\n            # Build orthonormal basis:\n            # Gram-Schmidt for higher dim (supporting 2D and 3D)\n            # We'll build transformation matrix with a1 as first column\n            import math as _math\n            # Create basis matrix Q = [a1, a2, a3,...]\n            orthonormal = [a1]\n            for i_dim in range(dim):\n                e = [0.0]*dim\n                e[i_dim] = 1.0\n                # Orthogonalize e wrt previous basis\n                for b in orthonormal:\n                    proj = sum(e[j]*b[j] for j in range(dim))\n                    for j in range(dim):\n                        e[j] -= proj * b[j]\n                norm_e = math.sqrt(sum(v*v for v in e))\n                if norm_e > 1e-8:\n                    e = [v/norm_e for v in e]\n                    orthonormal.append(e)\n                if len(orthonormal) >= dim:\n                    break\n            Q = orthonormal[:dim]\n\n            # Radii of ellipse axes\n            r1 = c_best / 2.0\n            if dim == 2:\n                r_others = math.sqrt(c_best**2 - dist(start_pos, goal_pos)**2) / 2.0\n                radii = [r1, r_others]\n            elif dim == 3:\n                r_others = math.sqrt(c_best**2 - dist(start_pos, goal_pos)**2) / 2.0\n                radii = [r1, r_others, r_others]\n            else:\n                # For higher dim, fallback to bounding box sampling (should not occur here)\n                return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n\n            # Sample uniformly inside unit n-ball\n            while True:\n                x = [random.gauss(0,1) for _ in range(dim)]\n                norm_x = math.sqrt(sum(px*px for px in x))\n                if norm_x > 1e-8:\n                    break\n            x_unit = [px/norm_x for px in x]\n            scale = random.uniform(0,1)**(1.0/dim)\n            x_scaled = [scale*v for v in x_unit]\n\n            # Map unit ball sample to ellipse point: center + Q * (radii * x_scaled)\n            sample = [center[i] + sum(Q[j][i]*radii[j]*x_scaled[j] for j in range(dim)) for i in range(dim)]\n            # Clamp sample to map bounds\n            clamped = tuple(max(0.0, min(bounds[i], sample[i])) for i in range(dim))\n            return clamped\n\n        def sample_point(c_best):\n            if random.random() < self.goal_sample_rate:\n                return goal_pos\n            if c_best == float('inf'):\n                return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n            else:\n                return informed_sample(c_best)\n\n        def shortcut_path(path):\n            # Attempts shortcutting to reduce length and sharp turns\n            # Random pairwise shortcutting with collision check\n            def check_shortcut(i,j):\n                return not is_edge_in_obstacle(path[i], path[j])\n            for _ in range(self.shortcut_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i+2, len(path) -1)\n                if check_shortcut(i,j):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        def gradient_smooth_path(path, alpha=0.2, beta=0.4, iterations=40):\n            # Smooth path using gradient descent approach similar to path smoothing in PRM/RRT*\n            if len(path) < 3:\n                return path[:]\n            smoothed = [list(p) for p in path]\n            for _ in range(iterations):\n                for i in range(1,len(smoothed)-1):\n                    p = smoothed[i]\n                    p_old = p[:]\n                    # Smoothness term: pull point towards neighbors\n                    for d in range(dim):\n                        p[d] += alpha * (smoothed[i-1][d] + smoothed[i+1][d] - 2*p[d])\n                    # Data term: keeps it close to original vertex position\n                    for d in range(dim):\n                        p[d] += beta * (path[i][d] - p[d])\n\n                    # Clamp to bounds\n                    for d in range(dim):\n                        p[d] = max(0.0, min(bounds[d], p[d]))\n\n                    # Collision check for edges (i-1)-(i) and (i)-(i+1)\n                    prev_p = tuple(smoothed[i-1])\n                    nxt_p = tuple(smoothed[i+1])\n                    curr_p = tuple(p)\n                    if (is_in_obstacle(curr_p) or \n                        is_edge_in_obstacle(prev_p, curr_p) or \n                        is_edge_in_obstacle(curr_p, nxt_p)):\n                        # revert if invalid\n                        smoothed[i] = p_old\n                    else:\n                        smoothed[i] = p\n            return [tuple(p) for p in smoothed]\n\n        success = False\n        connection_pair = (None, None)\n        c_best = float('inf')\n        best_path_nodes = None\n\n        for it in range(self.max_iter):\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                q_rand = sample_point(c_best)\n                nearest_node = nearest(tree_a, q_rand)\n                q_new_pos = steer(nearest_node.position, q_rand)\n                if is_in_obstacle(q_new_pos):\n                    continue\n                if is_edge_in_obstacle(nearest_node.position, q_new_pos):\n                    continue\n\n                radius = adaptive_radius(len(tree_a))\n                near_nodes_a = near_nodes(tree_a, q_new_pos, radius)\n\n                # Choose parent minimizing cost\n                min_cost = nearest_node.cost + dist(nearest_node.position, q_new_pos)\n                min_parent = nearest_node\n                for near_node in near_nodes_a:\n                    c = near_node.cost + dist(near_node.position, q_new_pos)\n                    if c + 1e-12 < min_cost and not is_edge_in_obstacle(near_node.position, q_new_pos):\n                        min_cost = c\n                        min_parent = near_node\n\n                q_new = Node(q_new_pos, parent=min_parent, cost=min_cost)\n                min_parent.add_child(q_new)\n                tree_a.append(q_new)\n                nodes.append(q_new)\n                edges.append((min_parent, q_new))\n\n                rewire(tree_a, q_new, near_nodes_a)\n\n                # Try connection with other tree within adaptive radius\n                nearest_to_new = nearest(tree_b, q_new.position)\n                dist_connect = dist(q_new.position, nearest_to_new.position)\n                radius_connect = max(self.step_size*1.5, adaptive_radius(len(tree_b)))\n                if dist_connect <= radius_connect and not is_edge_in_obstacle(q_new.position, nearest_to_new.position):\n                    # Build candidate path and update c_best if better\n                    if tree_a is start_tree:\n                        node_start, node_goal = q_new, nearest_to_new\n                    else:\n                        node_start, node_goal = nearest_to_new, q_new\n                    candidate_path_nodes = extract_path(node_start, node_goal)\n                    candidate_cost = 0.0\n                    for i in range(len(candidate_path_nodes)-1):\n                        candidate_cost += dist(candidate_path_nodes[i], candidate_path_nodes[i+1])\n                    if candidate_cost < c_best:\n                        c_best = candidate_cost\n                        connection_pair = (node_start, node_goal)\n                        best_path_nodes = candidate_path_nodes\n                        success = True\n            if success and (it > 100 and it % 30 == 0):\n                # Early termination could be allowed if path cost is stable\n                break\n\n        path = []\n        if success and best_path_nodes:\n            # Post-processing: shortcut + gradient smoothing\n            path = shortcut_path(best_path_nodes)\n            path = gradient_smooth_path(path, iterations=self.smoothing_iters)\n\n        return PlannerResult(success, path, nodes, edges)",
          "objective": -24.91343,
          "time_improvement": 24.0,
          "length_improvement": 17.0,
          "smoothness_improvement": 1521.0,
          "node_improvement": 69.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.04222602844238281,
                    "num_nodes_avg": 145.6,
                    "path_length_avg": 165.7015735704016,
                    "smoothness_avg": 0.03195078114288795,
                    "success_improvement": 0.0,
                    "time_improvement": -63.72509232767426,
                    "node_improvement": 63.33417275245531,
                    "length_improvement": 9.1763418166028,
                    "smoothness_improvement": 400.09910711794936,
                    "objective_score": -11.611227072750854
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.03934156894683838,
                    "num_nodes_avg": 346.2,
                    "path_length_avg": 234.8985415700393,
                    "smoothness_avg": 0.10549100772507927,
                    "success_improvement": 0.0,
                    "time_improvement": 76.23952661781249,
                    "node_improvement": 76.7385607740375,
                    "length_improvement": 21.58410564428557,
                    "smoothness_improvement": 2614.3596108679344,
                    "objective_score": 48.89411942625476
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.02059016227722168,
                    "num_nodes_avg": 254.8,
                    "path_length_avg": 120.75685810991956,
                    "smoothness_avg": 0.12972022960082913,
                    "success_improvement": 0.0,
                    "time_improvement": 59.42599710311202,
                    "node_improvement": 67.60330578512396,
                    "length_improvement": 19.799044667050456,
                    "smoothness_improvement": 1550.031745571195,
                    "objective_score": 37.45738465901985
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e2",
          "algorithm_description": "This algorithm is an Informed Bidirectional RRT* (Informed Bi-RRT*) that grows two trees from start and goal positions. It integrates focused ellipsoidal sampling around the current best path for efficient exploration, combines asymptotically optimal rewiring for path improvement, and applies post-planning path shortcutting for smoothness enhancement. The approach balances fast convergence, robust path quality improvement, and smooth, shorter final paths by combining informed sampling, smart rewiring, and path shortcutting techniques.",
          "planning_mechanism": "The planner alternates growing two RRT* trees from start and goal, using ellipsoidal informed sampling restricted to promising regions around the current shortest path cost. Each extension step rewires nearby nodes to improve path cost locally. Upon connecting trees, it extracts the path and applies iterative shortcutting to remove unnecessary waypoints and smooth rough turns. Early pruning of nodes and careful collision checks maintain robustness and computational efficiency.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\nclass Planner:\n    def __init__(self, max_iter=7000, step_size=7.0, radius_factor=1.5):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.radius_factor = radius_factor  # factor multiplied by step_size for rewiring radius\n\n    def plan(self, map) -> \"PlannerResult\":\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        edges = []\n        nodes = []\n\n        best_cost = float('inf')\n        best_path = []\n        connected = False\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_p, to_p, max_step):\n            d = dist(from_p, to_p)\n            if d <= max_step:\n                return to_p\n            ratio = max_step / d\n            return tuple(from_p[i] + (to_p[i] - from_p[i]) * ratio for i in range(len(from_p)))\n\n        def node_path_cost(node):\n            return node.cost\n\n        def is_collision_point(p):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = p\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w_, h_ = obs\n                    px, py = p\n                    if x <= px <= x + w_ and y <= py <= y + h_:\n                        return True\n            return False\n\n        def is_collision_edge(f, t):\n            d = dist(f, t)\n            steps = max(1, int(d / 1.0))\n            for i in range(steps + 1):\n                interp = tuple(f[j] + (t[j] - f[j]) * (i / steps) for j in range(len(f)))\n                if is_collision_point(interp):\n                    return True\n            return False\n\n        def extract_path(node_start, node_goal):\n            path_from_start = []\n            n = node_start\n            while n:\n                path_from_start.append(n.position)\n                n = n.parent\n            path_from_goal = []\n            n = node_goal\n            while n:\n                path_from_goal.append(n.position)\n                n = n.parent\n            return list(reversed(path_from_start)) + path_from_goal\n\n        def radius():\n            # radius depends on dimension and step size, uses standard RRT* ball radius scaling with factor\n            dim = 3 if is_3d else 2\n            return max(self.step_size * self.radius_factor, self.step_size * (math.log(len(start_tree) + len(goal_tree) + 1) / (len(start_tree) + len(goal_tree) + 1)) ** (1/dim))\n\n        def near_nodes(tree, point, rad):\n            return [n for n in tree if dist(n.position, point) <= rad]\n\n        def informed_sample():\n            # If we have a path, sample inside ellipsoid defined by start, goal, and best_cost\n            if best_cost == float('inf'):\n                # no solution yet, sample uniformly in bounds\n                while True:\n                    p = tuple(random.uniform(0, bounds[i]) for i in range(len(bounds)))\n                    if not is_collision_point(p):\n                        return p\n            else:\n                # ellipsoidal sampling focused on the best path cost\n                c_min = dist(start_pos, goal_pos)\n                if best_cost < c_min:\n                    # Numerical safety: best_cost cannot be less than min dist (due to floating point)\n                    c_best = c_min\n                else:\n                    c_best = best_cost\n                center = tuple((start_pos[i]+goal_pos[i])/2 for i in range(len(bounds)))\n\n                # Compute rotation matrix from standard basis to unit vector from start->goal\n                direction = tuple((goal_pos[i] - start_pos[i]) / c_min if c_min > 0 else 0.0 for i in range(len(bounds)))\n                # For 2D or 3D, build a rotation matrix U aligning x axis to direction vector\n                # We'll do 2D and 3D separately to reduce complexity\n\n                def sample_unit_ball():\n                    # Uniformly sample a point in the unit ball in n-dim\n                    while True:\n                        sample = tuple(random.uniform(-1,1) for _ in range(len(bounds)))\n                        if sum(x*x for x in sample) <= 1:\n                            return sample\n\n                # Radii of ellipsoid axes (r1,...,rn)\n                r1 = c_best / 2.0\n                if is_3d:\n                    r2 = math.sqrt(c_best**2 - c_min**2) / 2.0 if c_best > c_min else 0.0\n                    r3 = r2\n                    radii = (r1, r2, r3)\n                else:\n                    r2 = math.sqrt(c_best**2 - c_min**2) / 2.0 if c_best > c_min else 0.0\n                    radii = (r1, r2)\n\n                # Sample point in unit ball\n                while True:\n                    unit_sample = sample_unit_ball()\n                    scaled = tuple(unit_sample[i]*radii[i] for i in range(len(bounds)))\n\n                    # Rotation matrix U aligns x-axis to direction vector\n                    # For 2D: construct 2D rotation matrix\n                    if not is_3d:\n                        ux, uy = direction[0], direction[1]\n                        rot_sample = (scaled[0]*ux - scaled[1]*uy, scaled[0]*uy + scaled[1]*ux)\n                    else:\n                        # For 3D, use Householder reflection or simple rotation by aligning vector\n                        # We'll approximate: let u = direction vector\n                        # Find orthonormal basis [u, v, w]\n                        # We'll do a simple alignment: assume u is normalized\n                        u = direction\n                        # arbitrary orthogonal vector to u\n                        if abs(u[0]) < 0.9:\n                            v = (1,0,0)\n                        else:\n                            v = (0,1,0)\n                        # make v orthonormal to u\n                        dot_uv = sum(u[i]*v[i] for i in range(3))\n                        v = tuple(v[i] - dot_uv*u[i] for i in range(3))\n                        v_len = math.sqrt(sum(x*x for x in v))\n                        if v_len > 0:\n                            v = tuple(x/v_len for x in v)\n                        else:\n                            # fallback orthogonal vector\n                            if abs(u[2]) < 0.9:\n                                v = (0,0,1)\n                            else:\n                                v = (1,0,0)\n                            dot_uv = sum(u[i]*v[i] for i in range(3))\n                            v = tuple(v[i] - dot_uv*u[i] for i in range(3))\n                            v_len = math.sqrt(sum(x*x for x in v))\n                            if v_len > 0:\n                                v = tuple(x/v_len for x in v)\n\n                        # w = u cross v\n                        w = (u[1]*v[2] - u[2]*v[1], u[2]*v[0] - u[0]*v[2], u[0]*v[1] - u[1]*v[0])\n\n                        # scaled sample coords: [x,y,z]\n                        x, y, z = scaled\n                        rot_sample = (u[0]*x + v[0]*y + w[0]*z,\n                                      u[1]*x + v[1]*y + w[1]*z,\n                                      u[2]*x + v[2]*y + w[2]*z)\n\n                    point = tuple(center[i] + rot_sample[i] for i in range(len(bounds)))\n\n                    # Reject if out of bounds or in collision\n                    in_bounds = all(0 <= point[i] <= bounds[i] for i in range(len(bounds)))\n                    if in_bounds and not is_collision_point(point):\n                        return point\n\n        def try_extend(tree_from, tree_to):\n            nonlocal best_cost, best_path, connected\n            sample = informed_sample()\n            nearest = min(tree_from, key=lambda node: dist(node.position, sample))\n            new_pos = steer(nearest.position, sample, self.step_size)\n            if is_collision_point(new_pos) or is_collision_edge(nearest.position, new_pos):\n                return False\n\n            # Create new node, find near nodes for rewiring\n            new_node = Node(new_pos)\n            near_rad = radius()\n            near = [n for n in tree_from if dist(n.position, new_pos) <= near_rad]\n\n            # Choose best parent minimizing cost\n            cost_min = nearest.cost + dist(nearest.position, new_pos)\n            parent_min = nearest\n            for p in near:\n                if not is_collision_edge(p.position, new_pos) and p.cost + dist(p.position, new_pos) < cost_min:\n                    cost_min = p.cost + dist(p.position, new_pos)\n                    parent_min = p\n            new_node.parent = parent_min\n            new_node.cost = cost_min\n            parent_min.add_child(new_node)\n            tree_from.append(new_node)\n\n            # Rewire near nodes if cheaper through new_node\n            for n in near:\n                if n is parent_min:\n                    continue\n                edge_cost = dist(new_node.position, n.position)\n                new_cost = new_node.cost + edge_cost\n                if new_cost < n.cost and not is_collision_edge(new_node.position, n.position):\n                    # Change parent\n                    if n.parent:\n                        n.parent.remove_child(n)\n                    n.parent = new_node\n                    n.cost = new_cost\n                    new_node.add_child(n)\n\n            # Try to connect to other tree\n            nearest_other = min(tree_to, key=lambda node: dist(node.position, new_pos))\n            if dist(new_pos, nearest_other.position) <= self.step_size and not is_collision_edge(new_node.position, nearest_other.position):\n                # connection found, build path\n                connected = True\n                path = extract_path(new_node, nearest_other)\n                cost_path = 0.0\n                for i in range(len(path) - 1):\n                    cost_path += dist(path[i], path[i+1])\n                if cost_path < best_cost:\n                    best_cost = cost_path\n                    best_path = path\n                return True\n            return False\n\n        for i in range(self.max_iter):\n            if connected:\n                # Continue improving trees for better paths until iterations end\n                progressed = (try_extend(start_tree, goal_tree) or try_extend(goal_tree, start_tree))\n                if not progressed:\n                    break\n            else:\n                # Regular bidirectional grow\n                if try_extend(start_tree, goal_tree):\n                    connected = True\n                if not connected:\n                    try_extend(goal_tree, start_tree)\n\n        if not best_path:\n            # No path found\n            return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n        # Path shortcutting to smooth and shorten path\n        shortcut_path = self._shortcut_path(best_path, is_collision_point, is_collision_edge)\n\n        return PlannerResult(True, shortcut_path, start_tree + goal_tree, edges)\n\n    def _shortcut_path(self, path, is_collision_point, is_collision_edge, max_iter=150):\n        if len(path) <= 2:\n            return path[:]\n        path = path[:]\n        for _ in range(max_iter):\n            if len(path) <= 2:\n                break\n            i = random.randint(0, len(path) - 2)\n            j = random.randint(i + 1, len(path) - 1)\n            if j == i + 1:\n                continue\n            # Try to shortcut between path[i] and path[j]\n            if not is_collision_edge(path[i], path[j]):\n                # Shortcut: remove intermediate points between i and j\n                path = path[:i+1] + path[j:]\n        return path",
          "objective": -24.81658,
          "time_improvement": 30.0,
          "length_improvement": 15.0,
          "smoothness_improvement": 1375.0,
          "node_improvement": 74.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.02101633548736572,
                    "num_nodes_avg": 109.5,
                    "path_length_avg": 172.32714291787394,
                    "smoothness_avg": 0.049746205597541,
                    "success_improvement": 0.0,
                    "time_improvement": 18.51231112692918,
                    "node_improvement": 72.4250818433644,
                    "length_improvement": 5.544762268388349,
                    "smoothness_improvement": 678.6361432159815,
                    "objective_score": 12.273731415191671
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.017328310012817382,
                    "num_nodes_avg": 175.4,
                    "path_length_avg": 235.9789361832376,
                    "smoothness_avg": 0.0925726072219917,
                    "success_improvement": 0.0,
                    "time_improvement": 89.53450866755713,
                    "node_improvement": 88.21474165154875,
                    "length_improvement": 21.223438824965278,
                    "smoothness_improvement": 2281.9598611757096,
                    "objective_score": 51.00421520112486
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.05953328609466553,
                    "num_nodes_avg": 301.0,
                    "path_length_avg": 124.124788332228,
                    "smoothness_avg": 0.09950538690435078,
                    "success_improvement": 0.0,
                    "time_improvement": -17.313486408915992,
                    "node_improvement": 61.72917991099809,
                    "length_improvement": 17.562225776996367,
                    "smoothness_improvement": 1165.701176699687,
                    "objective_score": 11.171795427021458
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "time_expert",
          "algorithm_description": "An Adaptive Bidirectional RRT* Planner with Relaxed Curvature Constraints, Progressive Sampling, and Enhanced Multi-Stage Smoothing to Accelerate Planning and Improve Path Smoothness and Length. This planner grows two trees simultaneously with adaptive rewiring radius that decays moderately without aggressive shrinking, enabling better connectivity early on. Sampling progressively shifts from uniform to ellipsoidal informed sampling with adjustable bias to improve exploration-exploitation balance over iterations. Curvature penalties and rewiring angle thresholds are relaxed moderately to allow more beneficial rewiring and parent changes, facilitating shorter and smoother paths. The planner invokes local shortcutting frequently with improved curvature-aware checks, followed by extended iterative smoothing with momentum-based acceptance to reduce curvature spikes robustly while avoiding excessive runtime. Efficient grid-based nearest neighbor searches and early pruning accelerate collision checks, and incremental cost propagation ensures consistent updates. Planning halts early once improvement stalls, balancing quality and time.",
          "planning_mechanism": "The planner alternates between expanding start and goal trees, sampling adaptively between uniform and ellipsoidal informed distributions that gradually bias search toward the corridor between start and goal. Upon node addition, a moderate adaptive radius determines nearby candidates for rewiring with relaxed curvature constraints allowing smoother, shorter paths. Frequent local shortcutting aggressively prunes suboptimal segments respecting curvature improvement, followed by momentum-enhanced iterative smoothing that progressively refines path smoothness. Early pruning of nodes outside bounds or in obstacles, combined with efficient spatial hashing for neighborhood queries, reduces planning iterations and collision checks. Incremental cost updates propagate improvements rapidly, and the algorithm terminates early when no significant cost improvement is observed over fixed iteration windows, ensuring high-quality paths in reduced planning time.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n    def add_child(self, child):\n        self.children.append(child)\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\nclass Planner:\n    def __init__(self,\n                 max_iter=2500,\n                 initial_step=7.0,\n                 initial_radius=22.0,\n                 min_radius_factor=1.2,\n                 uniform_sample_decay_iter=800,\n                 local_shortcut_interval=8,\n                 max_local_shortcuts=100,\n                 curvature_alpha=1.6,\n                 max_rewire_angle_diff=2.2,  # relaxed ~126 deg\n                 smoothing_iters=25,\n                 smoothing_momentum=0.85,\n                 no_improve_stop=200):\n        self.max_iter = max_iter\n        self.initial_step = initial_step\n        self.initial_radius = initial_radius\n        self.min_radius_factor = min_radius_factor\n        self.uniform_sample_decay_iter = uniform_sample_decay_iter\n        self.local_shortcut_interval = local_shortcut_interval\n        self.max_local_shortcuts = max_local_shortcuts\n        self.curvature_alpha = curvature_alpha\n        self.max_rewire_angle_diff = max_rewire_angle_diff\n        self.smoothing_iters = smoothing_iters\n        self.smoothing_momentum = smoothing_momentum\n        self.no_improve_stop = no_improve_stop\n\n    def plan(self, map):\n        import math\n        import random\n\n        bounds = map.size\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        def in_bounds(p):\n            return all(0.0 <= p[i] <= bounds[i] for i in range(dim))\n\n        def collision_node(p):\n            px = p[0]\n            py = p[1]\n            pz = p[2] if is_3d else 0.0\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def collision_edge(a, b, step=0.3):\n            dist = math.dist(a, b)\n            if dist < 1e-12:\n                return False\n            steps = max(1, int(dist / step))\n            for i in range(steps + 1):\n                t = i / steps\n                interp = tuple(a[j] + t * (b[j] - a[j]) for j in range(dim))\n                if collision_node(interp):\n                    return True\n            return False\n\n        def steer(from_p, to_p, step):\n            dist = math.dist(from_p, to_p)\n            if dist <= step:\n                return to_p\n            ratio = step / dist\n            return tuple(from_p[i] + ratio * (to_p[i] - from_p[i]) for i in range(dim))\n\n        GRID_SIZE = self.initial_step * 2.8\n\n        def grid_hash(p):\n            return tuple(int(p[i] / GRID_SIZE) for i in range(dim))\n\n        def add_to_hash(ht, node):\n            h = grid_hash(node.position)\n            if h not in ht:\n                ht[h] = []\n            ht[h].append(node)\n\n        def remove_from_hash(ht, node):\n            h = grid_hash(node.position)\n            if h in ht and node in ht[h]:\n                ht[h].remove(node)\n                if not ht[h]:\n                    del ht[h]\n\n        def nearby_nodes(ht, p, radius):\n            radius_sq = radius * radius\n            gh = grid_hash(p)\n            shifts = [-1, 0, 1]\n            neighbors = []\n            if dim == 2:\n                cells = [(gh[0] + dx, gh[1] + dy) for dx in shifts for dy in shifts]\n            else:\n                cells = [(gh[0] + dx, gh[1] + dy, gh[2] + dz) for dx in shifts for dy in shifts for dz in shifts]\n            candidates = []\n            for c in cells:\n                if c in ht:\n                    candidates.extend(ht[c])\n            for node in candidates:\n                d_sq = 0.0\n                for i in range(dim):\n                    diff = node.position[i] - p[i]\n                    d_sq += diff * diff\n                    if d_sq > radius_sq:\n                        break\n                else:\n                    neighbors.append(node)\n            return neighbors\n\n        def nearest(ht, p):\n            gh = grid_hash(p)\n            min_node = None\n            min_dist_sq = float('inf')\n            expansions = 0\n            max_expansions = 3\n            while expansions <= max_expansions:\n                if dim == 2:\n                    cells = [(gh[0] + dx, gh[1] + dy) for dx in range(-expansions, expansions + 1) for dy in\n                             range(-expansions, expansions + 1)]\n                else:\n                    cells = [(gh[0] + dx, gh[1] + dy, gh[2] + dz) for dx in range(-expansions, expansions + 1) for dy in\n                             range(-expansions, expansions + 1) for dz in range(-expansions, expansions + 1)]\n                candidates = []\n                for c in cells:\n                    if c in ht:\n                        candidates.extend(ht[c])\n                for node in candidates:\n                    d_sq = 0.0\n                    for i in range(dim):\n                        diff = node.position[i] - p[i]\n                        d_sq += diff * diff\n                        if d_sq >= min_dist_sq:\n                            break\n                    else:\n                        if d_sq < min_dist_sq:\n                            min_dist_sq = d_sq\n                            min_node = node\n                if min_node is not None or expansions == max_expansions:\n                    break\n                expansions += 1\n            if min_node is None:\n                all_nodes = []\n                for cellnodes in ht.values():\n                    all_nodes.extend(cellnodes)\n                if all_nodes:\n                    min_node = min(all_nodes, key=lambda n: math.dist(n.position, p))\n            return min_node\n\n        def unit_ball_volume(d):\n            from math import pi, gamma\n            return (pi ** (d / 2)) / gamma(d / 2 + 1)\n\n        c_min = math.dist(start_pos, goal_pos)\n        vol_ball = unit_ball_volume(dim)\n\n        def adaptive_radius(n_nodes, best_cost, iter_ratio):\n            if n_nodes <= 1:\n                return self.initial_step * 3.5\n            val = (math.log(n_nodes) / n_nodes) ** (1.0 / dim)\n            base_r = self.initial_radius * val\n            if best_cost < float('inf'):\n                base_r = min(base_r, best_cost * 0.33)\n            base_r = max(base_r, self.initial_step * self.min_radius_factor)\n            decay = max(0.5, 1.0 - iter_ratio * 0.5)  # slower decay for better connectivity\n            return base_r * decay\n\n        def angle_between(a, b, c):\n            ab = [a[i] - b[i] for i in range(dim)]\n            cb = [c[i] - b[i] for i in range(dim)]\n            lab = math.sqrt(sum(x * x for x in ab))\n            lcb = math.sqrt(sum(x * x for x in cb))\n            if lab < 1e-14 or lcb < 1e-14:\n                return 0.0\n            dot = sum(ab[i] * cb[i] for i in range(dim))\n            val = max(min(dot / (lab * lcb), 1.0), -1.0)\n            return math.acos(val)\n\n        def curvature_penalty(parent, child_pos):\n            if parent is None or parent.parent is None:\n                return 0.0\n            v1 = [parent.position[i] - parent.parent.position[i] for i in range(dim)]\n            v2 = [child_pos[i] - parent.position[i] for i in range(dim)]\n            len1 = math.sqrt(sum(x * x for x in v1))\n            len2 = math.sqrt(sum(x * x for x in v2))\n            if len1 < 1e-9 or len2 < 1e-9:\n                return 0.0\n            dot = sum(v1[i] * v2[i] for i in range(dim))\n            cos_ang = max(min(dot / (len1 * len2), 1.0), -1.0)\n            angle = math.acos(cos_ang)\n            return angle * self.curvature_alpha\n\n        def path_cost(parent, child_pos):\n            linear_cost = parent.cost + math.dist(parent.position, child_pos)\n            penalty = curvature_penalty(parent, child_pos)\n            return linear_cost + penalty\n\n        def propagate_costs(node):\n            stack = [node]\n            while stack:\n                n = stack.pop()\n                for c in n.children:\n                    new_cost = n.cost + math.dist(n.position, c.position) + curvature_penalty(n, c.position)\n                    if new_cost + 1e-14 < c.cost:\n                        c.cost = new_cost\n                        stack.append(c)\n\n        self._propagate_costs = propagate_costs\n\n        def rewire(tree_hash, new_node, near_nodes):\n            # Allow relaxed curvature with max angle diff threshold and only rewire if cost gains sufficiently\n            for n in near_nodes:\n                if n is new_node.parent:\n                    continue\n                c_cost = path_cost(new_node, n.position)\n                if c_cost + 1e-14 < n.cost:\n                    if not collision_edge(new_node.position, n.position):\n                        angle_diff_ok = True\n                        if n.parent and n.parent.parent:\n                            angle_before = angle_between(n.parent.parent.position, n.parent.position, n.position)\n                            angle_after = angle_between(n.parent.position, new_node.position, n.position)\n                            angle_if = abs(angle_after - angle_before)\n                            if angle_if > self.max_rewire_angle_diff:\n                                angle_diff_ok = False\n                        if angle_diff_ok:\n                            if n.parent:\n                                n.parent.remove_child(n)\n                            n.parent = new_node\n                            n.cost = c_cost\n                            new_node.add_child(n)\n                            self._propagate_costs(n)\n\n        def extract_path(node_start, node_goal):\n            path_start = []\n            n = node_start\n            while n:\n                path_start.append(n.position)\n                n = n.parent\n            path_start.reverse()\n            path_goal = []\n            n = node_goal\n            while n:\n                path_goal.append(n.position)\n                n = n.parent\n            if path_start[-1] == path_goal[0]:\n                return path_start + path_goal[1:]\n            return path_start + path_goal\n\n        def ellipsoidal_informed_sample(best_cost, iteration):\n            # Progressive blend: Early iterations sample uniform; gradually bias toward ellipsoidal informed\n            blend_threshold = min(1.0, iteration / self.uniform_sample_decay_iter)\n            sample_use_informed = (random.random() < blend_threshold)\n            if best_cost == float('inf'):\n                sample_use_informed = False  # no path found yet, uniform sampling only\n\n            if not sample_use_informed:\n                attempts = 0\n                while attempts < 15:\n                    pt = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                    if not collision_node(pt):\n                        return pt\n                    attempts += 1\n                return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n\n            center = tuple(0.5 * (start_pos[i] + goal_pos[i]) for i in range(dim))\n            d_vec = [goal_pos[i] - start_pos[i] for i in range(dim)]\n            length = math.dist(start_pos, goal_pos)\n            half_best = best_cost * 0.5\n            delta = best_cost * best_cost - c_min * c_min\n            a_rest = math.sqrt(max(delta, 0.0)) * 0.5 if delta > 0 else 0.0\n\n            if dim == 2:\n                if length < 1e-14:\n                    R = [[1, 0], [0, 1]]\n                else:\n                    norm_d = (d_vec[0] / length, d_vec[1] / length)\n                    c = norm_d[0]\n                    s = norm_d[1]\n                    R = [[c, -s], [s, c]]\n                attempts = 0\n                while attempts < 50:\n                    r = random.uniform(0, 1) ** 0.5\n                    theta = random.uniform(0, 2 * math.pi)\n                    ball = [r * math.cos(theta), r * math.sin(theta)]\n                    x_scaled = [half_best * ball[0], a_rest * ball[1]]\n                    candidate = (\n                        center[0] + R[0][0] * x_scaled[0] + R[0][1] * x_scaled[1],\n                        center[1] + R[1][0] * x_scaled[0] + R[1][1] * x_scaled[1],\n                    )\n                    if in_bounds(candidate) and not collision_node(candidate):\n                        return candidate\n                    attempts += 1\n                return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n            else:\n                from math import sqrt\n                if length < 1e-14:\n                    R = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n                else:\n                    a1 = [1, 0, 0]\n                    a2 = [d_vec[i] / length for i in range(3)]\n                    v = [\n                        a1[1] * a2[2] - a1[2] * a2[1],\n                        a1[2] * a2[0] - a1[0] * a2[2],\n                        a1[0] * a2[1] - a1[1] * a2[0],\n                    ]\n                    s = sqrt(sum(x * x for x in v))\n                    c = sum(a1[i] * a2[i] for i in range(3))\n                    if s < 1e-14:\n                        R = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n                    else:\n                        vx = [[0, -v[2], v[1]], [v[2], 0, -v[0]], [-v[1], v[0], 0]]\n                        I = [[1 if i == j else 0 for j in range(3)] for i in range(3)]\n                        vx2 = [[sum(vx[i][k] * vx[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n                        R = [\n                            [I[i][j] + vx[i][j] + vx2[i][j] * ((1 - c) / (s * s)) for j in range(3)]\n                            for i in range(3)\n                        ]\n                attempts = 0\n                while attempts < 50:\n                    while True:\n                        ball = [random.uniform(-1, 1) for _ in range(3)]\n                        if sum(x * x for x in ball) <= 1:\n                            break\n                    x_scaled = [half_best * ball[0], a_rest * ball[1], a_rest * ball[2]]\n                    candidate = tuple(center[i] + sum(R[i][j] * x_scaled[j] for j in range(3)) for i in range(3))\n                    if in_bounds(candidate) and not collision_node(candidate):\n                        return candidate\n                    attempts += 1\n                return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n\n        def attempt_expand(tree, tree_hash, other_tree_hash, sample, best_cost, iter_ratio):\n            nearest_node = nearest(tree_hash, sample)\n            if nearest_node is None:\n                return None\n            step = max(self.initial_step * (0.65 + 0.35 * (1 - iter_ratio)), 1.0)\n            new_pos = steer(nearest_node.position, sample, step)\n            if not in_bounds(new_pos):\n                return None\n            if collision_node(new_pos):\n                return None\n            if collision_edge(nearest_node.position, new_pos):\n                return None\n\n            radius = adaptive_radius(len(tree), best_cost, iter_ratio)\n            near_nodes = nearby_nodes(tree_hash, new_pos, radius)\n\n            min_cost = path_cost(nearest_node, new_pos)\n            min_parent = nearest_node\n            for near in near_nodes:\n                if near is nearest_node:\n                    continue\n                c = path_cost(near, new_pos)\n                if c < min_cost and not collision_edge(near.position, new_pos):\n                    min_cost = c\n                    min_parent = near\n\n            new_node = Node(new_pos, min_parent, min_cost)\n            min_parent.add_child(new_node)\n            tree.append(new_node)\n            add_to_hash(tree_hash, new_node)\n\n            rewire(tree_hash, new_node, near_nodes)\n\n            other_near = nearest(other_tree_hash, new_node.position)\n            if other_near is None:\n                return None\n            dist_other = math.dist(other_near.position, new_node.position)\n            threshold = step * 1.22\n            if dist_other <= threshold and not collision_edge(other_near.position, new_node.position):\n                total_cost = new_node.cost + dist_other + other_near.cost\n                return (new_node, other_near, total_cost)\n            return None\n\n        def extract_nodes_edges(path):\n            nodes = []\n            edges = []\n            prev = None\n            for pos in path:\n                n = Node(pos)\n                nodes.append(n)\n                if prev is not None:\n                    edges.append((prev, n))\n                prev = n\n            return nodes, edges\n\n        def local_shortcut(path):\n            if len(path) < 3:\n                return path[:]\n            new_path = path[:]\n            attempts = 0\n            while attempts < self.max_local_shortcuts and len(new_path) >= 3:\n                i = random.randint(0, len(new_path) - 3)\n                j = random.randint(i + 2, len(new_path) - 1)\n                if not collision_edge(new_path[i], new_path[j]):\n                    valid = True\n                    if i > 0 and j < len(new_path) - 1:\n                        ang_before = angle_between(new_path[i - 1], new_path[i], new_path[i + 1])\n                        ang_after = angle_between(new_path[i - 1], new_path[i], new_path[j])\n                        ang_after2 = angle_between(new_path[i], new_path[j], new_path[j + 1])\n                        if ang_after > ang_before * 1.38 or ang_after2 > math.pi * 0.93:\n                            valid = False\n                    if valid:\n                        del new_path[i + 1:j]\n                        attempts += 1\n                    else:\n                        attempts += 1\n                else:\n                    attempts += 1\n            return new_path\n\n        def gaussian_smooth(path):\n            if len(path) < 4:\n                return path[:]\n            pts = [list(p) for p in path]\n            momentum = self.smoothing_momentum\n            prev_cost = None\n            for _ in range(self.smoothing_iters):\n                changed = False\n                new_pts = [pts[0][:]]\n                for i in range(1, len(pts) - 1):\n                    prev_pt = pts[i - 1]\n                    curr_pt = pts[i]\n                    next_pt = pts[i + 1]\n                    avg_pt = [(prev_pt[d] + curr_pt[d] * 4 + next_pt[d]) / 6.0 for d in range(dim)]\n                    if not collision_node(tuple(avg_pt)) and not collision_edge(tuple(prev_pt), tuple(avg_pt)) \\\n                            and not collision_edge(tuple(avg_pt), tuple(next_pt)):\n                        ang_before = angle_between(tuple(prev_pt), tuple(curr_pt), tuple(next_pt))\n                        ang_after = angle_between(tuple(prev_pt), tuple(avg_pt), tuple(next_pt))\n                        accept = False\n                        if ang_after <= ang_before:\n                            accept = True\n                        else:\n                            if ang_after <= ang_before * 1.1:\n                                accept = True\n                        if accept:\n                            # Momentum-based interpolation between avg_pt and curr_pt\n                            interp_pt = [curr_pt[d] * momentum + avg_pt[d] * (1 - momentum) for d in range(dim)]\n                            new_pts.append(interp_pt)\n                            changed = True\n                        else:\n                            new_pts.append(curr_pt)\n                    else:\n                        new_pts.append(curr_pt)\n                new_pts.append(pts[-1][:])\n                pts = new_pts\n                # Optional early stop if no change or smoothness cost doesn't improve significantly\n                # Compute rough smoothness cost: sum of curvature angles\n                def smoothness_cost(pnts):\n                    cost = 0.0\n                    for k in range(1, len(pnts) - 1):\n                        cost += angle_between(pnts[k - 1], pnts[k], pnts[k + 1])\n                    return cost\n\n                current_cost = smoothness_cost(pts)\n                if prev_cost is not None and (prev_cost - current_cost) < 1e-4:\n                    break\n                prev_cost = current_cost\n                if not changed:\n                    break\n            return [tuple(p) for p in pts]\n\n        start_tree = [Node(start_pos, None, 0.0)]\n        goal_tree = [Node(goal_pos, None, 0.0)]\n        all_nodes = start_tree + goal_tree\n        edges = []\n        start_hash = {}\n        goal_hash = {}\n        add_to_hash(start_hash, start_tree[0])\n        add_to_hash(goal_hash, goal_tree[0])\n\n        best_cost = float('inf')\n        best_start_node = None\n        best_goal_node = None\n        last_improvement_iter = 0\n\n        for it in range(1, self.max_iter + 1):\n            iter_ratio = it / self.max_iter\n            sample = ellipsoidal_informed_sample(best_cost, it)\n\n            # Expand alternately start and goal trees with reversed seq every iteration\n            if it % 2 == 1:\n                seq = [(start_tree, start_hash, goal_hash), (goal_tree, goal_hash, start_hash)]\n            else:\n                seq = [(goal_tree, goal_hash, start_hash), (start_tree, start_hash, goal_hash)]\n\n            improved_this_iter = False\n            for tree, tree_hash, other_hash in seq:\n                res = attempt_expand(tree, tree_hash, other_hash, sample, best_cost, iter_ratio)\n                if res:\n                    new_node, conn_node, candidate_cost = res\n                    if candidate_cost + 1e-15 < best_cost:\n                        best_cost = candidate_cost\n                        last_improvement_iter = it\n                        improved_this_iter = True\n                        if tree is start_tree:\n                            best_start_node, best_goal_node = new_node, conn_node\n                        else:\n                            best_start_node, best_goal_node = conn_node, new_node\n\n            # Early stop if no improvement for no_improve_stop iterations\n            if it - last_improvement_iter > self.no_improve_stop and best_cost < float('inf'):\n                break\n\n            # Frequent local shortcut and smoothing to prune\n            if best_cost < float('inf') and best_start_node and best_goal_node:\n                if it % self.local_shortcut_interval == 0 or it == self.max_iter:\n                    raw_path = extract_path(best_start_node, best_goal_node)\n                    shortcutted = local_shortcut(raw_path)\n                    smoothed = gaussian_smooth(shortcutted)\n                    nodes_out, edges_out = extract_nodes_edges(smoothed)\n                    return PlannerResult(True, smoothed, nodes_out, edges_out)\n\n        # If no path found, return failure with all nodes and no edges\n        return PlannerResult(False, [], all_nodes, edges)",
          "objective": -24.74655,
          "time_improvement": 38.0,
          "length_improvement": 12.0,
          "smoothness_improvement": 1317.0,
          "node_improvement": 98.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.030016565322875978,
                    "num_nodes_avg": 14.1,
                    "path_length_avg": 179.9872449276465,
                    "smoothness_avg": 0.03556942969605148,
                    "success_improvement": 0.0,
                    "time_improvement": -16.384730227549014,
                    "node_improvement": 96.44925711407706,
                    "length_improvement": 1.3461389747480768,
                    "smoothness_improvement": 456.7388149960638,
                    "objective_score": -1.824041608435539
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.027966880798339845,
                    "num_nodes_avg": 7.1,
                    "path_length_avg": 239.23197112424504,
                    "smoothness_avg": 0.0946968940862508,
                    "success_improvement": 0.0,
                    "time_improvement": 83.10930792593194,
                    "node_improvement": 99.52294564267957,
                    "length_improvement": 20.137482128237867,
                    "smoothness_improvement": 2336.6192922550786,
                    "objective_score": 48.6983781159977
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.02747805118560791,
                    "num_nodes_avg": 6.6,
                    "path_length_avg": 130.92330873802592,
                    "smoothness_avg": 0.09876166849570775,
                    "success_improvement": 0.0,
                    "time_improvement": 45.85304800443131,
                    "node_improvement": 99.16083916083916,
                    "length_improvement": 13.04697223421844,
                    "smoothness_improvement": 1156.2411334373305,
                    "objective_score": 27.365303409047108
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "A streamlined bidirectional RRT* planner employing simplified adaptive radius rewiring and refined elliptical informed sampling, combined with efficient collision checking and iterative cautious shortcutting to improve path length and smoothness while maintaining fast convergence and robustness. The planner symmetrically grows trees from start and goal, samples within an informed ellipsoid adapting to the best found path, selects parents minimizing cost with collision-free edges, and performs local rewiring. Periodic cautious shortcutting is applied to enhance smoothness without sharp deviations, balancing exploration and exploitation efficiently.",
          "planning_mechanism": "The planner grows two trees rooted at start and goal alternately, samples points using goal-biased uniform sampling or elliptical informed sampling based on current best cost. It extends trees toward samples with fixed step size, selects optimal parents within an adaptive neighborhood radius, and rewires nearby nodes if cost improves without collision. Trees attempt connection each iteration within step size. Upon connection, the path is extracted and improved via cautious multi-pass shortcutting that avoids sharp turns, outputting a collision-free, smoother, shorter path efficiently.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\nclass Planner:\n    def __init__(self, max_iter=3000, step_size=6.0, r_min=5.0, r_max=25.0, goal_sample_rate=0.1):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.r_min = r_min\n        self.r_max = r_max\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map):\n        import math\n        import random\n\n        bounds = map.size\n        start_pos = tuple(map.start)\n        goal_pos = tuple(map.goal)\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def in_bounds(p):\n            return all(0 <= p[i] <= bounds[i] for i in range(dim))\n\n        def node_collision(p):\n            px, py = p[0], p[1]\n            pz = p[2] if is_3d else 0.0\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def edge_collision(a, b, resolution=1.0):\n            dist_val = dist(a, b)\n            steps = max(1, int(dist_val / resolution))\n            for s in range(steps + 1):\n                t = s / steps\n                interp = tuple(a[i] + t * (b[i] - a[i]) for i in range(dim))\n                if node_collision(interp):\n                    return True\n            return False\n\n        def steer(from_p, to_p):\n            d = dist(from_p, to_p)\n            if d <= self.step_size:\n                return to_p\n            ratio = self.step_size / d\n            return tuple(from_p[i] + (to_p[i] - from_p[i]) * ratio for i in range(dim))\n\n        def adaptive_radius(n_nodes):\n            if n_nodes < 2:\n                return self.r_max\n            gamma = 35.0\n            val = gamma * (math.log(n_nodes) / n_nodes) ** (1 / dim)\n            return max(self.r_min, min(self.r_max, val))\n\n        def sample(best_cost):\n            if random.random() < self.goal_sample_rate:\n                return goal_pos\n            if best_cost == float('inf'):\n                while True:\n                    pt = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                    if not node_collision(pt):\n                        return pt\n            # informed ellipse sampling\n            c_min = dist(start_pos, goal_pos)\n            c_best = best_cost\n            if c_best < float('inf'):\n                center = tuple((start_pos[i] + goal_pos[i]) * 0.5 for i in range(dim))\n                foci_dist = c_min\n                val = c_best * c_best - foci_dist * foci_dist\n                r1 = c_best / 2.0\n                r_rest = math.sqrt(val) / 2.0 if val > 0 else 0.0\n\n                def unit_ball_sample():\n                    while True:\n                        vec = [random.gauss(0, 1) for _ in range(dim)]\n                        norm = math.sqrt(sum(x * x for x in vec))\n                        if norm > 1e-8:\n                            u = [x / norm for x in vec]\n                            r = random.random() ** (1.0 / dim)\n                            return [u[i] * r for i in range(dim)]\n\n                while True:\n                    u_sample = unit_ball_sample()\n                    sample_pt = [0.0] * dim\n                    sample_pt[0] = u_sample[0] * r1\n                    for i in range(1, dim):\n                        sample_pt[i] = u_sample[i] * r_rest\n                    pt = tuple(center[i] + sample_pt[i] for i in range(dim))\n                    if in_bounds(pt) and not node_collision(pt):\n                        return pt\n            else:\n                while True:\n                    pt = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                    if not node_collision(pt):\n                        return pt\n\n        def nearest(tree, point):\n            best_node = None\n            best_d = float('inf')\n            for n in tree:\n                d = dist(n.position, point)\n                if d < best_d:\n                    best_node = n\n                    best_d = d\n            return best_node\n\n        def near(tree, point, radius):\n            radius_sq = radius * radius\n            result = []\n            for n in tree:\n                d_sq = sum((n.position[i] - point[i]) ** 2 for i in range(dim))\n                if d_sq <= radius_sq:\n                    result.append(n)\n            return result\n\n        def update_costs(node):\n            for child in node.children:\n                new_cost = node.cost + dist(node.position, child.position)\n                if new_cost + 1e-14 < child.cost:\n                    child.cost = new_cost\n                    update_costs(child)\n\n        def extract_path(n_start, n_goal):\n            path_start = []\n            n = n_start\n            while n:\n                path_start.append(n.position)\n                n = n.parent\n            path_goal = []\n            n = n_goal\n            while n:\n                path_goal.append(n.position)\n                n = n.parent\n            return path_start[::-1] + path_goal\n\n        def shortcut_path(path, max_passes=4, max_attempts=150):\n            if len(path) < 3:\n                return path[:]\n            new_path = path[:]\n            for _ in range(max_passes):\n                improved = False\n                attempts = 0\n                i = 0\n                while i < len(new_path) - 2 and attempts < max_attempts:\n                    j = random.randint(i + 2, len(new_path) - 1)\n                    if edge_collision(new_path[i], new_path[j]):\n                        i += 1\n                        attempts += 1\n                        continue\n                    # Check turning angles to avoid sharp bends\n                    def angle(a, b, c):\n                        import math\n                        ab = [b[d] - a[d] for d in range(dim)]\n                        cb = [b[d] - c[d] for d in range(dim)]\n                        lab = math.sqrt(sum(x * x for x in ab))\n                        lcb = math.sqrt(sum(x * x for x in cb))\n                        if lab < 1e-8 or lcb < 1e-8:\n                            return 0\n                        dot = sum(ab[d] * cb[d] for d in range(dim))\n                        val = max(min(dot / (lab * lcb), 1.0), -1.0)\n                        return math.acos(val)\n\n                    cond = True\n                    if i > 0:\n                        a, b, c = new_path[i - 1], new_path[i], new_path[j]\n                        if angle(a, b, c) > 3 * math.pi / 4:  # >135 degrees\n                            cond = False\n                    if cond and j < len(new_path) - 1:\n                        a, b, c = new_path[i], new_path[j], new_path[j + 1]\n                        if angle(a, b, c) > 3 * math.pi / 4:\n                            cond = False\n                    if cond:\n                        new_path = new_path[:i + 1] + new_path[j:]\n                        improved = True\n                        i = 0\n                        attempts += 1\n                    else:\n                        i += 1\n                        attempts += 1\n                if not improved:\n                    break\n            return new_path\n\n        best_cost = float('inf')\n        solution_nodes = (None, None)\n\n        for it in range(self.max_iter):\n            pt = sample(best_cost)\n\n            # Alternate tree growth\n            if it % 2 == 0:\n                tree_a, tree_b = start_tree, goal_tree\n            else:\n                tree_a, tree_b = goal_tree, start_tree\n\n            nearest_node = nearest(tree_a, pt)\n            new_pos = steer(nearest_node.position, pt)\n\n            if not in_bounds(new_pos):\n                continue\n            if node_collision(new_pos):\n                continue\n            if edge_collision(nearest_node.position, new_pos):\n                continue\n\n            r = adaptive_radius(len(tree_a))\n            near_nodes = near(tree_a, new_pos, r)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            min_parent = nearest_node\n            for cand in near_nodes:\n                if cand is nearest_node:\n                    continue\n                cost_cand = cand.cost + dist(cand.position, new_pos)\n                if cost_cand + 1e-14 < min_cost and not edge_collision(cand.position, new_pos):\n                    min_cost = cost_cand\n                    min_parent = cand\n\n            new_node = Node(new_pos, min_parent, min_cost)\n            min_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((min_parent, new_node))\n\n            for near_node in near_nodes:\n                if near_node is min_parent or near_node is new_node:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, near_node.position)\n                if new_cost + 1e-14 < near_node.cost and not edge_collision(new_node.position, near_node.position):\n                    if near_node.parent:\n                        near_node.parent.remove_child(near_node)\n                        try:\n                            edges.remove((near_node.parent, near_node))\n                        except ValueError:\n                            pass\n                    near_node.parent = new_node\n                    near_node.cost = new_cost\n                    new_node.add_child(near_node)\n                    edges.append((new_node, near_node))\n                    update_costs(near_node)\n\n            nearest_other = nearest(tree_b, new_node.position)\n            dist_con = dist(nearest_other.position, new_node.position)\n            if dist_con <= self.step_size and not edge_collision(nearest_other.position, new_node.position):\n                total_cost = new_node.cost + dist_con + nearest_other.cost\n                if total_cost + 1e-14 < best_cost:\n                    best_cost = total_cost\n                    if it % 2 == 0:\n                        solution_nodes = (new_node, nearest_other)\n                    else:\n                        solution_nodes = (nearest_other, new_node)\n\n            if solution_nodes[0] and solution_nodes[1] and (it % 60 == 0 or it == self.max_iter - 1):\n                raw_path = extract_path(solution_nodes[0], solution_nodes[1])\n                short_path = shortcut_path(raw_path, max_passes=5, max_attempts=200)\n                if short_path:\n                    return PlannerResult(True, short_path, nodes, edges)\n\n        if solution_nodes[0] and solution_nodes[1]:\n            raw_path = extract_path(solution_nodes[0], solution_nodes[1])\n            short_path = shortcut_path(raw_path, max_passes=5, max_attempts=200)\n            return PlannerResult(True, short_path, nodes, edges)\n\n        return PlannerResult(False, [], nodes, edges)",
          "objective": -24.49867,
          "time_improvement": 49.0,
          "length_improvement": 13.0,
          "smoothness_improvement": 442.0,
          "node_improvement": 68.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.022717666625976563,
                    "num_nodes_avg": 183.8,
                    "path_length_avg": 169.35702476940347,
                    "smoothness_avg": 0.023703810745518868,
                    "success_improvement": 0.0,
                    "time_improvement": 11.91565479849687,
                    "node_improvement": 53.714429614706624,
                    "length_improvement": 7.172731090098877,
                    "smoothness_improvement": 271.0161118162685,
                    "objective_score": 9.233415652689729
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.032560324668884276,
                    "num_nodes_avg": 289.0,
                    "path_length_avg": 255.25648444467683,
                    "smoothness_avg": 0.02286526971496877,
                    "success_improvement": 0.0,
                    "time_improvement": 80.33508199289592,
                    "node_improvement": 80.58187193442183,
                    "length_improvement": 14.788038341835955,
                    "smoothness_improvement": 488.33985895423257,
                    "objective_score": 35.41504689774151
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.0229816198348999,
                    "num_nodes_avg": 227.0,
                    "path_length_avg": 126.47150951572493,
                    "smoothness_avg": 0.05237959417986045,
                    "success_improvement": 0.0,
                    "time_improvement": 54.71350360419659,
                    "node_improvement": 71.13795295613478,
                    "length_improvement": 16.003645305772068,
                    "smoothness_improvement": 566.2645717083553,
                    "objective_score": 28.847561123263993
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "path_expert",
          "algorithm_description": "A refined bidirectional RRT* planner incorporating adaptive informed sampling focused on progressively shrinking ellipsoidal regions, combined rewiring with multi-scale neighborhoods for fine and coarse optimization, and hierarchical smoothing via iterative shortcutting and curvature-based node pruning to yield minimal path length and enhanced smoothness efficiently. The planner adapts radius heuristics by tree density and dimension, performs dynamic rewiring for both local and extended neighborhoods, and aggressively shortcuts with curvature checks to remove zigzags and redundant nodes, reducing planning time and improving path quality.",
          "planning_mechanism": "The planner alternates expanding start and goal trees using goal-biased and informed sampling within ellipsoids defined by the current best solution cost to restrict unnecessary exploration. Upon adding nodes, it chooses optimal parents from a two-tier neighborhood (small and large radius) to balance local and global optimization and rewires neighbors accordingly. After connecting trees, it extracts a path that undergoes iterative shortcutting combined with curvature-driven pruning to remove short sharp turns, improving smoothness and path minimality. This integrated approach accelerates convergence to shorter, smoother paths with reduced total planning time.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n    def add_child(self, child):\n        self.children.append(child)\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\nclass Planner:\n    def __init__(self, max_iter=3500, step_size=7.0, radius_const=28.0, goal_bias=0.12, shortcut_interval=30, curvature_tol=0.22):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.radius_const = radius_const\n        self.goal_bias = goal_bias\n        self.shortcut_interval = shortcut_interval\n        self.curvature_tol = curvature_tol  # radians threshold for pruning\n\n    def plan(self, map):\n        import random\n        import math\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        best_cost = float('inf')\n        solution_start, solution_goal = None, None\n\n        dist_start_goal = math.dist(start_pos, goal_pos)\n\n        def radius(n):\n            # Adaptive radius with constants tuned for near-optimal rewiring\n            return min(self.radius_const * ((math.log(n + 1) / (n + 1)) ** (1.0 / dim)), self.step_size * 35)\n\n        def radius_small(n):\n            # Smaller radius for fine rewiring (local neighborhood)\n            return min(0.42 * self.step_size * ((math.log(n + 1) / (n + 1)) ** (1.0 / dim)), self.step_size * 15)\n\n        def near(tree, pos, r):\n            r_sq = r * r\n            return [n for n in tree if sum((n.position[i] - pos[i]) ** 2 for i in range(dim)) <= r_sq]\n\n        def steer(from_pos, to_pos, max_step):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= max_step:\n                return to_pos\n            ratio = max_step / dist\n            return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(dim))\n\n        def in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    px, py = pos\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def edge_in_obstacle(p1, p2, resolution=1.0):\n            dist = math.dist(p1, p2)\n            steps = max(1, int(dist / resolution))\n            for i in range(steps + 1):\n                interp = tuple(p1[d] + (p2[d] - p1[d]) * (i / steps) for d in range(dim))\n                if in_obstacle(interp):\n                    return True\n            return False\n\n        def sample_free():\n            while True:\n                pt = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not in_obstacle(pt):\n                    return pt\n\n        def informed_sample(c_max):\n            if c_max == float('inf'):\n                return sample_free()\n            if random.random() < self.goal_bias:\n                return goal_pos\n            # Ellipsoidal informed sampling around start to goal line\n            c_min = dist_start_goal\n            if c_max <= c_min:\n                return sample_free()\n            center = tuple((start_pos[i] + goal_pos[i]) / 2.0 for i in range(dim))\n            dir_vec = [goal_pos[i] - start_pos[i] for i in range(dim)]\n            length = c_min\n            if length == 0:\n                return sample_free()\n\n            # Rotation matrix from unit x-axis vector to direction vector\n            if dim == 2:\n                from math import cos, sin, pi, sqrt\n                a1 = (1, 0)\n                a2 = (dir_vec[0] / length, dir_vec[1] / length)\n                cos_theta = a1[0] * a2[0] + a1[1] * a2[1]\n                sin_theta = a1[0] * a2[1] - a1[1] * a2[0]\n                R = [[cos_theta, -sin_theta],\n                     [sin_theta, cos_theta]]\n                r = random.random() ** 0.5\n                theta = random.uniform(0, 2 * math.pi)\n                x_ball = [r * math.cos(theta), r * math.sin(theta)]\n                a1_val = c_max / 2.0\n                a_other = math.sqrt(c_max ** 2 - c_min ** 2) / 2.0\n                L = [[a1_val, 0], [0, a_other]]\n                x_scaled = [L[0][0] * x_ball[0] + L[0][1] * x_ball[1],\n                            L[1][0] * x_ball[0] + L[1][1] * x_ball[1]]\n                pt = (center[0] + R[0][0] * x_scaled[0] + R[0][1] * x_scaled[1],\n                      center[1] + R[1][0] * x_scaled[0] + R[1][1] * x_scaled[1])\n            else:\n                from math import sqrt\n                # 3D rotation from [1,0,0] to normalized dir_vec\n                a1 = [1, 0, 0]\n                a2 = [dir_vec[i] / length for i in range(3)]\n                v = [a1[1] * a2[2] - a1[2] * a2[1],\n                     a1[2] * a2[0] - a1[0] * a2[2],\n                     a1[0] * a2[1] - a1[1] * a2[0]]\n                s = sqrt(sum(vi * vi for vi in v))\n                c = sum(a1[i] * a2[i] for i in range(3))\n                if s == 0:\n                    R = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n                else:\n                    vx = [[0, -v[2], v[1]],\n                          [v[2], 0, -v[0]],\n                          [-v[1], v[0], 0]]\n                    I = [[1 if i == j else 0 for j in range(3)] for i in range(3)]\n                    vx2 = [[sum(vx[i][k] * vx[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n                    R = [[I[i][j] + vx[i][j] + vx2[i][j] * ((1 - c) / (s ** 2)) for j in range(3)] for i in range(3)]\n\n                while True:\n                    x_ball = [random.uniform(-1, 1) for _ in range(3)]\n                    norm_sq = sum(xi * xi for xi in x_ball)\n                    if norm_sq <= 1:\n                        break\n                a1_val = c_max / 2.0\n                a_other = sqrt(c_max ** 2 - c_min ** 2) / 2.0\n                L = [[a1_val, 0, 0], [0, a_other, 0], [0, 0, a_other]]\n                x_scaled = [L[0][0] * x_ball[0], L[1][1] * x_ball[1], L[2][2] * x_ball[2]]\n                pt = tuple(center[i] + sum(R[i][j] * x_scaled[j] for j in range(3)) for i in range(3))\n\n            # Clamp sample inside bounds and avoid obstacles\n            if any(pt[d] < 0 or pt[d] > bounds[d] for d in range(dim)):\n                return sample_free()\n            if in_obstacle(pt):\n                return sample_free()\n            return pt\n\n        def extract_path(nstart, ngoal):\n            # Path from nstart to root\n            ps = []\n            node = nstart\n            while node:\n                ps.append(node.position)\n                node = node.parent\n            ps.reverse()\n            # Path from ngoal to root (skip root because goal repeated)\n            pg = []\n            node = ngoal\n            while node:\n                pg.append(node.position)\n                node = node.parent\n            # join paths\n            return ps + pg\n\n        def curvature(pA, pB, pC):\n            # Calculate the curvature from three points (A,B,C)\n            # Using cosine law formula for angle at B\n            import math\n            def dist(u, v):\n                return math.dist(u, v)\n            a = dist(pB, pC)\n            b = dist(pA, pC)\n            c = dist(pA, pB)\n            if a * c == 0:\n                return 0.0\n            cos_angle = (a * a + c * c - b * b) / (2 * a * c)\n            cos_angle = min(1.0, max(-1.0, cos_angle))\n            return math.acos(cos_angle)\n\n        def shortcut_path(path, max_attempts=100):\n            if len(path) < 3:\n                return path[:]\n            new_path = path[:]\n            attempts = 0\n            while attempts < max_attempts:\n                if len(new_path) < 3:\n                    break\n                import random\n                i = random.randint(0, len(new_path) - 3)\n                j = random.randint(i + 2, len(new_path) - 1)\n                if not edge_in_obstacle(new_path[i], new_path[j]):\n                    # Replace intermediate nodes [i+1...j-1]\n                    new_path = new_path[:i + 1] + new_path[j:]\n                    attempts = 0\n                else:\n                    attempts += 1\n            return new_path\n\n        def prune_curvature(path):\n            # Remove nodes creating sharp small bends iteratively\n            if len(path) < 4:\n                return path[:]\n            changed = True\n            new_path = path[:]\n            while changed:\n                changed = False\n                n = len(new_path)\n                i = 1\n                while i < n - 1:\n                    angle = curvature(new_path[i - 1], new_path[i], new_path[i + 1])\n                    if angle < self.curvature_tol:\n                        # Try removing node i if edge between neighbors collision free\n                        if not edge_in_obstacle(new_path[i - 1], new_path[i + 1]):\n                            new_path.pop(i)\n                            n -= 1\n                            changed = True\n                            # Do not increment i, test new triple from same index\n                            continue\n                    i += 1\n            return new_path\n\n        def attach_new_node(tree, new_pos):\n            n_nodes = len(tree)\n            new_node = Node(new_pos)\n            # Near nodes large radius\n            R_big = radius(n_nodes)\n            near_big = near(tree, new_pos, R_big)\n            # Near nodes smaller radius for fine rewiring\n            R_small = radius_small(n_nodes)\n            near_small = near(tree, new_pos, R_small)\n            if len(near_big) == 0:\n                # Fallback to nearest as parent if no near\n                nearest = min(tree, key=lambda n: math.dist(n.position, new_pos))\n                if edge_in_obstacle(nearest.position, new_pos):\n                    return None\n                new_node.parent = nearest\n                new_node.cost = nearest.cost + math.dist(nearest.position, new_pos)\n                nearest.add_child(new_node)\n                tree.append(new_node)\n                return new_node\n\n            # Choose best parent from large radius near neighbors with collision-free edge\n            min_cost = float('inf')\n            best_parent = None\n            for neighbor in near_big:\n                if edge_in_obstacle(neighbor.position, new_pos):\n                    continue\n                cost = neighbor.cost + math.dist(neighbor.position, new_pos)\n                if cost < min_cost:\n                    min_cost = cost\n                    best_parent = neighbor\n            if best_parent is None:\n                return None\n            new_node.parent = best_parent\n            new_node.cost = min_cost\n            best_parent.add_child(new_node)\n            tree.append(new_node)\n\n            # Rewire: first use large radius neighbors to check global improvement\n            for neighbor in near_big:\n                if neighbor is best_parent:\n                    continue\n                if edge_in_obstacle(new_node.position, neighbor.position):\n                    continue\n                cost_through_new = new_node.cost + math.dist(new_node.position, neighbor.position)\n                if cost_through_new + 1e-6 < neighbor.cost:\n                    # Update parent of neighbor to new_node\n                    old_parent = neighbor.parent\n                    if old_parent:\n                        old_parent.remove_child(neighbor)\n                    neighbor.parent = new_node\n                    neighbor.cost = cost_through_new\n                    new_node.add_child(neighbor)\n\n            # Further, perform finer rewiring with smaller radius neighbors to polish local connections\n            for neighbor in near_small:\n                if neighbor is best_parent:\n                    continue\n                if edge_in_obstacle(new_node.position, neighbor.position):\n                    continue\n                cost_through_new = new_node.cost + math.dist(new_node.position, neighbor.position)\n                if cost_through_new + 1e-6 < neighbor.cost:\n                    old_parent = neighbor.parent\n                    if old_parent:\n                        old_parent.remove_child(neighbor)\n                    neighbor.parent = new_node\n                    neighbor.cost = cost_through_new\n                    new_node.add_child(neighbor)\n\n            return new_node\n\n        for iteration in range(self.max_iter):\n            c_max_use = best_cost if best_cost < float('inf') else float('inf')\n            x_rand = informed_sample(c_max_use)\n\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest = min(tree_a, key=lambda n: math.dist(n.position, x_rand))\n                new_pos = steer(nearest.position, x_rand, self.step_size)\n                if in_obstacle(new_pos) or edge_in_obstacle(nearest.position, new_pos):\n                    continue\n                new_node = attach_new_node(tree_a, new_pos)\n                if new_node is None:\n                    continue\n\n                # Try to connect the other tree\n                nearest_other = min(tree_b, key=lambda n: math.dist(n.position, new_node.position))\n                dist_connect = math.dist(new_node.position, nearest_other.position)\n                if dist_connect <= self.step_size and not edge_in_obstacle(new_node.position, nearest_other.position):\n                    path_cost = new_node.cost + dist_connect + nearest_other.cost\n                    if path_cost + 1e-7 < best_cost:\n                        best_cost = path_cost\n                        # Mark connection direction for path extraction\n                        if tree_a is start_tree:\n                            solution_start, solution_goal = new_node, nearest_other\n                        else:\n                            solution_start, solution_goal = nearest_other, new_node\n\n            # Progressive shortcutting and smoothing after some improvements or interval\n            if best_cost < float('inf') and solution_start and solution_goal and (iteration % self.shortcut_interval == 0 or iteration == self.max_iter - 1):\n                raw_path = extract_path(solution_start, solution_goal)\n                # Iteratively shortcut path aggressively with pruning\n                shorted = shortcut_path(raw_path, max_attempts=120)\n                pruned = prune_curvature(shorted)\n                if pruned and len(pruned) >= 2:\n                    return PlannerResult(True, pruned, nodes, edges)\n\n        # Return failure and last best nodes/edges if no path found\n        return PlannerResult(False, [], nodes, edges)",
          "objective": -24.38604,
          "time_improvement": 26.0,
          "length_improvement": 14.0,
          "smoothness_improvement": 1581.0,
          "node_improvement": 100.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.02613198757171631,
                    "num_nodes_avg": 2.0,
                    "path_length_avg": 166.51088262332885,
                    "smoothness_avg": 0.05025803213293863,
                    "success_improvement": 0.0,
                    "time_improvement": -1.3228625970076129,
                    "node_improvement": 99.49634852681945,
                    "length_improvement": 8.73274670037076,
                    "smoothness_improvement": 686.6473399440655,
                    "objective_score": 8.2760259408405
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.03163425922393799,
                    "num_nodes_avg": 2.0,
                    "path_length_avg": 241.39906339940762,
                    "smoothness_avg": 0.0971089706431334,
                    "success_improvement": 0.0,
                    "time_improvement": 80.89438234475895,
                    "node_improvement": 99.86561849089566,
                    "length_improvement": 19.414044350496003,
                    "smoothness_improvement": 2398.683759412188,
                    "objective_score": 47.91016011078622
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.05096986293792725,
                    "num_nodes_avg": 2.0,
                    "path_length_avg": 128.45238253246742,
                    "smoothness_avg": 0.13822002357252447,
                    "success_improvement": 0.0,
                    "time_improvement": -0.43880852679198545,
                    "node_improvement": 99.74570883661794,
                    "length_improvement": 14.688043767088448,
                    "smoothness_improvement": 1658.1484975016301,
                    "objective_score": 16.971926189723625
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "A bidirectional RRT* planner that uses a hybrid sampling strategy blending uniform and ellipsoidal informed samples, employs an adaptive rewiring radius based on both tree size and best path cost, and improves path quality and smoothness through incremental shortcutting combined with periodic global smoothing. The planner performs efficient nearest neighbor searches, dynamic rewiring, and early solution updating to boost planning speed, path length minimization, and path smoothness.",
          "planning_mechanism": "The planner alternately grows two trees from the start and goal points by sampling points within a combination of uniform and shrinking ellipsoidal informed regions. Each newly added node rewires nearby nodes within an adaptive radius that scales with the number of tree nodes and current best solution cost. Incremental local shortcutting is applied frequently, and global smoothing runs periodically to enhance path smoothness. Connections between the two trees happen based on an adaptive connection threshold derived from the rewiring radius. The planner returns the first significantly improved feasible path found.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n    \n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except ValueError:\n            pass\nclass Planner:\n    def __init__(self, max_iter=3000, step_size=5.0, gamma=25.0, max_shortcut_attempts=120, goal_bias=0.1, global_smooth_interval=150):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.gamma = gamma\n        self.max_shortcut_attempts = max_shortcut_attempts\n        self.goal_bias = goal_bias\n        self.global_smooth_interval = global_smooth_interval\n\n    def plan(self, map):\n        import math\n        import random\n\n        bounds = map.size\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        obstacles = map.obstacles\n        start_pos = map.start\n        goal_pos = map.goal\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        best_cost = float('inf')\n        sol_start = None\n        sol_goal = None\n        c_min = math.dist(start_pos, goal_pos)\n\n        def in_obstacle(p):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = p\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w_, h_ = obs\n                    px, py = p\n                    if x <= px <= x + w_ and y <= py <= y + h_:\n                        return True\n            return False\n\n        def edge_in_obstacle(p1, p2, resolution=0.35):\n            dist = math.dist(p1, p2)\n            steps = max(2, int(dist / resolution))\n            for step in range(steps + 1):\n                interp = tuple(p1[i] + (p2[i] - p1[i]) * step / steps for i in range(dim))\n                if in_obstacle(interp):\n                    return True\n            return False\n\n        def steer(from_p, to_p):\n            dist = math.dist(from_p, to_p)\n            if dist <= self.step_size:\n                return to_p\n            ratio = self.step_size / dist\n            new_point = tuple(from_p[i] + ratio * (to_p[i] - from_p[i]) for i in range(dim))\n            clipped = tuple(max(0, min(bounds[i], new_point[i])) for i in range(dim))\n            return clipped\n\n        def nearest(tree, point):\n            best_node = None\n            best_dist_sq = float('inf')\n            for node in tree:\n                d2 = 0.0\n                for i in range(dim):\n                    diff = node.position[i] - point[i]\n                    d2 += diff * diff\n                if d2 < best_dist_sq:\n                    best_dist_sq = d2\n                    best_node = node\n            return best_node\n\n        def near_radius(num_nodes, cost_bound):\n            if num_nodes <= 1:\n                return self.step_size * 4.0\n            r1 = self.gamma * (math.log(num_nodes) / num_nodes) ** (1.0 / dim)\n            r2 = self.step_size * max(2.5, min(15.0, cost_bound / (c_min + 1e-8)))\n            return min(r1, r2)\n\n        def near(tree, point, radius):\n            r2 = radius * radius\n            result = []\n            for n in tree:\n                dist2 = 0.0\n                for i in range(dim):\n                    diff = n.position[i] - point[i]\n                    dist2 += diff * diff\n                if dist2 <= r2:\n                    result.append(n)\n            return result\n\n        def update_parent(child, new_parent, new_cost):\n            if child.parent is not None:\n                child.parent.remove_child(child)\n            child.parent = new_parent\n            child.cost = new_cost\n            new_parent.add_child(child)\n\n        def propagate_costs(node):\n            stack = [node]\n            while stack:\n                current = stack.pop()\n                for c in current.children:\n                    new_cost = current.cost + math.dist(current.position, c.position)\n                    if new_cost + 1e-12 < c.cost:\n                        update_parent(c, current, new_cost)\n                        stack.append(c)\n\n        def extract_path(n_start, n_goal):\n            path_start = []\n            cur = n_start\n            while cur is not None:\n                path_start.append(cur.position)\n                cur = cur.parent\n            path_goal = []\n            cur = n_goal\n            while cur is not None:\n                path_goal.append(cur.position)\n                cur = cur.parent\n            if path_start[-1] == path_goal[-1]:\n                path_goal.pop()\n            return path_start[::-1] + path_goal\n\n        def incremental_shortcut(path):\n            if len(path) < 3:\n                return path[:]\n            pth = path[:]\n            attempts_limit = min(self.max_shortcut_attempts, max(30, int(len(pth)/1.5)))\n            attempts = 0\n            while attempts < attempts_limit:\n                if len(pth) <3:\n                    break\n                i = random.randint(0, len(pth)-3)\n                j = random.randint(i+2, len(pth)-1)\n                if not edge_in_obstacle(pth[i], pth[j]):\n                    pth = pth[:i+1] + pth[j:]\n                    attempts = 0\n                else:\n                    attempts += 1\n            return pth\n\n        def global_smooth(path):\n            # simple global smoothing by iterating attempts to replace segments with direct edges\n            if len(path) < 3:\n                return path[:]\n            pth = path[:]\n            length = len(pth)\n            for _ in range(min(self.max_shortcut_attempts//2, length*2)):\n                i = random.randint(0, length-3)\n                j = random.randint(i+2, length-1)\n                if not edge_in_obstacle(pth[i], pth[j]):\n                    pth = pth[:i+1] + pth[j:]\n                    length = len(pth)\n            return pth\n\n        def sample_hybrid():\n            # With probability goal_bias, sample goal\n            if random.random() < self.goal_bias and not in_obstacle(goal_pos):\n                return goal_pos\n            # If no solution yet or best_cost close to c_min, uniform sampling\n            if best_cost == float('inf') or best_cost <= c_min * 1.05:\n                while True:\n                    pt = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                    if not in_obstacle(pt):\n                        return pt\n            # Else ellipsoidal informed sampling blended with uniform exploration with probabilistic mixing\n            if random.random() < 0.7:\n                # ellipsoidal informed sampling\n                center = tuple(0.5*(start_pos[i]+goal_pos[i]) for i in range(dim))\n                direction = [goal_pos[i]-start_pos[i] for i in range(dim)]\n                length = c_min\n                if dim == 2:\n                    if length < 1e-12:\n                        R = [[1,0],[0,1]]\n                    else:\n                        a1 = [1,0]\n                        a2 = [direction[0]/length, direction[1]/length]\n                        cos_theta = a1[0]*a2[0] + a1[1]*a2[1]\n                        sin_theta = a1[0]*a2[1] - a1[1]*a2[0]\n                        R = [[cos_theta, -sin_theta],[sin_theta, cos_theta]]\n                else:\n                    if length < 1e-12:\n                        R = [[1 if i==j else 0 for j in range(dim)] for i in range(dim)]\n                    else:\n                        a1 = [1,0,0]\n                        a2 = [direction[i]/length for i in range(dim)]\n                        v = [a1[1]*a2[2]-a1[2]*a2[1],\n                             a1[2]*a2[0]-a1[0]*a2[2],\n                             a1[0]*a2[1]-a1[1]*a2[0]]\n                        s = math.sqrt(sum(vi*vi for vi in v))\n                        c = sum(a1[i]*a2[i] for i in range(dim))\n                        if s < 1e-12:\n                            R = [[1 if i==j else 0 for j in range(dim)] for i in range(dim)]\n                        else:\n                            vx = [[0,-v[2],v[1]],\n                                  [v[2],0,-v[0]],\n                                  [-v[1],v[0],0]]\n                            I = [[1 if i==j else 0 for j in range(dim)] for i in range(dim)]\n                            vx2 = [[sum(vx[i][k]*vx[k][j] for k in range(dim)) for j in range(dim)] for i in range(dim)]\n                            R = [[I[i][j]+vx[i][j]+vx2[i][j]*((1-c)/(s*s)) for j in range(dim)] for i in range(dim)]\n                a1_val = best_cost*0.5\n                a_other = math.sqrt(max(best_cost*best_cost - c_min*c_min, 0.0))*0.5\n                while True:\n                    if dim ==2:\n                        r = random.uniform(0,1)**0.5\n                        theta = random.uniform(0, 2*math.pi)\n                        x_ball = [r*math.cos(theta), r*math.sin(theta)]\n                        L = [[a1_val,0],[0,a_other]]\n                        x_scaled = [L[0][0]*x_ball[0]+L[0][1]*x_ball[1],\n                                    L[1][0]*x_ball[0]+L[1][1]*x_ball[1]]\n                        pt = (center[0]+R[0][0]*x_scaled[0]+R[0][1]*x_scaled[1],\n                              center[1]+R[1][0]*x_scaled[0]+R[1][1]*x_scaled[1])\n                    else:\n                        while True:\n                            x_ball = [random.uniform(-1,1) for _ in range(dim)]\n                            if sum(xi*xi for xi in x_ball) <= 1:\n                                break\n                        L = [[0]*dim for _ in range(dim)]\n                        for i in range(dim):\n                            for j in range(dim):\n                                L[i][j] = 0.0\n                        L[0][0] = a1_val\n                        for i in range(1, dim):\n                            L[i][i] = a_other\n                        x_scaled = [sum(L[i][j]*x_ball[j] for j in range(dim)) for i in range(dim)]\n                        pt = tuple(center[i]+sum(R[i][j]*x_scaled[j] for j in range(dim)) for i in range(dim))\n                    if any(pt[d]<0 or pt[d]>bounds[d] for d in range(dim)):\n                        continue\n                    if in_obstacle(pt):\n                        continue\n                    return pt\n            else:\n                # Uniform exploration sampling\n                while True:\n                    pt = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                    if not in_obstacle(pt):\n                        return pt\n\n        def attempt_extend(tree_from, tree_to, sample, cost_bound):\n            nearest_node = nearest(tree_from, sample)\n            new_pos = steer(nearest_node.position, sample)\n            if any(new_pos[i] < 0 or new_pos[i] > bounds[i] for i in range(dim)):\n                return None\n            if in_obstacle(new_pos) or edge_in_obstacle(nearest_node.position, new_pos):\n                return None\n\n            r = near_radius(len(tree_from), cost_bound)\n            near_nodes = near(tree_from, new_pos, r)\n\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            min_parent = nearest_node\n            for node in near_nodes:\n                c_new = node.cost + math.dist(node.position, new_pos)\n                if c_new + 1e-12 < min_cost and not edge_in_obstacle(node.position, new_pos):\n                    min_cost = c_new\n                    min_parent = node\n\n            new_node = Node(new_pos, min_parent, min_cost)\n            min_parent.add_child(new_node)\n            tree_from.append(new_node)\n            nodes.append(new_node)\n            edges.append((min_parent, new_node))\n\n            for node in near_nodes:\n                if node is min_parent:\n                    continue\n                c_through = new_node.cost + math.dist(new_node.position, node.position)\n                if c_through + 1e-12 < node.cost and not edge_in_obstacle(new_node.position, node.position):\n                    update_parent(node, new_node, c_through)\n                    propagate_costs(node)\n                    if node.parent is not None:\n                        try:\n                            edges.remove((node.parent, node))\n                        except ValueError:\n                            pass\n                    edges.append((new_node, node))\n\n            nearest_other = nearest(tree_to, new_node.position)\n            dist_connect = math.dist(new_node.position, nearest_other.position)\n            max_connect_dist = r\n            if dist_connect <= max_connect_dist and not edge_in_obstacle(new_node.position, nearest_other.position):\n                total_cost = new_node.cost + dist_connect + nearest_other.cost\n                return new_node, nearest_other, total_cost\n            return None\n\n        path = None\n        for it in range(1, self.max_iter + 1):\n            sample = sample_hybrid()\n            for tree_a, tree_b in ((start_tree, goal_tree), (goal_tree, start_tree)):\n                res = attempt_extend(tree_a, tree_b, sample, best_cost if best_cost != float('inf') else 1e9)\n                if res is not None:\n                    new_node, connect_node, cost_path = res\n                    if cost_path < best_cost:\n                        best_cost = cost_path\n                        sol_start, sol_goal = (new_node, connect_node) if tree_a is start_tree else (connect_node, new_node)\n                        raw_path = extract_path(sol_start, sol_goal)\n                        path = incremental_shortcut(raw_path)\n                        if it % self.global_smooth_interval == 0:\n                            path = global_smooth(path)\n                        if path and len(path) >= 2:\n                            return PlannerResult(True, path, nodes, edges)\n\n        return PlannerResult(False, [], nodes, edges)",
          "objective": -24.32893,
          "time_improvement": 30.0,
          "length_improvement": 14.0,
          "smoothness_improvement": 1345.0,
          "node_improvement": 70.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.025517725944519044,
                    "num_nodes_avg": 123.1,
                    "path_length_avg": 170.34272343598496,
                    "smoothness_avg": 0.034596724076046935,
                    "success_improvement": 0.0,
                    "time_improvement": 1.0588447369758993,
                    "node_improvement": 69.0002518257366,
                    "length_improvement": 6.6324540315506555,
                    "smoothness_improvement": 441.51385977893085,
                    "objective_score": 6.504695138917817
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.04263021945953369,
                    "num_nodes_avg": 287.0,
                    "path_length_avg": 241.88838424645087,
                    "smoothness_avg": 0.09472703358432175,
                    "success_improvement": 0.0,
                    "time_improvement": 74.25333503821882,
                    "node_improvement": 80.71625344352617,
                    "length_improvement": 19.25069496743331,
                    "smoothness_improvement": 2337.3948032490475,
                    "objective_score": 45.51339150817087
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.0426234245300293,
                    "num_nodes_avg": 313.8,
                    "path_length_avg": 125.75611555299454,
                    "smoothness_avg": 0.10658790176329103,
                    "success_improvement": 0.0,
                    "time_improvement": 16.008289440735243,
                    "node_improvement": 60.10171646535283,
                    "length_improvement": 16.478775912417827,
                    "smoothness_improvement": 1255.7902429285402,
                    "objective_score": 20.968703594313972
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "An advanced bidirectional RRT* planner with adaptive informed sampling, efficiently extended rewiring, and hierarchical smoothing combining cautious multi-pass shortcutting and local spline smoothing. The algorithm incorporates a spatial hashing structure for approximate nearest neighbor search to accelerate planning, uses a dynamic rewiring radius that balances exploration and exploitation, and applies iterative smoothing that relaxes curvature constraints progressively to enhance path quality and smoothness while maintaining fast convergence and robustness in complex environments.",
          "planning_mechanism": "The planner grows two trees simultaneously from start and goal, employing a goal-biased adaptive ellipsoidal informed sampler that shrinks with improvements in path cost. An approximate nearest neighbor search via spatial hashing accelerates neighbor queries for rewiring and parent selection. At each iteration, the planner connects the trees frequently when possible to find and improve the solution early. After solution discovery, a hierarchical smoothing phase performs multiple passes of cautious shortcutting combined with localized cubic spline smoothing on path segments, relaxing angle thresholds adaptively to improve smoothness and path length while avoiding collisions, thereby balancing efficient runtime and superior final path quality.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\nclass Planner:\n    def __init__(self, max_iter=4500, step_size=6.0, r_min=7.0, r_max=40.0, goal_sample_rate=0.1, hash_cell_size=15.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.r_min = r_min\n        self.r_max = r_max\n        self.goal_sample_rate = goal_sample_rate\n        self.hash_cell_size = hash_cell_size\n\n    def plan(self, map):\n        import math\n        import random\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = 3 if is_3d else 2\n\n        # Spatial hash for approximate nearest neighbors\n        class SpatialHash:\n            def __init__(self, cell_size):\n                self.cell_size = cell_size\n                self.cells = {}\n\n            def _cell_coords(self, pos):\n                return tuple(int(pos[i] // self.cell_size) for i in range(dim))\n\n            def add(self, node):\n                c = self._cell_coords(node.position)\n                if c not in self.cells:\n                    self.cells[c] = []\n                self.cells[c].append(node)\n\n            def neighbors(self, pos, radius):\n                r_cells = int(math.ceil(radius/self.cell_size))\n                base_c = self._cell_coords(pos)\n                result = []\n                for dx in range(-r_cells, r_cells+1):\n                    for dy in range(-r_cells, r_cells+1):\n                        if dim == 2:\n                            cell = (base_c[0]+dx, base_c[1]+dy)\n                            result.extend(self.cells.get(cell, []))\n                        else:\n                            for dz in range(-r_cells, r_cells+1):\n                                cell = (base_c[0]+dx, base_c[1]+dy, base_c[2]+dz)\n                                result.extend(self.cells.get(cell, []))\n                return result\n\n        def dist(a,b):\n            return math.dist(a,b)\n\n        def heuristic_forward(p):\n            return dist(p, goal_pos)\n\n        def heuristic_backward(p):\n            return dist(p, start_pos)\n\n        def update_subtree_costs(node):\n            for c in node.children:\n                prev_cost = c.cost\n                new_cost = node.cost + dist(node.position, c.position)\n                if new_cost + 1e-15 < prev_cost:\n                    c.cost = new_cost\n                    update_subtree_costs(c)\n\n        def rewiring_radius(n_nodes):\n            if n_nodes < 2:\n                return self.r_max\n            gamma = 35.0  # slightly more permissive than parents\n            val = gamma * (math.log(n_nodes) / n_nodes) ** (1 / dim)\n            return max(self.r_min, min(self.r_max, val))\n\n        def sample():\n            # goal bias enforced, use ellipsoid sampling if solution known\n            if random.random() < self.goal_sample_rate:\n                return goal_pos\n            if best_cost == float('inf'):\n                while True:\n                    pt = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                    if not self._is_in_obstacle(pt, obstacles, is_3d):\n                        return pt\n            else:\n                center = tuple((start_pos[i] + goal_pos[i]) / 2 for i in range(dim))\n                a1 = [goal_pos[i] - start_pos[i] for i in range(dim)]\n                length = dist(start_pos, goal_pos)\n                if length < 1e-15:\n                    return goal_pos\n\n                e1 = [x / length for x in a1]\n\n                def orthonormal_basis(dim_, e1_):\n                    basis_ = [e1_]\n                    if dim_ == 2:\n                        basis_.append((-e1_[1], e1_[0]))\n                    else:\n                        v = [1, 0, 0] if abs(e1_[0]) < 0.9 else [0,1,0]\n                        u = [v[i] - e1_[i]*sum(v[j]*e1_[j] for j in range(3)) for i in range(3)]\n                        u_norm = math.sqrt(sum(x*x for x in u))\n                        if u_norm < 1e-15:\n                            u = [0,0,1]\n                            u_norm = 1\n                        u = [x/u_norm for x in u]\n                        w = [e1_[1]*u[2] - e1_[2]*u[1],\n                             e1_[2]*u[0] - e1_[0]*u[2],\n                             e1_[0]*u[1] - e1_[1]*u[0]]\n                        basis_.extend([u,w])\n                    return basis_\n\n                B = orthonormal_basis(dim, e1)\n\n                c_min = length\n                c_max = min(best_cost * 1.04, sum(bounds)*10)\n\n                try:\n                    a1_len = c_max / 2.0\n                    a_others = max(((c_max*c_max - c_min*c_min) / 4.0) ** 0.5, 1e-8)\n                except Exception:\n                    a1_len = c_max / 2.0\n                    a_others = a1_len\n\n                while True:\n                    if dim == 2:\n                        r = random.uniform(0, 1) ** 0.5\n                        theta = random.uniform(0, 2*math.pi)\n                        unit_ball = [r*math.cos(theta), r*math.sin(theta)]\n                        coords = [a1_len*unit_ball[0], a_others*unit_ball[1]]\n                        sample_pt = [center[i] + sum(coords[j]*B[j][i] for j in range(dim)) for i in range(dim)]\n                    else:\n                        while True:\n                            u = [random.uniform(-1,1) for _ in range(3)]\n                            norm_u = math.sqrt(sum(x*x for x in u))\n                            if 0 < norm_u <= 1:\n                                unit_ball = [x/norm_u for x in u]\n                                break\n                        coords = [a1_len*unit_ball[0], a_others*unit_ball[1], a_others*unit_ball[2]]\n                        sample_pt = [center[i] + sum(coords[j]*B[j][i] for j in range(dim)) for i in range(dim)]\n                    pt = tuple(sample_pt)\n                    if any(pt[i]<0 or pt[i]>bounds[i] for i in range(dim)): \n                        continue\n                    if self._is_in_obstacle(pt, obstacles, is_3d):\n                        continue\n                    return pt\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            ratio = self.step_size / d\n            return tuple(from_pos[i] + (to_pos[i] - from_pos[i])*ratio for i in range(dim))\n\n        def is_free_node(pos):\n            return not self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def is_free_edge(a,b):\n            return not self._is_edge_in_obstacle(a, b, obstacles, is_3d)\n\n        # Initialize trees and spatial hashes\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = start_tree + goal_tree\n        edges = []\n        hash_start = SpatialHash(self.hash_cell_size)\n        hash_goal = SpatialHash(self.hash_cell_size)\n        hash_start.add(start_tree[0])\n        hash_goal.add(goal_tree[0])\n\n        best_cost = float('inf')\n        solution_nodes = (None, None)\n\n        def nearest(tree_hash, pos):\n            candidates = tree_hash.neighbors(pos, self.r_max)\n            best = None\n            best_d = float('inf')\n            for n in candidates:\n                d = dist(n.position, pos)\n                if d < best_d:\n                    best = n\n                    best_d = d\n            # fallback if no candidates found\n            if best is None:\n                for n in (start_tree if tree_hash is hash_start else goal_tree):\n                    d = dist(n.position, pos)\n                    if d < best_d:\n                        best = n\n                        best_d = d\n            return best\n\n        def near(tree_hash, pos, radius):\n            radius2 = radius*radius\n            candidates = tree_hash.neighbors(pos, radius)\n            result = []\n            for n in candidates:\n                d2 = sum((n.position[i] - pos[i])**2 for i in range(dim))\n                if d2 <= radius2: result.append(n)\n            return result\n\n        def path_from_to(n_start, n_goal):\n            path_s = []\n            n = n_start\n            while n is not None:\n                path_s.append(n.position)\n                n = n.parent\n            path_g = []\n            n = n_goal\n            while n is not None:\n                path_g.append(n.position)\n                n = n.parent\n            return path_s[::-1] + path_g\n\n        def update_subtree(node):\n            for c in node.children:\n                new_c_cost = node.cost + dist(node.position, c.position)\n                if new_c_cost + 1e-15 < c.cost:\n                    c.cost = new_c_cost\n                    update_subtree(c)\n\n        def angle_between(a,b,c):\n            # angle at b between points a-b-c\n            ba = [a[i]-b[i] for i in range(dim)]\n            bc = [c[i]-b[i] for i in range(dim)]\n            len_ba = math.sqrt(sum(x*x for x in ba))\n            len_bc = math.sqrt(sum(x*x for x in bc))\n            if len_ba < 1e-12 or len_bc < 1e-12:\n                return 0.0\n            dot = sum(ba[i]*bc[i] for i in range(dim))\n            val = max(min(dot/(len_ba*len_bc),1),-1)\n            return math.acos(val)\n\n        def shortcut_path(path, max_passes=6, max_attempts=300):\n            if len(path) < 3:\n                return path[:]\n            new_path = path[:]\n            base_angle_thresh = math.pi*150/180  # 150 deg\n            for pass_i in range(max_passes):\n                improved = False\n                attempts = 0\n                angle_thresh = base_angle_thresh + (pass_i * math.pi * 6/180)  # loosen up to ~186 deg progressively\n                angle_thresh = min(angle_thresh, math.pi*186/180)\n                i = 0\n                while i < len(new_path)-2 and attempts < max_attempts:\n                    j = random.randint(i+2, len(new_path)-1)\n                    if j <= i+1:\n                        attempts += 1\n                        continue\n                    if is_free_edge(new_path[i], new_path[j]):\n                        smooth = True\n                        if i > 0:\n                            a,b,c = new_path[i-1], new_path[i], new_path[j]\n                            if angle_between(a,b,c) < math.pi - angle_thresh:\n                                smooth = False\n                        if j < len(new_path)-1:\n                            a,b,c = new_path[i], new_path[j], new_path[j+1]\n                            if angle_between(a,b,c) < math.pi - angle_thresh:\n                                smooth = False\n                        if smooth:\n                            new_path = new_path[:i+1] + new_path[j:]\n                            improved = True\n                            i = 0\n                            attempts += 1\n                            continue\n                    i += 1\n                    attempts += 1\n                if not improved:\n                    break\n            return new_path\n\n        def cubic_spline_points(p0, p1, p2, p3, n_points=10):\n            # Generate points along cubic spline using a simple Bezier formula\n            u = lambda t: 1 - t\n            curve = []\n            for i in range(n_points):\n                t = i/(n_points-1)\n                u3 = u(t)**3\n                t3 = t**3\n                pt = tuple(\n                    u3*p0[d] + 3*u(t)**2 * t * p1[d] + 3*u(t)*t**2 * p2[d] + t3*p3[d]\n                    for d in range(dim)\n                )\n                curve.append(pt)\n            return curve\n\n        def is_curve_collision_free(points):\n            for i in range(len(points)-1):\n                if self._is_edge_in_obstacle(points[i], points[i+1], obstacles, is_3d):\n                    return False\n            return True\n\n        def spline_smooth_path(path):\n            # Locally replace 4-points segments by cubic splines if collision free\n            if len(path) < 4:\n                return path[:]\n            new_path = path[:]\n            i = 0\n            while i <= len(new_path)-4:\n                seg_pts = new_path[i:i+4]\n                curve_pts = cubic_spline_points(*seg_pts, n_points=10)\n                if is_curve_collision_free(curve_pts):\n                    # Replace middle points (1 and 2) by curve inner points except endpoints\n                    new_path = new_path[:i+1] + curve_pts[1:-1] + new_path[i+3:]\n                    i += len(curve_pts) - 2\n                else:\n                    i += 1\n            return new_path\n\n        for it in range(self.max_iter):\n            sample_pos = sample()\n            if it % 2 == 0:\n                prop_tree, other_tree = start_tree, goal_tree\n                prop_hash, other_hash = hash_start, hash_goal\n                heuristic_prop = heuristic_forward\n                heuristic_other = heuristic_backward\n            else:\n                prop_tree, other_tree = goal_tree, start_tree\n                prop_hash, other_hash = hash_goal, hash_start\n                heuristic_prop = heuristic_backward\n                heuristic_other = heuristic_forward\n\n            nearest_node = nearest(prop_hash, sample_pos)\n            new_pos = steer(nearest_node.position, sample_pos)\n            if not is_free_node(new_pos):\n                continue\n            if not is_free_edge(nearest_node.position, new_pos):\n                continue\n\n            r = rewiring_radius(len(prop_tree))\n            near_nodes = near(prop_hash, new_pos, r)\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for cand in near_nodes:\n                if cand is nearest_node:\n                    continue\n                tentative_cost = cand.cost + dist(cand.position, new_pos)\n                if tentative_cost + heuristic_prop(new_pos) + 1e-15 < min_cost + heuristic_prop(new_pos):\n                    if is_free_edge(cand.position, new_pos):\n                        min_cost = tentative_cost\n                        best_parent = cand\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.add_child(new_node)\n            prop_tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n            prop_hash.add(new_node)\n\n            for nbr in near_nodes:\n                if nbr is best_parent or nbr is new_node:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, nbr.position)\n                if new_cost + heuristic_prop(nbr.position) + 1e-15 < nbr.cost + heuristic_prop(nbr.position):\n                    if is_free_edge(new_node.position, nbr.position):\n                        if nbr.parent is not None:\n                            try:\n                                edges.remove((nbr.parent, nbr))\n                            except ValueError:\n                                pass\n                            nbr.parent.remove_child(nbr)\n                        nbr.parent = new_node\n                        nbr.cost = new_cost\n                        new_node.add_child(nbr)\n                        edges.append((new_node, nbr))\n                        update_subtree_costs(nbr)\n\n            near_other = nearest(other_hash, new_node.position)\n            dist_conn = dist(new_node.position, near_other.position)\n            if dist_conn <= self.step_size:\n                if is_free_edge(new_node.position, near_other.position):\n                    candidate_cost = new_node.cost + dist_conn + near_other.cost\n                    if candidate_cost + 1e-15 < best_cost:\n                        best_cost = candidate_cost\n                        solution_nodes = (new_node, near_other) if it % 2 == 0 else (near_other, new_node)\n\n            # After solution found, apply hierarchical smoothing periodically to improve path quality\n            if solution_nodes[0] and solution_nodes[1] and ((it > 0 and it % 75 == 0) or it == self.max_iter-1):\n                raw_path = path_from_to(solution_nodes[0], solution_nodes[1])\n                pass1 = shortcut_path(raw_path, max_passes=6, max_attempts=300)\n                pass2 = spline_smooth_path(pass1)\n                return PlannerResult(True, pass2, nodes, edges)\n\n        if solution_nodes[0] and solution_nodes[1]:\n            raw_path = path_from_to(solution_nodes[0], solution_nodes[1])\n            pass1 = shortcut_path(raw_path, max_passes=6, max_attempts=300)\n            pass2 = spline_smooth_path(pass1)\n            return PlannerResult(True, pass2, nodes, edges)\n        else:\n            return PlannerResult(False, [], nodes, edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        px = pos[0]\n        py = pos[1]\n        pz = pos[2] if is_3d else 0.0\n        for obs in obstacles:\n            if is_3d:\n                x,y,z,w,h,d = obs\n                if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                    return True\n            else:\n                x,y,w,h = obs\n                if x <= px <= x+w and y <= py <= y+h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        dist_val = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist_val/resolution))\n        for step in range(steps+1):\n            t = step/steps\n            interp = tuple(from_pos[i] + t*(to_pos[i]-from_pos[i]) for i in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -24.13005,
          "time_improvement": 29.0,
          "length_improvement": 16.0,
          "smoothness_improvement": 1122.0,
          "node_improvement": 62.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.02949981689453125,
                    "num_nodes_avg": 203.8,
                    "path_length_avg": 163.60189245888023,
                    "smoothness_avg": 0.029449457417570424,
                    "success_improvement": 0.0,
                    "time_improvement": -14.38111569732238,
                    "node_improvement": 48.67791488290103,
                    "length_improvement": 10.327210305404018,
                    "smoothness_improvement": 360.947959105323,
                    "objective_score": 3.686731269572311
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.036115503311157225,
                    "num_nodes_avg": 312.4,
                    "path_length_avg": 232.78743675484188,
                    "smoothness_avg": 0.07851141528876425,
                    "success_improvement": 0.0,
                    "time_improvement": 78.18791984964754,
                    "node_improvement": 79.00960827790097,
                    "length_improvement": 22.288853196381382,
                    "smoothness_improvement": 1920.1552648665893,
                    "objective_score": 46.43046419705604
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.03924586772918701,
                    "num_nodes_avg": 339.5,
                    "path_length_avg": 125.3576572566241,
                    "smoothness_avg": 0.09320353503277881,
                    "success_improvement": 0.0,
                    "time_improvement": 22.663943610755226,
                    "node_improvement": 56.83407501589319,
                    "length_improvement": 16.743412940321953,
                    "smoothness_improvement": 1085.542086047611,
                    "objective_score": 22.272941277657793
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "time_expert",
          "algorithm_description": "A dual-tree bidirectional planner utilizing adaptive sampling between uniform and informed ellipsoidal distributions with an enhanced smoothing post-processing phase. The planner implements curvature-aware adaptive shortcutting combined with a spline-based global smooth, enabling smooth, low-cost paths with efficient rewiring tuned by node density and path quality. Trees alternate extensions toward strategic samples; rewiring is dynamically bounded by a cost- and density-dependent radius. Connection attempts adapt to local conditions to accelerate convergence. Both incremental and global smoothings employ curvature and length considerations to reduce jaggedness organically, while collision checks prune invalid expansions early, resulting in faster planning times, shorter paths, and improved path smoothness.",
          "planning_mechanism": "The algorithm grows two trees from start and goal, sampling adaptively from uniform or ellipsoidal distributions guided by current best cost. Each iteration selects which tree to extend towards the sample, adding a new node steered stepwise with collision checks. Neighborhood rewiring optimizes path cost with a radius scaled via node count and best known path. When opposite trees connect, the path is extracted and immediately improved by curvature-sensitive incremental shortcuts. Periodically, a global smoothing pass using a cubic spline reduces curvature overall without overshooting or abrupt changes. The process stops early when a sufficiently good path is found, balancing speed and quality.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except ValueError:\n            pass\nclass Planner:\n    def __init__(self, max_iter=4000, step_size=7.0, goal_sample_rate=0.07,\n                 shortcut_attempts=40, global_smooth_freq=300, uniform_sample_rate=0.25,\n                 r_min=4.0, r_max=30.0, curvature_thresh=0.15):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.shortcut_attempts = shortcut_attempts\n        self.global_smooth_freq = global_smooth_freq\n        self.uniform_sample_rate = uniform_sample_rate\n        self.r_min = r_min\n        self.r_max = r_max\n        self.curvature_thresh = curvature_thresh\n\n    def plan(self, map):\n        import math\n        import random\n\n        bounds = map.size\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        obstacles = map.obstacles\n        start_pos = map.start\n        goal_pos = map.goal\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        best_cost = float('inf')\n        solution_nodes = (None, None)\n        improved_since_last_global_smooth = False\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def is_in_obstacle(pos):\n            px = pos[0]\n            py = pos[1]\n            pz = pos[2] if is_3d else 0.0\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(a, b, resolution=0.4):\n            dist_ab = dist(a, b)\n            steps = max(2, int(dist_ab / resolution))\n            for i in range(steps + 1):\n                t = i / steps\n                interm = tuple(a[j] + t * (b[j] - a[j]) for j in range(dim))\n                if is_in_obstacle(interm):\n                    return True\n            return False\n\n        def nearest(tree, point):\n            best = None\n            best_d = float('inf')\n            for n in tree:\n                d_n = dist(n.position, point)\n                if d_n < best_d:\n                    best = n\n                    best_d = d_n\n            return best\n\n        def near(tree, point, radius):\n            r_sq = radius * radius\n            res = []\n            for n in tree:\n                diff_sq = 0.0\n                for i in range(dim):\n                    d_i = n.position[i] - point[i]\n                    diff_sq += d_i * d_i\n                if diff_sq <= r_sq:\n                    res.append(n)\n            return res\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            ratio = self.step_size / d\n            return tuple(from_pos[i] + ratio * (to_pos[i] - from_pos[i]) for i in range(dim))\n\n        def compute_ellipsoid_params():\n            c_min = dist(start_pos, goal_pos)\n            if c_min < 1e-14:\n                return None\n            center = tuple(0.5 * (start_pos[i] + goal_pos[i]) for i in range(dim))\n            direction = [goal_pos[i] - start_pos[i] for i in range(dim)]\n            length = c_min\n            e1 = [d / length for d in direction]\n            if dim == 2:\n                e2 = (-e1[1], e1[0])\n                basis = [e1, e2]\n            else:\n                v = [1, 0, 0] if abs(e1[0]) < 0.9 else [0, 1, 0]\n                for i in range(dim):\n                    proj = sum(v[j] * e1[j] for j in range(dim))\n                    v[i] = v[i] - proj * e1[i]\n                norm_v = math.sqrt(sum(x * x for x in v))\n                if norm_v < 1e-15:\n                    v = [0.0] * dim\n                    v[-1] = 1.0\n                    norm_v = 1.0\n                u = [x / norm_v for x in v]\n                if dim == 3:\n                    w = [e1[1] * u[2] - e1[2] * u[1],\n                         e1[2] * u[0] - e1[0] * u[2],\n                         e1[0] * u[1] - e1[1] * u[0]]\n                    basis = [e1, u, w]\n                else:\n                    basis = [e1, u]\n\n            a1 = best_cost * 0.5\n            b_sq = max(best_cost * best_cost - c_min * c_min, 1e-14) * 0.25\n            b = math.sqrt(b_sq)\n            return center, basis, a1, b\n\n        def sample_point():\n            if best_cost == float('inf'):\n                while True:\n                    if random.random() < self.goal_sample_rate:\n                        pt = goal_pos\n                    else:\n                        pt = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                    if not is_in_obstacle(pt):\n                        return pt\n            if random.random() < self.uniform_sample_rate:\n                if random.random() < self.goal_sample_rate:\n                    pt = goal_pos\n                else:\n                    while True:\n                        pt = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                        if not is_in_obstacle(pt):\n                            break\n                return pt\n            params = compute_ellipsoid_params()\n            if params is None:\n                while True:\n                    pt = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                    if not is_in_obstacle(pt):\n                        return pt\n            center, basis, a1, b = params\n            while True:\n                if dim == 2:\n                    r = random.uniform(0, 1) ** 0.5\n                    theta = random.uniform(0, 2 * math.pi)\n                    ball = [r * math.cos(theta), r * math.sin(theta)]\n                    coords = [a1 * ball[0], b * ball[1]]\n                    pt = tuple(center[i] + sum(coords[j] * basis[j][i] for j in range(dim)) for i in range(dim))\n                else:\n                    while True:\n                        u_ball = [random.uniform(-1, 1) for _ in range(3)]\n                        norm_sq = sum(x * x for x in u_ball)\n                        if 0 < norm_sq <= 1:\n                            break\n                    norm = math.sqrt(norm_sq)\n                    unit_ball = [x / norm for x in u_ball]\n                    coords = [a1 * unit_ball[0], b * unit_ball[1], b * unit_ball[2]]\n                    pt = tuple(center[i] + sum(coords[j] * basis[j][i] for j in range(dim)) for i in range(dim))\n                if any(pt[d] < 0 or pt[d] > bounds[d] for d in range(dim)):\n                    continue\n                if is_in_obstacle(pt):\n                    continue\n                return pt\n\n        def rewiring_radius(num_nodes):\n            if num_nodes < 2:\n                return self.r_max\n            base = 2 * ((math.log(num_nodes) / num_nodes) ** (1 / dim)) * self.step_size\n            ratio = 1.0\n            if best_cost < float('inf') and best_cost > 0:\n                dist_base = dist(start_pos, goal_pos)\n                ratio = max(0.25, min(1.0, best_cost / (dist_base * 2.5)))\n            radius = base * ratio\n            return max(self.r_min, min(self.r_max, radius))\n\n        def extract_path(n_start, n_goal):\n            path_start = []\n            cur = n_start\n            while cur is not None:\n                path_start.append(cur.position)\n                cur = cur.parent\n            path_goal = []\n            cur = n_goal\n            while cur is not None:\n                path_goal.append(cur.position)\n                cur = cur.parent\n            return path_start[::-1] + path_goal\n\n        def angle_between(a, b, c):\n            # angle at b formed by points a-b-c in radians, dim>=2\n            v1 = [a[i] - b[i] for i in range(dim)]\n            v2 = [c[i] - b[i] for i in range(dim)]\n            dot = sum(v1[i] * v2[i] for i in range(dim))\n            norm1 = math.sqrt(sum(x * x for x in v1))\n            norm2 = math.sqrt(sum(x * x for x in v2))\n            if norm1 < 1e-14 or norm2 < 1e-14:\n                return 0.0\n            val = max(-1.0, min(1.0, dot / (norm1 * norm2)))\n            return math.acos(val)\n\n        def curvature_sensitive_shortcut(path):\n            if len(path) < 3:\n                return path[:]\n            new_path = path[:]\n            attempts = 0\n            max_attempts = self.shortcut_attempts\n            while attempts < max_attempts and len(new_path) >= 3:\n                i = random.randint(0, len(new_path) - 3)\n                j = random.randint(i + 2, len(new_path) - 1)\n                if is_edge_in_obstacle(new_path[i], new_path[j]):\n                    attempts += 1\n                    continue\n                # Estimate local curvature before and after shortcut\n                def local_curvature(idx):\n                    if idx <= 0 or idx >= len(new_path) - 1:\n                        return 0.0\n                    return angle_between(new_path[idx - 1], new_path[idx], new_path[idx + 1])\n\n                # Current max curvature in segment [i+1..j-1]\n                curr_max_curve = 0.0\n                for k in range(i + 1, j):\n                    c = local_curvature(k)\n                    if c > curr_max_curve:\n                        curr_max_curve = c\n\n                # Curvature after shortcut at i\n                # New connection from i to j replaces intermediate nodes, estimate curvature at i and j edges\n                after_curve_i = 0.0\n                if 0 < i < len(new_path) -1 and j < len(new_path):\n                    after_curve_i = local_curvature(i)\n\n                after_curve_j = 0.0\n                if 0 < j < len(new_path) - 1 and i >= 0:\n                    after_curve_j = local_curvature(j)\n\n                max_after_curve = max(after_curve_i, after_curve_j)\n                if max_after_curve <= max(curr_max_curve, self.curvature_thresh):\n                    # Accept shortcut\n                    new_path = new_path[:i + 1] + new_path[j:]\n                    attempts = 0\n                else:\n                    attempts += 1\n            return new_path\n\n        def catmull_rom_spline(points, n_points=100):\n            # 1D Catmull-Rom spline for each dimension to smooth the path globally\n            # Handles 2D and 3D points, linear interpolation on edges for clamping endpoints\n            if len(points) < 4:\n                return points[:]\n            def sample_segment(p0, p1, p2, p3, n):\n                res = []\n                for t_i in range(n):\n                    t = t_i / (n - 1)\n                    t2 = t * t\n                    t3 = t2 * t\n                    def c(t, p0, p1, p2, p3):\n                        return 0.5 * ((2 * p1) + (-p0 + p2) * t + (2*p0 - 5*p1 + 4*p2 - p3) * t2 + (-p0 + 3*p1 - 3*p2 + p3) * t3)\n                    pt = tuple(\n                        c(t, p0[d], p1[d], p2[d], p3[d])\n                        for d in range(dim)\n                    )\n                    res.append(pt)\n                return res\n\n            smoothed = []\n            for i in range(len(points) - 3):\n                seg = sample_segment(points[i], points[i + 1], points[i + 2], points[i + 3], n_points // (len(points) - 3))\n                smoothed.extend(seg if i == 0 else seg[1:])\n            return smoothed\n\n        def global_smooth(path):\n            if len(path) < 4:\n                # fallback to shortcutting only if spline not possible\n                return curvature_sensitive_shortcut(path)\n            # Apply curvature-sensitive shortcutting first\n            path = curvature_sensitive_shortcut(path)\n            # Then apply spline smoothing\n            spline_path = catmull_rom_spline(path, n_points=120)\n            # Verify collision free spline segments between sampled spline points (check every 3rd point for speed)\n            verified_path = [spline_path[0]]\n            idx = 0\n            while idx < len(spline_path) - 1:\n                next_idx = min(len(spline_path) - 1, idx + 3)\n                if is_edge_in_obstacle(spline_path[idx], spline_path[next_idx]):\n                    # If collision, fallback to previous point and skip smoothing partial\n                    # Insert intermediate points linearly for fallback\n                    verified_path.append(spline_path[next_idx])\n                    idx = next_idx\n                else:\n                    verified_path.append(spline_path[next_idx])\n                    idx = next_idx\n            return verified_path\n\n        for iteration in range(self.max_iter):\n            sample_pos = sample_point()\n            tree_to_extend, opposite_tree = (start_tree, goal_tree) if iteration % 2 == 0 else (goal_tree, start_tree)\n\n            nearest_node = nearest(tree_to_extend, sample_pos)\n            new_pos = steer(nearest_node.position, sample_pos)\n\n            if is_in_obstacle(new_pos) or is_edge_in_obstacle(nearest_node.position, new_pos):\n                continue\n\n            radius = rewiring_radius(len(tree_to_extend))\n            neighbors = near(tree_to_extend, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n\n            for candidate in neighbors:\n                if candidate is nearest_node:\n                    continue\n                tentative_cost = candidate.cost + dist(candidate.position, new_pos)\n                if tentative_cost < min_cost and not is_edge_in_obstacle(candidate.position, new_pos):\n                    min_cost = tentative_cost\n                    best_parent = candidate\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree_to_extend.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors for potential cost improvement\n            for nbr in neighbors:\n                if nbr is best_parent or nbr is new_node:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, nbr.position)\n                if new_cost < nbr.cost and not is_edge_in_obstacle(new_node.position, nbr.position):\n                    if nbr.parent is not None:\n                        try:\n                            edges.remove((nbr.parent, nbr))\n                        except ValueError:\n                            pass\n                        nbr.parent.remove_child(nbr)\n                    nbr.parent = new_node\n                    nbr.cost = new_cost\n                    new_node.add_child(nbr)\n                    edges.append((new_node, nbr))\n\n            # Try connect two trees if close enough\n            nearest_other = nearest(opposite_tree, new_pos)\n            dist_connect = dist(new_pos, nearest_other.position)\n            connect_thresh = min(self.step_size * 1.7, rewiring_radius(len(tree_to_extend)))\n\n            if dist_connect <= connect_thresh and not is_edge_in_obstacle(new_pos, nearest_other.position):\n                path_cost = new_node.cost + dist_connect + nearest_other.cost\n                if path_cost < best_cost:\n                    best_cost = path_cost\n                    solution_nodes = (new_node, nearest_other) if iteration % 2 == 0 else (nearest_other, new_node)\n                    raw_path = extract_path(solution_nodes[0], solution_nodes[1])\n                    # Immediately improve with curvature-aware shortcut\n                    smoothed_path = curvature_sensitive_shortcut(raw_path)\n                    improved_since_last_global_smooth = True\n\n                    # Early return if good quality solution found\n                    if smoothed_path and len(smoothed_path) >= 2:\n                        if iteration % self.global_smooth_freq == 0:\n                            smoothed_path = global_smooth(smoothed_path)\n                        return PlannerResult(True, smoothed_path, nodes, edges)\n\n            # Periodic global smoothing on best path if available\n            if improved_since_last_global_smooth and iteration % self.global_smooth_freq == 0 and best_cost < float('inf'):\n                raw_path = extract_path(solution_nodes[0], solution_nodes[1])\n                smoothed_path = global_smooth(raw_path)\n                if smoothed_path and len(smoothed_path) >= 2:\n                    improved_since_last_global_smooth = False\n                    return PlannerResult(True, smoothed_path, nodes, edges)\n\n        # Terminate returning best found solution if exists\n        if solution_nodes[0] is not None and solution_nodes[1] is not None:\n            raw_path = extract_path(solution_nodes[0], solution_nodes[1])\n            smoothed_path = global_smooth(raw_path)\n            return PlannerResult(True, smoothed_path, nodes, edges)\n\n        return PlannerResult(False, [], nodes, edges)",
          "objective": -24.04579,
          "time_improvement": 41.0,
          "length_improvement": 8.0,
          "smoothness_improvement": 1408.0,
          "node_improvement": 69.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.02419092655181885,
                    "num_nodes_avg": 141.9,
                    "path_length_avg": 188.3479380599631,
                    "smoothness_avg": 0.033290610348386845,
                    "success_improvement": 0.0,
                    "time_improvement": 6.203310392005505,
                    "node_improvement": 64.26592797783933,
                    "length_improvement": -3.2364894147353587,
                    "smoothness_improvement": 421.0703436696947,
                    "objective_score": 2.0244511871089097
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.0251894474029541,
                    "num_nodes_avg": 237.1,
                    "path_length_avg": 250.2720422831174,
                    "smoothness_avg": 0.1005791278020062,
                    "success_improvement": 0.0,
                    "time_improvement": 84.78674820166262,
                    "node_improvement": 84.06907209567964,
                    "length_improvement": 16.45198860457725,
                    "smoothness_improvement": 2487.9734025631583,
                    "objective_score": 47.74708463606093
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.034386706352233884,
                    "num_nodes_avg": 316.6,
                    "path_length_avg": 135.2191336681014,
                    "smoothness_avg": 0.1112860441211003,
                    "success_improvement": 0.0,
                    "time_improvement": 32.239177896453405,
                    "node_improvement": 59.74570883661793,
                    "length_improvement": 10.193889860863345,
                    "smoothness_improvement": 1315.5502669390778,
                    "objective_score": 22.365838620149418
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "time_expert",
          "algorithm_description": "A bidirectional RRT* planner with prioritized informed sampling, dynamically adaptive rewiring based on node density and current best cost, and a two-stage smoothing strategy combining frequent incremental shortcutting with scheduled global curvature-aware smoothing. The planning alternates tree extensions from start and goal, focused sampling inside an adaptive informed ellipsoid accelerates convergence. Rewiring balances exploration and exploitation with a radius adapting to tree growth and path quality. Upon path improvement, efficient incremental shortcutting is applied, while a global smoothing using curvature reduction techniques is periodically triggered to robustly smooth jagged paths, resulting in faster planning, shorter, and smoother paths.",
          "planning_mechanism": "The planner grows two trees alternately from start and goal using a blend of uniform and ellipsoidal informed sampling that targets promising regions. Each extension steers toward samples with step size limitation. Rewiring is done within an adaptively computed radius that shrinks as path quality improves and nodes increase, to reduce excessive edge rewiring and zigzagging. Upon connection of trees with a better path, incremental shortcutting removes redundant nodes locally. Periodically, a global smoothing pass reduces high-curvature points by iterative curvature-aware shortcutting, improving smoothness beyond local fixes. Efficient collision checks enforce obstacle-free nodes and edges. Early exits accelerate planning once a high-quality path is found.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except ValueError:\n            pass\nclass Planner:\n    def __init__(self, max_iter=4000, step_size=5.5, goal_sample_rate=0.07,\n                 uniform_sample_rate=0.4, r_min=4.5, r_max=28.0,\n                 incremental_shortcut_attempts=25, global_smooth_interval=200):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.uniform_sample_rate = uniform_sample_rate\n        self.r_min = r_min\n        self.r_max = r_max\n        self.incremental_shortcut_attempts = incremental_shortcut_attempts\n        self.global_smooth_interval = global_smooth_interval\n\n    def plan(self, map):\n        import math\n        import random\n\n        bounds = map.size\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        obstacles = map.obstacles\n        start_pos = map.start\n        goal_pos = map.goal\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        best_cost = float('inf')\n        best_solution_nodes = (None, None)\n        found_improvement_iter = -1\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def is_in_obstacle(pos):\n            px = pos[0]\n            py = pos[1]\n            pz = pos[2] if is_3d else 0.0\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(a, b, resolution=0.4):\n            dist_ab = dist(a, b)\n            steps = max(1, int(dist_ab / resolution))\n            for i in range(steps + 1):\n                t = i / steps\n                interm = tuple(a[j] + t * (b[j] - a[j]) for j in range(dim))\n                if is_in_obstacle(interm):\n                    return True\n            return False\n\n        def nearest(tree, point):\n            best = None\n            best_d = float('inf')\n            for n in tree:\n                d_n = dist(n.position, point)\n                if d_n < best_d:\n                    best = n\n                    best_d = d_n\n            return best\n\n        def near(tree, point, radius):\n            r_sq = radius * radius\n            res = []\n            for n in tree:\n                d_sq = 0.0\n                for i in range(dim):\n                    diff = n.position[i] - point[i]\n                    d_sq += diff * diff\n                if d_sq <= r_sq:\n                    res.append(n)\n            return res\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            ratio = self.step_size / d\n            return tuple(from_pos[i] + ratio * (to_pos[i] - from_pos[i]) for i in range(dim))\n\n        def compute_ellipsoid_params():\n            c_min = dist(start_pos, goal_pos)\n            if c_min < 1e-14:\n                return None\n            center = tuple((start_pos[i] + goal_pos[i]) * 0.5 for i in range(dim))\n            direction = [goal_pos[i] - start_pos[i] for i in range(dim)]\n            length = c_min\n            e1 = [d / length for d in direction]\n            if dim == 2:\n                e2 = (-e1[1], e1[0])\n                basis = [e1, e2]\n            else:\n                v = [1, 0, 0] if abs(e1[0]) < 0.9 else [0, 1, 0]\n                for i in range(dim):\n                    proj = sum(v[j] * e1[j] for j in range(dim))\n                    v[i] = v[i] - proj * e1[i]\n                norm_v = math.sqrt(sum(x * x for x in v))\n                if norm_v < 1e-15:\n                    v = [0.0] * dim\n                    v[-1] = 1.0\n                    norm_v = 1.0\n                u = [x / norm_v for x in v]\n                if dim == 3:\n                    w = [e1[1] * u[2] - e1[2] * u[1],\n                         e1[2] * u[0] - e1[0] * u[2],\n                         e1[0] * u[1] - e1[1] * u[0]]\n                    basis = [e1, u, w]\n                else:\n                    basis = [e1, u]\n\n            a1 = best_cost * 0.5 if best_cost < float('inf') else c_min * 1.5\n            b_sq = max(best_cost * best_cost - c_min * c_min, 1e-16) * 0.25 if best_cost < float('inf') else (c_min * c_min * 2)\n            b = math.sqrt(b_sq)\n            return center, basis, a1, b\n\n        def sample():\n            # If no current path, sample uniform with goal bias\n            if best_cost == float('inf'):\n                while True:\n                    if random.random() < self.goal_sample_rate:\n                        pt = goal_pos\n                    else:\n                        pt = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                    if not is_in_obstacle(pt):\n                        return pt\n            # Mix uniform and ellipsoidal informed sampling\n            if random.random() < self.uniform_sample_rate:\n                if random.random() < self.goal_sample_rate:\n                    pt = goal_pos\n                else:\n                    tries = 0\n                    while True:\n                        pt = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                        if not is_in_obstacle(pt):\n                            break\n                        tries += 1\n                        if tries > 30:\n                            break  # Fallback outside loop\n                return pt\n            # ellipsoidal informed sample\n            params = compute_ellipsoid_params()\n            if params is None:\n                while True:\n                    pt = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                    if not is_in_obstacle(pt):\n                        return pt\n            center, basis, a1, b = params\n            for _ in range(100):  # Limit retries for efficiency\n                if dim == 2:\n                    r = random.uniform(0, 1) ** 0.5\n                    theta = random.uniform(0, 2 * math.pi)\n                    u_ball = [r * math.cos(theta), r * math.sin(theta)]\n                    coords = [a1 * u_ball[0], b * u_ball[1]]\n                    pt = tuple(center[i] + sum(coords[j] * basis[j][i] for j in range(dim)) for i in range(dim))\n                else:\n                    while True:\n                        u_ball = [random.uniform(-1, 1) for _ in range(3)]\n                        norm_sq = sum(x * x for x in u_ball)\n                        if 0 < norm_sq <= 1:\n                            break\n                    norm_u = math.sqrt(norm_sq)\n                    unit_ball = [x / norm_u for x in u_ball]\n                    coords = [a1 * unit_ball[0], b * unit_ball[1], b * unit_ball[2]]\n                    pt = tuple(center[i] + sum(coords[j] * basis[j][i] for j in range(dim)) for i in range(dim))\n                if any(pt[d] < 0 or pt[d] > bounds[d] for d in range(dim)):\n                    continue\n                if is_in_obstacle(pt):\n                    continue\n                return pt\n            # Fallback uniform if ellipsoidal sampling fails\n            while True:\n                pt = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not is_in_obstacle(pt):\n                    return pt\n\n        def rewiring_radius(n_nodes):\n            if n_nodes < 3:\n                return self.r_max\n            base = 2 * ((math.log(n_nodes) / n_nodes) ** (1 / dim)) * self.step_size\n            # Shrink rewiring radius smoothly if best_cost is improving\n            if best_cost < float('inf') and best_cost > 0:\n                ratio = min(1.0, max(0.28, best_cost / (dist(start_pos, goal_pos) * 3.5)))\n            else:\n                ratio = 1.0\n            radius = base * ratio\n            return max(self.r_min, min(self.r_max, radius))\n\n        def extract_path(node_a, node_b):\n            path_a = []\n            cur = node_a\n            while cur is not None:\n                path_a.append(cur.position)\n                cur = cur.parent\n            path_b = []\n            cur = node_b\n            while cur is not None:\n                path_b.append(cur.position)\n                cur = cur.parent\n            return path_a[::-1] + path_b\n\n        def incremental_shortcut(path):\n            length = len(path)\n            if length < 3:\n                return path[:]\n            new_path = path[:]\n            attempts = 0\n            while attempts < self.incremental_shortcut_attempts:\n                if len(new_path) < 3:\n                    break\n                i = random.randint(0, len(new_path) - 3)\n                j = random.randint(i + 2, len(new_path) - 1)\n                if not is_edge_in_obstacle(new_path[i], new_path[j]):\n                    new_path = new_path[:i + 1] + new_path[j:]\n                    # only increment attempts if no shortcut success to avoid over-local shortcut\n                    attempts = 0\n                else:\n                    attempts += 1\n            return new_path\n\n        def curvature(p0, p1, p2):\n            # Compute 2D or 3D curvature approximation at p1\n            import math\n            def vec_sub(a, b):\n                return tuple(a[i]-b[i] for i in range(len(a)))\n            def vec_len(v):\n                return math.sqrt(sum(x*x for x in v))\n            def vec_cross2d(a,b):\n                return a[0]*b[1]-a[1]*b[0]\n            def vec_cross3d(a,b):\n                return (a[1]*b[2]-a[2]*b[1], a[2]*b[0]-a[0]*b[2], a[0]*b[1]-a[1]*b[0])\n            def vec_dot(a,b):\n                return sum(a[i]*b[i] for i in range(len(a)))\n            v1 = vec_sub(p0,p1)\n            v2 = vec_sub(p2,p1)\n            len1 = vec_len(v1)\n            len2 = vec_len(v2)\n            if len1 < 1e-8 or len2 < 1e-8:\n                return 0.0\n            if dim == 2:\n                cross = vec_cross2d(v1,v2)\n                dot = vec_dot(v1,v2)\n                denom = len1*len2*(len1+len2)\n                return abs(cross)/denom if denom > 1e-15 else 0.0\n            else:\n                cross = vec_cross3d(v1,v2)\n                cross_len = vec_len(cross)\n                dot = vec_dot(v1,v2)\n                denom = len1*len2*(len1+len2)\n                return cross_len/denom if denom > 1e-15 else 0.0\n\n        def global_curvature_aware_smooth(path, max_iters=25, curvature_thresh=0.08):\n            # Iteratively remove high-curvature midpoints by shortcutting while collision free\n            if len(path) < 4:\n                return path[:]\n            smoothed = path[:]\n            for _ in range(max_iters):\n                changed = False\n                i = 1\n                while i < len(smoothed) - 1:\n                    c = curvature(smoothed[i-1], smoothed[i], smoothed[i+1])\n                    if c > curvature_thresh:\n                        # Try shortcut from i-1 to i+1 skipping i\n                        if not is_edge_in_obstacle(smoothed[i-1], smoothed[i+1]):\n                            smoothed = smoothed[:i] + smoothed[i+1:]\n                            changed = True\n                            # After removal, stay at previous index to check new curvature\n                            i = max(1, i-1)\n                        else:\n                            i += 1\n                    else:\n                        i += 1\n                if not changed:\n                    break\n            return smoothed\n\n        for it in range(self.max_iter):\n            sample_pos = sample()\n            if it % 2 == 0:\n                tree_extend, tree_other = start_tree, goal_tree\n            else:\n                tree_extend, tree_other = goal_tree, start_tree\n\n            nearest_node = nearest(tree_extend, sample_pos)\n            new_pos = steer(nearest_node.position, sample_pos)\n\n            # Node collision check\n            if is_in_obstacle(new_pos):\n                continue\n            # Edge collision check\n            if is_edge_in_obstacle(nearest_node.position, new_pos):\n                continue\n\n            radius = rewiring_radius(len(tree_extend))\n            near_nodes = near(tree_extend, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for candidate in near_nodes:\n                if candidate is nearest_node:\n                    continue\n                tentative_cost = candidate.cost + dist(candidate.position, new_pos)\n                if tentative_cost < min_cost and not is_edge_in_obstacle(candidate.position, new_pos):\n                    min_cost = tentative_cost\n                    best_parent = candidate\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree_extend.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors if beneficial & collision-free\n            for nbr in near_nodes:\n                if nbr is best_parent or nbr is new_node:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, nbr.position)\n                if new_cost + 1e-8 < nbr.cost and not is_edge_in_obstacle(new_node.position, nbr.position):\n                    if nbr.parent:\n                        try:\n                            edges.remove((nbr.parent, nbr))\n                        except ValueError:\n                            pass\n                        nbr.parent.remove_child(nbr)\n                    nbr.parent = new_node\n                    nbr.cost = new_cost\n                    new_node.add_child(nbr)\n                    edges.append((new_node, nbr))\n\n            nearest_other = nearest(tree_other, new_pos)\n            dist_connect = dist(new_pos, nearest_other.position)\n            connect_thresh = min(self.step_size*1.6, rewiring_radius(len(tree_extend)))\n            if dist_connect <= connect_thresh and not is_edge_in_obstacle(new_pos, nearest_other.position):\n                total_cost = new_node.cost + dist_connect + nearest_other.cost\n                if total_cost + 1e-8 < best_cost:\n                    best_cost = total_cost\n                    if it % 2 == 0:\n                        best_solution_nodes = (new_node, nearest_other)\n                    else:\n                        best_solution_nodes = (nearest_other, new_node)\n                    raw_path = extract_path(best_solution_nodes[0], best_solution_nodes[1])\n                    path_inc_short = incremental_shortcut(raw_path)\n                    found_improvement_iter = it\n\n                    # If path improved and enough iterations occurred since last global smooth, do global smoothing\n                    if it - found_improvement_iter >= self.global_smooth_interval:\n                        path_smooth = global_curvature_aware_smooth(path_inc_short)\n                        if len(path_smooth) >= 2:\n                            return PlannerResult(True, path_smooth, nodes, edges)\n\n                    if len(path_inc_short) >= 2:\n                        return PlannerResult(True, path_inc_short, nodes, edges)\n\n            # On scheduled iterations, apply global smoothing on best path found\n            if best_solution_nodes[0] is not None and (it - found_improvement_iter) >= self.global_smooth_interval and best_cost < float('inf'):\n                raw_path = extract_path(best_solution_nodes[0], best_solution_nodes[1])\n                if len(raw_path) >= 4:\n                    smooth_path = global_curvature_aware_smooth(raw_path)\n                    if len(smooth_path) >= 2:\n                        found_improvement_iter = it\n                        return PlannerResult(True, smooth_path, nodes, edges)\n\n        # On termination, if solution found return best smoothed path\n        if best_solution_nodes[0] and best_solution_nodes[1]:\n            raw_path = extract_path(best_solution_nodes[0], best_solution_nodes[1])\n            inc_short_path = incremental_shortcut(raw_path)\n            final_path = global_curvature_aware_smooth(inc_short_path)\n            return PlannerResult(True, final_path, nodes, edges)\n\n        return PlannerResult(False, [], nodes, edges)",
          "objective": -23.87026,
          "time_improvement": 27.0,
          "length_improvement": 14.0,
          "smoothness_improvement": 1496.0,
          "node_improvement": 61.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.02388591766357422,
                    "num_nodes_avg": 171.8,
                    "path_length_avg": 174.82382351469033,
                    "smoothness_avg": 0.04021028520837535,
                    "success_improvement": 0.0,
                    "time_improvement": 7.385936611678351,
                    "node_improvement": 56.73633845378998,
                    "length_improvement": 4.176292070837513,
                    "smoothness_improvement": 529.3782815429777,
                    "objective_score": 7.368447633720901
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.02851369380950928,
                    "num_nodes_avg": 287.7,
                    "path_length_avg": 237.6084043860163,
                    "smoothness_avg": 0.10028630885230574,
                    "success_improvement": 0.0,
                    "time_improvement": 82.77905836180089,
                    "node_improvement": 80.66921991533964,
                    "length_improvement": 20.679475437236068,
                    "smoothness_improvement": 2480.4389600784007,
                    "objective_score": 49.64359757127391
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.054718732833862305,
                    "num_nodes_avg": 417.2,
                    "path_length_avg": 126.6024490030876,
                    "smoothness_avg": 0.12416050688823313,
                    "success_improvement": 0.0,
                    "time_improvement": -7.826154773499157,
                    "node_improvement": 46.95486331849968,
                    "length_improvement": 15.916681532934144,
                    "smoothness_improvement": 1479.3124830430165,
                    "objective_score": 14.598724902925822
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m1",
          "algorithm_description": "An optimized bidirectional RRT* planner employing a balanced KDTree with batched nearest neighbor queries and adaptive rewiring. The algorithm moderates rewiring and shortcutting frequency through dynamic scheduling informed by recent improvement trends, reducing computational overhead. Sampling is a hybrid informed strategy with goal bias and fallback uniform sampling constrained within map bounds. Early stopping is adaptively triggered based on solution improvement stability to curtail excess computation. Incremental shortcutting is applied selectively while global smoothing is invoked conditionally to balance planning speed with path quality enhancement. Overall, the planner balances exploration-exploitation efficiently, improving runtime while maintaining path length and smoothness.",
          "planning_mechanism": "The planner grows two trees bidirectionally, sampling points by biased and ellipsoidal informed sampling. It inserts new nodes via efficient KDTree nearest and radius searches with adaptive rewiring radius, minimizing cost connections. Rewiring and shortcutting run at adaptive intervals aligned with improvement progress. Path extraction merges start and goal trees via closest nodes upon connection. Early stopping detects plateauing improvements to end planning promptly. The output path is incrementally shortcut and optionally globally smoothed before return.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n    def add_child(self, child):\n        self.children.append(child)\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\nclass Planner:\n    def __init__(self, max_iter=2500, step_size=6.0, r_min=5.0, r_max=18.0,\n                 goal_sample_rate=0.15, shortcut_attempts=50, smooth_passes=3,\n                 improvement_thresh=5e-4, early_stop_patience=120,\n                 rewiring_interval=8, shortcut_interval=20, smooth_interval=100):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.r_min = r_min\n        self.r_max = r_max\n        self.goal_sample_rate = goal_sample_rate\n        self.shortcut_attempts = shortcut_attempts\n        self.smooth_passes = smooth_passes\n        self.improvement_thresh = improvement_thresh\n        self.early_stop_patience = early_stop_patience\n        self.rewiring_interval = rewiring_interval\n        self.shortcut_interval = shortcut_interval\n        self.smooth_interval = smooth_interval\n\n    def plan(self, map):\n        import math\n        import random\n\n        bounds = map.size\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        obstacles = map.obstacles\n        start_pos = map.start\n        goal_pos = map.goal\n\n        node_coll_cache = {}\n        edge_coll_cache = {}\n\n        def key_node_collision(p):\n            return tuple(round(x * 1000) for x in p)\n\n        def key_edge_collision(a, b):\n            ka = key_node_collision(a)\n            kb = key_node_collision(b)\n            return tuple(sorted((ka, kb)))\n\n        def collision_node(p):\n            key = key_node_collision(p)\n            if key in node_coll_cache:\n                return node_coll_cache[key]\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = p\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        node_coll_cache[key] = True\n                        return True\n                else:\n                    x, y, w_, h_ = obs\n                    px, py = p\n                    if x <= px <= x + w_ and y <= py <= y + h_:\n                        node_coll_cache[key] = True\n                        return True\n            node_coll_cache[key] = False\n            return False\n\n        def collision_edge(a, b):\n            key = key_edge_collision(a, b)\n            if key in edge_coll_cache:\n                return edge_coll_cache[key]\n            dist_ab = math.dist(a, b)\n            steps = max(3, int(dist_ab / 0.4))\n            for step in range(steps + 1):\n                interp = tuple(a[i] + (b[i] - a[i]) * step / steps for i in range(dim))\n                if collision_node(interp):\n                    edge_coll_cache[key] = True\n                    return True\n            edge_coll_cache[key] = False\n            return False\n\n        def in_bounds(p):\n            for i in range(dim):\n                if p[i] < 0 or p[i] > bounds[i]:\n                    return False\n            return True\n\n        def steer(from_p, to_p):\n            dist = math.dist(from_p, to_p)\n            if dist <= self.step_size:\n                clipped = tuple(max(0, min(bounds[i], to_p[i])) for i in range(dim))\n                return clipped\n            ratio = self.step_size / dist\n            new_p = tuple(from_p[i] + ratio * (to_p[i] - from_p[i]) for i in range(dim))\n            clipped = tuple(max(0, min(bounds[i], new_p[i])) for i in range(dim))\n            return clipped\n\n        class KDTree:\n            def __init__(self, points=None, depth=0):\n                self.axis = depth % dim\n                self.node = None\n                self.left = None\n                self.right = None\n                self.size = 0\n                if points:\n                    points = sorted(points, key=lambda n: n.position[self.axis])\n                    median = len(points) // 2\n                    self.node = points[median]\n                    left_points = points[:median]\n                    right_points = points[median + 1:]\n                    if left_points:\n                        self.left = KDTree(left_points, depth + 1)\n                    if right_points:\n                        self.right = KDTree(right_points, depth + 1)\n                    self.size = len(points)\n\n            def insert(self, node, depth=0):\n                axis = depth % dim\n                if self.node is None:\n                    self.node = node\n                    self.size = 1\n                    return\n                if node.position[axis] < self.node.position[axis]:\n                    if self.left is None:\n                        self.left = KDTree()\n                    self.left.insert(node, depth + 1)\n                else:\n                    if self.right is None:\n                        self.right = KDTree()\n                    self.right.insert(node, depth + 1)\n                self.size += 1\n\n            def nearest(self, point, best=None, best_dist=float('inf'), depth=0):\n                if self.node is None:\n                    return best, best_dist\n                axis = depth % dim\n                here_dist = math.dist(point, self.node.position)\n                if here_dist < best_dist:\n                    best = self.node\n                    best_dist = here_dist\n                diff = point[axis] - self.node.position[axis]\n                close, away = (self.left, self.right) if diff < 0 else (self.right, self.left)\n                if close is not None:\n                    best, best_dist = close.nearest(point, best, best_dist, depth + 1)\n                if away is not None and abs(diff) < best_dist:\n                    best, best_dist = away.nearest(point, best, best_dist, depth + 1)\n                return best, best_dist\n\n            def near(self, point, radius, results=None, depth=0):\n                if results is None:\n                    results = []\n                if self.node is None:\n                    return results\n                axis = depth % dim\n                dist_axis = point[axis] - self.node.position[axis]\n                sq_radius = radius * radius\n                dist_sq = sum((point[i] - self.node.position[i]) ** 2 for i in range(dim))\n                if dist_sq <= sq_radius:\n                    results.append(self.node)\n                if self.left is not None and dist_axis < radius:\n                    self.left.near(point, radius, results, depth + 1)\n                if self.right is not None and dist_axis > -radius:\n                    self.right.near(point, radius, results, depth + 1)\n                return results\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def rewiring_radius(num_nodes, current_cost):\n            # Use a smoothly decaying radius capped by r_min and r_max and cost factor to adapt rewiring scope\n            if num_nodes < 2:\n                return self.r_max\n            base = 2 * ((math.log(num_nodes) / num_nodes) ** (1 / dim)) * self.step_size\n            cost_scale = self.r_max if current_cost == float('inf') else max(self.r_min, min(self.r_max, current_cost / (dist(start_pos, goal_pos) + 1e-9)))\n            return max(self.r_min, min(base, cost_scale))\n\n        def sample(iter_num):\n            p_goal = self.goal_sample_rate\n            c_min = dist(start_pos, goal_pos)\n            c_best = best_cost if best_cost < float('inf') else None\n            if random.random() < p_goal and not collision_node(goal_pos):\n                return goal_pos\n            uniform_prob = 0.15 if (c_best is None or c_best > 1.1 * c_min) else 0.08\n            r = random.random()\n            if r < uniform_prob:\n                for _ in range(25):\n                    p = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                    if not collision_node(p):\n                        return p\n            if c_best is not None and c_best < float('inf'):\n                center = tuple((start_pos[i] + goal_pos[i]) * 0.5 for i in range(dim))\n                a_len = c_best / 2.0\n                val = max(c_best * c_best - c_min * c_min, 0.0)\n                b_len = math.sqrt(val) / 2.0\n\n                a1 = [goal_pos[i] - start_pos[i] for i in range(dim)]\n                length_a1 = math.sqrt(sum(x * x for x in a1))\n                if length_a1 < 1e-15:\n                    basis = [[1 if i == j else 0 for i in range(dim)] for j in range(dim)]\n                else:\n                    e1 = [x / length_a1 for x in a1]\n                    basis = [e1]\n                    if dim == 2:\n                        basis.append([-e1[1], e1[0]])\n                    else:\n                        v = [1, 0, 0] if abs(e1[0]) < 0.9 else [0, 1, 0]\n                        dot = sum(v[i] * e1[i] for i in range(dim))\n                        u = [v[i] - dot * e1[i] for i in range(dim)]\n                        u_norm = math.sqrt(sum(x * x for x in u))\n                        if u_norm < 1e-15:\n                            u = [0] * dim\n                            u[-1] = 1.0\n                            u_norm = 1.0\n                        u = [x / u_norm for x in u]\n                        w = [e1[1] * u[2] - e1[2] * u[1],\n                             e1[2] * u[0] - e1[0] * u[2],\n                             e1[0] * u[1] - e1[1] * u[0]]\n                        basis.extend([u, w])\n\n                def unit_ball_sample():\n                    while True:\n                        vec = [random.gauss(0, 1) for _ in range(dim)]\n                        norm = math.sqrt(sum(x * x for x in vec))\n                        if norm > 1e-9:\n                            return [x / norm for x in vec]\n\n                for _ in range(12):\n                    u = unit_ball_sample()\n                    pt = [0] * dim\n                    if dim == 2:\n                        pt[0] = u[0] * a_len\n                        pt[1] = u[1] * b_len\n                    else:\n                        pt[0] = u[0] * a_len\n                        pt[1] = u[1] * b_len\n                        pt[2] = u[2] * b_len\n                    sample_p = [center[i] + sum(pt[j] * basis[j][i] for j in range(dim)) for i in range(dim)]\n                    sample_t = tuple(sample_p)\n                    if in_bounds(sample_t) and not collision_node(sample_t):\n                        return sample_t\n                # fallback uniform sample one last attempt\n                for _ in range(10):\n                    p = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                    if not collision_node(p):\n                        return p\n                return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n            else:\n                for _ in range(25):\n                    p = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                    if not collision_node(p):\n                        return p\n                return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n\n        def update_parent(child, new_parent, new_cost):\n            if child.parent is not None:\n                child.parent.remove_child(child)\n            child.parent = new_parent\n            child.cost = new_cost\n            new_parent.add_child(child)\n\n        def propagate_costs(node):\n            stack = [node]\n            while stack:\n                current = stack.pop()\n                for c in current.children:\n                    c_new_cost = current.cost + dist(current.position, c.position)\n                    if c_new_cost + 1e-12 < c.cost:\n                        update_parent(c, current, c_new_cost)\n                        stack.append(c)\n\n        def extract_path(n_start, n_goal):\n            path_start = []\n            cur = n_start\n            while cur is not None:\n                path_start.append(cur.position)\n                cur = cur.parent\n            path_goal = []\n            cur = n_goal\n            while cur is not None:\n                path_goal.append(cur.position)\n                cur = cur.parent\n            if path_start and path_goal and path_start[-1] == path_goal[-1]:\n                path_goal.pop()\n            return path_start[::-1] + path_goal\n\n        def incremental_shortcut(path):\n            if len(path) < 3:\n                return path[:]\n            pth = path[:]\n            attempts_limit = min(self.shortcut_attempts, max(30, int(len(pth) / 1.5)))\n            attempts = 0\n            while attempts < attempts_limit:\n                if len(pth) < 3:\n                    break\n                i = random.randint(0, len(pth) - 3)\n                j = random.randint(i + 2, len(pth) - 1)\n                if not collision_edge(pth[i], pth[j]):\n                    pth = pth[:i + 1] + pth[j:]\n                    attempts = 0\n                else:\n                    attempts += 1\n            return pth\n\n        def global_smooth(path, passes=3):\n            smoothed = path[:]\n            for _ in range(passes):\n                smoothed = incremental_shortcut(smoothed)\n            return smoothed\n\n        start_node = Node(start_pos)\n        goal_node = Node(goal_pos)\n        start_tree_nodes = [start_node]\n        goal_tree_nodes = [goal_node]\n\n        start_kd = KDTree(start_tree_nodes)\n        goal_kd = KDTree(goal_tree_nodes)\n\n        all_nodes = start_tree_nodes + goal_tree_nodes\n        edges = []\n\n        best_cost = float('inf')\n        solution_nodes = (None, None)\n\n        iter_since_improve = 0\n        prev_best_cost = best_cost\n        last_improved_path = None\n\n        for it in range(1, self.max_iter + 1):\n            sample_point = sample(it)\n\n            if it % 2 == 1:\n                res = None\n                nearest_node, _ = start_kd.nearest(sample_point)\n                if nearest_node is not None:\n                    new_pos = steer(nearest_node.position, sample_point)\n                    if in_bounds(new_pos) and not collision_node(new_pos) and not collision_edge(nearest_node.position, new_pos):\n                        r = rewiring_radius(len(start_tree_nodes), best_cost)\n                        if it % self.rewiring_interval == 0:\n                            near_nodes = start_kd.near(new_pos, r)\n                        else:\n                            near_nodes = []\n                        min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n                        min_parent = nearest_node\n                        for node in near_nodes:\n                            c_new = node.cost + dist(node.position, new_pos)\n                            if c_new + 1e-12 < min_cost and not collision_edge(node.position, new_pos):\n                                min_cost = c_new\n                                min_parent = node\n                        new_node = Node(new_pos, min_parent, min_cost)\n                        min_parent.add_child(new_node)\n                        start_tree_nodes.append(new_node)\n                        all_nodes.append(new_node)\n                        edges.append((min_parent, new_node))\n                        start_kd.insert(new_node)\n                        if it % self.rewiring_interval == 0:\n                            for node in near_nodes:\n                                if node is min_parent or node is new_node:\n                                    continue\n                                c_through = new_node.cost + dist(new_node.position, node.position)\n                                if c_through + 1e-12 < node.cost and not collision_edge(new_node.position, node.position):\n                                    if node.parent is not None:\n                                        try:\n                                            edges.remove((node.parent, node))\n                                        except ValueError:\n                                            pass\n                                        node.parent.remove_child(node)\n                                    update_parent(node, new_node, c_through)\n                                    propagate_costs(node)\n                                    edges.append((new_node, node))\n                        nearest_other, dist_other = goal_kd.nearest(new_node.position)\n                        if nearest_other is not None:\n                            dist_connect = dist(new_node.position, nearest_other.position)\n                            max_connect_dist = max(self.step_size * 1.4, r)\n                            if dist_connect <= max_connect_dist and not collision_edge(new_node.position, nearest_other.position):\n                                total_cost = new_node.cost + dist_connect + nearest_other.cost\n                                res = new_node, nearest_other, total_cost\n                if res is not None:\n                    n1, n2, cost_path = res\n                    if cost_path + 1e-10 < best_cost:\n                        best_cost = cost_path\n                        iter_since_improve = 0\n                        solution_nodes = (n1, n2)\n                        raw_path = extract_path(n1, n2)\n                        if it % self.shortcut_interval == 0:\n                            shortcut_path = incremental_shortcut(raw_path)\n                            if it % self.smooth_interval == 0 or len(shortcut_path) > 30:\n                                shortcut_path = global_smooth(shortcut_path, passes=self.smooth_passes)\n                            last_improved_path = shortcut_path\n                        else:\n                            last_improved_path = raw_path\n                        if prev_best_cost - best_cost < self.improvement_thresh and it > self.smooth_interval:\n                            if last_improved_path and len(last_improved_path) >= 2:\n                                return PlannerResult(True, last_improved_path, all_nodes, edges)\n                        prev_best_cost = best_cost\n                    else:\n                        iter_since_improve += 1\n                else:\n                    iter_since_improve += 1\n\n            else:\n                res = None\n                nearest_node, _ = goal_kd.nearest(sample_point)\n                if nearest_node is not None:\n                    new_pos = steer(nearest_node.position, sample_point)\n                    if in_bounds(new_pos) and not collision_node(new_pos) and not collision_edge(nearest_node.position, new_pos):\n                        r = rewiring_radius(len(goal_tree_nodes), best_cost)\n                        if it % self.rewiring_interval == 0:\n                            near_nodes = goal_kd.near(new_pos, r)\n                        else:\n                            near_nodes = []\n                        min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n                        min_parent = nearest_node\n                        for node in near_nodes:\n                            c_new = node.cost + dist(node.position, new_pos)\n                            if c_new + 1e-12 < min_cost and not collision_edge(node.position, new_pos):\n                                min_cost = c_new\n                                min_parent = node\n                        new_node = Node(new_pos, min_parent, min_cost)\n                        min_parent.add_child(new_node)\n                        goal_tree_nodes.append(new_node)\n                        all_nodes.append(new_node)\n                        edges.append((min_parent, new_node))\n                        goal_kd.insert(new_node)\n                        if it % self.rewiring_interval == 0:\n                            for node in near_nodes:\n                                if node is min_parent or node is new_node:\n                                    continue\n                                c_through = new_node.cost + dist(new_node.position, node.position)\n                                if c_through + 1e-12 < node.cost and not collision_edge(new_node.position, node.position):\n                                    if node.parent is not None:\n                                        try:\n                                            edges.remove((node.parent, node))\n                                        except ValueError:\n                                            pass\n                                        node.parent.remove_child(node)\n                                    update_parent(node, new_node, c_through)\n                                    propagate_costs(node)\n                                    edges.append((new_node, node))\n                        nearest_other, dist_other = start_kd.nearest(new_node.position)\n                        if nearest_other is not None:\n                            dist_connect = dist(new_node.position, nearest_other.position)\n                            max_connect_dist = max(self.step_size * 1.4, r)\n                            if dist_connect <= max_connect_dist and not collision_edge(new_node.position, nearest_other.position):\n                                total_cost = new_node.cost + dist_connect + nearest_other.cost\n                                res = new_node, nearest_other, total_cost\n                if res is not None:\n                    n1, n2, cost_path = res\n                    if cost_path + 1e-10 < best_cost:\n                        best_cost = cost_path\n                        iter_since_improve = 0\n                        solution_nodes = (n2, n1)\n                        raw_path = extract_path(n2, n1)\n                        if it % self.shortcut_interval == 0:\n                            shortcut_path = incremental_shortcut(raw_path)\n                            if it % self.smooth_interval == 0 or len(shortcut_path) > 30:\n                                shortcut_path = global_smooth(shortcut_path, passes=self.smooth_passes)\n                            last_improved_path = shortcut_path\n                        else:\n                            last_improved_path = raw_path\n                        if prev_best_cost - best_cost < self.improvement_thresh and it > self.smooth_interval:\n                            if last_improved_path and len(last_improved_path) >= 2:\n                                return PlannerResult(True, last_improved_path, all_nodes, edges)\n                        prev_best_cost = best_cost\n                    else:\n                        iter_since_improve += 1\n                else:\n                    iter_since_improve += 1\n\n            if iter_since_improve > self.early_stop_patience and last_improved_path is not None:\n                final_path = global_smooth(last_improved_path, passes=self.smooth_passes)\n                if len(final_path) >= 2:\n                    return PlannerResult(True, final_path, all_nodes, edges)\n                break\n\n        # Final return fallback\n        if last_improved_path is not None and len(last_improved_path) >= 2:\n            return PlannerResult(True, last_improved_path, all_nodes, edges)\n        elif solution_nodes[0] is not None and solution_nodes[1] is not None:\n            final_path = extract_path(solution_nodes[0], solution_nodes[1])\n            final_path = global_smooth(incremental_shortcut(final_path), passes=self.smooth_passes)\n            if len(final_path) >= 2:\n                return PlannerResult(True, final_path, all_nodes, edges)\n\n        return PlannerResult(False, [], all_nodes, edges)",
          "objective": -23.86634,
          "time_improvement": 24.0,
          "length_improvement": 15.0,
          "smoothness_improvement": 1521.0,
          "node_improvement": 60.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.03662815093994141,
                    "num_nodes_avg": 201.4,
                    "path_length_avg": 166.29767002889622,
                    "smoothness_avg": 0.047824350412532836,
                    "success_improvement": 0.0,
                    "time_improvement": -42.020161868092764,
                    "node_improvement": 49.282296650717704,
                    "length_improvement": 8.849611901949048,
                    "smoothness_improvement": 648.5549361952724,
                    "objective_score": -4.053506738282037
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.041453075408935544,
                    "num_nodes_avg": 387.0,
                    "path_length_avg": 240.79462057912352,
                    "smoothness_avg": 0.09711053205906416,
                    "success_improvement": 0.0,
                    "time_improvement": 74.96427516160415,
                    "node_improvement": 73.9971779883088,
                    "length_improvement": 19.615824761828765,
                    "smoothness_improvement": 2398.7239357687286,
                    "objective_score": 46.25239708442215
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.030809426307678224,
                    "num_nodes_avg": 342.4,
                    "path_length_avg": 125.39917220855682,
                    "smoothness_avg": 0.1271093631225309,
                    "success_improvement": 0.0,
                    "time_improvement": 39.28839727299763,
                    "node_improvement": 56.46535282898919,
                    "length_improvement": 16.715840685977813,
                    "smoothness_improvement": 1516.8217166813586,
                    "objective_score": 29.400132176892768
               }
          ],
          "success_rate": 1.0
     }
]