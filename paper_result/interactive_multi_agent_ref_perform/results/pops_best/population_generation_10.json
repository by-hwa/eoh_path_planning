{
     "operator": "m1",
     "algorithm_description": "A bidirectional RRT* variant with a kd-tree-based nearest neighbor structure for efficient queries, ellipsoidal informed sampling to concentrate search around the best path, adaptive rewiring radius balancing exploration and exploitation, and a deferred global shortcut smoothing applied once a solution is found. The planner alternates expansion between the two trees, dynamically adjusts goal bias with iteration progress, and integrates collision checks before node/edge additions to ensure path validity and coherent tree structures, leading to improved planning time, path length, and smoothness.",
     "planning_mechanism": "The planner maintains two trees rooted at start and goal, performing expansions alternately. Each sample is drawn either from an informed ellipsoidal set biased by the current best path cost or via goal-biased sampling. kd-tree data structures enable fast nearest neighbor and radius-based neighbor retrievals. Parent selection and rewiring optimize path cost while collision checks maintain feasibility. Once a valid connection between trees appears, the planner reconstructs the combined path and applies global shortcutting for smoothness and length improvement before returning the result.",
     "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n    def add_child(self, child):\n        self.children.append(child)\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=3000, step_size=8.0, base_radius=25.0,\n                 goal_sample_rate=0.15, min_goal_sample_rate=0.05,\n                 goal_sample_decay=0.995, shortcut_iters=80):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.base_radius = base_radius\n        self.goal_sample_rate = goal_sample_rate\n        self.min_goal_sample_rate = min_goal_sample_rate\n        self.goal_sample_decay = goal_sample_decay\n        self.shortcut_iters = shortcut_iters\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def dist(a,b):\n            return math.dist(a,b)\n        def sq_dist(a,b):\n            return sum((a[i]-b[i])**2 for i in range(dim))\n        def in_bounds(p):\n            for i in range(dim):\n                if p[i]<0 or p[i]>bounds[i]:\n                    return False\n            return True\n        def is_in_obstacle(p):\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d_ = obs\n                    px,py,pz = p\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d_:\n                        return True\n                else:\n                    x,y,w_,h_ = obs\n                    px,py = p\n                    if x <= px <= x+w_ and y <= py <= y+h_:\n                        return True\n            return False\n        def edge_in_collision(fr,to, resolution=1.0):\n            length = dist(fr,to)\n            if length == 0: return False\n            steps = max(1, int(length/resolution))\n            for i in range(steps+1):\n                interp = tuple(fr[d] + (to[d]-fr[d])*i/steps for d in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n        def steer(fr,to):\n            length = dist(fr,to)\n            if length <= self.step_size:\n                return to\n            ratio = self.step_size / length\n            return tuple(fr[d] + (to[d] - fr[d]) * ratio for d in range(dim))\n\n        # Implement a simple k-d tree for efficient neighbor queries\n        class KDTree:\n            def __init__(self, points=None, depth=0):\n                self.axis = depth % dim\n                if not points:\n                    self.location = None\n                    self.left = None\n                    self.right = None\n                    self.nodes = []\n                    return\n                points = sorted(points, key=lambda n: n.position[self.axis])\n                median = len(points)//2\n                self.location = points[median]\n                self.left = KDTree(points[:median], depth+1) if median > 0 else None\n                self.right = KDTree(points[median+1:], depth+1) if median+1 < len(points) else None\n                self.nodes = None  # only in leaf-less nodes\n\n            def insert(self, node, depth=0):\n                if self.location is None:\n                    self.location = node\n                    self.left = None\n                    self.right = None\n                    return\n                axis = depth % dim\n                if node.position[axis] < self.location.position[axis]:\n                    if self.left is None:\n                        self.left = KDTree([node], depth+1)\n                    else:\n                        self.left.insert(node, depth+1)\n                else:\n                    if self.right is None:\n                        self.right = KDTree([node], depth+1)\n                    else:\n                        self.right.insert(node, depth+1)\n\n            def nearest(self, point, best=None, best_dist=float('inf'), depth=0):\n                if self.location is None:\n                    return best, best_dist\n                axis = depth % dim\n                here_dist = sq_dist(point, self.location.position)\n                if here_dist < best_dist:\n                    best = self.location\n                    best_dist = here_dist\n                diff = point[axis] - self.location.position[axis]\n                close, away = (self.left, self.right) if diff < 0 else (self.right, self.left)\n                if close is not None:\n                    best, best_dist = close.nearest(point, best, best_dist, depth+1)\n                if away is not None and diff*diff < best_dist:\n                    best, best_dist = away.nearest(point, best, best_dist, depth+1)\n                return best, best_dist\n\n            def radius_search(self, point, radius, results=None, depth=0):\n                if results is None:\n                    results = []\n                if self.location is None:\n                    return results\n                axis = depth % dim\n                dist_sq = sq_dist(point, self.location.position)\n                if dist_sq <= radius*radius:\n                    results.append(self.location)\n                diff = point[axis] - self.location.position[axis]\n                if self.left is not None and diff - radius <= 0:\n                    self.left.radius_search(point, radius, results, depth+1)\n                if self.right is not None and diff + radius >= 0:\n                    self.right.radius_search(point, radius, results, depth+1)\n                return results\n\n        def adaptive_radius(n_nodes):\n            n_nodes = max(n_nodes, 2)\n            gamma = self.base_radius\n            radius = gamma * (math.log(n_nodes)/n_nodes)**(1/dim)\n            return max(radius, self.step_size*1.5)\n\n        def ellipsoid_sample(start, goal, c_max):\n            if c_max == float('inf'):\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            center = tuple((start[d]+goal[d])*0.5 for d in range(dim))\n            diff = tuple(goal[d]-start[d] for d in range(dim))\n            dist_sg = dist(start, goal)\n            if dist_sg < 1e-100:\n                return tuple(random.uniform(0,bounds[d]) for d in range(dim))\n            unit_vec = tuple(diff[d]/dist_sg for d in range(dim))\n            if dim == 2:\n                import math\n                angle = math.atan2(unit_vec[1], unit_vec[0])\n                for _ in range(15):\n                    r1 = random.uniform(0,1)\n                    r2 = random.uniform(0,1)\n                    rx = r1 * c_max * 0.5\n                    ry = r2 * math.sqrt(c_max*c_max - dist_sg*dist_sg)*0.5\n                    x = rx * math.cos(angle) - ry * math.sin(angle)\n                    y = rx * math.sin(angle) + ry * math.cos(angle)\n                    sample = (center[0]+x, center[1]+y)\n                    if in_bounds(sample):\n                        return sample\n                return tuple(random.uniform(0,bounds[d]) for d in range(dim))\n            else:\n                rx = c_max*0.5\n                ry = rx*0.6\n                rz = rx*0.4\n                for _ in range(25):\n                    x = random.uniform(-rx, rx)\n                    y = random.uniform(-ry, ry)\n                    z = random.uniform(-rz, rz)\n                    sample = (center[0]+x, center[1]+y, center[2]+z)\n                    if in_bounds(sample):\n                        return sample\n                return tuple(random.uniform(0,bounds[d]) for d in range(dim))\n\n        def extract_path(node_start, node_goal):\n            path_start = node_start.path_from_root()\n            path_goal = node_goal.path_from_root()[::-1]\n            if path_start and path_goal and path_start[-1] == path_goal[0]:\n                path_goal = path_goal[1:]\n            return path_start + path_goal\n\n        def global_shortcut(path):\n            if len(path) < 3:\n                return path[:]\n            p = path[:]\n            for _ in range(self.shortcut_iters):\n                if len(p) < 3:\n                    break\n                i = random.randint(0, len(p)-3)\n                j = random.randint(i+2, len(p)-1)\n                if not edge_in_collision(p[i], p[j]):\n                    p = p[:i+1] + p[j:]\n            return p\n\n        # Initialize trees and kd-trees\n        start_root = Node(start_pos)\n        goal_root = Node(goal_pos)\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n        all_nodes = start_tree + goal_tree\n        edges = []\n\n        kd_start = KDTree([start_root])\n        kd_goal = KDTree([goal_root])\n\n        best_cost = float('inf')\n        connection = None\n        goal_bias = self.goal_sample_rate\n\n        for it in range(self.max_iter):\n            goal_bias = max(self.min_goal_sample_rate, goal_bias * self.goal_sample_decay)\n\n            for tree_a, tree_b, kd_a, kd_b in [(start_tree, goal_tree, kd_start, kd_goal),\n                                               (goal_tree, start_tree, kd_goal, kd_start)]:\n                c_max = best_cost if best_cost < float('inf') else float('inf')\n                if random.random() < goal_bias:\n                    sample = goal_pos\n                else:\n                    sample = ellipsoid_sample(start_pos, goal_pos, c_max)\n                if is_in_obstacle(sample):\n                    continue\n\n                nearest_node, _ = kd_a.nearest(sample)\n                if nearest_node is None:\n                    continue\n                new_pos = steer(nearest_node.position, sample)\n                if not in_bounds(new_pos) or is_in_obstacle(new_pos) or edge_in_collision(nearest_node.position, new_pos):\n                    continue\n                radius = adaptive_radius(len(tree_a)+1)\n                near_nodes = kd_a.radius_search(new_pos, radius)\n\n                min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n                min_parent = nearest_node\n                for nb in near_nodes:\n                    if nb == nearest_node:\n                        continue\n                    cand_cost = nb.cost + dist(nb.position, new_pos)\n                    if cand_cost + 1e-9 < min_cost and not edge_in_collision(nb.position, new_pos):\n                        min_cost = cand_cost\n                        min_parent = nb\n\n                new_node = Node(new_pos, parent=min_parent, cost=min_cost)\n                min_parent.add_child(new_node)\n                tree_a.append(new_node)\n                all_nodes.append(new_node)\n                edges.append((min_parent, new_node))\n                kd_a.insert(new_node)\n\n                # Rewire near nodes through new_node if improvement\n                for nb in near_nodes:\n                    if nb == min_parent:\n                        continue\n                    new_cost = new_node.cost + dist(new_node.position, nb.position)\n                    if new_cost + 1e-9 < nb.cost and not edge_in_collision(new_node.position, nb.position):\n                        old_parent = nb.parent\n                        if old_parent:\n                            old_parent.remove_child(nb)\n                            try:\n                                edges.remove((old_parent, nb))\n                            except ValueError:\n                                pass\n                        nb.parent = new_node\n                        nb.cost = new_cost\n                        new_node.add_child(nb)\n                        edges.append((new_node, nb))\n\n                # Attempt connection with other tree - nearest node within step_size\n                near_other = kd_b.radius_search(new_node.position, self.step_size*1.5)\n                for node_other in near_other:\n                    if dist(new_node.position, node_other.position) <= self.step_size:\n                        if not edge_in_collision(new_node.position, node_other.position):\n                            total_cost = new_node.cost + dist(new_node.position, node_other.position) + node_other.cost\n                            if total_cost + 1e-9 < best_cost:\n                                best_cost = total_cost\n                                if tree_a is start_tree:\n                                    connection = (new_node, node_other)\n                                else:\n                                    connection = (node_other, new_node)\n\n            if connection is not None:\n                break\n\n        if connection is None:\n            return PlannerResult(False, [], all_nodes, edges)\n\n        raw_path = extract_path(connection[0], connection[1])\n        smooth_path = global_shortcut(raw_path)\n\n        return PlannerResult(True, smooth_path, all_nodes, edges)",
     "objective": -35.67144,
     "time_improvement": 62.0,
     "length_improvement": 15.0,
     "smoothness_improvement": 1613.0,
     "node_improvement": 80.0,
     "other_inf": [
          {
               "map_id": 0,
               "success_rate": 1.0,
               "time_avg": 0.017667293548583984,
               "num_nodes_avg": 101.7,
               "path_length_avg": 166.13517920479458,
               "smoothness_avg": 0.03625333347975132,
               "success_improvement": 0.0,
               "time_improvement": 31.497718963341637,
               "node_improvement": 74.38932258876858,
               "length_improvement": 8.938675697471036,
               "smoothness_improvement": 467.4433943318028,
               "objective_score": 17.149738079144125
          },
          {
               "map_id": 1,
               "success_rate": 1.0,
               "time_avg": 0.0215378999710083,
               "num_nodes_avg": 201.5,
               "path_length_avg": 233.193267577381,
               "smoothness_avg": 0.1118364131236119,
               "success_improvement": 0.0,
               "time_improvement": 86.99211260077399,
               "node_improvement": 86.46106295773701,
               "length_improvement": 22.15337518662528,
               "smoothness_improvement": 2777.6314621829497,
               "objective_score": 53.277816203122114
          },
          {
               "map_id": 2,
               "success_rate": 1.0,
               "time_avg": 0.016871142387390136,
               "num_nodes_avg": 164.8,
               "path_length_avg": 128.99936346398462,
               "smoothness_avg": 0.1331070185910396,
               "success_improvement": 0.0,
               "time_improvement": 66.75452233530704,
               "node_improvement": 79.04640813731724,
               "length_improvement": 14.324765076807733,
               "smoothness_improvement": 1593.1114515399127,
               "objective_score": 36.58677300437632
          }
     ],
     "success_rate": 1.0
}