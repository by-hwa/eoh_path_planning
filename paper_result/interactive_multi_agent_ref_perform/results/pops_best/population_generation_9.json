{
     "operator": "time_expert",
     "algorithm_description": "A focused bidirectional Informed RRT* planner with ellipsoidal informed sampling around the current best path to guide sampling toward promising regions, combined with efficient rewiring using cost-to-come and adaptive radius scaling for rapid convergence. After each successful tree connection, a deterministic global shortcutting post-process refines the path to significantly improve smoothness and path length. Progressive bidirectional expansion with dynamic goal biasing accelerates connection. This focused sampling and enhanced rewiring drastically reduces redundant exploration, cutting planning time while improving path quality and smoothness.",
     "planning_mechanism": "The planner grows two trees from start and goal, alternately expanding towards samples drawn within an ellipsoidal informed set bound by the current best solution cost. New nodes connect to the lowest-cost parent within an adaptive radius, with rewiring improving local paths. Upon successful connection, a deterministic global shortcutting removes unnecessary waypoints and smooths the path. This approach focuses search near the current best path, efficiently reducing exploration time while systematically improving path quality and smoothness.",
     "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except ValueError:\n            pass\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=3500, step_size=7.5, base_radius=22.0, goal_sample_rate=0.10):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.base_radius = base_radius\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map) -> 'PlannerResult':\n        import random, math\n\n        bounds = map.size\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        # Distance and linear interpolation helpers\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(fr, to):\n            d = dist(fr, to)\n            if d <= self.step_size:\n                return to\n            ratio = self.step_size / d\n            return tuple(fr[i] + (to[i] - fr[i]) * ratio for i in range(dim))\n\n        # Collision checking helpers\n        def is_in_obstacle(p):\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d_ = obs\n                    px,py,pz = p\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d_:\n                        return True\n                else:\n                    x,y,w,h = obs\n                    px,py = p\n                    if x <= px <= x+w and y <= py <= y+h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(fr, to, resolution=1.0):\n            d = dist(fr, to)\n            steps = max(1, int(d / resolution))\n            for i in range(steps+1):\n                interp = tuple(fr[j] + (to[j] - fr[j]) * i / steps for j in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        # Nearest and near node search (linear scan)\n        def nearest(tree, point):\n            return min(tree, key=lambda node: dist(node.position, point))\n\n        def near_nodes(tree, point, radius):\n            r2 = radius * radius\n            result = []\n            for n in tree:\n                cd = 0.0\n                for i in range(dim):\n                    d_ = n.position[i] - point[i]\n                    cd += d_*d_\n                    if cd > r2:\n                        break\n                else:\n                    result.append(n)\n            return result\n\n        # Adaptive rewiring radius based on tree size and dimension\n        def adaptive_radius(n):\n            n = max(n,1)\n            radius = self.base_radius * (math.log(n)/n)**(1.0/dim)\n            min_radius = self.step_size * 1.7\n            return max(radius, min_radius)\n\n        # Rewire tree edges for better parent selection\n        def rewire(tree, new_node, near_nodes_):\n            nonlocal edges\n            for near in near_nodes_:\n                if near is new_node.parent:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, near.position)\n                if new_cost + 1e-10 < near.cost:\n                    if not is_edge_in_obstacle(new_node.position, near.position):\n                        # Remove old edge\n                        if near.parent is not None:\n                            try:\n                                edges.remove((near.parent, near))\n                                near.parent.remove_child(near)\n                            except Exception:\n                                pass\n                        near.parent = new_node\n                        near.cost = new_cost\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n\n        # Extract path joining two nodes' root paths\n        def extract_path(node_start, node_goal):\n            p1 = node_start.path_from_root()\n            p2 = node_goal.path_from_root()[::-1]\n            if p1 and p2 and p1[-1] == p2[0]:\n                p2 = p2[1:]\n            return p1 + p2\n\n        # Compute minimum possible cost heuristic for Informed Sampling \n        def straight_dist(a,b):\n            return dist(a,b)\n\n        # Elliptical informed sampling, samples inside ellipsoid between start and goal w.r.t current best cost.\n        def informed_sample(c_best):\n            # If no path, sample uniformly\n            if c_best == math.inf:\n                return tuple(random.uniform(0,bounds[i]) for i in range(dim))\n            # Positions as vectors\n            c_min = straight_dist(start_pos, goal_pos)\n            if c_best < c_min:\n                # Numerical fallback to uniform\n                return tuple(random.uniform(0,bounds[i]) for i in range(dim))\n            # Transform sample inside unit ball to ellipsoidal space\n            from math import sqrt, sin, cos, pi\n            # Build rotation matrix aligning the main axis along start->goal\n            # For 2D only for simplicity\n            if dim == 2:\n                dx = goal_pos[0]-start_pos[0]\n                dy = goal_pos[1]-start_pos[1]\n                theta = math.atan2(dy, dx)\n                r1 = c_best / 2.0\n                if c_best == 0:\n                    r2 = 0\n                else:\n                    r2 = sqrt(c_best**2 - c_min**2)/2.0\n\n                for _ in range(10):  # try 10 samples max\n                    # Sample random point inside unit circle\n                    u, v = random.uniform(-1,1), random.uniform(-1,1)\n                    if u*u + v*v > 1.0:\n                        continue\n                    # Scale to ellipse radii\n                    x_ball = u * r1\n                    y_ball = v * r2\n                    # Rotate and translate center to midpoint\n                    x_ellipse = math.cos(theta)*x_ball - math.sin(theta)*y_ball + (start_pos[0]+goal_pos[0])/2.0\n                    y_ellipse = math.sin(theta)*x_ball + math.cos(theta)*y_ball + (start_pos[1]+goal_pos[1])/2.0\n                    # Check bounds\n                    if 0 <= x_ellipse <= bounds[0] and 0 <= y_ellipse <= bounds[1]:\n                        return (x_ellipse, y_ellipse)\n                # fallback uniform\n                return tuple(random.uniform(0,bounds[i]) for i in range(dim))\n            else:\n                # For 3D or others: uniform fallback for performance\n                return tuple(random.uniform(0,bounds[i]) for i in range(dim))\n\n        # Deterministic global shortcutting to remove intermediary nodes where line is obstacle free\n        def global_shortcut(path):\n            if len(path) < 3:\n                return path[:]\n            new_path = [path[0]]\n            idx = 0\n            while idx < len(path)-1:\n                next_idx = len(path)-1\n                # find farthest reachable node in path without collision\n                for j in range(len(path)-1, idx, -1):\n                    if not is_edge_in_obstacle(path[idx], path[j]):\n                        next_idx = j\n                        break\n                new_path.append(path[next_idx])\n                idx = next_idx\n            return new_path\n\n        # Initialize trees and tracking variables\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        best_cost = math.inf\n        connection_start = connection_goal = None\n        success = False\n\n        # Alternate expansion: 0 for start_tree, 1 for goal_tree\n        tree_switch = 0\n\n        for itr in range(self.max_iter):\n            tree_a = start_tree if tree_switch == 0 else goal_tree\n            tree_b = goal_tree if tree_switch == 0 else start_tree\n            tree_switch = 1 - tree_switch\n\n            # Sample point: goal bias or informed sample around best path cost\n            if best_cost < math.inf and random.random() > self.goal_sample_rate:\n                q_rand = informed_sample(best_cost)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    q_rand = goal_pos if tree_a is start_tree else start_pos\n                else:\n                    q_rand = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n\n            nearest_node = nearest(tree_a, q_rand)\n            q_new_pos = steer(nearest_node.position, q_rand)\n            if is_in_obstacle(q_new_pos):\n                continue\n            if is_edge_in_obstacle(nearest_node.position, q_new_pos):\n                continue\n\n            # Determine near nodes for parent selection and rewiring\n            radius = adaptive_radius(len(tree_a))\n            near_nodes_a = near_nodes(tree_a, q_new_pos, radius)\n\n            # Parent selection: minimum cost that yields collision free edge\n            min_cost = nearest_node.cost + dist(nearest_node.position, q_new_pos)\n            min_parent = nearest_node\n            for near in near_nodes_a:\n                cost_candidate = near.cost + dist(near.position, q_new_pos)\n                if cost_candidate + 1e-10 < min_cost and not is_edge_in_obstacle(near.position, q_new_pos):\n                    min_cost = cost_candidate\n                    min_parent = near\n\n            q_new = Node(q_new_pos, parent=min_parent, cost=min_cost)\n            min_parent.add_child(q_new)\n            tree_a.append(q_new)\n            nodes.append(q_new)\n            edges.append((min_parent, q_new))\n\n            # Rewire around new node for improved paths\n            rewire(tree_a, q_new, near_nodes_a)\n\n            # Check connection to other tree\n            nearest_other = nearest(tree_b, q_new.position)\n            d_connect = dist(q_new.position, nearest_other.position)\n            radius_conn = max(self.step_size*1.7, adaptive_radius(len(tree_b)))\n            if d_connect <= radius_conn and not is_edge_in_obstacle(q_new.position, nearest_other.position):\n                # Connection found\n                if tree_a is start_tree:\n                    connection_start, connection_goal = q_new, nearest_other\n                else:\n                    connection_start, connection_goal = nearest_other, q_new\n\n                raw_path = extract_path(connection_start, connection_goal)\n                path_cost = 0.0\n                for i in range(len(raw_path)-1):\n                    path_cost += dist(raw_path[i], raw_path[i+1])\n                if path_cost + 1e-10 < best_cost:\n                    best_cost = path_cost\n                    # Deterministic global shortcut for smoothness and length improvement\n                    improved_path = global_shortcut(raw_path)\n                    success = True\n                    # Stop early to return best found path\n                    return self._result(True, improved_path, nodes, edges)\n\n        # If no direct connection found but partial paths exist, attempt best partial path smoothing\n        if connection_start and connection_goal:\n            raw_path = extract_path(connection_start, connection_goal)\n            improved_path = global_shortcut(raw_path)\n            return self._result(True, improved_path, nodes, edges)\n\n        # No path found at all\n        return self._result(False, [], nodes, edges)\n\n    def _result(self, success, path, nodes, edges):\n        return PlannerResult(success, path, nodes, edges)",
     "objective": -35.64856,
     "time_improvement": 62.0,
     "length_improvement": 16.0,
     "smoothness_improvement": 1513.0,
     "node_improvement": 79.0,
     "other_inf": [
          {
               "map_id": 0,
               "success_rate": 1.0,
               "time_avg": 0.010542154312133789,
               "num_nodes_avg": 74.4,
               "path_length_avg": 168.37361962619414,
               "smoothness_avg": 0.055376394290867416,
               "success_improvement": 0.0,
               "time_improvement": 59.12437774151948,
               "node_improvement": 81.26416519768321,
               "length_improvement": 7.711751032143607,
               "smoothness_improvement": 766.7608224169738,
               "objective_score": 26.198168053826876
          },
          {
               "map_id": 1,
               "success_rate": 1.0,
               "time_avg": 0.015135645866394043,
               "num_nodes_avg": 175.4,
               "path_length_avg": 235.62763018068162,
               "smoothness_avg": 0.09300366993397884,
               "success_improvement": 0.0,
               "time_improvement": 90.8587755812018,
               "node_improvement": 88.21474165154875,
               "length_improvement": 21.340714880401087,
               "smoothness_improvement": 2293.05141523706,
               "objective_score": 51.52731867878649
          },
          {
               "map_id": 2,
               "success_rate": 1.0,
               "time_avg": 0.0327984094619751,
               "num_nodes_avg": 254.1,
               "path_length_avg": 122.41329750020927,
               "smoothness_avg": 0.1240597817209133,
               "success_improvement": 0.0,
               "time_improvement": 35.36900085553568,
               "node_improvement": 67.69230769230768,
               "length_improvement": 18.698916495187646,
               "smoothness_improvement": 1478.0312663494665,
               "objective_score": 29.220206485520627
          }
     ],
     "success_rate": 1.0
}