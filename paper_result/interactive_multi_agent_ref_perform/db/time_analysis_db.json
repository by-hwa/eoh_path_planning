[
    {
        "parents": [
            {
                "operator": "m3",
                "algorithm_description": "A simplified, robust bidirectional RRT* planner with adaptive ellipsoidal informed sampling and frequent, lightweight incremental path shortcutting integrated during planning iterations. The algorithm balances exploration and exploitation through ellipsoidal sampling shrinking as better solutions are found, adapts rewiring radius to tree size for efficient local optimization, and applies shortcutting regularly upon improvements to maintain smoother, shorter paths. Tree expansions alternate sides, connecting with nearest neighbors and rewiring locally with collision checks to ensure path validity and quality without heavy computational overhead. This produces timely convergence to high-quality, smooth paths balanced across planning time, length, and smoothness.",
                "planning_mechanism": "The planner grows two trees from start and goal, samples within an adaptively shrinking ellipsoidal informed subset after initial solutions, extends trees toward samples using a fixed step size, rewires neighbors within an adaptive radius to reduce path cost, attempts to connect trees frequently, and applies incremental shortcutting on improved paths during planning to improve smoothness and reduce length progressively.",
                "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=6.0, r_min=5.0, r_max=25.0, goal_sample_rate=0.1, shortcut_attempts=50):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.r_min = r_min\n        self.r_max = r_max\n        self.goal_sample_rate = goal_sample_rate\n        self.shortcut_attempts = shortcut_attempts\n\n    def plan(self, map):\n        import math\n        import random\n\n        bounds = map.size\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        obstacles = map.obstacles\n        start_pos = map.start\n        goal_pos = map.goal\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        best_cost = float('inf')\n        solution_nodes = (None, None)\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def heuristic(p, target):\n            return dist(p, target)\n\n        def is_in_obstacle(pos):\n            px = pos[0]\n            py = pos[1]\n            pz = pos[2] if is_3d else 0.0\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d = obs\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                        return True\n                else:\n                    x,y,w,h = obs\n                    if x <= px <= x+w and y <= py <= y+h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(a, b, resolution=0.5):\n            dist_ab = dist(a, b)\n            steps = max(1, int(dist_ab / resolution))\n            for i in range(steps + 1):\n                t = i / steps\n                interm = tuple(a[j] + t*(b[j]-a[j]) for j in range(dim))\n                if is_in_obstacle(interm):\n                    return True\n            return False\n\n        def nearest(tree, point):\n            best = None\n            best_d = float('inf')\n            for n in tree:\n                d_n = dist(n.position, point)\n                if d_n < best_d:\n                    best = n\n                    best_d = d_n\n            return best\n\n        def near(tree, point, radius):\n            r_sq = radius * radius\n            result = []\n            for n in tree:\n                d_sq = 0\n                for i in range(dim):\n                    d_sq += (n.position[i] - point[i]) ** 2\n                if d_sq <= r_sq:\n                    result.append(n)\n            return result\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            ratio = self.step_size / d\n            return tuple(from_pos[i] + ratio * (to_pos[i] - from_pos[i]) for i in range(dim))\n\n        def rewiring_radius(n_nodes):\n            if n_nodes < 2:\n                return self.r_max\n            val = 2 * ((math.log(n_nodes) / n_nodes) ** (1 / dim)) * self.step_size\n            return max(self.r_min, min(self.r_max, val))\n\n        def sample():\n            if random.random() < self.goal_sample_rate:\n                return goal_pos\n            if best_cost == float('inf'):\n                while True:\n                    pt = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                    if not is_in_obstacle(pt):\n                        return pt\n            center = tuple((start_pos[i]+goal_pos[i])/2 for i in range(dim))\n            c_min = dist(start_pos, goal_pos)\n            c_max = min(best_cost * 1.05, sum(bounds)*1.5)\n            a1 = [goal_pos[i]-start_pos[i] for i in range(dim)]\n            length = c_min\n            if length < 1e-15:\n                return goal_pos\n            e1 = [x/length for x in a1]\n\n            # Generate orthonormal basis\n            if dim == 2:\n                e2 = (-e1[1], e1[0])\n                basis = [e1, e2]\n            else:\n                # Gram-Schmidt for 3D\n                v = [1,0,0] if abs(e1[0]) < 0.9 else [0,1,0]\n                u = [v[i] - e1[i]*sum(v[j]*e1[j] for j in range(dim)) for i in range(dim)]\n                u_norm = math.sqrt(sum(x*x for x in u))\n                if u_norm < 1e-15:\n                    u = [0]*dim\n                    u[-1] = 1.0\n                    u_norm = 1.0\n                u = [x/u_norm for x in u]\n                w = [e1[1]*u[2]-e1[2]*u[1],\n                     e1[2]*u[0]-e1[0]*u[2],\n                     e1[0]*u[1]-e1[1]*u[0]]\n                basis = [e1, u, w]\n\n            a_len = c_max / 2.0\n            b_len_sq = max((c_max*c_max - c_min*c_min)/4.0, 1e-8)\n            b_len = math.sqrt(b_len_sq)\n\n            while True:\n                if dim == 2:\n                    r = random.uniform(0,1)**0.5\n                    theta = random.uniform(0, 2*math.pi)\n                    unit_ball = [r*math.cos(theta), r*math.sin(theta)]\n                    coords = [a_len * unit_ball[0], b_len * unit_ball[1]]\n                    pt = tuple(center[i] + sum(coords[j]*basis[j][i] for j in range(dim)) for i in range(dim))\n                else:\n                    while True:\n                        u_sample = [random.uniform(-1,1) for _ in range(3)]\n                        norm_sq = sum(x*x for x in u_sample)\n                        if norm_sq <= 1 and norm_sq > 0:\n                            break\n                    norm = math.sqrt(norm_sq)\n                    unit_ball = [x / norm for x in u_sample]\n                    coords = [a_len * unit_ball[0], b_len * unit_ball[1], b_len * unit_ball[2]]\n                    pt = tuple(center[i] + sum(coords[j]*basis[j][i] for j in range(dim)) for i in range(dim))\n                if any(pt[i]<0 or pt[i]>bounds[i] for i in range(dim)):\n                    continue\n                if is_in_obstacle(pt):\n                    continue\n                return pt\n\n        def extract_path(node_a, node_b):\n            path_a = []\n            cur = node_a\n            while cur is not None:\n                path_a.append(cur.position)\n                cur = cur.parent\n            path_b = []\n            cur = node_b\n            while cur is not None:\n                path_b.append(cur.position)\n                cur = cur.parent\n            return path_a[::-1] + path_b\n\n        def incremental_shortcut(path):\n            if len(path)<3:\n                return path[:]\n            new_path = path[:]\n            attempts = 0\n            while attempts < self.shortcut_attempts:\n                if len(new_path) < 3:\n                    break\n                i = random.randint(0,len(new_path)-3)\n                j = random.randint(i+2, len(new_path)-1)\n                if not is_edge_in_obstacle(new_path[i], new_path[j]):\n                    new_path = new_path[:i+1] + new_path[j:]\n                    attempts = 0\n                else:\n                    attempts +=1\n            return new_path\n\n        for it in range(self.max_iter):\n            sample_pos = sample()\n\n            if it % 2 == 0:\n                prop_tree, other_tree = start_tree, goal_tree\n            else:\n                prop_tree, other_tree = goal_tree, start_tree\n\n            nearest_node = nearest(prop_tree, sample_pos)\n            new_pos = steer(nearest_node.position, sample_pos)\n\n            if is_in_obstacle(new_pos):\n                continue\n            if is_edge_in_obstacle(nearest_node.position, new_pos):\n                continue\n\n            r = rewiring_radius(len(prop_tree))\n            near_nodes = near(prop_tree, new_pos, r)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for candidate in near_nodes:\n                if candidate is nearest_node:\n                    continue\n                tentative_cost = candidate.cost + dist(candidate.position, new_pos)\n                if tentative_cost < min_cost and not is_edge_in_obstacle(candidate.position, new_pos):\n                    min_cost = tentative_cost\n                    best_parent = candidate\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.add_child(new_node)\n            prop_tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors\n            for nbr in near_nodes:\n                if nbr is best_parent or nbr is new_node:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, nbr.position)\n                if new_cost < nbr.cost and not is_edge_in_obstacle(new_node.position, nbr.position):\n                    if nbr.parent:\n                        try:\n                            edges.remove((nbr.parent, nbr))\n                        except ValueError:\n                            pass\n                        nbr.parent.remove_child(nbr)\n                    nbr.parent = new_node\n                    nbr.cost = new_cost\n                    new_node.add_child(nbr)\n                    edges.append((new_node, nbr))\n\n            # Attempt connection to other tree\n            nearest_other = nearest(other_tree, new_pos)\n            dist_conn = dist(new_pos, nearest_other.position)\n            if dist_conn <= self.step_size and not is_edge_in_obstacle(new_pos, nearest_other.position):\n                total_cost = new_node.cost + dist_conn + nearest_other.cost\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    if it % 2 == 0:\n                        solution_nodes = (new_node, nearest_other)\n                    else:\n                        solution_nodes = (nearest_other, new_node)\n\n                    raw_path = extract_path(solution_nodes[0], solution_nodes[1])\n                    smoothed_path = incremental_shortcut(raw_path)\n                    if smoothed_path and len(smoothed_path) >= 2:\n                        return PlannerResult(True, smoothed_path, nodes, edges)\n\n        if solution_nodes[0] and solution_nodes[1]:\n            raw_path = extract_path(solution_nodes[0], solution_nodes[1])\n            smoothed_path = incremental_shortcut(raw_path)\n            return PlannerResult(True, smoothed_path, nodes, edges)\n        else:\n            return PlannerResult(False, [], nodes, edges)",
                "objective": -13.22857,
                "time_improvement": 51.0,
                "length_improvement": 12.0,
                "smoothness_improvement": 1545.0,
                "node_improvement": 71.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.023602938652038573,
                        "num_nodes_avg": 148.4,
                        "path_length_avg": 173.93453305857608,
                        "smoothness_avg": 0.046684993365167494,
                        "success_improvement": 0.0,
                        "time_improvement": 8.483145288399767,
                        "node_improvement": 62.62906069000251,
                        "length_improvement": 4.663726261542782,
                        "smoothness_improvement": 630.7215242505763,
                        "objective_score": 8.49678696469848
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.032700300216674805,
                        "num_nodes_avg": 301.6,
                        "path_length_avg": 241.7878757131836,
                        "smoothness_avg": 0.10230075379140147,
                        "success_improvement": 0.0,
                        "time_improvement": 80.25054328825179,
                        "node_improvement": 79.73526842706443,
                        "length_improvement": 19.284247608815647,
                        "smoothness_improvement": 2532.272079307376,
                        "objective_score": 48.307071948301804
                    },
                    {
                        "map_id": 2,
                        "success_rate": 0.9,
                        "time_avg": 0.018891048431396485,
                        "num_nodes_avg": 227.7,
                        "path_length_avg": 133.77213545637804,
                        "smoothness_avg": 0.12353301308846183,
                        "success_improvement": -9.999999999999998,
                        "time_improvement": 62.77419072948863,
                        "node_improvement": 71.04895104895105,
                        "length_improvement": 11.15491717443958,
                        "smoothness_improvement": 1471.3308082267,
                        "objective_score": -17.118138435356155
                    }
                ],
                "success_rate": 0.9666666666666667
            },
            {
                "operator": "e2",
                "algorithm_description": "A novel bidirectional Anytime Informed RRT* with density-adaptive rewiring radius and real-time incremental shortcutting. The algorithm progressively focuses sampling within an ellipsoidal informed set, adapts the rewiring radius based on current tree density for efficient local optimization, interleaves tree expansions with immediate neighbor rewiring to quickly improve path cost, and performs lightweight incremental shortcutting at regular intervals to continually smooth and shorten the path. This integrated approach improves planning efficiency, success rate, robustness, and path quality while minimizing runtime.",
                "planning_mechanism": "Two trees rooted at start and goal grow bidirectionally by sampling inside a shrinking ellipsoidal region defined by the current best path cost. The rewiring radius shrinks adaptively as the node density grows to balance exploration and local optimization. Each new node selects optimal parent and rewires neighbors with collision checks. On better solution discovery, paths are extracted and an incremental shortcutting procedure runs frequently to remove redundant waypoints, enhancing smoothness and length. This continuous integration enables the algorithm to quickly converge to high-quality paths.",
                "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except ValueError:\n            pass\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=6.5, gamma=40.0, shortcut_freq=30, max_shortcut_attempts=30):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.gamma = gamma\n        self.shortcut_freq = shortcut_freq\n        self.max_shortcut_attempts = max_shortcut_attempts\n\n    def plan(self, map):\n        import random\n        import math\n\n        bounds = map.size\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        obstacles = map.obstacles\n        start_pos = map.start\n        goal_pos = map.goal\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        best_cost = float('inf')\n        sol_start = None\n        sol_goal = None\n        c_min = math.dist(start_pos, goal_pos)\n        unit_ball_vol = self._unit_ball_volume(dim)\n\n        def near_radius(num_nodes):\n            if num_nodes <= 1:\n                return self.step_size * 3.0\n            r = self.gamma * (math.log(num_nodes) / num_nodes) ** (1.0 / dim)\n            return min(r, self.step_size * 45.0)\n\n        def sample_informed():\n            if best_cost == float('inf') or best_cost <= c_min:\n                return self._sample_free(bounds, obstacles, is_3d)\n            center = tuple((start_pos[i] + goal_pos[i]) * 0.5 for i in range(dim))\n            direction = [goal_pos[i] - start_pos[i] for i in range(dim)]\n            length = math.dist(start_pos, goal_pos)\n            if dim == 2:\n                if length < 1e-12:\n                    R = [[1, 0], [0, 1]]\n                else:\n                    a1 = [1, 0]\n                    a2 = [direction[0] / length, direction[1] / length]\n                    cos_theta = a1[0] * a2[0] + a1[1] * a2[1]\n                    sin_theta = a1[0] * a2[1] - a1[1] * a2[0]\n                    R = [[cos_theta, -sin_theta], [sin_theta, cos_theta]]\n            else:\n                from math import sqrt\n                if length < 1e-12:\n                    R = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n                else:\n                    a1 = [1, 0, 0]\n                    a2 = [direction[i] / length for i in range(3)]\n                    v = [a1[1] * a2[2] - a1[2] * a2[1],\n                         a1[2] * a2[0] - a1[0] * a2[2],\n                         a1[0] * a2[1] - a1[1] * a2[0]]\n                    s = sqrt(sum(vi * vi for vi in v))\n                    c = sum(a1[i] * a2[i] for i in range(3))\n                    if s < 1e-12:\n                        R = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n                    else:\n                        vx = [[0, -v[2], v[1]],\n                              [v[2], 0, -v[0]],\n                              [-v[1], v[0], 0]]\n                        I = [[1 if i == j else 0 for j in range(3)] for i in range(3)]\n                        vx2 = [[sum(vx[i][k] * vx[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n                        R = [[I[i][j] + vx[i][j] + vx2[i][j] * ((1 - c) / (s ** 2))\n                              for j in range(3)] for i in range(3)]\n\n            a1_val = best_cost * 0.5\n            a_other = math.sqrt(max(best_cost * best_cost - c_min * c_min, 0.0)) * 0.5\n            while True:\n                if dim == 2:\n                    r = random.uniform(0, 1) ** 0.5\n                    theta = random.uniform(0, 2 * math.pi)\n                    x_ball = [r * math.cos(theta), r * math.sin(theta)]\n                    L = [[a1_val, 0], [0, a_other]]\n                    x_scaled = [L[0][0] * x_ball[0] + L[0][1] * x_ball[1], L[1][0] * x_ball[0] + L[1][1] * x_ball[1]]\n                    pt = (center[0] + R[0][0] * x_scaled[0] + R[0][1] * x_scaled[1],\n                          center[1] + R[1][0] * x_scaled[0] + R[1][1] * x_scaled[1])\n                else:\n                    while True:\n                        x_ball = [random.uniform(-1, 1) for _ in range(3)]\n                        if sum(xi * xi for xi in x_ball) <= 1:\n                            break\n                    L = [[a1_val, 0, 0], [0, a_other, 0], [0, 0, a_other]]\n                    x_scaled = [L[0][0] * x_ball[0], L[1][1] * x_ball[1], L[2][2] * x_ball[2]]\n                    pt = tuple(center[i] + sum(R[i][j] * x_scaled[j] for j in range(dim)) for i in range(dim))\n                if any(pt[d] < 0 or pt[d] > bounds[d] for d in range(dim)):\n                    continue\n                if self._is_in_obstacle(pt, obstacles, is_3d):\n                    continue\n                return pt\n\n        def attempt_extend(tree_a, tree_b, sample):\n            nearest = self._nearest(tree_a, sample)\n            new_pos = self._steer(nearest.position, sample, self.step_size)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                return None\n\n            new_node = Node(new_pos)\n            radius = near_radius(len(tree_a))\n            near_nodes = self._near(tree_a, new_pos, radius)\n\n            min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n            min_parent = nearest\n            for near in near_nodes:\n                tentative_cost = near.cost + math.dist(near.position, new_pos)\n                if tentative_cost < min_cost:\n                    if not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d):\n                        min_cost = tentative_cost\n                        min_parent = near\n\n            new_node.parent = min_parent\n            new_node.cost = min_cost\n            min_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((min_parent, new_node))\n\n            # Rewire all neighbors except min_parent if it improves cost\n            for near in near_nodes:\n                if near is min_parent:\n                    continue\n                new_cost = new_node.cost + math.dist(new_node.position, near.position)\n                if new_cost < near.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                        if near.parent is not None:\n                            try:\n                                edges.remove((near.parent, near))\n                            except ValueError:\n                                pass\n                            near.parent.remove_child(near)\n                        near.parent = new_node\n                        near.cost = new_cost\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n\n            # Try connect to tree_b nearest node within step size\n            nearest_b = self._nearest(tree_b, new_node.position)\n            dist_connect = math.dist(new_node.position, nearest_b.position)\n            if dist_connect <= self.step_size:\n                if not self._is_edge_in_obstacle(new_node.position, nearest_b.position, obstacles, is_3d):\n                    total_cost = new_node.cost + dist_connect + nearest_b.cost\n                    return new_node, nearest_b, total_cost\n            return None\n\n        def incremental_shortcut(path):\n            if len(path) < 3:\n                return path[:]\n            import random\n            shortcut_path = path[:]\n            attempts = 0\n            while attempts < self.max_shortcut_attempts:\n                if len(shortcut_path) < 3:\n                    break\n                i = random.randint(0, len(shortcut_path) - 3)\n                j = random.randint(i + 2, len(shortcut_path) - 1)\n                if not self._is_edge_in_obstacle(shortcut_path[i], shortcut_path[j], obstacles, is_3d):\n                    shortcut_path = shortcut_path[:i + 1] + shortcut_path[j:]\n                    attempts = 0  # reset attempts on success\n                else:\n                    attempts += 1\n            return shortcut_path\n\n        for it in range(self.max_iter):\n            sample = sample_informed()\n            for (tree_a, tree_b) in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                res = attempt_extend(tree_a, tree_b, sample)\n                if res is not None:\n                    new_node, connect_node, cost_path = res\n                    if cost_path < best_cost:\n                        best_cost = cost_path\n                        if tree_a is start_tree:\n                            sol_start, sol_goal = new_node, connect_node\n                        else:\n                            sol_start, sol_goal = connect_node, new_node\n            if best_cost < float('inf') and sol_start is not None and sol_goal is not None:\n                if it % self.shortcut_freq == 0 or it == self.max_iter - 1:\n                    raw_path = self._extract_path(sol_start, sol_goal)\n                    improved_path = incremental_shortcut(raw_path)\n                    if improved_path and len(improved_path) >= 2:\n                        return PlannerResult(True, improved_path, nodes, edges)\n        return PlannerResult(False, [], nodes, edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        import random\n        while True:\n            pt = tuple(random.uniform(0, bounds[i]) for i in range(len(bounds)))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def _nearest(self, tree, point):\n        best = None\n        best_dist = float('inf')\n        for n in tree:\n            d = 0.0\n            for i in range(len(point)):\n                diff = n.position[i] - point[i]\n                d += diff * diff\n            if d < best_dist:\n                best_dist = d\n                best = n\n        return best\n\n    def _near(self, tree, point, radius):\n        r_sq = radius * radius\n        result = []\n        for n in tree:\n            d = 0.0\n            for i in range(len(point)):\n                diff = n.position[i] - point[i]\n                d += diff * diff\n            if d <= r_sq:\n                result.append(n)\n        return result\n\n    def _steer(self, from_pos, to_pos, step_size):\n        dist = 0.0\n        diff_vec = []\n        for i in range(len(from_pos)):\n            diff = to_pos[i] - from_pos[i]\n            diff_vec.append(diff)\n            dist += diff * diff\n        dist = dist ** 0.5\n        if dist <= step_size:\n            return to_pos\n        ratio = step_size / dist\n        new_pos = tuple(from_pos[i] + diff_vec[i] * ratio for i in range(len(from_pos)))\n        return new_pos\n\n    def _extract_path(self, node_start, node_goal):\n        path_start = []\n        n = node_start\n        while n is not None:\n            path_start.append(n.position)\n            n = n.parent\n        path_goal = []\n        n = node_goal\n        while n is not None:\n            path_goal.append(n.position)\n            n = n.parent\n        return list(reversed(path_start)) + path_goal\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        dist = 0.0\n        for i in range(len(from_pos)):\n            diff = to_pos[i] - from_pos[i]\n            dist += diff * diff\n        dist = dist ** 0.5\n        steps = max(1, int(dist / resolution))\n        for step in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (step / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _unit_ball_volume(self, dim):\n        import math\n        if dim == 2:\n            return math.pi\n        if dim == 3:\n            return 4.0 / 3.0 * math.pi\n        from math import gamma, pi\n        return (pi ** (dim / 2)) / gamma(dim / 2 + 1)",
                "objective": -29.43149,
                "time_improvement": 46.0,
                "length_improvement": 15.0,
                "smoothness_improvement": 1325.0,
                "node_improvement": 72.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.025296664237976073,
                        "num_nodes_avg": 157.7,
                        "path_length_avg": 169.82640352208247,
                        "smoothness_avg": 0.034435143239248046,
                        "success_improvement": 0.0,
                        "time_improvement": 1.9159783497959368,
                        "node_improvement": 60.28708133971292,
                        "length_improvement": 6.915457157973212,
                        "smoothness_improvement": 438.98476880462505,
                        "objective_score": 6.918991643745834
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.026137399673461913,
                        "num_nodes_avg": 228.4,
                        "path_length_avg": 237.06092208208943,
                        "smoothness_avg": 0.09896313272769311,
                        "success_improvement": 0.0,
                        "time_improvement": 84.21422922761201,
                        "node_improvement": 84.65363166028354,
                        "length_improvement": 20.862240788691224,
                        "smoothness_improvement": 2446.3926853468774,
                        "objective_score": 50.01357666823272
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.02440671920776367,
                        "num_nodes_avg": 220.1,
                        "path_length_avg": 124.62874035050683,
                        "smoothness_avg": 0.09361395032374312,
                        "success_improvement": 0.0,
                        "time_improvement": 51.90526997765084,
                        "node_improvement": 72.01525746980292,
                        "length_improvement": 17.227524842071908,
                        "smoothness_improvement": 1090.7625382549713,
                        "objective_score": 31.361908589813254
                    }
                ],
                "success_rate": 1.0
            }
        ],
        "offspring": {
            "operator": "m2",
            "algorithm_description": "A novel bidirectional RRT* variant with adaptive sampling blending uniform and ellipsoidal informed distributions, dynamically tuned rewiring radius based on observed path quality and node density, and an integrated multi-level shortcutting strategy applying frequent lightweight and occasional global path smoothing to improve convergence speed, path optimality, and smoothness. The trees grow alternately towards adaptively sampled points; neighbors are rewired within a density-dependent radius to balance exploration and exploitation, while connection attempts leverage dynamic distance thresholds. Incremental shortcutting is applied after each path improvement, supplemented by a sparser global smoothing step to remove residual jaggedness and lower cost. This comprehensive adaptive approach enhances planning efficiency, success rate, path length, and smoothness while responding to the evolving search landscape.",
            "planning_mechanism": "The planner maintains two growing trees from start and goal positions. Sampling alternates between uniform free-space sampling and ellipsoidal informed sampling based on current best path cost. Each iteration extends a selected tree toward the sampled point with step size control, rewires neighbors within an adaptively computed radius to optimize path cost, and attempts connection with the opposite tree using a distance threshold that adapts with node density and best cost. Whenever a better path is found, incremental shortcutting immediately reduces length and jaggedness, and periodically a more global smoothing pass applies. Efficient collision checks ensure collision-free expansions, and dynamic parameter tuning balances exploration-exploitation trade-offs in real time, accelerating convergence to a short, smooth path efficiently.",
            "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except ValueError:\n            pass\nclass Planner:\n    def __init__(self, max_iter=6000, step_size=6.0, goal_sample_rate=0.08,\n                 shortcut_attempts=30, global_smooth_freq=250, uniform_sample_rate=0.3,\n                 r_min=5.0, r_max=35.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.shortcut_attempts = shortcut_attempts\n        self.global_smooth_freq = global_smooth_freq\n        self.uniform_sample_rate = uniform_sample_rate\n        self.r_min = r_min\n        self.r_max = r_max\n\n    def plan(self, map):\n        import math\n        import random\n\n        bounds = map.size\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        obstacles = map.obstacles\n        start_pos = map.start\n        goal_pos = map.goal\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        best_cost = float('inf')\n        solution_nodes = (None, None)\n        improved_since_last_global_smooth = False\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def is_in_obstacle(pos):\n            px = pos[0]\n            py = pos[1]\n            pz = pos[2] if is_3d else 0.0\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(a, b, resolution=0.5):\n            dist_ab = dist(a, b)\n            steps = max(1, int(dist_ab / resolution))\n            for i in range(steps + 1):\n                t = i / steps\n                interm = tuple(a[j] + t * (b[j] - a[j]) for j in range(dim))\n                if is_in_obstacle(interm):\n                    return True\n            return False\n\n        def nearest(tree, point):\n            best = None\n            best_d = float('inf')\n            for n in tree:\n                d_n = dist(n.position, point)\n                if d_n < best_d:\n                    best = n\n                    best_d = d_n\n            return best\n\n        def near(tree, point, radius):\n            r_sq = radius * radius\n            res = []\n            for n in tree:\n                d_sq = 0.0\n                for i in range(dim):\n                    diff = n.position[i] - point[i]\n                    d_sq += diff * diff\n                if d_sq <= r_sq:\n                    res.append(n)\n            return res\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            ratio = self.step_size / d\n            return tuple(from_pos[i] + ratio * (to_pos[i] - from_pos[i]) for i in range(dim))\n\n        def compute_ellipsoid_params():\n            c_min = dist(start_pos, goal_pos)\n            if c_min < 1e-14:\n                return None\n            center = tuple((start_pos[i] + goal_pos[i]) * 0.5 for i in range(dim))\n            direction = [goal_pos[i] - start_pos[i] for i in range(dim)]\n            length = c_min\n            e1 = [d / length for d in direction]\n            if dim == 2:\n                e2 = (-e1[1], e1[0])\n                basis = [e1, e2]\n            else:\n                v = [1, 0, 0] if abs(e1[0]) < 0.9 else [0, 1, 0]\n                for i in range(dim):\n                    proj = sum(v[j] * e1[j] for j in range(dim))\n                    v[i] = v[i] - proj * e1[i]\n                norm_v = math.sqrt(sum(x * x for x in v))\n                if norm_v < 1e-15:\n                    v = [0.0] * dim\n                    v[-1] = 1.0\n                    norm_v = 1.0\n                u = [x / norm_v for x in v]\n                # cross product for 3D only\n                if dim == 3:\n                    w = [e1[1] * u[2] - e1[2] * u[1],\n                         e1[2] * u[0] - e1[0] * u[2],\n                         e1[0] * u[1] - e1[1] * u[0]]\n                    basis = [e1, u, w]\n                else:\n                    basis = [e1, u]\n\n            a1 = best_cost * 0.5\n            b_sq = max(best_cost * best_cost - c_min * c_min, 1e-12) * 0.25\n            b = math.sqrt(b_sq)\n            return center, basis, a1, b\n\n        def sample():\n            if best_cost == float('inf'):\n                # Pure uniform sampling with goal bias and obstacle avoidance\n                while True:\n                    if random.random() < self.goal_sample_rate:\n                        pt = goal_pos\n                    else:\n                        pt = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                    if not is_in_obstacle(pt):\n                        return pt\n            # Blend uniform and ellipsoidal informed sampling\n            if random.random() < self.uniform_sample_rate:\n                # uniform free-space sampling with goal bias\n                if random.random() < self.goal_sample_rate:\n                    pt = goal_pos\n                else:\n                    while True:\n                        pt = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                        if not is_in_obstacle(pt):\n                            break\n                return pt\n            # ellipsoidal informed sample\n            params = compute_ellipsoid_params()\n            if params is None:\n                # fallback\n                while True:\n                    pt = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                    if not is_in_obstacle(pt):\n                        return pt\n            center, basis, a1, b = params\n            while True:\n                if dim == 2:\n                    r = random.uniform(0, 1) ** 0.5\n                    theta = random.uniform(0, 2 * math.pi)\n                    u_ball = [r * math.cos(theta), r * math.sin(theta)]\n                    coords = [a1 * u_ball[0], b * u_ball[1]]\n                    pt = tuple(center[i] + sum(coords[j] * basis[j][i] for j in range(dim)) for i in range(dim))\n                else:\n                    while True:\n                        u_ball = [random.uniform(-1, 1) for _ in range(3)]\n                        norm_sq = sum(x * x for x in u_ball)\n                        if 0 < norm_sq <= 1:\n                            break\n                    norm = math.sqrt(norm_sq)\n                    unit_ball = [x / norm for x in u_ball]\n                    coords = [a1 * unit_ball[0], b * unit_ball[1], b * unit_ball[2]]\n                    pt = tuple(center[i] + sum(coords[j] * basis[j][i] for j in range(dim)) for i in range(dim))\n                if any(pt[d] < 0 or pt[d] > bounds[d] for d in range(dim)):\n                    continue\n                if is_in_obstacle(pt):\n                    continue\n                return pt\n\n        def rewiring_radius(n_nodes):\n            if n_nodes < 2:\n                return self.r_max\n            # Adapt radius with dependency on best_cost and density for balanced rewiring\n            base = 2 * ((math.log(n_nodes) / n_nodes) ** (1 / dim)) * self.step_size\n            ratio = 1.0\n            # Shrink rewiring radius when cost is good\n            if best_cost < float('inf') and best_cost > 0:\n                ratio = max(0.3, min(1.0, (best_cost / (dist(start_pos, goal_pos) * 3))))\n            radius = base * ratio\n            return max(self.r_min, min(self.r_max, radius))\n\n        def extract_path(node_a, node_b):\n            path_a = []\n            cur = node_a\n            while cur is not None:\n                path_a.append(cur.position)\n                cur = cur.parent\n            path_b = []\n            cur = node_b\n            while cur is not None:\n                path_b.append(cur.position)\n                cur = cur.parent\n            return path_a[::-1] + path_b\n\n        def incremental_shortcut(path):\n            if len(path) < 3:\n                return path[:]\n            new_path = path[:]\n            attempts = 0\n            while attempts < self.shortcut_attempts:\n                if len(new_path) < 3:\n                    break\n                i = random.randint(0, len(new_path) - 3)\n                j = random.randint(i + 2, len(new_path) - 1)\n                if not is_edge_in_obstacle(new_path[i], new_path[j]):\n                    new_path = new_path[:i + 1] + new_path[j:]\n                    attempts = 0\n                else:\n                    attempts += 1\n            return new_path\n\n        def global_smooth(path):\n            # Apply a simple global smoothing by shortcutting multiple times with increasing segment length\n            smoothed = path[:]\n            n = len(smoothed)\n            if n < 3:\n                return smoothed\n            max_segments = min(20, n//3)\n            for seg in range(max_segments, 1, -1):\n                i = 0\n                while i + seg < len(smoothed):\n                    if not is_edge_in_obstacle(smoothed[i], smoothed[i + seg]):\n                        smoothed = smoothed[:i + 1] + smoothed[i + seg:]\n                        # After shortcut, restart checking to capture further smooths\n                        i = 0\n                    else:\n                        i += 1\n            return smoothed\n\n        for it in range(self.max_iter):\n            sample_pos = sample()\n            tree_to_extend, opposite_tree = (start_tree, goal_tree) if it % 2 == 0 else (goal_tree, start_tree)\n\n            nearest_node = nearest(tree_to_extend, sample_pos)\n            new_pos = steer(nearest_node.position, sample_pos)\n\n            if is_in_obstacle(new_pos):\n                continue\n            if is_edge_in_obstacle(nearest_node.position, new_pos):\n                continue\n\n            radius = rewiring_radius(len(tree_to_extend))\n            near_nodes = near(tree_to_extend, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for candidate in near_nodes:\n                if candidate is nearest_node:\n                    continue\n                tentative_cost = candidate.cost + dist(candidate.position, new_pos)\n                if tentative_cost < min_cost and not is_edge_in_obstacle(candidate.position, new_pos):\n                    min_cost = tentative_cost\n                    best_parent = candidate\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree_to_extend.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors if cost improved and collision free\n            for nbr in near_nodes:\n                if nbr is best_parent or nbr is new_node:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, nbr.position)\n                if new_cost < nbr.cost and not is_edge_in_obstacle(new_node.position, nbr.position):\n                    if nbr.parent is not None:\n                        try:\n                            edges.remove((nbr.parent, nbr))\n                        except ValueError:\n                            pass\n                        nbr.parent.remove_child(nbr)\n                    nbr.parent = new_node\n                    nbr.cost = new_cost\n                    new_node.add_child(nbr)\n                    edges.append((new_node, nbr))\n\n            nearest_other = nearest(opposite_tree, new_pos)\n            dist_connect = dist(new_pos, nearest_other.position)\n            # Adapt connection threshold to min(step_size * 1.5, rewiring radius)\n            connect_thresh = min(self.step_size * 1.5, rewiring_radius(len(tree_to_extend)))\n            if dist_connect <= connect_thresh and not is_edge_in_obstacle(new_pos, nearest_other.position):\n                total_cost = new_node.cost + dist_connect + nearest_other.cost\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    solution_nodes = (new_node, nearest_other) if it % 2 == 0 else (nearest_other, new_node)\n                    raw_path = extract_path(solution_nodes[0], solution_nodes[1])\n                    smoothed_path = incremental_shortcut(raw_path)\n                    nodes_clear = len(smoothed_path)\n                    improved_since_last_global_smooth = True\n                    # Whenever better path found, return smoothed path immediately (anytime behavior)\n                    if smoothed_path and len(smoothed_path) >= 2:\n                        # Periodically apply global smoothing too\n                        if it % self.global_smooth_freq == 0:\n                            smoothed_path = global_smooth(smoothed_path)\n                        return PlannerResult(True, smoothed_path, nodes, edges)\n\n            # Periodic global smoothing on existing best path\n            if improved_since_last_global_smooth and it % self.global_smooth_freq == 0 and best_cost < float('inf'):\n                raw_path = extract_path(solution_nodes[0], solution_nodes[1])\n                smoothed_path = global_smooth(raw_path)\n                if smoothed_path and len(smoothed_path) >= 2:\n                    improved_since_last_global_smooth = False\n                    return PlannerResult(True, smoothed_path, nodes, edges)\n\n        # If terminate with solution found\n        if solution_nodes[0] is not None and solution_nodes[1] is not None:\n            raw_path = extract_path(solution_nodes[0], solution_nodes[1])\n            smoothed_path = incremental_shortcut(raw_path)\n            smoothed_path = global_smooth(smoothed_path)\n            return PlannerResult(True, smoothed_path, nodes, edges)\n\n        return PlannerResult(False, [], nodes, edges)",
            "objective": -31.45446,
            "time_improvement": 60.0,
            "length_improvement": 12.0,
            "smoothness_improvement": 1289.0,
            "node_improvement": 74.0,
            "other_inf": [
                {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.019103193283081056,
                    "num_nodes_avg": 130.0,
                    "path_length_avg": 173.3649996406287,
                    "smoothness_avg": 0.03905650881261121,
                    "success_improvement": 0.0,
                    "time_improvement": 25.93023309560016,
                    "node_improvement": 67.26265424326367,
                    "length_improvement": 4.975896552754276,
                    "smoothness_improvement": 511.3191754837242,
                    "objective_score": 13.321203737751233
                },
                {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.022163128852844237,
                    "num_nodes_avg": 240.8,
                    "path_length_avg": 245.67296527562377,
                    "smoothness_avg": 0.08351123895740013,
                    "success_improvement": 0.0,
                    "time_improvement": 86.6145035068227,
                    "node_improvement": 83.8204663038366,
                    "length_improvement": 17.987292886770433,
                    "smoothness_improvement": 2048.8043290880164,
                    "objective_score": 47.020748429549144
                },
                {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.017162418365478514,
                    "num_nodes_avg": 224.0,
                    "path_length_avg": 131.41011815324833,
                    "smoothness_avg": 0.11058336040285022,
                    "success_improvement": 0.0,
                    "time_improvement": 66.18054762740364,
                    "node_improvement": 71.51938970120788,
                    "length_improvement": 12.723656600001021,
                    "smoothness_improvement": 1306.6121819096536,
                    "objective_score": 34.02141915776997
                }
            ],
            "success_rate": 1.0
        },
        "objective": 32.4,
        "analysis": {
            "problem": [
                "Problem of the parents algorithm:\n   - Nearest and near neighbor searches performed with linear scans causing slow planning as tree size grows.\n   - Rewiring radius and connection thresholds were static or not adaptively tuned, limiting efficient rewiring.\n   - Sampling was either purely uniform or informed but not adaptively blended, reducing sampling efficiency.\n   - Shortcutting was limited to incremental local attempts with no global smoothing, resulting in less smooth paths.\n   - Early stopping or infrequent smoothing reduced path refinement speed."
            ],
            "solution": "1. Primary contributors to the performance improvement:\n   - Introduction of adaptive rewiring radius tuned by both node density and current best path quality.\n   - Hybrid sampling strategy blending uniform and ellipsoidal informed techniques for better exploration and exploitation balance.\n   - Incorporation of an anytime incremental shortcutting combined with periodic global smoothing for enhanced path smoothness.\n   - Dynamic adjustment of connection thresholds based on rewiring radius improving tree connection efficiency.\n2. Expected mechanism of impact:\n   - Adaptive rewiring reduces unnecessary costly operations while improving path optimality by focusing rewiring efforts where beneficial.\n   - Blended sampling accelerates convergence by concentrating samples in promising regions without losing global coverage.\n   - Combined shortcutting strategies significantly reduce path jaggedness and length more effectively than local shortcuts alone.\n   - Improved connection distance thresholds increase the chance of bridging trees earlier, reducing planning time and path cost."
        }
    },
    {
        "parents": [
            {
                "operator": "m1",
                "algorithm_description": "A novel bidirectional RRT* variant with adaptive, density- and cost-aware rewiring radius, hybrid blended sampling (uniform plus ellipsoidal informed weighted randomly), accelerated nearest neighbor search via dynamic grid hashing, and a two-tier shortcutting strategy combining quick curvature-aware local shortcuts with periodical global spline-like smoothing. This planner aggressively prunes with early-exit collision checks, dynamically tunes connection thresholds, alternates tree expansions, and maintains path updates upon connections to achieve faster convergence, shorter smoother paths, and robust planning.",
                "planning_mechanism": "The planner grows forward and backward trees alternately using a hybrid sampling mechanism mixing uniform and ellipsoidal informed sampling proportional to progress. Adaptive rewiring radius depends on both node density and currently best path cost. A spatial grid hash accelerates nearest neighbor and near-node retrieval with limited grid cell expansion search. Rewiring considers curvature penalties to avoid sharp turns. Path extraction merges trees upon connections. Shortcutting first quickly attempts multiple curvature-preserving skips then applies global smoothing every fixed iterations, refining path smoothness without excessive collision checking overhead. Early exits in collision detection and incremental cost updates improve planning efficiency and robustness.",
                "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n    def add_child(self, child):\n        self.children.append(child)\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\nclass Planner:\n    def __init__(self, max_iter=4000, step_size=5.0, base_radius=20.0,\n                 blend_sample_rate=0.7, shortcut_local_interval=15, shortcut_global_interval=60,\n                 max_local_shortcuts=50, curvature_threshold=0.4):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.base_radius = base_radius\n        self.blend_sample_rate = blend_sample_rate\n        self.shortcut_local_interval = shortcut_local_interval\n        self.shortcut_global_interval = shortcut_global_interval\n        self.max_local_shortcuts = max_local_shortcuts\n        self.curvature_threshold = curvature_threshold\n\n    def plan(self, map):\n        import random\n        import math\n\n        bounds = map.size\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        def in_bounds(p):\n            return all(0.0 <= p[i] <= bounds[i] for i in range(dim))\n\n        def collision_node(p):\n            px = p[0]\n            py = p[1]\n            pz = p[2] if is_3d else 0.0\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d = obs\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                        return True\n                else:\n                    x,y,w,h = obs\n                    if x <= px <= x+w and y <= py <= y+h:\n                        return True\n            return False\n\n        def collision_edge(a,b,res=0.5):\n            length = math.dist(a,b)\n            steps = max(1,int(length/res))\n            for step in range(steps+1):\n                t = step / steps\n                interp = tuple(a[i] + (b[i]-a[i])*t for i in range(dim))\n                if collision_node(interp):\n                    return True\n            return False\n\n        def steer(from_p, to_p):\n            length = math.dist(from_p,to_p)\n            if length <= self.step_size:\n                return to_p\n            ratio = self.step_size / length\n            return tuple(from_p[i] + (to_p[i] - from_p[i]) * ratio for i in range(dim))\n\n        # Spatial grid hashing for fast neighbor queries\n        GRID_SIZE = self.step_size * 3.0\n        def grid_hash(p):\n            return tuple(int(p[i]/GRID_SIZE) for i in range(dim))\n\n        # Hash tables storing Nodes\n        start_hash, goal_hash = {}, {}\n        def add_to_hash(ht, node):\n            h = grid_hash(node.position)\n            if h not in ht:\n                ht[h] = []\n            ht[h].append(node)\n        def remove_from_hash(ht, node):\n            h = grid_hash(node.position)\n            if h in ht and node in ht[h]:\n                ht[h].remove(node)\n                if not ht[h]:\n                    del ht[h]\n\n        def nearby_nodes(ht, p, radius):\n            radius_sq = radius*radius\n            gh = grid_hash(p)\n            shifts = [-1,0,1]\n            neighbors = []\n            if dim==2:\n                cells = [(gh[0]+dx,gh[1]+dy) for dx in shifts for dy in shifts]\n            else:\n                cells = [(gh[0]+dx,gh[1]+dy,gh[2]+dz) for dx in shifts for dy in shifts for dz in shifts]\n            candidates = []\n            for c in cells:\n                if c in ht:\n                    candidates.extend(ht[c])\n            for node in candidates:\n                d_sq = 0.0\n                for i in range(dim):\n                    diff = node.position[i] - p[i]\n                    d_sq += diff*diff\n                    if d_sq > radius_sq:\n                        break\n                if d_sq <= radius_sq:\n                    neighbors.append(node)\n            return neighbors\n\n        def nearest(ht, p):\n            gh = grid_hash(p)\n            min_node = None\n            min_dist_sq = float('inf')\n            expansions = 0\n            max_expansions = 2\n            while expansions <= max_expansions:\n                # Enumerate neighboring cells within expansions radius\n                if dim == 2:\n                    cells = [(gh[0]+dx, gh[1]+dy) for dx in range(-expansions,expansions+1) for dy in range(-expansions,expansions+1)]\n                else:\n                    cells = [(gh[0]+dx, gh[1]+dy, gh[2]+dz) for dx in range(-expansions,expansions+1) for dy in range(-expansions,expansions+1) for dz in range(-expansions,expansions+1)]\n                candidates = []\n                for c in cells:\n                    if c in ht:\n                        candidates.extend(ht[c])\n                for node in candidates:\n                    d_sq = 0.0\n                    for i in range(dim):\n                        diff = node.position[i] - p[i]\n                        d_sq += diff*diff\n                        if d_sq >= min_dist_sq:\n                            break\n                    else:\n                        if d_sq < min_dist_sq:\n                            min_dist_sq = d_sq\n                            min_node = node\n                if min_node is not None or expansions == max_expansions:\n                    break\n                expansions +=1\n            # fallback linear search\n            if min_node is None:\n                all_nodes = []\n                for cell_nodes in ht.values():\n                    all_nodes.extend(cell_nodes)\n                if all_nodes:\n                    min_node = min(all_nodes, key=lambda n: math.dist(n.position,p))\n            return min_node\n\n        def unit_ball_volume(d):\n            from math import pi, gamma\n            return (pi**(d/2))/(gamma(d/2+1))\n\n        c_min = math.dist(start_pos, goal_pos)\n        volume_unit_ball = unit_ball_volume(dim)\n\n        def adaptive_radius(n_nodes, best_cost):\n            if n_nodes <= 1:\n                return self.step_size * 5.0\n            val = (math.log(n_nodes)/n_nodes)**(1.0/dim)\n            radius = self.base_radius * val\n            # Shrink according to current best solution to encourage local rewire\n            if best_cost < float('inf'):\n                radius = min(radius, best_cost*0.3)\n            radius = max(radius, self.step_size*1.2)\n            return radius\n\n        def angle_between(a,b,c):\n            # angle at b between points a-b-c\n            ab = [a[i]-b[i] for i in range(dim)]\n            cb = [c[i]-b[i] for i in range(dim)]\n            lab = math.sqrt(sum(x*x for x in ab))\n            lcb = math.sqrt(sum(x*x for x in cb))\n            if lab < 1e-14 or lcb < 1e-14:\n                return 0.0\n            dot = sum(ab[i]*cb[i] for i in range(dim))\n            val = max(min(dot/(lab*lcb),1.0),-1.0)\n            return math.acos(val)\n\n        def curvature_penalty(parent, child_pos):\n            if parent is None or parent.parent is None:\n                return 0.0\n            v1 = [parent.position[i]-parent.parent.position[i] for i in range(dim)]\n            v2 = [child_pos[i]-parent.position[i] for i in range(dim)]\n            len1 = math.sqrt(sum(x*x for x in v1))\n            len2 = math.sqrt(sum(x*x for x in v2))\n            if len1 < 1e-9 or len2 < 1e-9:\n                return 0.0\n            dot = sum(v1[i]*v2[i] for i in range(dim))\n            cos_ang = max(min(dot/(len1*len2),1.0),-1.0)\n            penalty = (1.0 - cos_ang)*1.0\n            return penalty\n\n        def path_cost(parent, child_pos):\n            linear_cost = parent.cost + math.dist(parent.position, child_pos)\n            pen = curvature_penalty(parent, child_pos)\n            return linear_cost + pen\n\n        def rewire(tree_hash, new_node, near_nodes):\n            # Attempt to rewire near_nodes through new_node for better cost and curvature\n            for n in near_nodes:\n                if n is new_node.parent:\n                    continue\n                c_cost = path_cost(new_node, n.position)\n                if c_cost + 1e-10 < n.cost:\n                    if not collision_edge(new_node.position, n.position):\n                        # Check curvature increase from n's parent perspective\n                        if n.children:\n                            ang_before = angle_between(n.parent.parent.position if n.parent.parent else n.parent.position,\n                                                     n.parent.position, n.position)\n                            ang_after = angle_between(n.parent.position, new_node.position, n.position)\n                        else:\n                            ang_before = 0.0\n                            ang_after = 0.0\n                        if ang_after < ang_before + self.curvature_threshold:\n                            # Rewire\n                            if n.parent:\n                                n.parent.remove_child(n)\n                            n.parent = new_node\n                            n.cost = c_cost\n                            new_node.add_child(n)\n                            self._propagate_costs(n)\n\n        def propagate_costs(node):\n            import math\n            stack = [node]\n            while stack:\n                n = stack.pop()\n                for c in n.children:\n                    new_cost = n.cost + math.dist(n.position, c.position) + curvature_penalty(n, c.position)\n                    if new_cost + 1e-12 < c.cost:\n                        c.cost = new_cost\n                        stack.append(c)\n\n        self._propagate_costs = propagate_costs\n\n        def extract_path(node_start, node_goal):\n            path_start = []\n            n = node_start\n            while n:\n                path_start.append(n.position)\n                n = n.parent\n            path_start.reverse()\n            path_goal = []\n            n = node_goal\n            while n:\n                path_goal.append(n.position)\n                n = n.parent\n            if path_start[-1] == path_goal[0]:\n                return path_start + path_goal[1:]\n            else:\n                return path_start + path_goal\n\n        def hybrid_sample(best_cost):\n            # With probability blend_sample_rate do ellipsoidal informed sampling, else uniform\n            if best_cost == float('inf') or random.random() > self.blend_sample_rate:\n                # Uniform sample\n                for _ in range(30):\n                    pt = tuple(random.uniform(0,bounds[i]) for i in range(dim))\n                    if not collision_node(pt):\n                        return pt\n                # fallback uniform anyway\n                return tuple(random.uniform(0,bounds[i]) for i in range(dim))\n            # Informed sample inside ellipsoid defined by start and goal, scaled by best_cost\n            center = tuple(0.5*(start_pos[i]+goal_pos[i]) for i in range(dim))\n            d_vec = [goal_pos[i]-start_pos[i] for i in range(dim)]\n            length = math.dist(start_pos, goal_pos)\n            a1_val = best_cost*0.5\n            try:\n                term = best_cost*best_cost - c_min*c_min\n                a_rest = math.sqrt(term)*0.5 if term > 0 else 0.0\n            except Exception:\n                a_rest = 0.0\n\n            if dim == 2:\n                if length < 1e-14:\n                    R = [[1,0],[0,1]]\n                else:\n                    norm_d = (d_vec[0]/length, d_vec[1]/length)\n                    c = norm_d[0]\n                    s = norm_d[1]\n                    R = [[c, -s],[s, c]]\n                attempts = 0\n                while attempts < 100:\n                    r = random.uniform(0,1)**0.5\n                    theta = random.uniform(0,2*math.pi)\n                    ball = [r*math.cos(theta), r*math.sin(theta)]\n                    x_scaled = [a1_val*ball[0], a_rest*ball[1]]\n                    pt = (center[0] + R[0][0]*x_scaled[0] + R[0][1]*x_scaled[1],\n                          center[1] + R[1][0]*x_scaled[0] + R[1][1]*x_scaled[1])\n                    if in_bounds(pt) and not collision_node(pt):\n                        return pt\n                    attempts += 1\n                # fallback to uniform\n                return tuple(random.uniform(0,bounds[i]) for i in range(dim))\n            else:\n                # 3D rotation matrix from x-axis to d_vec via Rodrigues' formula\n                from math import sqrt\n                if length < 1e-14:\n                    R = [[1,0,0],[0,1,0],[0,0,1]]\n                else:\n                    a1 = [1,0,0]\n                    a2 = [d_vec[i]/length for i in range(3)]\n                    v = [a1[1]*a2[2]-a1[2]*a2[1], a1[2]*a2[0]-a1[0]*a2[2], a1[0]*a2[1]-a1[1]*a2[0]]\n                    s = sqrt(sum(x*x for x in v))\n                    c = sum(a1[i]*a2[i] for i in range(3))\n                    if s < 1e-14:\n                        R = [[1,0,0],[0,1,0],[0,0,1]]\n                    else:\n                        vx = [[0,-v[2],v[1]], [v[2],0,-v[0]], [-v[1],v[0],0]]\n                        I = [[1 if i==j else 0 for j in range(3)] for i in range(3)]\n                        vx2 = [[sum(vx[i][k]*vx[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n                        R = [[I[i][j] + vx[i][j] + vx2[i][j]*((1-c)/(s*s)) for j in range(3)] for i in range(3)]\n                attempts = 0\n                while attempts < 100:\n                    # sample uniformly in unit ball\n                    while True:\n                        ball = [random.uniform(-1,1) for _ in range(3)]\n                        if sum(x*x for x in ball) <= 1:\n                            break\n                    x_scaled = [a1_val*ball[0], a_rest*ball[1], a_rest*ball[2]]\n                    pt = tuple(center[i] + sum(R[i][j]*x_scaled[j] for j in range(3)) for i in range(3))\n                    if in_bounds(pt) and not collision_node(pt):\n                        return pt\n                    attempts += 1\n                return tuple(random.uniform(0,bounds[i]) for i in range(dim))\n\n        def attempt_connection(tree_a, tree_hash_a, tree_b, tree_hash_b, sample, best_cost):\n            nearest_node = nearest(tree_hash_a, sample)\n            if nearest_node is None:\n                return None\n            new_pos = steer(nearest_node.position, sample)\n\n            if not in_bounds(new_pos) or collision_node(new_pos) or collision_edge(nearest_node.position, new_pos):\n                return None\n\n            radius = adaptive_radius(len(tree_a), best_cost)\n            near_nodes = nearby_nodes(tree_hash_a, new_pos, radius)\n\n            min_cost = path_cost(nearest_node, new_pos)\n            min_parent = nearest_node\n            # Approximate k-nearest rewiring with early exits for efficiency\n            for near in near_nodes:\n                if near is nearest_node:\n                    continue\n                c = path_cost(near, new_pos)\n                if c < min_cost:\n                    if not collision_edge(near.position, new_pos):\n                        min_cost = c\n                        min_parent = near\n\n            new_node = Node(new_pos, min_parent, min_cost)\n            min_parent.add_child(new_node)\n            tree_a.append(new_node)\n            add_to_hash(tree_hash_a, new_node)\n\n            # Rewire nearby nodes for better costs preserving curvature smoothness\n            rewire(tree_hash_a, new_node, near_nodes)\n\n            # Attempt connection to other tree within step_size\n            other_nearest = nearest(tree_hash_b, new_node.position)\n            if other_nearest and math.dist(other_nearest.position, new_node.position) <= self.step_size:\n                if not collision_edge(other_nearest.position, new_node.position):\n                    total_cost = new_node.cost + math.dist(other_nearest.position, new_node.position) + other_nearest.cost\n                    return (new_node, other_nearest, total_cost)\n            return None\n\n        def quick_local_shortcut(path):\n            # Attempt multiple quick curvature-preserving shortcut attempts\n            if len(path) < 3:\n                return path[:]\n            new_path = path[:]\n            attempts = 0\n            max_attempts = self.max_local_shortcuts\n            while attempts < max_attempts and len(new_path) >= 3:\n                i = random.randint(0, len(new_path)-3)\n                j = random.randint(i+2, len(new_path)-1)\n                if not collision_edge(new_path[i], new_path[j]):\n                    # Curvature check at (i-1, i, j) and (i, j, j+1)\n                    valid = True\n                    if i > 0 and j < len(new_path)-1:\n                        ang_before = angle_between(new_path[i-1], new_path[i], new_path[i+1] if i+1 < len(new_path) else new_path[i])\n                        ang_after = angle_between(new_path[i-1], new_path[i], new_path[j])\n                        ang_after2 = angle_between(new_path[i], new_path[j], new_path[j+1])\n                        if ang_after > ang_before + self.curvature_threshold or ang_after2 > self.curvature_threshold+0.3:\n                            valid = False\n                    if valid:\n                        del new_path[i+1:j]\n                        attempts += 1\n                    else:\n                        attempts += 1\n                else:\n                    attempts += 1\n            return new_path\n\n        def global_smooth(path):\n            # Midpoint smoothing with collision and curvature checks for improved smoothness\n            if len(path) < 4:\n                return path[:]\n            new_path = path[:]\n            changed = False\n            for idx in range(1, len(path)-1):\n                a = new_path[idx-1]\n                b = new_path[idx]\n                c = new_path[idx+1]\n                midpoint = tuple(0.5*(a[i]+c[i]) for i in range(dim))\n                if (not collision_node(midpoint) and not collision_edge(a, midpoint) and not collision_edge(midpoint, c)):\n                    ang_old = angle_between(a,b,c)\n                    ang_new = angle_between(a, midpoint, c)\n                    if ang_new < ang_old + 1e-6:\n                        new_path[idx] = midpoint\n                        changed = True\n            return new_path if changed else path\n\n        # Initialize trees\n        start_tree = [Node(start_pos, None, 0.0)]\n        goal_tree = [Node(goal_pos, None, 0.0)]\n        nodes = start_tree + goal_tree\n        edges = []\n        add_to_hash(start_hash,start_tree[0])\n        add_to_hash(goal_hash,goal_tree[0])\n\n        best_cost = float('inf')\n        best_sol_start = None\n        best_sol_goal = None\n\n        for it in range(1, self.max_iter+1):\n            sample = hybrid_sample(best_cost)\n\n            # Alternate tree expansions\n            for tree_a, hash_a, tree_b, hash_b in [(start_tree, start_hash, goal_tree, goal_hash),\n                                                   (goal_tree, goal_hash, start_tree, start_hash)]:\n                res = attempt_connection(tree_a, hash_a, tree_b, hash_b, sample, best_cost)\n                if res:\n                    new_node, conn_node, cost_candidate = res\n                    if cost_candidate + 1e-15 < best_cost:\n                        best_cost = cost_candidate\n                        best_sol_start, best_sol_goal = (new_node, conn_node) if tree_a is start_tree else (conn_node, new_node)\n\n            # Periodic shortcutting and smoothing after solution found\n            if best_cost < float('inf') and best_sol_start and best_sol_goal:\n                if it % self.shortcut_local_interval == 0 or it == self.max_iter:\n                    raw_path = extract_path(best_sol_start, best_sol_goal)\n                    path_after_local = quick_local_shortcut(raw_path)\n                    if it % self.shortcut_global_interval == 0 or it == self.max_iter:\n                        path_after_global = global_smooth(path_after_local)\n                    else:\n                        path_after_global = path_after_local\n                    return PlannerResult(True, path_after_global, nodes, edges)\n\n        return PlannerResult(False, [], nodes, edges)",
                "objective": -3.74951,
                "time_improvement": 57.0,
                "length_improvement": 5.0,
                "smoothness_improvement": 125.0,
                "node_improvement": 100.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 0.9,
                        "time_avg": 0.020368432998657225,
                        "num_nodes_avg": 2.0,
                        "path_length_avg": 175.35768525769066,
                        "smoothness_avg": 0.015265608128551078,
                        "success_improvement": -9.999999999999998,
                        "time_improvement": 21.02445585604741,
                        "node_improvement": 99.49634852681945,
                        "length_improvement": 3.883673989918361,
                        "smoothness_improvement": 138.93991701045644,
                        "objective_score": -40.66775926418247
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.026290488243103028,
                        "num_nodes_avg": 2.0,
                        "path_length_avg": 286.29152846026153,
                        "smoothness_avg": 0.008320432129279458,
                        "success_improvement": 0.0,
                        "time_improvement": 84.12177086915176,
                        "node_improvement": 99.86561849089566,
                        "length_improvement": 4.427647355221835,
                        "smoothness_improvement": 114.09071165138572,
                        "objective_score": 28.463573232135555
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.017556381225585938,
                        "num_nodes_avg": 2.0,
                        "path_length_avg": 142.47317175392737,
                        "smoothness_avg": 0.017386855632877084,
                        "success_improvement": 0.0,
                        "time_improvement": 65.4042229917815,
                        "node_improvement": 99.74570883661794,
                        "length_improvement": 5.3761031644317825,
                        "smoothness_improvement": 121.15952028601069,
                        "objective_score": 23.45272639762357
                    }
                ],
                "success_rate": 0.9666666666666667
            }
        ],
        "offspring": {
            "operator": "m1",
            "algorithm_description": "A bidirectional RRT* planner with relaxed curvature constraints and adaptive rewiring radius enabling more aggressive shortcutting and sharper turns to produce smoother and shorter paths with efficient planning time. It combines hybrid uniform and informed sampling, hash-grid accelerated neighbor queries, incremental rewiring with curvature-aware cost, and periodic multi-level smoothing phases employing increased angle thresholds for enhanced path smoothness and robustness.",
            "planning_mechanism": "The planner grows two trees from start and goal alternately using hybrid sampling. It adaptively tunes rewiring radius to the node density and best path cost but relaxes curvature penalties and uses higher angle thresholds in curvature checks to allow more aggressive rewiring and shortcuts. Nearest neighbors are queried through spatial grid hashing. After connection, local multi-attempt curvature-aware shortcuts and global midpoint smoothing with relaxed angle limits progressively refine path smoothness. Early collision checking pruning and incremental cost propagation accelerate search and ensure feasible paths.",
            "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n    def add_child(self, child):\n        self.children.append(child)\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\nclass Planner:\n    def __init__(self, max_iter=4000, step_size=5.0, base_radius=20.0,\n                 blend_sample_rate=0.7, shortcut_local_interval=15, shortcut_global_interval=60,\n                 max_local_shortcuts=60, curvature_threshold=0.8):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.base_radius = base_radius\n        self.blend_sample_rate = blend_sample_rate\n        self.shortcut_local_interval = shortcut_local_interval\n        self.shortcut_global_interval = shortcut_global_interval\n        self.max_local_shortcuts = max_local_shortcuts\n        self.curvature_threshold = curvature_threshold\n\n    def plan(self, map):\n        import random\n        import math\n\n        bounds = map.size\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        def in_bounds(p):\n            return all(0.0 <= p[i] <= bounds[i] for i in range(dim))\n\n        def collision_node(p):\n            px = p[0]\n            py = p[1]\n            pz = p[2] if is_3d else 0.0\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d = obs\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                        return True\n                else:\n                    x,y,w,h = obs\n                    if x <= px <= x+w and y <= py <= y+h:\n                        return True\n            return False\n\n        def collision_edge(a,b,res=0.5):\n            length = math.dist(a,b)\n            if length < 1e-12:\n                return False\n            steps = max(1,int(length/res))\n            for step in range(steps+1):\n                t = step / steps\n                interp = tuple(a[i] + (b[i]-a[i])*t for i in range(dim))\n                if collision_node(interp):\n                    return True\n            return False\n\n        def steer(from_p, to_p):\n            length = math.dist(from_p,to_p)\n            if length <= self.step_size:\n                return to_p\n            ratio = self.step_size / length\n            return tuple(from_p[i] + (to_p[i] - from_p[i]) * ratio for i in range(dim))\n\n        GRID_SIZE = self.step_size * 3.0\n        def grid_hash(p):\n            return tuple(int(p[i]/GRID_SIZE) for i in range(dim))\n\n        start_hash, goal_hash = {}, {}\n        def add_to_hash(ht, node):\n            h = grid_hash(node.position)\n            if h not in ht:\n                ht[h] = []\n            ht[h].append(node)\n        def remove_from_hash(ht, node):\n            h = grid_hash(node.position)\n            if h in ht and node in ht[h]:\n                ht[h].remove(node)\n                if not ht[h]:\n                    del ht[h]\n\n        def nearby_nodes(ht, p, radius):\n            radius_sq = radius*radius\n            gh = grid_hash(p)\n            shifts = [-1,0,1]\n            neighbors = []\n            if dim==2:\n                cells = [(gh[0]+dx,gh[1]+dy) for dx in shifts for dy in shifts]\n            else:\n                cells = [(gh[0]+dx,gh[1]+dy,gh[2]+dz) for dx in shifts for dy in shifts for dz in shifts]\n            candidates = []\n            for c in cells:\n                if c in ht:\n                    candidates.extend(ht[c])\n            for node in candidates:\n                d_sq = 0.0\n                for i in range(dim):\n                    diff = node.position[i] - p[i]\n                    d_sq += diff*diff\n                    if d_sq > radius_sq:\n                        break\n                if d_sq <= radius_sq:\n                    neighbors.append(node)\n            return neighbors\n\n        def nearest(ht, p):\n            gh = grid_hash(p)\n            min_node = None\n            min_dist_sq = float('inf')\n            expansions = 0\n            max_expansions = 2\n            while expansions <= max_expansions:\n                if dim == 2:\n                    cells = [(gh[0]+dx, gh[1]+dy) for dx in range(-expansions,expansions+1) for dy in range(-expansions,expansions+1)]\n                else:\n                    cells = [(gh[0]+dx, gh[1]+dy, gh[2]+dz) for dx in range(-expansions,expansions+1) for dy in range(-expansions,expansions+1) for dz in range(-expansions,expansions+1)]\n                candidates = []\n                for c in cells:\n                    if c in ht:\n                        candidates.extend(ht[c])\n                for node in candidates:\n                    d_sq = 0.0\n                    for i in range(dim):\n                        diff = node.position[i] - p[i]\n                        d_sq += diff*diff\n                        if d_sq >= min_dist_sq:\n                            break\n                    else:\n                        if d_sq < min_dist_sq:\n                            min_dist_sq = d_sq\n                            min_node = node\n                if min_node is not None or expansions == max_expansions:\n                    break\n                expansions +=1\n            if min_node is None:\n                all_nodes = []\n                for cell_nodes in ht.values():\n                    all_nodes.extend(cell_nodes)\n                if all_nodes:\n                    min_node = min(all_nodes, key=lambda n: math.dist(n.position,p))\n            return min_node\n\n        def unit_ball_volume(d):\n            from math import pi, gamma\n            return (pi**(d/2))/(gamma(d/2+1))\n\n        c_min = math.dist(start_pos, goal_pos)\n        volume_unit_ball = unit_ball_volume(dim)\n\n        def adaptive_radius(n_nodes, best_cost):\n            if n_nodes <= 1:\n                return self.step_size * 5.0\n            val = (math.log(n_nodes)/n_nodes)**(1.0/dim)\n            radius = self.base_radius * val\n            if best_cost < float('inf'):\n                radius = min(radius, best_cost*0.4)  # relaxed multiplier for bigger radius\n            radius = max(radius, self.step_size*1.2)\n            return radius\n\n        def angle_between(a,b,c):\n            ab = [a[i]-b[i] for i in range(dim)]\n            cb = [c[i]-b[i] for i in range(dim)]\n            lab = math.sqrt(sum(x*x for x in ab))\n            lcb = math.sqrt(sum(x*x for x in cb))\n            if lab < 1e-14 or lcb < 1e-14:\n                return 0.0\n            dot = sum(ab[i]*cb[i] for i in range(dim))\n            val = max(min(dot/(lab*lcb),1.0),-1.0)\n            return math.acos(val)\n\n        def curvature_penalty(parent, child_pos):\n            # Reduced penalty scale for more permissive curvature\n            if parent is None or parent.parent is None:\n                return 0.0\n            v1 = [parent.position[i]-parent.parent.position[i] for i in range(dim)]\n            v2 = [child_pos[i]-parent.position[i] for i in range(dim)]\n            len1 = math.sqrt(sum(x*x for x in v1))\n            len2 = math.sqrt(sum(x*x for x in v2))\n            if len1 < 1e-9 or len2 < 1e-9:\n                return 0.0\n            dot = sum(v1[i]*v2[i] for i in range(dim))\n            cos_ang = max(min(dot/(len1*len2),1.0),-1.0)\n            penalty = (1.0 - cos_ang)*0.5  # half previous penalty weight\n            return penalty\n\n        def path_cost(parent, child_pos):\n            linear_cost = parent.cost + math.dist(parent.position, child_pos)\n            pen = curvature_penalty(parent, child_pos)\n            return linear_cost + pen\n\n        def rewire(tree_hash, new_node, near_nodes):\n            for n in near_nodes:\n                if n is new_node.parent:\n                    continue\n                c_cost = path_cost(new_node, n.position)\n                if c_cost + 1e-10 < n.cost:\n                    if not collision_edge(new_node.position, n.position):\n                        # Check curvature increase with relaxed threshold\n                        if n.parent:\n                            ang_before = angle_between(n.parent.parent.position if n.parent.parent else n.parent.position,\n                                                     n.parent.position, n.position)\n                            ang_after = angle_between(n.parent.position, new_node.position, n.position)\n                            if ang_after > ang_before + self.curvature_threshold:\n                                continue\n                        if n.parent:\n                            n.parent.remove_child(n)\n                        n.parent = new_node\n                        n.cost = c_cost\n                        new_node.add_child(n)\n                        self._propagate_costs(n)\n\n        def propagate_costs(node):\n            import math\n            stack = [node]\n            while stack:\n                n = stack.pop()\n                for c in n.children:\n                    new_cost = n.cost + math.dist(n.position, c.position) + curvature_penalty(n, c.position)\n                    if new_cost + 1e-12 < c.cost:\n                        c.cost = new_cost\n                        stack.append(c)\n\n        self._propagate_costs = propagate_costs\n\n        def extract_path(node_start, node_goal):\n            path_start = []\n            n = node_start\n            while n:\n                path_start.append(n.position)\n                n = n.parent\n            path_start.reverse()\n            path_goal = []\n            n = node_goal\n            while n:\n                path_goal.append(n.position)\n                n = n.parent\n            if path_start[-1] == path_goal[0]:\n                return path_start + path_goal[1:]\n            else:\n                return path_start + path_goal\n\n        def hybrid_sample(best_cost):\n            if best_cost == float('inf') or random.random() > self.blend_sample_rate:\n                for _ in range(30):\n                    pt = tuple(random.uniform(0,bounds[i]) for i in range(dim))\n                    if not collision_node(pt):\n                        return pt\n                return tuple(random.uniform(0,bounds[i]) for i in range(dim))\n            center = tuple(0.5*(start_pos[i]+goal_pos[i]) for i in range(dim))\n            d_vec = [goal_pos[i]-start_pos[i] for i in range(dim)]\n            length = math.dist(start_pos, goal_pos)\n            a1_val = best_cost*0.5\n            term = best_cost*best_cost - c_min*c_min\n            a_rest = math.sqrt(term)*0.5 if term > 0 else 0.0\n\n            if dim == 2:\n                if length < 1e-14:\n                    R = [[1,0],[0,1]]\n                else:\n                    norm_d = (d_vec[0]/length, d_vec[1]/length)\n                    c = norm_d[0]\n                    s = norm_d[1]\n                    R = [[c, -s],[s, c]]\n                attempts = 0\n                while attempts < 100:\n                    r = random.uniform(0,1)**0.5\n                    theta = random.uniform(0,2*math.pi)\n                    ball = [r*math.cos(theta), r*math.sin(theta)]\n                    x_scaled = [a1_val*ball[0], a_rest*ball[1]]\n                    pt = (center[0] + R[0][0]*x_scaled[0] + R[0][1]*x_scaled[1],\n                          center[1] + R[1][0]*x_scaled[0] + R[1][1]*x_scaled[1])\n                    if in_bounds(pt) and not collision_node(pt):\n                        return pt\n                    attempts += 1\n                return tuple(random.uniform(0,bounds[i]) for i in range(dim))\n            else:\n                from math import sqrt\n                if length < 1e-14:\n                    R = [[1,0,0],[0,1,0],[0,0,1]]\n                else:\n                    a1 = [1,0,0]\n                    a2 = [d_vec[i]/length for i in range(3)]\n                    v = [a1[1]*a2[2]-a1[2]*a2[1], a1[2]*a2[0]-a1[0]*a2[2], a1[0]*a2[1]-a1[1]*a2[0]]\n                    s = sqrt(sum(x*x for x in v))\n                    c = sum(a1[i]*a2[i] for i in range(3))\n                    if s < 1e-14:\n                        R = [[1,0,0],[0,1,0],[0,0,1]]\n                    else:\n                        vx = [[0,-v[2],v[1]], [v[2],0,-v[0]], [-v[1],v[0],0]]\n                        I = [[1 if i==j else 0 for j in range(3)] for i in range(3)]\n                        vx2 = [[sum(vx[i][k]*vx[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n                        R = [[I[i][j] + vx[i][j] + vx2[i][j]*((1-c)/(s*s)) for j in range(3)] for i in range(3)]\n                attempts = 0\n                while attempts < 100:\n                    while True:\n                        ball = [random.uniform(-1,1) for _ in range(3)]\n                        if sum(x*x for x in ball) <= 1:\n                            break\n                    x_scaled = [a1_val*ball[0], a_rest*ball[1], a_rest*ball[2]]\n                    pt = tuple(center[i] + sum(R[i][j]*x_scaled[j] for j in range(3)) for i in range(3))\n                    if in_bounds(pt) and not collision_node(pt):\n                        return pt\n                    attempts += 1\n                return tuple(random.uniform(0,bounds[i]) for i in range(dim))\n\n        def attempt_connection(tree_a, tree_hash_a, tree_b, tree_hash_b, sample, best_cost):\n            nearest_node = nearest(tree_hash_a, sample)\n            if nearest_node is None:\n                return None\n            new_pos = steer(nearest_node.position, sample)\n\n            if not in_bounds(new_pos) or collision_node(new_pos) or collision_edge(nearest_node.position, new_pos):\n                return None\n\n            radius = adaptive_radius(len(tree_a), best_cost)\n            near_nodes = nearby_nodes(tree_hash_a, new_pos, radius)\n\n            min_cost = path_cost(nearest_node, new_pos)\n            min_parent = nearest_node\n            for near in near_nodes:\n                if near is nearest_node:\n                    continue\n                c = path_cost(near, new_pos)\n                if c < min_cost and not collision_edge(near.position, new_pos):\n                    min_cost = c\n                    min_parent = near\n\n            new_node = Node(new_pos, min_parent, min_cost)\n            min_parent.add_child(new_node)\n            tree_a.append(new_node)\n            add_to_hash(tree_hash_a, new_node)\n\n            rewire(tree_hash_a, new_node, near_nodes)\n\n            other_nearest = nearest(tree_hash_b, new_node.position)\n            if other_nearest and math.dist(other_nearest.position, new_node.position) <= self.step_size:\n                if not collision_edge(other_nearest.position, new_node.position):\n                    total_cost = new_node.cost + math.dist(other_nearest.position, new_node.position) + other_nearest.cost\n                    return (new_node, other_nearest, total_cost)\n            return None\n\n        def quick_local_shortcut(path):\n            if len(path) < 3:\n                return path[:]\n            new_path = path[:]\n            attempts = 0\n            max_attempts = self.max_local_shortcuts\n            while attempts < max_attempts and len(new_path) >=3:\n                i = random.randint(0, len(new_path)-3)\n                j = random.randint(i+2, len(new_path)-1)\n                if not collision_edge(new_path[i], new_path[j]):\n                    valid = True\n                    # Relax curvature checks: larger angle threshold and apply selectively\n                    if i > 0 and j < len(new_path)-1:\n                        ang_before = angle_between(new_path[i-1], new_path[i], new_path[i+1] if i+1<len(new_path) else new_path[i])\n                        ang_after = angle_between(new_path[i-1], new_path[i], new_path[j])\n                        ang_after2 = angle_between(new_path[i], new_path[j], new_path[j+1])\n                        if ang_after > ang_before + self.curvature_threshold + 0.3 or ang_after2 > self.curvature_threshold + 0.7:\n                            valid = False\n                    if valid:\n                        del new_path[i+1:j]\n                        attempts += 1\n                    else:\n                        attempts +=1\n                else:\n                    attempts +=1\n            return new_path\n\n        def global_smooth(path):\n            if len(path) < 4:\n                return path[:]\n            new_path = path[:]\n            changed = False\n            for idx in range(1, len(path)-1):\n                a = new_path[idx-1]\n                b = new_path[idx]\n                c = new_path[idx+1]\n                midpoint = tuple(0.5*(a[i]+c[i]) for i in range(dim))\n                if not collision_node(midpoint) and not collision_edge(a, midpoint) and not collision_edge(midpoint, c):\n                    ang_old = angle_between(a,b,c)\n                    ang_new = angle_between(a, midpoint, c)\n                    # Allow relaxed curvature threshold to smooth sharper turns\n                    if ang_new < ang_old + self.curvature_threshold + 0.2:\n                        new_path[idx] = midpoint\n                        changed = True\n            return new_path if changed else path\n\n        start_tree = [Node(start_pos, None, 0.0)]\n        goal_tree = [Node(goal_pos, None, 0.0)]\n        nodes = start_tree + goal_tree\n        edges = []\n        add_to_hash(start_hash,start_tree[0])\n        add_to_hash(goal_hash,goal_tree[0])\n\n        best_cost = float('inf')\n        best_sol_start = None\n        best_sol_goal = None\n\n        for it in range(1, self.max_iter+1):\n            sample = hybrid_sample(best_cost)\n\n            for tree_a, hash_a, tree_b, hash_b in [(start_tree, start_hash, goal_tree, goal_hash),\n                                                   (goal_tree, goal_hash, start_tree, start_hash)]:\n                res = attempt_connection(tree_a, hash_a, tree_b, hash_b, sample, best_cost)\n                if res:\n                    new_node, conn_node, cost_candidate = res\n                    if cost_candidate + 1e-15 < best_cost:\n                        best_cost = cost_candidate\n                        best_sol_start, best_sol_goal = (new_node, conn_node) if tree_a is start_tree else (conn_node, new_node)\n\n            if best_cost < float('inf') and best_sol_start and best_sol_goal:\n                if it % self.shortcut_local_interval == 0 or it == self.max_iter:\n                    raw_path = extract_path(best_sol_start, best_sol_goal)\n                    path_after_local = quick_local_shortcut(raw_path)\n                    if it % self.shortcut_global_interval == 0 or it == self.max_iter:\n                        path_after_global = global_smooth(path_after_local)\n                    else:\n                        path_after_global = path_after_local\n                    return PlannerResult(True, path_after_global, nodes, edges)\n\n        return PlannerResult(False, [], nodes, edges)",
            "objective": -23.54405,
            "time_improvement": 61.0,
            "length_improvement": 8.0,
            "smoothness_improvement": 147.0,
            "node_improvement": 100.0,
            "other_inf": [
                {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.019300460815429688,
                    "num_nodes_avg": 2.0,
                    "path_length_avg": 182.424034052097,
                    "smoothness_avg": 0.013544456505030241,
                    "success_improvement": 0.0,
                    "time_improvement": 25.16535782462595,
                    "node_improvement": 99.49634852681945,
                    "length_improvement": 0.01049624224208904,
                    "smoothness_improvement": 112.00015656178346,
                    "objective_score": 8.115905875541955
                },
                {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.025008130073547363,
                    "num_nodes_avg": 2.0,
                    "path_length_avg": 267.74552895014153,
                    "smoothness_avg": 0.009938292940300212,
                    "success_improvement": 0.0,
                    "time_improvement": 84.89625541488331,
                    "node_improvement": 99.86561849089566,
                    "length_improvement": 10.618835808697503,
                    "smoothness_improvement": 155.7194356169902,
                    "objective_score": 32.61877528776845
                },
                {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.013741588592529297,
                    "num_nodes_avg": 2.0,
                    "path_length_avg": 132.60623477657154,
                    "smoothness_avg": 0.021438419722591737,
                    "success_improvement": 0.0,
                    "time_improvement": 72.92147347580986,
                    "node_improvement": 99.74570883661794,
                    "length_improvement": 11.929252891742708,
                    "smoothness_improvement": 172.69511645182806,
                    "objective_score": 29.897469360047726
                }
            ],
            "success_rate": 1.0
        },
        "objective": 35.0,
        "analysis": {
            "problem": [
                "Problem of the parents algorithm:\n   - Overly strict curvature constraints limiting rewiring and shortcutting aggressiveness.\n   - Aggressive shrinking of rewiring radius reduces beneficial rewirings to lower path cost.\n   - Conservative local and global smoothing thresholds restrict path refinement.\n   - Sampling attempts may be inefficient in dense obstacle regions.\n   - Nearest neighbor search with limited grid cell expansions causing fallback linear searches and slowing planning.\n   - Frequent collision checks and recursion during rewiring increase computational overhead."
            ],
            "solution": "1. Primary contributors to the performance improvement:\n   - Relaxation of curvature penalty weights and increased curvature thresholds enable more aggressive rewiring and shortcutting.\n   - Adaptively larger rewiring radius allowing more effective neighborhood rewiring.\n   - Increased maximum local shortcut attempts facilitating better path shortening.\n   - Relaxed curvature criteria in local and global path smoothing improving smoother paths with less planning delays.\n   - More permissive angle thresholds reducing overly conservative pruning of potential improvements.\n\n2. Expected mechanism of impact:\n   - By loosening curvature constraints and penalties, the planner explores more rewiring options, avoiding unnecessarily long detours, thus speeding convergence.\n   - Larger rewiring radius expands neighborhood search yielding more cost-effective parent assignments and faster path improvement.\n   - Higher number of shortcut attempts leads to quicker elimination of redundant waypoints reducing path length and complexity.\n   - Relaxed smoothing thresholds permit smoother bends with fewer failed smoothing attempts, enhancing path quality without excessive runtime.\n   - Reduced fallback linear searches and pruning enable better computational efficiency lowering planning time while maintaining feasible paths."
        }
    },
    {
        "parents": [
            {
                "operator": "m1",
                "algorithm_description": "A novel bidirectional RRT* planner employing a hybrid adaptive sampling strategy that blends uniform sampling and dynamically scaled ellipsoidal informed sampling based on solution quality to balance exploration and exploitation. It integrates a KD-tree-inspired spatial indexing for efficient nearest and near neighbor queries, adaptive rewiring radius scaled by node density and current best path cost, and combines incremental local shortcutting with periodic global path smoothing using cubic B\u00e9zier curve fitting for superior path smoothness and length optimization. The planner incrementally extends both trees with dynamic step sizes reducing over-extension and enables early tree connection attempts prioritized by cost improvements, resulting in faster convergence, higher-quality paths, and improved smoothness while maintaining full obstacle collision safety checks.",
                "planning_mechanism": "A bidirectional RRT* maintaining two trees grown from start and goal alternately, where samples are drawn from a hybrid sampler switching smoothly from uniform to ellipsoidal informed sampling as solutions improve. KD-tree-like spatial partitioning accelerates nearest neighbor searches. Nodes are extended with adaptive step sizes limited by local node density. Rewiring radius adapts with node count and solution cost. Local incremental shortcutting applies continuously, and after fixed intervals, global smoothing refines full paths using B\u00e9zier curve fitting. The connection procedure prioritizes lower-cost connections with early exit for efficiency. The approach robustly balances exploration and optimization, improving planning time, path length, and smoothness.",
                "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n    def add_child(self, child):\n        self.children.append(child)\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except ValueError:\n            pass\nclass Planner:\n    def __init__(self, max_iter=5500, max_step=5.0, gamma=35.0,\n                 shortcut_local_freq=15, shortcut_global_freq=150, max_local_shortcut_attempts=60):\n        self.max_iter = max_iter\n        self.max_step = max_step\n        self.gamma = gamma\n        self.shortcut_local_freq = shortcut_local_freq\n        self.shortcut_global_freq = shortcut_global_freq\n        self.max_local_shortcut_attempts = max_local_shortcut_attempts\n\n    def plan(self, map):\n        import math\n        import random\n\n        start = map.start\n        goal = map.goal\n        bounds = map.size\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is3d = (dim == 3)\n\n        # Simple spatial hashing for approximate nearest neighbor acceleration\n        # Grid cell size tuned to step size\n        cell_size = self.max_step * 2.0\n        def cell_coords(pos):\n            return tuple(int(p / cell_size) for p in pos)\n        # Each tree stores spatial hash: dict key=cell_coords -> list of nodes\n        start_tree_nodes = [Node(start)]\n        goal_tree_nodes = [Node(goal)]\n        nodes = start_tree_nodes + goal_tree_nodes\n        edges = []\n\n        start_hash = {}\n        goal_hash = {}\n        def _insert_hash(h, node):\n            cell = cell_coords(node.position)\n            h.setdefault(cell, []).append(node)\n        _insert_hash(start_hash, start_tree_nodes[0])\n        _insert_hash(goal_hash, goal_tree_nodes[0])\n\n        def _get_candidates(h, pos, radius):\n            # collect nodes in neighboring cells to radius\n            c = cell_coords(pos)\n            r_cells = int(math.ceil(radius / cell_size))\n            candidates = []\n            r2 = radius*radius\n            for dx in range(-r_cells, r_cells+1):\n                for dy in range(-r_cells, r_cells+1):\n                    for dz in ([0] if dim==2 else range(-r_cells, r_cells+1)):\n                        cell = (c[0]+dx, c[1]+dy) if dim==2 else (c[0]+dx, c[1]+dy, c[2]+dz)\n                        for n in h.get(cell, []):\n                            dist2 = 0.0\n                            for i in range(dim):\n                                diff = n.position[i] - pos[i]\n                                dist2 += diff*diff\n                            if dist2 <= r2:\n                                candidates.append(n)\n            return candidates\n\n        def dist_points(a, b):\n            s = 0.0\n            for i in range(dim):\n                d = a[i] - b[i]\n                s += d*d\n            return math.sqrt(s)\n\n        def in_bounds(p):\n            for i in range(dim):\n                if p[i] < 0 or p[i] > bounds[i]:\n                    return False\n            return True\n\n        def collision_point(p):\n            for obs in obstacles:\n                if is3d:\n                    x,y,z,w,h,d = obs\n                    px,py,pz = p\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                        return True\n                else:\n                    x,y,w,h = obs\n                    px,py = p\n                    if x <= px <= x+w and y <= py <= y+h:\n                        return True\n            return False\n\n        def collision_edge(p1, p2, resolution=1.0):\n            dist_len = dist_points(p1, p2)\n            steps = max(1, int(dist_len/resolution))\n            for step in range(steps+1):\n                interp = tuple(p1[i] + (p2[i]-p1[i])*(step/steps) for i in range(dim))\n                if collision_point(interp):\n                    return True\n            return False\n\n        def steer(from_p, to_p, max_len):\n            delta = [to_p[i] - from_p[i] for i in range(dim)]\n            dist_len = math.sqrt(sum(d*d for d in delta))\n            if dist_len <= max_len:\n                return to_p\n            ratio = max_len / dist_len\n            new_pos = tuple(from_p[i] + delta[i] * ratio for i in range(dim))\n            return new_pos\n\n        # Hybrid sampling: blends uniform and ellipsoidal informed sampling\n        best_cost = float('inf')\n        c_min = dist_points(start, goal)\n        def sample():\n            if best_cost == float('inf') or best_cost <= c_min:\n                # Pure uniform\n                while True:\n                    pt = tuple(random.uniform(0,bounds[i]) for i in range(dim))\n                    if not collision_point(pt):\n                        return pt\n            # Blend factor alpha based on progress toward best cost (0..1)\n            alpha = min(1.0, max(0.0, (best_cost - c_min)/(best_cost + 1e-8)))\n            if random.random() < alpha:\n                # Ellipsoidal informed sampling\n                center = tuple( (start[i]+goal[i])*0.5 for i in range(dim))\n                dir_vec = [goal[i]-start[i] for i in range(dim)]\n                length = c_min\n                if length < 1e-14:\n                    R = None\n                else:\n                    if dim == 2:\n                        dx, dy = dir_vec[0]/length, dir_vec[1]/length\n                        cos_t, sin_t = dx, dy\n                        R = [[cos_t, -sin_t], [sin_t, cos_t]]\n                    else:\n                        from math import sqrt\n                        a1 = [1,0,0]\n                        a2 = [d/length for d in dir_vec]\n                        v = [a1[1]*a2[2]-a1[2]*a2[1],\n                             a1[2]*a2[0]-a1[0]*a2[2],\n                             a1[0]*a2[1]-a1[1]*a2[0]]\n                        s = math.sqrt(sum(x*x for x in v))\n                        c = sum(a1[i]*a2[i] for i in range(3))\n                        if s < 1e-14:\n                            R = [[1,0,0],[0,1,0],[0,0,1]]\n                        else:\n                            vx = [[0,-v[2],v[1]],[v[2],0,-v[0]],[-v[1],v[0],0]]\n                            I = [[1 if i==j else 0 for j in range(3)] for i in range(3)]\n                            vx2 = [[sum(vx[i][k]*vx[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n                            R = [[I[i][j] + vx[i][j] + vx2[i][j]*((1-c)/(s*s)) for j in range(3)] for i in range(3)]\n                a1_ellip = best_cost / 2.0\n                r_others = math.sqrt(max(best_cost*best_cost - c_min*c_min, 0)) / 2.0\n                for _ in range(150):\n                    if dim == 2:\n                        r = random.uniform(0,1)**0.5\n                        theta = random.uniform(0, 2*math.pi)\n                        x_ball = [r*math.cos(theta), r*math.sin(theta)]\n                        L = [[a1_ellip, 0],[0, r_others]]\n                        x_scaled = [L[0][0]*x_ball[0], L[1][1]*x_ball[1]]\n                        if R is None:\n                            pt = (center[0]+x_scaled[0], center[1]+x_scaled[1])\n                        else:\n                            pt = (center[0] + R[0][0]*x_scaled[0] + R[0][1]*x_scaled[1],\n                                  center[1] + R[1][0]*x_scaled[0] + R[1][1]*x_scaled[1])\n                    else:\n                        while True:\n                            x_ball = [random.uniform(-1,1) for _ in range(3)]\n                            if sum(x*x for x in x_ball) <= 1:\n                                break\n                        L = [[a1_ellip,0,0],[0,r_others,0],[0,0,r_others]]\n                        x_scaled = [L[0][0]*x_ball[0], L[1][1]*x_ball[1], L[2][2]*x_ball[2]]\n                        if R is None:\n                            pt = tuple(center[i] + x_scaled[i] for i in range(3))\n                        else:\n                            pt = tuple(center[i] + sum(R[i][j]*x_scaled[j] for j in range(dim)) for i in range(dim))\n                    if not in_bounds(pt): continue\n                    if collision_point(pt): continue\n                    return pt\n                # fallback uniform if no ellipse sample found\n                while True:\n                    pt = tuple(random.uniform(0,bounds[i]) for i in range(dim))\n                    if not collision_point(pt):\n                        return pt\n            else:\n                # uniform sample for exploration\n                while True:\n                    pt = tuple(random.uniform(0,bounds[i]) for i in range(dim))\n                    if not collision_point(pt):\n                        return pt\n\n        def near_radius(n_nodes):\n            if n_nodes <= 1:\n                return self.max_step * 3.0\n            base_r = self.gamma * (math.log(n_nodes) / n_nodes) ** (1.0/dim)\n            max_r = self.max_step * 20.0\n            # Adapt radius with solution cost for refined connectivity\n            adapt_factor = 1.0\n            if best_cost < float('inf'):\n                adapt_factor = max(0.5, min(1.0, best_cost / (c_min*3.0)))\n            return min(base_r * adapt_factor, max_r)\n\n        def insert_node(tree_nodes, tree_hash, node):\n            tree_nodes.append(node)\n            _insert_hash(tree_hash, node)\n\n        def remove_edge(edges_list, parent, child):\n            try:\n                edges_list.remove((parent, child))\n            except ValueError:\n                pass\n            parent.remove_child(child)\n\n        def update_parent(child, new_parent, edges_list):\n            old_parent = child.parent\n            if old_parent is not None:\n                remove_edge(edges_list, old_parent, child)\n            child.parent = new_parent\n            child.cost = new_parent.cost + dist_points(new_parent.position, child.position)\n            new_parent.add_child(child)\n            edges_list.append((new_parent, child))\n\n        def extract_path(n_start, n_goal):\n            path_s, path_g = [], []\n            n = n_start\n            while n is not None:\n                path_s.append(n.position)\n                n = n.parent\n            n = n_goal\n            while n is not None:\n                path_g.append(n.position)\n                n = n.parent\n            return list(reversed(path_s)) + path_g\n\n        def local_shortcut(path):\n            if len(path) < 3:\n                return path[:]\n            new_path = path[:]\n            attempts = 0\n            while attempts < self.max_local_shortcut_attempts:\n                if len(new_path) < 3:\n                    break\n                i = random.randint(0, len(new_path) - 3)\n                j = random.randint(i+2, len(new_path) -1)\n                if not collision_edge(new_path[i], new_path[j]):\n                    new_path = new_path[:i+1] + new_path[j:]\n                    attempts = 0\n                else:\n                    attempts += 1\n            return new_path\n\n        def cubic_bezier(points, t):\n            # Compute cubic B\u00e9zier for path smoothing\n            # points: list of 4 control points (tuples)\n            inv = 1 - t\n            p = [0.0]*len(points[0])\n            for i in range(len(points[0])):\n                p[i] = (inv**3)*points[0][i] + 3*(inv**2)*t*points[1][i] + 3*inv*(t**2)*points[2][i] + (t**3)*points[3][i]\n            return tuple(p)\n\n        def global_smooth(path):\n            # If path too short or less than 4 pts, return original\n            if len(path) < 4:\n                return path[:]\n            # Construct smoothed path using cubic B\u00e9zier segments over consecutive quartets with resampling\n            smoothed = []\n            N = len(path)\n            smoothed.append(path[0])\n            steps_per_segment = 6\n            for i in range(N-3):\n                p0, p1, p2, p3 = path[i], path[i+1], path[i+2], path[i+3]\n                for step_idx in range(1, steps_per_segment+1):\n                    t = step_idx / steps_per_segment\n                    pt = cubic_bezier([p0,p1,p2,p3], t)\n                    # Only add if no collision along segment from last appended point\n                    if not collision_edge(smoothed[-1], pt):\n                        smoothed.append(pt)\n                    else:\n                        # Cannot shortcut this segment, keep original intermediate points\n                        smoothed.append(path[i+1])\n                        smoothed.append(path[i+2])\n                        break\n            # Add remaining last points if any\n            if smoothed[-1] != path[-1]:\n                smoothed.append(path[-1])\n            # Remove duplicates (if any)\n            final_path = [smoothed[0]]\n            for p in smoothed[1:]:\n                if dist_points(final_path[-1], p) > 1e-6:\n                    final_path.append(p)\n            return final_path if len(final_path) >= 2 else path[:]\n\n        def try_connect_trees(tree_a, tree_b):\n            # Try connections of nodes in tree_a to nearest in tree_b limited by max_step threshold\n            radius = self.max_step * 1.5\n            improved = None\n            for n_a in tree_a:\n                candidates = _get_candidates(goal_hash if tree_b is goal_tree_nodes else start_hash, n_a.position, radius)\n                for n_b in candidates:\n                    total_cost = n_a.cost + dist_points(n_a.position, n_b.position) + n_b.cost\n                    if total_cost < best_cost:\n                        if not collision_edge(n_a.position, n_b.position):\n                            improved = (n_a, n_b, total_cost) if tree_a is start_tree_nodes else (n_b, n_a, total_cost)\n            return improved\n\n        best_pair = None\n\n        for it in range(self.max_iter):\n            s = sample()\n\n            def extend(tree_nodes, tree_hash, other_tree_nodes, other_tree_hash):\n                nonlocal best_cost, best_pair\n\n                # Find nearest node approx with spatial hash + linear within radius\n                radius_near = near_radius(len(tree_nodes))\n                near_candidates = _get_candidates(tree_hash, s, radius_near)\n                if not near_candidates:\n                    # Fallback to all nodes for nearest\n                    near_candidates = tree_nodes\n\n                # Find nearest for extension\n                nearest_node = None\n                nearest_dist2 = float('inf')\n                for n in near_candidates:\n                    d2 = 0.0\n                    for i in range(dim):\n                        diff = n.position[i] - s[i]\n                        d2 += diff*diff\n                    if d2 < nearest_dist2:\n                        nearest_dist2 = d2\n                        nearest_node = n\n                if nearest_node is None:\n                    return\n\n                new_pos = steer(nearest_node.position, s, self.max_step)\n                if collision_point(new_pos):\n                    return\n                if collision_edge(nearest_node.position, new_pos):\n                    return\n\n                # Potential parents near new_pos within radius\n                near_nodes = _get_candidates(tree_hash, new_pos, radius_near)\n                # Compute minimal-cost parent avoiding collision edges\n                min_cost = nearest_node.cost + dist_points(nearest_node.position, new_pos)\n                min_parent = nearest_node\n                for n in near_nodes:\n                    cost_cand = n.cost + dist_points(n.position, new_pos)\n                    if cost_cand < min_cost and not collision_edge(n.position, new_pos):\n                        min_cost = cost_cand\n                        min_parent = n\n\n                new_node = Node(new_pos)\n                new_node.parent = min_parent\n                new_node.cost = min_cost\n                min_parent.add_child(new_node)\n\n                insert_node(tree_nodes, tree_hash, new_node)\n                nodes.append(new_node)\n                edges.append((min_parent, new_node))\n\n                # Rewire neighbors if improving cost\n                for n in near_nodes:\n                    if n is min_parent:\n                        continue\n                    new_cost = new_node.cost + dist_points(new_node.position, n.position)\n                    if new_cost < n.cost and not collision_edge(new_node.position, n.position):\n                        update_parent(n, new_node, edges)\n\n                # Early attempt connect to other tree\u2019s nearest candidates near new_node.position\n                radius_conn = self.max_step * 1.5\n                candidates_other = _get_candidates(other_tree_hash, new_node.position, radius_conn)\n                for other_node in candidates_other:\n                    dist_conn = dist_points(new_node.position, other_node.position)\n                    if dist_conn <= self.max_step:\n                        if not collision_edge(new_node.position, other_node.position):\n                            total_path_cost = new_node.cost + dist_conn + other_node.cost\n                            if total_path_cost < best_cost:\n                                best_cost = total_path_cost\n                                best_pair = (new_node, other_node)\n                return\n\n            # Alternate extension start->goal and goal->start each iteration\n            if it % 2 == 0:\n                extend(start_tree_nodes, start_hash, goal_tree_nodes, goal_hash)\n            else:\n                extend(goal_tree_nodes, goal_hash, start_tree_nodes, start_hash)\n\n            # Local shortcut incremental improvements after fixed freq\n            if best_pair is not None and it % self.shortcut_local_freq == 0:\n                raw_path = extract_path(best_pair[0], best_pair[1])\n                improved_path = local_shortcut(raw_path)\n                if len(improved_path) >= 2:\n                    # Update best cost with refined path if cheaper\n                    cost_new = 0.0\n                    for i in range(len(improved_path)-1):\n                        cost_new += dist_points(improved_path[i], improved_path[i+1])\n                    if cost_new < best_cost:\n                        best_cost = cost_new\n                        raw_path = improved_path\n                # Do NOT return here, keep planning for better solution\n\n            # Periodic global smoothing and return final solution\n            if best_pair is not None and (it % self.shortcut_global_freq == 0 or it == self.max_iter-1):\n                raw_path = extract_path(best_pair[0], best_pair[1])\n                path_smoothed = global_smooth(raw_path)\n                # Validate smoothed path collision free\n                collision_free = True\n                for i in range(len(path_smoothed)-1):\n                    if collision_edge(path_smoothed[i], path_smoothed[i+1]):\n                        collision_free = False\n                        break\n                if collision_free and len(path_smoothed) >= 2:\n                    return PlannerResult(True, path_smoothed, nodes, edges)\n\n        # No path found after max iterations, if best_pair exists return raw best path\n        if best_pair is not None:\n            path = extract_path(best_pair[0], best_pair[1])\n            return PlannerResult(True, path, nodes, edges)\n\n        return PlannerResult(False, [], nodes, edges)",
                "objective": 103.9749,
                "time_improvement": -6.0,
                "length_improvement": -170.0,
                "smoothness_improvement": -28.0,
                "node_improvement": 62.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.05240914821624756,
                        "num_nodes_avg": 182.8,
                        "path_length_avg": 447.2865755203916,
                        "smoothness_avg": 0.006119858169783832,
                        "success_improvement": 0.0,
                        "time_improvement": -103.20861201114863,
                        "node_improvement": 53.9662553512969,
                        "length_improvement": -145.16485975207908,
                        "smoothness_improvement": -4.210930158161774,
                        "objective_score": -118.08255410538283
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.04765622615814209,
                        "num_nodes_avg": 304.2,
                        "path_length_avg": 887.7922454706983,
                        "smoothness_avg": 0.0023280083557436766,
                        "success_improvement": 0.0,
                        "time_improvement": 71.21786132484577,
                        "node_improvement": 79.56057246522879,
                        "length_improvement": -196.37060522104258,
                        "smoothness_improvement": -40.098668210073185,
                        "objective_score": -96.65749807622217
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.043147945404052736,
                        "num_nodes_avg": 369.4,
                        "path_length_avg": 405.2404780236693,
                        "smoothness_avg": 0.004839742850928227,
                        "success_improvement": 0.0,
                        "time_improvement": 14.974693339083887,
                        "node_improvement": 53.032422123331216,
                        "length_improvement": -169.14143002541118,
                        "smoothness_improvement": -38.438828168850456,
                        "objective_score": -97.18464415436578
                    }
                ],
                "success_rate": 1.0
            },
            {
                "operator": "m2",
                "algorithm_description": "This algorithm is an enhanced bidirectional RRT* planner that incorporates adaptive rewiring radius, smarter sampling strategies incorporating goal bias and informed sampling, and a post-processing path smoothing stage using shortcutting to greatly improve path smoothness, length, and planning efficiency. It grows two trees from start and goal, alternates expansion, rewires locally for optimality, attempts early connection, and finally smooths the extracted path for a low-cost, feasible, and smooth trajectory.",
                "planning_mechanism": "The planner uses bidirectional RRT* with adaptive rewiring radius based on the logarithm of tree size for asymptotic optimality and faster rewiring, samples with a goal bias probability to focus exploration, uses a connection radius scaled to domain size, and applies a shortcut smoothing post-processing on the constructed path. Trees are alternately expanded toward random samples or the opposing tree's nearest nodes to encourage faster convergence and connection. Collision checks are extensive but efficient with early rejections.",
                "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        node, path = self, []\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=5.0, base_radius=15.0, goal_sample_rate=0.1, shortcut_iterations=150):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.base_radius = base_radius\n        self.goal_sample_rate = goal_sample_rate\n        self.shortcut_iterations = shortcut_iterations\n\n    def plan(self, map) -> 'PlannerResult':\n        import random, math\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        def dist(a,b):\n            return math.dist(a,b)\n\n        def steer(fr, to):\n            d = dist(fr, to)\n            if d <= self.step_size:\n                return to\n            ratio = self.step_size / d\n            return tuple(fr[i] + (to[i] - fr[i]) * ratio for i in range(dim))\n\n        def is_in_obstacle(p):\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d_ = obs\n                    px,py,pz = p\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d_:\n                        return True\n                else:\n                    x,y,w,h = obs\n                    px,py = p\n                    if x <= px <= x+w and y <= py <= y+h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(fr,to, resolution=1.0):\n            d = dist(fr,to)\n            steps = max(1, int(d / resolution))\n            for i in range(steps + 1):\n                interp = tuple(fr[j] + (to[j] - fr[j]) * i / steps for j in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: dist(node.position, point))\n\n        def near_nodes(tree, point, radius):\n            return [node for node in tree if dist(node.position, point) <= radius]\n\n        def rewire(tree, new_node, near_nodes_):\n            nonlocal edges\n            for near in near_nodes_:\n                if near == new_node.parent:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, near.position)\n                if new_cost + 1e-7 < near.cost:\n                    if not is_edge_in_obstacle(new_node.position, near.position):\n                        # Remove old edge\n                        if near.parent is not None:\n                            try:\n                                edges.remove((near.parent, near))\n                            except Exception:\n                                pass\n                        near.parent.children.remove(near) if near.parent else None\n                        near.parent = new_node\n                        near.cost = new_cost\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n\n        def extract_path(node_from_start, node_from_goal):\n            path_start = node_from_start.path_from_root()\n            path_goal = node_from_goal.path_from_root()[::-1]\n            if len(path_start) > 0 and len(path_goal) > 0 and path_start[-1] == path_goal[0]:\n                path_goal = path_goal[1:]\n            return path_start + path_goal\n\n        def sample_point():\n            if random.random() < self.goal_sample_rate:\n                return goal_pos\n            else:\n                return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n\n        def shortcut_path(path):\n            # Attempts shortcutting to reduce sharp turns and improve smoothness\n            for _ in range(self.shortcut_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i+2, len(path) -1)\n                p1, p2 = path[i], path[j]\n                if not is_edge_in_obstacle(p1, p2):\n                    # shortcut successful: remove intermediate points between i and j\n                    path = path[:i+1] + path[j:]\n            return path\n\n        def adaptive_radius(tree_size):\n            # follow RRT* inspired radius scaling: gamma*(log(n)/n)^(1/d)\n            gamma = self.base_radius\n            n = max(tree_size, 1)\n            radius = gamma * (math.log(n)/n)**(1.0/dim)\n            return max(radius, self.step_size*1.5)\n\n        success = False\n        connection_pair = (None, None)\n\n        # Alternate which is tree A and tree B\n        for it in range(self.max_iter):\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                q_rand = sample_point()\n                nearest_node = nearest(tree_a, q_rand)\n                q_new_pos = steer(nearest_node.position, q_rand)\n                if is_in_obstacle(q_new_pos):\n                    continue\n                if is_edge_in_obstacle(nearest_node.position, q_new_pos):\n                    continue\n\n                # Rewiring radius adaptive\n                radius = adaptive_radius(len(tree_a))\n\n                # Find near nodes in tree_a for rewiring\n                near_nodes_a = near_nodes(tree_a, q_new_pos, radius)\n\n                # Choose best parent minimizing cost\n                min_cost = nearest_node.cost + dist(nearest_node.position, q_new_pos)\n                min_parent = nearest_node\n                for near_node in near_nodes_a:\n                    c = near_node.cost + dist(near_node.position, q_new_pos)\n                    if c < min_cost and not is_edge_in_obstacle(near_node.position, q_new_pos):\n                        min_cost = c\n                        min_parent = near_node\n\n                q_new = Node(q_new_pos, parent=min_parent, cost=min_cost)\n                min_parent.add_child(q_new)\n                tree_a.append(q_new)\n                nodes.append(q_new)\n                edges.append((min_parent, q_new))\n\n                # Rewire neighbors for improved costs\n                rewire(tree_a, q_new, near_nodes_a)\n\n                # Attempt connection to other tree\n                nearest_to_new = nearest(tree_b, q_new.position)\n                dist_connect = dist(q_new.position, nearest_to_new.position)\n                radius_connect = max(self.step_size*1.5, adaptive_radius(len(tree_b)))\n                if dist_connect <= radius_connect and not is_edge_in_obstacle(q_new.position, nearest_to_new.position):\n                    # Connected trees successfully\n                    if tree_a is start_tree:\n                        node_start, node_goal = q_new, nearest_to_new\n                    else:\n                        node_start, node_goal = nearest_to_new, q_new\n                    success = True\n                    connection_pair = (node_start, node_goal)\n                    break\n            if success:\n                break\n\n        path = []\n        if success:\n            raw_path = extract_path(connection_pair[0], connection_pair[1])\n            path = shortcut_path(raw_path)\n\n        return PlannerResult(success, path, nodes, edges)",
                "objective": -33.9861,
                "time_improvement": 56.0,
                "length_improvement": 16.0,
                "smoothness_improvement": 1519.0,
                "node_improvement": 69.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.01380462646484375,
                        "num_nodes_avg": 128.7,
                        "path_length_avg": 166.57538852397772,
                        "smoothness_avg": 0.04015959576609991,
                        "success_improvement": 0.0,
                        "time_improvement": 46.47463126707311,
                        "node_improvement": 67.59002770083103,
                        "length_improvement": 8.697389994063707,
                        "smoothness_improvement": 528.5848816974815,
                        "objective_score": 21.803747785047563
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.028153705596923827,
                        "num_nodes_avg": 317.3,
                        "path_length_avg": 238.40919577619638,
                        "smoothness_avg": 0.10655923140396159,
                        "success_improvement": 0.0,
                        "time_improvement": 82.9964744581085,
                        "node_improvement": 78.68037358059532,
                        "length_improvement": 20.412148221691805,
                        "smoothness_improvement": 2641.8457755359923,
                        "objective_score": 50.35546014812759
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.031368589401245116,
                        "num_nodes_avg": 304.4,
                        "path_length_avg": 121.92947455845565,
                        "smoothness_avg": 0.11683997631770895,
                        "success_improvement": 0.0,
                        "time_improvement": 38.186536846996304,
                        "node_improvement": 61.29688493324858,
                        "length_improvement": 19.020248655927677,
                        "smoothness_improvement": 1386.1958745313084,
                        "objective_score": 29.79908962031204
                    }
                ],
                "success_rate": 1.0
            }
        ],
        "offspring": {
            "operator": "m2",
            "algorithm_description": "An advanced bidirectional RRT* planner combining adaptive rewiring radius with dynamic goal bias and local incremental smoothing performed continuously during planning to enhance convergence speed, path quality, and smoothness. It features balanced exploration via adjustable goal bias sampling, adaptive rewiring based on tree size and dimensionality to optimize local connections efficiently, and progressive local shortcutting integrated into the planning loop to refine path geometry incrementally. This design reduces sharp turns and excess waypoints early, producing shorter, smoother, and more robust paths with lower computational overhead.",
            "planning_mechanism": "The planner grows two trees from start and goal positions alternately, sampling primarily with a tunable goal bias to accelerate convergence. Expansion towards samples is constrained by a fixed step size, and new nodes are optimally connected using an adaptive rewiring radius scaled with the logarithm of the tree size and problem dimension. After each iteration, local shortcutting attempts simplify the best available path, continuously enhancing path smoothness without waiting for post-processing. The algorithm terminates upon tree connection or maximum iterations, returning the smoothed shortest path found.",
            "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except ValueError:\n            pass\n\n    def path_from_root(self):\n        node, path = self, []\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=4000, step_size=5.0, base_radius=18.0, goal_sample_rate=0.15,\n                 local_shortcut_attempts=40):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.base_radius = base_radius\n        self.goal_sample_rate = goal_sample_rate\n        self.local_shortcut_attempts = local_shortcut_attempts\n\n    def plan(self, map) -> 'PlannerResult':\n        import random, math\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        def dist(a,b):\n            return math.dist(a,b)\n\n        def steer(fr, to):\n            d = dist(fr, to)\n            if d <= self.step_size:\n                return to\n            ratio = self.step_size / d\n            return tuple(fr[i] + (to[i] - fr[i]) * ratio for i in range(dim))\n\n        def is_in_obstacle(p):\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d_ = obs\n                    px,py,pz = p\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d_:\n                        return True\n                else:\n                    x,y,w,h = obs\n                    px,py = p\n                    if x <= px <= x+w and y <= py <= y+h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(fr,to, resolution=1.0):\n            d = dist(fr,to)\n            steps = max(1, int(d / resolution))\n            for i in range(steps + 1):\n                interp = tuple(fr[j] + (to[j] - fr[j]) * i / steps for j in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: dist(node.position, point))\n\n        def near_nodes(tree, point, radius):\n            r2 = radius*radius\n            result = []\n            for n in tree:\n                cd = 0.0\n                for i in range(dim):\n                    d = n.position[i] - point[i]\n                    cd += d*d\n                    if cd > r2:\n                        break\n                else:\n                    result.append(n)\n            return result\n\n        def rewire(tree, new_node, near_nodes_):\n            nonlocal edges\n            for near in near_nodes_:\n                if near == new_node.parent:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, near.position)\n                if new_cost + 1e-8 < near.cost:\n                    if not is_edge_in_obstacle(new_node.position, near.position):\n                        # Remove old edge\n                        if near.parent is not None:\n                            try:\n                                edges.remove((near.parent, near))\n                                near.parent.remove_child(near)\n                            except Exception:\n                                pass\n                        near.parent = new_node\n                        near.cost = new_cost\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n\n        def extract_path(node_from_start, node_from_goal):\n            path_start = node_from_start.path_from_root()\n            path_goal = node_from_goal.path_from_root()[::-1]\n            if len(path_start) > 0 and len(path_goal) > 0 and path_start[-1] == path_goal[0]:\n                path_goal = path_goal[1:]\n            return path_start + path_goal\n\n        def sample_point():\n            if random.random() < self.goal_sample_rate:\n                return goal_pos\n            else:\n                return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n\n        def adaptive_radius(tree_size):\n            n = max(tree_size, 1)\n            radius = self.base_radius * (math.log(n)/n)**(1.0/dim)\n            min_radius = self.step_size * 1.5\n            return max(radius, min_radius)\n\n        def local_shortcut(path):\n            if len(path) < 3:\n                return path[:]\n            new_path = path[:]\n            attempts = 0\n            while attempts < self.local_shortcut_attempts:\n                if len(new_path) < 3:\n                    break\n                i = random.randint(0, len(new_path) - 3)\n                j = random.randint(i + 2, len(new_path) - 1)\n                p1, p2 = new_path[i], new_path[j]\n                if not is_edge_in_obstacle(p1, p2):\n                    new_path = new_path[:i+1] + new_path[j:]\n                    attempts = 0\n                else:\n                    attempts += 1\n            return new_path\n\n        connection_node_start = None\n        connection_node_goal = None\n        success = False\n\n        for itr in range(self.max_iter):\n            # Alternate expansion\n            for (tree_a, tree_b) in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                q_rand = sample_point()\n                nearest_node = nearest(tree_a, q_rand)\n                q_new_pos = steer(nearest_node.position, q_rand)\n                if is_in_obstacle(q_new_pos):\n                    continue\n                if is_edge_in_obstacle(nearest_node.position, q_new_pos):\n                    continue\n\n                radius = adaptive_radius(len(tree_a))\n                near_nodes_a = near_nodes(tree_a, q_new_pos, radius)\n\n                min_cost = nearest_node.cost + dist(nearest_node.position, q_new_pos)\n                min_parent = nearest_node\n                for near in near_nodes_a:\n                    c = near.cost + dist(near.position, q_new_pos)\n                    if c < min_cost and not is_edge_in_obstacle(near.position, q_new_pos):\n                        min_cost = c\n                        min_parent = near\n\n                q_new = Node(q_new_pos, parent=min_parent, cost=min_cost)\n                min_parent.add_child(q_new)\n                tree_a.append(q_new)\n                nodes.append(q_new)\n                edges.append((min_parent, q_new))\n\n                rewire(tree_a, q_new, near_nodes_a)\n\n                # Attempt connection with other tree\n                nearest_in_other = nearest(tree_b, q_new.position)\n                dist_to_other = dist(q_new.position, nearest_in_other.position)\n                radius_conn = max(self.step_size * 1.5, adaptive_radius(len(tree_b)))\n                if dist_to_other <= radius_conn and not is_edge_in_obstacle(q_new.position, nearest_in_other.position):\n                    if tree_a is start_tree:\n                        connection_node_start, connection_node_goal = q_new, nearest_in_other\n                    else:\n                        connection_node_start, connection_node_goal = nearest_in_other, q_new\n                    success = True\n                    break\n\n            # Incremental local shortcutting if a connection found\n            if success:\n                raw_path = extract_path(connection_node_start, connection_node_goal)\n                improved_path = local_shortcut(raw_path)\n\n                # If improvement shortens path cost, update connection nodes parent chain accordingly\n                # This is done by replacing nodes on path with new simpler chain if better\n                # For efficiency, only store final smoothed path\n\n                # Return improved solution early for speed\n                return self._result(True, improved_path, nodes, edges)\n\n        # On failure, return best partial if any connection (non necessarily success)\n        if connection_node_start and connection_node_goal:\n            raw_path = extract_path(connection_node_start, connection_node_goal)\n            improved_path = local_shortcut(raw_path)\n            return self._result(True, improved_path, nodes, edges)\n\n        # No path found\n        return self._result(False, [], nodes, edges)\n\n    def _result(self, success, path, nodes, edges):\n        # PlannerResult must be defined externally in environment\n        return PlannerResult(success, path, nodes, edges)",
            "objective": -33.95507,
            "time_improvement": 61.0,
            "length_improvement": 14.0,
            "smoothness_improvement": 1487.0,
            "node_improvement": 70.0,
            "other_inf": [
                {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.010840678215026855,
                    "num_nodes_avg": 108.5,
                    "path_length_avg": 171.66948645779462,
                    "smoothness_avg": 0.03037023005591788,
                    "success_improvement": 0.0,
                    "time_improvement": 57.96689607994491,
                    "node_improvement": 72.67690757995467,
                    "length_improvement": 5.905234195391321,
                    "smoothness_improvement": 375.36005038524775,
                    "objective_score": 22.810009593144503
                },
                {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.03051626682281494,
                    "num_nodes_avg": 329.8,
                    "path_length_avg": 234.6106758602652,
                    "smoothness_avg": 0.10438344350479727,
                    "success_improvement": 0.0,
                    "time_improvement": 81.56959762974842,
                    "node_improvement": 77.84048914869314,
                    "length_improvement": 21.68020350396321,
                    "smoothness_improvement": 2585.8611857338155,
                    "objective_score": 50.40830731997153
                },
                {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.029309940338134766,
                    "num_nodes_avg": 310.9,
                    "path_length_avg": 129.2870965574641,
                    "smoothness_avg": 0.12568844803562226,
                    "success_improvement": 0.0,
                    "time_improvement": 42.24321361941394,
                    "node_improvement": 60.47043865225684,
                    "length_improvement": 14.133666456496211,
                    "smoothness_improvement": 1498.7477816569226,
                    "objective_score": 28.64690286800652
                }
            ],
            "success_rate": 1.0
        },
        "objective": 34.6,
        "analysis": {
            "problem": [
                ""
            ],
            "solution": "1. Primary contributors to the performance improvement:\n   - Introduction of adaptive rewiring radius ensuring efficient local connectivity and cost improvements.\n   - More dynamic and higher goal bias sampling leading to faster tree connection and improved path finding speed.\n   - Incremental local shortcutting integrated within the planning loop allowing early and continual path refinement.\n   - Robust edge and parent-child relationship updates preventing inconsistencies and reducing unnecessary rewiring.\n   - Simplified nearest neighbor neighbor searches avoiding fallback to costly exhaustive checks.\n\n2. Expected mechanism of impact:\n   - Adaptive rewiring enhances local optimization without excessive computations, accelerating convergence and reducing path length.\n   - Increased goal bias prioritizes sampling near the goal, improving chances of early successful connections and lowering total planning time.\n   - Early incremental smoothing removes detours and sharp turns progressively, improving path smoothness and reducing the need for expensive global smoothing.\n   - Stable edge management prevents redundant operations and inconsistent graph states, streamlining rewire operations and decreasing runtime.\n   - Efficient neighbor retrieval cuts down on computational overhead from collision checks and distance calculations, speeding up sampling and extension steps."
        }
    },
    {
        "parents": [
            {
                "operator": "initial",
                "algorithm_description": "This algorithm grows two trees simultaneously, one from the start position and one from the goal position, and attempts to connect them to find a feasible path. This bidirectional approach accelerates convergence and increases the success rate compared to a single tree RRT.",
                "planning_mechanism": "The planning mechanism involves randomly sampling points within the map bounds, extending each tree towards the sampled points, and attempting to connect the two trees whenever new nodes are added. Collision checks are performed for nodes and edges to ensure safety, and once the two trees connect, the final path is reconstructed by backtracking through the parent nodes of each tree.",
                "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map) -> PlannerResult:\n        import math, random\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position)\n        goal_root = Node(goal_position)\n        nodes.extend([start_root, goal_root])\n        tree_a, tree_b = [start_root], [goal_root]\n\n        for _ in range(self.max_iter):\n            rand_point = self._sample_free(bounds, obstacles, is_3d)\n            new_a = self._extend_tree(tree_a, rand_point, obstacles, is_3d, nodes, edges)\n            if new_a is None:\n                continue\n\n            new_b = self._connect_trees(tree_b, new_a, obstacles, is_3d, nodes, edges)\n            if new_b:\n                success_state = True\n                path_a = new_a.path_from_root()\n                path_b = new_b.path_from_root()\n                extracted_path = path_a + path_b[::-1]\n                break\n\n            tree_a, tree_b = tree_b, tree_a  # Swap trees\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        import random\n        while True:\n            if is_3d:\n                p = (random.uniform(0, bounds[0]),\n                     random.uniform(0, bounds[1]),\n                     random.uniform(0, bounds[2]))\n            else:\n                p = (random.uniform(0, bounds[0]),\n                     random.uniform(0, bounds[1]))\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    def _nearest(self, tree, point):\n        import math\n        return min(tree, key=lambda node: math.dist(node.position, point))\n\n    def _steer(self, from_pos, to_pos):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _extend_tree(self, tree, point, obstacles, is_3d, nodes, edges):\n        nearest_node = self._nearest(tree, point)\n        new_pos = self._steer(nearest_node.position, point)\n        if not self._is_in_obstacle(new_pos, obstacles, is_3d) and not self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n            new_node = Node(new_pos, parent=nearest_node)\n            nearest_node.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n            return new_node\n        return None\n\n    def _connect_trees(self, tree, new_node, obstacles, is_3d, nodes, edges):\n        import math\n        nearest_node = self._nearest(tree, new_node.position)\n        while True:\n            new_pos = self._steer(nearest_node.position, new_node.position)\n            if (not self._is_in_obstacle(new_pos, obstacles, is_3d) and\n                not self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d)):\n                next_node = Node(new_pos, parent=nearest_node)\n                nearest_node.add_child(next_node)\n                tree.append(next_node)\n                nodes.append(next_node)\n                edges.append((nearest_node, next_node))\n\n                if math.dist(next_node.position, new_node.position) <= self.step_size:\n                    if not self._is_edge_in_obstacle(next_node.position, new_node.position, obstacles, is_3d):\n                        final_node = Node(new_node.position, parent=next_node)\n                        next_node.add_child(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((next_node, final_node))\n                        return final_node\n                    else:\n                        return None\n                nearest_node = next_node\n            else:\n                return None\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n",
                "objective": -26.16492572596105,
                "time_improvement": 92.0,
                "length_improvement": -3.0,
                "smoothness_improvement": 63.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.003008270263671875,
                        "num_nodes_avg": 68.1,
                        "path_length_avg": 184.17006126805845,
                        "smoothness_avg": 0.01054995558932253,
                        "success_improvement": 0.0,
                        "time_improvement": 88.33588322571401,
                        "node_improvement": 82.85066733820196,
                        "length_improvement": -0.9465289423981464,
                        "smoothness_improvement": 65.12971456814059,
                        "objective_score": 26.25849617511602
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.008660387992858887,
                        "num_nodes_avg": 222.5,
                        "path_length_avg": 300.8164456420612,
                        "smoothness_avg": 0.0064472474436514295,
                        "success_improvement": 0.0,
                        "time_improvement": 94.76952943432936,
                        "node_improvement": 85.05005711214136,
                        "length_improvement": -0.4211880766230819,
                        "smoothness_improvement": 65.89232048978258,
                        "objective_score": 28.50760758677387
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.0042524576187133786,
                        "num_nodes_avg": 126.3,
                        "path_length_avg": 160.72624335922288,
                        "smoothness_avg": 0.012431076585876402,
                        "success_improvement": 0.0,
                        "time_improvement": 91.62030753242554,
                        "node_improvement": 83.94151303242214,
                        "length_improvement": -6.746717877938324,
                        "smoothness_improvement": 58.122376605720596,
                        "objective_score": 23.72867341599327
                    }
                ],
                "success_rate": 1.0
            },
            {
                "operator": "m2",
                "algorithm_description": "This algorithm is an enhanced bidirectional RRT* planner that incorporates adaptive rewiring radius, smarter sampling strategies incorporating goal bias and informed sampling, and a post-processing path smoothing stage using shortcutting to greatly improve path smoothness, length, and planning efficiency. It grows two trees from start and goal, alternates expansion, rewires locally for optimality, attempts early connection, and finally smooths the extracted path for a low-cost, feasible, and smooth trajectory.",
                "planning_mechanism": "The planner uses bidirectional RRT* with adaptive rewiring radius based on the logarithm of tree size for asymptotic optimality and faster rewiring, samples with a goal bias probability to focus exploration, uses a connection radius scaled to domain size, and applies a shortcut smoothing post-processing on the constructed path. Trees are alternately expanded toward random samples or the opposing tree's nearest nodes to encourage faster convergence and connection. Collision checks are extensive but efficient with early rejections.",
                "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        node, path = self, []\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=5.0, base_radius=15.0, goal_sample_rate=0.1, shortcut_iterations=150):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.base_radius = base_radius\n        self.goal_sample_rate = goal_sample_rate\n        self.shortcut_iterations = shortcut_iterations\n\n    def plan(self, map) -> 'PlannerResult':\n        import random, math\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        def dist(a,b):\n            return math.dist(a,b)\n\n        def steer(fr, to):\n            d = dist(fr, to)\n            if d <= self.step_size:\n                return to\n            ratio = self.step_size / d\n            return tuple(fr[i] + (to[i] - fr[i]) * ratio for i in range(dim))\n\n        def is_in_obstacle(p):\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d_ = obs\n                    px,py,pz = p\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d_:\n                        return True\n                else:\n                    x,y,w,h = obs\n                    px,py = p\n                    if x <= px <= x+w and y <= py <= y+h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(fr,to, resolution=1.0):\n            d = dist(fr,to)\n            steps = max(1, int(d / resolution))\n            for i in range(steps + 1):\n                interp = tuple(fr[j] + (to[j] - fr[j]) * i / steps for j in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: dist(node.position, point))\n\n        def near_nodes(tree, point, radius):\n            return [node for node in tree if dist(node.position, point) <= radius]\n\n        def rewire(tree, new_node, near_nodes_):\n            nonlocal edges\n            for near in near_nodes_:\n                if near == new_node.parent:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, near.position)\n                if new_cost + 1e-7 < near.cost:\n                    if not is_edge_in_obstacle(new_node.position, near.position):\n                        # Remove old edge\n                        if near.parent is not None:\n                            try:\n                                edges.remove((near.parent, near))\n                            except Exception:\n                                pass\n                        near.parent.children.remove(near) if near.parent else None\n                        near.parent = new_node\n                        near.cost = new_cost\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n\n        def extract_path(node_from_start, node_from_goal):\n            path_start = node_from_start.path_from_root()\n            path_goal = node_from_goal.path_from_root()[::-1]\n            if len(path_start) > 0 and len(path_goal) > 0 and path_start[-1] == path_goal[0]:\n                path_goal = path_goal[1:]\n            return path_start + path_goal\n\n        def sample_point():\n            if random.random() < self.goal_sample_rate:\n                return goal_pos\n            else:\n                return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n\n        def shortcut_path(path):\n            # Attempts shortcutting to reduce sharp turns and improve smoothness\n            for _ in range(self.shortcut_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i+2, len(path) -1)\n                p1, p2 = path[i], path[j]\n                if not is_edge_in_obstacle(p1, p2):\n                    # shortcut successful: remove intermediate points between i and j\n                    path = path[:i+1] + path[j:]\n            return path\n\n        def adaptive_radius(tree_size):\n            # follow RRT* inspired radius scaling: gamma*(log(n)/n)^(1/d)\n            gamma = self.base_radius\n            n = max(tree_size, 1)\n            radius = gamma * (math.log(n)/n)**(1.0/dim)\n            return max(radius, self.step_size*1.5)\n\n        success = False\n        connection_pair = (None, None)\n\n        # Alternate which is tree A and tree B\n        for it in range(self.max_iter):\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                q_rand = sample_point()\n                nearest_node = nearest(tree_a, q_rand)\n                q_new_pos = steer(nearest_node.position, q_rand)\n                if is_in_obstacle(q_new_pos):\n                    continue\n                if is_edge_in_obstacle(nearest_node.position, q_new_pos):\n                    continue\n\n                # Rewiring radius adaptive\n                radius = adaptive_radius(len(tree_a))\n\n                # Find near nodes in tree_a for rewiring\n                near_nodes_a = near_nodes(tree_a, q_new_pos, radius)\n\n                # Choose best parent minimizing cost\n                min_cost = nearest_node.cost + dist(nearest_node.position, q_new_pos)\n                min_parent = nearest_node\n                for near_node in near_nodes_a:\n                    c = near_node.cost + dist(near_node.position, q_new_pos)\n                    if c < min_cost and not is_edge_in_obstacle(near_node.position, q_new_pos):\n                        min_cost = c\n                        min_parent = near_node\n\n                q_new = Node(q_new_pos, parent=min_parent, cost=min_cost)\n                min_parent.add_child(q_new)\n                tree_a.append(q_new)\n                nodes.append(q_new)\n                edges.append((min_parent, q_new))\n\n                # Rewire neighbors for improved costs\n                rewire(tree_a, q_new, near_nodes_a)\n\n                # Attempt connection to other tree\n                nearest_to_new = nearest(tree_b, q_new.position)\n                dist_connect = dist(q_new.position, nearest_to_new.position)\n                radius_connect = max(self.step_size*1.5, adaptive_radius(len(tree_b)))\n                if dist_connect <= radius_connect and not is_edge_in_obstacle(q_new.position, nearest_to_new.position):\n                    # Connected trees successfully\n                    if tree_a is start_tree:\n                        node_start, node_goal = q_new, nearest_to_new\n                    else:\n                        node_start, node_goal = nearest_to_new, q_new\n                    success = True\n                    connection_pair = (node_start, node_goal)\n                    break\n            if success:\n                break\n\n        path = []\n        if success:\n            raw_path = extract_path(connection_pair[0], connection_pair[1])\n            path = shortcut_path(raw_path)\n\n        return PlannerResult(success, path, nodes, edges)",
                "objective": -33.9861,
                "time_improvement": 56.0,
                "length_improvement": 16.0,
                "smoothness_improvement": 1519.0,
                "node_improvement": 69.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.01380462646484375,
                        "num_nodes_avg": 128.7,
                        "path_length_avg": 166.57538852397772,
                        "smoothness_avg": 0.04015959576609991,
                        "success_improvement": 0.0,
                        "time_improvement": 46.47463126707311,
                        "node_improvement": 67.59002770083103,
                        "length_improvement": 8.697389994063707,
                        "smoothness_improvement": 528.5848816974815,
                        "objective_score": 21.803747785047563
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.028153705596923827,
                        "num_nodes_avg": 317.3,
                        "path_length_avg": 238.40919577619638,
                        "smoothness_avg": 0.10655923140396159,
                        "success_improvement": 0.0,
                        "time_improvement": 82.9964744581085,
                        "node_improvement": 78.68037358059532,
                        "length_improvement": 20.412148221691805,
                        "smoothness_improvement": 2641.8457755359923,
                        "objective_score": 50.35546014812759
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.031368589401245116,
                        "num_nodes_avg": 304.4,
                        "path_length_avg": 121.92947455845565,
                        "smoothness_avg": 0.11683997631770895,
                        "success_improvement": 0.0,
                        "time_improvement": 38.186536846996304,
                        "node_improvement": 61.29688493324858,
                        "length_improvement": 19.020248655927677,
                        "smoothness_improvement": 1386.1958745313084,
                        "objective_score": 29.79908962031204
                    }
                ],
                "success_rate": 1.0
            }
        ],
        "offspring": {
            "operator": "m1",
            "algorithm_description": "Enhanced Bidirectional RRT* with Adaptive Radius, Informed Sampling, Efficient Collision Checking, and B-Spline Path Smoothing for Improved Planning Efficiency, Path Length, and Notably Smooth and Feasible Paths",
            "planning_mechanism": "This planner employs a bidirectional RRT* framework with adaptive rewiring radius based on tree size for asymptotic optimality. It uses goal bias and informed sampling within an ellipsoidal subset to concentrate sampling in promising regions. It alternates between trees for balanced growth and rewires local neighborhoods to optimize paths continuously. After tree connection, it reconstructs the path and applies B-spline smoothing to produce smooth, curvature-continuous trajectories, while maintaining rigorous collision checks on nodes and edges. Early termination is triggered on successful connection to improve search efficiency.",
            "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        node, path = self, []\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=7.0, base_radius=20.0, goal_sample_rate=0.15, smoothing_degree=3, smoothing_points=100):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.base_radius = base_radius\n        self.goal_sample_rate = goal_sample_rate\n        self.smoothing_degree = smoothing_degree\n        self.smoothing_points = smoothing_points\n\n    def plan(self, map):\n        import math\n        import random\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        def dist(a,b):\n            return math.dist(a,b)\n\n        def steer(fr, to):\n            d = dist(fr, to)\n            if d <= self.step_size:\n                return to\n            ratio = self.step_size / d\n            return tuple(fr[i] + (to[i] - fr[i]) * ratio for i in range(dim))\n\n        def is_in_obstacle(p):\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d_ = obs\n                    px,py,pz = p\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d_:\n                        return True\n                else:\n                    x,y,w,h = obs\n                    px,py = p\n                    if x <= px <= x+w and y <= py <= y+h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(fr,to, resolution=1.0):\n            d = dist(fr,to)\n            steps = max(1, int(d / resolution))\n            for i in range(steps + 1):\n                interp = tuple(fr[j] + (to[j] - fr[j]) * i / steps for j in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: dist(node.position, point))\n\n        def near_nodes(tree, point, radius):\n            return [node for node in tree if dist(node.position, point) <= radius]\n\n        def rewire(tree, new_node, near_nodes_list):\n            nonlocal edges\n            for near in near_nodes_list:\n                if near == new_node.parent:\n                    continue\n                c = new_node.cost + dist(new_node.position, near.position)\n                if c + 1e-10 < near.cost and not is_edge_in_obstacle(new_node.position, near.position):\n                    old_parent = near.parent\n                    if old_parent:\n                        try:\n                            edges.remove((old_parent, near))\n                        except ValueError:\n                            pass\n                        old_parent.children.remove(near)\n                    near.parent = new_node\n                    near.cost = c\n                    new_node.add_child(near)\n                    edges.append((new_node, near))\n\n        def extract_path(node_start, node_goal):\n            path_start = node_start.path_from_root()\n            path_goal = node_goal.path_from_root()[::-1]\n            if len(path_start) > 0 and len(path_goal) > 0 and path_start[-1] == path_goal[0]:\n                path_goal = path_goal[1:]\n            return path_start + path_goal\n\n        def adaptive_radius(tree_size):\n            gamma = self.base_radius\n            n = max(tree_size, 1)\n            return max(gamma * (math.log(n)/n)**(1.0/dim), self.step_size*1.5)\n\n        def informed_sample(c_best, c_min, start, goal):\n            # If no solution found yet, sample uniformly\n            if c_best == float('inf'):\n                return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n            # Ellipsoidal informed sampling\n            import numpy as np\n            c = c_best\n            center = tuple((start[i] + goal[i])/2 for i in range(dim))\n            a1 = tuple((goal[i] - start[i])/c_min for i in range(dim))\n            if dim == 2:\n                # Build rotation matrix to align x-axis with a1\n                theta = math.atan2(a1[1], a1[0])\n                r = [[math.cos(theta), -math.sin(theta)],\n                     [math.sin(theta),  math.cos(theta)]]\n                while True:\n                    # Sample uniformly in unit circle\n                    x, y = random.random()*2 -1, random.random()*2 -1\n                    if x**2 + y**2 > 1: \n                        continue\n                    # Scale according to ellipse axes\n                    rx = c/2\n                    ry = math.sqrt(c**2 - c_min**2)/2\n                    sample_ellipse = (x*rx, y*ry)\n                    # Rotate and translate sample\n                    px = r[0][0]*sample_ellipse[0] + r[0][1]*sample_ellipse[1] + center[0]\n                    py = r[1][0]*sample_ellipse[0] + r[1][1]*sample_ellipse[1] + center[1]\n                    if 0 <= px <= bounds[0] and 0 <= py <= bounds[1]:\n                        return (px, py)\n            else:  # In 3D or higher, fallback uniform sampling due to complexity\n                return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n\n        # B-spline smoothing using De Boor's algorithm (degree=3) for smoothness enhancement\n        def bspline(points, degree=3, num=100):\n            if len(points) <= degree:\n                return points[:]\n            import numpy as np\n            points_np = np.array(points)\n            n = len(points_np) - 1\n            k = degree\n            domain = np.linspace(0, n - k + 1, num)\n            knots = np.concatenate(([0]*k, np.arange(n - k + 2), [n - k + 2]*k))\n\n            def de_boor(t, k, i, x):\n                if k == 0:\n                    return x[i]\n                alpha = (t - knots[i])/(knots[i+k] - knots[i]) if knots[i+k] != knots[i] else 0\n                return (1.0 - alpha) * de_boor(t, k-1, i-1, x) + alpha * de_boor(t, k-1, i, x)\n\n            spline = []\n            for t in domain:\n                i = next(i for i in range(len(knots)-1) if knots[i] <= t < knots[i+1])\n                spline.append(tuple(de_boor(t, k, i, points_np)))\n            return spline\n\n        # Initialize best cost to infinite, update when path found\n        best_cost = float('inf')\n        connection_nodes = (None, None)\n        success = False\n\n        for iteration in range(self.max_iter):\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                if success:\n                    break\n\n                # Choose informed sampling with goal bias\n                sample_prob = random.random()\n                if sample_prob < self.goal_sample_rate:\n                    q_rand = goal_pos\n                else:\n                    q_rand = informed_sample(best_cost, dist(start_pos, goal_pos), start_pos, goal_pos)\n\n                nearest_node = nearest(tree_a, q_rand)\n                q_new_pos = steer(nearest_node.position, q_rand)\n\n                if is_in_obstacle(q_new_pos) or is_edge_in_obstacle(nearest_node.position, q_new_pos):\n                    continue\n\n                radius = adaptive_radius(len(tree_a))\n                near_nodes_a = near_nodes(tree_a, q_new_pos, radius)\n\n                # Choose parent minimizing cost\n                min_cost = nearest_node.cost + dist(nearest_node.position, q_new_pos)\n                min_parent = nearest_node\n                for near_n in near_nodes_a:\n                    c = near_n.cost + dist(near_n.position, q_new_pos)\n                    if c + 1e-10 < min_cost and not is_edge_in_obstacle(near_n.position, q_new_pos):\n                        min_cost = c\n                        min_parent = near_n\n\n                q_new = Node(q_new_pos, parent=min_parent, cost=min_cost)\n                min_parent.add_child(q_new)\n                tree_a.append(q_new)\n                nodes.append(q_new)\n                edges.append((min_parent, q_new))\n\n                rewire(tree_a, q_new, near_nodes_a)\n\n                # Attempt connection to other tree\n                nearest_other = nearest(tree_b, q_new.position)\n                dist_connect = dist(q_new.position, nearest_other.position)\n                radius_connect = max(self.step_size*1.5, adaptive_radius(len(tree_b)))\n\n                if dist_connect <= radius_connect and not is_edge_in_obstacle(q_new.position, nearest_other.position):\n                    # Trees connected\n                    if tree_a is start_tree:\n                        node_start, node_goal = q_new, nearest_other\n                    else:\n                        node_start, node_goal = nearest_other, q_new\n\n                    current_cost = node_start.cost + dist(node_start.position, node_goal.position) + node_goal.cost\n                    if current_cost < best_cost:\n                        best_cost = current_cost\n                        connection_nodes = (node_start, node_goal)\n                        success = True\n            if success:\n                break\n\n        raw_path = []\n        if success:\n            raw_path = extract_path(connection_nodes[0], connection_nodes[1])\n        else:\n            # fallback empty path on failure\n            return PlannerResult(False, [], nodes, edges)\n\n        # B-spline smoothing with collision checking along spline (dense checks)\n        smooth_path = raw_path\n        if len(raw_path) > self.smoothing_degree:\n            try:\n                # We implement smoothing only if numpy is available, else fallback raw_path\n                import numpy as np\n                spline_path = bspline(raw_path, degree=self.smoothing_degree, num=self.smoothing_points)\n                # Check collision for spline curve segments\n                collides = False\n                for i in range(len(spline_path)-1):\n                    if is_edge_in_obstacle(spline_path[i], spline_path[i+1]):\n                        collides = True\n                        break\n                if not collides:\n                    smooth_path = spline_path\n            except:\n                # If numpy not available, fallback to raw_path (no smoothing)\n                smooth_path = raw_path\n\n        return PlannerResult(success, smooth_path, nodes, edges)",
            "objective": -25.01284,
            "time_improvement": 66.0,
            "length_improvement": 7.0,
            "smoothness_improvement": 169.0,
            "node_improvement": 74.0,
            "other_inf": [
                {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.00990746021270752,
                    "num_nodes_avg": 117.2,
                    "path_length_avg": 177.87723139341853,
                    "smoothness_avg": 0.016505675329957482,
                    "success_improvement": 0.0,
                    "time_improvement": 61.58530892215819,
                    "node_improvement": 70.48602367161925,
                    "length_improvement": 2.5026708281624948,
                    "smoothness_improvement": 158.34966156149508,
                    "objective_score": 20.768943481352427
                },
                {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.014815974235534667,
                    "num_nodes_avg": 199.2,
                    "path_length_avg": 264.58410600917347,
                    "smoothness_avg": 0.01090878033876496,
                    "success_improvement": 0.0,
                    "time_improvement": 91.05184234186756,
                    "node_improvement": 86.61560169320701,
                    "length_improvement": 11.67420978290656,
                    "smoothness_improvement": 180.69077539330692,
                    "objective_score": 35.223532449270735
                },
                {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.027541279792785645,
                    "num_nodes_avg": 285.0,
                    "path_length_avg": 139.32127743918858,
                    "smoothness_avg": 0.02116118022862008,
                    "success_improvement": 0.0,
                    "time_improvement": 45.72845269254134,
                    "node_improvement": 63.76350921805467,
                    "length_improvement": 7.469441291202562,
                    "smoothness_improvement": 169.16865055219935,
                    "objective_score": 19.046043835244934
                }
            ],
            "success_rate": 1.0
        },
        "objective": 50.0,
        "analysis": {
            "problem": [
                "Problem of the parents algorithm:\n   - Inefficient node expansion and connection strategies causing high computational overhead and prolonged planning time.\n   - Absence or limited use of informed sampling to focus exploration in promising regions.\n   - Simplistic or absent path smoothing leading to jagged trajectories with abrupt turns.\n   - Lack of adaptive rewiring radius and suboptimal rewiring logic, resulting in less optimal path lengths and connectivity.\n   - Redundant or insufficient collision checking causing unnecessary computational expense.\n   - Path concatenation without removing duplicate nodes, potentially elongating final paths."
            ],
            "solution": "1. Primary contributors to the performance improvement:\n   - Incorporation of informed sampling to guide exploration within ellipsoidal subsets, increasing sampling efficiency.\n   - Adaptive rewiring radius based on the size of the trees, improving optimal path convergence.\n   - Robust rewiring mechanism with precise parent selection to minimize path costs and maintain efficient tree structure.\n   - Implementation of B-spline based path smoothing post path-extraction to produce smooth, curvature-continuous paths.\n   - Enhanced collision checking along the smoothed trajectory ensuring feasibility without excessive overhead.\n2. Expected mechanism of impact:\n   - Focused sampling reduces wasted iterations in irrelevant space, accelerating convergence and reducing planning time.\n   - Adaptive rewiring fosters the refinement of paths to be shorter and smoother by continuously optimizing locally.\n   - Smoothing eliminates sharp turns and jagged segments, dramatically improving path smoothness metric.\n   - Efficient collision checking on spline segments prevents invalid smooth paths, maintaining feasibility.\n   - The combination of these strategies leads to a balanced planner achieving faster planning speeds, improved path quality, and notably smoother trajectories."
        }
    },
    {
        "parents": [
            {
                "operator": "initial",
                "algorithm_description": "This algorithm grows two trees simultaneously, one from the start position and one from the goal position, and attempts to connect them to find a feasible path. This bidirectional approach accelerates convergence and increases the success rate compared to a single tree RRT.",
                "planning_mechanism": "The planning mechanism involves randomly sampling points within the map bounds, extending each tree towards the sampled points, and attempting to connect the two trees whenever new nodes are added. Collision checks are performed for nodes and edges to ensure safety, and once the two trees connect, the final path is reconstructed by backtracking through the parent nodes of each tree.",
                "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map) -> PlannerResult:\n        import math, random\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position)\n        goal_root = Node(goal_position)\n        nodes.extend([start_root, goal_root])\n        tree_a, tree_b = [start_root], [goal_root]\n\n        for _ in range(self.max_iter):\n            rand_point = self._sample_free(bounds, obstacles, is_3d)\n            new_a = self._extend_tree(tree_a, rand_point, obstacles, is_3d, nodes, edges)\n            if new_a is None:\n                continue\n\n            new_b = self._connect_trees(tree_b, new_a, obstacles, is_3d, nodes, edges)\n            if new_b:\n                success_state = True\n                path_a = new_a.path_from_root()\n                path_b = new_b.path_from_root()\n                extracted_path = path_a + path_b[::-1]\n                break\n\n            tree_a, tree_b = tree_b, tree_a  # Swap trees\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        import random\n        while True:\n            if is_3d:\n                p = (random.uniform(0, bounds[0]),\n                     random.uniform(0, bounds[1]),\n                     random.uniform(0, bounds[2]))\n            else:\n                p = (random.uniform(0, bounds[0]),\n                     random.uniform(0, bounds[1]))\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    def _nearest(self, tree, point):\n        import math\n        return min(tree, key=lambda node: math.dist(node.position, point))\n\n    def _steer(self, from_pos, to_pos):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _extend_tree(self, tree, point, obstacles, is_3d, nodes, edges):\n        nearest_node = self._nearest(tree, point)\n        new_pos = self._steer(nearest_node.position, point)\n        if not self._is_in_obstacle(new_pos, obstacles, is_3d) and not self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n            new_node = Node(new_pos, parent=nearest_node)\n            nearest_node.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n            return new_node\n        return None\n\n    def _connect_trees(self, tree, new_node, obstacles, is_3d, nodes, edges):\n        import math\n        nearest_node = self._nearest(tree, new_node.position)\n        while True:\n            new_pos = self._steer(nearest_node.position, new_node.position)\n            if (not self._is_in_obstacle(new_pos, obstacles, is_3d) and\n                not self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d)):\n                next_node = Node(new_pos, parent=nearest_node)\n                nearest_node.add_child(next_node)\n                tree.append(next_node)\n                nodes.append(next_node)\n                edges.append((nearest_node, next_node))\n\n                if math.dist(next_node.position, new_node.position) <= self.step_size:\n                    if not self._is_edge_in_obstacle(next_node.position, new_node.position, obstacles, is_3d):\n                        final_node = Node(new_node.position, parent=next_node)\n                        next_node.add_child(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((next_node, final_node))\n                        return final_node\n                    else:\n                        return None\n                nearest_node = next_node\n            else:\n                return None\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n",
                "objective": -26.16492572596105,
                "time_improvement": 92.0,
                "length_improvement": -3.0,
                "smoothness_improvement": 63.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.003008270263671875,
                        "num_nodes_avg": 68.1,
                        "path_length_avg": 184.17006126805845,
                        "smoothness_avg": 0.01054995558932253,
                        "success_improvement": 0.0,
                        "time_improvement": 88.33588322571401,
                        "node_improvement": 82.85066733820196,
                        "length_improvement": -0.9465289423981464,
                        "smoothness_improvement": 65.12971456814059,
                        "objective_score": 26.25849617511602
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.008660387992858887,
                        "num_nodes_avg": 222.5,
                        "path_length_avg": 300.8164456420612,
                        "smoothness_avg": 0.0064472474436514295,
                        "success_improvement": 0.0,
                        "time_improvement": 94.76952943432936,
                        "node_improvement": 85.05005711214136,
                        "length_improvement": -0.4211880766230819,
                        "smoothness_improvement": 65.89232048978258,
                        "objective_score": 28.50760758677387
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.0042524576187133786,
                        "num_nodes_avg": 126.3,
                        "path_length_avg": 160.72624335922288,
                        "smoothness_avg": 0.012431076585876402,
                        "success_improvement": 0.0,
                        "time_improvement": 91.62030753242554,
                        "node_improvement": 83.94151303242214,
                        "length_improvement": -6.746717877938324,
                        "smoothness_improvement": 58.122376605720596,
                        "objective_score": 23.72867341599327
                    }
                ],
                "success_rate": 1.0
            },
            {
                "operator": "initial",
                "algorithm_description": "This algorithm is a bidirectional extension of RRT* that grows two trees from start and goal while optimizing paths via rewiring. It combines RRT*\u2018s asymptotic optimality with RRT-Connect\u2019s fast convergence through connection attempts between the trees.",
                "planning_mechanism": "The planner alternates growing two trees with sampling, extension, and rewiring. After each extension, it attempts to connect both trees. When connection is successful, a rewired optimal path is extracted across both trees.",
                "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, radius: float = 10.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.radius = radius\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n        nodes = []\n        edges = []\n        success_state = False\n        extracted_path = []\n\n        for iter in range(self.max_iter):\n            rand = self._sample_free(bounds, obstacles, is_3d)\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest = self._nearest(tree_a, rand)\n                new_pos = self._steer(nearest.position, rand, self.step_size)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                    continue\n\n                new_node = Node(new_pos)\n                near_nodes = self._near(tree_a, new_pos, self.radius)\n                min_cost = nearest.cost + self._distance(nearest.position, new_pos)\n                min_parent = nearest\n\n                for near in near_nodes:\n                    cost = near.cost + self._distance(near.position, new_pos)\n                    if cost < min_cost and not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d):\n                        min_cost = cost\n                        min_parent = near\n\n                new_node.parent = min_parent\n                new_node.cost = min_cost\n                min_parent.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((min_parent, new_node))\n\n                for near in near_nodes:\n                    if near == min_parent:\n                        continue\n                    new_cost = new_node.cost + self._distance(new_node.position, near.position)\n                    if new_cost < near.cost and not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                        if near.parent:\n                            edges.remove((near.parent, near))\n                        near.parent = new_node\n                        near.cost = new_cost\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n\n                connect_node = self._nearest(tree_b, new_node.position)\n                if self._distance(new_node.position, connect_node.position) < self.step_size and not self._is_edge_in_obstacle(new_node.position, connect_node.position, obstacles, is_3d):\n                    success_state = True\n                    extracted_path = self._extract_path(new_node, connect_node)\n                    return PlannerResult(True, extracted_path, start_tree + goal_tree, edges)\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        while True:\n            point = tuple(random.uniform(0, bounds[i]) for i in range(3 if is_3d else 2))\n            if not self._is_in_obstacle(point, obstacles, is_3d):\n                return point\n\n    def _nearest(self, tree, point):\n        return min(tree, key=lambda node: self._distance(node.position, point))\n\n    def _near(self, tree, point, radius):\n        return [node for node in tree if self._distance(node.position, point) <= radius]\n\n    def _steer(self, from_pos, to_pos, step_size):\n        dist = self._distance(from_pos, to_pos)\n        if dist <= step_size:\n            return to_pos\n        ratio = step_size / dist\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n    def _extract_path(self, node_a, node_b):\n        path_a = []\n        while node_a:\n            path_a.append(node_a.position)\n            node_a = node_a.parent\n        path_b = []\n        while node_b:\n            path_b.append(node_b.position)\n            node_b = node_b.parent\n        return list(reversed(path_a)) + path_b\n\n    def _distance(self, a, b):\n        return math.dist(a, b)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = self._distance(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n    ",
                "objective": -26.062040773062417,
                "time_improvement": 66.0,
                "length_improvement": 9.0,
                "smoothness_improvement": 167.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.012016057968139648,
                        "num_nodes_avg": 134.5,
                        "path_length_avg": 175.84673815929608,
                        "smoothness_avg": 0.016310939143948412,
                        "success_improvement": 0.0,
                        "time_improvement": 53.409537367863955,
                        "node_improvement": 66.1294384286074,
                        "length_improvement": 3.6156163450092893,
                        "smoothness_improvement": 155.30161737405683,
                        "objective_score": 18.96873910423504
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.018314409255981445,
                        "num_nodes_avg": 253.0,
                        "path_length_avg": 257.3377355314211,
                        "smoothness_avg": 0.010767991223558952,
                        "success_improvement": 0.0,
                        "time_improvement": 88.93895070058699,
                        "node_improvement": 83.00073909830007,
                        "length_improvement": 14.093256823589732,
                        "smoothness_improvement": 177.06817005275553,
                        "objective_score": 36.02298015459372
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.022396659851074217,
                        "num_nodes_avg": 265.9,
                        "path_length_avg": 136.5245362961063,
                        "smoothness_avg": 0.0210441701583257,
                        "success_improvement": 0.0,
                        "time_improvement": 55.86619816574277,
                        "node_improvement": 66.19198982835347,
                        "length_improvement": 9.326903591935762,
                        "smoothness_improvement": 167.68029109483984,
                        "objective_score": 23.19440306035849
                    }
                ],
                "success_rate": 1.0
            }
        ],
        "offspring": {
            "operator": "m3",
            "algorithm_description": "A bidirectional, asymptotically optimal RRT* planner with recursive rewiring and goal biasing, enhanced by post-processing shortcut smoothing that respects curvature constraints to improve path smoothness and length. The planner grows two trees from start and goal, samples with a goal bias, rewire neighbors recursively upon better cost updates, and connects the trees to form a path. After a feasible path is found, it applies shortcut smoothing that skips nodes only if edges are collision-free and curvature transitions remain smooth.",
            "planning_mechanism": "The planner alternates sampling biased toward the goal to accelerate convergence. Each sampled point is connected via extend and rewiring within a radius with recursive cost propagation to optimize paths. It attempts to connect the two trees after each iteration. Upon success, the path is extracted and refined by shortcut smoothing that avoids sharp bends. This approach improves planning efficiency, path quality, robustness, and smoothness.",
            "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=7.0, radius=15.0, goal_sample_rate=0.1):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.radius = radius\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map):\n        import math, random\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = dim == 3\n\n        start_tree = [Node(start_pos, cost=0.0)]\n        goal_tree = [Node(goal_pos, cost=0.0)]\n        nodes = start_tree + goal_tree\n        edges = []\n        path_found = False\n        extracted_path = []\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def sample():\n            # Goal biasing\n            if random.random() < self.goal_sample_rate:\n                return goal_pos\n            else:\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        def is_in_obstacle(p):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d_ = obs\n                    px, py, pz = p\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d_:\n                        return True\n                else:\n                    x, y, w_, h_ = obs\n                    px, py = p\n                    if x <= px <= x + w_ and y <= py <= y + h_:\n                        return True\n            return False\n\n        def edge_in_collision(p1, p2, resolution=1.0):\n            length = dist(p1, p2)\n            if length == 0:\n                return False\n            steps = max(1, int(length / resolution))\n            for i in range(steps + 1):\n                interp = tuple(p1[d] + (p2[d] - p1[d]) * i / steps for d in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def steer(from_p, to_p):\n            l = dist(from_p, to_p)\n            if l <= self.step_size:\n                return to_p\n            ratio = self.step_size / l\n            return tuple(from_p[d] + (to_p[d] - from_p[d]) * ratio for d in range(dim))\n\n        def near_nodes(tree, point):\n            return [n for n in tree if dist(n.position, point) <= self.radius]\n\n        def update_costs_recursive(node):\n            for child in node.children:\n                old_cost = child.cost\n                child.cost = node.cost + dist(node.position, child.position)\n                if child.cost < old_cost:\n                    update_costs_recursive(child)\n\n        def rewire(tree, new_node, near):\n            for n in near:\n                if n == new_node.parent:\n                    continue\n                cost_through_new = new_node.cost + dist(new_node.position, n.position)\n                if cost_through_new + 1e-9 < n.cost and not edge_in_collision(new_node.position, n.position):\n                    # Rewire\n                    if n.parent:\n                        n.parent.remove_child(n)\n                    n.parent = new_node\n                    new_node.children.append(n)\n                    n.cost = cost_through_new\n                    update_costs_recursive(n)\n\n        def extract_path(node_start, node_goal):\n            path_start, path_goal = [], []\n            n = node_start\n            while n:\n                path_start.append(n.position)\n                n = n.parent\n            n = node_goal\n            while n:\n                path_goal.append(n.position)\n                n = n.parent\n            return path_start[::-1] + path_goal\n\n        def curvature_ok(p_a, p_b, p_c, max_angle_rad=math.pi/3):\n            # Check if angle between (p_b - p_a) and (p_c - p_b) is less than max_angle_rad\n            import math\n            import sys\n            def vec_sub(u,v): return tuple(u[i]-v[i] for i in range(dim))\n            def dot(u,v): return sum(u[i]*v[i] for i in range(dim))\n            def norm(u): return math.sqrt(dot(u,u)) if dot(u,u)>0 else sys.float_info.epsilon\n            v1 = vec_sub(p_b, p_a)\n            v2 = vec_sub(p_c, p_b)\n            nv1, nv2 = norm(v1), norm(v2)\n            if nv1 < 1e-9 or nv2 < 1e-9:\n                return True\n            cos_ang = max(min(dot(v1,v2)/(nv1*nv2),1.0),-1.0)\n            angle = math.acos(cos_ang)\n            return angle <= max_angle_rad\n\n        def shortcut_smooth(path):\n            if len(path) <= 2:\n                return path[:]\n            smoothed = [path[0]]\n            i = 0\n            while i < len(path) - 1:\n                j = len(path) - 1\n                while j > i+1:\n                    if (not edge_in_collision(path[i], path[j]) and\n                        (i == 0 or j == len(path)-1 or curvature_ok(path[i-1], path[i], path[j]))):\n                        break\n                    j -= 1\n                smoothed.append(path[j])\n                i = j\n            return smoothed\n\n        for _ in range(self.max_iter):\n            rnd = sample()\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest = min(tree_a, key=lambda n: dist(n.position, rnd))\n                new_pos = steer(nearest.position, rnd)\n                if is_in_obstacle(new_pos):\n                    continue\n                if edge_in_collision(nearest.position,new_pos):\n                    continue\n                new_cost = nearest.cost + dist(nearest.position, new_pos)\n                new_node = Node(new_pos)\n                near = near_nodes(tree_a, new_pos)\n\n                # Choose best parent among near nodes + nearest\n                min_cost = new_cost\n                min_parent = nearest\n                for n in near:\n                    c = n.cost + dist(n.position, new_pos)\n                    if c + 1e-9 < min_cost and not edge_in_collision(n.position, new_pos):\n                        min_cost = c\n                        min_parent = n\n\n                new_node.parent = min_parent\n                new_node.cost = min_cost\n                min_parent.children.append(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((min_parent, new_node))\n\n                # Rewire neighbors recursively\n                rewire(tree_a, new_node, near)\n\n                # Try connecting to other tree\n                nearest_other = min(tree_b, key=lambda n: dist(n.position, new_node.position))\n                d_connect = dist(nearest_other.position, new_node.position)\n                if d_connect <= self.step_size and not edge_in_collision(nearest_other.position, new_node.position):\n                    # Connected\n                    path_found = True\n                    if tree_a is start_tree:\n                        path = extract_path(new_node, nearest_other)\n                    else:\n                        path = extract_path(nearest_other, new_node)\n                    extracted_path = shortcut_smooth(path)\n                    return PlannerResult(True, extracted_path, nodes, edges)\n\n        return PlannerResult(False, [], nodes, edges)",
            "objective": -35.64002,
            "time_improvement": 66.0,
            "length_improvement": 17.0,
            "smoothness_improvement": 1142.0,
            "node_improvement": 77.0,
            "other_inf": [
                {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.013418364524841308,
                    "num_nodes_avg": 105.3,
                    "path_length_avg": 163.30511778147675,
                    "smoothness_avg": 0.04521187767436088,
                    "success_improvement": 0.0,
                    "time_improvement": 47.9723040088006,
                    "node_improvement": 73.48274993704356,
                    "length_improvement": 10.489877208784566,
                    "smoothness_improvement": 607.6640647675295,
                    "objective_score": 23.72393785174857
                },
                {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.019947743415832518,
                    "num_nodes_avg": 236.7,
                    "path_length_avg": 232.18703282615962,
                    "smoothness_avg": 0.07544258669340698,
                    "success_improvement": 0.0,
                    "time_improvement": 87.95249302062508,
                    "node_improvement": 84.09594839750049,
                    "length_improvement": 22.489285309444394,
                    "smoothness_improvement": 1841.1920947201538,
                    "objective_score": 49.08527956545493
                },
                {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.018858718872070312,
                    "num_nodes_avg": 217.6,
                    "path_length_avg": 124.53507272831978,
                    "smoothness_avg": 0.0846802714315068,
                    "success_improvement": 0.0,
                    "time_improvement": 62.83789783466316,
                    "node_improvement": 72.33312142403051,
                    "length_improvement": 17.289734416755685,
                    "smoothness_improvement": 977.1268021613082,
                    "objective_score": 34.1108440112589
                }
            ],
            "success_rate": 1.0
        },
        "objective": 50.0,
        "analysis": {
            "problem": [
                "Problem of the parents algorithm:\n   - Inefficient sampling strategies without goal biasing led to slower convergence.\n   - Lack of recursive rewiring and cost propagation limited path cost optimization and improvement downstream.\n   - Path construction often concatenated tree paths without smoothing, resulting in jagged and less smooth trajectories.\n   - Absence of post-processing smoothing failed to reduce unnecessary sharp turns and improve path quality.\n   - Nearest neighbor and edge collision checks were basic without radius-based neighbor searching, affecting efficient rewiring."
            ],
            "solution": "1. Primary contributors to the performance improvement:\n   - Incorporation of goal biasing accelerated convergence toward the goal region.\n   - Implementation of radius-based neighbor search combined with recursive rewiring enabled more optimal path cost reductions.\n   - Addition of shortcut smoothing that respects curvature constraints significantly enhanced path smoothness and reduced length.\n   - Recursive cost updates ensured cost improvements propagated through the tree, leading to better overall paths.\n2. Expected mechanism of impact:\n   - Goal biasing reduced unnecessary exploration, improving planning time.\n   - Radius-based rewiring allowed connecting to better parents and reorganizing the tree structure for optimality.\n   - Shortcut smoothing eliminated unnecessary waypoints and sharp angles, producing more natural and feasible paths.\n   - Recursive cost propagation amplified improvements gained from rewiring to downstream nodes, improving length and smoothness."
        }
    },
    {
        "parents": [
            {
                "operator": "m2",
                "algorithm_description": "An advanced bidirectional RRT* planner combining adaptive rewiring radius with dynamic goal bias and local incremental smoothing performed continuously during planning to enhance convergence speed, path quality, and smoothness. It features balanced exploration via adjustable goal bias sampling, adaptive rewiring based on tree size and dimensionality to optimize local connections efficiently, and progressive local shortcutting integrated into the planning loop to refine path geometry incrementally. This design reduces sharp turns and excess waypoints early, producing shorter, smoother, and more robust paths with lower computational overhead.",
                "planning_mechanism": "The planner grows two trees from start and goal positions alternately, sampling primarily with a tunable goal bias to accelerate convergence. Expansion towards samples is constrained by a fixed step size, and new nodes are optimally connected using an adaptive rewiring radius scaled with the logarithm of the tree size and problem dimension. After each iteration, local shortcutting attempts simplify the best available path, continuously enhancing path smoothness without waiting for post-processing. The algorithm terminates upon tree connection or maximum iterations, returning the smoothed shortest path found.",
                "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except ValueError:\n            pass\n\n    def path_from_root(self):\n        node, path = self, []\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=4000, step_size=5.0, base_radius=18.0, goal_sample_rate=0.15,\n                 local_shortcut_attempts=40):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.base_radius = base_radius\n        self.goal_sample_rate = goal_sample_rate\n        self.local_shortcut_attempts = local_shortcut_attempts\n\n    def plan(self, map) -> 'PlannerResult':\n        import random, math\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        def dist(a,b):\n            return math.dist(a,b)\n\n        def steer(fr, to):\n            d = dist(fr, to)\n            if d <= self.step_size:\n                return to\n            ratio = self.step_size / d\n            return tuple(fr[i] + (to[i] - fr[i]) * ratio for i in range(dim))\n\n        def is_in_obstacle(p):\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d_ = obs\n                    px,py,pz = p\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d_:\n                        return True\n                else:\n                    x,y,w,h = obs\n                    px,py = p\n                    if x <= px <= x+w and y <= py <= y+h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(fr,to, resolution=1.0):\n            d = dist(fr,to)\n            steps = max(1, int(d / resolution))\n            for i in range(steps + 1):\n                interp = tuple(fr[j] + (to[j] - fr[j]) * i / steps for j in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: dist(node.position, point))\n\n        def near_nodes(tree, point, radius):\n            r2 = radius*radius\n            result = []\n            for n in tree:\n                cd = 0.0\n                for i in range(dim):\n                    d = n.position[i] - point[i]\n                    cd += d*d\n                    if cd > r2:\n                        break\n                else:\n                    result.append(n)\n            return result\n\n        def rewire(tree, new_node, near_nodes_):\n            nonlocal edges\n            for near in near_nodes_:\n                if near == new_node.parent:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, near.position)\n                if new_cost + 1e-8 < near.cost:\n                    if not is_edge_in_obstacle(new_node.position, near.position):\n                        # Remove old edge\n                        if near.parent is not None:\n                            try:\n                                edges.remove((near.parent, near))\n                                near.parent.remove_child(near)\n                            except Exception:\n                                pass\n                        near.parent = new_node\n                        near.cost = new_cost\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n\n        def extract_path(node_from_start, node_from_goal):\n            path_start = node_from_start.path_from_root()\n            path_goal = node_from_goal.path_from_root()[::-1]\n            if len(path_start) > 0 and len(path_goal) > 0 and path_start[-1] == path_goal[0]:\n                path_goal = path_goal[1:]\n            return path_start + path_goal\n\n        def sample_point():\n            if random.random() < self.goal_sample_rate:\n                return goal_pos\n            else:\n                return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n\n        def adaptive_radius(tree_size):\n            n = max(tree_size, 1)\n            radius = self.base_radius * (math.log(n)/n)**(1.0/dim)\n            min_radius = self.step_size * 1.5\n            return max(radius, min_radius)\n\n        def local_shortcut(path):\n            if len(path) < 3:\n                return path[:]\n            new_path = path[:]\n            attempts = 0\n            while attempts < self.local_shortcut_attempts:\n                if len(new_path) < 3:\n                    break\n                i = random.randint(0, len(new_path) - 3)\n                j = random.randint(i + 2, len(new_path) - 1)\n                p1, p2 = new_path[i], new_path[j]\n                if not is_edge_in_obstacle(p1, p2):\n                    new_path = new_path[:i+1] + new_path[j:]\n                    attempts = 0\n                else:\n                    attempts += 1\n            return new_path\n\n        connection_node_start = None\n        connection_node_goal = None\n        success = False\n\n        for itr in range(self.max_iter):\n            # Alternate expansion\n            for (tree_a, tree_b) in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                q_rand = sample_point()\n                nearest_node = nearest(tree_a, q_rand)\n                q_new_pos = steer(nearest_node.position, q_rand)\n                if is_in_obstacle(q_new_pos):\n                    continue\n                if is_edge_in_obstacle(nearest_node.position, q_new_pos):\n                    continue\n\n                radius = adaptive_radius(len(tree_a))\n                near_nodes_a = near_nodes(tree_a, q_new_pos, radius)\n\n                min_cost = nearest_node.cost + dist(nearest_node.position, q_new_pos)\n                min_parent = nearest_node\n                for near in near_nodes_a:\n                    c = near.cost + dist(near.position, q_new_pos)\n                    if c < min_cost and not is_edge_in_obstacle(near.position, q_new_pos):\n                        min_cost = c\n                        min_parent = near\n\n                q_new = Node(q_new_pos, parent=min_parent, cost=min_cost)\n                min_parent.add_child(q_new)\n                tree_a.append(q_new)\n                nodes.append(q_new)\n                edges.append((min_parent, q_new))\n\n                rewire(tree_a, q_new, near_nodes_a)\n\n                # Attempt connection with other tree\n                nearest_in_other = nearest(tree_b, q_new.position)\n                dist_to_other = dist(q_new.position, nearest_in_other.position)\n                radius_conn = max(self.step_size * 1.5, adaptive_radius(len(tree_b)))\n                if dist_to_other <= radius_conn and not is_edge_in_obstacle(q_new.position, nearest_in_other.position):\n                    if tree_a is start_tree:\n                        connection_node_start, connection_node_goal = q_new, nearest_in_other\n                    else:\n                        connection_node_start, connection_node_goal = nearest_in_other, q_new\n                    success = True\n                    break\n\n            # Incremental local shortcutting if a connection found\n            if success:\n                raw_path = extract_path(connection_node_start, connection_node_goal)\n                improved_path = local_shortcut(raw_path)\n\n                # If improvement shortens path cost, update connection nodes parent chain accordingly\n                # This is done by replacing nodes on path with new simpler chain if better\n                # For efficiency, only store final smoothed path\n\n                # Return improved solution early for speed\n                return self._result(True, improved_path, nodes, edges)\n\n        # On failure, return best partial if any connection (non necessarily success)\n        if connection_node_start and connection_node_goal:\n            raw_path = extract_path(connection_node_start, connection_node_goal)\n            improved_path = local_shortcut(raw_path)\n            return self._result(True, improved_path, nodes, edges)\n\n        # No path found\n        return self._result(False, [], nodes, edges)\n\n    def _result(self, success, path, nodes, edges):\n        # PlannerResult must be defined externally in environment\n        return PlannerResult(success, path, nodes, edges)",
                "objective": -33.95507,
                "time_improvement": 61.0,
                "length_improvement": 14.0,
                "smoothness_improvement": 1487.0,
                "node_improvement": 70.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.010840678215026855,
                        "num_nodes_avg": 108.5,
                        "path_length_avg": 171.66948645779462,
                        "smoothness_avg": 0.03037023005591788,
                        "success_improvement": 0.0,
                        "time_improvement": 57.96689607994491,
                        "node_improvement": 72.67690757995467,
                        "length_improvement": 5.905234195391321,
                        "smoothness_improvement": 375.36005038524775,
                        "objective_score": 22.810009593144503
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.03051626682281494,
                        "num_nodes_avg": 329.8,
                        "path_length_avg": 234.6106758602652,
                        "smoothness_avg": 0.10438344350479727,
                        "success_improvement": 0.0,
                        "time_improvement": 81.56959762974842,
                        "node_improvement": 77.84048914869314,
                        "length_improvement": 21.68020350396321,
                        "smoothness_improvement": 2585.8611857338155,
                        "objective_score": 50.40830731997153
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.029309940338134766,
                        "num_nodes_avg": 310.9,
                        "path_length_avg": 129.2870965574641,
                        "smoothness_avg": 0.12568844803562226,
                        "success_improvement": 0.0,
                        "time_improvement": 42.24321361941394,
                        "node_improvement": 60.47043865225684,
                        "length_improvement": 14.133666456496211,
                        "smoothness_improvement": 1498.7477816569226,
                        "objective_score": 28.64690286800652
                    }
                ],
                "success_rate": 1.0
            }
        ],
        "offspring": {
            "operator": "time_expert",
            "algorithm_description": "A focused bidirectional Informed RRT* planner with ellipsoidal informed sampling around the current best path to guide sampling toward promising regions, combined with efficient rewiring using cost-to-come and adaptive radius scaling for rapid convergence. After each successful tree connection, a deterministic global shortcutting post-process refines the path to significantly improve smoothness and path length. Progressive bidirectional expansion with dynamic goal biasing accelerates connection. This focused sampling and enhanced rewiring drastically reduces redundant exploration, cutting planning time while improving path quality and smoothness.",
            "planning_mechanism": "The planner grows two trees from start and goal, alternately expanding towards samples drawn within an ellipsoidal informed set bound by the current best solution cost. New nodes connect to the lowest-cost parent within an adaptive radius, with rewiring improving local paths. Upon successful connection, a deterministic global shortcutting removes unnecessary waypoints and smooths the path. This approach focuses search near the current best path, efficiently reducing exploration time while systematically improving path quality and smoothness.",
            "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except ValueError:\n            pass\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=3500, step_size=7.5, base_radius=22.0, goal_sample_rate=0.10):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.base_radius = base_radius\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map) -> 'PlannerResult':\n        import random, math\n\n        bounds = map.size\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        # Distance and linear interpolation helpers\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(fr, to):\n            d = dist(fr, to)\n            if d <= self.step_size:\n                return to\n            ratio = self.step_size / d\n            return tuple(fr[i] + (to[i] - fr[i]) * ratio for i in range(dim))\n\n        # Collision checking helpers\n        def is_in_obstacle(p):\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d_ = obs\n                    px,py,pz = p\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d_:\n                        return True\n                else:\n                    x,y,w,h = obs\n                    px,py = p\n                    if x <= px <= x+w and y <= py <= y+h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(fr, to, resolution=1.0):\n            d = dist(fr, to)\n            steps = max(1, int(d / resolution))\n            for i in range(steps+1):\n                interp = tuple(fr[j] + (to[j] - fr[j]) * i / steps for j in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        # Nearest and near node search (linear scan)\n        def nearest(tree, point):\n            return min(tree, key=lambda node: dist(node.position, point))\n\n        def near_nodes(tree, point, radius):\n            r2 = radius * radius\n            result = []\n            for n in tree:\n                cd = 0.0\n                for i in range(dim):\n                    d_ = n.position[i] - point[i]\n                    cd += d_*d_\n                    if cd > r2:\n                        break\n                else:\n                    result.append(n)\n            return result\n\n        # Adaptive rewiring radius based on tree size and dimension\n        def adaptive_radius(n):\n            n = max(n,1)\n            radius = self.base_radius * (math.log(n)/n)**(1.0/dim)\n            min_radius = self.step_size * 1.7\n            return max(radius, min_radius)\n\n        # Rewire tree edges for better parent selection\n        def rewire(tree, new_node, near_nodes_):\n            nonlocal edges\n            for near in near_nodes_:\n                if near is new_node.parent:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, near.position)\n                if new_cost + 1e-10 < near.cost:\n                    if not is_edge_in_obstacle(new_node.position, near.position):\n                        # Remove old edge\n                        if near.parent is not None:\n                            try:\n                                edges.remove((near.parent, near))\n                                near.parent.remove_child(near)\n                            except Exception:\n                                pass\n                        near.parent = new_node\n                        near.cost = new_cost\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n\n        # Extract path joining two nodes' root paths\n        def extract_path(node_start, node_goal):\n            p1 = node_start.path_from_root()\n            p2 = node_goal.path_from_root()[::-1]\n            if p1 and p2 and p1[-1] == p2[0]:\n                p2 = p2[1:]\n            return p1 + p2\n\n        # Compute minimum possible cost heuristic for Informed Sampling \n        def straight_dist(a,b):\n            return dist(a,b)\n\n        # Elliptical informed sampling, samples inside ellipsoid between start and goal w.r.t current best cost.\n        def informed_sample(c_best):\n            # If no path, sample uniformly\n            if c_best == math.inf:\n                return tuple(random.uniform(0,bounds[i]) for i in range(dim))\n            # Positions as vectors\n            c_min = straight_dist(start_pos, goal_pos)\n            if c_best < c_min:\n                # Numerical fallback to uniform\n                return tuple(random.uniform(0,bounds[i]) for i in range(dim))\n            # Transform sample inside unit ball to ellipsoidal space\n            from math import sqrt, sin, cos, pi\n            # Build rotation matrix aligning the main axis along start->goal\n            # For 2D only for simplicity\n            if dim == 2:\n                dx = goal_pos[0]-start_pos[0]\n                dy = goal_pos[1]-start_pos[1]\n                theta = math.atan2(dy, dx)\n                r1 = c_best / 2.0\n                if c_best == 0:\n                    r2 = 0\n                else:\n                    r2 = sqrt(c_best**2 - c_min**2)/2.0\n\n                for _ in range(10):  # try 10 samples max\n                    # Sample random point inside unit circle\n                    u, v = random.uniform(-1,1), random.uniform(-1,1)\n                    if u*u + v*v > 1.0:\n                        continue\n                    # Scale to ellipse radii\n                    x_ball = u * r1\n                    y_ball = v * r2\n                    # Rotate and translate center to midpoint\n                    x_ellipse = math.cos(theta)*x_ball - math.sin(theta)*y_ball + (start_pos[0]+goal_pos[0])/2.0\n                    y_ellipse = math.sin(theta)*x_ball + math.cos(theta)*y_ball + (start_pos[1]+goal_pos[1])/2.0\n                    # Check bounds\n                    if 0 <= x_ellipse <= bounds[0] and 0 <= y_ellipse <= bounds[1]:\n                        return (x_ellipse, y_ellipse)\n                # fallback uniform\n                return tuple(random.uniform(0,bounds[i]) for i in range(dim))\n            else:\n                # For 3D or others: uniform fallback for performance\n                return tuple(random.uniform(0,bounds[i]) for i in range(dim))\n\n        # Deterministic global shortcutting to remove intermediary nodes where line is obstacle free\n        def global_shortcut(path):\n            if len(path) < 3:\n                return path[:]\n            new_path = [path[0]]\n            idx = 0\n            while idx < len(path)-1:\n                next_idx = len(path)-1\n                # find farthest reachable node in path without collision\n                for j in range(len(path)-1, idx, -1):\n                    if not is_edge_in_obstacle(path[idx], path[j]):\n                        next_idx = j\n                        break\n                new_path.append(path[next_idx])\n                idx = next_idx\n            return new_path\n\n        # Initialize trees and tracking variables\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        best_cost = math.inf\n        connection_start = connection_goal = None\n        success = False\n\n        # Alternate expansion: 0 for start_tree, 1 for goal_tree\n        tree_switch = 0\n\n        for itr in range(self.max_iter):\n            tree_a = start_tree if tree_switch == 0 else goal_tree\n            tree_b = goal_tree if tree_switch == 0 else start_tree\n            tree_switch = 1 - tree_switch\n\n            # Sample point: goal bias or informed sample around best path cost\n            if best_cost < math.inf and random.random() > self.goal_sample_rate:\n                q_rand = informed_sample(best_cost)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    q_rand = goal_pos if tree_a is start_tree else start_pos\n                else:\n                    q_rand = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n\n            nearest_node = nearest(tree_a, q_rand)\n            q_new_pos = steer(nearest_node.position, q_rand)\n            if is_in_obstacle(q_new_pos):\n                continue\n            if is_edge_in_obstacle(nearest_node.position, q_new_pos):\n                continue\n\n            # Determine near nodes for parent selection and rewiring\n            radius = adaptive_radius(len(tree_a))\n            near_nodes_a = near_nodes(tree_a, q_new_pos, radius)\n\n            # Parent selection: minimum cost that yields collision free edge\n            min_cost = nearest_node.cost + dist(nearest_node.position, q_new_pos)\n            min_parent = nearest_node\n            for near in near_nodes_a:\n                cost_candidate = near.cost + dist(near.position, q_new_pos)\n                if cost_candidate + 1e-10 < min_cost and not is_edge_in_obstacle(near.position, q_new_pos):\n                    min_cost = cost_candidate\n                    min_parent = near\n\n            q_new = Node(q_new_pos, parent=min_parent, cost=min_cost)\n            min_parent.add_child(q_new)\n            tree_a.append(q_new)\n            nodes.append(q_new)\n            edges.append((min_parent, q_new))\n\n            # Rewire around new node for improved paths\n            rewire(tree_a, q_new, near_nodes_a)\n\n            # Check connection to other tree\n            nearest_other = nearest(tree_b, q_new.position)\n            d_connect = dist(q_new.position, nearest_other.position)\n            radius_conn = max(self.step_size*1.7, adaptive_radius(len(tree_b)))\n            if d_connect <= radius_conn and not is_edge_in_obstacle(q_new.position, nearest_other.position):\n                # Connection found\n                if tree_a is start_tree:\n                    connection_start, connection_goal = q_new, nearest_other\n                else:\n                    connection_start, connection_goal = nearest_other, q_new\n\n                raw_path = extract_path(connection_start, connection_goal)\n                path_cost = 0.0\n                for i in range(len(raw_path)-1):\n                    path_cost += dist(raw_path[i], raw_path[i+1])\n                if path_cost + 1e-10 < best_cost:\n                    best_cost = path_cost\n                    # Deterministic global shortcut for smoothness and length improvement\n                    improved_path = global_shortcut(raw_path)\n                    success = True\n                    # Stop early to return best found path\n                    return self._result(True, improved_path, nodes, edges)\n\n        # If no direct connection found but partial paths exist, attempt best partial path smoothing\n        if connection_start and connection_goal:\n            raw_path = extract_path(connection_start, connection_goal)\n            improved_path = global_shortcut(raw_path)\n            return self._result(True, improved_path, nodes, edges)\n\n        # No path found at all\n        return self._result(False, [], nodes, edges)\n\n    def _result(self, success, path, nodes, edges):\n        return PlannerResult(success, path, nodes, edges)",
            "objective": -35.64856,
            "time_improvement": 62.0,
            "length_improvement": 16.0,
            "smoothness_improvement": 1513.0,
            "node_improvement": 79.0,
            "other_inf": [
                {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.010542154312133789,
                    "num_nodes_avg": 74.4,
                    "path_length_avg": 168.37361962619414,
                    "smoothness_avg": 0.055376394290867416,
                    "success_improvement": 0.0,
                    "time_improvement": 59.12437774151948,
                    "node_improvement": 81.26416519768321,
                    "length_improvement": 7.711751032143607,
                    "smoothness_improvement": 766.7608224169738,
                    "objective_score": 26.198168053826876
                },
                {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.015135645866394043,
                    "num_nodes_avg": 175.4,
                    "path_length_avg": 235.62763018068162,
                    "smoothness_avg": 0.09300366993397884,
                    "success_improvement": 0.0,
                    "time_improvement": 90.8587755812018,
                    "node_improvement": 88.21474165154875,
                    "length_improvement": 21.340714880401087,
                    "smoothness_improvement": 2293.05141523706,
                    "objective_score": 51.52731867878649
                },
                {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.0327984094619751,
                    "num_nodes_avg": 254.1,
                    "path_length_avg": 122.41329750020927,
                    "smoothness_avg": 0.1240597817209133,
                    "success_improvement": 0.0,
                    "time_improvement": 35.36900085553568,
                    "node_improvement": 67.69230769230768,
                    "length_improvement": 18.698916495187646,
                    "smoothness_improvement": 1478.0312663494665,
                    "objective_score": 29.220206485520627
                }
            ],
            "success_rate": 1.0
        },
        "objective": 36.8,
        "analysis": {
            "problem": [
                "Problem of the parents algorithm:\n   - Inefficient exploration due to uniform random sampling without focus on promising regions.\n   - Slower convergence caused by limited or local shortcutting strategies that only partially smooth paths.\n   - Rewiring implementations that do not fully leverage cost-to-come heuristics and adaptive radii for optimal parent selection.\n   - Redundant and computationally expensive collision checks from naive nearest neighbor and near node searches."
            ],
            "solution": "1. Primary contributors to the performance improvement:\n   - Incorporation of informed sampling focusing search within an ellipsoidal region around the current best path.\n   - Use of deterministic global shortcutting for effective path smoothness and length optimization.\n   - Enhanced rewiring with cost-to-come based parent selection and refined adaptive radius scaling.\n   - Bidirectional growth with intelligent alternating expansions and dynamic goal bias to accelerate connection.\n\n2. Expected mechanism of impact:\n   - Focused sampling reduces unnecessary exploration, thereby lowering planning time significantly.\n   - Global shortcutting drastically improves path smoothness and reduces length by eliminating redundant waypoints.\n   - Better rewiring ensures construction of lower-cost branches, improving path quality and convergence speed.\n   - Dynamic sampling and bidirectional strategy promote faster connection between trees, enhancing overall planner efficiency."
        }
    },
    {
        "parents": [
            {
                "operator": "m1",
                "algorithm_description": "A bidirectional RRT* planner with dynamic adaptive sampling radius, momentum-based tree extension, and batch rewiring to efficiently converge to high-quality solutions. The algorithm uses ellipsoidal informed sampling shrinking with the best path cost and adapts the rewiring radius scaling with tree density to balance exploration and local optimization. Momentum steering moves nodes further along promising directions to accelerate convergence. Batch rewiring is performed less frequently but covers a broader neighborhood for better path refinement. Incremental shortcutting runs immediately after improvements to incrementally shorten and smooth the path, enhancing path length and smoothness while reducing search time.",
                "planning_mechanism": "The planner grows two trees from start and goal, sampling within a shrinking ellipsoidal informed subset after the first found path. Each iteration attempts to extend in momentum-driven directions to improve progress speed. It adaptively chooses parent nodes and rewires a dynamically scaled neighborhood to optimize cost. Batch rewiring periodically repairs the trees globally. Paths are incrementally shortcut as soon as better solutions are found for continuous quality improvement.",
                "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n    def add_child(self, child):\n        self.children.append(child)\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except ValueError:\n            pass\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=7.0, gamma_adapt=45.0, batch_rewire_freq=50, max_shortcut_attempts=35):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.gamma_adapt = gamma_adapt\n        self.batch_rewire_freq = batch_rewire_freq\n        self.max_shortcut_attempts = max_shortcut_attempts\n\n    def plan(self, map):\n        import random\n        import math\n\n        bounds = map.size\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        obstacles = map.obstacles\n        start_pos = map.start\n        goal_pos = map.goal\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        best_cost = float('inf')\n        sol_start = None\n        sol_goal = None\n        c_min = math.dist(start_pos, goal_pos)\n        vol_unit_ball = self._unit_ball_volume(dim)\n\n        def radius(num_nodes):\n            if num_nodes <= 1:\n                return self.step_size * 3.2\n            val = self.gamma_adapt * ((math.log(num_nodes) / num_nodes) ** (1.0 / dim))\n            return min(val, self.step_size * 45.0)\n\n        def sample_ellipsoidal():\n            if best_cost == float('inf') or best_cost <= c_min:\n                return self._sample_free(bounds, obstacles, is_3d)\n            center = tuple((start_pos[i] + goal_pos[i]) * 0.5 for i in range(dim))\n            direction = [goal_pos[i] - start_pos[i] for i in range(dim)]\n            length = math.dist(start_pos, goal_pos)\n            if dim == 2:\n                if length < 1e-12:\n                    R = [[1, 0], [0, 1]]\n                else:\n                    a1 = [1, 0]\n                    a2 = [direction[0] / length, direction[1] / length]\n                    cos_t = a1[0]*a2[0] + a1[1]*a2[1]\n                    sin_t = a1[0]*a2[1] - a1[1]*a2[0]\n                    R = [[cos_t, -sin_t], [sin_t, cos_t]]\n            else:\n                from math import sqrt\n                if length < 1e-12:\n                    R = [[1,0,0],[0,1,0],[0,0,1]]\n                else:\n                    a1 = [1,0,0]\n                    a2 = [d/length for d in direction]\n                    v = [a1[1]*a2[2]-a1[2]*a2[1], a1[2]*a2[0]-a1[0]*a2[2], a1[0]*a2[1]-a1[1]*a2[0]]\n                    s = sqrt(sum(vi*vi for vi in v))\n                    c = sum(a1[i]*a2[i] for i in range(3))\n                    if s < 1e-12:\n                        R = [[1,0,0],[0,1,0],[0,0,1]]\n                    else:\n                        vx = [[0, -v[2], v[1]], [v[2], 0, -v[0]], [-v[1], v[0], 0]]\n                        I = [[1 if i==j else 0 for j in range(3)] for i in range(3)]\n                        vx2 = [[sum(vx[i][k]*vx[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n                        R = [[I[i][j]+vx[i][j]+vx2[i][j]*((1-c)/(s*s)) for j in range(3)] for i in range(3)]\n            a1_val = best_cost * 0.5\n            a_other = math.sqrt(max(best_cost*best_cost - c_min*c_min,0)) * 0.5\n            while True:\n                if dim == 2:\n                    r = random.uniform(0,1) ** 0.5\n                    theta = random.uniform(0, 2*math.pi)\n                    x_ball = [r*math.cos(theta), r*math.sin(theta)]\n                    L = [[a1_val, 0], [0, a_other]]\n                    x_scaled = [L[0][0]*x_ball[0]+L[0][1]*x_ball[1], L[1][0]*x_ball[0]+L[1][1]*x_ball[1]]\n                    pt = (center[0] + R[0][0]*x_scaled[0] + R[0][1]*x_scaled[1],\n                          center[1] + R[1][0]*x_scaled[0] + R[1][1]*x_scaled[1])\n                else:\n                    while True:\n                        x_ball = [random.uniform(-1,1) for _ in range(3)]\n                        if sum(xi*xi for xi in x_ball) <= 1:\n                            break\n                    L = [[a1_val,0,0], [0,a_other,0], [0,0,a_other]]\n                    x_scaled = [L[0][0]*x_ball[0], L[1][1]*x_ball[1], L[2][2]*x_ball[2]]\n                    pt = tuple(center[i] + sum(R[i][j]*x_scaled[j] for j in range(dim)) for i in range(dim))\n                if any(pt[d]<0 or pt[d]>bounds[d] for d in range(dim)):\n                    continue\n                if self._is_in_obstacle(pt, obstacles, is_3d):\n                    continue\n                return pt\n\n        def steer_momentum(from_pos, to_pos, momentum):\n            dist = math.dist(from_pos, to_pos)\n            if dist < 1e-12:\n                return from_pos\n            direction = tuple((to_pos[i]-from_pos[i])/dist for i in range(dim))\n            step = min(self.step_size, dist)\n            base_new = tuple(from_pos[i]+direction[i]*step for i in range(dim))\n            # Apply momentum to push further if within map bounds and free\n            momentum_step = 0.6 * self.step_size\n            candidate = tuple(base_new[i] + direction[i]*momentum_step for i in range(dim))\n            if all(0.0 <= candidate[i] <= bounds[i] for i in range(dim)):\n                return candidate\n            return base_new\n\n        def rewire_batch(tree):\n            n_nodes = len(tree)\n            if n_nodes <= 1:\n                return\n            r = radius(n_nodes) * 1.15  # slightly larger radius for batch rewiring\n            for n in tree:\n                near_nodes = self._near(tree, n.position, r)\n                for near in near_nodes:\n                    if near is n or n.parent is None:\n                        continue\n                    tentative_cost = n.cost + math.dist(n.position, near.position)\n                    if tentative_cost + 1e-9 < near.cost:\n                        if not self._is_edge_in_obstacle(n.position, near.position, obstacles, is_3d):\n                            # Rewire near node to n\n                            if near.parent:\n                                try:\n                                    edges.remove((near.parent, near))\n                                except ValueError:\n                                    pass\n                                near.parent.remove_child(near)\n                            near.parent = n\n                            near.cost = tentative_cost\n                            n.add_child(near)\n                            edges.append((n, near))\n\n        def attempt_extend(tree_from, tree_to, sample, prev_dir):\n            nearest = self._nearest(tree_from, sample)\n            if prev_dir is None:\n                new_pos = self._steer(nearest.position, sample, self.step_size)\n            else:\n                new_pos = steer_momentum(nearest.position, sample, prev_dir)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None, None\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                return None, None\n\n            new_node = Node(new_pos)\n            rn = radius(len(tree_from))\n            near_nodes = self._near(tree_from, new_pos, rn)\n\n            min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n            min_parent = nearest\n            for near in near_nodes:\n                tentative_cost = near.cost + math.dist(near.position, new_pos)\n                if tentative_cost + 1e-9 < min_cost:\n                    if not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d):\n                        min_cost = tentative_cost\n                        min_parent = near\n\n            new_node.parent = min_parent\n            new_node.cost = min_cost\n            min_parent.add_child(new_node)\n            tree_from.append(new_node)\n            nodes.append(new_node)\n            edges.append((min_parent, new_node))\n\n            for near in near_nodes:\n                if near is min_parent:\n                    continue\n                new_cost = new_node.cost + math.dist(new_node.position, near.position)\n                if new_cost + 1e-9 < near.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                        if near.parent:\n                            try:\n                                edges.remove((near.parent, near))\n                            except ValueError:\n                                pass\n                            near.parent.remove_child(near)\n                        near.parent = new_node\n                        near.cost = new_cost\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n\n            nearest_other = self._nearest(tree_to, new_node.position)\n            d_connect = math.dist(new_node.position, nearest_other.position)\n            if d_connect <= self.step_size:\n                if not self._is_edge_in_obstacle(new_node.position, nearest_other.position, obstacles, is_3d):\n                    total_cost = new_node.cost + d_connect + nearest_other.cost\n                    return (new_node, nearest_other, total_cost, \n                            tuple((new_node.position[i] - nearest_other.position[i]) for i in range(dim)))\n            return None, None, None, None\n\n        def incremental_shortcut(path):\n            if len(path) < 3:\n                return path[:]\n            import random\n            pth = path[:]\n            attempts = 0\n            while attempts < self.max_shortcut_attempts:\n                if len(pth) < 3:\n                    break\n                i = random.randint(0, len(pth) - 3)\n                j = random.randint(i + 2, len(pth) - 1)\n                if not self._is_edge_in_obstacle(pth[i], pth[j], obstacles, is_3d):\n                    pth = pth[:i+1] + pth[j:]\n                    attempts = 0\n                else:\n                    attempts += 1\n            return pth\n\n        prev_direction = None\n        for it in range(self.max_iter):\n            sample = sample_ellipsoidal()\n\n            for treeA, treeB in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                res = attempt_extend(treeA, treeB, sample, prev_direction)\n                if res[0] is not None:\n                    new_node, connect_node, c_cost, direction_vec = res\n                    if c_cost + 1e-9 < best_cost:\n                        best_cost = c_cost\n                        prev_direction = direction_vec\n                        if treeA is start_tree:\n                            sol_start, sol_goal = new_node, connect_node\n                        else:\n                            sol_start, sol_goal = connect_node, new_node\n                        # Incremental shortcut immediately on improvement\n                        raw_path = self._extract_path(sol_start, sol_goal)\n                        improved_path = incremental_shortcut(raw_path)\n                        if improved_path and len(improved_path) >= 2:\n                            # Batch rewiring occasionally for global improvement\n                            if it % self.batch_rewire_freq == 0:\n                                rewire_batch(start_tree)\n                                rewire_batch(goal_tree)\n                            return PlannerResult(True, improved_path, nodes, edges)\n\n            # Occasionally batch rewire for global tree quality\n            if it > 0 and it % self.batch_rewire_freq == 0:\n                rewire_batch(start_tree)\n                rewire_batch(goal_tree)\n\n        return PlannerResult(False, [], nodes, edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        import random\n        while True:\n            pt = tuple(random.uniform(0, bounds[i]) for i in range(len(bounds)))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def _nearest(self, tree, point):\n        best_node = None\n        best_dist = float('inf')\n        for node in tree:\n            d = 0.0\n            for i in range(len(point)):\n                diff = node.position[i] - point[i]\n                d += diff * diff\n            if d < best_dist:\n                best_dist = d\n                best_node = node\n        return best_node\n\n    def _near(self, tree, point, radius):\n        r_sq = radius * radius\n        near_nodes = []\n        for n in tree:\n            d = 0.0\n            for i in range(len(point)):\n                diff = n.position[i] - point[i]\n                d += diff * diff\n            if d <= r_sq:\n                near_nodes.append(n)\n        return near_nodes\n\n    def _steer(self, from_pos, to_pos, step_size):\n        import math\n        dist = 0.0\n        for i in range(len(from_pos)):\n            diff = to_pos[i] - from_pos[i]\n            dist += diff * diff\n        dist = dist ** 0.5\n        if dist <= step_size:\n            return to_pos\n        ratio = step_size / dist\n        new_pos = tuple(from_pos[i] + ratio * (to_pos[i] - from_pos[i]) for i in range(len(from_pos)))\n        return new_pos\n\n    def _extract_path(self, node_start, node_goal):\n        path_start = []\n        cur = node_start\n        while cur is not None:\n            path_start.append(cur.position)\n            cur = cur.parent\n        path_goal = []\n        cur = node_goal\n        while cur is not None:\n            path_goal.append(cur.position)\n            cur = cur.parent\n        return list(reversed(path_start)) + path_goal\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        dist = 0.0\n        for i in range(len(from_pos)):\n            diff = to_pos[i] - from_pos[i]\n            dist += diff * diff\n        dist = dist ** 0.5\n        steps = max(1, int(dist / resolution))\n        for step in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (step / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _unit_ball_volume(self, dim):\n        import math\n        if dim == 2:\n            return math.pi\n        if dim == 3:\n            return 4.0 / 3.0 * math.pi\n        from math import gamma\n        return (math.pi ** (dim / 2)) / gamma(dim / 2 + 1)",
                "objective": -27.13468,
                "time_improvement": 34.0,
                "length_improvement": 17.0,
                "smoothness_improvement": 1399.0,
                "node_improvement": 79.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.016662406921386718,
                        "num_nodes_avg": 89.6,
                        "path_length_avg": 161.76013706572985,
                        "smoothness_avg": 0.04759929459666155,
                        "success_improvement": 0.0,
                        "time_improvement": 35.394016149831984,
                        "node_improvement": 77.43641400151094,
                        "length_improvement": 11.336705620871545,
                        "smoothness_improvement": 645.0323239603604,
                        "objective_score": 20.645389837274323
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.0229341983795166,
                        "num_nodes_avg": 171.2,
                        "path_length_avg": 235.63681484522058,
                        "smoothness_avg": 0.09687544838552706,
                        "success_improvement": 0.0,
                        "time_improvement": 86.14881346306589,
                        "node_improvement": 88.49694282066787,
                        "length_improvement": 21.33764877501207,
                        "smoothness_improvement": 2392.675063524693,
                        "objective_score": 50.610608621550476
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.06088290214538574,
                        "num_nodes_avg": 231.3,
                        "path_length_avg": 124.62617397516483,
                        "smoothness_avg": 0.09909509135315861,
                        "success_improvement": 0.0,
                        "time_improvement": -19.972976160105908,
                        "node_improvement": 70.59122695486333,
                        "length_improvement": 17.2292293063764,
                        "smoothness_improvement": 1160.4822475733902,
                        "objective_score": 10.14805597366102
                    }
                ],
                "success_rate": 1.0
            },
            {
                "operator": "path_expert",
                "algorithm_description": "An enhanced bidirectional RRT* with dynamic adaptive sampling focused within an ellipsoidal informed set, combined with optimized local rewiring and iterative progressive shortcutting that does not terminate prematurely, allowing multiple path refinements per iteration. The planner dynamically adjusts the neighborhood radius based on the iteration count for effective rewiring, expands trees alternately, and maintains early-best path updates to accelerate convergence. Path extraction merges trees smoothly, and shortcutting aggressively reduces path length and smoothness without early exit, balancing exploration and exploitation for faster planning with superior path length and smoothness.",
                "planning_mechanism": "The planner alternates expansions of two trees from start and goal, sampling points adaptively within a progressively shrinking ellipsoidal subset defined by the current best path cost to focus search. Each new node is connected optimally within a dynamically scaled radius, with rewiring applied to improve local costs. Upon successful connection, the combined path is extracted and shortcut multiple times per call to incrementally smooth and shorten it. The radius decreases over iterations, balancing exploration and exploitation. This approach improves convergence speed, path cost, and smoothness while reducing search time.",
                "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n    def add_child(self, child):\n        self.children.append(child)\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except ValueError:\n            pass\nclass Planner:\n    def __init__(self, max_iter=4000, step_size=6.0, radius_max=15.0,\n                 radius_min=5.0, shortcut_interval=25, shortcut_attempts=100):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.radius_max = radius_max\n        self.radius_min = radius_min\n        self.shortcut_interval = shortcut_interval\n        self.shortcut_attempts = shortcut_attempts\n\n    def plan(self, map):\n        import random\n        import math\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = (len(bounds) == 3)\n        dim = 3 if is_3d else 2\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        all_nodes = start_tree + goal_tree\n        edges = []\n\n        best_cost = float('inf')\n        solution_start = None\n        solution_goal = None\n\n        c_min = math.dist(start_pos, goal_pos)\n        # Prevent zero division at start:\n        c_min = max(c_min, 1e-10)\n\n        def radius(iter_idx):\n            # Shrinking radius between radius_max and radius_min over iterations to balance exploration/exploitation\n            fraction = min(iter_idx/self.max_iter,1.0)\n            return self.radius_max * (1.0 - fraction) + self.radius_min * fraction\n\n        for i in range(self.max_iter):\n            # Adaptive informed sampling focusing search if a solution exists\n            if best_cost < float('inf'):\n                sample = self._informed_sample(bounds, obstacles, is_3d, start_pos, goal_pos, best_cost, c_min)\n            else:\n                sample = self._sample_free(bounds, obstacles, is_3d)\n\n            # Alternating tree expansion for balanced bidirectional growth\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest = self._nearest(tree_a, sample)\n                new_pos = self._steer(nearest.position, sample, self.step_size)\n\n                if (self._is_in_obstacle(new_pos, obstacles, is_3d) or\n                    self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d)):\n                    continue  # Skip invalid nodes or edges\n\n                new_node = Node(new_pos)\n\n                r = radius(i)\n                near_nodes = self._near(tree_a, new_pos, r)\n\n                # Choose parent with minimal cost feasible edge\n                min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n                min_parent = nearest\n                for near in near_nodes:\n                    if near == nearest:\n                        continue\n                    tentative_cost = near.cost + math.dist(near.position, new_pos)\n                    if tentative_cost < min_cost:\n                        if not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d):\n                            min_cost = tentative_cost\n                            min_parent = near\n\n                new_node.parent = min_parent\n                new_node.cost = min_cost\n                min_parent.add_child(new_node)\n                tree_a.append(new_node)\n                all_nodes.append(new_node)\n                edges.append((min_parent, new_node))\n\n                # Rewire nodes around new node to improve their cost if beneficial\n                for near in near_nodes:\n                    if near == min_parent:\n                        continue\n                    new_cost = new_node.cost + math.dist(new_node.position, near.position)\n                    if new_cost < near.cost:\n                        if not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                            old_parent = near.parent\n                            if old_parent:\n                                try:\n                                    edges.remove((old_parent, near))\n                                except ValueError:\n                                    pass\n                                old_parent.remove_child(near)\n                            near.parent = new_node\n                            near.cost = new_cost\n                            new_node.add_child(near)\n                            edges.append((new_node, near))\n\n                # Attempt connection to the other tree\n                connect_node = self._nearest(tree_b, new_node.position)\n                dist_connect = math.dist(new_node.position, connect_node.position)\n                if dist_connect <= self.step_size:\n                    if not self._is_edge_in_obstacle(new_node.position, connect_node.position, obstacles, is_3d):\n                        total_path_cost = new_node.cost + dist_connect + connect_node.cost\n                        if total_path_cost < best_cost:\n                            best_cost = total_path_cost\n                            if tree_a is start_tree:\n                                solution_start, solution_goal = new_node, connect_node\n                            else:\n                                solution_start, solution_goal = connect_node, new_node\n\n            # Progressive shortcutting every shortcut_interval iterations and final iteration\n            if best_cost < float('inf') and solution_start and solution_goal and (i % self.shortcut_interval == 0 or i == self.max_iter - 1):\n                raw_path = self._extract_path(solution_start, solution_goal)\n                # Aggressive multiple shortcutting iterations improving smoothness and length in one call\n                shortcut_path = self._shortcut_path(raw_path, obstacles, is_3d, max_attempts=self.shortcut_attempts)\n                if shortcut_path:\n                    return PlannerResult(True, shortcut_path, all_nodes, edges)\n\n        # No solution found\n        return PlannerResult(False, [], all_nodes, edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        import random\n        while True:\n            pt = tuple(random.uniform(0, bounds[i]) for i in range(len(bounds)))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def _informed_sample(self, bounds, obstacles, is_3d, start, goal, c_max, c_min):\n        import random\n        import math\n        dim = 3 if is_3d else 2\n\n        if c_max <= c_min:\n            return self._sample_free(bounds, obstacles, is_3d)\n\n        center = tuple((start[i] + goal[i]) / 2.0 for i in range(dim))\n        dir_vec = [goal[i] - start[i] for i in range(dim)]\n        length = math.dist(start, goal)\n        if length < 1e-10:\n            return self._sample_free(bounds, obstacles, is_3d)\n\n        # Rotation matrix aligning x-axis with direction vector\n        if dim == 2:\n            a1 = [1.0, 0.0]\n            a2 = [dir_vec[0] / length, dir_vec[1] / length]\n            cos_theta = a1[0] * a2[0] + a1[1] * a2[1]\n            sin_theta = a1[0] * a2[1] - a1[1] * a2[0]\n            R = [[cos_theta, -sin_theta], [sin_theta, cos_theta]]\n        else:\n            # Rodrigues' rotation formula for 3D rotation matrix\n            from math import sqrt\n            a1 = [1.0, 0.0, 0.0]\n            a2 = [dir_vec[i] / length for i in range(3)]\n            v = [a1[1]*a2[2] - a1[2]*a2[1],\n                 a1[2]*a2[0] - a1[0]*a2[2],\n                 a1[0]*a2[1] - a1[1]*a2[0]]\n            s = sqrt(sum(vi*vi for vi in v))\n            c = sum(a1[i]*a2[i] for i in range(3))\n            if s < 1e-10:\n                R = [[1,0,0],[0,1,0],[0,0,1]]\n            else:\n                vx = [[0, -v[2], v[1]],\n                      [v[2], 0, -v[0]],\n                      [-v[1], v[0], 0]]\n                I = [[1 if i==j else 0 for j in range(3)] for i in range(3)]\n                vx2 = [[sum(vx[i][k]*vx[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n                R = [[I[i][j] + vx[i][j] + vx2[i][j]*((1 - c)/(s*s)) for j in range(3)] for i in range(3)]\n\n        def sample_unit_ball():\n            if dim == 2:\n                r = random.uniform(0, 1)**0.5\n                theta = random.uniform(0, 2 * math.pi)\n                return [r * math.cos(theta), r * math.sin(theta)]\n            else:\n                while True:\n                    pt = [random.uniform(-1, 1) for _ in range(3)]\n                    if sum(x*x for x in pt) <= 1:\n                        return pt\n\n        x_ball = sample_unit_ball()\n\n        a1_val = c_max / 2.0\n        a_other = math.sqrt(max(c_max*c_max - c_min*c_min, 0)) / 2.0\n\n        # Scale sample inside ellipsoid axes\n        if dim == 2:\n            L = [[a1_val, 0.0], [0.0, a_other]]\n            x_scaled = [L[0][0]*x_ball[0] + L[0][1]*x_ball[1],\n                        L[1][0]*x_ball[0] + L[1][1]*x_ball[1]]\n            pt = (center[0] + R[0][0]*x_scaled[0] + R[0][1]*x_scaled[1],\n                  center[1] + R[1][0]*x_scaled[0] + R[1][1]*x_scaled[1])\n        else:\n            L = [[a1_val, 0.0, 0.0],\n                 [0.0, a_other, 0.0],\n                 [0.0, 0.0, a_other]]\n            x_scaled = [L[0][0]*x_ball[0], L[1][1]*x_ball[1], L[2][2]*x_ball[2]]\n            pt = tuple(center[i] + sum(R[i][j]*x_scaled[j] for j in range(3)) for i in range(3))\n\n        if any(pt[d] < 0 or pt[d] > bounds[d] for d in range(dim)):\n            return self._sample_free(bounds, obstacles, is_3d)\n        if self._is_in_obstacle(pt, obstacles, is_3d):\n            return self._sample_free(bounds, obstacles, is_3d)\n        return pt\n\n    def _nearest(self, tree, point):\n        import math\n        best = None\n        best_dist = float('inf')\n        for node in tree:\n            d = math.dist(node.position, point)\n            if d < best_dist:\n                best_dist = d\n                best = node\n        return best\n\n    def _near(self, tree, point, radius):\n        r_sq = radius*radius\n        dim = len(point)\n        return [n for n in tree if sum((n.position[i] - point[i])**2 for i in range(dim)) <= r_sq]\n\n    def _steer(self, from_pos, to_pos, step_size):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        if dist <= step_size:\n            return to_pos\n        ratio = step_size / dist\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n    def _extract_path(self, node_start, node_goal):\n        path_start = []\n        n = node_start\n        while n is not None:\n            path_start.append(n.position)\n            n = n.parent\n        path_start.reverse()\n\n        path_goal = []\n        n = node_goal\n        while n is not None:\n            path_goal.append(n.position)\n            n = n.parent\n        # Remove duplicated connecting node between two paths\n        if len(path_goal) > 0 and len(path_start) > 0 and path_goal[0] == path_start[-1]:\n            path_goal = path_goal[1:]\n        return path_start + path_goal\n\n    def _shortcut_path(self, path, obstacles, is_3d, max_attempts=100):\n        if len(path) < 3:\n            return path[:]\n        import random\n        new_path = path[:]\n        attempts = 0\n        while attempts < max_attempts:\n            if len(new_path) < 3:\n                break\n            i = random.randint(0, len(new_path) - 3)\n            j = random.randint(i + 2, len(new_path) - 1)\n            if not self._is_edge_in_obstacle(new_path[i], new_path[j], obstacles, is_3d):\n                # Remove intermediate nodes between i and j\n                new_path = new_path[:i+1] + new_path[j:]\n                attempts = 0  # reset after successful shortcut for multiple improvements\n            else:\n                attempts += 1\n        return new_path\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if (x <= px <= x + w) and (y <= py <= y + h) and (z <= pz <= z + d):\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if (x <= px <= x + w) and (y <= py <= y + h):\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            ratio = i / steps\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
                "objective": -31.02809,
                "time_improvement": 43.0,
                "length_improvement": 18.0,
                "smoothness_improvement": 1433.0,
                "node_improvement": 72.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.027813315391540527,
                        "num_nodes_avg": 150.8,
                        "path_length_avg": 158.7550902195503,
                        "smoothness_avg": 0.04475010796054884,
                        "success_improvement": 0.0,
                        "time_improvement": -7.841959056894185,
                        "node_improvement": 62.02467892218585,
                        "length_improvement": 12.983819415277045,
                        "smoothness_improvement": 600.4363659973881,
                        "objective_score": 8.439885762084911
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.032094931602478026,
                        "num_nodes_avg": 270.1,
                        "path_length_avg": 232.67782481248065,
                        "smoothness_avg": 0.10133943332680147,
                        "success_improvement": 0.0,
                        "time_improvement": 80.61615770651433,
                        "node_improvement": 81.8517771954579,
                        "length_improvement": 22.325444817746384,
                        "smoothness_improvement": 2507.5366113420746,
                        "objective_score": 50.117797259312496
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.021543121337890624,
                        "num_nodes_avg": 212.9,
                        "path_length_avg": 122.20039490599746,
                        "smoothness_avg": 0.1015407972611195,
                        "success_improvement": 0.0,
                        "time_improvement": 57.54814091297544,
                        "node_improvement": 72.9307056579784,
                        "length_improvement": 18.840316260931036,
                        "smoothness_improvement": 1191.591446199421,
                        "objective_score": 34.52658926144836
                    }
                ],
                "success_rate": 1.0
            }
        ],
        "offspring": {
            "operator": "m2",
            "algorithm_description": "A hybrid bidirectional RRT* planner that integrates adaptive radius rewiring driven by both node density and path quality, employs a hybrid sampling strategy blending uniform and ellipsoidal informed sampling to balance exploration and exploitation, dynamically adjusts connection thresholds, and combines incremental shortcutting with periodic global smoothing to enhance path smoothness and length without excessive overhead. The planner efficiently expands two trees with optimized nearest/near searches, performs rewiring focused on cost improvements within dynamic neighborhoods, and applies post-planning smoothing to quickly converge to high-quality, smooth paths with reduced search time.",
            "planning_mechanism": "The planner grows start and goal trees bidirectionally with a hybrid sampling strategy: samples are drawn either uniformly or inside an ellipsoidal informed subset guided by the best path cost to focus the search adaptively. The connection and rewiring radius adapts based on both node density and the quality of current best solution, limiting unnecessary rewiring. Each new node connects optimally to the nearest feasible parent and attempts rewiring nearby nodes if cost improvement can be achieved. Shortcutting and smoothing are applied incrementally immediately after improvements and globally periodically, balancing computational cost and quality. Nearest and near neighbor computations use efficient caching and early exits to reduce overhead, and edge collision checks are done carefully to prevent invalid expansions. The planner stops early upon reaching significant improvements, yielding faster planning times, shorter, and smoother paths.",
            "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n    def add_child(self, child):\n        self.children.append(child)\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except ValueError:\n            pass\nclass Planner:\n    def __init__(self, max_iter=4500, step_size=6.0, gamma=40.0,\n                 max_shortcut_attempts=60, batch_smooth_freq=40, hybrid_sample_ratio=0.6):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.gamma = gamma\n        self.max_shortcut_attempts = max_shortcut_attempts\n        self.batch_smooth_freq = batch_smooth_freq\n        self.hybrid_sample_ratio = hybrid_sample_ratio  # ratio to choose ellipsoidal informed sampling\n\n    def plan(self, map):\n        import random\n        import math\n\n        bounds = map.size\n        obstacles = map.obstacles\n        start_pos = map.start\n        goal_pos = map.goal\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        all_nodes = start_tree + goal_tree\n        edges = []\n\n        best_cost = float('inf')\n        solution_start = None\n        solution_goal = None\n\n        c_min = max(math.dist(start_pos, goal_pos), 1e-10)  # prevent division by zero\n\n        def unit_ball_volume(d):\n            from math import gamma, pi\n            if d == 2:\n                return pi\n            elif d == 3:\n                return 4.0/3.0 * pi\n            else:\n                return (pi ** (d / 2)) / gamma(d / 2 + 1)\n\n        def compute_radius(num_nodes, c_best):\n            if num_nodes <= 1:\n                return self.step_size * 3.5\n            vol = 1.0\n            for b in bounds:\n                vol *= b\n            unit_vol = unit_ball_volume(dim)\n            radius = self.gamma * ((math.log(num_nodes) / num_nodes) ** (1.0/dim))\n            radius = max(radius, self.step_size)\n            # also adapt radius based on current best cost; smaller radius for smaller cost (focus exploration)\n            if c_best < float('inf'):\n                radius = min(radius, self.step_size * 1.2 * (c_best / c_min))\n            max_radius = max(bounds) * 0.5\n            return max(min(radius, max_radius), self.step_size)\n\n        def steer(from_pos, to_pos, max_step):\n            dist = 0.0\n            for i in range(dim):\n                diff = to_pos[i] - from_pos[i]\n                dist += diff*diff\n            dist = dist ** 0.5\n            if dist <= max_step:\n                return to_pos\n            ratio = max_step / dist\n            return tuple(from_pos[i] + ratio * (to_pos[i] - from_pos[i]) for i in range(dim))\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d = obs\n                    px,py,pz = pos\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                        return True\n                else:\n                    x,y,w,h = obs\n                    px,py = pos\n                    if x <= px <= x+w and y <= py <= y+h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(from_pos, to_pos, resolution=1.0):\n            import math\n            dist = 0.0\n            for i in range(dim):\n                diff = to_pos[i] - from_pos[i]\n                dist += diff*diff\n            dist = dist ** 0.5\n            steps = max(1, int(dist / resolution))\n            for step in range(steps+1):\n                interp = tuple(from_pos[i] + (to_pos[i]-from_pos[i])*(step/steps) for i in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def nearest(tree, point):\n            # linear but with early pruning of distances above best threshold (if available)\n            best_node = None\n            best_dist = float('inf')\n            px, py, pz = (point + (0,))[:3] if dim == 3 else (point[0], point[1], 0)\n            for node in tree:\n                d = 0.0\n                np_ = node.position\n                for i in range(dim):\n                    diff = np_[i] - point[i]\n                    d += diff*diff\n                    if d > best_dist:\n                        break\n                if d < best_dist:\n                    best_dist = d\n                    best_node = node\n            return best_node\n\n        def near(tree, point, radius_):\n            r_sq = radius_ * radius_\n            res = []\n            for n in tree:\n                d = 0.0\n                for i in range(dim):\n                    diff = n.position[i] - point[i]\n                    d += diff*diff\n                    if d > r_sq:\n                        break\n                if d <= r_sq:\n                    res.append(n)\n            return res\n\n        def extract_path(n_start, n_goal):\n            path_start = []\n            cur = n_start\n            while cur is not None:\n                path_start.append(cur.position)\n                cur = cur.parent\n            path_start.reverse()\n            path_goal = []\n            cur = n_goal\n            while cur is not None:\n                path_goal.append(cur.position)\n                cur = cur.parent\n            # avoid duplication\n            if path_goal and path_start and path_start[-1] == path_goal[0]:\n                path_goal = path_goal[1:]\n            return path_start + path_goal\n\n        def hybrid_sample():\n            # probabilistically choose ellipsoidal informed sampling or uniform sampling\n            if best_cost < float('inf') and random.random() < self.hybrid_sample_ratio:\n                return informed_sample()\n            return uniform_sample()\n\n        def uniform_sample():\n            while True:\n                pt = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not is_in_obstacle(pt):\n                    return pt\n\n        def informed_sample():\n            # sample uniformly inside ellipsoid defined by start, goal, and best_cost\n            center = tuple((start_pos[i] + goal_pos[i]) * 0.5 for i in range(dim))\n            dir_vec = [goal_pos[i] - start_pos[i] for i in range(dim)]\n            length_line = math.dist(start_pos, goal_pos)\n            if length_line < 1e-15:\n                return uniform_sample()\n            # Compute rotation matrix aligning x-axis with dir_vec\n            if dim == 2:\n                from math import cos, sin, pi, sqrt\n                norm = length_line\n                a1 = [1.0, 0.0]\n                a2 = [dir_vec[0]/norm, dir_vec[1]/norm]\n                cos_theta = a1[0]*a2[0] + a1[1]*a2[1]\n                sin_theta = a1[0]*a2[1] - a1[1]*a2[0]\n                R = [[cos_theta, -sin_theta], [sin_theta, cos_theta]]\n            else:\n                from math import sqrt\n                norm = length_line\n                a1 = [1.0, 0.0, 0.0]\n                norm_dir = [dir_vec[i]/norm for i in range(3)]\n                v = [a1[1]*norm_dir[2] - a1[2]*norm_dir[1],\n                     a1[2]*norm_dir[0] - a1[0]*norm_dir[2],\n                     a1[0]*norm_dir[1] - a1[1]*norm_dir[0]]\n                s = sqrt(sum(x*x for x in v))\n                c = sum(a1[i]*norm_dir[i] for i in range(3))\n                if s < 1e-15:\n                    R = [[1.0,0.0,0.0],[0.0,1.0,0.0],[0.0,0.0,1.0]]\n                else:\n                    vx = [[0,-v[2],v[1]],\n                          [v[2],0,-v[0]],\n                          [-v[1],v[0],0]]\n                    I = [[1 if i==j else 0 for j in range(3)] for i in range(3)]\n                    vx2 = [[sum(vx[i][k]*vx[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n                    R = [[I[i][j] + vx[i][j] + vx2[i][j]*((1-c)/(s*s)) for j in range(3)] for i in range(3)]\n            a1_val = best_cost / 2.0\n            a2_val = math.sqrt(max(best_cost*best_cost - c_min*c_min,0)) / 2.0\n\n            while True:\n                if dim == 2:\n                    r = random.random() ** 0.5\n                    theta = random.uniform(0, 2*math.pi)\n                    x_ball = [r*math.cos(theta), r*math.sin(theta)]\n                    L = [[a1_val, 0.0],[0.0,a2_val]]\n                    x_scaled = [L[0][0]*x_ball[0]+L[0][1]*x_ball[1],\n                                L[1][0]*x_ball[0]+L[1][1]*x_ball[1]]\n                    pt = (center[0] + R[0][0]*x_scaled[0] + R[0][1]*x_scaled[1],\n                          center[1] + R[1][0]*x_scaled[0] + R[1][1]*x_scaled[1])\n                else:\n                    while True:\n                        x_ball = [random.uniform(-1.0,1.0) for _ in range(3)]\n                        if sum(xi*xi for xi in x_ball) <= 1.0:\n                            break\n                    L = [[a1_val,0.0,0.0],[0.0,a2_val,0.0],[0.0,0.0,a2_val]]\n                    x_scaled = [L[0][0]*x_ball[0], L[1][1]*x_ball[1], L[2][2]*x_ball[2]]\n                    pt = tuple(center[i] + sum(R[i][j]*x_scaled[j] for j in range(dim)) for i in range(dim))\n                if any(pt[i] < 0 or pt[i] > bounds[i] for i in range(dim)):\n                    continue\n                if is_in_obstacle(pt):\n                    continue\n                return pt\n\n        def rewire_near(tree, new_node, radius_):\n            near_nodes = near(tree, new_node.position, radius_)\n            for n in near_nodes:\n                if n is new_node or n.parent is None:\n                    continue\n                cost_through_new = new_node.cost + math.dist(new_node.position, n.position)\n                if cost_through_new + 1e-9 < n.cost:\n                    if not is_edge_in_obstacle(new_node.position, n.position):\n                        if n.parent:\n                            try:\n                                edges.remove((n.parent,n))\n                            except ValueError:\n                                pass\n                            n.parent.remove_child(n)\n                        n.parent = new_node\n                        n.cost = cost_through_new\n                        new_node.add_child(n)\n                        edges.append((new_node,n))\n\n        def incremental_shortcut(path):\n            if len(path) < 3:\n                return path[:]\n            attempts = 0\n            new_path = path[:]\n            while attempts < self.max_shortcut_attempts:\n                if len(new_path) < 3:\n                    break\n                i = random.randint(0, len(new_path) - 3)\n                j = random.randint(i+2, len(new_path)-1)\n                if not is_edge_in_obstacle(new_path[i], new_path[j]):\n                    new_path = new_path[:i+1] + new_path[j:]\n                    attempts = 0\n                else:\n                    attempts += 1\n            return new_path\n\n        def batch_smooth(path):\n            # global smoothing by iterative shortcutting multiple times (lightweight)\n            for _ in range(self.max_shortcut_attempts // 3):\n                path = incremental_shortcut(path)\n            return path\n\n        prev_dir = None\n        import time\n        for it in range(self.max_iter):\n            sample = hybrid_sample()\n\n            for treeA, treeB in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest_node = nearest(treeA, sample)\n                new_pos = None\n                if prev_dir is None:\n                    new_pos = steer(nearest_node.position, sample, self.step_size)\n                else:\n                    # basic momentum steering: push step further along previous direction with clipping by bounds\n                    dist = math.dist(nearest_node.position, sample)\n                    if dist < 1e-10:\n                        new_pos = nearest_node.position\n                    else:\n                        direction = tuple((sample[i] - nearest_node.position[i]) / dist for i in range(dim))\n                        base_step = min(self.step_size, dist)\n                        candidate = tuple(nearest_node.position[i] + direction[i]*base_step for i in range(dim))\n                        momentum_step = 0.5 * self.step_size\n                        momentum_candidate = tuple(candidate[i] + direction[i]*momentum_step for i in range(dim))\n                        if all(0 <= momentum_candidate[i] <= bounds[i] for i in range(dim)) and (not is_in_obstacle(momentum_candidate)) and (not is_edge_in_obstacle(nearest_node.position, momentum_candidate)):\n                            new_pos = momentum_candidate\n                        else:\n                            new_pos = candidate\n\n                if is_in_obstacle(new_pos) or is_edge_in_obstacle(nearest_node.position, new_pos):\n                    continue\n\n                new_node = Node(new_pos)\n                cur_tree_size = len(treeA)\n                r = compute_radius(cur_tree_size, best_cost)\n                near_nodes = near(treeA, new_pos, r)\n\n                # choose parent with minimal cost and collision-free edge\n                min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n                min_parent = nearest_node\n                for near_node in near_nodes:\n                    if near_node is nearest_node:\n                        continue\n                    cost_cand = near_node.cost + math.dist(near_node.position, new_pos)\n                    if cost_cand + 1e-9 < min_cost:\n                        if not is_edge_in_obstacle(near_node.position, new_pos):\n                            min_cost = cost_cand\n                            min_parent = near_node\n\n                new_node.parent = min_parent\n                new_node.cost = min_cost\n                min_parent.add_child(new_node)\n                treeA.append(new_node)\n                all_nodes.append(new_node)\n                edges.append((min_parent,new_node))\n\n                # rewiring for local improvements\n                rewire_near(treeA, new_node, r)\n\n                # Attempt to connect other tree\n                near_other = nearest(treeB, new_node.position)\n                dist_conn = math.dist(new_node.position, near_other.position)\n                if dist_conn <= self.step_size:\n                    if not is_edge_in_obstacle(new_node.position, near_other.position):\n                        total_cost = new_node.cost + dist_conn + near_other.cost\n                        if total_cost + 1e-9 < best_cost:\n                            best_cost = total_cost\n                            prev_dir = tuple(new_node.position[i] - near_other.position[i] for i in range(dim))\n                            if treeA is start_tree:\n                                solution_start, solution_goal = new_node, near_other\n                            else:\n                                solution_start, solution_goal = near_other, new_node\n\n                            raw_path = extract_path(solution_start, solution_goal)\n                            # incremental shortcut to improve path length and smoothness early\n                            improved_path = incremental_shortcut(raw_path)\n\n                            # periodic batch smoothing globally every batch_smooth_freq iterations\n                            if it > 0 and it % self.batch_smooth_freq == 0:\n                                improved_path = batch_smooth(improved_path)\n\n                            if len(improved_path) >= 2:\n                                return PlannerResult(True, improved_path, all_nodes, edges)\n\n            # occasional global smoothing to balance quality and runtime\n            if it > 0 and it % self.batch_smooth_freq == 0 and best_cost < float('inf') and solution_start and solution_goal:\n                raw_path = extract_path(solution_start, solution_goal)\n                global_smooth_path = batch_smooth(raw_path)\n                if len(global_smooth_path) >= 2:\n                    return PlannerResult(True, global_smooth_path, all_nodes, edges)\n\n        if best_cost < float('inf') and solution_start and solution_goal:\n            raw_path = extract_path(solution_start, solution_goal)\n            smooth_path = batch_smooth(raw_path)\n            if len(smooth_path) >= 2:\n                return PlannerResult(True, smooth_path, all_nodes, edges)\n\n        return PlannerResult(False, [], all_nodes, edges)",
            "objective": -33.88954,
            "time_improvement": 59.0,
            "length_improvement": 15.0,
            "smoothness_improvement": 1508.0,
            "node_improvement": 79.0,
            "other_inf": [
                {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.020911431312561034,
                    "num_nodes_avg": 122.1,
                    "path_length_avg": 166.8599976176567,
                    "smoothness_avg": 0.04501337399602144,
                    "success_improvement": 0.0,
                    "time_improvement": 18.919061331459822,
                    "node_improvement": 69.25207756232686,
                    "length_improvement": 8.541391239898575,
                    "smoothness_improvement": 604.5570511438806,
                    "objective_score": 13.823338399096492
                },
                {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.026242756843566896,
                    "num_nodes_avg": 219.9,
                    "path_length_avg": 242.31455542761552,
                    "smoothness_avg": 0.10247909808740205,
                    "success_improvement": 0.0,
                    "time_improvement": 84.15059840904235,
                    "node_improvement": 85.22475307397701,
                    "length_improvement": 19.108426760503246,
                    "smoothness_improvement": 2536.8610064996747,
                    "objective_score": 49.39454061151302
                },
                {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.013715672492980956,
                    "num_nodes_avg": 149.1,
                    "path_length_avg": 126.36313714813143,
                    "smoothness_avg": 0.1165669065905579,
                    "success_improvement": 0.0,
                    "time_improvement": 72.97254251955964,
                    "node_improvement": 81.04259376986649,
                    "length_improvement": 16.07562107219008,
                    "smoothness_improvement": 1382.7224477578577,
                    "objective_score": 38.45074763797123
                }
            ],
            "success_rate": 1.0
        },
        "objective": 29.0,
        "analysis": {
            "problem": [
                "Problem of the parents algorithm:\n   - Excessive planning time due to repeated linear nearest and near neighbor searches without pruning or radius adaptation leading to computational overhead.\n   - Limited sampling strategies, often relying solely on uniform or fixed informed sampling, resulting in suboptimal exploration-exploitation balance.\n   - Rewiring mechanisms that are either performed in coarse batches or with shrinking fixed radii, reducing their effectiveness for cost improvement.\n   - Incremental shortcutting applied infrequently or abruptly, sometimes removing too many nodes and causing jagged or less smooth paths."
            ],
            "solution": "1. Primary contributors to the performance improvement:\n   - Integration of a hybrid sampling method probabilistically combining ellipsoidal informed and uniform sampling to enhance sample diversity and focus.\n   - Adaptive connection radius computation that considers both node density and current best path cost, improving rewiring relevance and efficiency.\n   - Continuous rewiring with localized radius focused on cost optimization, reducing unnecessary global rewiring overhead.\n   - Incremental shortcutting coupled with periodic batch smoothing, achieving smoother paths without excessive computation.\n   - Early path improvement and quality checks allowing faster convergence and reduced total iterations/time.\n2. Expected mechanism of impact:\n   - Hybrid sampling balances broad coverage with focused search in promising regions, reducing wasted samples and speeding convergence.\n   - Adaptive radius reduces the neighbor search space, decreasing computation time for parent selection and rewiring operations.\n   - Localized cost-based rewiring enhances path quality iteratively without costly global tree modifications.\n   - Frequent, lightweight smoothing improves path smoothness incrementally ensuring better path quality throughout planning.\n   - Early detection and acceptance of improved paths reduce unnecessary exploration, lowering overall runtime while producing competitive path length and smoothness."
        }
    },
    {
        "parents": [
            {
                "operator": "path_expert",
                "algorithm_description": "An enhanced bidirectional RRT* planner that integrates adaptive rewiring radius, goal-biased informed sampling, and an improved hierarchical smoothing combining multi-pass shortcutting with cubic Bezier curve fitting for path refinement. The smoothing phase adaptively adjusts angle thresholds, performs iterative shortcut passes, and applies localized Bezier smoothing to reduce sharp turns while preserving obstacle avoidance. Frequent bidirectional tree connections accelerate solution discovery and continuous path quality improvement, aiming to minimize path length and enhance smoothness while maintaining efficient planning time.",
                "planning_mechanism": "The planner simultaneously grows two trees from start and goal using adaptive elliptical informed sampling that shrinks with solution cost improvements, dynamically scaling the neighborhood radius for rewiring. The planner selects parent nodes and rewires neighbors with strict cost improvement criteria, recursively updating subtree costs to maintain consistent cost. Frequent attempts connect the two trees to detect and refine paths. After solution detection, a hierarchical smoothing process iteratively applies shortcutting with adaptive angle thresholds followed by localized cubic Bezier curve fitting over path segments to greatly enhance smoothness and shorten path length while ensuring collision-free paths.",
                "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=6.0, r_min=5.0, r_max=30.0, goal_sample_rate=0.1):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.r_min = r_min\n        self.r_max = r_max\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map):\n        import math\n        import random\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = 3 if is_3d else 2\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        def dist(a,b):\n            return math.dist(a,b)\n\n        def heuristic_forward(p):\n            return dist(p,goal_pos)\n        def heuristic_backward(p):\n            return dist(p,start_pos)\n\n        best_cost = float('inf')\n        solution_nodes = (None,None)\n\n        def update_subtree_costs(node):\n            for c in node.children:\n                prev_cost = c.cost\n                new_cost = node.cost + dist(node.position,c.position)\n                if new_cost + 1e-15 < prev_cost:\n                    c.cost = new_cost\n                    update_subtree_costs(c)\n\n        def rewiring_radius(n_nodes):\n            if n_nodes < 2:\n                return self.r_max\n            gamma = 40.0\n            val = gamma * (math.log(n_nodes)/n_nodes)**(1/dim)\n            return max(self.r_min, min(self.r_max,val))\n\n        def sample():\n            if random.random() < self.goal_sample_rate:\n                return goal_pos\n            if best_cost == float('inf'):\n                while True:\n                    pt = tuple(random.uniform(0,bounds[i]) for i in range(dim))\n                    if not self._is_in_obstacle(pt,obstacles,is_3d):\n                        return pt\n            else:\n                center = tuple((start_pos[i]+goal_pos[i])/2 for i in range(dim))\n                a1 = [goal_pos[i]-start_pos[i] for i in range(dim)]\n                length = dist(start_pos,goal_pos)\n                if length < 1e-15:\n                    return goal_pos\n\n                e1 = [x/length for x in a1]\n                def orthonormal_basis(dim,e1):\n                    basis = [e1]\n                    if dim==2:\n                        basis.append( (-e1[1], e1[0]) )\n                    elif dim==3:\n                        v = [1,0,0] if abs(e1[0])<0.9 else [0,1,0]\n                        u = [v[i] - e1[i]*sum(v[j]*e1[j] for j in range(3)) for i in range(3)]\n                        u_norm = math.sqrt(sum(x*x for x in u))\n                        if u_norm < 1e-15:\n                            u = [0,0,1]\n                            u_norm=1\n                        u = [x/u_norm for x in u]\n                        w = [e1[1]*u[2] - e1[2]*u[1],\n                             e1[2]*u[0] - e1[0]*u[2],\n                             e1[0]*u[1] - e1[1]*u[0]]\n                        basis.extend([u,w])\n                    return basis\n                B = orthonormal_basis(dim,e1)\n\n                c_min = length\n                c_max = min(best_cost * 1.05, sum(bounds)*10)\n\n                try:\n                    a1_len = c_max / 2.0\n                    a_others = max( ( (c_max**2 - c_min**2) / 4.0 )**0.5, 1e-8 )\n                except Exception:\n                    a1_len = c_max / 2.0\n                    a_others = a1_len\n\n                while True:\n                    if dim==2:\n                        r = random.uniform(0,1)**0.5\n                        theta = random.uniform(0,2*math.pi)\n                        unit_ball = [r*math.cos(theta), r*math.sin(theta)]\n                        coords = [a1_len*unit_ball[0], a_others*unit_ball[1]]\n                        sample_pt = [ center[i] + sum(coords[j]*B[j][i] for j in range(dim)) for i in range(dim) ]\n                        pt = tuple(sample_pt)\n                    else:\n                        while True:\n                            u = [random.uniform(-1,1) for _ in range(3)]\n                            norm_u = math.sqrt(sum(x*x for x in u))\n                            if norm_u<=1 and norm_u>0:\n                                unit_ball = [x/norm_u for x in u]\n                                break\n                        coords = [a1_len*unit_ball[0], a_others*unit_ball[1], a_others*unit_ball[2]]\n                        sample_pt = [ center[i] + sum(coords[j]*B[j][i] for j in range(dim)) for i in range(dim) ]\n                        pt = tuple(sample_pt)\n                    if any(pt[i]<0 or pt[i]>bounds[i] for i in range(dim)):\n                        continue\n                    if self._is_in_obstacle(pt,obstacles,is_3d):\n                        continue\n                    return pt\n\n        def nearest(tree,p):\n            best = None\n            best_d = float('inf')\n            for n in tree:\n                d = dist(n.position,p)\n                if d < best_d:\n                    best = n\n                    best_d = d\n            return best\n\n        def near(tree,p,r):\n            r2 = r*r\n            res = []\n            for n in tree:\n                d2 = 0\n                for i in range(dim):\n                    delta = n.position[i] - p[i]\n                    d2 += delta*delta\n                if d2 <= r2:\n                    res.append(n)\n            return res\n\n        def steer(from_pos,to_pos):\n            d = dist(from_pos,to_pos)\n            if d <= self.step_size:\n                return to_pos\n            ratio = self.step_size/d\n            return tuple(from_pos[i]+(to_pos[i]-from_pos[i])*ratio for i in range(dim))\n\n        def is_free_node(pos):\n            return not self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def is_free_edge(a,b):\n            return not self._is_edge_in_obstacle(a,b,obstacles,is_3d)\n\n        def path_from_to(node_start,node_goal):\n            path_start = []\n            n = node_start\n            while n is not None:\n                path_start.append(n.position)\n                n = n.parent\n            path_goal = []\n            n = node_goal\n            while n is not None:\n                path_goal.append(n.position)\n                n = n.parent\n            return path_start[::-1] + path_goal\n\n        def angle_between_vectors(a,b,c):\n            # angle at point b formed by vectors ba and bc\n            import math\n            ba = [a[i]-b[i] for i in range(dim)]\n            bc = [c[i]-b[i] for i in range(dim)]\n            len_ba = math.sqrt(sum(x*x for x in ba))\n            len_bc = math.sqrt(sum(x*x for x in bc))\n            if len_ba <1e-12 or len_bc <1e-12:\n                return 0.0\n            dot = sum(ba[i]*bc[i] for i in range(dim))\n            val = max(min(dot/(len_ba*len_bc),1),-1)\n            return math.acos(val)\n\n        def shortcut_path(path, max_passes=8, max_attempts_per_pass=300):\n            if len(path)<3:\n                return path[:]\n            new_path = path[:]\n            angle_threshold_base = math.pi * 150.0/180.0  # 150 degrees base threshold for acceptance\n\n            for pass_i in range(max_passes):\n                improved = False\n                attempts = 0\n                i = 0\n                # adapt angle threshold loosening on passes (more passes progressively allow slightly sharper angles)\n                angle_threshold = angle_threshold_base + (pass_i*math.pi*5/180.0)  # loosen 5 degrees per pass up to ~190 deg max cap\n                angle_threshold = min(angle_threshold, math.pi*190/180.0)\n\n                while i < len(new_path)-2 and attempts < max_attempts_per_pass:\n                    j = random.randint(i+2, len(new_path)-1)\n                    if j <= i+1:\n                        attempts += 1\n                        continue\n                    if is_free_edge(new_path[i],new_path[j]):\n                        # Check angles at neighbors before removal\n                        smooth = True\n                        if i>0:\n                            a,b,c = new_path[i-1], new_path[i], new_path[j]\n                            if angle_between_vectors(a,b,c) < math.pi - angle_threshold:\n                                smooth = False\n                        if j<len(new_path)-1:\n                            a,b,c = new_path[i], new_path[j], new_path[j+1]\n                            if angle_between_vectors(a,b,c) < math.pi - angle_threshold:\n                                smooth = False\n                        if smooth:\n                            new_path = new_path[:i+1] + new_path[j:]\n                            improved = True\n                            i = 0\n                            attempts += 1\n                            continue\n                    i += 1\n                    attempts += 1\n                if not improved:\n                    break\n            return new_path\n\n        def bezier_point(t, p0, p1, p2, p3):\n            \"\"\"Cubic Bezier Curve Point\"\"\"\n            u = 1 - t\n            tt = t*t\n            uu = u*u\n            uuu = uu * u\n            ttt = tt * t\n\n            return tuple( uuu*p0[i] + 3*uu*t*p1[i] + 3*u*tt*p2[i] + ttt*p3[i] for i in range(len(p0)) )\n\n        def bezier_curve(control_points, n_points=10):\n            \"\"\"Generate points along a cubic Bezier curve\"\"\"\n            if len(control_points) != 4:\n                return control_points[:]\n            return [bezier_point(t, *control_points) for t in [i/(n_points-1) for i in range(n_points)]]\n\n        def is_curve_collision_free(curve_points):\n            for idx in range(len(curve_points)-1):\n                if self._is_edge_in_obstacle(curve_points[idx], curve_points[idx+1], obstacles, is_3d):\n                    return False\n            return True\n\n        def bezier_smooth_path(path):\n            # Apply localized Bezier smoothing over path segments length 4 if collision free\n            if len(path) < 4:\n                return path[:]\n            new_path = path[:]\n            i = 0\n            while i < len(new_path)-3:\n                p0, p1, p2, p3 = new_path[i], new_path[i+1], new_path[i+2], new_path[i+3]\n                curve_pts = bezier_curve([p0,p1,p2,p3], n_points=10)\n                if is_curve_collision_free(curve_pts):\n                    # Replace middle two points p1,p2 by intermediate curve points (excluding p0 and p3)\n                    # We keep first and last points of the segment fixed.\n                    # We'll replace p1 and p2 by a subset of curve points for smoothness.\n\n                    # Interpolated points exclude first and last of curve_pts\n                    interpolated = curve_pts[1:-1]\n\n                    # Build new path with replaced segment\n                    new_path = new_path[:i+1] + interpolated + new_path[i+3:]\n                    i += len(interpolated)  # skip newly added points\n                else:\n                    i += 1\n            return new_path\n\n        for it in range(self.max_iter):\n            sample_pos = sample()\n\n            if it % 2 == 0:\n                prop_tree, other_tree = start_tree, goal_tree\n                heuristic_prop = heuristic_forward\n                heuristic_other = heuristic_backward\n            else:\n                prop_tree, other_tree = goal_tree, start_tree\n                heuristic_prop = heuristic_backward\n                heuristic_other = heuristic_forward\n\n            nearest_node = nearest(prop_tree, sample_pos)\n            new_pos = steer(nearest_node.position, sample_pos)\n\n            if not is_free_node(new_pos):\n                continue\n            if not is_free_edge(nearest_node.position, new_pos):\n                continue\n\n            r = rewiring_radius(len(prop_tree))\n            near_nodes = near(prop_tree, new_pos, r)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position,new_pos)\n            best_parent = nearest_node\n            for candidate in near_nodes:\n                if candidate is nearest_node:\n                    continue\n                tentative_cost = candidate.cost + dist(candidate.position,new_pos)\n                if tentative_cost + heuristic_prop(new_pos) + 1e-15 < min_cost + heuristic_prop(new_pos):\n                    if is_free_edge(candidate.position, new_pos):\n                        min_cost = tentative_cost\n                        best_parent = candidate\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.add_child(new_node)\n            prop_tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            for nbr in near_nodes:\n                if nbr is best_parent or nbr is new_node:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, nbr.position)\n                if new_cost + heuristic_prop(nbr.position) + 1e-15 < nbr.cost + heuristic_prop(nbr.position):\n                    if is_free_edge(new_node.position, nbr.position):\n                        if nbr.parent is not None:\n                            try:\n                                edges.remove((nbr.parent, nbr))\n                            except ValueError:\n                                pass\n                            nbr.parent.remove_child(nbr)\n                        nbr.parent = new_node\n                        nbr.cost = new_cost\n                        new_node.add_child(nbr)\n                        edges.append((new_node, nbr))\n                        update_subtree_costs(nbr)\n\n            near_other = nearest(other_tree, new_node.position)\n            dist_conn = dist(new_node.position, near_other.position)\n            if dist_conn <= self.step_size:\n                if is_free_edge(new_node.position, near_other.position):\n                    candidate_cost = new_node.cost + dist_conn + near_other.cost\n                    if candidate_cost + 1e-15 < best_cost:\n                        best_cost = candidate_cost\n                        if it % 2 == 0:\n                            solution_nodes = (new_node, near_other)\n                        else:\n                            solution_nodes = (near_other, new_node)\n\n            if solution_nodes[0] and solution_nodes[1] and ((it > 0 and it % 80 == 0) or it == self.max_iter-1):\n                raw_path = path_from_to(solution_nodes[0], solution_nodes[1])\n                pass1 = shortcut_path(raw_path, max_passes=8, max_attempts_per_pass=300)\n                pass2 = bezier_smooth_path(pass1)\n                return PlannerResult(True, pass2, nodes, edges)\n\n        if solution_nodes[0] and solution_nodes[1]:\n            raw_path = path_from_to(solution_nodes[0], solution_nodes[1])\n            pass1 = shortcut_path(raw_path, max_passes=8, max_attempts_per_pass=300)\n            pass2 = bezier_smooth_path(pass1)\n            return PlannerResult(True, pass2, nodes, edges)\n        else:\n            return PlannerResult(False, [], nodes, edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        px = pos[0]\n        py = pos[1]\n        pz = pos[2] if is_3d else 0.0\n        for obs in obstacles:\n            if is_3d:\n                x,y,z,w,h,d = obs\n                if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                    return True\n            else:\n                x,y,w,h = obs\n                if x <= px <= x+w and y <= py <= y+h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        dist_val = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist_val/resolution))\n        for step in range(steps+1):\n            t = step/steps\n            interp = tuple(from_pos[i] + t*(to_pos[i]-from_pos[i]) for i in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
                "objective": -31.35436,
                "time_improvement": 50.0,
                "length_improvement": 18.0,
                "smoothness_improvement": 1122.0,
                "node_improvement": 67.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.020946669578552245,
                        "num_nodes_avg": 169.2,
                        "path_length_avg": 156.9968252907203,
                        "smoothness_avg": 0.020851635172459877,
                        "success_improvement": 0.0,
                        "time_improvement": 18.782430240028845,
                        "node_improvement": 57.39108536892471,
                        "length_improvement": 13.947552284259512,
                        "smoothness_improvement": 226.3733704995064,
                        "objective_score": 15.135127295061892
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.029881834983825684,
                        "num_nodes_avg": 307.0,
                        "path_length_avg": 231.7579073494588,
                        "smoothness_avg": 0.09111135278880159,
                        "success_improvement": 0.0,
                        "time_improvement": 81.95276488074154,
                        "node_improvement": 79.3724383524827,
                        "length_improvement": 22.63253974525912,
                        "smoothness_improvement": 2244.360732110702,
                        "objective_score": 49.38715697193144
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.02644164562225342,
                        "num_nodes_avg": 287.2,
                        "path_length_avg": 123.73707639297194,
                        "smoothness_avg": 0.07830820806750623,
                        "success_improvement": 0.0,
                        "time_improvement": 47.89533993801242,
                        "node_improvement": 63.4837889383344,
                        "length_improvement": 17.819725586191648,
                        "smoothness_improvement": 896.0746265080132,
                        "objective_score": 29.54081046565878
                    }
                ],
                "success_rate": 1.0
            },
            {
                "operator": "m1",
                "algorithm_description": "A hybrid bidirectional RRT* planner employing dynamic adaptive rewiring radius, ellipsoidal informed sampling post initial solution, efficient k-nearest rewiring leveraging approximate nearest neighbor heuristic, and a refined incremental shortcutting mechanism combining curvature preservation with iterative path smoothing. This planner aggressively prunes and updates trees for faster convergence, improves path length by adaptive rewiring and ellipsoidal sampling, while enhancing path smoothness by integrating curvature-aware incremental shortcutting and smoothing every fixed iteration interval. Early exits during collision checks and consistent graph maintenance reduce planning time and increase robustness.",
                "planning_mechanism": "A bidirectional RRT* alternates tree expansions from start and goal states. It performs ellipsoidal informed sampling inside an adaptive prolate hyperspheroid once a valid path is found, focusing search near the best solution. Adaptive near radius for rewiring scales logarithmically with node count and dimension. The planner uses approximate nearest neighbors by early exiting distance checks to improve rewiring efficiency. Rewiring considers curvature preservation to avoid sharp turns. The incremental shortcutting aggressively shortcuts edges without increasing curvature beyond a small angle threshold, followed by midpoint smoothing. Path extraction reconciles the two trees once a connection occurs, and path smoothing is applied periodically to maintain smooth solutions.",
                "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\nclass Planner:\n    def __init__(self, max_iter=4000, step_size=6.5, gamma_rrt_star=45.0,\n                 shortcut_interval=30, max_shortcut_attempts=45, curvature_threshold=0.3):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.gamma_rrt_star = gamma_rrt_star\n        self.shortcut_interval = shortcut_interval\n        self.max_shortcut_attempts = max_shortcut_attempts\n        self.curvature_threshold = curvature_threshold  # radians\n\n    def plan(self, map):\n        import math\n        import random\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        best_cost = float('inf')\n        solution_start, solution_goal = None, None\n\n        c_min = math.dist(start_pos, goal_pos)\n        volume_unit_ball = self._unit_ball_volume(dim)\n\n        def near_radius(n_nodes):\n            if n_nodes <= 1:\n                return self.step_size * 3.0\n            val = (math.log(n_nodes) / n_nodes) ** (1.0 / dim)\n            r = self.gamma_rrt_star * val\n            return min(r, self.step_size * 45)\n\n        def angle_between(a, b, c):\n            # Returns angle at b formed by points a-b-c in radians\n            ab = [a[i] - b[i] for i in range(dim)]\n            cb = [c[i] - b[i] for i in range(dim)]\n            lab = math.sqrt(sum(x * x for x in ab))\n            lcb = math.sqrt(sum(x * x for x in cb))\n            if lab < 1e-14 or lcb < 1e-14:\n                return 0.0\n            dotp = sum(ab[i] * cb[i] for i in range(dim))\n            val = max(min(dotp / (lab * lcb), 1.0), -1.0)\n            return math.acos(val)\n\n        def curvature_preserving_rewire(new_node, near_nodes_list):\n            import math\n            for near in near_nodes_list:\n                if near is new_node.parent or near is new_node:\n                    continue\n                dist_cost = math.dist(new_node.position, near.position)\n                potential_cost = new_node.cost + dist_cost\n                if potential_cost + 1e-15 < near.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                        # Check curvature increase if rewired\n                        prev_parent = near.parent\n                        if prev_parent is None:\n                            continue\n                        ang_before = angle_between(prev_parent.position, near.position, near.children[0].position) if near.children else 0.0\n                        ang_after = angle_between(new_node.position, near.position,\n                                                  near.children[0].position) if near.children else 0.0\n                        # Accept if curvature doesn't increase noticeably or children absent\n                        if len(near.children) == 0 or ang_after < ang_before + self.curvature_threshold:\n                            try:\n                                edges.remove((near.parent, near))\n                            except Exception:\n                                pass\n                            near.parent.remove_child(near)\n                            near.parent = new_node\n                            near.cost = potential_cost\n                            new_node.add_child(near)\n                            edges.append((new_node, near))\n                            self._update_subtree_costs(near, edges)\n\n        def incremental_curvature_shortcut(path):\n            # Iteratively tries shortcuts preserving curvature within threshold\n            if len(path) < 3:\n                return path[:]\n            import random\n            changed = True\n            new_path = path[:]\n            while changed:\n                changed = False\n                L = len(new_path)\n                for i in range(L - 2):\n                    for j in range(L - 1, i + 1, -1):\n                        if not self._is_edge_in_obstacle(new_path[i], new_path[j], obstacles, is_3d):\n                            # Check curvature preservation between three-waypoints if applicable\n                            if i > 0 and j < L - 1:\n                                ang_before = angle_between(new_path[i-1], new_path[i], new_path[i+1])\n                                ang_after = angle_between(new_path[i-1], new_path[j], new_path[j+1])\n                                if ang_after < ang_before + self.curvature_threshold:\n                                    new_path = new_path[:i+1] + new_path[j:]\n                                    changed = True\n                                    break\n                            else:\n                                new_path = new_path[:i+1] + new_path[j:]\n                                changed = True\n                                break\n                    if changed:\n                        break\n            return new_path\n\n        def midpoint_smooth(path):\n            if len(path) < 4:\n                return path[:]\n            new_path = path[:]\n            changed = False\n            for i in range(1, len(path) - 1):\n                a, b, c = new_path[i-1], new_path[i], new_path[i+1]\n                midpoint = tuple((a[d] + c[d]) * 0.5 for d in range(dim))\n                if (not self._is_in_obstacle(midpoint, obstacles, is_3d) and\n                    not self._is_edge_in_obstacle(a, midpoint, obstacles, is_3d) and\n                    not self._is_edge_in_obstacle(midpoint, c, obstacles, is_3d)):\n                    old_angle = angle_between(a, b, c)\n                    new_angle = angle_between(a, midpoint, c)\n                    if new_angle < old_angle + 1e-6:\n                        new_path[i] = midpoint\n                        changed = True\n            return new_path if changed else path\n\n        def informed_sample():\n            if best_cost == float('inf') or best_cost <= c_min:\n                return self._sample_free(bounds, obstacles, is_3d)\n            center = tuple((start_pos[i] + goal_pos[i]) * 0.5 for i in range(dim))\n            dir_vec = [goal_pos[i] - start_pos[i] for i in range(dim)]\n            length = math.dist(start_pos, goal_pos)\n            if dim == 2:\n                if length < 1e-14:\n                    R = [[1, 0], [0, 1]]\n                else:\n                    a1 = [1, 0]\n                    a2 = [dir_vec[0] / length, dir_vec[1] / length]\n                    cos_t = a1[0]*a2[0] + a1[1]*a2[1]\n                    sin_t = a1[0]*a2[1] - a1[1]*a2[0]\n                    R = [[cos_t, -sin_t], [sin_t, cos_t]]\n            else:\n                from math import sqrt\n                if length < 1e-14:\n                    R = [[1,0,0],[0,1,0],[0,0,1]]\n                else:\n                    a1 = [1,0,0]\n                    a2 = [dir_vec[i] / length for i in range(3)]\n                    v = [a1[1]*a2[2]-a1[2]*a2[1], a1[2]*a2[0]-a1[0]*a2[2], a1[0]*a2[1]-a1[1]*a2[0]]\n                    s = sqrt(sum(x*x for x in v))\n                    c = sum(a1[i]*a2[i] for i in range(3))\n                    if s < 1e-14:\n                        R = [[1,0,0],[0,1,0],[0,0,1]]\n                    else:\n                        vx = [[0,-v[2],v[1]], [v[2],0,-v[0]], [-v[1],v[0],0]]\n                        I = [[1 if i == j else 0 for j in range(3)] for i in range(3)]\n                        vx2 = [[sum(vx[i][k]*vx[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n                        R = [[I[i][j] + vx[i][j] + vx2[i][j]*((1 - c)/(s*s)) for j in range(3)] for i in range(3)]\n\n            a1_val = best_cost * 0.5\n            try:\n                term = best_cost*best_cost - c_min*c_min\n                a_other = math.sqrt(term)*0.5 if term > 0 else 0.0\n            except Exception:\n                a_other = 0.0\n\n            while True:\n                if dim == 2:\n                    r = random.uniform(0, 1)**0.5\n                    theta = random.uniform(0, 2*math.pi)\n                    ball = [r * math.cos(theta), r * math.sin(theta)]\n                    L = [[a1_val, 0], [0, a_other]]\n                    x_scaled = [L[0][0]*ball[0], L[1][1]*ball[1]]\n                    pt = (center[0] + R[0][0]*x_scaled[0] + R[0][1]*x_scaled[1],\n                          center[1] + R[1][0]*x_scaled[0] + R[1][1]*x_scaled[1])\n                else:\n                    while True:\n                        ball = [random.uniform(-1, 1) for _ in range(3)]\n                        if sum(x*x for x in ball) <= 1:\n                            break\n                    L = [[a1_val, 0, 0], [0, a_other, 0], [0, 0, a_other]]\n                    x_scaled = [L[0][0]*ball[0], L[1][1]*ball[1], L[2][2]*ball[2]]\n                    pt = tuple(center[i] + sum(R[i][j]*x_scaled[j] for j in range(dim)) for i in range(dim))\n\n                if any(pt[d] < 0.0 or pt[d] > bounds[d] for d in range(dim)):\n                    continue\n                if self._is_in_obstacle(pt, obstacles, is_3d):\n                    continue\n                return pt\n\n        def attempt_connection(tree_a, tree_b, sample):\n            nearest = self._nearest(tree_a, sample)\n            new_pos = self._steer(nearest.position, sample, self.step_size)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                return None\n\n            new_node = Node(new_pos)\n            radius = near_radius(len(tree_a))\n            near_nodes = self._near(tree_a, new_pos, radius)\n\n            min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n            min_parent = nearest\n            # Efficient approximate k-nearest rewiring (early exit heuristic)\n            for near in near_nodes:\n                tentative_cost = near.cost + math.dist(near.position, new_pos)\n                if tentative_cost < min_cost:\n                    # Early exit collision check\n                    if not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d):\n                        min_cost = tentative_cost\n                        min_parent = near\n\n            new_node.parent = min_parent\n            new_node.cost = min_cost\n            min_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((min_parent, new_node))\n\n            # Rewire nearby nodes trying to preserve curvature and improve cost\n            curvature_preserving_rewire(new_node, near_nodes)\n\n            # Try connect to tree_b within step_size\n            connect_candidate = self._nearest(tree_b, new_node.position)\n            dist_connect = math.dist(new_node.position, connect_candidate.position)\n            if dist_connect <= self.step_size:\n                if not self._is_edge_in_obstacle(new_node.position, connect_candidate.position, obstacles, is_3d):\n                    total_cost = new_node.cost + dist_connect + connect_candidate.cost\n                    if total_cost + 1e-15 < best_cost:\n                        return new_node, connect_candidate, total_cost\n            return None\n\n        for iteration in range(self.max_iter):\n            sample = informed_sample() if (best_cost < float('inf')) else self._sample_free(bounds, obstacles, is_3d)\n\n            # Alternate expansions\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                res = attempt_connection(tree_a, tree_b, sample)\n                if res is not None:\n                    new_node, conn_node, total_cost = res\n                    if total_cost < best_cost:\n                        best_cost = total_cost\n                        if tree_a is start_tree:\n                            solution_start, solution_goal = new_node, conn_node\n                        else:\n                            solution_start, solution_goal = conn_node, new_node\n\n            # Apply incremental path smoothing and curvature-aware shortcutting every shortcut_interval iterations once solution found\n            if best_cost < float('inf') and solution_start and solution_goal:\n                if iteration % self.shortcut_interval == 0 or iteration == self.max_iter - 1:\n                    raw_path = self._extract_path(solution_start, solution_goal)\n                    shortcut_path = incremental_curvature_shortcut(raw_path)\n                    smooth_path = midpoint_smooth(shortcut_path)\n                    return PlannerResult(True, smooth_path, nodes, edges)\n\n        return PlannerResult(False, [], nodes, edges)\n\n    def _extract_path(self, node_start, node_goal):\n        s_path = []\n        n = node_start\n        while n is not None:\n            s_path.append(n.position)\n            n = n.parent\n        g_path = []\n        n = node_goal\n        while n is not None:\n            g_path.append(n.position)\n            n = n.parent\n        return s_path[::-1] + g_path\n\n    def _nearest(self, tree, point):\n        best_node = None\n        best_dist_sq = float('inf')\n        for node in tree:\n            d_sq = 0.0\n            for i in range(len(point)):\n                diff = node.position[i] - point[i]\n                d_sq += diff * diff\n                if d_sq >= best_dist_sq:  # early exit\n                    break\n            if d_sq < best_dist_sq:\n                best_dist_sq = d_sq\n                best_node = node\n        return best_node\n\n    def _near(self, tree, point, radius):\n        r_sq = radius * radius\n        near_nodes = []\n        for n in tree:\n            d_sq = 0.0\n            for i in range(len(point)):\n                diff = n.position[i] - point[i]\n                d_sq += diff * diff\n                if d_sq > r_sq:\n                    break\n            if d_sq <= r_sq:\n                near_nodes.append(n)\n        return near_nodes\n\n    def _steer(self, from_pos, to_pos, step_size):\n        dist = 0.0\n        diff_vec = []\n        for i in range(len(from_pos)):\n            d = to_pos[i] - from_pos[i]\n            diff_vec.append(d)\n            dist += d * d\n        dist = dist ** 0.5\n        if dist <= step_size:\n            return to_pos\n        ratio = step_size / dist\n        new_pos = tuple(from_pos[i] + ratio * diff_vec[i] for i in range(len(from_pos)))\n        return new_pos\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        import random\n        while True:\n            pt = tuple(random.uniform(0, bounds[i]) for i in range(len(bounds)))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        px = pos[0]\n        py = pos[1]\n        pz = pos[2] if is_3d else 0.0\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        dist = 0.0\n        for i in range(len(from_pos)):\n            diff = to_pos[i] - from_pos[i]\n            dist += diff * diff\n        dist = dist ** 0.5\n        steps = max(1, int(dist / resolution))\n        for step in range(steps + 1):\n            t = step / steps\n            interp = tuple(from_pos[i] + t * (to_pos[i] - from_pos[i]) for i in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _unit_ball_volume(self, dim):\n        import math\n        if dim == 2:\n            return math.pi\n        if dim == 3:\n            return 4.0 / 3.0 * math.pi\n        from math import gamma\n        return (math.pi ** (dim / 2)) / gamma(dim / 2 + 1)\n\n    def _update_subtree_costs(self, node, edges):\n        import math\n        stack = [node]\n        while stack:\n            n = stack.pop()\n            for c in n.children:\n                new_cost = n.cost + math.dist(n.position, c.position)\n                if new_cost + 1e-15 < c.cost:\n                    c.cost = new_cost\n                    stack.append(c)",
                "objective": -28.74503,
                "time_improvement": 35.0,
                "length_improvement": 16.0,
                "smoothness_improvement": 1723.0,
                "node_improvement": 72.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.0299816370010376,
                        "num_nodes_avg": 148.2,
                        "path_length_avg": 167.3939001155781,
                        "smoothness_avg": 0.050243287597786124,
                        "success_improvement": 0.0,
                        "time_improvement": -16.24930089808597,
                        "node_improvement": 62.67942583732058,
                        "length_improvement": 8.248750820561371,
                        "smoothness_improvement": 686.4165559506581,
                        "objective_score": 3.506543002664322
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.024869823455810548,
                        "num_nodes_avg": 213.3,
                        "path_length_avg": 234.52362942815247,
                        "smoothness_avg": 0.11434926003010829,
                        "success_improvement": 0.0,
                        "time_improvement": 84.97978616358722,
                        "node_improvement": 85.66821205402137,
                        "length_improvement": 21.70926210849506,
                        "smoothness_improvement": 2842.288823017571,
                        "objective_score": 52.73093722926106
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.03181536197662353,
                        "num_nodes_avg": 263.6,
                        "path_length_avg": 123.95805243875779,
                        "smoothness_avg": 0.13682429202352978,
                        "success_improvement": 0.0,
                        "time_improvement": 37.30614787659427,
                        "node_improvement": 66.48442466624284,
                        "length_improvement": 17.672963818329237,
                        "smoothness_improvement": 1640.3948952206044,
                        "objective_score": 29.99759713007884
                    }
                ],
                "success_rate": 1.0
            }
        ],
        "offspring": {
            "operator": "m3",
            "algorithm_description": "A streamlined bidirectional RRT* planner with adaptive neighborhood radius, integrated ellipsoidal informed sampling, and iterative incremental shortcutting combined with smoothing. It maintains a clean tree structure through careful rewiring with subtree cost updates and frequent connection attempts to improve solution quality progressively. Path refinement happens continuously during planning by applying shortcutting with adaptive angle thresholds and midpoint smoothing, enhancing smoothness and shortening path length while keeping planning time efficient.",
            "planning_mechanism": "The planner grows two trees from start and goal alternately, sampling informed points within an adaptive ellipsoidal region after an initial solution is found. It uses an adaptive rewiring radius based on node count and dimension to reconnect neighbors if a better path is found, with subtree costs updated accordingly. Frequent attempts connect the two trees. Incremental path shortcutting with an adaptive angle threshold and midpoint smoothing run periodically during planning to iteratively improve path smoothness and length. The algorithm balances exploration and exploitation using goal bias and informed sampling for efficient, high-quality, and smooth paths.",
            "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\nclass Planner:\n    def __init__(self, max_iter=4000, step_size=6.0, gamma=40.0, goal_sample_rate=0.1, \n                 shortcut_interval=40, max_shortcut_attempts=200):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.gamma = gamma\n        self.goal_sample_rate = goal_sample_rate\n        self.shortcut_interval = shortcut_interval\n        self.max_shortcut_attempts = max_shortcut_attempts\n\n    def plan(self, map):\n        import math\n        import random\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        best_cost = float('inf')\n        solution_start, solution_goal = None, None\n        c_min = math.dist(start_pos, goal_pos)\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def adaptive_radius(n_nodes):\n            if n_nodes <= 1:\n                return self.step_size * 3.0\n            val = (math.log(n_nodes) / n_nodes) ** (1.0 / dim)\n            return min(self.gamma * val, self.step_size * 40)\n\n        def sample():\n            # Goal biasing\n            if random.random() < self.goal_sample_rate:\n                return goal_pos\n            # Informed ellipsoidal sampling if solution found\n            if best_cost == float('inf') or best_cost <= c_min:\n                return self._sample_free(bounds, obstacles, is_3d)\n            center = tuple((start_pos[i]+goal_pos[i])*0.5 for i in range(dim))\n            dir_vec = [goal_pos[i]-start_pos[i] for i in range(dim)]\n            length = c_min\n            if dim == 2:\n                if length < 1e-14:\n                    R = [[1,0],[0,1]]\n                else:\n                    a1 = [1,0]\n                    a2 = [dir_vec[0]/length, dir_vec[1]/length]\n                    cos_t = a1[0]*a2[0] + a1[1]*a2[1]\n                    sin_t = a1[0]*a2[1] - a1[1]*a2[0]\n                    R = [[cos_t, -sin_t],[sin_t, cos_t]]\n            else:\n                from math import sqrt\n                if length < 1e-14:\n                    R = [[1,0,0],[0,1,0],[0,0,1]]\n                else:\n                    a1 = [1,0,0]\n                    a2 = [dir_vec[i]/length for i in range(3)]\n                    v = [a1[1]*a2[2]-a1[2]*a2[1], a1[2]*a2[0]-a1[0]*a2[2], a1[0]*a2[1]-a1[1]*a2[0]]\n                    s = sqrt(sum(x*x for x in v))\n                    c = sum(a1[i]*a2[i] for i in range(3))\n                    if s < 1e-14:\n                        R = [[1,0,0],[0,1,0],[0,0,1]]\n                    else:\n                        vx = [[0,-v[2],v[1]],[v[2],0,-v[0]],[-v[1],v[0],0]]\n                        I = [[1 if i==j else 0 for j in range(3)] for i in range(3)]\n                        vx2 = [[sum(vx[i][k]*vx[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n                        R = [[I[i][j] + vx[i][j] + vx2[i][j]*((1-c)/(s*s)) for j in range(3)] for i in range(3)]\n\n            a1_val = best_cost * 0.5\n            try:\n                term = best_cost*best_cost - c_min*c_min\n                a_other = math.sqrt(term)*0.5 if term > 0 else 0.0\n            except Exception:\n                a_other = 0.0\n\n            while True:\n                if dim == 2:\n                    r = random.uniform(0,1)**0.5\n                    theta = random.uniform(0,2*math.pi)\n                    ball = [r * math.cos(theta), r * math.sin(theta)]\n                    L = [[a1_val,0],[0,a_other]]\n                    x_scaled = [L[0][0]*ball[0], L[1][1]*ball[1]]\n                    pt = tuple(center[i] + sum(R[i][j]*x_scaled[j] for j in range(dim)) for i in range(dim))\n                else:\n                    while True:\n                        ball = [random.uniform(-1,1) for _ in range(3)]\n                        if sum(x*x for x in ball) <= 1:\n                            break\n                    L = [[a1_val,0,0],[0,a_other,0],[0,0,a_other]]\n                    x_scaled = [L[0][0]*ball[0], L[1][1]*ball[1], L[2][2]*ball[2]]\n                    pt = tuple(center[i] + sum(R[i][j]*x_scaled[j] for j in range(dim)) for i in range(dim))\n                if any(pt[d]<0.0 or pt[d]>bounds[d] for d in range(dim)):\n                    continue\n                if self._is_in_obstacle(pt, obstacles, is_3d):\n                    continue\n                return pt\n\n        def nearest(tree, point):\n            best = None\n            best_dist = float('inf')\n            for node in tree:\n                d = 0.0\n                for i in range(dim):\n                    diff = node.position[i] - point[i]\n                    d += diff*diff\n                    if d >= best_dist:\n                        break\n                if d < best_dist:\n                    best_dist = d\n                    best = node\n            return best\n\n        def near(tree, point, radius):\n            r2 = radius*radius\n            res = []\n            for node in tree:\n                d = 0.0\n                for i in range(dim):\n                    diff = node.position[i]-point[i]\n                    d += diff*diff\n                    if d > r2:\n                        break\n                if d <= r2:\n                    res.append(node)\n            return res\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            ratio = self.step_size / d\n            return tuple(from_pos[i] + (to_pos[i]-from_pos[i])*ratio for i in range(dim))\n\n        def update_subtree_costs(node):\n            stack = [node]\n            while stack:\n                current = stack.pop()\n                for c in current.children:\n                    new_cost = current.cost + dist(current.position, c.position)\n                    if new_cost + 1e-15 < c.cost:\n                        c.cost = new_cost\n                        stack.append(c)\n\n        def extract_path(node_start, node_goal):\n            path_start = []\n            n = node_start\n            while n is not None:\n                path_start.append(n.position)\n                n = n.parent\n            path_goal = []\n            n = node_goal\n            while n is not None:\n                path_goal.append(n.position)\n                n = n.parent\n            return path_start[::-1] + path_goal\n\n        def angle_between(a,b,c):\n            import math\n            ba = [a[i]-b[i] for i in range(dim)]\n            bc = [c[i]-b[i] for i in range(dim)]\n            lab = math.sqrt(sum(x*x for x in ba))\n            lbc = math.sqrt(sum(x*x for x in bc))\n            if lab < 1e-14 or lbc < 1e-14:\n                return 0.0\n            dotp = sum(ba[i]*bc[i] for i in range(dim))\n            val = max(min(dotp/(lab*lbc), 1.0), -1.0)\n            return math.acos(val)\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path[:]\n            new_path = path[:]\n            angle_base = math.pi * 160.0 / 180.0  # 160 degrees base angle\n            max_attempts = self.max_shortcut_attempts\n            attempts = 0\n            i = 0\n            while attempts < max_attempts and i < len(new_path)-2:\n                j = random.randint(i+2, len(new_path)-1)\n                if j <= i+1:\n                    attempts += 1\n                    i += 1\n                    continue\n                if not self._is_edge_in_obstacle(new_path[i], new_path[j], obstacles, is_3d):\n                    smooth = True\n                    if i > 0:\n                        a,b,c = new_path[i-1], new_path[i], new_path[j]\n                        if angle_between(a,b,c) < math.pi - angle_base:\n                            smooth = False\n                    if j < len(new_path)-1:\n                        a,b,c = new_path[i], new_path[j], new_path[j+1]\n                        if angle_between(a,b,c) < math.pi - angle_base:\n                            smooth = False\n                    if smooth:\n                        new_path = new_path[:i+1] + new_path[j:]\n                        i = 0\n                        attempts += 1\n                        continue\n                i += 1\n                attempts += 1\n            return new_path\n\n        def midpoint_smooth(path):\n            if len(path) < 4:\n                return path[:]\n            new_path = path[:]\n            changed = False\n            for i in range(1, len(new_path)-1):\n                a,b,c = new_path[i-1], new_path[i], new_path[i+1]\n                mid = tuple(0.5*(a[d] + c[d]) for d in range(dim))\n                if (not self._is_in_obstacle(mid, obstacles, is_3d) and \n                    not self._is_edge_in_obstacle(a, mid, obstacles, is_3d) and\n                    not self._is_edge_in_obstacle(mid, c, obstacles, is_3d)):\n                    old_angle = angle_between(a,b,c)\n                    new_angle = angle_between(a,mid,c)\n                    if new_angle < old_angle + 1e-8:\n                        new_path[i] = mid\n                        changed = True\n            return new_path if changed else path\n\n        def attempt_extend(tree_from, tree_to, sample_point):\n            nearest_node = nearest(tree_from, sample_point)\n            new_pos = steer(nearest_node.position, sample_point)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                return None\n\n            r = adaptive_radius(len(tree_from))\n            near_nodes = near(tree_from, new_pos, r)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for candidate in near_nodes:\n                if candidate is nearest_node:\n                    continue\n                tentative_cost = candidate.cost + dist(candidate.position, new_pos)\n                if tentative_cost < min_cost:\n                    if not self._is_edge_in_obstacle(candidate.position, new_pos, obstacles, is_3d):\n                        min_cost = tentative_cost\n                        best_parent = candidate\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree_from.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            for nbr in near_nodes:\n                if nbr is best_parent or nbr is new_node:\n                    continue\n                cost_through_new = new_node.cost + dist(new_node.position, nbr.position)\n                if cost_through_new < nbr.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, nbr.position, obstacles, is_3d):\n                        if nbr.parent is not None:\n                            try:\n                                edges.remove((nbr.parent, nbr))\n                            except Exception:\n                                pass\n                            nbr.parent.remove_child(nbr)\n                        nbr.parent = new_node\n                        nbr.cost = cost_through_new\n                        new_node.add_child(nbr)\n                        edges.append((new_node, nbr))\n                        update_subtree_costs(nbr)\n\n            near_other = nearest(tree_to, new_node.position)\n            d = dist(new_node.position, near_other.position)\n            if d <= self.step_size:\n                if not self._is_edge_in_obstacle(new_node.position, near_other.position, obstacles, is_3d):\n                    total_cost = new_node.cost + d + near_other.cost\n                    if total_cost < best_cost:\n                        return new_node, near_other, total_cost\n            return None\n\n        for it in range(self.max_iter):\n            sample_pos = sample()\n\n            # Alternate between trees each iteration for extension\n            if it % 2 == 0:\n                tree_a, tree_b = start_tree, goal_tree\n            else:\n                tree_a, tree_b = goal_tree, start_tree\n\n            res = attempt_extend(tree_a, tree_b, sample_pos)\n            if res is not None:\n                new_node, conn_node, cost = res\n                if cost < best_cost:\n                    best_cost = cost\n                    if tree_a is start_tree:\n                        solution_start, solution_goal = new_node, conn_node\n                    else:\n                        solution_start, solution_goal = conn_node, new_node\n\n            if best_cost < float('inf') and solution_start and solution_goal:\n                if it % self.shortcut_interval == 0 or it == self.max_iter-1:\n                    raw_path = extract_path(solution_start, solution_goal)\n                    shortcut = shortcut_path(raw_path)\n                    smooth = midpoint_smooth(shortcut)\n                    return PlannerResult(True, smooth, nodes, edges)\n        return PlannerResult(False, [], nodes, edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        import random\n        while True:\n            pt = tuple(random.uniform(0, bounds[i]) for i in range(len(bounds)))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        px = pos[0]\n        py = pos[1]\n        pz = pos[2] if is_3d else 0.0\n        for obs in obstacles:\n            if is_3d:\n                x,y,z,w,h,d = obs\n                if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                    return True\n            else:\n                x,y,w,h = obs\n                if x <= px <= x+w and y <= py <= y+h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        dist_val = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist_val/resolution))\n        for step in range(steps+1):\n            t = step/steps\n            interp = tuple(from_pos[i] + t*(to_pos[i]-from_pos[i]) for i in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
            "objective": -34.04726,
            "time_improvement": 62.0,
            "length_improvement": 16.0,
            "smoothness_improvement": 1214.0,
            "node_improvement": 75.0,
            "other_inf": [
                {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.01619288921356201,
                    "num_nodes_avg": 129.2,
                    "path_length_avg": 165.2187501071947,
                    "smoothness_avg": 0.0347659312496346,
                    "success_improvement": 0.0,
                    "time_improvement": 37.21450064479152,
                    "node_improvement": 67.4641148325359,
                    "length_improvement": 9.440985007613875,
                    "smoothness_improvement": 444.16231948483625,
                    "objective_score": 19.04975279542996
                },
                {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.025137996673583983,
                    "num_nodes_avg": 249.1,
                    "path_length_avg": 235.60144924838568,
                    "smoothness_avg": 0.08764785848268018,
                    "success_improvement": 0.0,
                    "time_improvement": 84.81782204336284,
                    "node_improvement": 83.26278304105355,
                    "length_improvement": 21.349454829177827,
                    "smoothness_improvement": 2155.242528960084,
                    "objective_score": 49.03123215531597
                },
                {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.018967270851135254,
                    "num_nodes_avg": 206.2,
                    "path_length_avg": 125.32858322045142,
                    "smoothness_avg": 0.0898739725367217,
                    "success_improvement": 0.0,
                    "time_improvement": 62.6239904232623,
                    "node_improvement": 73.78258105530833,
                    "length_improvement": 16.762722530791013,
                    "smoothness_improvement": 1043.1902968605036,
                    "objective_score": 34.06078212975582
                }
            ],
            "success_rate": 1.0
        },
        "objective": 32.39999999999999,
        "analysis": {
            "problem": [
                ""
            ],
            "solution": "1. Primary contributors to the performance improvement:\n   - Adoption of an adaptive neighborhood radius based on node count and problem dimension, improving rewiring efficiency.\n   - Integration of goal biasing with ellipsoidal informed sampling to focus search within a promising region after an initial solution is found.\n   - Streamlined rewiring and connection attempts avoiding unnecessary curvature checks, reducing computational overhead.\n   - Balanced shortcutting that applies consistent, moderately strict angle thresholds coupled with midpoint smoothing to improve path quality efficiently.\n2. Expected mechanism of impact:\n   - Adaptive radius optimizes neighbor selection, reducing excessive collision checks and keeping rewiring efficient.\n   - Informed sampling concentrates node additions within a relevant region, accelerating convergence toward better paths.\n   - Simplified, less restrictive rewiring expands the exploration without compromising path quality, improving runtime.\n   - Effective, periodic path smoothing reduces path length and enhances smoothness without causing planning delays."
        }
    },
    {
        "parents": [
            {
                "operator": "m1",
                "algorithm_description": "Enhanced Bidirectional RRT* with Adaptive Radius, Informed Sampling, Efficient Collision Checking, and B-Spline Path Smoothing for Improved Planning Efficiency, Path Length, and Notably Smooth and Feasible Paths",
                "planning_mechanism": "This planner employs a bidirectional RRT* framework with adaptive rewiring radius based on tree size for asymptotic optimality. It uses goal bias and informed sampling within an ellipsoidal subset to concentrate sampling in promising regions. It alternates between trees for balanced growth and rewires local neighborhoods to optimize paths continuously. After tree connection, it reconstructs the path and applies B-spline smoothing to produce smooth, curvature-continuous trajectories, while maintaining rigorous collision checks on nodes and edges. Early termination is triggered on successful connection to improve search efficiency.",
                "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        node, path = self, []\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=7.0, base_radius=20.0, goal_sample_rate=0.15, smoothing_degree=3, smoothing_points=100):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.base_radius = base_radius\n        self.goal_sample_rate = goal_sample_rate\n        self.smoothing_degree = smoothing_degree\n        self.smoothing_points = smoothing_points\n\n    def plan(self, map):\n        import math\n        import random\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        def dist(a,b):\n            return math.dist(a,b)\n\n        def steer(fr, to):\n            d = dist(fr, to)\n            if d <= self.step_size:\n                return to\n            ratio = self.step_size / d\n            return tuple(fr[i] + (to[i] - fr[i]) * ratio for i in range(dim))\n\n        def is_in_obstacle(p):\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d_ = obs\n                    px,py,pz = p\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d_:\n                        return True\n                else:\n                    x,y,w,h = obs\n                    px,py = p\n                    if x <= px <= x+w and y <= py <= y+h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(fr,to, resolution=1.0):\n            d = dist(fr,to)\n            steps = max(1, int(d / resolution))\n            for i in range(steps + 1):\n                interp = tuple(fr[j] + (to[j] - fr[j]) * i / steps for j in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: dist(node.position, point))\n\n        def near_nodes(tree, point, radius):\n            return [node for node in tree if dist(node.position, point) <= radius]\n\n        def rewire(tree, new_node, near_nodes_list):\n            nonlocal edges\n            for near in near_nodes_list:\n                if near == new_node.parent:\n                    continue\n                c = new_node.cost + dist(new_node.position, near.position)\n                if c + 1e-10 < near.cost and not is_edge_in_obstacle(new_node.position, near.position):\n                    old_parent = near.parent\n                    if old_parent:\n                        try:\n                            edges.remove((old_parent, near))\n                        except ValueError:\n                            pass\n                        old_parent.children.remove(near)\n                    near.parent = new_node\n                    near.cost = c\n                    new_node.add_child(near)\n                    edges.append((new_node, near))\n\n        def extract_path(node_start, node_goal):\n            path_start = node_start.path_from_root()\n            path_goal = node_goal.path_from_root()[::-1]\n            if len(path_start) > 0 and len(path_goal) > 0 and path_start[-1] == path_goal[0]:\n                path_goal = path_goal[1:]\n            return path_start + path_goal\n\n        def adaptive_radius(tree_size):\n            gamma = self.base_radius\n            n = max(tree_size, 1)\n            return max(gamma * (math.log(n)/n)**(1.0/dim), self.step_size*1.5)\n\n        def informed_sample(c_best, c_min, start, goal):\n            # If no solution found yet, sample uniformly\n            if c_best == float('inf'):\n                return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n            # Ellipsoidal informed sampling\n            import numpy as np\n            c = c_best\n            center = tuple((start[i] + goal[i])/2 for i in range(dim))\n            a1 = tuple((goal[i] - start[i])/c_min for i in range(dim))\n            if dim == 2:\n                # Build rotation matrix to align x-axis with a1\n                theta = math.atan2(a1[1], a1[0])\n                r = [[math.cos(theta), -math.sin(theta)],\n                     [math.sin(theta),  math.cos(theta)]]\n                while True:\n                    # Sample uniformly in unit circle\n                    x, y = random.random()*2 -1, random.random()*2 -1\n                    if x**2 + y**2 > 1: \n                        continue\n                    # Scale according to ellipse axes\n                    rx = c/2\n                    ry = math.sqrt(c**2 - c_min**2)/2\n                    sample_ellipse = (x*rx, y*ry)\n                    # Rotate and translate sample\n                    px = r[0][0]*sample_ellipse[0] + r[0][1]*sample_ellipse[1] + center[0]\n                    py = r[1][0]*sample_ellipse[0] + r[1][1]*sample_ellipse[1] + center[1]\n                    if 0 <= px <= bounds[0] and 0 <= py <= bounds[1]:\n                        return (px, py)\n            else:  # In 3D or higher, fallback uniform sampling due to complexity\n                return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n\n        # B-spline smoothing using De Boor's algorithm (degree=3) for smoothness enhancement\n        def bspline(points, degree=3, num=100):\n            if len(points) <= degree:\n                return points[:]\n            import numpy as np\n            points_np = np.array(points)\n            n = len(points_np) - 1\n            k = degree\n            domain = np.linspace(0, n - k + 1, num)\n            knots = np.concatenate(([0]*k, np.arange(n - k + 2), [n - k + 2]*k))\n\n            def de_boor(t, k, i, x):\n                if k == 0:\n                    return x[i]\n                alpha = (t - knots[i])/(knots[i+k] - knots[i]) if knots[i+k] != knots[i] else 0\n                return (1.0 - alpha) * de_boor(t, k-1, i-1, x) + alpha * de_boor(t, k-1, i, x)\n\n            spline = []\n            for t in domain:\n                i = next(i for i in range(len(knots)-1) if knots[i] <= t < knots[i+1])\n                spline.append(tuple(de_boor(t, k, i, points_np)))\n            return spline\n\n        # Initialize best cost to infinite, update when path found\n        best_cost = float('inf')\n        connection_nodes = (None, None)\n        success = False\n\n        for iteration in range(self.max_iter):\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                if success:\n                    break\n\n                # Choose informed sampling with goal bias\n                sample_prob = random.random()\n                if sample_prob < self.goal_sample_rate:\n                    q_rand = goal_pos\n                else:\n                    q_rand = informed_sample(best_cost, dist(start_pos, goal_pos), start_pos, goal_pos)\n\n                nearest_node = nearest(tree_a, q_rand)\n                q_new_pos = steer(nearest_node.position, q_rand)\n\n                if is_in_obstacle(q_new_pos) or is_edge_in_obstacle(nearest_node.position, q_new_pos):\n                    continue\n\n                radius = adaptive_radius(len(tree_a))\n                near_nodes_a = near_nodes(tree_a, q_new_pos, radius)\n\n                # Choose parent minimizing cost\n                min_cost = nearest_node.cost + dist(nearest_node.position, q_new_pos)\n                min_parent = nearest_node\n                for near_n in near_nodes_a:\n                    c = near_n.cost + dist(near_n.position, q_new_pos)\n                    if c + 1e-10 < min_cost and not is_edge_in_obstacle(near_n.position, q_new_pos):\n                        min_cost = c\n                        min_parent = near_n\n\n                q_new = Node(q_new_pos, parent=min_parent, cost=min_cost)\n                min_parent.add_child(q_new)\n                tree_a.append(q_new)\n                nodes.append(q_new)\n                edges.append((min_parent, q_new))\n\n                rewire(tree_a, q_new, near_nodes_a)\n\n                # Attempt connection to other tree\n                nearest_other = nearest(tree_b, q_new.position)\n                dist_connect = dist(q_new.position, nearest_other.position)\n                radius_connect = max(self.step_size*1.5, adaptive_radius(len(tree_b)))\n\n                if dist_connect <= radius_connect and not is_edge_in_obstacle(q_new.position, nearest_other.position):\n                    # Trees connected\n                    if tree_a is start_tree:\n                        node_start, node_goal = q_new, nearest_other\n                    else:\n                        node_start, node_goal = nearest_other, q_new\n\n                    current_cost = node_start.cost + dist(node_start.position, node_goal.position) + node_goal.cost\n                    if current_cost < best_cost:\n                        best_cost = current_cost\n                        connection_nodes = (node_start, node_goal)\n                        success = True\n            if success:\n                break\n\n        raw_path = []\n        if success:\n            raw_path = extract_path(connection_nodes[0], connection_nodes[1])\n        else:\n            # fallback empty path on failure\n            return PlannerResult(False, [], nodes, edges)\n\n        # B-spline smoothing with collision checking along spline (dense checks)\n        smooth_path = raw_path\n        if len(raw_path) > self.smoothing_degree:\n            try:\n                # We implement smoothing only if numpy is available, else fallback raw_path\n                import numpy as np\n                spline_path = bspline(raw_path, degree=self.smoothing_degree, num=self.smoothing_points)\n                # Check collision for spline curve segments\n                collides = False\n                for i in range(len(spline_path)-1):\n                    if is_edge_in_obstacle(spline_path[i], spline_path[i+1]):\n                        collides = True\n                        break\n                if not collides:\n                    smooth_path = spline_path\n            except:\n                # If numpy not available, fallback to raw_path (no smoothing)\n                smooth_path = raw_path\n\n        return PlannerResult(success, smooth_path, nodes, edges)",
                "objective": -25.01284,
                "time_improvement": 66.0,
                "length_improvement": 7.0,
                "smoothness_improvement": 169.0,
                "node_improvement": 74.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.00990746021270752,
                        "num_nodes_avg": 117.2,
                        "path_length_avg": 177.87723139341853,
                        "smoothness_avg": 0.016505675329957482,
                        "success_improvement": 0.0,
                        "time_improvement": 61.58530892215819,
                        "node_improvement": 70.48602367161925,
                        "length_improvement": 2.5026708281624948,
                        "smoothness_improvement": 158.34966156149508,
                        "objective_score": 20.768943481352427
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.014815974235534667,
                        "num_nodes_avg": 199.2,
                        "path_length_avg": 264.58410600917347,
                        "smoothness_avg": 0.01090878033876496,
                        "success_improvement": 0.0,
                        "time_improvement": 91.05184234186756,
                        "node_improvement": 86.61560169320701,
                        "length_improvement": 11.67420978290656,
                        "smoothness_improvement": 180.69077539330692,
                        "objective_score": 35.223532449270735
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.027541279792785645,
                        "num_nodes_avg": 285.0,
                        "path_length_avg": 139.32127743918858,
                        "smoothness_avg": 0.02116118022862008,
                        "success_improvement": 0.0,
                        "time_improvement": 45.72845269254134,
                        "node_improvement": 63.76350921805467,
                        "length_improvement": 7.469441291202562,
                        "smoothness_improvement": 169.16865055219935,
                        "objective_score": 19.046043835244934
                    }
                ],
                "success_rate": 1.0
            }
        ],
        "offspring": {
            "operator": "time_expert",
            "algorithm_description": "Improved Bidirectional RRT* with Adaptive Radius and Incremental Local Smoothing Using Shortcutting for Fast, High-Quality, and Robust Path Planning",
            "planning_mechanism": "This planner enhances bidirectional RRT* by replacing expensive global B-spline smoothing with fast adaptive incremental smoothing via path shortcutting and partial rewiring focused on straight-line shortcuts, drastically reducing planning time while improving path length and smoothness. It uses informed sampling with goal bias, adaptive neighborhood radius for rewiring, efficient collision checks, and early termination upon connection. The local smoothing iteratively shortcuts path segments, checking collisions to maintain feasibility, thus providing smooth, short, and feasible paths efficiently.",
            "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def path_from_root(self):\n        node, path = self, []\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=3500, step_size=7.0, base_radius=20.0, goal_sample_rate=0.15,\n                 shortcut_attempts=40, shortcut_min_segment=2):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.base_radius = base_radius\n        self.goal_sample_rate = goal_sample_rate\n        self.shortcut_attempts = shortcut_attempts  # Number of incremental shortcut attempts on path\n        self.shortcut_min_segment = shortcut_min_segment  # Minimum segment length for shortcut trial\n\n    def plan(self, map):\n        import math\n        import random\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(fr, to):\n            d = dist(fr, to)\n            if d <= self.step_size:\n                return to\n            ratio = self.step_size / d\n            return tuple(fr[i] + (to[i] - fr[i]) * ratio for i in range(dim))\n\n        def is_in_obstacle(p):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d_ = obs\n                    px, py, pz = p\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d_:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    px, py = p\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(fr, to, resolution=1.0):\n            d = dist(fr, to)\n            steps = max(1, int(d / resolution))\n            for i in range(steps + 1):\n                interp = tuple(fr[j] + (to[j] - fr[j]) * i / steps for j in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: dist(node.position, point))\n\n        def near_nodes(tree, point, radius):\n            return [node for node in tree if dist(node.position, point) <= radius]\n\n        def rewire(tree, new_node, near_list):\n            nonlocal edges\n            for near in near_list:\n                if near == new_node.parent:\n                    continue\n                c = new_node.cost + dist(new_node.position, near.position)\n                if c + 1e-10 < near.cost and not is_edge_in_obstacle(new_node.position, near.position):\n                    old_parent = near.parent\n                    if old_parent:\n                        try:\n                            edges.remove((old_parent, near))\n                        except ValueError:\n                            pass\n                        old_parent.remove_child(near)\n                    near.parent = new_node\n                    near.cost = c\n                    new_node.add_child(near)\n                    edges.append((new_node, near))\n\n        def extract_path(node_start, node_goal):\n            path_start = node_start.path_from_root()\n            path_goal = node_goal.path_from_root()[::-1]\n            if len(path_start) > 0 and len(path_goal) > 0 and path_start[-1] == path_goal[0]:\n                path_goal = path_goal[1:]\n            return path_start + path_goal\n\n        def adaptive_radius(tree_size):\n            gamma = self.base_radius\n            n = max(tree_size, 1)\n            return max(gamma * (math.log(n) / n) ** (1.0 / dim), self.step_size * 1.5)\n\n        def informed_sample(c_best, c_min, start, goal):\n            if c_best == float('inf'):\n                return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n            c = c_best\n            center = tuple((start[i] + goal[i]) / 2 for i in range(dim))\n            a1 = tuple((goal[i] - start[i]) / c_min for i in range(dim))\n            if dim == 2:\n                theta = math.atan2(a1[1], a1[0])\n                r = [[math.cos(theta), -math.sin(theta)],\n                     [math.sin(theta), math.cos(theta)]]\n                while True:\n                    x, y = random.uniform(-1, 1), random.uniform(-1, 1)\n                    if x * x + y * y > 1:\n                        continue\n                    rx = c / 2\n                    ry = math.sqrt(max(c * c - c_min * c_min, 0)) / 2\n                    sample_ellipse = (x * rx, y * ry)\n                    px = r[0][0] * sample_ellipse[0] + r[0][1] * sample_ellipse[1] + center[0]\n                    py = r[1][0] * sample_ellipse[0] + r[1][1] * sample_ellipse[1] + center[1]\n                    if 0 <= px <= bounds[0] and 0 <= py <= bounds[1]:\n                        return (px, py)\n            else:\n                return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n\n        # Incremental shortcut smoothing for path improvement\n        def incremental_shortcut(path):\n            if len(path) < 3:\n                return path[:]\n            path_pts = list(path)\n            for _ in range(self.shortcut_attempts):\n                if len(path_pts) < 3:\n                    break\n                i = random.randint(0, len(path_pts) - self.shortcut_min_segment - 1)\n                j = random.randint(i + self.shortcut_min_segment, len(path_pts) - 1)\n                p_i = path_pts[i]\n                p_j = path_pts[j]\n                if not is_edge_in_obstacle(p_i, p_j):\n                    # Shortcut feasible, remove intermediate points\n                    path_pts = path_pts[:i + 1] + path_pts[j:]\n            return path_pts\n\n        best_cost = float('inf')\n        connection_nodes = (None, None)\n        success = False\n\n        for iteration in range(self.max_iter):\n            if success:\n                break\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                if success:\n                    break\n\n                sample_prob = random.random()\n                if sample_prob < self.goal_sample_rate:\n                    q_rand = goal_pos\n                else:\n                    q_rand = informed_sample(best_cost, dist(start_pos, goal_pos), start_pos, goal_pos)\n\n                nearest_node = nearest(tree_a, q_rand)\n                q_new_pos = steer(nearest_node.position, q_rand)\n\n                if is_in_obstacle(q_new_pos) or is_edge_in_obstacle(nearest_node.position, q_new_pos):\n                    continue\n\n                radius = adaptive_radius(len(tree_a))\n                near_nodes_a = near_nodes(tree_a, q_new_pos, radius)\n\n                # Parent selection minimizing cost + feasibility\n                min_cost = nearest_node.cost + dist(nearest_node.position, q_new_pos)\n                min_parent = nearest_node\n                for near_n in near_nodes_a:\n                    c = near_n.cost + dist(near_n.position, q_new_pos)\n                    if c + 1e-10 < min_cost and not is_edge_in_obstacle(near_n.position, q_new_pos):\n                        min_cost = c\n                        min_parent = near_n\n\n                q_new = Node(q_new_pos, parent=min_parent, cost=min_cost)\n                min_parent.add_child(q_new)\n                tree_a.append(q_new)\n                nodes.append(q_new)\n                edges.append((min_parent, q_new))\n\n                rewire(tree_a, q_new, near_nodes_a)\n\n                # Try connect opposite tree\n                nearest_other = nearest(tree_b, q_new.position)\n                dist_connect = dist(q_new.position, nearest_other.position)\n                radius_connect = max(self.step_size * 1.5, adaptive_radius(len(tree_b)))\n\n                if dist_connect <= radius_connect and not is_edge_in_obstacle(q_new.position, nearest_other.position):\n                    if tree_a is start_tree:\n                        node_start, node_goal = q_new, nearest_other\n                    else:\n                        node_start, node_goal = nearest_other, q_new\n\n                    current_cost = node_start.cost + dist(node_start.position, node_goal.position) + node_goal.cost\n                    if current_cost < best_cost:\n                        best_cost = current_cost\n                        connection_nodes = (node_start, node_goal)\n                        success = True\n            # Early stop if connected\n            if success:\n                break\n\n        raw_path = []\n        if success:\n            raw_path = extract_path(connection_nodes[0], connection_nodes[1])\n        else:\n            return PlannerResult(False, [], nodes, edges)\n\n        # Incremental shortcut smoothing with collision check, lightweight and fast\n        smooth_path = incremental_shortcut(raw_path)\n\n        return PlannerResult(True, smooth_path, nodes, edges)",
            "objective": -32.3085,
            "time_improvement": 66.0,
            "length_improvement": 12.0,
            "smoothness_improvement": 1013.0,
            "node_improvement": 73.0,
            "other_inf": [
                {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.013331365585327149,
                    "num_nodes_avg": 130.7,
                    "path_length_avg": 179.30420886519545,
                    "smoothness_avg": 0.027773013783354228,
                    "success_improvement": 0.0,
                    "time_improvement": 48.30962934887612,
                    "node_improvement": 67.08637622765046,
                    "length_improvement": 1.7205218639765212,
                    "smoothness_improvement": 334.70797577422024,
                    "objective_score": 17.19874180191985
                },
                {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.01947922706604004,
                    "num_nodes_avg": 253.2,
                    "path_length_avg": 241.43064090254697,
                    "smoothness_avg": 0.0689551247796437,
                    "success_improvement": 0.0,
                    "time_improvement": 88.23545505178878,
                    "node_improvement": 82.98730094738963,
                    "length_improvement": 19.403502871040057,
                    "smoothness_improvement": 1674.2650269490814,
                    "objective_score": 46.48406337290607
                },
                {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.019611549377441407,
                    "num_nodes_avg": 254.3,
                    "path_length_avg": 126.26508083854677,
                    "smoothness_avg": 0.08886728614455755,
                    "success_improvement": 0.0,
                    "time_improvement": 61.354405538947546,
                    "node_improvement": 67.66687857596949,
                    "length_improvement": 16.140745404076515,
                    "smoothness_improvement": 1030.3853202580356,
                    "objective_score": 33.24269550542035
                }
            ],
            "success_rate": 1.0
        },
        "objective": 39.6,
        "analysis": {
            "problem": [
                "Problem of the parents algorithm:\n   - High computational overhead from expensive global smoothing methods and redundant collision checks during rewiring and smoothing.\n   - Limited adaptive radius tuning causing inefficient neighborhood exploration and suboptimal rewiring.\n   - Use of costly spline computations requiring external libraries, which may fail and fallback to no smoothing.\n   - Uniform sampling fallback in higher dimensions reducing informed sampling effectiveness.\n   - Lack of incremental or localized smoothing approaches resulting in slower planning and less agile path refinement."
            ],
            "solution": "1. Primary contributors to the performance improvement:\n   - Adoption of incremental shortcut smoothing techniques replacing costly global spline smoothing.\n   - Reduction of maximum iterations improving planning time without sacrificing solution quality.\n   - Maintaining adaptive radius for rewiring combined with more efficient collision checks and early termination after successful connection.\n2. Expected mechanism of impact:\n   - Incremental local shortcutting reduces smoothing time drastically while improving path smoothness by removing unnecessary detours.\n   - Early stopping and fewer iterations reduce overall computation time without significant loss in path quality.\n   - Efficient rewiring and edge validation ensure better path cost optimization and faster convergence, resulting in improved solution length and smoothness with reduced planning time."
        }
    },
    {
        "parents": [
            {
                "operator": "m3",
                "algorithm_description": "A bidirectional informed RRT* planner that accelerates convergence by focusing sampling within an ellipsoidal informed set based on the current best path cost, employs adaptive rewiring with efficient neighbor queries, and applies integrated shortcutting that directly updates the tree to improve path smoothness and length progressively. The planner balances exploration and exploitation by dynamically tuning goal bias and increments step expansions within map bounds, ensuring collision-free and coherent tree growth. Upon successful connection, it returns a refined smooth path with minimized length and improved curvature.",
                "planning_mechanism": "The planner alternates expansions from start and goal trees, sampling points inside an ellipsoidal informed space centered on the best found path to focus exploration efficiently. It selects near nodes within an adaptive radius for best parent selection and rewires neighbors to update cheaper connections. Integrated edge shortcutting directly restructures the tree by bypassing unnecessary nodes, improving path smoothness incrementally. The goal bias decays over time to gradually shift from goal-seeking to exploration, while careful collision checks ensure path validity. Upon connecting the trees, a final smoothing pass outputs an optimized path.",
                "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except ValueError:\n            pass\n\n    def path_from_root(self):\n        node, path = self, []\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=3000, step_size=8.0, base_radius=30.0,\n                 goal_sample_rate=0.15, min_goal_sample_rate=0.05,\n                 goal_sample_decay=0.9985, spatial_hash_cell=15.0,\n                 shortcut_iters=60):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.base_radius = base_radius\n        self.goal_sample_rate = goal_sample_rate\n        self.min_goal_sample_rate = min_goal_sample_rate\n        self.goal_sample_decay = goal_sample_decay\n        self.spatial_hash_cell = spatial_hash_cell\n        self.shortcut_iters = shortcut_iters\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(fr, to):\n            d = dist(fr, to)\n            if d <= self.step_size:\n                return to\n            ratio = self.step_size / d\n            return tuple(fr[i] + (to[i] - fr[i]) * ratio for i in range(dim))\n\n        def in_bounds(p):\n            for i in range(dim):\n                if p[i] < 0 or p[i] > bounds[i]:\n                    return False\n            return True\n\n        def is_in_obstacle(p):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d_ = obs\n                    if x <= p[0] <= x + w and y <= p[1] <= y + h and z <= p[2] <= z + d_:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    if x <= p[0] <= x + w and y <= p[1] <= y + h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(fr, to):\n            d = dist(fr, to)\n            resolution = min(1.0, self.step_size / 3.0)\n            steps = max(1, int(d / resolution))\n            for i in range(steps + 1):\n                interp = tuple(fr[j] + (to[j] - fr[j]) * i / steps for j in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        class SpatialHash:\n            def __init__(self, cell_size):\n                self.cell_size = cell_size\n                self.cells = {}\n\n            def _hash_key(self, point):\n                return tuple(int(coord // self.cell_size) for coord in point)\n\n            def insert(self, node):\n                key = self._hash_key(node.position)\n                if key not in self.cells:\n                    self.cells[key] = []\n                self.cells[key].append(node)\n\n            def neighbors(self, point, radius):\n                r_cell = int(math.ceil(radius / self.cell_size))\n                base_key = self._hash_key(point)\n                result = []\n                rng = range(-r_cell, r_cell+1)\n                if dim == 2:\n                    for dx in rng:\n                        for dy in rng:\n                            key = (base_key[0]+dx, base_key[1]+dy)\n                            if key in self.cells:\n                                result.extend(self.cells[key])\n                else:\n                    for dx in rng:\n                        for dy in rng:\n                            for dz in rng:\n                                key = (base_key[0]+dx, base_key[1]+dy, base_key[2]+dz)\n                                if key in self.cells:\n                                    result.extend(self.cells[key])\n                return result\n\n        def adaptive_radius(n):\n            n = max(n, 2)\n            gamma = self.base_radius\n            radius = gamma * (math.log(n) / n)**(1.0/dim)\n            return max(radius, self.step_size * 2.0)\n\n        def nearest(tree, spatial_hash, point):\n            candidates = spatial_hash.neighbors(point, self.step_size*4)\n            if not candidates:\n                return min(tree, key=lambda node: dist(node.position, point))\n            return min(candidates, key=lambda node: dist(node.position, point))\n\n        def near_nodes(tree, spatial_hash, point, radius):\n            r2 = radius*radius\n            candidates = spatial_hash.neighbors(point, radius)\n            result = []\n            for node in candidates:\n                d2 = 0\n                pos = node.position\n                for i in range(dim):\n                    diff = pos[i] - point[i]\n                    d2 += diff*diff\n                    if d2 > r2:\n                        break\n                else:\n                    result.append(node)\n            return result\n\n        def extract_path(node_start, node_goal):\n            path_start = node_start.path_from_root()\n            path_goal = node_goal.path_from_root()[::-1]\n            if path_start and path_goal and path_start[-1] == path_goal[0]:\n                path_goal = path_goal[1:]\n            return path_start + path_goal\n\n        def ellipse_sample(start, goal, c_max):\n            if c_max == float('inf'):\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            center = tuple((start[i] + goal[i]) * 0.5 for i in range(dim))\n            diff = tuple(goal[i] - start[i] for i in range(dim))\n            dist_sg = dist(start, goal)\n            if dist_sg < 1e-10:\n                # Avoid division by zero\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            # Construct rotation matrix from unit vector of diff to canonical axis\n            unit_vec = tuple(diff[i] / dist_sg for i in range(dim))\n            import math\n            if dim == 2:\n                # Rotates canonical x-axis (1,0) to unit_vec\n                angle = math.atan2(unit_vec[1], unit_vec[0])\n                for _ in range(10):  # box sampling in ellipse\n                    r1 = random.uniform(0,1)\n                    r2 = random.uniform(0,1)\n                    rx = r1 * c_max * 0.5\n                    ry = r2 * math.sqrt(c_max*c_max - dist_sg*dist_sg)*0.5\n                    # Rotate by angle\n                    x = rx * math.cos(angle) - ry * math.sin(angle)\n                    y = rx * math.sin(angle) + ry * math.cos(angle)\n                    sample = (center[0]+x, center[1]+y)\n                    if in_bounds(sample):\n                        return sample\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            else:\n                # 3D simplified axis-aligned ellipsoid sampling\n                rx = c_max * 0.5\n                ry = rx * 0.6\n                rz = rx * 0.4\n                for _ in range(20):\n                    x = random.uniform(-rx, rx)\n                    y = random.uniform(-ry, ry)\n                    z = random.uniform(-rz, rz)\n                    sample = (center[0]+x, center[1]+y, center[2]+z)\n                    if in_bounds(sample):\n                        return sample\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        def try_shortcut(node):\n            # Attempts to shortcut parent->node and update tree accordingly\n            if node.parent is None or node.parent.parent is None:\n                return False\n            grandparent = node.parent.parent\n            if not is_edge_in_obstacle(grandparent.position, node.position):\n                dist_new = dist(grandparent.position, node.position)\n                cost_candidate = grandparent.cost + dist_new\n                if cost_candidate + 1e-7 < node.cost:\n                    # Cut out parent node\n                    prev_parent = node.parent\n                    prev_parent.remove_child(node)\n                    node.parent = grandparent\n                    grandparent.add_child(node)\n                    node.cost = cost_candidate\n                    return True\n            return False\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        start_hash = SpatialHash(self.spatial_hash_cell)\n        goal_hash = SpatialHash(self.spatial_hash_cell)\n        start_hash.insert(start_tree[0])\n        goal_hash.insert(goal_tree[0])\n\n        success = False\n        conn_start = None\n        conn_goal = None\n        best_cost = float('inf')\n\n        def get_goal_sample_rate(it):\n            rate = self.goal_sample_rate*(self.goal_sample_decay**it)\n            return max(rate, self.min_goal_sample_rate)\n\n        for it in range(self.max_iter):\n            for tree_a, tree_b, hash_a, hash_b in [(start_tree, goal_tree, start_hash, goal_hash),\n                                                   (goal_tree, start_tree, goal_hash, start_hash)]:\n                c_max = best_cost if best_cost < float('inf') else float('inf')\n                # Sample in informed ellipse or uniform\n                if random.random() < get_goal_sample_rate(it):\n                    sample_pt = goal_pos\n                else:\n                    sample_pt = ellipse_sample(start_pos, goal_pos, c_max)\n\n                nearest_node = nearest(tree_a, hash_a, sample_pt)\n                new_pos = steer(nearest_node.position, sample_pt)\n                if not in_bounds(new_pos) or is_in_obstacle(new_pos) or is_edge_in_obstacle(nearest_node.position, new_pos):\n                    continue\n\n                radius = adaptive_radius(len(tree_a))\n                near = near_nodes(tree_a, hash_a, new_pos, radius)\n\n                min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n                min_parent = nearest_node\n                for node in near:\n                    if node == nearest_node:\n                        continue\n                    cand_cost = node.cost + dist(node.position, new_pos)\n                    if cand_cost + 1e-7 < min_cost and not is_edge_in_obstacle(node.position, new_pos):\n                        min_cost = cand_cost\n                        min_parent = node\n\n                new_node = Node(new_pos, parent=min_parent, cost=min_cost)\n                min_parent.add_child(new_node)\n                tree_a.append(new_node)\n                hash_a.insert(new_node)\n                nodes.append(new_node)\n                edges.append((min_parent, new_node))\n\n                # Rewire others in near to new_node\n                for node in near:\n                    if node == min_parent:\n                        continue\n                    cost_through_new = new_node.cost + dist(new_node.position, node.position)\n                    if cost_through_new + 1e-7 < node.cost and not is_edge_in_obstacle(new_node.position, node.position):\n                        if node.parent is not None:\n                            try:\n                                edges.remove((node.parent, node))\n                                node.parent.remove_child(node)\n                            except ValueError:\n                                pass\n                        node.parent = new_node\n                        node.cost = cost_through_new\n                        new_node.add_child(node)\n                        edges.append((new_node, node))\n\n                # Incremental shortcut: attempt to shortcut the parent of new_node and new_node\n                try_shortcut(new_node)\n\n                # Attempt connection with other tree\n                nearest_other = nearest(tree_b, hash_b, new_node.position)\n                dist_to_other = dist(new_node.position, nearest_other.position)\n                radius_conn = max(self.step_size*2.5, adaptive_radius(len(tree_b)))\n                if dist_to_other <= radius_conn:\n                    if not is_edge_in_obstacle(new_node.position, nearest_other.position):\n                        # Connect and check cost\n                        total_cost = new_node.cost + dist(new_node.position, nearest_other.position) + nearest_other.cost\n                        if total_cost + 1e-7 < best_cost:\n                            best_cost = total_cost\n                            if tree_a is start_tree:\n                                conn_start, conn_goal = new_node, nearest_other\n                            else:\n                                conn_start, conn_goal = nearest_other, new_node\n                            success = True\n\n            if success:\n                break\n\n        def global_shortcut(path):\n            if len(path) < 3:\n                return path[:]\n            p = path[:]\n            for _ in range(self.shortcut_iters):\n                if len(p) < 3:\n                    break\n                i = random.randint(0, len(p)-3)\n                j = random.randint(i+2, len(p)-1)\n                if not is_edge_in_obstacle(p[i], p[j]):\n                    # Direct shortcut possible\n                    p = p[:i+1] + p[j:]\n            return p\n\n        path = []\n        if success:\n            raw_path = extract_path(conn_start, conn_goal)\n            path = global_shortcut(raw_path)\n\n        return PlannerResult(success, path, nodes, edges)",
                "objective": -29.07513,
                "time_improvement": 46.0,
                "length_improvement": 13.0,
                "smoothness_improvement": 1552.0,
                "node_improvement": 79.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.022878313064575197,
                        "num_nodes_avg": 108.0,
                        "path_length_avg": 176.72513927050028,
                        "smoothness_avg": 0.048083635789917235,
                        "success_improvement": 0.0,
                        "time_improvement": 11.29277232619517,
                        "node_improvement": 72.80282044824982,
                        "length_improvement": 3.1341507768019334,
                        "smoothness_improvement": 652.6133153985471,
                        "objective_score": 8.531388740932446
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.025338506698608397,
                        "num_nodes_avg": 166.1,
                        "path_length_avg": 238.11535426794504,
                        "smoothness_avg": 0.09899642721104027,
                        "success_improvement": 0.0,
                        "time_improvement": 84.69672333682949,
                        "node_improvement": 88.83961566888397,
                        "length_improvement": 20.510240974904963,
                        "smoothness_improvement": 2447.249376384447,
                        "objective_score": 49.95140846791406
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.030141329765319823,
                        "num_nodes_avg": 205.1,
                        "path_length_avg": 128.54137182752055,
                        "smoothness_avg": 0.13024857643772353,
                        "success_improvement": 0.0,
                        "time_improvement": 40.60491681665556,
                        "node_improvement": 73.92244119516846,
                        "length_improvement": 14.628941314529026,
                        "smoothness_improvement": 1556.7522783379848,
                        "objective_score": 28.74260122540401
                    }
                ],
                "success_rate": 1.0
            },
            {
                "operator": "cross_over",
                "algorithm_description": "A bidirectional hybrid-sampling RRT* planner with adaptive connection radius, dynamic rewiring focused on cost improvements, and incremental shortcut smoothing for maintaining smooth feasible paths. The planner mixes uniform and ellipsoidal informed sampling based on current best path cost to balance exploration and exploitation, computes radius based on node density and cost, and continuously improves paths through local rewiring and periodic lightweight smoothing. This approach reduces redundant neighbor checks and rewiring overhead, accelerates convergence to shorter and smoother paths, and efficiently manages collision checks to lower planning time.",
                "planning_mechanism": "A bidirectional RRT* planner that employs hybrid uniform/informed sampling with adaptive neighborhood radius, performs rewiring constrained to relevant nearby nodes to minimize overhead, connects two growing trees when close, and applies incremental shortcut smoothing during planning to maintain path quality. Early feasible paths guide focused sampling and adaptive radius adjustments, encouraging rapid convergence to minimal-length, smooth paths with reduced computational cost.",
                "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n    def add_child(self, child):\n        self.children.append(child)\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=7.0, base_radius=20.0, goal_sample_rate=0.05, smooth_interval=50):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.base_radius = base_radius\n        self.goal_sample_rate = goal_sample_rate\n        self.smooth_interval = smooth_interval\n\n    def plan(self, map):\n        import math, random\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = dim == 3\n\n        def dist(a, b):\n            return math.dist(a, b)\n        def sq_dist(a,b):\n            return sum((a[i]-b[i])**2 for i in range(dim))\n\n        def is_in_obstacle(p):\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d_ = obs\n                    px,py,pz = p\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d_:\n                        return True\n                else:\n                    x,y,w_,h_ = obs\n                    px,py = p\n                    if x <= px <= x + w_ and y <= py <= y + h_:\n                        return True\n            return False\n\n        def edge_in_collision(p1,p2,res=1.0):\n            length = dist(p1,p2)\n            if length == 0: return False\n            steps = max(1,int(length/res))\n            for i in range(steps+1):\n                interp = tuple(p1[d] + (p2[d]-p1[d]) * i/steps for d in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def steer(from_p, to_p):\n            length = dist(from_p,to_p)\n            if length <= self.step_size:\n                return to_p\n            ratio = self.step_size / length\n            return tuple(from_p[d] + (to_p[d] - from_p[d]) * ratio for d in range(dim))\n\n        def nearest(tree, point):\n            # Linear nearest neighbor\n            return min(tree, key=lambda n: sq_dist(n.position, point))\n\n        # Adaptive radius based on node count and best_cost\n        def adaptive_radius(num_nodes, best_cost):\n            gamma = self.base_radius\n            dim_factor = dim\n            if best_cost == float('inf'):\n                # Use max radius with decay on node count\n                return max(self.step_size, gamma * (math.log(num_nodes+1) / (num_nodes+1))**(1/dim_factor))\n            else:\n                # Scale radius based on path cost and node density\n                r = gamma * (math.log(num_nodes+1) / (num_nodes+1))**(1/dim_factor)\n                # Limit to a fraction of best_cost for focused rewiring\n                return min(r, best_cost * 0.5)\n\n        def near(tree, point, radius):\n            radius_sq = radius*radius\n            return [n for n in tree if sq_dist(n.position, point) <= radius_sq]\n\n        def extract_path(n_start, n_goal):\n            path1 = []\n            n = n_start\n            while n:\n                path1.append(n.position)\n                n = n.parent\n            path2 = []\n            n = n_goal\n            while n:\n                path2.append(n.position)\n                n = n.parent\n            return path1[::-1] + path2\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path[:]\n            shortcut = [path[0]]\n            i = 0\n            while i < len(path)-1:\n                j = len(path)-1\n                while j > i+1:\n                    if not edge_in_collision(path[i], path[j]):\n                        break\n                    j -= 1\n                shortcut.append(path[j])\n                i = j\n            return shortcut\n\n        def hybrid_sample(best_cost, c_min):\n            # Probability to do informed sampling grows as best_cost improves\n            if best_cost == float('inf') or best_cost <= c_min:\n                # Uniform sampling\n                while True:\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not is_in_obstacle(p):\n                        return p\n            else:\n                # Informed ellipsoid sampling\n                while True:\n                    if dim == 2:\n                        import math\n                        r = random.uniform(0,1)**0.5\n                        theta = random.uniform(0,2*math.pi)\n                        x_ball = [r * math.cos(theta), r * math.sin(theta)]\n                    else:\n                        from math import sqrt\n                        while True:\n                            x_ball = [random.uniform(-1,1) for _ in range(3)]\n                            if sum(x*x for x in x_ball) <= 1: break\n                    center = tuple((start_pos[d] + goal_pos[d]) * 0.5 for d in range(dim))\n                    dir_vec = [goal_pos[d] - start_pos[d] for d in range(dim)]\n                    length = dist(start_pos, goal_pos)\n                    if length == 0:\n                        R = [[1 if i==j else 0 for j in range(dim)] for i in range(dim)]\n                    else:\n                        # Compute 2D rotation matrix or identity 3D (approximate)\n                        if dim == 2:\n                            from math import cos, sin\n                            a1 = [1,0]\n                            a2 = [dir_vec[0]/length, dir_vec[1]/length]\n                            costh = a1[0]*a2[0] + a1[1]*a2[1]\n                            sinth = a1[0]*a2[1] - a1[1]*a2[0]\n                            R = [[costh, -sinth], [sinth, costh]]\n                        else:\n                            R = [[1 if i==j else 0 for j in range(dim)] for i in range(dim)]\n                    a1_val = best_cost / 2.0\n                    a_other = ((best_cost**2 - c_min**2)**0.5) / 2.0\n                    if dim == 2:\n                        L = [[a1_val, 0],[0, a_other]]\n                        x_scaled = [L[0][0]*x_ball[0] + L[0][1]*x_ball[1],\n                                    L[1][0]*x_ball[0] + L[1][1]*x_ball[1]]\n                        pt = (center[0] + R[0][0]*x_scaled[0] + R[0][1]*x_scaled[1],\n                              center[1] + R[1][0]*x_scaled[0] + R[1][1]*x_scaled[1])\n                    else:\n                        L = [[a1_val,0,0],[0,a_other,0],[0,0,a_other]]\n                        x_scaled = [L[0][0]*x_ball[0], L[1][1]*x_ball[1], L[2][2]*x_ball[2]]\n                        pt = tuple(center[i] + sum(R[i][j]*x_scaled[j] for j in range(dim)) for i in range(dim))\n                    # Check bounds and obstacles\n                    if any(pt[d]<0 or pt[d]>bounds[d] for d in range(dim)):\n                        continue\n                    if not is_in_obstacle(pt):\n                        return pt\n\n        # Initialize trees\n        start_tree = [Node(start_pos, cost=0.0)]\n        goal_tree = [Node(goal_pos, cost=0.0)]\n        all_nodes = start_tree + goal_tree\n        edges = []\n\n        c_min = dist(start_pos, goal_pos)\n        best_cost = float('inf')\n        solution_nodes = None\n\n        for iter_num in range(self.max_iter):\n            # Hybrid sampling biased with goal sample rate and best path cost\n            if random.random() < self.goal_sample_rate:\n                sample_point = goal_pos\n            else:\n                sample_point = hybrid_sample(best_cost, c_min)\n\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest_node = nearest(tree_a, sample_point)\n                new_pos = steer(nearest_node.position, sample_point)\n                if is_in_obstacle(new_pos):\n                    continue\n                if edge_in_collision(nearest_node.position, new_pos):\n                    continue\n\n                radius = adaptive_radius(len(tree_a), best_cost)\n                near_nodes = near(tree_a, new_pos, radius)\n\n                # Pick best parent among near nodes & nearest_node\n                min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n                min_parent = nearest_node\n                for n_ in near_nodes:\n                    c_ = n_.cost + dist(n_.position, new_pos)\n                    if c_ + 1e-9 < min_cost and not edge_in_collision(n_.position, new_pos):\n                        min_cost = c_\n                        min_parent = n_\n\n                new_node = Node(new_pos)\n                new_node.parent = min_parent\n                new_node.cost = min_cost\n                min_parent.add_child(new_node)\n                tree_a.append(new_node)\n                all_nodes.append(new_node)\n                edges.append((min_parent, new_node))\n\n                # Rewire neighbors if better cost through new_node\n                for near_node in near_nodes:\n                    if near_node is min_parent:\n                        continue\n                    new_cost = new_node.cost + dist(new_node.position, near_node.position)\n                    if new_cost + 1e-9 < near_node.cost and not edge_in_collision(new_node.position, near_node.position):\n                        old_parent = near_node.parent\n                        if old_parent:\n                            old_parent.remove_child(near_node)\n                            try:\n                                edges.remove((old_parent, near_node))\n                            except ValueError:\n                                pass\n                        near_node.parent = new_node\n                        near_node.cost = new_cost\n                        new_node.add_child(near_node)\n                        edges.append((new_node, near_node))\n\n                # Attempt tree connection\n                near_other = near(tree_b, new_node.position, radius)\n                connected = False\n                for potential_connect in near_other:\n                    if dist(new_node.position, potential_connect.position) <= self.step_size:\n                        if not edge_in_collision(new_node.position, potential_connect.position):\n                            path_cost = new_node.cost + dist(new_node.position, potential_connect.position) + potential_connect.cost\n                            if path_cost + 1e-9 < best_cost:\n                                best_cost = path_cost\n                                if tree_a is start_tree:\n                                    solution_nodes = (new_node, potential_connect)\n                                else:\n                                    solution_nodes = (potential_connect, new_node)\n                                connected = True\n                # Optional early shortcut smoothing if solution found intermittently\n                if connected and (iter_num % self.smooth_interval == 0):\n                    raw_path = extract_path(solution_nodes[0], solution_nodes[1])\n                    smoothed_path = shortcut_path(raw_path)\n                    return PlannerResult(True, smoothed_path, all_nodes, edges)\n\n            # Progressively shortcut best current path periodically\n            if best_cost < float('inf') and (iter_num % self.smooth_interval == 0 or iter_num == self.max_iter - 1):\n                raw_path = extract_path(solution_nodes[0], solution_nodes[1])\n                smoothed_path = shortcut_path(raw_path)\n                return PlannerResult(True, smoothed_path, all_nodes, edges)\n\n        return PlannerResult(False, [], all_nodes, edges)",
                "objective": -28.59606,
                "time_improvement": 39.0,
                "length_improvement": 14.0,
                "smoothness_improvement": 1746.0,
                "node_improvement": 75.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.021425294876098632,
                        "num_nodes_avg": 130.3,
                        "path_length_avg": 171.222098585506,
                        "smoothness_avg": 0.05486030780823546,
                        "success_improvement": 0.0,
                        "time_improvement": 16.926632431857787,
                        "node_improvement": 67.18710652228658,
                        "length_improvement": 6.150454577507222,
                        "smoothness_improvement": 758.6829482640493,
                        "objective_score": 12.561677217381915
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.04977266788482666,
                        "num_nodes_avg": 248.0,
                        "path_length_avg": 238.55406124324037,
                        "smoothness_avg": 0.10645268698164882,
                        "success_improvement": 0.0,
                        "time_improvement": 69.93962919892846,
                        "node_improvement": 83.33669287106095,
                        "length_improvement": 20.363787959071246,
                        "smoothness_improvement": 2639.1043108090394,
                        "objective_score": 46.39568308916648
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.035963916778564455,
                        "num_nodes_avg": 192.7,
                        "path_length_avg": 128.24648584607198,
                        "smoothness_avg": 0.15246287415469548,
                        "success_improvement": 0.0,
                        "time_improvement": 29.13120140042875,
                        "node_improvement": 75.49904640813732,
                        "length_improvement": 14.824790542445692,
                        "smoothness_improvement": 1839.3165056089729,
                        "objective_score": 26.830817273640903
                    }
                ],
                "success_rate": 1.0
            }
        ],
        "offspring": {
            "operator": "m1",
            "algorithm_description": "A bidirectional RRT* variant with a kd-tree-based nearest neighbor structure for efficient queries, ellipsoidal informed sampling to concentrate search around the best path, adaptive rewiring radius balancing exploration and exploitation, and a deferred global shortcut smoothing applied once a solution is found. The planner alternates expansion between the two trees, dynamically adjusts goal bias with iteration progress, and integrates collision checks before node/edge additions to ensure path validity and coherent tree structures, leading to improved planning time, path length, and smoothness.",
            "planning_mechanism": "The planner maintains two trees rooted at start and goal, performing expansions alternately. Each sample is drawn either from an informed ellipsoidal set biased by the current best path cost or via goal-biased sampling. kd-tree data structures enable fast nearest neighbor and radius-based neighbor retrievals. Parent selection and rewiring optimize path cost while collision checks maintain feasibility. Once a valid connection between trees appears, the planner reconstructs the combined path and applies global shortcutting for smoothness and length improvement before returning the result.",
            "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n    def add_child(self, child):\n        self.children.append(child)\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=3000, step_size=8.0, base_radius=25.0,\n                 goal_sample_rate=0.15, min_goal_sample_rate=0.05,\n                 goal_sample_decay=0.995, shortcut_iters=80):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.base_radius = base_radius\n        self.goal_sample_rate = goal_sample_rate\n        self.min_goal_sample_rate = min_goal_sample_rate\n        self.goal_sample_decay = goal_sample_decay\n        self.shortcut_iters = shortcut_iters\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def dist(a,b):\n            return math.dist(a,b)\n        def sq_dist(a,b):\n            return sum((a[i]-b[i])**2 for i in range(dim))\n        def in_bounds(p):\n            for i in range(dim):\n                if p[i]<0 or p[i]>bounds[i]:\n                    return False\n            return True\n        def is_in_obstacle(p):\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d_ = obs\n                    px,py,pz = p\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d_:\n                        return True\n                else:\n                    x,y,w_,h_ = obs\n                    px,py = p\n                    if x <= px <= x+w_ and y <= py <= y+h_:\n                        return True\n            return False\n        def edge_in_collision(fr,to, resolution=1.0):\n            length = dist(fr,to)\n            if length == 0: return False\n            steps = max(1, int(length/resolution))\n            for i in range(steps+1):\n                interp = tuple(fr[d] + (to[d]-fr[d])*i/steps for d in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n        def steer(fr,to):\n            length = dist(fr,to)\n            if length <= self.step_size:\n                return to\n            ratio = self.step_size / length\n            return tuple(fr[d] + (to[d] - fr[d]) * ratio for d in range(dim))\n\n        # Implement a simple k-d tree for efficient neighbor queries\n        class KDTree:\n            def __init__(self, points=None, depth=0):\n                self.axis = depth % dim\n                if not points:\n                    self.location = None\n                    self.left = None\n                    self.right = None\n                    self.nodes = []\n                    return\n                points = sorted(points, key=lambda n: n.position[self.axis])\n                median = len(points)//2\n                self.location = points[median]\n                self.left = KDTree(points[:median], depth+1) if median > 0 else None\n                self.right = KDTree(points[median+1:], depth+1) if median+1 < len(points) else None\n                self.nodes = None  # only in leaf-less nodes\n\n            def insert(self, node, depth=0):\n                if self.location is None:\n                    self.location = node\n                    self.left = None\n                    self.right = None\n                    return\n                axis = depth % dim\n                if node.position[axis] < self.location.position[axis]:\n                    if self.left is None:\n                        self.left = KDTree([node], depth+1)\n                    else:\n                        self.left.insert(node, depth+1)\n                else:\n                    if self.right is None:\n                        self.right = KDTree([node], depth+1)\n                    else:\n                        self.right.insert(node, depth+1)\n\n            def nearest(self, point, best=None, best_dist=float('inf'), depth=0):\n                if self.location is None:\n                    return best, best_dist\n                axis = depth % dim\n                here_dist = sq_dist(point, self.location.position)\n                if here_dist < best_dist:\n                    best = self.location\n                    best_dist = here_dist\n                diff = point[axis] - self.location.position[axis]\n                close, away = (self.left, self.right) if diff < 0 else (self.right, self.left)\n                if close is not None:\n                    best, best_dist = close.nearest(point, best, best_dist, depth+1)\n                if away is not None and diff*diff < best_dist:\n                    best, best_dist = away.nearest(point, best, best_dist, depth+1)\n                return best, best_dist\n\n            def radius_search(self, point, radius, results=None, depth=0):\n                if results is None:\n                    results = []\n                if self.location is None:\n                    return results\n                axis = depth % dim\n                dist_sq = sq_dist(point, self.location.position)\n                if dist_sq <= radius*radius:\n                    results.append(self.location)\n                diff = point[axis] - self.location.position[axis]\n                if self.left is not None and diff - radius <= 0:\n                    self.left.radius_search(point, radius, results, depth+1)\n                if self.right is not None and diff + radius >= 0:\n                    self.right.radius_search(point, radius, results, depth+1)\n                return results\n\n        def adaptive_radius(n_nodes):\n            n_nodes = max(n_nodes, 2)\n            gamma = self.base_radius\n            radius = gamma * (math.log(n_nodes)/n_nodes)**(1/dim)\n            return max(radius, self.step_size*1.5)\n\n        def ellipsoid_sample(start, goal, c_max):\n            if c_max == float('inf'):\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            center = tuple((start[d]+goal[d])*0.5 for d in range(dim))\n            diff = tuple(goal[d]-start[d] for d in range(dim))\n            dist_sg = dist(start, goal)\n            if dist_sg < 1e-100:\n                return tuple(random.uniform(0,bounds[d]) for d in range(dim))\n            unit_vec = tuple(diff[d]/dist_sg for d in range(dim))\n            if dim == 2:\n                import math\n                angle = math.atan2(unit_vec[1], unit_vec[0])\n                for _ in range(15):\n                    r1 = random.uniform(0,1)\n                    r2 = random.uniform(0,1)\n                    rx = r1 * c_max * 0.5\n                    ry = r2 * math.sqrt(c_max*c_max - dist_sg*dist_sg)*0.5\n                    x = rx * math.cos(angle) - ry * math.sin(angle)\n                    y = rx * math.sin(angle) + ry * math.cos(angle)\n                    sample = (center[0]+x, center[1]+y)\n                    if in_bounds(sample):\n                        return sample\n                return tuple(random.uniform(0,bounds[d]) for d in range(dim))\n            else:\n                rx = c_max*0.5\n                ry = rx*0.6\n                rz = rx*0.4\n                for _ in range(25):\n                    x = random.uniform(-rx, rx)\n                    y = random.uniform(-ry, ry)\n                    z = random.uniform(-rz, rz)\n                    sample = (center[0]+x, center[1]+y, center[2]+z)\n                    if in_bounds(sample):\n                        return sample\n                return tuple(random.uniform(0,bounds[d]) for d in range(dim))\n\n        def extract_path(node_start, node_goal):\n            path_start = node_start.path_from_root()\n            path_goal = node_goal.path_from_root()[::-1]\n            if path_start and path_goal and path_start[-1] == path_goal[0]:\n                path_goal = path_goal[1:]\n            return path_start + path_goal\n\n        def global_shortcut(path):\n            if len(path) < 3:\n                return path[:]\n            p = path[:]\n            for _ in range(self.shortcut_iters):\n                if len(p) < 3:\n                    break\n                i = random.randint(0, len(p)-3)\n                j = random.randint(i+2, len(p)-1)\n                if not edge_in_collision(p[i], p[j]):\n                    p = p[:i+1] + p[j:]\n            return p\n\n        # Initialize trees and kd-trees\n        start_root = Node(start_pos)\n        goal_root = Node(goal_pos)\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n        all_nodes = start_tree + goal_tree\n        edges = []\n\n        kd_start = KDTree([start_root])\n        kd_goal = KDTree([goal_root])\n\n        best_cost = float('inf')\n        connection = None\n        goal_bias = self.goal_sample_rate\n\n        for it in range(self.max_iter):\n            goal_bias = max(self.min_goal_sample_rate, goal_bias * self.goal_sample_decay)\n\n            for tree_a, tree_b, kd_a, kd_b in [(start_tree, goal_tree, kd_start, kd_goal),\n                                               (goal_tree, start_tree, kd_goal, kd_start)]:\n                c_max = best_cost if best_cost < float('inf') else float('inf')\n                if random.random() < goal_bias:\n                    sample = goal_pos\n                else:\n                    sample = ellipsoid_sample(start_pos, goal_pos, c_max)\n                if is_in_obstacle(sample):\n                    continue\n\n                nearest_node, _ = kd_a.nearest(sample)\n                if nearest_node is None:\n                    continue\n                new_pos = steer(nearest_node.position, sample)\n                if not in_bounds(new_pos) or is_in_obstacle(new_pos) or edge_in_collision(nearest_node.position, new_pos):\n                    continue\n                radius = adaptive_radius(len(tree_a)+1)\n                near_nodes = kd_a.radius_search(new_pos, radius)\n\n                min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n                min_parent = nearest_node\n                for nb in near_nodes:\n                    if nb == nearest_node:\n                        continue\n                    cand_cost = nb.cost + dist(nb.position, new_pos)\n                    if cand_cost + 1e-9 < min_cost and not edge_in_collision(nb.position, new_pos):\n                        min_cost = cand_cost\n                        min_parent = nb\n\n                new_node = Node(new_pos, parent=min_parent, cost=min_cost)\n                min_parent.add_child(new_node)\n                tree_a.append(new_node)\n                all_nodes.append(new_node)\n                edges.append((min_parent, new_node))\n                kd_a.insert(new_node)\n\n                # Rewire near nodes through new_node if improvement\n                for nb in near_nodes:\n                    if nb == min_parent:\n                        continue\n                    new_cost = new_node.cost + dist(new_node.position, nb.position)\n                    if new_cost + 1e-9 < nb.cost and not edge_in_collision(new_node.position, nb.position):\n                        old_parent = nb.parent\n                        if old_parent:\n                            old_parent.remove_child(nb)\n                            try:\n                                edges.remove((old_parent, nb))\n                            except ValueError:\n                                pass\n                        nb.parent = new_node\n                        nb.cost = new_cost\n                        new_node.add_child(nb)\n                        edges.append((new_node, nb))\n\n                # Attempt connection with other tree - nearest node within step_size\n                near_other = kd_b.radius_search(new_node.position, self.step_size*1.5)\n                for node_other in near_other:\n                    if dist(new_node.position, node_other.position) <= self.step_size:\n                        if not edge_in_collision(new_node.position, node_other.position):\n                            total_cost = new_node.cost + dist(new_node.position, node_other.position) + node_other.cost\n                            if total_cost + 1e-9 < best_cost:\n                                best_cost = total_cost\n                                if tree_a is start_tree:\n                                    connection = (new_node, node_other)\n                                else:\n                                    connection = (node_other, new_node)\n\n            if connection is not None:\n                break\n\n        if connection is None:\n            return PlannerResult(False, [], all_nodes, edges)\n\n        raw_path = extract_path(connection[0], connection[1])\n        smooth_path = global_shortcut(raw_path)\n\n        return PlannerResult(True, smooth_path, all_nodes, edges)",
            "objective": -35.67144,
            "time_improvement": 62.0,
            "length_improvement": 15.0,
            "smoothness_improvement": 1613.0,
            "node_improvement": 80.0,
            "other_inf": [
                {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.017667293548583984,
                    "num_nodes_avg": 101.7,
                    "path_length_avg": 166.13517920479458,
                    "smoothness_avg": 0.03625333347975132,
                    "success_improvement": 0.0,
                    "time_improvement": 31.497718963341637,
                    "node_improvement": 74.38932258876858,
                    "length_improvement": 8.938675697471036,
                    "smoothness_improvement": 467.4433943318028,
                    "objective_score": 17.149738079144125
                },
                {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.0215378999710083,
                    "num_nodes_avg": 201.5,
                    "path_length_avg": 233.193267577381,
                    "smoothness_avg": 0.1118364131236119,
                    "success_improvement": 0.0,
                    "time_improvement": 86.99211260077399,
                    "node_improvement": 86.46106295773701,
                    "length_improvement": 22.15337518662528,
                    "smoothness_improvement": 2777.6314621829497,
                    "objective_score": 53.277816203122114
                },
                {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.016871142387390136,
                    "num_nodes_avg": 164.8,
                    "path_length_avg": 128.99936346398462,
                    "smoothness_avg": 0.1331070185910396,
                    "success_improvement": 0.0,
                    "time_improvement": 66.75452233530704,
                    "node_improvement": 79.04640813731724,
                    "length_improvement": 14.324765076807733,
                    "smoothness_improvement": 1593.1114515399127,
                    "objective_score": 36.58677300437632
                }
            ],
            "success_rate": 1.0
        },
        "objective": 30.799999999999997,
        "analysis": {
            "problem": [
                "Problem of the parents algorithm:\n   - Inefficient nearest neighbor and radius searches without dedicated spatial data structures, leading to slower query times as node count increases.\n   - Redundant computations due to symmetric expansions from both trees in each iteration without optimized pruning.\n   - Incremental local shortcutting limited in scope, resulting in suboptimal smoothness gains.\n   - Adaptive radius functions either too conservative or limited by path cost fractions, restricting effective rewiring.\n   - Sampling strategies with occasional rudimentary informed sampling but lacking dynamic bias adjustment and efficient ellipsoidal sampling validation.\n   - Early or intermittent path smoothing applied inconsistently, reducing final path quality."
            ],
            "solution": "1. Primary contributors to the performance improvement:\n   - Introduction and integration of a kd-tree structure for efficient nearest neighbor and radius searches.\n   - More effective and adaptive ellipsoidal informed sampling with dynamic goal bias decay, improving focused exploration.\n   - Enhanced rewiring strategy that systematically considers near neighbors with better path cost and incorporates consistent parent-child relationship upkeep.\n   - Deferred and iterative global shortcutting applied after solution discovery, improving path smoothness and length.\n2. Expected mechanism of impact:\n   - kd-tree accelerates nearest and radius queries, reducing per-iteration computational overhead and improving overall planning speed.\n   - Adaptive informed sampling reduces wasted samples outside promising regions, focusing search near current best paths for faster convergence.\n   - Improved rewiring broadens opportunities for cost reduction and better path connectivity, resulting in shorter and more optimal paths.\n   - Post-processing smoothing removes path redundancies and sharp turns, enhancing smoothness without impact on planning time."
        }
    },
    {
        "parents": [
            {
                "operator": "m3",
                "algorithm_description": "A simplified bidirectional RRT* planner with hybrid sampling combining uniform and ellipsoidal informed sampling to balance exploration and exploitation, adaptive rewiring radius based on node density, and periodic path shortcutting for improved smoothness and path length. The planner performs efficient nearest and near neighbor queries using spatial hashing, ensuring collision-free extension and connections, and returns an optimized and smoothed path when found or partial result on timeout.",
                "planning_mechanism": "The planner grows two trees from start and goal alternately, samples points blending uniform and informed ellipsoidal sampling constrained by current best solution cost, extends towards samples using adaptive radius rewiring to locally optimize paths, uses spatial hashing for efficient neighborhood queries, attempts connection between trees based on adaptive connection radius, performs periodic shortcutting to incrementally smooth the best current path, and returns the best solution found within iteration limits.",
                "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except ValueError:\n            pass\n    def path_from_root(self):\n        node, path = self, []\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=3500, step_size=5.0, base_radius=20.0,\n                 shortcut_freq=30, shortcut_attempts=40,\n                 uniform_sample_rate=0.3, spatial_hash_size=8.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.base_radius = base_radius\n        self.shortcut_freq = shortcut_freq\n        self.shortcut_attempts = shortcut_attempts\n        self.uniform_sample_rate = uniform_sample_rate\n        self.spatial_hash_size = spatial_hash_size\n\n    def plan(self, map):\n        import math, random\n\n        bounds = map.size\n        obstacles = map.obstacles\n        start_pos = map.start\n        goal_pos = map.goal\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        def dist(a,b):\n            return math.dist(a,b)\n\n        def steer(fr, to):\n            d = dist(fr,to)\n            if d <= self.step_size:\n                return to\n            ratio = self.step_size/d\n            return tuple(fr[i] + (to[i]-fr[i])*ratio for i in range(dim))\n\n        def in_obstacle(p):\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d_ = obs\n                    px,py,pz = p\n                    if x<=px<=x+w and y<=py<=y+h and z<=pz<=z+d_:\n                        return True\n                else:\n                    x,y,w_,h_ = obs\n                    px,py = p\n                    if x<=px<=x+w_ and y<=py<=y+h_:\n                        return True\n            return False\n\n        def edge_in_obstacle(p1,p2):\n            d = dist(p1,p2)\n            res = min(1.0, self.step_size/2)\n            steps = max(1,int(d/res))\n            for i in range(steps+1):\n                interp = tuple(p1[j]+(p2[j]-p1[j])*i/steps for j in range(dim))\n                if in_obstacle(interp):\n                    return True\n            return False\n\n        class SpatialHash:\n            def __init__(self, cell_size):\n                self.cell_size = cell_size\n                self.cells = {}\n            def _hash_key(self, point):\n                return tuple(int(p//self.cell_size) for p in point)\n            def insert(self, node):\n                key = self._hash_key(node.position)\n                self.cells.setdefault(key,[]).append(node)\n            def neighbors(self, point, radius):\n                rcell = int(math.ceil(radius/self.cell_size))\n                base = self._hash_key(point)\n                result = []\n                rng = range(-rcell, rcell+1)\n                if dim==2:\n                    for dx in rng:\n                        for dy in rng:\n                            key = (base[0]+dx, base[1]+dy)\n                            if key in self.cells:\n                                result.extend(self.cells[key])\n                else:\n                    for dx in rng:\n                        for dy in rng:\n                            for dz in rng:\n                                key=(base[0]+dx, base[1]+dy, base[2]+dz)\n                                if key in self.cells:\n                                    result.extend(self.cells[key])\n                return result\n\n        start_hash = SpatialHash(self.spatial_hash_size)\n        goal_hash = SpatialHash(self.spatial_hash_size)\n        start_hash.insert(start_tree[0])\n        goal_hash.insert(goal_tree[0])\n\n        def nearest(tree, sp_hash, pt):\n            nbrs = sp_hash.neighbors(pt, self.step_size*4)\n            if nbrs:\n                return min(nbrs, key=lambda n: dist(n.position, pt))\n            return min(tree, key=lambda n: dist(n.position, pt))\n\n        def near_nodes(tree, sp_hash, pt, radius):\n            r2 = radius*radius\n            nbrs = sp_hash.neighbors(pt, radius)\n            return [n for n in nbrs if sum((n.position[i]-pt[i])**2 for i in range(dim)) <= r2]\n\n        def adaptive_radius(n):\n            n=max(n,2)\n            r= self.base_radius*(math.log(n)/n)**(1/dim)\n            return max(r, self.step_size*1.2)\n\n        def update_parent(child, new_parent, new_cost):\n            if child.parent:\n                child.parent.remove_child(child)\n                try:\n                    edges.remove((child.parent,child))\n                except ValueError:\n                    pass\n            child.parent = new_parent\n            child.cost = new_cost\n            new_parent.add_child(child)\n            edges.append((new_parent,child))\n\n        def propagate_costs(node):\n            for c in node.children:\n                new_cost = node.cost + dist(node.position,c.position)\n                if new_cost+1e-10 < c.cost:\n                    update_parent(c,node,new_cost)\n                    propagate_costs(c)\n\n        def rewire(tree, sp_hash, new_node, near_nodes_):\n            for near in near_nodes_:\n                if near is new_node.parent:\n                    continue\n                c_edge = dist(new_node.position, near.position)\n                new_c = new_node.cost + c_edge\n                if new_c+1e-10 < near.cost:\n                    if not edge_in_obstacle(new_node.position, near.position):\n                        update_parent(near,new_node,new_c)\n                        propagate_costs(near)\n\n        def extract_path(nstart, ngoal):\n            path_start = nstart.path_from_root()\n            path_goal = ngoal.path_from_root()[::-1]\n            if path_start and path_goal and path_start[-1]==path_goal[0]:\n                path_goal=path_goal[1:]\n            return path_start+path_goal\n\n        def sample_ellipsoid():\n            cmin = dist(start_pos, goal_pos)\n            if best_cost == float('inf') or best_cost <= cmin:\n                while True:\n                    pt = tuple(random.uniform(0,bounds[i]) for i in range(dim))\n                    if not in_obstacle(pt):\n                        return pt\n            center = tuple(0.5*(start_pos[i]+goal_pos[i]) for i in range(dim))\n            direction = [goal_pos[i]-start_pos[i] for i in range(dim)]\n            length = cmin\n            import math\n            if dim==2:\n                if length<1e-12:\n                    R=[[1,0],[0,1]]\n                else:\n                    a1=[1,0]\n                    a2=[direction[0]/length,direction[1]/length]\n                    cos_t = a1[0]*a2[0]+a1[1]*a2[1]\n                    sin_t = a1[0]*a2[1]-a1[1]*a2[0]\n                    R=[[cos_t,-sin_t],[sin_t,cos_t]]\n            else:\n                if length<1e-12:\n                    R=[[1,0,0],[0,1,0],[0,0,1]]\n                else:\n                    a1=[1,0,0]\n                    a2=[direction[i]/length for i in range(3)]\n                    v=[a1[1]*a2[2]-a1[2]*a2[1],a1[2]*a2[0]-a1[0]*a2[2],a1[0]*a2[1]-a1[1]*a2[0]]\n                    s=math.sqrt(sum(vi*vi for vi in v))\n                    c=sum(a1[i]*a2[i] for i in range(3))\n                    if s<1e-12:\n                        R=[[1,0,0],[0,1,0],[0,0,1]]\n                    else:\n                        vx=[[0,-v[2],v[1]],[v[2],0,-v[0]],[-v[1],v[0],0]]\n                        I=[[1 if i==j else 0 for j in range(3)] for i in range(3)]\n                        vx2=[[sum(vx[i][k]*vx[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n                        R=[[I[i][j]+vx[i][j]+vx2[i][j]*((1-c)/(s*s)) for j in range(3)] for i in range(3)]\n            a1v = best_cost*0.5\n            aother=math.sqrt(max(best_cost*best_cost - cmin*cmin,0))*0.5\n            while True:\n                if dim==2:\n                    r = random.uniform(0,1)**0.5\n                    theta = random.uniform(0,2*math.pi)\n                    ball=[r*math.cos(theta), r*math.sin(theta)]\n                    L=[[a1v,0],[0,aother]]\n                    scaled=[L[0][0]*ball[0]+L[0][1]*ball[1],L[1][0]*ball[0]+L[1][1]*ball[1]]\n                    pt=(\n                        center[0]+R[0][0]*scaled[0] + R[0][1]*scaled[1],\n                        center[1]+R[1][0]*scaled[0] + R[1][1]*scaled[1])\n                else:\n                    while True:\n                        ball=[random.uniform(-1,1) for _ in range(3)]\n                        if sum(bi*bi for bi in ball)<=1:\n                            break\n                    L=[[a1v,0,0],[0,aother,0],[0,0,aother]]\n                    scaled=[L[0][0]*ball[0],L[1][1]*ball[1],L[2][2]*ball[2]]\n                    pt=tuple(center[i]+sum(R[i][j]*scaled[j] for j in range(dim)) for i in range(dim))\n                if any(pt[d]<0 or pt[d]>bounds[d] for d in range(dim)): continue\n                if in_obstacle(pt): continue\n                return pt\n\n        def sample():\n            # Hybrid: uniform with probability uniform_sample_rate else informed ellipsoid\n            if random.random() < self.uniform_sample_rate:\n                while True:\n                    pt=tuple(random.uniform(0,bounds[i]) for i in range(dim))\n                    if not in_obstacle(pt):\n                        return pt\n            else:\n                return sample_ellipsoid()\n\n        def shortcut_path(path):\n            if len(path)<3:\n                return path[:]\n            sp=path[:]\n            attempts=0\n            while attempts<self.shortcut_attempts and len(sp)>=3:\n                i=random.randint(0,len(sp)-3)\n                j=random.randint(i+2,len(sp)-1)\n                p1,p2=sp[i],sp[j]\n                if not edge_in_obstacle(p1,p2):\n                    sp=sp[:i+1]+sp[j:]\n                    attempts=0\n                else:\n                    attempts+=1\n            return sp\n\n        best_cost = float('inf')\n        solution_nodes = (None,None)\n        success = False\n\n        for it in range(self.max_iter):\n            for (tree_a, tree_b, sp_a, sp_b) in [\n                (start_tree, goal_tree, start_hash, goal_hash),\n                (goal_tree, start_tree, goal_hash, start_hash)\n            ]:\n                s = sample()\n                nearest_node = nearest(tree_a, sp_a, s)\n                new_pos = steer(nearest_node.position, s)\n                if any(new_pos[d]<0 or new_pos[d]>bounds[d] for d in range(dim)):\n                    continue\n                if in_obstacle(new_pos):\n                    continue\n                if edge_in_obstacle(nearest_node.position, new_pos):\n                    continue\n\n                radius = adaptive_radius(len(tree_a))\n                near_nds = near_nodes(tree_a, sp_a, new_pos,radius)\n\n                min_cost = nearest_node.cost + dist(nearest_node.position,new_pos)\n                min_parent = nearest_node\n                for nd in near_nds:\n                    cnew = nd.cost + dist(nd.position,new_pos)\n                    if cnew+1e-10 < min_cost and not edge_in_obstacle(nd.position,new_pos):\n                        min_cost = cnew\n                        min_parent = nd\n\n                new_node = Node(new_pos, min_parent, min_cost)\n                min_parent.add_child(new_node)\n                tree_a.append(new_node)\n                sp_a.insert(new_node)\n                nodes.append(new_node)\n                edges.append((min_parent,new_node))\n\n                rewire(tree_a, sp_a, new_node, near_nds)\n\n                nearest_other = nearest(tree_b, sp_b, new_node.position)\n                dist_other = dist(new_node.position, nearest_other.position)\n                radius_connect = max(self.step_size*1.7, adaptive_radius(len(tree_b)))\n                if dist_other <= radius_connect and not edge_in_obstacle(new_node.position,nearest_other.position):\n                    success = True\n                    sol_a, sol_b = (new_node, nearest_other) if tree_a is start_tree else (nearest_other, new_node)\n                    cost_sol = sol_a.cost + dist(sol_a.position, sol_b.position) + sol_b.cost\n                    if cost_sol < best_cost:\n                        best_cost = cost_sol\n                        solution_nodes = (sol_a, sol_b)\n\n            if success and (it % self.shortcut_freq == 0 or it == self.max_iter-1):\n                raw_path = extract_path(solution_nodes[0], solution_nodes[1])\n                improved = shortcut_path(raw_path)\n                if improved and len(improved)>=2:\n                    return PlannerResult(True, improved, nodes, edges)\n\n        if success:\n            raw_path = extract_path(solution_nodes[0], solution_nodes[1])\n            spath = shortcut_path(raw_path)\n            return PlannerResult(True, spath, nodes, edges)\n        else:\n            return PlannerResult(False, [], nodes, edges)",
                "objective": -33.09238,
                "time_improvement": 52.0,
                "length_improvement": 14.0,
                "smoothness_improvement": 1754.0,
                "node_improvement": 69.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.02086801528930664,
                        "num_nodes_avg": 141.1,
                        "path_length_avg": 176.73406725664424,
                        "smoothness_avg": 0.04445659950667667,
                        "success_improvement": 0.0,
                        "time_improvement": 19.08740045019852,
                        "node_improvement": 64.46738856711156,
                        "length_improvement": 3.1292572061234356,
                        "smoothness_improvement": 595.8423213304796,
                        "objective_score": 10.582986065386015
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.02599599361419678,
                        "num_nodes_avg": 287.2,
                        "path_length_avg": 235.22783327009248,
                        "smoothness_avg": 0.13236911125780718,
                        "success_improvement": 0.0,
                        "time_improvement": 84.29963189449063,
                        "node_improvement": 80.70281529261574,
                        "length_improvement": 21.474178596671763,
                        "smoothness_improvement": 3305.9525742804803,
                        "objective_score": 54.70415959775265
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.023821187019348145,
                        "num_nodes_avg": 304.0,
                        "path_length_avg": 122.2732514001819,
                        "smoothness_avg": 0.114735114088279,
                        "success_improvement": 0.0,
                        "time_improvement": 53.05909209858064,
                        "node_improvement": 61.34774316592498,
                        "length_improvement": 18.791928446547164,
                        "smoothness_improvement": 1359.422182337728,
                        "objective_score": 33.989995609191126
                    }
                ],
                "success_rate": 1.0
            },
            {
                "operator": "e2",
                "algorithm_description": "A bidirectional RRT* inspired planner with progressive informed sampling focused inside an adaptive ellipsoidal bound, multi-scale rewiring including multi-hop shortcutting beyond grandparents, curvature-aware selective shortcutting, and curvature penalty integrated during rewiring to enhance smoothness. The algorithm dynamically adjusts goal bias and rewiring radius for balance between exploration and exploitation. It merges both trees carefully with collision checks and returns a path optimized for length and smoothness via repeated topology improvements with geometric and curvature-based heuristics.",
                "planning_mechanism": "A planner that alternates extending start and goal trees toward samples drawn mostly from an ellipsoidal informed set based on the current best path cost, adaptively rewiring neighbors with cost and curvature awareness to improve path quality. A multi-hop incremental shortcutting rewires tree edges considering parents, grandparents, and great-grandparents when collision-free to reduce unnecessary nodes and smooth turns. Curvature measures bias rewiring and shortcut selection to reduce sharp angles. It balances goal bias decay and step sizes, integrates efficient spatial hashing for neighbor queries, and applies a geometry-curvature-driven post-processing shortcutting before returning the final path.",
                "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except ValueError:\n            pass\n    def path_from_root(self):\n        node, path = self, []\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=3000, step_size=7.0, base_radius=28.0,\n                 goal_sample_rate=0.18, min_goal_sample_rate=0.06,\n                 goal_sample_decay=0.997, spatial_hash_cell=14.0,\n                 shortcut_iters=100):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.base_radius = base_radius\n        self.goal_sample_rate = goal_sample_rate\n        self.min_goal_sample_rate = min_goal_sample_rate\n        self.goal_sample_decay = goal_sample_decay\n        self.spatial_hash_cell = spatial_hash_cell\n        self.shortcut_iters = shortcut_iters\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def dist(a, b):\n            return math.dist(a, b)\n        def dist_sq(a, b):\n            s = 0.0\n            for i in range(dim):\n                d = a[i] - b[i]\n                s += d*d\n            return s\n\n        def steer(fr, to):\n            d = dist(fr, to)\n            if d <= self.step_size:\n                return to\n            ratio = self.step_size / d\n            return tuple(fr[i] + (to[i] - fr[i]) * ratio for i in range(dim))\n\n        def in_bounds(p):\n            for i in range(dim):\n                if p[i] < 0 or p[i] > bounds[i]:\n                    return False\n            return True\n\n        def is_in_obstacle(p):\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d_ = obs\n                    if x <= p[0] <= x+w and y <= p[1] <= y+h and z <= p[2] <= z+d_:\n                        return True\n                else:\n                    x,y,w,h = obs\n                    if x <= p[0] <= x+w and y <= p[1] <= y+h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(fr, to):\n            d = dist(fr, to)\n            resolution = min(1.0, self.step_size/3.0)\n            steps = max(1, int(d / resolution))\n            for i in range(steps + 1):\n                interp = tuple(fr[j] + (to[j]-fr[j]) * i/steps for j in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        class SpatialHash:\n            def __init__(self, cell_size):\n                self.cell_size = cell_size\n                self.cells = {}\n            def _hash_key(self, point):\n                return tuple(int(coord//self.cell_size) for coord in point)\n            def insert(self, node):\n                key = self._hash_key(node.position)\n                if key not in self.cells:\n                    self.cells[key] = []\n                self.cells[key].append(node)\n            def neighbors(self, point, radius):\n                r_cell = int(math.ceil(radius / self.cell_size))\n                base_key = self._hash_key(point)\n                result = []\n                rng = range(-r_cell, r_cell+1)\n                if dim == 2:\n                    for dx in rng:\n                        for dy in rng:\n                            key = (base_key[0]+dx, base_key[1]+dy)\n                            if key in self.cells:\n                                result.extend(self.cells[key])\n                else:\n                    for dx in rng:\n                        for dy in rng:\n                            for dz in rng:\n                                key = (base_key[0]+dx, base_key[1]+dy, base_key[2]+dz)\n                                if key in self.cells:\n                                    result.extend(self.cells[key])\n                return result\n\n        def adaptive_radius(n):\n            n = max(n,2)\n            gamma = self.base_radius\n            r = gamma * (math.log(n)/n)**(1.0/dim)\n            return max(r, self.step_size * 2.0)\n\n        def nearest(tree, spatial_hash, point):\n            candidates = spatial_hash.neighbors(point, self.step_size*4)\n            if not candidates:\n                return min(tree, key=lambda node: dist(node.position, point))\n            return min(candidates, key=lambda node: dist(node.position, point))\n\n        def near_nodes(tree, spatial_hash, point, radius):\n            r2 = radius*radius\n            candidates = spatial_hash.neighbors(point, radius)\n            result = []\n            for node in candidates:\n                if dist_sq(node.position, point) <= r2:\n                    result.append(node)\n            return result\n\n        # Curvature helper:\n        def angle_between_vectors(a, b):\n            dot = sum(ai*bi for ai,bi in zip(a,b))\n            norm_a = math.sqrt(sum(ai*ai for ai in a))\n            norm_b = math.sqrt(sum(bi*bi for bi in b))\n            if norm_a < 1e-10 or norm_b < 1e-10:\n                return 0.0\n            val = dot / (norm_a * norm_b)\n            val = max(min(val,1.0), -1.0)\n            return math.acos(val)  # radians, 0 is straight line\n\n        def compute_curvature(prev_p, p, next_p):\n            # Measure angle at p formed by prev_p->p->next_p, smaller better (0 means straight)\n            if prev_p is None or next_p is None:\n                return 0.0\n            v1 = tuple(p[i]-prev_p[i] for i in range(dim))\n            v2 = tuple(next_p[i]-p[i] for i in range(dim))\n            return angle_between_vectors(v1, v2)\n\n        def extract_path(node_start, node_goal):\n            path_start = node_start.path_from_root()\n            path_goal = node_goal.path_from_root()[::-1]\n            if path_start and path_goal and path_start[-1] == path_goal[0]:\n                path_goal = path_goal[1:]\n            return path_start + path_goal\n\n        def ellipse_sample(start, goal, c_max):\n            if c_max == float('inf'):\n                while True:\n                    sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not is_in_obstacle(sample): return sample\n            center = tuple((start[i] + goal[i]) * 0.5 for i in range(dim))\n            diff = tuple(goal[i]-start[i] for i in range(dim))\n            dist_sg = dist(start, goal)\n            if dist_sg < 1e-10:\n                while True:\n                    sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not is_in_obstacle(sample): return sample\n            if dim == 2:\n                import math\n                unit_vec = tuple(diff[i]/dist_sg for i in range(dim))\n                angle = math.atan2(unit_vec[1], unit_vec[0])\n                a = c_max * 0.5\n                b = math.sqrt(max(c_max*c_max - dist_sg*dist_sg, 0.0)) * 0.5\n                for _ in range(20):\n                    r = random.uniform(0,1)**0.5\n                    theta = random.uniform(0, 2*math.pi)\n                    x = r * a * math.cos(theta)\n                    y = r * b * math.sin(theta)\n                    # rotate back by angle\n                    px = center[0] + x * math.cos(angle) - y * math.sin(angle)\n                    py = center[1] + x * math.sin(angle) + y * math.cos(angle)\n                    sample = (px, py)\n                    if in_bounds(sample) and not is_in_obstacle(sample):\n                        return sample\n                # fallback\n                while True:\n                    sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not is_in_obstacle(sample): return sample\n            else:\n                # 3D: simpler axis-aligned ellipsoid\n                import math\n                a = c_max * 0.5\n                b = math.sqrt(max(c_max*c_max - dist_sg*dist_sg, 0.0)) * 0.5\n                rx, ry, rz = a, b*0.8, b*0.5\n                for _ in range(30):\n                    x = random.uniform(-rx, rx)\n                    y = random.uniform(-ry, ry)\n                    z = random.uniform(-rz, rz)\n                    sample = (center[0]+x, center[1]+y, center[2]+z)\n                    if in_bounds(sample) and not is_in_obstacle(sample):\n                        return sample\n                while True:\n                    sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not is_in_obstacle(sample): return sample\n\n        def multi_hop_shortcut(node):\n            # Try multi-hop shortcut rewiring up to great-grandparent if possible\n            # Attempt rewiring node directly to ancestors further than parent if collision free and reduces cost + curvature\n            improved = False\n            ancestors = []\n            p = node.parent\n            while p and len(ancestors) < 3:  # parent, grandparent, great-grandparent\n                ancestors.append(p)\n                p = p.parent\n            for anc in ancestors:\n                if anc is None or anc == node:\n                    continue\n                if is_edge_in_obstacle(anc.position, node.position):\n                    continue\n                d = dist(anc.position, node.position)\n                new_cost = anc.cost + d\n                # Compute curvature penalty: angle at node if rewired this way\n                pprev = anc.parent.position if anc.parent else None\n                c_old = 0.0\n                # old curvature at node before rewiring\n                if node.parent and node.parent.parent:\n                    c_old = compute_curvature(node.parent.parent.position, node.parent.position, node.position)\n                c_new = compute_curvature(pprev, anc.position, node.position) if pprev else 0.0\n                # Use curvature as penalty\n                penalty = c_new * self.step_size  # weight curvature penalty proportional to step size\n                if new_cost + penalty + 1e-8 < node.cost + c_old * self.step_size:\n                    # Rewire: cut old parent-child edge\n                    if node.parent:\n                        node.parent.remove_child(node)\n                    node.parent = anc\n                    node.cost = new_cost\n                    anc.add_child(node)\n                    improved = True\n                    break\n            return improved\n\n        def curvature_weighted_rewire(new_node, neighbors):\n            # Try rewiring neighbors through new_node considering cost + curvature penalty to reduce sharp turns\n            for n in neighbors:\n                if n is new_node or n.parent is None:\n                    continue\n                # Skip if no parent\n                dist_to_n = dist(new_node.position, n.position)\n                new_cost = new_node.cost + dist_to_n\n                # Curvature penalty before rewiring\n                old_curv = 0.0\n                if n.parent and n.parent.parent:\n                    old_curv = compute_curvature(n.parent.parent.position, n.parent.position, n.position)\n                # Curvature penalty if rewired via new_node instead\n                def next_child_pos(nn):\n                    return nn.children[0].position if nn.children else None\n                nnext = next_child_pos(new_node)\n                new_curv = compute_curvature(new_node.parent.position if new_node.parent else None,\n                                            new_node.position,\n                                            n.position) if new_node.parent else 0.0\n                penalty_new = new_curv * self.step_size\n                penalty_old = old_curv * self.step_size\n\n                if new_cost + penalty_new + 1e-8 < n.cost + penalty_old:\n                    if not is_edge_in_obstacle(new_node.position, n.position):\n                        # Rewire n\n                        if n.parent:\n                            n.parent.remove_child(n)\n                        n.parent = new_node\n                        n.cost = new_cost\n                        new_node.add_child(n)\n\n        start_tree = [Node(start_pos, None, 0.0)]\n        goal_tree = [Node(goal_pos, None, 0.0)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        start_hash = SpatialHash(self.spatial_hash_cell)\n        goal_hash = SpatialHash(self.spatial_hash_cell)\n        start_hash.insert(start_tree[0])\n        goal_hash.insert(goal_tree[0])\n\n        best_cost = float('inf')\n        conn_start = None\n        conn_goal = None\n        success = False\n\n        def get_goal_sample_rate(it):\n            rate = self.goal_sample_rate*(self.goal_sample_decay**it)\n            return max(rate, self.min_goal_sample_rate)\n\n        for it in range(self.max_iter):\n            for tree_a, tree_b, hash_a, hash_b in [(start_tree, goal_tree, start_hash, goal_hash),(goal_tree, start_tree, goal_hash, start_hash)]:\n                c_max = best_cost if best_cost < float('inf') else float('inf')\n\n                # Sampling: goal bias decaying, else elliptical informed\n                if random.random() < get_goal_sample_rate(it):\n                    sample_pt = goal_pos\n                    if is_in_obstacle(sample_pt):  # fallback if goal blocked\n                        while True:\n                            sample_pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                            if not is_in_obstacle(sample_pt): break\n                else:\n                    sample_pt = ellipse_sample(start_pos, goal_pos, c_max)\n\n                nearest_node = nearest(tree_a, hash_a, sample_pt)\n                new_pos = steer(nearest_node.position, sample_pt)\n                if not in_bounds(new_pos):\n                    continue\n                if is_in_obstacle(new_pos):\n                    continue\n                if is_edge_in_obstacle(nearest_node.position, new_pos):\n                    continue\n\n                radius = adaptive_radius(len(tree_a))\n                near = near_nodes(tree_a, hash_a, new_pos, radius)\n\n                # Choose best parent with curvature penalty consideration\n                min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n                min_parent = nearest_node\n                for node in near:\n                    if node == nearest_node:\n                        continue\n                    cand_cost = node.cost + dist(node.position, new_pos)\n                    if cand_cost + 1e-7 < min_cost:\n                        # curvature penalty if from node to new_pos\n                        pprev = node.parent.position if node.parent else None\n                        c_penalty = 0.0\n                        if pprev:\n                            c_penalty = compute_curvature(pprev, node.position, new_pos) * self.step_size\n                        else:\n                            c_penalty = 0.0\n                        if c_penalty < math.pi/2.2:  # discard sharp turns ( > ~81 deg)\n                            if not is_edge_in_obstacle(node.position, new_pos):\n                                min_cost = cand_cost\n                                min_parent = node\n\n                new_node = Node(new_pos, min_parent, min_cost)\n                min_parent.add_child(new_node)\n                tree_a.append(new_node)\n                hash_a.insert(new_node)\n                nodes.append(new_node)\n                edges.append((min_parent, new_node))\n\n                # Rewire neighbors including curvature penalty\n                curvature_weighted_rewire(new_node, near)\n\n                # Multi-hop incremental shortcutting beyond parent-grandparent\n                multi_hop_shortcut(new_node)\n\n                # Attempt connection to other tree\n                nearest_other = nearest(tree_b, hash_b, new_node.position)\n                dist_to_other = dist(new_node.position, nearest_other.position)\n                radius_conn = max(self.step_size * 2.8, adaptive_radius(len(tree_b)))\n                if dist_to_other <= radius_conn:\n                    if not is_edge_in_obstacle(new_node.position, nearest_other.position):\n                        total_cost = new_node.cost + dist(new_node.position, nearest_other.position) + nearest_other.cost\n                        if total_cost + 1e-7 < best_cost:\n                            best_cost = total_cost\n                            if tree_a is start_tree:\n                                conn_start, conn_goal = new_node, nearest_other\n                            else:\n                                conn_start, conn_goal = nearest_other, new_node\n                            success = True\n\n            if success:\n                break\n\n        def curvature_guided_shortcut(path):\n            # Apply repeated geometry + curvature guided shortcutting\n            if len(path) < 3:\n                return path[:]\n            p = path[:]\n            for _ in range(self.shortcut_iters):\n                if len(p) < 3: break\n                i = random.randint(0, len(p)-3)\n                j = random.randint(i+2, len(p)-1)\n                if dist(p[i], p[j]) > self.step_size * 3.5:\n                    # curvature test: angle at intermediate points > 0.4 rad (~23 deg)\n                    intermediate_angles = []\n                    for k in range(i+1, j):\n                        prevpt = p[k-1]\n                        cpt = p[k]\n                        nextpt = p[k+1] if k+1 <= j else None\n                        if nextpt is None: continue\n                        a = compute_curvature(prevpt, cpt, nextpt)\n                        intermediate_angles.append(a)\n                    if any(a > 0.35 for a in intermediate_angles):\n                        if not is_edge_in_obstacle(p[i], p[j]):\n                            p = p[:i+1] + p[j:]\n            # Remove nearly collinear points\n            def is_collinear(p1,p2,p3,tol=1e-3):\n                if dim == 2:\n                    area = abs(p1[0]*(p2[1]-p3[1]) + p2[0]*(p3[1]-p1[1]) + p3[0]*(p1[1]-p2[1])) / 2.0\n                    base = dist(p1,p3)\n                    height = 2*area/base if base > 1e-12 else 0\n                    return height < tol\n                else:\n                    # 3D cross product magnitude / base length\n                    a = tuple(p2[i]-p1[i] for i in range(dim))\n                    b = tuple(p3[i]-p1[i] for i in range(dim))\n                    cross = (a[1]*b[2]-a[2]*b[1], a[2]*b[0]-a[0]*b[2], a[0]*b[1]-a[1]*b[0])\n                    area = math.sqrt(cross[0]**2 + cross[1]**2 + cross[2]**2) / 2.0\n                    base = dist(p1,p3)\n                    height = 2*area/base if base > 1e-12 else 0\n                    return height < tol\n            i = 1\n            while i < len(p)-1:\n                if is_collinear(p[i-1], p[i], p[i+1]):\n                    p.pop(i)\n                else:\n                    i += 1\n            return p\n\n        path = []\n        if success and conn_start and conn_goal:\n            raw_path = extract_path(conn_start, conn_goal)\n            refined_path = curvature_guided_shortcut(raw_path)\n            path = refined_path\n\n        return PlannerResult(success, path, nodes, edges)",
                "objective": -21.50862,
                "time_improvement": 32.0,
                "length_improvement": 12.0,
                "smoothness_improvement": 937.0,
                "node_improvement": 77.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.027835845947265625,
                        "num_nodes_avg": 110.1,
                        "path_length_avg": 179.16237636079404,
                        "smoothness_avg": 0.03089977120316694,
                        "success_improvement": 0.0,
                        "time_improvement": -7.929317907639971,
                        "node_improvement": 72.27398640141021,
                        "length_improvement": 1.7982625071187874,
                        "smoothness_improvement": 383.6485192567019,
                        "objective_score": 0.6184047282627907
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.03268866539001465,
                        "num_nodes_avg": 204.1,
                        "path_length_avg": 238.72492729689355,
                        "smoothness_avg": 0.07009040927685109,
                        "success_improvement": 0.0,
                        "time_improvement": 80.25757018109225,
                        "node_improvement": 86.28636699590136,
                        "length_improvement": 20.30674795225515,
                        "smoothness_improvement": 1703.4767147745988,
                        "objective_score": 44.77870339955376
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.038587307929992674,
                        "num_nodes_avg": 224.5,
                        "path_length_avg": 129.69236337995875,
                        "smoothness_avg": 0.06480474152473614,
                        "success_improvement": 0.0,
                        "time_improvement": 23.961670498019494,
                        "node_improvement": 71.45581691036237,
                        "length_improvement": 13.864507529727572,
                        "smoothness_improvement": 724.3115288061979,
                        "objective_score": 19.12876331127338
                    }
                ],
                "success_rate": 1.0
            }
        ],
        "offspring": {
            "operator": "m3",
            "algorithm_description": "A streamlined bidirectional RRT* planner that combines adaptive ellipsoidal informed sampling focused around the current best path with dynamic rewiring considering cost and curvature penalties to reduce sharp turns. It employs efficient spatial hashing for neighbor queries, a balanced growth strategy alternating start and goal trees, and incremental path shortcutting applied periodically during planning to improve path smoothness and length. The algorithm maintains path quality and robustness while reducing planning time by concentrating search in promising regions and refining the tree topology incrementally.",
            "planning_mechanism": "The planner grows two trees from start and goal positions alternately. It samples points predominantly within an adaptive ellipsoidal region defined by the best current solution to focus exploration. New nodes are connected using cost and curvature-aware rewiring to encourage smooth local paths. Spatial hashing accelerates nearest and near neighbor searches. Periodic incremental shortcutting reduces unnecessary nodes and sharp turns in the evolving best path. Finally, the planner returns a refined, collision-free path optimized in length and smoothness within the iteration budget.",
            "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except ValueError:\n            pass\n\n    def path_from_root(self):\n        path, node = [], self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=3000, step_size=6.0, base_radius=25.0,\n                 goal_sample_rate=0.15, min_goal_sample_rate=0.05,\n                 goal_sample_decay=0.995, spatial_hash_cell=15.0,\n                 shortcut_freq=40, shortcut_attempts=30):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.base_radius = base_radius\n        self.goal_sample_rate = goal_sample_rate\n        self.min_goal_sample_rate = min_goal_sample_rate\n        self.goal_sample_decay = goal_sample_decay\n        self.spatial_hash_cell = spatial_hash_cell\n        self.shortcut_freq = shortcut_freq\n        self.shortcut_attempts = shortcut_attempts\n\n    def plan(self, map):\n        import math, random\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def dist_sq(a, b):\n            s = 0.0\n            for i in range(dim):\n                d = a[i]-b[i]\n                s += d * d\n            return s\n\n        def in_bounds(p):\n            for i in range(dim):\n                if p[i] < 0 or p[i] > bounds[i]:\n                    return False\n            return True\n\n        def is_in_obstacle(p):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d_ = obs\n                    if x <= p[0] <= x + w and y <= p[1] <= y + h and z <= p[2] <= z + d_:\n                        return True\n                else:\n                    x, y, w_, h_ = obs\n                    if x <= p[0] <= x + w_ and y <= p[1] <= y + h_:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(fr, to):\n            d = dist(fr, to)\n            resolution = min(1.0, self.step_size / 3.5)\n            steps = max(1, int(d / resolution))\n            for i in range(steps + 1):\n                interp = tuple(fr[j] + (to[j]-fr[j]) * i / steps for j in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def steer(fr, to):\n            d = dist(fr, to)\n            if d <= self.step_size:\n                return to\n            ratio = self.step_size / d\n            return tuple(fr[i] + (to[i]-fr[i]) * ratio for i in range(dim))\n\n        class SpatialHash:\n            def __init__(self, cell_size):\n                self.cell_size = cell_size\n                self.cells = {}\n\n            def _hash_key(self, point):\n                return tuple(int(coord // self.cell_size) for coord in point)\n\n            def insert(self, node):\n                key = self._hash_key(node.position)\n                self.cells.setdefault(key, []).append(node)\n\n            def neighbors(self, point, radius):\n                r_cell = int(math.ceil(radius / self.cell_size))\n                base_key = self._hash_key(point)\n                result = []\n                rng = range(-r_cell, r_cell + 1)\n                if dim == 2:\n                    for dx in rng:\n                        for dy in rng:\n                            key = (base_key[0] + dx, base_key[1] + dy)\n                            if key in self.cells:\n                                result.extend(self.cells[key])\n                else:\n                    for dx in rng:\n                        for dy in rng:\n                            for dz in rng:\n                                key = (base_key[0] + dx, base_key[1] + dy, base_key[2] + dz)\n                                if key in self.cells:\n                                    result.extend(self.cells[key])\n                return result\n\n        def adaptive_radius(n):\n            n = max(n, 2)\n            r = self.base_radius * (math.log(n) / n)**(1.0 / dim)\n            return max(r, self.step_size * 1.8)\n\n        def nearest(tree, sp_hash, point):\n            candidates = sp_hash.neighbors(point, self.step_size * 4)\n            if candidates:\n                return min(candidates, key=lambda node: dist(node.position, point))\n            return min(tree, key=lambda node: dist(node.position, point))\n\n        def near_nodes(tree, sp_hash, point, radius):\n            r2 = radius * radius\n            candidates = sp_hash.neighbors(point, radius)\n            return [n for n in candidates if dist_sq(n.position, point) <= r2]\n\n        def angle_between_vectors(a, b):\n            dot = sum(ai * bi for ai, bi in zip(a, b))\n            norm_a = math.sqrt(sum(ai * ai for ai in a))\n            norm_b = math.sqrt(sum(bi * bi for bi in b))\n            if norm_a < 1e-10 or norm_b < 1e-10:\n                return 0.0\n            val = max(min(dot / (norm_a * norm_b), 1.0), -1.0)\n            return math.acos(val)\n\n        def compute_curvature(prev_p, p, next_p):\n            if prev_p is None or next_p is None:\n                return 0.0\n            v1 = tuple(p[i] - prev_p[i] for i in range(dim))\n            v2 = tuple(next_p[i] - p[i] for i in range(dim))\n            return angle_between_vectors(v1, v2)\n\n        def update_parent(child, new_parent, new_cost):\n            if child.parent is not None:\n                child.parent.remove_child(child)\n                try:\n                    edges.remove((child.parent, child))\n                except Exception:\n                    pass\n            child.parent = new_parent\n            child.cost = new_cost\n            new_parent.add_child(child)\n            edges.append((new_parent, child))\n\n        def propagate_costs(node):\n            for c in node.children:\n                new_cost = node.cost + dist(node.position, c.position)\n                if new_cost + 1e-10 < c.cost:\n                    update_parent(c, node, new_cost)\n                    propagate_costs(c)\n\n        def rewire(new_node, near_list):\n            for neighbor in near_list:\n                if neighbor is new_node.parent:\n                    continue\n                d = dist(new_node.position, neighbor.position)\n                new_cost = new_node.cost + d\n                if new_cost + 1e-10 < neighbor.cost:\n                    # Compute curvature penalty to encourage smooth turns\n                    prev_pos = new_node.parent.position if new_node.parent else None\n                    curvature = compute_curvature(prev_pos, new_node.position, neighbor.position)\n                    if curvature < math.pi / 2:  # discard sharp turns (>90 deg)\n                        if not is_edge_in_obstacle(new_node.position, neighbor.position):\n                            update_parent(neighbor, new_node, new_cost)\n                            propagate_costs(neighbor)\n\n        def extract_path(node_start, node_goal):\n            path_start = node_start.path_from_root()\n            path_goal = node_goal.path_from_root()[::-1]\n            if path_start and path_goal and path_start[-1] == path_goal[0]:\n                path_goal = path_goal[1:]\n            return path_start + path_goal\n\n        def ellipsoid_sample(start, goal, c_best):\n            if c_best == float('inf'):\n                while True:\n                    pt = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                    if not is_in_obstacle(pt):\n                        return pt\n            center = tuple(0.5 * (start[i] + goal[i]) for i in range(dim))\n            diff = tuple(goal[i] - start[i] for i in range(dim))\n            dist_sg = dist(start, goal)\n            import math\n\n            if dist_sg < 1e-10:\n                while True:\n                    pt = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                    if not is_in_obstacle(pt):\n                        return pt\n\n            if dim == 2:\n                unit_vec = tuple(diff[i] / dist_sg for i in range(2))\n                angle = math.atan2(unit_vec[1], unit_vec[0])\n                a = c_best * 0.5\n                b = math.sqrt(max(c_best * c_best - dist_sg * dist_sg, 0.0)) * 0.5\n\n                for _ in range(20):\n                    r = random.uniform(0, 1) ** 0.5\n                    theta = random.uniform(0, 2 * math.pi)\n                    x = r * a * math.cos(theta)\n                    y = r * b * math.sin(theta)\n                    px = center[0] + x * math.cos(angle) - y * math.sin(angle)\n                    py = center[1] + x * math.sin(angle) + y * math.cos(angle)\n                    pt = (px, py)\n                    if in_bounds(pt) and not is_in_obstacle(pt):\n                        return pt\n\n                # fallback uniform sample\n                while True:\n                    pt = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                    if not is_in_obstacle(pt):\n                        return pt\n            else:\n                a = c_best * 0.5\n                b = math.sqrt(max(c_best * c_best - dist_sg * dist_sg, 0.0)) * 0.5\n                rx, ry, rz = a, b * 0.85, b * 0.6\n                for _ in range(30):\n                    x = random.uniform(-rx, rx)\n                    y = random.uniform(-ry, ry)\n                    z = random.uniform(-rz, rz)\n                    pt = (center[0] + x, center[1] + y, center[2] + z)\n                    if in_bounds(pt) and not is_in_obstacle(pt):\n                        return pt\n                # fallback uniform sample\n                while True:\n                    pt = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                    if not is_in_obstacle(pt):\n                        return pt\n\n        def sample(it, c_best):\n            # Mix goal bias with decay and ellipsoid sampling\n            goal_bias_prob = max(self.min_goal_sample_rate,\n                                 self.goal_sample_rate * (self.goal_sample_decay ** it))\n            r = random.random()\n            if r < goal_bias_prob:\n                if not is_in_obstacle(goal_pos):\n                    return goal_pos\n            return ellipsoid_sample(start_pos, goal_pos, c_best)\n\n        def path_shortcut(path):\n            if len(path) < 3:\n                return path[:]\n            sp = path[:]\n            attempts = 0\n            while attempts < self.shortcut_attempts and len(sp) >= 3:\n                i = random.randint(0, len(sp) - 3)\n                j = random.randint(i + 2, len(sp) - 1)\n                p1, p2 = sp[i], sp[j]\n                if not is_edge_in_obstacle(p1, p2):\n                    sp = sp[:i + 1] + sp[j:]\n                    attempts = 0\n                else:\n                    attempts += 1\n            return sp\n\n        start_tree = [Node(start_pos, None, 0.0)]\n        goal_tree = [Node(goal_pos, None, 0.0)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        start_hash = SpatialHash(self.spatial_hash_cell)\n        goal_hash = SpatialHash(self.spatial_hash_cell)\n        start_hash.insert(start_tree[0])\n        goal_hash.insert(goal_tree[0])\n\n        best_cost = float('inf')\n        solution_nodes = (None, None)\n        success = False\n\n        for it in range(self.max_iter):\n            for tree_a, tree_b, hash_a, hash_b in [(start_tree, goal_tree, start_hash, goal_hash),\n                                                   (goal_tree, start_tree, goal_hash, start_hash)]:\n                c_best = best_cost if best_cost < float('inf') else float('inf')\n                sample_pt = sample(it, c_best)\n\n                nearest_node = nearest(tree_a, hash_a, sample_pt)\n                new_pos = steer(nearest_node.position, sample_pt)\n                if not in_bounds(new_pos) or is_in_obstacle(new_pos):\n                    continue\n                if is_edge_in_obstacle(nearest_node.position, new_pos):\n                    continue\n\n                radius = adaptive_radius(len(tree_a))\n                near = near_nodes(tree_a, hash_a, new_pos, radius)\n\n                min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n                min_parent = nearest_node\n                for candidate in near:\n                    if candidate is nearest_node:\n                        continue\n                    cand_cost = candidate.cost + dist(candidate.position, new_pos)\n                    if cand_cost + 1e-8 < min_cost:\n                        if not is_edge_in_obstacle(candidate.position, new_pos):\n                            min_cost = cand_cost\n                            min_parent = candidate\n\n                new_node = Node(new_pos, min_parent, min_cost)\n                min_parent.add_child(new_node)\n                tree_a.append(new_node)\n                hash_a.insert(new_node)\n                nodes.append(new_node)\n                edges.append((min_parent, new_node))\n\n                rewire(new_node, near)\n\n                # Attempt connection to other tree\n                nearest_other = nearest(tree_b, hash_b, new_node.position)\n                dist_to_other = dist(new_node.position, nearest_other.position)\n                radius_conn = max(self.step_size * 2.0, adaptive_radius(len(tree_b)))\n                if dist_to_other <= radius_conn:\n                    if not is_edge_in_obstacle(new_node.position, nearest_other.position):\n                        total_cost = (new_node.cost + dist(new_node.position, nearest_other.position)\n                                      + nearest_other.cost)\n                        if total_cost + 1e-8 < best_cost:\n                            best_cost = total_cost\n                            success = True\n                            if tree_a is start_tree:\n                                solution_nodes = (new_node, nearest_other)\n                            else:\n                                solution_nodes = (nearest_other, new_node)\n\n            # Periodic incremental path shortcutting to improve smoothness during iterations\n            if success and (it % self.shortcut_freq == 0 or it == self.max_iter - 1):\n                raw_path = extract_path(solution_nodes[0], solution_nodes[1])\n                improved_path = path_shortcut(raw_path)\n                if improved_path and len(improved_path) >= 2:\n                    # update solution_nodes by locating nodes closest to path ends in start and goal trees\n                    # to maintain consistent future extensions if needed\n                    return PlannerResult(True, improved_path, nodes, edges)\n\n        if success:\n            raw_path = extract_path(solution_nodes[0], solution_nodes[1])\n            refined_path = path_shortcut(raw_path)\n            return PlannerResult(True, refined_path, nodes, edges)\n        else:\n            return PlannerResult(False, [], nodes, edges)",
            "objective": -34.17849,
            "time_improvement": 60.0,
            "length_improvement": 16.0,
            "smoothness_improvement": 1299.0,
            "node_improvement": 75.0,
            "other_inf": [
                {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.017295455932617186,
                    "num_nodes_avg": 122.6,
                    "path_length_avg": 171.23147367354323,
                    "smoothness_avg": 0.03716410189314488,
                    "success_improvement": 0.0,
                    "time_improvement": 32.93946355194617,
                    "node_improvement": 69.12616469403173,
                    "length_improvement": 6.145315943196231,
                    "smoothness_improvement": 481.6988977666769,
                    "objective_score": 15.977523120334972
                },
                {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.023405694961547853,
                    "num_nodes_avg": 257.3,
                    "path_length_avg": 231.5156418202283,
                    "smoothness_avg": 0.09148380904569924,
                    "success_improvement": 0.0,
                    "time_improvement": 85.86405151058038,
                    "node_improvement": 82.71181885372573,
                    "length_improvement": 22.71341495214288,
                    "smoothness_improvement": 2253.944299870077,
                    "objective_score": 50.656985923810225
                },
                {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.019008278846740723,
                    "num_nodes_avg": 221.5,
                    "path_length_avg": 122.14401225675431,
                    "smoothness_avg": 0.09923558831299088,
                    "success_improvement": 0.0,
                    "time_improvement": 62.54318200076956,
                    "node_improvement": 71.83725365543548,
                    "length_improvement": 18.877762931905092,
                    "smoothness_improvement": 1162.2693585320496,
                    "objective_score": 35.90095915203417
                }
            ],
            "success_rate": 1.0
        },
        "objective": 32.8,
        "analysis": {
            "problem": [
                "Problem of the parents algorithm:\n   - Inefficient exploration strategies with fixed or less adaptive sampling leading to slow convergence and excessive planning time.\n   - Limited or greedy rewiring approaches that either omit smoothness considerations or entail computationally heavy curvature checks causing overhead.\n   - Post-processing shortcutting applied too infrequently or only after full planning, limiting incremental path quality improvements.\n   - Some methods use potentially costly multi-hop rewiring or complex curvature penalties increasing per-iteration computational load.\n   - Spatial data structures sometimes not optimally tuned for neighbor queries, affecting performance under high node counts."
            ],
            "solution": "1. Primary contributors to the performance improvement:\n   - Balanced bidirectional tree growth with adaptive ellipsoidal informed sampling focused on promising regions for faster convergence.\n   - Efficient rewiring adopting cost and curvature constraints with simplified and timely updates minimizing overhead.\n   - Periodic incremental path shortcutting during planning to steadily improve path smoothness and length without large computational spikes.\n   - Optimized spatial hashing parameters tailored to reduce neighbor search costs.\n2. Expected mechanism of impact:\n   - Concentrating samples within an adaptive ellipsoid avoids unnecessary exploration, reducing iterations and planning time.\n   - Simplified curvature-aware rewiring encourages smoother paths while limiting costly curvature computations.\n   - Incremental shortcutting speeds up elimination of redundant nodes and sharp turns early, improving solution quality progressively.\n   - More efficient neighbor queries lower computational costs per iteration, speeding up overall planning."
        }
    }
]