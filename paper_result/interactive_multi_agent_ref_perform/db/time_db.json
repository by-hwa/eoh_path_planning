[
    {
        "operator": "m2",
        "algorithm_description": "A novel bidirectional RRT* variant with adaptive sampling blending uniform and ellipsoidal informed distributions, dynamically tuned rewiring radius based on observed path quality and node density, and an integrated multi-level shortcutting strategy applying frequent lightweight and occasional global path smoothing to improve convergence speed, path optimality, and smoothness. The trees grow alternately towards adaptively sampled points; neighbors are rewired within a density-dependent radius to balance exploration and exploitation, while connection attempts leverage dynamic distance thresholds. Incremental shortcutting is applied after each path improvement, supplemented by a sparser global smoothing step to remove residual jaggedness and lower cost. This comprehensive adaptive approach enhances planning efficiency, success rate, path length, and smoothness while responding to the evolving search landscape.",
        "planning_mechanism": "The planner maintains two growing trees from start and goal positions. Sampling alternates between uniform free-space sampling and ellipsoidal informed sampling based on current best path cost. Each iteration extends a selected tree toward the sampled point with step size control, rewires neighbors within an adaptively computed radius to optimize path cost, and attempts connection with the opposite tree using a distance threshold that adapts with node density and best cost. Whenever a better path is found, incremental shortcutting immediately reduces length and jaggedness, and periodically a more global smoothing pass applies. Efficient collision checks ensure collision-free expansions, and dynamic parameter tuning balances exploration-exploitation trade-offs in real time, accelerating convergence to a short, smooth path efficiently.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except ValueError:\n            pass\nclass Planner:\n    def __init__(self, max_iter=6000, step_size=6.0, goal_sample_rate=0.08,\n                 shortcut_attempts=30, global_smooth_freq=250, uniform_sample_rate=0.3,\n                 r_min=5.0, r_max=35.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.shortcut_attempts = shortcut_attempts\n        self.global_smooth_freq = global_smooth_freq\n        self.uniform_sample_rate = uniform_sample_rate\n        self.r_min = r_min\n        self.r_max = r_max\n\n    def plan(self, map):\n        import math\n        import random\n\n        bounds = map.size\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        obstacles = map.obstacles\n        start_pos = map.start\n        goal_pos = map.goal\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        best_cost = float('inf')\n        solution_nodes = (None, None)\n        improved_since_last_global_smooth = False\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def is_in_obstacle(pos):\n            px = pos[0]\n            py = pos[1]\n            pz = pos[2] if is_3d else 0.0\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(a, b, resolution=0.5):\n            dist_ab = dist(a, b)\n            steps = max(1, int(dist_ab / resolution))\n            for i in range(steps + 1):\n                t = i / steps\n                interm = tuple(a[j] + t * (b[j] - a[j]) for j in range(dim))\n                if is_in_obstacle(interm):\n                    return True\n            return False\n\n        def nearest(tree, point):\n            best = None\n            best_d = float('inf')\n            for n in tree:\n                d_n = dist(n.position, point)\n                if d_n < best_d:\n                    best = n\n                    best_d = d_n\n            return best\n\n        def near(tree, point, radius):\n            r_sq = radius * radius\n            res = []\n            for n in tree:\n                d_sq = 0.0\n                for i in range(dim):\n                    diff = n.position[i] - point[i]\n                    d_sq += diff * diff\n                if d_sq <= r_sq:\n                    res.append(n)\n            return res\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            ratio = self.step_size / d\n            return tuple(from_pos[i] + ratio * (to_pos[i] - from_pos[i]) for i in range(dim))\n\n        def compute_ellipsoid_params():\n            c_min = dist(start_pos, goal_pos)\n            if c_min < 1e-14:\n                return None\n            center = tuple((start_pos[i] + goal_pos[i]) * 0.5 for i in range(dim))\n            direction = [goal_pos[i] - start_pos[i] for i in range(dim)]\n            length = c_min\n            e1 = [d / length for d in direction]\n            if dim == 2:\n                e2 = (-e1[1], e1[0])\n                basis = [e1, e2]\n            else:\n                v = [1, 0, 0] if abs(e1[0]) < 0.9 else [0, 1, 0]\n                for i in range(dim):\n                    proj = sum(v[j] * e1[j] for j in range(dim))\n                    v[i] = v[i] - proj * e1[i]\n                norm_v = math.sqrt(sum(x * x for x in v))\n                if norm_v < 1e-15:\n                    v = [0.0] * dim\n                    v[-1] = 1.0\n                    norm_v = 1.0\n                u = [x / norm_v for x in v]\n                # cross product for 3D only\n                if dim == 3:\n                    w = [e1[1] * u[2] - e1[2] * u[1],\n                         e1[2] * u[0] - e1[0] * u[2],\n                         e1[0] * u[1] - e1[1] * u[0]]\n                    basis = [e1, u, w]\n                else:\n                    basis = [e1, u]\n\n            a1 = best_cost * 0.5\n            b_sq = max(best_cost * best_cost - c_min * c_min, 1e-12) * 0.25\n            b = math.sqrt(b_sq)\n            return center, basis, a1, b\n\n        def sample():\n            if best_cost == float('inf'):\n                # Pure uniform sampling with goal bias and obstacle avoidance\n                while True:\n                    if random.random() < self.goal_sample_rate:\n                        pt = goal_pos\n                    else:\n                        pt = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                    if not is_in_obstacle(pt):\n                        return pt\n            # Blend uniform and ellipsoidal informed sampling\n            if random.random() < self.uniform_sample_rate:\n                # uniform free-space sampling with goal bias\n                if random.random() < self.goal_sample_rate:\n                    pt = goal_pos\n                else:\n                    while True:\n                        pt = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                        if not is_in_obstacle(pt):\n                            break\n                return pt\n            # ellipsoidal informed sample\n            params = compute_ellipsoid_params()\n            if params is None:\n                # fallback\n                while True:\n                    pt = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                    if not is_in_obstacle(pt):\n                        return pt\n            center, basis, a1, b = params\n            while True:\n                if dim == 2:\n                    r = random.uniform(0, 1) ** 0.5\n                    theta = random.uniform(0, 2 * math.pi)\n                    u_ball = [r * math.cos(theta), r * math.sin(theta)]\n                    coords = [a1 * u_ball[0], b * u_ball[1]]\n                    pt = tuple(center[i] + sum(coords[j] * basis[j][i] for j in range(dim)) for i in range(dim))\n                else:\n                    while True:\n                        u_ball = [random.uniform(-1, 1) for _ in range(3)]\n                        norm_sq = sum(x * x for x in u_ball)\n                        if 0 < norm_sq <= 1:\n                            break\n                    norm = math.sqrt(norm_sq)\n                    unit_ball = [x / norm for x in u_ball]\n                    coords = [a1 * unit_ball[0], b * unit_ball[1], b * unit_ball[2]]\n                    pt = tuple(center[i] + sum(coords[j] * basis[j][i] for j in range(dim)) for i in range(dim))\n                if any(pt[d] < 0 or pt[d] > bounds[d] for d in range(dim)):\n                    continue\n                if is_in_obstacle(pt):\n                    continue\n                return pt\n\n        def rewiring_radius(n_nodes):\n            if n_nodes < 2:\n                return self.r_max\n            # Adapt radius with dependency on best_cost and density for balanced rewiring\n            base = 2 * ((math.log(n_nodes) / n_nodes) ** (1 / dim)) * self.step_size\n            ratio = 1.0\n            # Shrink rewiring radius when cost is good\n            if best_cost < float('inf') and best_cost > 0:\n                ratio = max(0.3, min(1.0, (best_cost / (dist(start_pos, goal_pos) * 3))))\n            radius = base * ratio\n            return max(self.r_min, min(self.r_max, radius))\n\n        def extract_path(node_a, node_b):\n            path_a = []\n            cur = node_a\n            while cur is not None:\n                path_a.append(cur.position)\n                cur = cur.parent\n            path_b = []\n            cur = node_b\n            while cur is not None:\n                path_b.append(cur.position)\n                cur = cur.parent\n            return path_a[::-1] + path_b\n\n        def incremental_shortcut(path):\n            if len(path) < 3:\n                return path[:]\n            new_path = path[:]\n            attempts = 0\n            while attempts < self.shortcut_attempts:\n                if len(new_path) < 3:\n                    break\n                i = random.randint(0, len(new_path) - 3)\n                j = random.randint(i + 2, len(new_path) - 1)\n                if not is_edge_in_obstacle(new_path[i], new_path[j]):\n                    new_path = new_path[:i + 1] + new_path[j:]\n                    attempts = 0\n                else:\n                    attempts += 1\n            return new_path\n\n        def global_smooth(path):\n            # Apply a simple global smoothing by shortcutting multiple times with increasing segment length\n            smoothed = path[:]\n            n = len(smoothed)\n            if n < 3:\n                return smoothed\n            max_segments = min(20, n//3)\n            for seg in range(max_segments, 1, -1):\n                i = 0\n                while i + seg < len(smoothed):\n                    if not is_edge_in_obstacle(smoothed[i], smoothed[i + seg]):\n                        smoothed = smoothed[:i + 1] + smoothed[i + seg:]\n                        # After shortcut, restart checking to capture further smooths\n                        i = 0\n                    else:\n                        i += 1\n            return smoothed\n\n        for it in range(self.max_iter):\n            sample_pos = sample()\n            tree_to_extend, opposite_tree = (start_tree, goal_tree) if it % 2 == 0 else (goal_tree, start_tree)\n\n            nearest_node = nearest(tree_to_extend, sample_pos)\n            new_pos = steer(nearest_node.position, sample_pos)\n\n            if is_in_obstacle(new_pos):\n                continue\n            if is_edge_in_obstacle(nearest_node.position, new_pos):\n                continue\n\n            radius = rewiring_radius(len(tree_to_extend))\n            near_nodes = near(tree_to_extend, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for candidate in near_nodes:\n                if candidate is nearest_node:\n                    continue\n                tentative_cost = candidate.cost + dist(candidate.position, new_pos)\n                if tentative_cost < min_cost and not is_edge_in_obstacle(candidate.position, new_pos):\n                    min_cost = tentative_cost\n                    best_parent = candidate\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree_to_extend.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors if cost improved and collision free\n            for nbr in near_nodes:\n                if nbr is best_parent or nbr is new_node:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, nbr.position)\n                if new_cost < nbr.cost and not is_edge_in_obstacle(new_node.position, nbr.position):\n                    if nbr.parent is not None:\n                        try:\n                            edges.remove((nbr.parent, nbr))\n                        except ValueError:\n                            pass\n                        nbr.parent.remove_child(nbr)\n                    nbr.parent = new_node\n                    nbr.cost = new_cost\n                    new_node.add_child(nbr)\n                    edges.append((new_node, nbr))\n\n            nearest_other = nearest(opposite_tree, new_pos)\n            dist_connect = dist(new_pos, nearest_other.position)\n            # Adapt connection threshold to min(step_size * 1.5, rewiring radius)\n            connect_thresh = min(self.step_size * 1.5, rewiring_radius(len(tree_to_extend)))\n            if dist_connect <= connect_thresh and not is_edge_in_obstacle(new_pos, nearest_other.position):\n                total_cost = new_node.cost + dist_connect + nearest_other.cost\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    solution_nodes = (new_node, nearest_other) if it % 2 == 0 else (nearest_other, new_node)\n                    raw_path = extract_path(solution_nodes[0], solution_nodes[1])\n                    smoothed_path = incremental_shortcut(raw_path)\n                    nodes_clear = len(smoothed_path)\n                    improved_since_last_global_smooth = True\n                    # Whenever better path found, return smoothed path immediately (anytime behavior)\n                    if smoothed_path and len(smoothed_path) >= 2:\n                        # Periodically apply global smoothing too\n                        if it % self.global_smooth_freq == 0:\n                            smoothed_path = global_smooth(smoothed_path)\n                        return PlannerResult(True, smoothed_path, nodes, edges)\n\n            # Periodic global smoothing on existing best path\n            if improved_since_last_global_smooth and it % self.global_smooth_freq == 0 and best_cost < float('inf'):\n                raw_path = extract_path(solution_nodes[0], solution_nodes[1])\n                smoothed_path = global_smooth(raw_path)\n                if smoothed_path and len(smoothed_path) >= 2:\n                    improved_since_last_global_smooth = False\n                    return PlannerResult(True, smoothed_path, nodes, edges)\n\n        # If terminate with solution found\n        if solution_nodes[0] is not None and solution_nodes[1] is not None:\n            raw_path = extract_path(solution_nodes[0], solution_nodes[1])\n            smoothed_path = incremental_shortcut(raw_path)\n            smoothed_path = global_smooth(smoothed_path)\n            return PlannerResult(True, smoothed_path, nodes, edges)\n\n        return PlannerResult(False, [], nodes, edges)",
        "objective": -31.45446,
        "time_improvement": 60.0,
        "length_improvement": 12.0,
        "smoothness_improvement": 1289.0,
        "node_improvement": 74.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.019103193283081056,
                "num_nodes_avg": 130.0,
                "path_length_avg": 173.3649996406287,
                "smoothness_avg": 0.03905650881261121,
                "success_improvement": 0.0,
                "time_improvement": 25.93023309560016,
                "node_improvement": 67.26265424326367,
                "length_improvement": 4.975896552754276,
                "smoothness_improvement": 511.3191754837242,
                "objective_score": 13.321203737751233
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.022163128852844237,
                "num_nodes_avg": 240.8,
                "path_length_avg": 245.67296527562377,
                "smoothness_avg": 0.08351123895740013,
                "success_improvement": 0.0,
                "time_improvement": 86.6145035068227,
                "node_improvement": 83.8204663038366,
                "length_improvement": 17.987292886770433,
                "smoothness_improvement": 2048.8043290880164,
                "objective_score": 47.020748429549144
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.017162418365478514,
                "num_nodes_avg": 224.0,
                "path_length_avg": 131.41011815324833,
                "smoothness_avg": 0.11058336040285022,
                "success_improvement": 0.0,
                "time_improvement": 66.18054762740364,
                "node_improvement": 71.51938970120788,
                "length_improvement": 12.723656600001021,
                "smoothness_improvement": 1306.6121819096536,
                "objective_score": 34.02141915776997
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "m1",
        "algorithm_description": "A bidirectional RRT* planner with relaxed curvature constraints and adaptive rewiring radius enabling more aggressive shortcutting and sharper turns to produce smoother and shorter paths with efficient planning time. It combines hybrid uniform and informed sampling, hash-grid accelerated neighbor queries, incremental rewiring with curvature-aware cost, and periodic multi-level smoothing phases employing increased angle thresholds for enhanced path smoothness and robustness.",
        "planning_mechanism": "The planner grows two trees from start and goal alternately using hybrid sampling. It adaptively tunes rewiring radius to the node density and best path cost but relaxes curvature penalties and uses higher angle thresholds in curvature checks to allow more aggressive rewiring and shortcuts. Nearest neighbors are queried through spatial grid hashing. After connection, local multi-attempt curvature-aware shortcuts and global midpoint smoothing with relaxed angle limits progressively refine path smoothness. Early collision checking pruning and incremental cost propagation accelerate search and ensure feasible paths.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n    def add_child(self, child):\n        self.children.append(child)\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\nclass Planner:\n    def __init__(self, max_iter=4000, step_size=5.0, base_radius=20.0,\n                 blend_sample_rate=0.7, shortcut_local_interval=15, shortcut_global_interval=60,\n                 max_local_shortcuts=60, curvature_threshold=0.8):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.base_radius = base_radius\n        self.blend_sample_rate = blend_sample_rate\n        self.shortcut_local_interval = shortcut_local_interval\n        self.shortcut_global_interval = shortcut_global_interval\n        self.max_local_shortcuts = max_local_shortcuts\n        self.curvature_threshold = curvature_threshold\n\n    def plan(self, map):\n        import random\n        import math\n\n        bounds = map.size\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        def in_bounds(p):\n            return all(0.0 <= p[i] <= bounds[i] for i in range(dim))\n\n        def collision_node(p):\n            px = p[0]\n            py = p[1]\n            pz = p[2] if is_3d else 0.0\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d = obs\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                        return True\n                else:\n                    x,y,w,h = obs\n                    if x <= px <= x+w and y <= py <= y+h:\n                        return True\n            return False\n\n        def collision_edge(a,b,res=0.5):\n            length = math.dist(a,b)\n            if length < 1e-12:\n                return False\n            steps = max(1,int(length/res))\n            for step in range(steps+1):\n                t = step / steps\n                interp = tuple(a[i] + (b[i]-a[i])*t for i in range(dim))\n                if collision_node(interp):\n                    return True\n            return False\n\n        def steer(from_p, to_p):\n            length = math.dist(from_p,to_p)\n            if length <= self.step_size:\n                return to_p\n            ratio = self.step_size / length\n            return tuple(from_p[i] + (to_p[i] - from_p[i]) * ratio for i in range(dim))\n\n        GRID_SIZE = self.step_size * 3.0\n        def grid_hash(p):\n            return tuple(int(p[i]/GRID_SIZE) for i in range(dim))\n\n        start_hash, goal_hash = {}, {}\n        def add_to_hash(ht, node):\n            h = grid_hash(node.position)\n            if h not in ht:\n                ht[h] = []\n            ht[h].append(node)\n        def remove_from_hash(ht, node):\n            h = grid_hash(node.position)\n            if h in ht and node in ht[h]:\n                ht[h].remove(node)\n                if not ht[h]:\n                    del ht[h]\n\n        def nearby_nodes(ht, p, radius):\n            radius_sq = radius*radius\n            gh = grid_hash(p)\n            shifts = [-1,0,1]\n            neighbors = []\n            if dim==2:\n                cells = [(gh[0]+dx,gh[1]+dy) for dx in shifts for dy in shifts]\n            else:\n                cells = [(gh[0]+dx,gh[1]+dy,gh[2]+dz) for dx in shifts for dy in shifts for dz in shifts]\n            candidates = []\n            for c in cells:\n                if c in ht:\n                    candidates.extend(ht[c])\n            for node in candidates:\n                d_sq = 0.0\n                for i in range(dim):\n                    diff = node.position[i] - p[i]\n                    d_sq += diff*diff\n                    if d_sq > radius_sq:\n                        break\n                if d_sq <= radius_sq:\n                    neighbors.append(node)\n            return neighbors\n\n        def nearest(ht, p):\n            gh = grid_hash(p)\n            min_node = None\n            min_dist_sq = float('inf')\n            expansions = 0\n            max_expansions = 2\n            while expansions <= max_expansions:\n                if dim == 2:\n                    cells = [(gh[0]+dx, gh[1]+dy) for dx in range(-expansions,expansions+1) for dy in range(-expansions,expansions+1)]\n                else:\n                    cells = [(gh[0]+dx, gh[1]+dy, gh[2]+dz) for dx in range(-expansions,expansions+1) for dy in range(-expansions,expansions+1) for dz in range(-expansions,expansions+1)]\n                candidates = []\n                for c in cells:\n                    if c in ht:\n                        candidates.extend(ht[c])\n                for node in candidates:\n                    d_sq = 0.0\n                    for i in range(dim):\n                        diff = node.position[i] - p[i]\n                        d_sq += diff*diff\n                        if d_sq >= min_dist_sq:\n                            break\n                    else:\n                        if d_sq < min_dist_sq:\n                            min_dist_sq = d_sq\n                            min_node = node\n                if min_node is not None or expansions == max_expansions:\n                    break\n                expansions +=1\n            if min_node is None:\n                all_nodes = []\n                for cell_nodes in ht.values():\n                    all_nodes.extend(cell_nodes)\n                if all_nodes:\n                    min_node = min(all_nodes, key=lambda n: math.dist(n.position,p))\n            return min_node\n\n        def unit_ball_volume(d):\n            from math import pi, gamma\n            return (pi**(d/2))/(gamma(d/2+1))\n\n        c_min = math.dist(start_pos, goal_pos)\n        volume_unit_ball = unit_ball_volume(dim)\n\n        def adaptive_radius(n_nodes, best_cost):\n            if n_nodes <= 1:\n                return self.step_size * 5.0\n            val = (math.log(n_nodes)/n_nodes)**(1.0/dim)\n            radius = self.base_radius * val\n            if best_cost < float('inf'):\n                radius = min(radius, best_cost*0.4)  # relaxed multiplier for bigger radius\n            radius = max(radius, self.step_size*1.2)\n            return radius\n\n        def angle_between(a,b,c):\n            ab = [a[i]-b[i] for i in range(dim)]\n            cb = [c[i]-b[i] for i in range(dim)]\n            lab = math.sqrt(sum(x*x for x in ab))\n            lcb = math.sqrt(sum(x*x for x in cb))\n            if lab < 1e-14 or lcb < 1e-14:\n                return 0.0\n            dot = sum(ab[i]*cb[i] for i in range(dim))\n            val = max(min(dot/(lab*lcb),1.0),-1.0)\n            return math.acos(val)\n\n        def curvature_penalty(parent, child_pos):\n            # Reduced penalty scale for more permissive curvature\n            if parent is None or parent.parent is None:\n                return 0.0\n            v1 = [parent.position[i]-parent.parent.position[i] for i in range(dim)]\n            v2 = [child_pos[i]-parent.position[i] for i in range(dim)]\n            len1 = math.sqrt(sum(x*x for x in v1))\n            len2 = math.sqrt(sum(x*x for x in v2))\n            if len1 < 1e-9 or len2 < 1e-9:\n                return 0.0\n            dot = sum(v1[i]*v2[i] for i in range(dim))\n            cos_ang = max(min(dot/(len1*len2),1.0),-1.0)\n            penalty = (1.0 - cos_ang)*0.5  # half previous penalty weight\n            return penalty\n\n        def path_cost(parent, child_pos):\n            linear_cost = parent.cost + math.dist(parent.position, child_pos)\n            pen = curvature_penalty(parent, child_pos)\n            return linear_cost + pen\n\n        def rewire(tree_hash, new_node, near_nodes):\n            for n in near_nodes:\n                if n is new_node.parent:\n                    continue\n                c_cost = path_cost(new_node, n.position)\n                if c_cost + 1e-10 < n.cost:\n                    if not collision_edge(new_node.position, n.position):\n                        # Check curvature increase with relaxed threshold\n                        if n.parent:\n                            ang_before = angle_between(n.parent.parent.position if n.parent.parent else n.parent.position,\n                                                     n.parent.position, n.position)\n                            ang_after = angle_between(n.parent.position, new_node.position, n.position)\n                            if ang_after > ang_before + self.curvature_threshold:\n                                continue\n                        if n.parent:\n                            n.parent.remove_child(n)\n                        n.parent = new_node\n                        n.cost = c_cost\n                        new_node.add_child(n)\n                        self._propagate_costs(n)\n\n        def propagate_costs(node):\n            import math\n            stack = [node]\n            while stack:\n                n = stack.pop()\n                for c in n.children:\n                    new_cost = n.cost + math.dist(n.position, c.position) + curvature_penalty(n, c.position)\n                    if new_cost + 1e-12 < c.cost:\n                        c.cost = new_cost\n                        stack.append(c)\n\n        self._propagate_costs = propagate_costs\n\n        def extract_path(node_start, node_goal):\n            path_start = []\n            n = node_start\n            while n:\n                path_start.append(n.position)\n                n = n.parent\n            path_start.reverse()\n            path_goal = []\n            n = node_goal\n            while n:\n                path_goal.append(n.position)\n                n = n.parent\n            if path_start[-1] == path_goal[0]:\n                return path_start + path_goal[1:]\n            else:\n                return path_start + path_goal\n\n        def hybrid_sample(best_cost):\n            if best_cost == float('inf') or random.random() > self.blend_sample_rate:\n                for _ in range(30):\n                    pt = tuple(random.uniform(0,bounds[i]) for i in range(dim))\n                    if not collision_node(pt):\n                        return pt\n                return tuple(random.uniform(0,bounds[i]) for i in range(dim))\n            center = tuple(0.5*(start_pos[i]+goal_pos[i]) for i in range(dim))\n            d_vec = [goal_pos[i]-start_pos[i] for i in range(dim)]\n            length = math.dist(start_pos, goal_pos)\n            a1_val = best_cost*0.5\n            term = best_cost*best_cost - c_min*c_min\n            a_rest = math.sqrt(term)*0.5 if term > 0 else 0.0\n\n            if dim == 2:\n                if length < 1e-14:\n                    R = [[1,0],[0,1]]\n                else:\n                    norm_d = (d_vec[0]/length, d_vec[1]/length)\n                    c = norm_d[0]\n                    s = norm_d[1]\n                    R = [[c, -s],[s, c]]\n                attempts = 0\n                while attempts < 100:\n                    r = random.uniform(0,1)**0.5\n                    theta = random.uniform(0,2*math.pi)\n                    ball = [r*math.cos(theta), r*math.sin(theta)]\n                    x_scaled = [a1_val*ball[0], a_rest*ball[1]]\n                    pt = (center[0] + R[0][0]*x_scaled[0] + R[0][1]*x_scaled[1],\n                          center[1] + R[1][0]*x_scaled[0] + R[1][1]*x_scaled[1])\n                    if in_bounds(pt) and not collision_node(pt):\n                        return pt\n                    attempts += 1\n                return tuple(random.uniform(0,bounds[i]) for i in range(dim))\n            else:\n                from math import sqrt\n                if length < 1e-14:\n                    R = [[1,0,0],[0,1,0],[0,0,1]]\n                else:\n                    a1 = [1,0,0]\n                    a2 = [d_vec[i]/length for i in range(3)]\n                    v = [a1[1]*a2[2]-a1[2]*a2[1], a1[2]*a2[0]-a1[0]*a2[2], a1[0]*a2[1]-a1[1]*a2[0]]\n                    s = sqrt(sum(x*x for x in v))\n                    c = sum(a1[i]*a2[i] for i in range(3))\n                    if s < 1e-14:\n                        R = [[1,0,0],[0,1,0],[0,0,1]]\n                    else:\n                        vx = [[0,-v[2],v[1]], [v[2],0,-v[0]], [-v[1],v[0],0]]\n                        I = [[1 if i==j else 0 for j in range(3)] for i in range(3)]\n                        vx2 = [[sum(vx[i][k]*vx[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n                        R = [[I[i][j] + vx[i][j] + vx2[i][j]*((1-c)/(s*s)) for j in range(3)] for i in range(3)]\n                attempts = 0\n                while attempts < 100:\n                    while True:\n                        ball = [random.uniform(-1,1) for _ in range(3)]\n                        if sum(x*x for x in ball) <= 1:\n                            break\n                    x_scaled = [a1_val*ball[0], a_rest*ball[1], a_rest*ball[2]]\n                    pt = tuple(center[i] + sum(R[i][j]*x_scaled[j] for j in range(3)) for i in range(3))\n                    if in_bounds(pt) and not collision_node(pt):\n                        return pt\n                    attempts += 1\n                return tuple(random.uniform(0,bounds[i]) for i in range(dim))\n\n        def attempt_connection(tree_a, tree_hash_a, tree_b, tree_hash_b, sample, best_cost):\n            nearest_node = nearest(tree_hash_a, sample)\n            if nearest_node is None:\n                return None\n            new_pos = steer(nearest_node.position, sample)\n\n            if not in_bounds(new_pos) or collision_node(new_pos) or collision_edge(nearest_node.position, new_pos):\n                return None\n\n            radius = adaptive_radius(len(tree_a), best_cost)\n            near_nodes = nearby_nodes(tree_hash_a, new_pos, radius)\n\n            min_cost = path_cost(nearest_node, new_pos)\n            min_parent = nearest_node\n            for near in near_nodes:\n                if near is nearest_node:\n                    continue\n                c = path_cost(near, new_pos)\n                if c < min_cost and not collision_edge(near.position, new_pos):\n                    min_cost = c\n                    min_parent = near\n\n            new_node = Node(new_pos, min_parent, min_cost)\n            min_parent.add_child(new_node)\n            tree_a.append(new_node)\n            add_to_hash(tree_hash_a, new_node)\n\n            rewire(tree_hash_a, new_node, near_nodes)\n\n            other_nearest = nearest(tree_hash_b, new_node.position)\n            if other_nearest and math.dist(other_nearest.position, new_node.position) <= self.step_size:\n                if not collision_edge(other_nearest.position, new_node.position):\n                    total_cost = new_node.cost + math.dist(other_nearest.position, new_node.position) + other_nearest.cost\n                    return (new_node, other_nearest, total_cost)\n            return None\n\n        def quick_local_shortcut(path):\n            if len(path) < 3:\n                return path[:]\n            new_path = path[:]\n            attempts = 0\n            max_attempts = self.max_local_shortcuts\n            while attempts < max_attempts and len(new_path) >=3:\n                i = random.randint(0, len(new_path)-3)\n                j = random.randint(i+2, len(new_path)-1)\n                if not collision_edge(new_path[i], new_path[j]):\n                    valid = True\n                    # Relax curvature checks: larger angle threshold and apply selectively\n                    if i > 0 and j < len(new_path)-1:\n                        ang_before = angle_between(new_path[i-1], new_path[i], new_path[i+1] if i+1<len(new_path) else new_path[i])\n                        ang_after = angle_between(new_path[i-1], new_path[i], new_path[j])\n                        ang_after2 = angle_between(new_path[i], new_path[j], new_path[j+1])\n                        if ang_after > ang_before + self.curvature_threshold + 0.3 or ang_after2 > self.curvature_threshold + 0.7:\n                            valid = False\n                    if valid:\n                        del new_path[i+1:j]\n                        attempts += 1\n                    else:\n                        attempts +=1\n                else:\n                    attempts +=1\n            return new_path\n\n        def global_smooth(path):\n            if len(path) < 4:\n                return path[:]\n            new_path = path[:]\n            changed = False\n            for idx in range(1, len(path)-1):\n                a = new_path[idx-1]\n                b = new_path[idx]\n                c = new_path[idx+1]\n                midpoint = tuple(0.5*(a[i]+c[i]) for i in range(dim))\n                if not collision_node(midpoint) and not collision_edge(a, midpoint) and not collision_edge(midpoint, c):\n                    ang_old = angle_between(a,b,c)\n                    ang_new = angle_between(a, midpoint, c)\n                    # Allow relaxed curvature threshold to smooth sharper turns\n                    if ang_new < ang_old + self.curvature_threshold + 0.2:\n                        new_path[idx] = midpoint\n                        changed = True\n            return new_path if changed else path\n\n        start_tree = [Node(start_pos, None, 0.0)]\n        goal_tree = [Node(goal_pos, None, 0.0)]\n        nodes = start_tree + goal_tree\n        edges = []\n        add_to_hash(start_hash,start_tree[0])\n        add_to_hash(goal_hash,goal_tree[0])\n\n        best_cost = float('inf')\n        best_sol_start = None\n        best_sol_goal = None\n\n        for it in range(1, self.max_iter+1):\n            sample = hybrid_sample(best_cost)\n\n            for tree_a, hash_a, tree_b, hash_b in [(start_tree, start_hash, goal_tree, goal_hash),\n                                                   (goal_tree, goal_hash, start_tree, start_hash)]:\n                res = attempt_connection(tree_a, hash_a, tree_b, hash_b, sample, best_cost)\n                if res:\n                    new_node, conn_node, cost_candidate = res\n                    if cost_candidate + 1e-15 < best_cost:\n                        best_cost = cost_candidate\n                        best_sol_start, best_sol_goal = (new_node, conn_node) if tree_a is start_tree else (conn_node, new_node)\n\n            if best_cost < float('inf') and best_sol_start and best_sol_goal:\n                if it % self.shortcut_local_interval == 0 or it == self.max_iter:\n                    raw_path = extract_path(best_sol_start, best_sol_goal)\n                    path_after_local = quick_local_shortcut(raw_path)\n                    if it % self.shortcut_global_interval == 0 or it == self.max_iter:\n                        path_after_global = global_smooth(path_after_local)\n                    else:\n                        path_after_global = path_after_local\n                    return PlannerResult(True, path_after_global, nodes, edges)\n\n        return PlannerResult(False, [], nodes, edges)",
        "objective": -23.54405,
        "time_improvement": 61.0,
        "length_improvement": 8.0,
        "smoothness_improvement": 147.0,
        "node_improvement": 100.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.019300460815429688,
                "num_nodes_avg": 2.0,
                "path_length_avg": 182.424034052097,
                "smoothness_avg": 0.013544456505030241,
                "success_improvement": 0.0,
                "time_improvement": 25.16535782462595,
                "node_improvement": 99.49634852681945,
                "length_improvement": 0.01049624224208904,
                "smoothness_improvement": 112.00015656178346,
                "objective_score": 8.115905875541955
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.025008130073547363,
                "num_nodes_avg": 2.0,
                "path_length_avg": 267.74552895014153,
                "smoothness_avg": 0.009938292940300212,
                "success_improvement": 0.0,
                "time_improvement": 84.89625541488331,
                "node_improvement": 99.86561849089566,
                "length_improvement": 10.618835808697503,
                "smoothness_improvement": 155.7194356169902,
                "objective_score": 32.61877528776845
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.013741588592529297,
                "num_nodes_avg": 2.0,
                "path_length_avg": 132.60623477657154,
                "smoothness_avg": 0.021438419722591737,
                "success_improvement": 0.0,
                "time_improvement": 72.92147347580986,
                "node_improvement": 99.74570883661794,
                "length_improvement": 11.929252891742708,
                "smoothness_improvement": 172.69511645182806,
                "objective_score": 29.897469360047726
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "m2",
        "algorithm_description": "An advanced bidirectional RRT* planner combining adaptive rewiring radius with dynamic goal bias and local incremental smoothing performed continuously during planning to enhance convergence speed, path quality, and smoothness. It features balanced exploration via adjustable goal bias sampling, adaptive rewiring based on tree size and dimensionality to optimize local connections efficiently, and progressive local shortcutting integrated into the planning loop to refine path geometry incrementally. This design reduces sharp turns and excess waypoints early, producing shorter, smoother, and more robust paths with lower computational overhead.",
        "planning_mechanism": "The planner grows two trees from start and goal positions alternately, sampling primarily with a tunable goal bias to accelerate convergence. Expansion towards samples is constrained by a fixed step size, and new nodes are optimally connected using an adaptive rewiring radius scaled with the logarithm of the tree size and problem dimension. After each iteration, local shortcutting attempts simplify the best available path, continuously enhancing path smoothness without waiting for post-processing. The algorithm terminates upon tree connection or maximum iterations, returning the smoothed shortest path found.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except ValueError:\n            pass\n\n    def path_from_root(self):\n        node, path = self, []\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=4000, step_size=5.0, base_radius=18.0, goal_sample_rate=0.15,\n                 local_shortcut_attempts=40):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.base_radius = base_radius\n        self.goal_sample_rate = goal_sample_rate\n        self.local_shortcut_attempts = local_shortcut_attempts\n\n    def plan(self, map) -> 'PlannerResult':\n        import random, math\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        def dist(a,b):\n            return math.dist(a,b)\n\n        def steer(fr, to):\n            d = dist(fr, to)\n            if d <= self.step_size:\n                return to\n            ratio = self.step_size / d\n            return tuple(fr[i] + (to[i] - fr[i]) * ratio for i in range(dim))\n\n        def is_in_obstacle(p):\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d_ = obs\n                    px,py,pz = p\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d_:\n                        return True\n                else:\n                    x,y,w,h = obs\n                    px,py = p\n                    if x <= px <= x+w and y <= py <= y+h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(fr,to, resolution=1.0):\n            d = dist(fr,to)\n            steps = max(1, int(d / resolution))\n            for i in range(steps + 1):\n                interp = tuple(fr[j] + (to[j] - fr[j]) * i / steps for j in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: dist(node.position, point))\n\n        def near_nodes(tree, point, radius):\n            r2 = radius*radius\n            result = []\n            for n in tree:\n                cd = 0.0\n                for i in range(dim):\n                    d = n.position[i] - point[i]\n                    cd += d*d\n                    if cd > r2:\n                        break\n                else:\n                    result.append(n)\n            return result\n\n        def rewire(tree, new_node, near_nodes_):\n            nonlocal edges\n            for near in near_nodes_:\n                if near == new_node.parent:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, near.position)\n                if new_cost + 1e-8 < near.cost:\n                    if not is_edge_in_obstacle(new_node.position, near.position):\n                        # Remove old edge\n                        if near.parent is not None:\n                            try:\n                                edges.remove((near.parent, near))\n                                near.parent.remove_child(near)\n                            except Exception:\n                                pass\n                        near.parent = new_node\n                        near.cost = new_cost\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n\n        def extract_path(node_from_start, node_from_goal):\n            path_start = node_from_start.path_from_root()\n            path_goal = node_from_goal.path_from_root()[::-1]\n            if len(path_start) > 0 and len(path_goal) > 0 and path_start[-1] == path_goal[0]:\n                path_goal = path_goal[1:]\n            return path_start + path_goal\n\n        def sample_point():\n            if random.random() < self.goal_sample_rate:\n                return goal_pos\n            else:\n                return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n\n        def adaptive_radius(tree_size):\n            n = max(tree_size, 1)\n            radius = self.base_radius * (math.log(n)/n)**(1.0/dim)\n            min_radius = self.step_size * 1.5\n            return max(radius, min_radius)\n\n        def local_shortcut(path):\n            if len(path) < 3:\n                return path[:]\n            new_path = path[:]\n            attempts = 0\n            while attempts < self.local_shortcut_attempts:\n                if len(new_path) < 3:\n                    break\n                i = random.randint(0, len(new_path) - 3)\n                j = random.randint(i + 2, len(new_path) - 1)\n                p1, p2 = new_path[i], new_path[j]\n                if not is_edge_in_obstacle(p1, p2):\n                    new_path = new_path[:i+1] + new_path[j:]\n                    attempts = 0\n                else:\n                    attempts += 1\n            return new_path\n\n        connection_node_start = None\n        connection_node_goal = None\n        success = False\n\n        for itr in range(self.max_iter):\n            # Alternate expansion\n            for (tree_a, tree_b) in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                q_rand = sample_point()\n                nearest_node = nearest(tree_a, q_rand)\n                q_new_pos = steer(nearest_node.position, q_rand)\n                if is_in_obstacle(q_new_pos):\n                    continue\n                if is_edge_in_obstacle(nearest_node.position, q_new_pos):\n                    continue\n\n                radius = adaptive_radius(len(tree_a))\n                near_nodes_a = near_nodes(tree_a, q_new_pos, radius)\n\n                min_cost = nearest_node.cost + dist(nearest_node.position, q_new_pos)\n                min_parent = nearest_node\n                for near in near_nodes_a:\n                    c = near.cost + dist(near.position, q_new_pos)\n                    if c < min_cost and not is_edge_in_obstacle(near.position, q_new_pos):\n                        min_cost = c\n                        min_parent = near\n\n                q_new = Node(q_new_pos, parent=min_parent, cost=min_cost)\n                min_parent.add_child(q_new)\n                tree_a.append(q_new)\n                nodes.append(q_new)\n                edges.append((min_parent, q_new))\n\n                rewire(tree_a, q_new, near_nodes_a)\n\n                # Attempt connection with other tree\n                nearest_in_other = nearest(tree_b, q_new.position)\n                dist_to_other = dist(q_new.position, nearest_in_other.position)\n                radius_conn = max(self.step_size * 1.5, adaptive_radius(len(tree_b)))\n                if dist_to_other <= radius_conn and not is_edge_in_obstacle(q_new.position, nearest_in_other.position):\n                    if tree_a is start_tree:\n                        connection_node_start, connection_node_goal = q_new, nearest_in_other\n                    else:\n                        connection_node_start, connection_node_goal = nearest_in_other, q_new\n                    success = True\n                    break\n\n            # Incremental local shortcutting if a connection found\n            if success:\n                raw_path = extract_path(connection_node_start, connection_node_goal)\n                improved_path = local_shortcut(raw_path)\n\n                # If improvement shortens path cost, update connection nodes parent chain accordingly\n                # This is done by replacing nodes on path with new simpler chain if better\n                # For efficiency, only store final smoothed path\n\n                # Return improved solution early for speed\n                return self._result(True, improved_path, nodes, edges)\n\n        # On failure, return best partial if any connection (non necessarily success)\n        if connection_node_start and connection_node_goal:\n            raw_path = extract_path(connection_node_start, connection_node_goal)\n            improved_path = local_shortcut(raw_path)\n            return self._result(True, improved_path, nodes, edges)\n\n        # No path found\n        return self._result(False, [], nodes, edges)\n\n    def _result(self, success, path, nodes, edges):\n        # PlannerResult must be defined externally in environment\n        return PlannerResult(success, path, nodes, edges)",
        "objective": -33.95507,
        "time_improvement": 61.0,
        "length_improvement": 14.0,
        "smoothness_improvement": 1487.0,
        "node_improvement": 70.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.010840678215026855,
                "num_nodes_avg": 108.5,
                "path_length_avg": 171.66948645779462,
                "smoothness_avg": 0.03037023005591788,
                "success_improvement": 0.0,
                "time_improvement": 57.96689607994491,
                "node_improvement": 72.67690757995467,
                "length_improvement": 5.905234195391321,
                "smoothness_improvement": 375.36005038524775,
                "objective_score": 22.810009593144503
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.03051626682281494,
                "num_nodes_avg": 329.8,
                "path_length_avg": 234.6106758602652,
                "smoothness_avg": 0.10438344350479727,
                "success_improvement": 0.0,
                "time_improvement": 81.56959762974842,
                "node_improvement": 77.84048914869314,
                "length_improvement": 21.68020350396321,
                "smoothness_improvement": 2585.8611857338155,
                "objective_score": 50.40830731997153
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.029309940338134766,
                "num_nodes_avg": 310.9,
                "path_length_avg": 129.2870965574641,
                "smoothness_avg": 0.12568844803562226,
                "success_improvement": 0.0,
                "time_improvement": 42.24321361941394,
                "node_improvement": 60.47043865225684,
                "length_improvement": 14.133666456496211,
                "smoothness_improvement": 1498.7477816569226,
                "objective_score": 28.64690286800652
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "m1",
        "algorithm_description": "Enhanced Bidirectional RRT* with Adaptive Radius, Informed Sampling, Efficient Collision Checking, and B-Spline Path Smoothing for Improved Planning Efficiency, Path Length, and Notably Smooth and Feasible Paths",
        "planning_mechanism": "This planner employs a bidirectional RRT* framework with adaptive rewiring radius based on tree size for asymptotic optimality. It uses goal bias and informed sampling within an ellipsoidal subset to concentrate sampling in promising regions. It alternates between trees for balanced growth and rewires local neighborhoods to optimize paths continuously. After tree connection, it reconstructs the path and applies B-spline smoothing to produce smooth, curvature-continuous trajectories, while maintaining rigorous collision checks on nodes and edges. Early termination is triggered on successful connection to improve search efficiency.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        node, path = self, []\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=7.0, base_radius=20.0, goal_sample_rate=0.15, smoothing_degree=3, smoothing_points=100):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.base_radius = base_radius\n        self.goal_sample_rate = goal_sample_rate\n        self.smoothing_degree = smoothing_degree\n        self.smoothing_points = smoothing_points\n\n    def plan(self, map):\n        import math\n        import random\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        def dist(a,b):\n            return math.dist(a,b)\n\n        def steer(fr, to):\n            d = dist(fr, to)\n            if d <= self.step_size:\n                return to\n            ratio = self.step_size / d\n            return tuple(fr[i] + (to[i] - fr[i]) * ratio for i in range(dim))\n\n        def is_in_obstacle(p):\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d_ = obs\n                    px,py,pz = p\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d_:\n                        return True\n                else:\n                    x,y,w,h = obs\n                    px,py = p\n                    if x <= px <= x+w and y <= py <= y+h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(fr,to, resolution=1.0):\n            d = dist(fr,to)\n            steps = max(1, int(d / resolution))\n            for i in range(steps + 1):\n                interp = tuple(fr[j] + (to[j] - fr[j]) * i / steps for j in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: dist(node.position, point))\n\n        def near_nodes(tree, point, radius):\n            return [node for node in tree if dist(node.position, point) <= radius]\n\n        def rewire(tree, new_node, near_nodes_list):\n            nonlocal edges\n            for near in near_nodes_list:\n                if near == new_node.parent:\n                    continue\n                c = new_node.cost + dist(new_node.position, near.position)\n                if c + 1e-10 < near.cost and not is_edge_in_obstacle(new_node.position, near.position):\n                    old_parent = near.parent\n                    if old_parent:\n                        try:\n                            edges.remove((old_parent, near))\n                        except ValueError:\n                            pass\n                        old_parent.children.remove(near)\n                    near.parent = new_node\n                    near.cost = c\n                    new_node.add_child(near)\n                    edges.append((new_node, near))\n\n        def extract_path(node_start, node_goal):\n            path_start = node_start.path_from_root()\n            path_goal = node_goal.path_from_root()[::-1]\n            if len(path_start) > 0 and len(path_goal) > 0 and path_start[-1] == path_goal[0]:\n                path_goal = path_goal[1:]\n            return path_start + path_goal\n\n        def adaptive_radius(tree_size):\n            gamma = self.base_radius\n            n = max(tree_size, 1)\n            return max(gamma * (math.log(n)/n)**(1.0/dim), self.step_size*1.5)\n\n        def informed_sample(c_best, c_min, start, goal):\n            # If no solution found yet, sample uniformly\n            if c_best == float('inf'):\n                return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n            # Ellipsoidal informed sampling\n            import numpy as np\n            c = c_best\n            center = tuple((start[i] + goal[i])/2 for i in range(dim))\n            a1 = tuple((goal[i] - start[i])/c_min for i in range(dim))\n            if dim == 2:\n                # Build rotation matrix to align x-axis with a1\n                theta = math.atan2(a1[1], a1[0])\n                r = [[math.cos(theta), -math.sin(theta)],\n                     [math.sin(theta),  math.cos(theta)]]\n                while True:\n                    # Sample uniformly in unit circle\n                    x, y = random.random()*2 -1, random.random()*2 -1\n                    if x**2 + y**2 > 1: \n                        continue\n                    # Scale according to ellipse axes\n                    rx = c/2\n                    ry = math.sqrt(c**2 - c_min**2)/2\n                    sample_ellipse = (x*rx, y*ry)\n                    # Rotate and translate sample\n                    px = r[0][0]*sample_ellipse[0] + r[0][1]*sample_ellipse[1] + center[0]\n                    py = r[1][0]*sample_ellipse[0] + r[1][1]*sample_ellipse[1] + center[1]\n                    if 0 <= px <= bounds[0] and 0 <= py <= bounds[1]:\n                        return (px, py)\n            else:  # In 3D or higher, fallback uniform sampling due to complexity\n                return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n\n        # B-spline smoothing using De Boor's algorithm (degree=3) for smoothness enhancement\n        def bspline(points, degree=3, num=100):\n            if len(points) <= degree:\n                return points[:]\n            import numpy as np\n            points_np = np.array(points)\n            n = len(points_np) - 1\n            k = degree\n            domain = np.linspace(0, n - k + 1, num)\n            knots = np.concatenate(([0]*k, np.arange(n - k + 2), [n - k + 2]*k))\n\n            def de_boor(t, k, i, x):\n                if k == 0:\n                    return x[i]\n                alpha = (t - knots[i])/(knots[i+k] - knots[i]) if knots[i+k] != knots[i] else 0\n                return (1.0 - alpha) * de_boor(t, k-1, i-1, x) + alpha * de_boor(t, k-1, i, x)\n\n            spline = []\n            for t in domain:\n                i = next(i for i in range(len(knots)-1) if knots[i] <= t < knots[i+1])\n                spline.append(tuple(de_boor(t, k, i, points_np)))\n            return spline\n\n        # Initialize best cost to infinite, update when path found\n        best_cost = float('inf')\n        connection_nodes = (None, None)\n        success = False\n\n        for iteration in range(self.max_iter):\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                if success:\n                    break\n\n                # Choose informed sampling with goal bias\n                sample_prob = random.random()\n                if sample_prob < self.goal_sample_rate:\n                    q_rand = goal_pos\n                else:\n                    q_rand = informed_sample(best_cost, dist(start_pos, goal_pos), start_pos, goal_pos)\n\n                nearest_node = nearest(tree_a, q_rand)\n                q_new_pos = steer(nearest_node.position, q_rand)\n\n                if is_in_obstacle(q_new_pos) or is_edge_in_obstacle(nearest_node.position, q_new_pos):\n                    continue\n\n                radius = adaptive_radius(len(tree_a))\n                near_nodes_a = near_nodes(tree_a, q_new_pos, radius)\n\n                # Choose parent minimizing cost\n                min_cost = nearest_node.cost + dist(nearest_node.position, q_new_pos)\n                min_parent = nearest_node\n                for near_n in near_nodes_a:\n                    c = near_n.cost + dist(near_n.position, q_new_pos)\n                    if c + 1e-10 < min_cost and not is_edge_in_obstacle(near_n.position, q_new_pos):\n                        min_cost = c\n                        min_parent = near_n\n\n                q_new = Node(q_new_pos, parent=min_parent, cost=min_cost)\n                min_parent.add_child(q_new)\n                tree_a.append(q_new)\n                nodes.append(q_new)\n                edges.append((min_parent, q_new))\n\n                rewire(tree_a, q_new, near_nodes_a)\n\n                # Attempt connection to other tree\n                nearest_other = nearest(tree_b, q_new.position)\n                dist_connect = dist(q_new.position, nearest_other.position)\n                radius_connect = max(self.step_size*1.5, adaptive_radius(len(tree_b)))\n\n                if dist_connect <= radius_connect and not is_edge_in_obstacle(q_new.position, nearest_other.position):\n                    # Trees connected\n                    if tree_a is start_tree:\n                        node_start, node_goal = q_new, nearest_other\n                    else:\n                        node_start, node_goal = nearest_other, q_new\n\n                    current_cost = node_start.cost + dist(node_start.position, node_goal.position) + node_goal.cost\n                    if current_cost < best_cost:\n                        best_cost = current_cost\n                        connection_nodes = (node_start, node_goal)\n                        success = True\n            if success:\n                break\n\n        raw_path = []\n        if success:\n            raw_path = extract_path(connection_nodes[0], connection_nodes[1])\n        else:\n            # fallback empty path on failure\n            return PlannerResult(False, [], nodes, edges)\n\n        # B-spline smoothing with collision checking along spline (dense checks)\n        smooth_path = raw_path\n        if len(raw_path) > self.smoothing_degree:\n            try:\n                # We implement smoothing only if numpy is available, else fallback raw_path\n                import numpy as np\n                spline_path = bspline(raw_path, degree=self.smoothing_degree, num=self.smoothing_points)\n                # Check collision for spline curve segments\n                collides = False\n                for i in range(len(spline_path)-1):\n                    if is_edge_in_obstacle(spline_path[i], spline_path[i+1]):\n                        collides = True\n                        break\n                if not collides:\n                    smooth_path = spline_path\n            except:\n                # If numpy not available, fallback to raw_path (no smoothing)\n                smooth_path = raw_path\n\n        return PlannerResult(success, smooth_path, nodes, edges)",
        "objective": -25.01284,
        "time_improvement": 66.0,
        "length_improvement": 7.0,
        "smoothness_improvement": 169.0,
        "node_improvement": 74.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.00990746021270752,
                "num_nodes_avg": 117.2,
                "path_length_avg": 177.87723139341853,
                "smoothness_avg": 0.016505675329957482,
                "success_improvement": 0.0,
                "time_improvement": 61.58530892215819,
                "node_improvement": 70.48602367161925,
                "length_improvement": 2.5026708281624948,
                "smoothness_improvement": 158.34966156149508,
                "objective_score": 20.768943481352427
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.014815974235534667,
                "num_nodes_avg": 199.2,
                "path_length_avg": 264.58410600917347,
                "smoothness_avg": 0.01090878033876496,
                "success_improvement": 0.0,
                "time_improvement": 91.05184234186756,
                "node_improvement": 86.61560169320701,
                "length_improvement": 11.67420978290656,
                "smoothness_improvement": 180.69077539330692,
                "objective_score": 35.223532449270735
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.027541279792785645,
                "num_nodes_avg": 285.0,
                "path_length_avg": 139.32127743918858,
                "smoothness_avg": 0.02116118022862008,
                "success_improvement": 0.0,
                "time_improvement": 45.72845269254134,
                "node_improvement": 63.76350921805467,
                "length_improvement": 7.469441291202562,
                "smoothness_improvement": 169.16865055219935,
                "objective_score": 19.046043835244934
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "m3",
        "algorithm_description": "A bidirectional, asymptotically optimal RRT* planner with recursive rewiring and goal biasing, enhanced by post-processing shortcut smoothing that respects curvature constraints to improve path smoothness and length. The planner grows two trees from start and goal, samples with a goal bias, rewire neighbors recursively upon better cost updates, and connects the trees to form a path. After a feasible path is found, it applies shortcut smoothing that skips nodes only if edges are collision-free and curvature transitions remain smooth.",
        "planning_mechanism": "The planner alternates sampling biased toward the goal to accelerate convergence. Each sampled point is connected via extend and rewiring within a radius with recursive cost propagation to optimize paths. It attempts to connect the two trees after each iteration. Upon success, the path is extracted and refined by shortcut smoothing that avoids sharp bends. This approach improves planning efficiency, path quality, robustness, and smoothness.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=7.0, radius=15.0, goal_sample_rate=0.1):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.radius = radius\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map):\n        import math, random\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = dim == 3\n\n        start_tree = [Node(start_pos, cost=0.0)]\n        goal_tree = [Node(goal_pos, cost=0.0)]\n        nodes = start_tree + goal_tree\n        edges = []\n        path_found = False\n        extracted_path = []\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def sample():\n            # Goal biasing\n            if random.random() < self.goal_sample_rate:\n                return goal_pos\n            else:\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        def is_in_obstacle(p):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d_ = obs\n                    px, py, pz = p\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d_:\n                        return True\n                else:\n                    x, y, w_, h_ = obs\n                    px, py = p\n                    if x <= px <= x + w_ and y <= py <= y + h_:\n                        return True\n            return False\n\n        def edge_in_collision(p1, p2, resolution=1.0):\n            length = dist(p1, p2)\n            if length == 0:\n                return False\n            steps = max(1, int(length / resolution))\n            for i in range(steps + 1):\n                interp = tuple(p1[d] + (p2[d] - p1[d]) * i / steps for d in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def steer(from_p, to_p):\n            l = dist(from_p, to_p)\n            if l <= self.step_size:\n                return to_p\n            ratio = self.step_size / l\n            return tuple(from_p[d] + (to_p[d] - from_p[d]) * ratio for d in range(dim))\n\n        def near_nodes(tree, point):\n            return [n for n in tree if dist(n.position, point) <= self.radius]\n\n        def update_costs_recursive(node):\n            for child in node.children:\n                old_cost = child.cost\n                child.cost = node.cost + dist(node.position, child.position)\n                if child.cost < old_cost:\n                    update_costs_recursive(child)\n\n        def rewire(tree, new_node, near):\n            for n in near:\n                if n == new_node.parent:\n                    continue\n                cost_through_new = new_node.cost + dist(new_node.position, n.position)\n                if cost_through_new + 1e-9 < n.cost and not edge_in_collision(new_node.position, n.position):\n                    # Rewire\n                    if n.parent:\n                        n.parent.remove_child(n)\n                    n.parent = new_node\n                    new_node.children.append(n)\n                    n.cost = cost_through_new\n                    update_costs_recursive(n)\n\n        def extract_path(node_start, node_goal):\n            path_start, path_goal = [], []\n            n = node_start\n            while n:\n                path_start.append(n.position)\n                n = n.parent\n            n = node_goal\n            while n:\n                path_goal.append(n.position)\n                n = n.parent\n            return path_start[::-1] + path_goal\n\n        def curvature_ok(p_a, p_b, p_c, max_angle_rad=math.pi/3):\n            # Check if angle between (p_b - p_a) and (p_c - p_b) is less than max_angle_rad\n            import math\n            import sys\n            def vec_sub(u,v): return tuple(u[i]-v[i] for i in range(dim))\n            def dot(u,v): return sum(u[i]*v[i] for i in range(dim))\n            def norm(u): return math.sqrt(dot(u,u)) if dot(u,u)>0 else sys.float_info.epsilon\n            v1 = vec_sub(p_b, p_a)\n            v2 = vec_sub(p_c, p_b)\n            nv1, nv2 = norm(v1), norm(v2)\n            if nv1 < 1e-9 or nv2 < 1e-9:\n                return True\n            cos_ang = max(min(dot(v1,v2)/(nv1*nv2),1.0),-1.0)\n            angle = math.acos(cos_ang)\n            return angle <= max_angle_rad\n\n        def shortcut_smooth(path):\n            if len(path) <= 2:\n                return path[:]\n            smoothed = [path[0]]\n            i = 0\n            while i < len(path) - 1:\n                j = len(path) - 1\n                while j > i+1:\n                    if (not edge_in_collision(path[i], path[j]) and\n                        (i == 0 or j == len(path)-1 or curvature_ok(path[i-1], path[i], path[j]))):\n                        break\n                    j -= 1\n                smoothed.append(path[j])\n                i = j\n            return smoothed\n\n        for _ in range(self.max_iter):\n            rnd = sample()\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest = min(tree_a, key=lambda n: dist(n.position, rnd))\n                new_pos = steer(nearest.position, rnd)\n                if is_in_obstacle(new_pos):\n                    continue\n                if edge_in_collision(nearest.position,new_pos):\n                    continue\n                new_cost = nearest.cost + dist(nearest.position, new_pos)\n                new_node = Node(new_pos)\n                near = near_nodes(tree_a, new_pos)\n\n                # Choose best parent among near nodes + nearest\n                min_cost = new_cost\n                min_parent = nearest\n                for n in near:\n                    c = n.cost + dist(n.position, new_pos)\n                    if c + 1e-9 < min_cost and not edge_in_collision(n.position, new_pos):\n                        min_cost = c\n                        min_parent = n\n\n                new_node.parent = min_parent\n                new_node.cost = min_cost\n                min_parent.children.append(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((min_parent, new_node))\n\n                # Rewire neighbors recursively\n                rewire(tree_a, new_node, near)\n\n                # Try connecting to other tree\n                nearest_other = min(tree_b, key=lambda n: dist(n.position, new_node.position))\n                d_connect = dist(nearest_other.position, new_node.position)\n                if d_connect <= self.step_size and not edge_in_collision(nearest_other.position, new_node.position):\n                    # Connected\n                    path_found = True\n                    if tree_a is start_tree:\n                        path = extract_path(new_node, nearest_other)\n                    else:\n                        path = extract_path(nearest_other, new_node)\n                    extracted_path = shortcut_smooth(path)\n                    return PlannerResult(True, extracted_path, nodes, edges)\n\n        return PlannerResult(False, [], nodes, edges)",
        "objective": -35.64002,
        "time_improvement": 66.0,
        "length_improvement": 17.0,
        "smoothness_improvement": 1142.0,
        "node_improvement": 77.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.013418364524841308,
                "num_nodes_avg": 105.3,
                "path_length_avg": 163.30511778147675,
                "smoothness_avg": 0.04521187767436088,
                "success_improvement": 0.0,
                "time_improvement": 47.9723040088006,
                "node_improvement": 73.48274993704356,
                "length_improvement": 10.489877208784566,
                "smoothness_improvement": 607.6640647675295,
                "objective_score": 23.72393785174857
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.019947743415832518,
                "num_nodes_avg": 236.7,
                "path_length_avg": 232.18703282615962,
                "smoothness_avg": 0.07544258669340698,
                "success_improvement": 0.0,
                "time_improvement": 87.95249302062508,
                "node_improvement": 84.09594839750049,
                "length_improvement": 22.489285309444394,
                "smoothness_improvement": 1841.1920947201538,
                "objective_score": 49.08527956545493
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.018858718872070312,
                "num_nodes_avg": 217.6,
                "path_length_avg": 124.53507272831978,
                "smoothness_avg": 0.0846802714315068,
                "success_improvement": 0.0,
                "time_improvement": 62.83789783466316,
                "node_improvement": 72.33312142403051,
                "length_improvement": 17.289734416755685,
                "smoothness_improvement": 977.1268021613082,
                "objective_score": 34.1108440112589
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "time_expert",
        "algorithm_description": "A focused bidirectional Informed RRT* planner with ellipsoidal informed sampling around the current best path to guide sampling toward promising regions, combined with efficient rewiring using cost-to-come and adaptive radius scaling for rapid convergence. After each successful tree connection, a deterministic global shortcutting post-process refines the path to significantly improve smoothness and path length. Progressive bidirectional expansion with dynamic goal biasing accelerates connection. This focused sampling and enhanced rewiring drastically reduces redundant exploration, cutting planning time while improving path quality and smoothness.",
        "planning_mechanism": "The planner grows two trees from start and goal, alternately expanding towards samples drawn within an ellipsoidal informed set bound by the current best solution cost. New nodes connect to the lowest-cost parent within an adaptive radius, with rewiring improving local paths. Upon successful connection, a deterministic global shortcutting removes unnecessary waypoints and smooths the path. This approach focuses search near the current best path, efficiently reducing exploration time while systematically improving path quality and smoothness.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except ValueError:\n            pass\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=3500, step_size=7.5, base_radius=22.0, goal_sample_rate=0.10):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.base_radius = base_radius\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map) -> 'PlannerResult':\n        import random, math\n\n        bounds = map.size\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        # Distance and linear interpolation helpers\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(fr, to):\n            d = dist(fr, to)\n            if d <= self.step_size:\n                return to\n            ratio = self.step_size / d\n            return tuple(fr[i] + (to[i] - fr[i]) * ratio for i in range(dim))\n\n        # Collision checking helpers\n        def is_in_obstacle(p):\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d_ = obs\n                    px,py,pz = p\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d_:\n                        return True\n                else:\n                    x,y,w,h = obs\n                    px,py = p\n                    if x <= px <= x+w and y <= py <= y+h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(fr, to, resolution=1.0):\n            d = dist(fr, to)\n            steps = max(1, int(d / resolution))\n            for i in range(steps+1):\n                interp = tuple(fr[j] + (to[j] - fr[j]) * i / steps for j in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        # Nearest and near node search (linear scan)\n        def nearest(tree, point):\n            return min(tree, key=lambda node: dist(node.position, point))\n\n        def near_nodes(tree, point, radius):\n            r2 = radius * radius\n            result = []\n            for n in tree:\n                cd = 0.0\n                for i in range(dim):\n                    d_ = n.position[i] - point[i]\n                    cd += d_*d_\n                    if cd > r2:\n                        break\n                else:\n                    result.append(n)\n            return result\n\n        # Adaptive rewiring radius based on tree size and dimension\n        def adaptive_radius(n):\n            n = max(n,1)\n            radius = self.base_radius * (math.log(n)/n)**(1.0/dim)\n            min_radius = self.step_size * 1.7\n            return max(radius, min_radius)\n\n        # Rewire tree edges for better parent selection\n        def rewire(tree, new_node, near_nodes_):\n            nonlocal edges\n            for near in near_nodes_:\n                if near is new_node.parent:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, near.position)\n                if new_cost + 1e-10 < near.cost:\n                    if not is_edge_in_obstacle(new_node.position, near.position):\n                        # Remove old edge\n                        if near.parent is not None:\n                            try:\n                                edges.remove((near.parent, near))\n                                near.parent.remove_child(near)\n                            except Exception:\n                                pass\n                        near.parent = new_node\n                        near.cost = new_cost\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n\n        # Extract path joining two nodes' root paths\n        def extract_path(node_start, node_goal):\n            p1 = node_start.path_from_root()\n            p2 = node_goal.path_from_root()[::-1]\n            if p1 and p2 and p1[-1] == p2[0]:\n                p2 = p2[1:]\n            return p1 + p2\n\n        # Compute minimum possible cost heuristic for Informed Sampling \n        def straight_dist(a,b):\n            return dist(a,b)\n\n        # Elliptical informed sampling, samples inside ellipsoid between start and goal w.r.t current best cost.\n        def informed_sample(c_best):\n            # If no path, sample uniformly\n            if c_best == math.inf:\n                return tuple(random.uniform(0,bounds[i]) for i in range(dim))\n            # Positions as vectors\n            c_min = straight_dist(start_pos, goal_pos)\n            if c_best < c_min:\n                # Numerical fallback to uniform\n                return tuple(random.uniform(0,bounds[i]) for i in range(dim))\n            # Transform sample inside unit ball to ellipsoidal space\n            from math import sqrt, sin, cos, pi\n            # Build rotation matrix aligning the main axis along start->goal\n            # For 2D only for simplicity\n            if dim == 2:\n                dx = goal_pos[0]-start_pos[0]\n                dy = goal_pos[1]-start_pos[1]\n                theta = math.atan2(dy, dx)\n                r1 = c_best / 2.0\n                if c_best == 0:\n                    r2 = 0\n                else:\n                    r2 = sqrt(c_best**2 - c_min**2)/2.0\n\n                for _ in range(10):  # try 10 samples max\n                    # Sample random point inside unit circle\n                    u, v = random.uniform(-1,1), random.uniform(-1,1)\n                    if u*u + v*v > 1.0:\n                        continue\n                    # Scale to ellipse radii\n                    x_ball = u * r1\n                    y_ball = v * r2\n                    # Rotate and translate center to midpoint\n                    x_ellipse = math.cos(theta)*x_ball - math.sin(theta)*y_ball + (start_pos[0]+goal_pos[0])/2.0\n                    y_ellipse = math.sin(theta)*x_ball + math.cos(theta)*y_ball + (start_pos[1]+goal_pos[1])/2.0\n                    # Check bounds\n                    if 0 <= x_ellipse <= bounds[0] and 0 <= y_ellipse <= bounds[1]:\n                        return (x_ellipse, y_ellipse)\n                # fallback uniform\n                return tuple(random.uniform(0,bounds[i]) for i in range(dim))\n            else:\n                # For 3D or others: uniform fallback for performance\n                return tuple(random.uniform(0,bounds[i]) for i in range(dim))\n\n        # Deterministic global shortcutting to remove intermediary nodes where line is obstacle free\n        def global_shortcut(path):\n            if len(path) < 3:\n                return path[:]\n            new_path = [path[0]]\n            idx = 0\n            while idx < len(path)-1:\n                next_idx = len(path)-1\n                # find farthest reachable node in path without collision\n                for j in range(len(path)-1, idx, -1):\n                    if not is_edge_in_obstacle(path[idx], path[j]):\n                        next_idx = j\n                        break\n                new_path.append(path[next_idx])\n                idx = next_idx\n            return new_path\n\n        # Initialize trees and tracking variables\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        best_cost = math.inf\n        connection_start = connection_goal = None\n        success = False\n\n        # Alternate expansion: 0 for start_tree, 1 for goal_tree\n        tree_switch = 0\n\n        for itr in range(self.max_iter):\n            tree_a = start_tree if tree_switch == 0 else goal_tree\n            tree_b = goal_tree if tree_switch == 0 else start_tree\n            tree_switch = 1 - tree_switch\n\n            # Sample point: goal bias or informed sample around best path cost\n            if best_cost < math.inf and random.random() > self.goal_sample_rate:\n                q_rand = informed_sample(best_cost)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    q_rand = goal_pos if tree_a is start_tree else start_pos\n                else:\n                    q_rand = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n\n            nearest_node = nearest(tree_a, q_rand)\n            q_new_pos = steer(nearest_node.position, q_rand)\n            if is_in_obstacle(q_new_pos):\n                continue\n            if is_edge_in_obstacle(nearest_node.position, q_new_pos):\n                continue\n\n            # Determine near nodes for parent selection and rewiring\n            radius = adaptive_radius(len(tree_a))\n            near_nodes_a = near_nodes(tree_a, q_new_pos, radius)\n\n            # Parent selection: minimum cost that yields collision free edge\n            min_cost = nearest_node.cost + dist(nearest_node.position, q_new_pos)\n            min_parent = nearest_node\n            for near in near_nodes_a:\n                cost_candidate = near.cost + dist(near.position, q_new_pos)\n                if cost_candidate + 1e-10 < min_cost and not is_edge_in_obstacle(near.position, q_new_pos):\n                    min_cost = cost_candidate\n                    min_parent = near\n\n            q_new = Node(q_new_pos, parent=min_parent, cost=min_cost)\n            min_parent.add_child(q_new)\n            tree_a.append(q_new)\n            nodes.append(q_new)\n            edges.append((min_parent, q_new))\n\n            # Rewire around new node for improved paths\n            rewire(tree_a, q_new, near_nodes_a)\n\n            # Check connection to other tree\n            nearest_other = nearest(tree_b, q_new.position)\n            d_connect = dist(q_new.position, nearest_other.position)\n            radius_conn = max(self.step_size*1.7, adaptive_radius(len(tree_b)))\n            if d_connect <= radius_conn and not is_edge_in_obstacle(q_new.position, nearest_other.position):\n                # Connection found\n                if tree_a is start_tree:\n                    connection_start, connection_goal = q_new, nearest_other\n                else:\n                    connection_start, connection_goal = nearest_other, q_new\n\n                raw_path = extract_path(connection_start, connection_goal)\n                path_cost = 0.0\n                for i in range(len(raw_path)-1):\n                    path_cost += dist(raw_path[i], raw_path[i+1])\n                if path_cost + 1e-10 < best_cost:\n                    best_cost = path_cost\n                    # Deterministic global shortcut for smoothness and length improvement\n                    improved_path = global_shortcut(raw_path)\n                    success = True\n                    # Stop early to return best found path\n                    return self._result(True, improved_path, nodes, edges)\n\n        # If no direct connection found but partial paths exist, attempt best partial path smoothing\n        if connection_start and connection_goal:\n            raw_path = extract_path(connection_start, connection_goal)\n            improved_path = global_shortcut(raw_path)\n            return self._result(True, improved_path, nodes, edges)\n\n        # No path found at all\n        return self._result(False, [], nodes, edges)\n\n    def _result(self, success, path, nodes, edges):\n        return PlannerResult(success, path, nodes, edges)",
        "objective": -35.64856,
        "time_improvement": 62.0,
        "length_improvement": 16.0,
        "smoothness_improvement": 1513.0,
        "node_improvement": 79.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.010542154312133789,
                "num_nodes_avg": 74.4,
                "path_length_avg": 168.37361962619414,
                "smoothness_avg": 0.055376394290867416,
                "success_improvement": 0.0,
                "time_improvement": 59.12437774151948,
                "node_improvement": 81.26416519768321,
                "length_improvement": 7.711751032143607,
                "smoothness_improvement": 766.7608224169738,
                "objective_score": 26.198168053826876
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.015135645866394043,
                "num_nodes_avg": 175.4,
                "path_length_avg": 235.62763018068162,
                "smoothness_avg": 0.09300366993397884,
                "success_improvement": 0.0,
                "time_improvement": 90.8587755812018,
                "node_improvement": 88.21474165154875,
                "length_improvement": 21.340714880401087,
                "smoothness_improvement": 2293.05141523706,
                "objective_score": 51.52731867878649
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.0327984094619751,
                "num_nodes_avg": 254.1,
                "path_length_avg": 122.41329750020927,
                "smoothness_avg": 0.1240597817209133,
                "success_improvement": 0.0,
                "time_improvement": 35.36900085553568,
                "node_improvement": 67.69230769230768,
                "length_improvement": 18.698916495187646,
                "smoothness_improvement": 1478.0312663494665,
                "objective_score": 29.220206485520627
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "m2",
        "algorithm_description": "A hybrid bidirectional RRT* planner that integrates adaptive radius rewiring driven by both node density and path quality, employs a hybrid sampling strategy blending uniform and ellipsoidal informed sampling to balance exploration and exploitation, dynamically adjusts connection thresholds, and combines incremental shortcutting with periodic global smoothing to enhance path smoothness and length without excessive overhead. The planner efficiently expands two trees with optimized nearest/near searches, performs rewiring focused on cost improvements within dynamic neighborhoods, and applies post-planning smoothing to quickly converge to high-quality, smooth paths with reduced search time.",
        "planning_mechanism": "The planner grows start and goal trees bidirectionally with a hybrid sampling strategy: samples are drawn either uniformly or inside an ellipsoidal informed subset guided by the best path cost to focus the search adaptively. The connection and rewiring radius adapts based on both node density and the quality of current best solution, limiting unnecessary rewiring. Each new node connects optimally to the nearest feasible parent and attempts rewiring nearby nodes if cost improvement can be achieved. Shortcutting and smoothing are applied incrementally immediately after improvements and globally periodically, balancing computational cost and quality. Nearest and near neighbor computations use efficient caching and early exits to reduce overhead, and edge collision checks are done carefully to prevent invalid expansions. The planner stops early upon reaching significant improvements, yielding faster planning times, shorter, and smoother paths.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n    def add_child(self, child):\n        self.children.append(child)\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except ValueError:\n            pass\nclass Planner:\n    def __init__(self, max_iter=4500, step_size=6.0, gamma=40.0,\n                 max_shortcut_attempts=60, batch_smooth_freq=40, hybrid_sample_ratio=0.6):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.gamma = gamma\n        self.max_shortcut_attempts = max_shortcut_attempts\n        self.batch_smooth_freq = batch_smooth_freq\n        self.hybrid_sample_ratio = hybrid_sample_ratio  # ratio to choose ellipsoidal informed sampling\n\n    def plan(self, map):\n        import random\n        import math\n\n        bounds = map.size\n        obstacles = map.obstacles\n        start_pos = map.start\n        goal_pos = map.goal\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        all_nodes = start_tree + goal_tree\n        edges = []\n\n        best_cost = float('inf')\n        solution_start = None\n        solution_goal = None\n\n        c_min = max(math.dist(start_pos, goal_pos), 1e-10)  # prevent division by zero\n\n        def unit_ball_volume(d):\n            from math import gamma, pi\n            if d == 2:\n                return pi\n            elif d == 3:\n                return 4.0/3.0 * pi\n            else:\n                return (pi ** (d / 2)) / gamma(d / 2 + 1)\n\n        def compute_radius(num_nodes, c_best):\n            if num_nodes <= 1:\n                return self.step_size * 3.5\n            vol = 1.0\n            for b in bounds:\n                vol *= b\n            unit_vol = unit_ball_volume(dim)\n            radius = self.gamma * ((math.log(num_nodes) / num_nodes) ** (1.0/dim))\n            radius = max(radius, self.step_size)\n            # also adapt radius based on current best cost; smaller radius for smaller cost (focus exploration)\n            if c_best < float('inf'):\n                radius = min(radius, self.step_size * 1.2 * (c_best / c_min))\n            max_radius = max(bounds) * 0.5\n            return max(min(radius, max_radius), self.step_size)\n\n        def steer(from_pos, to_pos, max_step):\n            dist = 0.0\n            for i in range(dim):\n                diff = to_pos[i] - from_pos[i]\n                dist += diff*diff\n            dist = dist ** 0.5\n            if dist <= max_step:\n                return to_pos\n            ratio = max_step / dist\n            return tuple(from_pos[i] + ratio * (to_pos[i] - from_pos[i]) for i in range(dim))\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d = obs\n                    px,py,pz = pos\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                        return True\n                else:\n                    x,y,w,h = obs\n                    px,py = pos\n                    if x <= px <= x+w and y <= py <= y+h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(from_pos, to_pos, resolution=1.0):\n            import math\n            dist = 0.0\n            for i in range(dim):\n                diff = to_pos[i] - from_pos[i]\n                dist += diff*diff\n            dist = dist ** 0.5\n            steps = max(1, int(dist / resolution))\n            for step in range(steps+1):\n                interp = tuple(from_pos[i] + (to_pos[i]-from_pos[i])*(step/steps) for i in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def nearest(tree, point):\n            # linear but with early pruning of distances above best threshold (if available)\n            best_node = None\n            best_dist = float('inf')\n            px, py, pz = (point + (0,))[:3] if dim == 3 else (point[0], point[1], 0)\n            for node in tree:\n                d = 0.0\n                np_ = node.position\n                for i in range(dim):\n                    diff = np_[i] - point[i]\n                    d += diff*diff\n                    if d > best_dist:\n                        break\n                if d < best_dist:\n                    best_dist = d\n                    best_node = node\n            return best_node\n\n        def near(tree, point, radius_):\n            r_sq = radius_ * radius_\n            res = []\n            for n in tree:\n                d = 0.0\n                for i in range(dim):\n                    diff = n.position[i] - point[i]\n                    d += diff*diff\n                    if d > r_sq:\n                        break\n                if d <= r_sq:\n                    res.append(n)\n            return res\n\n        def extract_path(n_start, n_goal):\n            path_start = []\n            cur = n_start\n            while cur is not None:\n                path_start.append(cur.position)\n                cur = cur.parent\n            path_start.reverse()\n            path_goal = []\n            cur = n_goal\n            while cur is not None:\n                path_goal.append(cur.position)\n                cur = cur.parent\n            # avoid duplication\n            if path_goal and path_start and path_start[-1] == path_goal[0]:\n                path_goal = path_goal[1:]\n            return path_start + path_goal\n\n        def hybrid_sample():\n            # probabilistically choose ellipsoidal informed sampling or uniform sampling\n            if best_cost < float('inf') and random.random() < self.hybrid_sample_ratio:\n                return informed_sample()\n            return uniform_sample()\n\n        def uniform_sample():\n            while True:\n                pt = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not is_in_obstacle(pt):\n                    return pt\n\n        def informed_sample():\n            # sample uniformly inside ellipsoid defined by start, goal, and best_cost\n            center = tuple((start_pos[i] + goal_pos[i]) * 0.5 for i in range(dim))\n            dir_vec = [goal_pos[i] - start_pos[i] for i in range(dim)]\n            length_line = math.dist(start_pos, goal_pos)\n            if length_line < 1e-15:\n                return uniform_sample()\n            # Compute rotation matrix aligning x-axis with dir_vec\n            if dim == 2:\n                from math import cos, sin, pi, sqrt\n                norm = length_line\n                a1 = [1.0, 0.0]\n                a2 = [dir_vec[0]/norm, dir_vec[1]/norm]\n                cos_theta = a1[0]*a2[0] + a1[1]*a2[1]\n                sin_theta = a1[0]*a2[1] - a1[1]*a2[0]\n                R = [[cos_theta, -sin_theta], [sin_theta, cos_theta]]\n            else:\n                from math import sqrt\n                norm = length_line\n                a1 = [1.0, 0.0, 0.0]\n                norm_dir = [dir_vec[i]/norm for i in range(3)]\n                v = [a1[1]*norm_dir[2] - a1[2]*norm_dir[1],\n                     a1[2]*norm_dir[0] - a1[0]*norm_dir[2],\n                     a1[0]*norm_dir[1] - a1[1]*norm_dir[0]]\n                s = sqrt(sum(x*x for x in v))\n                c = sum(a1[i]*norm_dir[i] for i in range(3))\n                if s < 1e-15:\n                    R = [[1.0,0.0,0.0],[0.0,1.0,0.0],[0.0,0.0,1.0]]\n                else:\n                    vx = [[0,-v[2],v[1]],\n                          [v[2],0,-v[0]],\n                          [-v[1],v[0],0]]\n                    I = [[1 if i==j else 0 for j in range(3)] for i in range(3)]\n                    vx2 = [[sum(vx[i][k]*vx[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n                    R = [[I[i][j] + vx[i][j] + vx2[i][j]*((1-c)/(s*s)) for j in range(3)] for i in range(3)]\n            a1_val = best_cost / 2.0\n            a2_val = math.sqrt(max(best_cost*best_cost - c_min*c_min,0)) / 2.0\n\n            while True:\n                if dim == 2:\n                    r = random.random() ** 0.5\n                    theta = random.uniform(0, 2*math.pi)\n                    x_ball = [r*math.cos(theta), r*math.sin(theta)]\n                    L = [[a1_val, 0.0],[0.0,a2_val]]\n                    x_scaled = [L[0][0]*x_ball[0]+L[0][1]*x_ball[1],\n                                L[1][0]*x_ball[0]+L[1][1]*x_ball[1]]\n                    pt = (center[0] + R[0][0]*x_scaled[0] + R[0][1]*x_scaled[1],\n                          center[1] + R[1][0]*x_scaled[0] + R[1][1]*x_scaled[1])\n                else:\n                    while True:\n                        x_ball = [random.uniform(-1.0,1.0) for _ in range(3)]\n                        if sum(xi*xi for xi in x_ball) <= 1.0:\n                            break\n                    L = [[a1_val,0.0,0.0],[0.0,a2_val,0.0],[0.0,0.0,a2_val]]\n                    x_scaled = [L[0][0]*x_ball[0], L[1][1]*x_ball[1], L[2][2]*x_ball[2]]\n                    pt = tuple(center[i] + sum(R[i][j]*x_scaled[j] for j in range(dim)) for i in range(dim))\n                if any(pt[i] < 0 or pt[i] > bounds[i] for i in range(dim)):\n                    continue\n                if is_in_obstacle(pt):\n                    continue\n                return pt\n\n        def rewire_near(tree, new_node, radius_):\n            near_nodes = near(tree, new_node.position, radius_)\n            for n in near_nodes:\n                if n is new_node or n.parent is None:\n                    continue\n                cost_through_new = new_node.cost + math.dist(new_node.position, n.position)\n                if cost_through_new + 1e-9 < n.cost:\n                    if not is_edge_in_obstacle(new_node.position, n.position):\n                        if n.parent:\n                            try:\n                                edges.remove((n.parent,n))\n                            except ValueError:\n                                pass\n                            n.parent.remove_child(n)\n                        n.parent = new_node\n                        n.cost = cost_through_new\n                        new_node.add_child(n)\n                        edges.append((new_node,n))\n\n        def incremental_shortcut(path):\n            if len(path) < 3:\n                return path[:]\n            attempts = 0\n            new_path = path[:]\n            while attempts < self.max_shortcut_attempts:\n                if len(new_path) < 3:\n                    break\n                i = random.randint(0, len(new_path) - 3)\n                j = random.randint(i+2, len(new_path)-1)\n                if not is_edge_in_obstacle(new_path[i], new_path[j]):\n                    new_path = new_path[:i+1] + new_path[j:]\n                    attempts = 0\n                else:\n                    attempts += 1\n            return new_path\n\n        def batch_smooth(path):\n            # global smoothing by iterative shortcutting multiple times (lightweight)\n            for _ in range(self.max_shortcut_attempts // 3):\n                path = incremental_shortcut(path)\n            return path\n\n        prev_dir = None\n        import time\n        for it in range(self.max_iter):\n            sample = hybrid_sample()\n\n            for treeA, treeB in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest_node = nearest(treeA, sample)\n                new_pos = None\n                if prev_dir is None:\n                    new_pos = steer(nearest_node.position, sample, self.step_size)\n                else:\n                    # basic momentum steering: push step further along previous direction with clipping by bounds\n                    dist = math.dist(nearest_node.position, sample)\n                    if dist < 1e-10:\n                        new_pos = nearest_node.position\n                    else:\n                        direction = tuple((sample[i] - nearest_node.position[i]) / dist for i in range(dim))\n                        base_step = min(self.step_size, dist)\n                        candidate = tuple(nearest_node.position[i] + direction[i]*base_step for i in range(dim))\n                        momentum_step = 0.5 * self.step_size\n                        momentum_candidate = tuple(candidate[i] + direction[i]*momentum_step for i in range(dim))\n                        if all(0 <= momentum_candidate[i] <= bounds[i] for i in range(dim)) and (not is_in_obstacle(momentum_candidate)) and (not is_edge_in_obstacle(nearest_node.position, momentum_candidate)):\n                            new_pos = momentum_candidate\n                        else:\n                            new_pos = candidate\n\n                if is_in_obstacle(new_pos) or is_edge_in_obstacle(nearest_node.position, new_pos):\n                    continue\n\n                new_node = Node(new_pos)\n                cur_tree_size = len(treeA)\n                r = compute_radius(cur_tree_size, best_cost)\n                near_nodes = near(treeA, new_pos, r)\n\n                # choose parent with minimal cost and collision-free edge\n                min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n                min_parent = nearest_node\n                for near_node in near_nodes:\n                    if near_node is nearest_node:\n                        continue\n                    cost_cand = near_node.cost + math.dist(near_node.position, new_pos)\n                    if cost_cand + 1e-9 < min_cost:\n                        if not is_edge_in_obstacle(near_node.position, new_pos):\n                            min_cost = cost_cand\n                            min_parent = near_node\n\n                new_node.parent = min_parent\n                new_node.cost = min_cost\n                min_parent.add_child(new_node)\n                treeA.append(new_node)\n                all_nodes.append(new_node)\n                edges.append((min_parent,new_node))\n\n                # rewiring for local improvements\n                rewire_near(treeA, new_node, r)\n\n                # Attempt to connect other tree\n                near_other = nearest(treeB, new_node.position)\n                dist_conn = math.dist(new_node.position, near_other.position)\n                if dist_conn <= self.step_size:\n                    if not is_edge_in_obstacle(new_node.position, near_other.position):\n                        total_cost = new_node.cost + dist_conn + near_other.cost\n                        if total_cost + 1e-9 < best_cost:\n                            best_cost = total_cost\n                            prev_dir = tuple(new_node.position[i] - near_other.position[i] for i in range(dim))\n                            if treeA is start_tree:\n                                solution_start, solution_goal = new_node, near_other\n                            else:\n                                solution_start, solution_goal = near_other, new_node\n\n                            raw_path = extract_path(solution_start, solution_goal)\n                            # incremental shortcut to improve path length and smoothness early\n                            improved_path = incremental_shortcut(raw_path)\n\n                            # periodic batch smoothing globally every batch_smooth_freq iterations\n                            if it > 0 and it % self.batch_smooth_freq == 0:\n                                improved_path = batch_smooth(improved_path)\n\n                            if len(improved_path) >= 2:\n                                return PlannerResult(True, improved_path, all_nodes, edges)\n\n            # occasional global smoothing to balance quality and runtime\n            if it > 0 and it % self.batch_smooth_freq == 0 and best_cost < float('inf') and solution_start and solution_goal:\n                raw_path = extract_path(solution_start, solution_goal)\n                global_smooth_path = batch_smooth(raw_path)\n                if len(global_smooth_path) >= 2:\n                    return PlannerResult(True, global_smooth_path, all_nodes, edges)\n\n        if best_cost < float('inf') and solution_start and solution_goal:\n            raw_path = extract_path(solution_start, solution_goal)\n            smooth_path = batch_smooth(raw_path)\n            if len(smooth_path) >= 2:\n                return PlannerResult(True, smooth_path, all_nodes, edges)\n\n        return PlannerResult(False, [], all_nodes, edges)",
        "objective": -33.88954,
        "time_improvement": 59.0,
        "length_improvement": 15.0,
        "smoothness_improvement": 1508.0,
        "node_improvement": 79.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.020911431312561034,
                "num_nodes_avg": 122.1,
                "path_length_avg": 166.8599976176567,
                "smoothness_avg": 0.04501337399602144,
                "success_improvement": 0.0,
                "time_improvement": 18.919061331459822,
                "node_improvement": 69.25207756232686,
                "length_improvement": 8.541391239898575,
                "smoothness_improvement": 604.5570511438806,
                "objective_score": 13.823338399096492
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.026242756843566896,
                "num_nodes_avg": 219.9,
                "path_length_avg": 242.31455542761552,
                "smoothness_avg": 0.10247909808740205,
                "success_improvement": 0.0,
                "time_improvement": 84.15059840904235,
                "node_improvement": 85.22475307397701,
                "length_improvement": 19.108426760503246,
                "smoothness_improvement": 2536.8610064996747,
                "objective_score": 49.39454061151302
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.013715672492980956,
                "num_nodes_avg": 149.1,
                "path_length_avg": 126.36313714813143,
                "smoothness_avg": 0.1165669065905579,
                "success_improvement": 0.0,
                "time_improvement": 72.97254251955964,
                "node_improvement": 81.04259376986649,
                "length_improvement": 16.07562107219008,
                "smoothness_improvement": 1382.7224477578577,
                "objective_score": 38.45074763797123
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "m3",
        "algorithm_description": "A streamlined bidirectional RRT* planner with adaptive neighborhood radius, integrated ellipsoidal informed sampling, and iterative incremental shortcutting combined with smoothing. It maintains a clean tree structure through careful rewiring with subtree cost updates and frequent connection attempts to improve solution quality progressively. Path refinement happens continuously during planning by applying shortcutting with adaptive angle thresholds and midpoint smoothing, enhancing smoothness and shortening path length while keeping planning time efficient.",
        "planning_mechanism": "The planner grows two trees from start and goal alternately, sampling informed points within an adaptive ellipsoidal region after an initial solution is found. It uses an adaptive rewiring radius based on node count and dimension to reconnect neighbors if a better path is found, with subtree costs updated accordingly. Frequent attempts connect the two trees. Incremental path shortcutting with an adaptive angle threshold and midpoint smoothing run periodically during planning to iteratively improve path smoothness and length. The algorithm balances exploration and exploitation using goal bias and informed sampling for efficient, high-quality, and smooth paths.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\nclass Planner:\n    def __init__(self, max_iter=4000, step_size=6.0, gamma=40.0, goal_sample_rate=0.1, \n                 shortcut_interval=40, max_shortcut_attempts=200):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.gamma = gamma\n        self.goal_sample_rate = goal_sample_rate\n        self.shortcut_interval = shortcut_interval\n        self.max_shortcut_attempts = max_shortcut_attempts\n\n    def plan(self, map):\n        import math\n        import random\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        best_cost = float('inf')\n        solution_start, solution_goal = None, None\n        c_min = math.dist(start_pos, goal_pos)\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def adaptive_radius(n_nodes):\n            if n_nodes <= 1:\n                return self.step_size * 3.0\n            val = (math.log(n_nodes) / n_nodes) ** (1.0 / dim)\n            return min(self.gamma * val, self.step_size * 40)\n\n        def sample():\n            # Goal biasing\n            if random.random() < self.goal_sample_rate:\n                return goal_pos\n            # Informed ellipsoidal sampling if solution found\n            if best_cost == float('inf') or best_cost <= c_min:\n                return self._sample_free(bounds, obstacles, is_3d)\n            center = tuple((start_pos[i]+goal_pos[i])*0.5 for i in range(dim))\n            dir_vec = [goal_pos[i]-start_pos[i] for i in range(dim)]\n            length = c_min\n            if dim == 2:\n                if length < 1e-14:\n                    R = [[1,0],[0,1]]\n                else:\n                    a1 = [1,0]\n                    a2 = [dir_vec[0]/length, dir_vec[1]/length]\n                    cos_t = a1[0]*a2[0] + a1[1]*a2[1]\n                    sin_t = a1[0]*a2[1] - a1[1]*a2[0]\n                    R = [[cos_t, -sin_t],[sin_t, cos_t]]\n            else:\n                from math import sqrt\n                if length < 1e-14:\n                    R = [[1,0,0],[0,1,0],[0,0,1]]\n                else:\n                    a1 = [1,0,0]\n                    a2 = [dir_vec[i]/length for i in range(3)]\n                    v = [a1[1]*a2[2]-a1[2]*a2[1], a1[2]*a2[0]-a1[0]*a2[2], a1[0]*a2[1]-a1[1]*a2[0]]\n                    s = sqrt(sum(x*x for x in v))\n                    c = sum(a1[i]*a2[i] for i in range(3))\n                    if s < 1e-14:\n                        R = [[1,0,0],[0,1,0],[0,0,1]]\n                    else:\n                        vx = [[0,-v[2],v[1]],[v[2],0,-v[0]],[-v[1],v[0],0]]\n                        I = [[1 if i==j else 0 for j in range(3)] for i in range(3)]\n                        vx2 = [[sum(vx[i][k]*vx[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n                        R = [[I[i][j] + vx[i][j] + vx2[i][j]*((1-c)/(s*s)) for j in range(3)] for i in range(3)]\n\n            a1_val = best_cost * 0.5\n            try:\n                term = best_cost*best_cost - c_min*c_min\n                a_other = math.sqrt(term)*0.5 if term > 0 else 0.0\n            except Exception:\n                a_other = 0.0\n\n            while True:\n                if dim == 2:\n                    r = random.uniform(0,1)**0.5\n                    theta = random.uniform(0,2*math.pi)\n                    ball = [r * math.cos(theta), r * math.sin(theta)]\n                    L = [[a1_val,0],[0,a_other]]\n                    x_scaled = [L[0][0]*ball[0], L[1][1]*ball[1]]\n                    pt = tuple(center[i] + sum(R[i][j]*x_scaled[j] for j in range(dim)) for i in range(dim))\n                else:\n                    while True:\n                        ball = [random.uniform(-1,1) for _ in range(3)]\n                        if sum(x*x for x in ball) <= 1:\n                            break\n                    L = [[a1_val,0,0],[0,a_other,0],[0,0,a_other]]\n                    x_scaled = [L[0][0]*ball[0], L[1][1]*ball[1], L[2][2]*ball[2]]\n                    pt = tuple(center[i] + sum(R[i][j]*x_scaled[j] for j in range(dim)) for i in range(dim))\n                if any(pt[d]<0.0 or pt[d]>bounds[d] for d in range(dim)):\n                    continue\n                if self._is_in_obstacle(pt, obstacles, is_3d):\n                    continue\n                return pt\n\n        def nearest(tree, point):\n            best = None\n            best_dist = float('inf')\n            for node in tree:\n                d = 0.0\n                for i in range(dim):\n                    diff = node.position[i] - point[i]\n                    d += diff*diff\n                    if d >= best_dist:\n                        break\n                if d < best_dist:\n                    best_dist = d\n                    best = node\n            return best\n\n        def near(tree, point, radius):\n            r2 = radius*radius\n            res = []\n            for node in tree:\n                d = 0.0\n                for i in range(dim):\n                    diff = node.position[i]-point[i]\n                    d += diff*diff\n                    if d > r2:\n                        break\n                if d <= r2:\n                    res.append(node)\n            return res\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            ratio = self.step_size / d\n            return tuple(from_pos[i] + (to_pos[i]-from_pos[i])*ratio for i in range(dim))\n\n        def update_subtree_costs(node):\n            stack = [node]\n            while stack:\n                current = stack.pop()\n                for c in current.children:\n                    new_cost = current.cost + dist(current.position, c.position)\n                    if new_cost + 1e-15 < c.cost:\n                        c.cost = new_cost\n                        stack.append(c)\n\n        def extract_path(node_start, node_goal):\n            path_start = []\n            n = node_start\n            while n is not None:\n                path_start.append(n.position)\n                n = n.parent\n            path_goal = []\n            n = node_goal\n            while n is not None:\n                path_goal.append(n.position)\n                n = n.parent\n            return path_start[::-1] + path_goal\n\n        def angle_between(a,b,c):\n            import math\n            ba = [a[i]-b[i] for i in range(dim)]\n            bc = [c[i]-b[i] for i in range(dim)]\n            lab = math.sqrt(sum(x*x for x in ba))\n            lbc = math.sqrt(sum(x*x for x in bc))\n            if lab < 1e-14 or lbc < 1e-14:\n                return 0.0\n            dotp = sum(ba[i]*bc[i] for i in range(dim))\n            val = max(min(dotp/(lab*lbc), 1.0), -1.0)\n            return math.acos(val)\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path[:]\n            new_path = path[:]\n            angle_base = math.pi * 160.0 / 180.0  # 160 degrees base angle\n            max_attempts = self.max_shortcut_attempts\n            attempts = 0\n            i = 0\n            while attempts < max_attempts and i < len(new_path)-2:\n                j = random.randint(i+2, len(new_path)-1)\n                if j <= i+1:\n                    attempts += 1\n                    i += 1\n                    continue\n                if not self._is_edge_in_obstacle(new_path[i], new_path[j], obstacles, is_3d):\n                    smooth = True\n                    if i > 0:\n                        a,b,c = new_path[i-1], new_path[i], new_path[j]\n                        if angle_between(a,b,c) < math.pi - angle_base:\n                            smooth = False\n                    if j < len(new_path)-1:\n                        a,b,c = new_path[i], new_path[j], new_path[j+1]\n                        if angle_between(a,b,c) < math.pi - angle_base:\n                            smooth = False\n                    if smooth:\n                        new_path = new_path[:i+1] + new_path[j:]\n                        i = 0\n                        attempts += 1\n                        continue\n                i += 1\n                attempts += 1\n            return new_path\n\n        def midpoint_smooth(path):\n            if len(path) < 4:\n                return path[:]\n            new_path = path[:]\n            changed = False\n            for i in range(1, len(new_path)-1):\n                a,b,c = new_path[i-1], new_path[i], new_path[i+1]\n                mid = tuple(0.5*(a[d] + c[d]) for d in range(dim))\n                if (not self._is_in_obstacle(mid, obstacles, is_3d) and \n                    not self._is_edge_in_obstacle(a, mid, obstacles, is_3d) and\n                    not self._is_edge_in_obstacle(mid, c, obstacles, is_3d)):\n                    old_angle = angle_between(a,b,c)\n                    new_angle = angle_between(a,mid,c)\n                    if new_angle < old_angle + 1e-8:\n                        new_path[i] = mid\n                        changed = True\n            return new_path if changed else path\n\n        def attempt_extend(tree_from, tree_to, sample_point):\n            nearest_node = nearest(tree_from, sample_point)\n            new_pos = steer(nearest_node.position, sample_point)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                return None\n\n            r = adaptive_radius(len(tree_from))\n            near_nodes = near(tree_from, new_pos, r)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for candidate in near_nodes:\n                if candidate is nearest_node:\n                    continue\n                tentative_cost = candidate.cost + dist(candidate.position, new_pos)\n                if tentative_cost < min_cost:\n                    if not self._is_edge_in_obstacle(candidate.position, new_pos, obstacles, is_3d):\n                        min_cost = tentative_cost\n                        best_parent = candidate\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree_from.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            for nbr in near_nodes:\n                if nbr is best_parent or nbr is new_node:\n                    continue\n                cost_through_new = new_node.cost + dist(new_node.position, nbr.position)\n                if cost_through_new < nbr.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, nbr.position, obstacles, is_3d):\n                        if nbr.parent is not None:\n                            try:\n                                edges.remove((nbr.parent, nbr))\n                            except Exception:\n                                pass\n                            nbr.parent.remove_child(nbr)\n                        nbr.parent = new_node\n                        nbr.cost = cost_through_new\n                        new_node.add_child(nbr)\n                        edges.append((new_node, nbr))\n                        update_subtree_costs(nbr)\n\n            near_other = nearest(tree_to, new_node.position)\n            d = dist(new_node.position, near_other.position)\n            if d <= self.step_size:\n                if not self._is_edge_in_obstacle(new_node.position, near_other.position, obstacles, is_3d):\n                    total_cost = new_node.cost + d + near_other.cost\n                    if total_cost < best_cost:\n                        return new_node, near_other, total_cost\n            return None\n\n        for it in range(self.max_iter):\n            sample_pos = sample()\n\n            # Alternate between trees each iteration for extension\n            if it % 2 == 0:\n                tree_a, tree_b = start_tree, goal_tree\n            else:\n                tree_a, tree_b = goal_tree, start_tree\n\n            res = attempt_extend(tree_a, tree_b, sample_pos)\n            if res is not None:\n                new_node, conn_node, cost = res\n                if cost < best_cost:\n                    best_cost = cost\n                    if tree_a is start_tree:\n                        solution_start, solution_goal = new_node, conn_node\n                    else:\n                        solution_start, solution_goal = conn_node, new_node\n\n            if best_cost < float('inf') and solution_start and solution_goal:\n                if it % self.shortcut_interval == 0 or it == self.max_iter-1:\n                    raw_path = extract_path(solution_start, solution_goal)\n                    shortcut = shortcut_path(raw_path)\n                    smooth = midpoint_smooth(shortcut)\n                    return PlannerResult(True, smooth, nodes, edges)\n        return PlannerResult(False, [], nodes, edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        import random\n        while True:\n            pt = tuple(random.uniform(0, bounds[i]) for i in range(len(bounds)))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        px = pos[0]\n        py = pos[1]\n        pz = pos[2] if is_3d else 0.0\n        for obs in obstacles:\n            if is_3d:\n                x,y,z,w,h,d = obs\n                if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                    return True\n            else:\n                x,y,w,h = obs\n                if x <= px <= x+w and y <= py <= y+h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        dist_val = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist_val/resolution))\n        for step in range(steps+1):\n            t = step/steps\n            interp = tuple(from_pos[i] + t*(to_pos[i]-from_pos[i]) for i in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
        "objective": -34.04726,
        "time_improvement": 62.0,
        "length_improvement": 16.0,
        "smoothness_improvement": 1214.0,
        "node_improvement": 75.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.01619288921356201,
                "num_nodes_avg": 129.2,
                "path_length_avg": 165.2187501071947,
                "smoothness_avg": 0.0347659312496346,
                "success_improvement": 0.0,
                "time_improvement": 37.21450064479152,
                "node_improvement": 67.4641148325359,
                "length_improvement": 9.440985007613875,
                "smoothness_improvement": 444.16231948483625,
                "objective_score": 19.04975279542996
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.025137996673583983,
                "num_nodes_avg": 249.1,
                "path_length_avg": 235.60144924838568,
                "smoothness_avg": 0.08764785848268018,
                "success_improvement": 0.0,
                "time_improvement": 84.81782204336284,
                "node_improvement": 83.26278304105355,
                "length_improvement": 21.349454829177827,
                "smoothness_improvement": 2155.242528960084,
                "objective_score": 49.03123215531597
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.018967270851135254,
                "num_nodes_avg": 206.2,
                "path_length_avg": 125.32858322045142,
                "smoothness_avg": 0.0898739725367217,
                "success_improvement": 0.0,
                "time_improvement": 62.6239904232623,
                "node_improvement": 73.78258105530833,
                "length_improvement": 16.762722530791013,
                "smoothness_improvement": 1043.1902968605036,
                "objective_score": 34.06078212975582
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "time_expert",
        "algorithm_description": "Improved Bidirectional RRT* with Adaptive Radius and Incremental Local Smoothing Using Shortcutting for Fast, High-Quality, and Robust Path Planning",
        "planning_mechanism": "This planner enhances bidirectional RRT* by replacing expensive global B-spline smoothing with fast adaptive incremental smoothing via path shortcutting and partial rewiring focused on straight-line shortcuts, drastically reducing planning time while improving path length and smoothness. It uses informed sampling with goal bias, adaptive neighborhood radius for rewiring, efficient collision checks, and early termination upon connection. The local smoothing iteratively shortcuts path segments, checking collisions to maintain feasibility, thus providing smooth, short, and feasible paths efficiently.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def path_from_root(self):\n        node, path = self, []\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=3500, step_size=7.0, base_radius=20.0, goal_sample_rate=0.15,\n                 shortcut_attempts=40, shortcut_min_segment=2):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.base_radius = base_radius\n        self.goal_sample_rate = goal_sample_rate\n        self.shortcut_attempts = shortcut_attempts  # Number of incremental shortcut attempts on path\n        self.shortcut_min_segment = shortcut_min_segment  # Minimum segment length for shortcut trial\n\n    def plan(self, map):\n        import math\n        import random\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(fr, to):\n            d = dist(fr, to)\n            if d <= self.step_size:\n                return to\n            ratio = self.step_size / d\n            return tuple(fr[i] + (to[i] - fr[i]) * ratio for i in range(dim))\n\n        def is_in_obstacle(p):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d_ = obs\n                    px, py, pz = p\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d_:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    px, py = p\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(fr, to, resolution=1.0):\n            d = dist(fr, to)\n            steps = max(1, int(d / resolution))\n            for i in range(steps + 1):\n                interp = tuple(fr[j] + (to[j] - fr[j]) * i / steps for j in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: dist(node.position, point))\n\n        def near_nodes(tree, point, radius):\n            return [node for node in tree if dist(node.position, point) <= radius]\n\n        def rewire(tree, new_node, near_list):\n            nonlocal edges\n            for near in near_list:\n                if near == new_node.parent:\n                    continue\n                c = new_node.cost + dist(new_node.position, near.position)\n                if c + 1e-10 < near.cost and not is_edge_in_obstacle(new_node.position, near.position):\n                    old_parent = near.parent\n                    if old_parent:\n                        try:\n                            edges.remove((old_parent, near))\n                        except ValueError:\n                            pass\n                        old_parent.remove_child(near)\n                    near.parent = new_node\n                    near.cost = c\n                    new_node.add_child(near)\n                    edges.append((new_node, near))\n\n        def extract_path(node_start, node_goal):\n            path_start = node_start.path_from_root()\n            path_goal = node_goal.path_from_root()[::-1]\n            if len(path_start) > 0 and len(path_goal) > 0 and path_start[-1] == path_goal[0]:\n                path_goal = path_goal[1:]\n            return path_start + path_goal\n\n        def adaptive_radius(tree_size):\n            gamma = self.base_radius\n            n = max(tree_size, 1)\n            return max(gamma * (math.log(n) / n) ** (1.0 / dim), self.step_size * 1.5)\n\n        def informed_sample(c_best, c_min, start, goal):\n            if c_best == float('inf'):\n                return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n            c = c_best\n            center = tuple((start[i] + goal[i]) / 2 for i in range(dim))\n            a1 = tuple((goal[i] - start[i]) / c_min for i in range(dim))\n            if dim == 2:\n                theta = math.atan2(a1[1], a1[0])\n                r = [[math.cos(theta), -math.sin(theta)],\n                     [math.sin(theta), math.cos(theta)]]\n                while True:\n                    x, y = random.uniform(-1, 1), random.uniform(-1, 1)\n                    if x * x + y * y > 1:\n                        continue\n                    rx = c / 2\n                    ry = math.sqrt(max(c * c - c_min * c_min, 0)) / 2\n                    sample_ellipse = (x * rx, y * ry)\n                    px = r[0][0] * sample_ellipse[0] + r[0][1] * sample_ellipse[1] + center[0]\n                    py = r[1][0] * sample_ellipse[0] + r[1][1] * sample_ellipse[1] + center[1]\n                    if 0 <= px <= bounds[0] and 0 <= py <= bounds[1]:\n                        return (px, py)\n            else:\n                return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n\n        # Incremental shortcut smoothing for path improvement\n        def incremental_shortcut(path):\n            if len(path) < 3:\n                return path[:]\n            path_pts = list(path)\n            for _ in range(self.shortcut_attempts):\n                if len(path_pts) < 3:\n                    break\n                i = random.randint(0, len(path_pts) - self.shortcut_min_segment - 1)\n                j = random.randint(i + self.shortcut_min_segment, len(path_pts) - 1)\n                p_i = path_pts[i]\n                p_j = path_pts[j]\n                if not is_edge_in_obstacle(p_i, p_j):\n                    # Shortcut feasible, remove intermediate points\n                    path_pts = path_pts[:i + 1] + path_pts[j:]\n            return path_pts\n\n        best_cost = float('inf')\n        connection_nodes = (None, None)\n        success = False\n\n        for iteration in range(self.max_iter):\n            if success:\n                break\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                if success:\n                    break\n\n                sample_prob = random.random()\n                if sample_prob < self.goal_sample_rate:\n                    q_rand = goal_pos\n                else:\n                    q_rand = informed_sample(best_cost, dist(start_pos, goal_pos), start_pos, goal_pos)\n\n                nearest_node = nearest(tree_a, q_rand)\n                q_new_pos = steer(nearest_node.position, q_rand)\n\n                if is_in_obstacle(q_new_pos) or is_edge_in_obstacle(nearest_node.position, q_new_pos):\n                    continue\n\n                radius = adaptive_radius(len(tree_a))\n                near_nodes_a = near_nodes(tree_a, q_new_pos, radius)\n\n                # Parent selection minimizing cost + feasibility\n                min_cost = nearest_node.cost + dist(nearest_node.position, q_new_pos)\n                min_parent = nearest_node\n                for near_n in near_nodes_a:\n                    c = near_n.cost + dist(near_n.position, q_new_pos)\n                    if c + 1e-10 < min_cost and not is_edge_in_obstacle(near_n.position, q_new_pos):\n                        min_cost = c\n                        min_parent = near_n\n\n                q_new = Node(q_new_pos, parent=min_parent, cost=min_cost)\n                min_parent.add_child(q_new)\n                tree_a.append(q_new)\n                nodes.append(q_new)\n                edges.append((min_parent, q_new))\n\n                rewire(tree_a, q_new, near_nodes_a)\n\n                # Try connect opposite tree\n                nearest_other = nearest(tree_b, q_new.position)\n                dist_connect = dist(q_new.position, nearest_other.position)\n                radius_connect = max(self.step_size * 1.5, adaptive_radius(len(tree_b)))\n\n                if dist_connect <= radius_connect and not is_edge_in_obstacle(q_new.position, nearest_other.position):\n                    if tree_a is start_tree:\n                        node_start, node_goal = q_new, nearest_other\n                    else:\n                        node_start, node_goal = nearest_other, q_new\n\n                    current_cost = node_start.cost + dist(node_start.position, node_goal.position) + node_goal.cost\n                    if current_cost < best_cost:\n                        best_cost = current_cost\n                        connection_nodes = (node_start, node_goal)\n                        success = True\n            # Early stop if connected\n            if success:\n                break\n\n        raw_path = []\n        if success:\n            raw_path = extract_path(connection_nodes[0], connection_nodes[1])\n        else:\n            return PlannerResult(False, [], nodes, edges)\n\n        # Incremental shortcut smoothing with collision check, lightweight and fast\n        smooth_path = incremental_shortcut(raw_path)\n\n        return PlannerResult(True, smooth_path, nodes, edges)",
        "objective": -32.3085,
        "time_improvement": 66.0,
        "length_improvement": 12.0,
        "smoothness_improvement": 1013.0,
        "node_improvement": 73.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.013331365585327149,
                "num_nodes_avg": 130.7,
                "path_length_avg": 179.30420886519545,
                "smoothness_avg": 0.027773013783354228,
                "success_improvement": 0.0,
                "time_improvement": 48.30962934887612,
                "node_improvement": 67.08637622765046,
                "length_improvement": 1.7205218639765212,
                "smoothness_improvement": 334.70797577422024,
                "objective_score": 17.19874180191985
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.01947922706604004,
                "num_nodes_avg": 253.2,
                "path_length_avg": 241.43064090254697,
                "smoothness_avg": 0.0689551247796437,
                "success_improvement": 0.0,
                "time_improvement": 88.23545505178878,
                "node_improvement": 82.98730094738963,
                "length_improvement": 19.403502871040057,
                "smoothness_improvement": 1674.2650269490814,
                "objective_score": 46.48406337290607
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.019611549377441407,
                "num_nodes_avg": 254.3,
                "path_length_avg": 126.26508083854677,
                "smoothness_avg": 0.08886728614455755,
                "success_improvement": 0.0,
                "time_improvement": 61.354405538947546,
                "node_improvement": 67.66687857596949,
                "length_improvement": 16.140745404076515,
                "smoothness_improvement": 1030.3853202580356,
                "objective_score": 33.24269550542035
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "m1",
        "algorithm_description": "A bidirectional RRT* variant with a kd-tree-based nearest neighbor structure for efficient queries, ellipsoidal informed sampling to concentrate search around the best path, adaptive rewiring radius balancing exploration and exploitation, and a deferred global shortcut smoothing applied once a solution is found. The planner alternates expansion between the two trees, dynamically adjusts goal bias with iteration progress, and integrates collision checks before node/edge additions to ensure path validity and coherent tree structures, leading to improved planning time, path length, and smoothness.",
        "planning_mechanism": "The planner maintains two trees rooted at start and goal, performing expansions alternately. Each sample is drawn either from an informed ellipsoidal set biased by the current best path cost or via goal-biased sampling. kd-tree data structures enable fast nearest neighbor and radius-based neighbor retrievals. Parent selection and rewiring optimize path cost while collision checks maintain feasibility. Once a valid connection between trees appears, the planner reconstructs the combined path and applies global shortcutting for smoothness and length improvement before returning the result.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n    def add_child(self, child):\n        self.children.append(child)\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=3000, step_size=8.0, base_radius=25.0,\n                 goal_sample_rate=0.15, min_goal_sample_rate=0.05,\n                 goal_sample_decay=0.995, shortcut_iters=80):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.base_radius = base_radius\n        self.goal_sample_rate = goal_sample_rate\n        self.min_goal_sample_rate = min_goal_sample_rate\n        self.goal_sample_decay = goal_sample_decay\n        self.shortcut_iters = shortcut_iters\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def dist(a,b):\n            return math.dist(a,b)\n        def sq_dist(a,b):\n            return sum((a[i]-b[i])**2 for i in range(dim))\n        def in_bounds(p):\n            for i in range(dim):\n                if p[i]<0 or p[i]>bounds[i]:\n                    return False\n            return True\n        def is_in_obstacle(p):\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d_ = obs\n                    px,py,pz = p\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d_:\n                        return True\n                else:\n                    x,y,w_,h_ = obs\n                    px,py = p\n                    if x <= px <= x+w_ and y <= py <= y+h_:\n                        return True\n            return False\n        def edge_in_collision(fr,to, resolution=1.0):\n            length = dist(fr,to)\n            if length == 0: return False\n            steps = max(1, int(length/resolution))\n            for i in range(steps+1):\n                interp = tuple(fr[d] + (to[d]-fr[d])*i/steps for d in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n        def steer(fr,to):\n            length = dist(fr,to)\n            if length <= self.step_size:\n                return to\n            ratio = self.step_size / length\n            return tuple(fr[d] + (to[d] - fr[d]) * ratio for d in range(dim))\n\n        # Implement a simple k-d tree for efficient neighbor queries\n        class KDTree:\n            def __init__(self, points=None, depth=0):\n                self.axis = depth % dim\n                if not points:\n                    self.location = None\n                    self.left = None\n                    self.right = None\n                    self.nodes = []\n                    return\n                points = sorted(points, key=lambda n: n.position[self.axis])\n                median = len(points)//2\n                self.location = points[median]\n                self.left = KDTree(points[:median], depth+1) if median > 0 else None\n                self.right = KDTree(points[median+1:], depth+1) if median+1 < len(points) else None\n                self.nodes = None  # only in leaf-less nodes\n\n            def insert(self, node, depth=0):\n                if self.location is None:\n                    self.location = node\n                    self.left = None\n                    self.right = None\n                    return\n                axis = depth % dim\n                if node.position[axis] < self.location.position[axis]:\n                    if self.left is None:\n                        self.left = KDTree([node], depth+1)\n                    else:\n                        self.left.insert(node, depth+1)\n                else:\n                    if self.right is None:\n                        self.right = KDTree([node], depth+1)\n                    else:\n                        self.right.insert(node, depth+1)\n\n            def nearest(self, point, best=None, best_dist=float('inf'), depth=0):\n                if self.location is None:\n                    return best, best_dist\n                axis = depth % dim\n                here_dist = sq_dist(point, self.location.position)\n                if here_dist < best_dist:\n                    best = self.location\n                    best_dist = here_dist\n                diff = point[axis] - self.location.position[axis]\n                close, away = (self.left, self.right) if diff < 0 else (self.right, self.left)\n                if close is not None:\n                    best, best_dist = close.nearest(point, best, best_dist, depth+1)\n                if away is not None and diff*diff < best_dist:\n                    best, best_dist = away.nearest(point, best, best_dist, depth+1)\n                return best, best_dist\n\n            def radius_search(self, point, radius, results=None, depth=0):\n                if results is None:\n                    results = []\n                if self.location is None:\n                    return results\n                axis = depth % dim\n                dist_sq = sq_dist(point, self.location.position)\n                if dist_sq <= radius*radius:\n                    results.append(self.location)\n                diff = point[axis] - self.location.position[axis]\n                if self.left is not None and diff - radius <= 0:\n                    self.left.radius_search(point, radius, results, depth+1)\n                if self.right is not None and diff + radius >= 0:\n                    self.right.radius_search(point, radius, results, depth+1)\n                return results\n\n        def adaptive_radius(n_nodes):\n            n_nodes = max(n_nodes, 2)\n            gamma = self.base_radius\n            radius = gamma * (math.log(n_nodes)/n_nodes)**(1/dim)\n            return max(radius, self.step_size*1.5)\n\n        def ellipsoid_sample(start, goal, c_max):\n            if c_max == float('inf'):\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            center = tuple((start[d]+goal[d])*0.5 for d in range(dim))\n            diff = tuple(goal[d]-start[d] for d in range(dim))\n            dist_sg = dist(start, goal)\n            if dist_sg < 1e-100:\n                return tuple(random.uniform(0,bounds[d]) for d in range(dim))\n            unit_vec = tuple(diff[d]/dist_sg for d in range(dim))\n            if dim == 2:\n                import math\n                angle = math.atan2(unit_vec[1], unit_vec[0])\n                for _ in range(15):\n                    r1 = random.uniform(0,1)\n                    r2 = random.uniform(0,1)\n                    rx = r1 * c_max * 0.5\n                    ry = r2 * math.sqrt(c_max*c_max - dist_sg*dist_sg)*0.5\n                    x = rx * math.cos(angle) - ry * math.sin(angle)\n                    y = rx * math.sin(angle) + ry * math.cos(angle)\n                    sample = (center[0]+x, center[1]+y)\n                    if in_bounds(sample):\n                        return sample\n                return tuple(random.uniform(0,bounds[d]) for d in range(dim))\n            else:\n                rx = c_max*0.5\n                ry = rx*0.6\n                rz = rx*0.4\n                for _ in range(25):\n                    x = random.uniform(-rx, rx)\n                    y = random.uniform(-ry, ry)\n                    z = random.uniform(-rz, rz)\n                    sample = (center[0]+x, center[1]+y, center[2]+z)\n                    if in_bounds(sample):\n                        return sample\n                return tuple(random.uniform(0,bounds[d]) for d in range(dim))\n\n        def extract_path(node_start, node_goal):\n            path_start = node_start.path_from_root()\n            path_goal = node_goal.path_from_root()[::-1]\n            if path_start and path_goal and path_start[-1] == path_goal[0]:\n                path_goal = path_goal[1:]\n            return path_start + path_goal\n\n        def global_shortcut(path):\n            if len(path) < 3:\n                return path[:]\n            p = path[:]\n            for _ in range(self.shortcut_iters):\n                if len(p) < 3:\n                    break\n                i = random.randint(0, len(p)-3)\n                j = random.randint(i+2, len(p)-1)\n                if not edge_in_collision(p[i], p[j]):\n                    p = p[:i+1] + p[j:]\n            return p\n\n        # Initialize trees and kd-trees\n        start_root = Node(start_pos)\n        goal_root = Node(goal_pos)\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n        all_nodes = start_tree + goal_tree\n        edges = []\n\n        kd_start = KDTree([start_root])\n        kd_goal = KDTree([goal_root])\n\n        best_cost = float('inf')\n        connection = None\n        goal_bias = self.goal_sample_rate\n\n        for it in range(self.max_iter):\n            goal_bias = max(self.min_goal_sample_rate, goal_bias * self.goal_sample_decay)\n\n            for tree_a, tree_b, kd_a, kd_b in [(start_tree, goal_tree, kd_start, kd_goal),\n                                               (goal_tree, start_tree, kd_goal, kd_start)]:\n                c_max = best_cost if best_cost < float('inf') else float('inf')\n                if random.random() < goal_bias:\n                    sample = goal_pos\n                else:\n                    sample = ellipsoid_sample(start_pos, goal_pos, c_max)\n                if is_in_obstacle(sample):\n                    continue\n\n                nearest_node, _ = kd_a.nearest(sample)\n                if nearest_node is None:\n                    continue\n                new_pos = steer(nearest_node.position, sample)\n                if not in_bounds(new_pos) or is_in_obstacle(new_pos) or edge_in_collision(nearest_node.position, new_pos):\n                    continue\n                radius = adaptive_radius(len(tree_a)+1)\n                near_nodes = kd_a.radius_search(new_pos, radius)\n\n                min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n                min_parent = nearest_node\n                for nb in near_nodes:\n                    if nb == nearest_node:\n                        continue\n                    cand_cost = nb.cost + dist(nb.position, new_pos)\n                    if cand_cost + 1e-9 < min_cost and not edge_in_collision(nb.position, new_pos):\n                        min_cost = cand_cost\n                        min_parent = nb\n\n                new_node = Node(new_pos, parent=min_parent, cost=min_cost)\n                min_parent.add_child(new_node)\n                tree_a.append(new_node)\n                all_nodes.append(new_node)\n                edges.append((min_parent, new_node))\n                kd_a.insert(new_node)\n\n                # Rewire near nodes through new_node if improvement\n                for nb in near_nodes:\n                    if nb == min_parent:\n                        continue\n                    new_cost = new_node.cost + dist(new_node.position, nb.position)\n                    if new_cost + 1e-9 < nb.cost and not edge_in_collision(new_node.position, nb.position):\n                        old_parent = nb.parent\n                        if old_parent:\n                            old_parent.remove_child(nb)\n                            try:\n                                edges.remove((old_parent, nb))\n                            except ValueError:\n                                pass\n                        nb.parent = new_node\n                        nb.cost = new_cost\n                        new_node.add_child(nb)\n                        edges.append((new_node, nb))\n\n                # Attempt connection with other tree - nearest node within step_size\n                near_other = kd_b.radius_search(new_node.position, self.step_size*1.5)\n                for node_other in near_other:\n                    if dist(new_node.position, node_other.position) <= self.step_size:\n                        if not edge_in_collision(new_node.position, node_other.position):\n                            total_cost = new_node.cost + dist(new_node.position, node_other.position) + node_other.cost\n                            if total_cost + 1e-9 < best_cost:\n                                best_cost = total_cost\n                                if tree_a is start_tree:\n                                    connection = (new_node, node_other)\n                                else:\n                                    connection = (node_other, new_node)\n\n            if connection is not None:\n                break\n\n        if connection is None:\n            return PlannerResult(False, [], all_nodes, edges)\n\n        raw_path = extract_path(connection[0], connection[1])\n        smooth_path = global_shortcut(raw_path)\n\n        return PlannerResult(True, smooth_path, all_nodes, edges)",
        "objective": -35.67144,
        "time_improvement": 62.0,
        "length_improvement": 15.0,
        "smoothness_improvement": 1613.0,
        "node_improvement": 80.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.017667293548583984,
                "num_nodes_avg": 101.7,
                "path_length_avg": 166.13517920479458,
                "smoothness_avg": 0.03625333347975132,
                "success_improvement": 0.0,
                "time_improvement": 31.497718963341637,
                "node_improvement": 74.38932258876858,
                "length_improvement": 8.938675697471036,
                "smoothness_improvement": 467.4433943318028,
                "objective_score": 17.149738079144125
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.0215378999710083,
                "num_nodes_avg": 201.5,
                "path_length_avg": 233.193267577381,
                "smoothness_avg": 0.1118364131236119,
                "success_improvement": 0.0,
                "time_improvement": 86.99211260077399,
                "node_improvement": 86.46106295773701,
                "length_improvement": 22.15337518662528,
                "smoothness_improvement": 2777.6314621829497,
                "objective_score": 53.277816203122114
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.016871142387390136,
                "num_nodes_avg": 164.8,
                "path_length_avg": 128.99936346398462,
                "smoothness_avg": 0.1331070185910396,
                "success_improvement": 0.0,
                "time_improvement": 66.75452233530704,
                "node_improvement": 79.04640813731724,
                "length_improvement": 14.324765076807733,
                "smoothness_improvement": 1593.1114515399127,
                "objective_score": 36.58677300437632
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "m3",
        "algorithm_description": "A streamlined bidirectional RRT* planner that combines adaptive ellipsoidal informed sampling focused around the current best path with dynamic rewiring considering cost and curvature penalties to reduce sharp turns. It employs efficient spatial hashing for neighbor queries, a balanced growth strategy alternating start and goal trees, and incremental path shortcutting applied periodically during planning to improve path smoothness and length. The algorithm maintains path quality and robustness while reducing planning time by concentrating search in promising regions and refining the tree topology incrementally.",
        "planning_mechanism": "The planner grows two trees from start and goal positions alternately. It samples points predominantly within an adaptive ellipsoidal region defined by the best current solution to focus exploration. New nodes are connected using cost and curvature-aware rewiring to encourage smooth local paths. Spatial hashing accelerates nearest and near neighbor searches. Periodic incremental shortcutting reduces unnecessary nodes and sharp turns in the evolving best path. Finally, the planner returns a refined, collision-free path optimized in length and smoothness within the iteration budget.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except ValueError:\n            pass\n\n    def path_from_root(self):\n        path, node = [], self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=3000, step_size=6.0, base_radius=25.0,\n                 goal_sample_rate=0.15, min_goal_sample_rate=0.05,\n                 goal_sample_decay=0.995, spatial_hash_cell=15.0,\n                 shortcut_freq=40, shortcut_attempts=30):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.base_radius = base_radius\n        self.goal_sample_rate = goal_sample_rate\n        self.min_goal_sample_rate = min_goal_sample_rate\n        self.goal_sample_decay = goal_sample_decay\n        self.spatial_hash_cell = spatial_hash_cell\n        self.shortcut_freq = shortcut_freq\n        self.shortcut_attempts = shortcut_attempts\n\n    def plan(self, map):\n        import math, random\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def dist_sq(a, b):\n            s = 0.0\n            for i in range(dim):\n                d = a[i]-b[i]\n                s += d * d\n            return s\n\n        def in_bounds(p):\n            for i in range(dim):\n                if p[i] < 0 or p[i] > bounds[i]:\n                    return False\n            return True\n\n        def is_in_obstacle(p):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d_ = obs\n                    if x <= p[0] <= x + w and y <= p[1] <= y + h and z <= p[2] <= z + d_:\n                        return True\n                else:\n                    x, y, w_, h_ = obs\n                    if x <= p[0] <= x + w_ and y <= p[1] <= y + h_:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(fr, to):\n            d = dist(fr, to)\n            resolution = min(1.0, self.step_size / 3.5)\n            steps = max(1, int(d / resolution))\n            for i in range(steps + 1):\n                interp = tuple(fr[j] + (to[j]-fr[j]) * i / steps for j in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def steer(fr, to):\n            d = dist(fr, to)\n            if d <= self.step_size:\n                return to\n            ratio = self.step_size / d\n            return tuple(fr[i] + (to[i]-fr[i]) * ratio for i in range(dim))\n\n        class SpatialHash:\n            def __init__(self, cell_size):\n                self.cell_size = cell_size\n                self.cells = {}\n\n            def _hash_key(self, point):\n                return tuple(int(coord // self.cell_size) for coord in point)\n\n            def insert(self, node):\n                key = self._hash_key(node.position)\n                self.cells.setdefault(key, []).append(node)\n\n            def neighbors(self, point, radius):\n                r_cell = int(math.ceil(radius / self.cell_size))\n                base_key = self._hash_key(point)\n                result = []\n                rng = range(-r_cell, r_cell + 1)\n                if dim == 2:\n                    for dx in rng:\n                        for dy in rng:\n                            key = (base_key[0] + dx, base_key[1] + dy)\n                            if key in self.cells:\n                                result.extend(self.cells[key])\n                else:\n                    for dx in rng:\n                        for dy in rng:\n                            for dz in rng:\n                                key = (base_key[0] + dx, base_key[1] + dy, base_key[2] + dz)\n                                if key in self.cells:\n                                    result.extend(self.cells[key])\n                return result\n\n        def adaptive_radius(n):\n            n = max(n, 2)\n            r = self.base_radius * (math.log(n) / n)**(1.0 / dim)\n            return max(r, self.step_size * 1.8)\n\n        def nearest(tree, sp_hash, point):\n            candidates = sp_hash.neighbors(point, self.step_size * 4)\n            if candidates:\n                return min(candidates, key=lambda node: dist(node.position, point))\n            return min(tree, key=lambda node: dist(node.position, point))\n\n        def near_nodes(tree, sp_hash, point, radius):\n            r2 = radius * radius\n            candidates = sp_hash.neighbors(point, radius)\n            return [n for n in candidates if dist_sq(n.position, point) <= r2]\n\n        def angle_between_vectors(a, b):\n            dot = sum(ai * bi for ai, bi in zip(a, b))\n            norm_a = math.sqrt(sum(ai * ai for ai in a))\n            norm_b = math.sqrt(sum(bi * bi for bi in b))\n            if norm_a < 1e-10 or norm_b < 1e-10:\n                return 0.0\n            val = max(min(dot / (norm_a * norm_b), 1.0), -1.0)\n            return math.acos(val)\n\n        def compute_curvature(prev_p, p, next_p):\n            if prev_p is None or next_p is None:\n                return 0.0\n            v1 = tuple(p[i] - prev_p[i] for i in range(dim))\n            v2 = tuple(next_p[i] - p[i] for i in range(dim))\n            return angle_between_vectors(v1, v2)\n\n        def update_parent(child, new_parent, new_cost):\n            if child.parent is not None:\n                child.parent.remove_child(child)\n                try:\n                    edges.remove((child.parent, child))\n                except Exception:\n                    pass\n            child.parent = new_parent\n            child.cost = new_cost\n            new_parent.add_child(child)\n            edges.append((new_parent, child))\n\n        def propagate_costs(node):\n            for c in node.children:\n                new_cost = node.cost + dist(node.position, c.position)\n                if new_cost + 1e-10 < c.cost:\n                    update_parent(c, node, new_cost)\n                    propagate_costs(c)\n\n        def rewire(new_node, near_list):\n            for neighbor in near_list:\n                if neighbor is new_node.parent:\n                    continue\n                d = dist(new_node.position, neighbor.position)\n                new_cost = new_node.cost + d\n                if new_cost + 1e-10 < neighbor.cost:\n                    # Compute curvature penalty to encourage smooth turns\n                    prev_pos = new_node.parent.position if new_node.parent else None\n                    curvature = compute_curvature(prev_pos, new_node.position, neighbor.position)\n                    if curvature < math.pi / 2:  # discard sharp turns (>90 deg)\n                        if not is_edge_in_obstacle(new_node.position, neighbor.position):\n                            update_parent(neighbor, new_node, new_cost)\n                            propagate_costs(neighbor)\n\n        def extract_path(node_start, node_goal):\n            path_start = node_start.path_from_root()\n            path_goal = node_goal.path_from_root()[::-1]\n            if path_start and path_goal and path_start[-1] == path_goal[0]:\n                path_goal = path_goal[1:]\n            return path_start + path_goal\n\n        def ellipsoid_sample(start, goal, c_best):\n            if c_best == float('inf'):\n                while True:\n                    pt = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                    if not is_in_obstacle(pt):\n                        return pt\n            center = tuple(0.5 * (start[i] + goal[i]) for i in range(dim))\n            diff = tuple(goal[i] - start[i] for i in range(dim))\n            dist_sg = dist(start, goal)\n            import math\n\n            if dist_sg < 1e-10:\n                while True:\n                    pt = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                    if not is_in_obstacle(pt):\n                        return pt\n\n            if dim == 2:\n                unit_vec = tuple(diff[i] / dist_sg for i in range(2))\n                angle = math.atan2(unit_vec[1], unit_vec[0])\n                a = c_best * 0.5\n                b = math.sqrt(max(c_best * c_best - dist_sg * dist_sg, 0.0)) * 0.5\n\n                for _ in range(20):\n                    r = random.uniform(0, 1) ** 0.5\n                    theta = random.uniform(0, 2 * math.pi)\n                    x = r * a * math.cos(theta)\n                    y = r * b * math.sin(theta)\n                    px = center[0] + x * math.cos(angle) - y * math.sin(angle)\n                    py = center[1] + x * math.sin(angle) + y * math.cos(angle)\n                    pt = (px, py)\n                    if in_bounds(pt) and not is_in_obstacle(pt):\n                        return pt\n\n                # fallback uniform sample\n                while True:\n                    pt = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                    if not is_in_obstacle(pt):\n                        return pt\n            else:\n                a = c_best * 0.5\n                b = math.sqrt(max(c_best * c_best - dist_sg * dist_sg, 0.0)) * 0.5\n                rx, ry, rz = a, b * 0.85, b * 0.6\n                for _ in range(30):\n                    x = random.uniform(-rx, rx)\n                    y = random.uniform(-ry, ry)\n                    z = random.uniform(-rz, rz)\n                    pt = (center[0] + x, center[1] + y, center[2] + z)\n                    if in_bounds(pt) and not is_in_obstacle(pt):\n                        return pt\n                # fallback uniform sample\n                while True:\n                    pt = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                    if not is_in_obstacle(pt):\n                        return pt\n\n        def sample(it, c_best):\n            # Mix goal bias with decay and ellipsoid sampling\n            goal_bias_prob = max(self.min_goal_sample_rate,\n                                 self.goal_sample_rate * (self.goal_sample_decay ** it))\n            r = random.random()\n            if r < goal_bias_prob:\n                if not is_in_obstacle(goal_pos):\n                    return goal_pos\n            return ellipsoid_sample(start_pos, goal_pos, c_best)\n\n        def path_shortcut(path):\n            if len(path) < 3:\n                return path[:]\n            sp = path[:]\n            attempts = 0\n            while attempts < self.shortcut_attempts and len(sp) >= 3:\n                i = random.randint(0, len(sp) - 3)\n                j = random.randint(i + 2, len(sp) - 1)\n                p1, p2 = sp[i], sp[j]\n                if not is_edge_in_obstacle(p1, p2):\n                    sp = sp[:i + 1] + sp[j:]\n                    attempts = 0\n                else:\n                    attempts += 1\n            return sp\n\n        start_tree = [Node(start_pos, None, 0.0)]\n        goal_tree = [Node(goal_pos, None, 0.0)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        start_hash = SpatialHash(self.spatial_hash_cell)\n        goal_hash = SpatialHash(self.spatial_hash_cell)\n        start_hash.insert(start_tree[0])\n        goal_hash.insert(goal_tree[0])\n\n        best_cost = float('inf')\n        solution_nodes = (None, None)\n        success = False\n\n        for it in range(self.max_iter):\n            for tree_a, tree_b, hash_a, hash_b in [(start_tree, goal_tree, start_hash, goal_hash),\n                                                   (goal_tree, start_tree, goal_hash, start_hash)]:\n                c_best = best_cost if best_cost < float('inf') else float('inf')\n                sample_pt = sample(it, c_best)\n\n                nearest_node = nearest(tree_a, hash_a, sample_pt)\n                new_pos = steer(nearest_node.position, sample_pt)\n                if not in_bounds(new_pos) or is_in_obstacle(new_pos):\n                    continue\n                if is_edge_in_obstacle(nearest_node.position, new_pos):\n                    continue\n\n                radius = adaptive_radius(len(tree_a))\n                near = near_nodes(tree_a, hash_a, new_pos, radius)\n\n                min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n                min_parent = nearest_node\n                for candidate in near:\n                    if candidate is nearest_node:\n                        continue\n                    cand_cost = candidate.cost + dist(candidate.position, new_pos)\n                    if cand_cost + 1e-8 < min_cost:\n                        if not is_edge_in_obstacle(candidate.position, new_pos):\n                            min_cost = cand_cost\n                            min_parent = candidate\n\n                new_node = Node(new_pos, min_parent, min_cost)\n                min_parent.add_child(new_node)\n                tree_a.append(new_node)\n                hash_a.insert(new_node)\n                nodes.append(new_node)\n                edges.append((min_parent, new_node))\n\n                rewire(new_node, near)\n\n                # Attempt connection to other tree\n                nearest_other = nearest(tree_b, hash_b, new_node.position)\n                dist_to_other = dist(new_node.position, nearest_other.position)\n                radius_conn = max(self.step_size * 2.0, adaptive_radius(len(tree_b)))\n                if dist_to_other <= radius_conn:\n                    if not is_edge_in_obstacle(new_node.position, nearest_other.position):\n                        total_cost = (new_node.cost + dist(new_node.position, nearest_other.position)\n                                      + nearest_other.cost)\n                        if total_cost + 1e-8 < best_cost:\n                            best_cost = total_cost\n                            success = True\n                            if tree_a is start_tree:\n                                solution_nodes = (new_node, nearest_other)\n                            else:\n                                solution_nodes = (nearest_other, new_node)\n\n            # Periodic incremental path shortcutting to improve smoothness during iterations\n            if success and (it % self.shortcut_freq == 0 or it == self.max_iter - 1):\n                raw_path = extract_path(solution_nodes[0], solution_nodes[1])\n                improved_path = path_shortcut(raw_path)\n                if improved_path and len(improved_path) >= 2:\n                    # update solution_nodes by locating nodes closest to path ends in start and goal trees\n                    # to maintain consistent future extensions if needed\n                    return PlannerResult(True, improved_path, nodes, edges)\n\n        if success:\n            raw_path = extract_path(solution_nodes[0], solution_nodes[1])\n            refined_path = path_shortcut(raw_path)\n            return PlannerResult(True, refined_path, nodes, edges)\n        else:\n            return PlannerResult(False, [], nodes, edges)",
        "objective": -34.17849,
        "time_improvement": 60.0,
        "length_improvement": 16.0,
        "smoothness_improvement": 1299.0,
        "node_improvement": 75.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.017295455932617186,
                "num_nodes_avg": 122.6,
                "path_length_avg": 171.23147367354323,
                "smoothness_avg": 0.03716410189314488,
                "success_improvement": 0.0,
                "time_improvement": 32.93946355194617,
                "node_improvement": 69.12616469403173,
                "length_improvement": 6.145315943196231,
                "smoothness_improvement": 481.6988977666769,
                "objective_score": 15.977523120334972
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.023405694961547853,
                "num_nodes_avg": 257.3,
                "path_length_avg": 231.5156418202283,
                "smoothness_avg": 0.09148380904569924,
                "success_improvement": 0.0,
                "time_improvement": 85.86405151058038,
                "node_improvement": 82.71181885372573,
                "length_improvement": 22.71341495214288,
                "smoothness_improvement": 2253.944299870077,
                "objective_score": 50.656985923810225
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.019008278846740723,
                "num_nodes_avg": 221.5,
                "path_length_avg": 122.14401225675431,
                "smoothness_avg": 0.09923558831299088,
                "success_improvement": 0.0,
                "time_improvement": 62.54318200076956,
                "node_improvement": 71.83725365543548,
                "length_improvement": 18.877762931905092,
                "smoothness_improvement": 1162.2693585320496,
                "objective_score": 35.90095915203417
            }
        ],
        "success_rate": 1.0
    }
]