[
    {
        "operator": "e2",
        "algorithm_description": "A bidirectional RRT* inspired planner with rewiring and path smoothing that grows two trees from start and goal. It efficiently samples collision-free nodes, extends trees with batch rewiring for shorter and smoother paths, and attempts early connections. Final path is further smoothed using shortcutting to improve length and smoothness while reducing planning time.",
        "planning_mechanism": "The planner alternates growing two trees toward sampled points with a fixed step size, uses nearest rewiring within radius to optimize path cost, checks collisions thoroughly, tries quick connection after each extension, and applies a post-processing path shortcutting for smoothness and length improvements.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=4000, step_size=6.0, rewire_radius=12.0, shortcut_trials=150):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.rewire_radius = rewire_radius\n        self.shortcut_trials = shortcut_trials\n\n    def plan(self, map) -> 'PlannerResult':\n        import math, random\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        # Initialize start and goal trees\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n\n        nodes = [start_root, goal_root]\n        edges = []\n        connected_node_start = None\n        connected_node_goal = None\n        success = False\n\n        # Precompute squared radius for efficiency\n        radius_sq = self.rewire_radius * self.rewire_radius\n\n        def dist_sq(a, b):\n            return sum((a[d]-b[d])**2 for d in range(len(a)))\n\n        def dist(a,b):\n            return math.sqrt(dist_sq(a,b))\n\n        def in_radius(tree, point, radius):\n            r_sq = radius * radius\n            return [node for node in tree if dist_sq(node.position, point) <= r_sq]\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            ratio = self.step_size / d\n            return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n        def collision_free_edge(p1, p2):\n            if self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution=1.0):\n                return False\n            return True\n\n        def no_collision_node(p):\n            return not self._is_in_obstacle(p, obstacles, is_3d)\n\n        def rewire(new_node, near_nodes, tree, nodes, edges):\n            for near_node in near_nodes:\n                if near_node == new_node.parent:\n                    continue\n                potential_cost = new_node.cost + dist(new_node.position, near_node.position)\n                if potential_cost < near_node.cost:\n                    if collision_free_edge(new_node.position, near_node.position):\n                        old_parent = near_node.parent\n                        if old_parent:\n                            if near_node in old_parent.children:\n                                old_parent.children.remove(near_node)\n                            try:\n                                edges.remove((old_parent, near_node))\n                            except ValueError:\n                                pass\n                        near_node.parent = new_node\n                        near_node.cost = potential_cost\n                        new_node.children.append(near_node)\n                        edges.append((new_node, near_node))\n                        # Update costs recursively for descendants\n                        self._update_costs(near_node, edges)\n\n        def extend(tree, point):\n            nearest = min(tree, key=lambda n: dist(n.position, point))\n            new_pos = steer(nearest.position, point)\n            if not no_collision_node(new_pos):\n                return None\n            if not collision_free_edge(nearest.position, new_pos):\n                return None\n            new_cost = nearest.cost + dist(nearest.position, new_pos)\n            new_node = Node(new_pos, parent=nearest, cost=new_cost)\n            nearest.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest, new_node))\n            # Rewire nearby nodes for optimization\n            near_nodes = in_radius(tree, new_pos, self.rewire_radius)\n            rewire(new_node, near_nodes, tree, nodes, edges)\n            return new_node\n\n        def try_connect(node_start, node_goal):\n            # Try connect by direct edge if collision free\n            if collision_free_edge(node_start.position, node_goal.position):\n                # Create connecting nodes on goal tree side for consistency\n                connecting_node = Node(node_start.position, parent=node_goal,\n                                      cost=node_goal.cost + dist(node_goal.position, node_start.position))\n                node_goal.children.append(connecting_node)\n                nodes.append(connecting_node)\n                edges.append((node_goal, connecting_node))\n                return connecting_node\n            return None\n\n        def extract_path(n_start, n_goal):\n            path_start = n_start.path_from_root()\n            path_goal = n_goal.path_from_root()\n            return path_start + path_goal[::-1]\n\n        def path_shortcut(path):\n            # Attempt shortcutting random pairs to smooth path\n            import random\n            if len(path) < 3:\n                return path\n            for _ in range(self.shortcut_trials):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) -1)\n                if self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d, resolution=1.0):\n                    continue\n                path = path[:i+1] + path[j:]\n            return path\n\n        # Main loop alternating tree expansion\n        for iter in range(self.max_iter):\n            rand_pt = self._sample_free(bounds, obstacles, is_3d)\n\n            new_node_start = extend(tree_start, rand_pt)\n            if new_node_start:\n                nearest_goal = min(tree_goal, key=lambda n: dist(n.position, new_node_start.position))\n                connecting_node = try_connect(new_node_start, nearest_goal)\n                if connecting_node:\n                    connected_node_start = new_node_start\n                    connected_node_goal = connecting_node\n                    success = True\n                    break\n\n            new_node_goal = extend(tree_goal, rand_pt)\n            if new_node_goal:\n                nearest_start = min(tree_start, key=lambda n: dist(n.position, new_node_goal.position))\n                connecting_node = try_connect(new_node_goal, nearest_start)\n                if connecting_node:\n                    connected_node_goal = new_node_goal\n                    connected_node_start = connecting_node\n                    success = True\n                    break\n\n        if success:\n            raw_path = extract_path(connected_node_start, connected_node_goal)\n            smoothed_path = path_shortcut(raw_path)\n            return PlannerResult(True, smoothed_path, nodes, edges)\n\n        # If fail, empty path\n        return PlannerResult(False, [], nodes, edges)\n\n    def _update_costs(self, node, edges):\n        import math\n        for child in node.children:\n            child.cost = node.cost + math.dist(node.position, child.position)\n            self._update_costs(child, edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        import random\n        while True:\n            if is_3d:\n                p = (random.uniform(0, bounds[0]),\n                     random.uniform(0, bounds[1]),\n                     random.uniform(0, bounds[2]))\n            else:\n                p = (random.uniform(0, bounds[0]),\n                     random.uniform(0, bounds[1]))\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
        "objective": -22.16212,
        "time_improvement": 20.0,
        "length_improvement": 13.0,
        "smoothness_improvement": 1613.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.018953418731689452,
                "num_nodes_avg": 81.0,
                "path_length_avg": 171.68715107805457,
                "smoothness_avg": 0.052197424039673826,
                "success_improvement": 0.0,
                "time_improvement": 25.163236257653466,
                "node_improvement": 79.60211533618737,
                "length_improvement": 5.895551937113022,
                "smoothness_improvement": 717.0030347414034,
                "objective_score": 14.67131721327087
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.05427415370941162,
                "num_nodes_avg": 223.1,
                "path_length_avg": 248.40557495835523,
                "smoothness_avg": 0.10736639107141233,
                "success_improvement": 0.0,
                "time_improvement": 67.22146554739268,
                "node_improvement": 85.00974265941007,
                "length_improvement": 17.075069120866036,
                "smoothness_improvement": 2662.614575153109,
                "objective_score": 43.72455401250298
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.06621241569519043,
                "num_nodes_avg": 221.6,
                "path_length_avg": 124.19023230834314,
                "smoothness_avg": 0.12268260456847457,
                "success_improvement": 0.0,
                "time_improvement": -32.411130325660395,
                "node_improvement": 71.82453909726637,
                "length_improvement": 17.518761004167946,
                "smoothness_improvement": 1460.5136746230896,
                "objective_score": 8.090485877918098
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "e1",
        "algorithm_description": "A bidirectional informed RRT* with adaptive sampling and post-processing path shortcutting. The algorithm grows two trees from start and goal, but restricts sampling within an ellipsoidal region (informed sampling) to focus search around the best solution path. It performs rewiring to optimize local connections and applies an efficient post-processing shortcutting procedure to smooth the final path, which improves path quality and smoothness while reducing planning time.",
        "planning_mechanism": "The planner alternates expanding two trees by sampling random points within an informed ellipsoidal subset after an initial solution is found. It performs steer, collision checks, rewiring, and attempts to connect the trees continuously. Upon success, it extracts the path and applies post-processing shortcutting to remove unnecessary waypoints and smooth sharp turns, leading to a shorter, smoother trajectory with improved efficiency.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n    def add_child(self, child):\n        self.children.append(child)\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=7.0, radius=15.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.radius = radius\n\n    def plan(self, map):\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = (len(bounds) == 3)\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = []\n        edges = []\n\n        best_path_cost = float('inf')\n        solution_node_start = None\n        solution_node_goal = None\n\n        # Basic heuristic distance for informed sampling\n        c_min = self._distance(start_pos, goal_pos)\n\n        for i in range(self.max_iter):\n            if solution_node_start and solution_node_goal:\n                # Informed sampling inside ellipsoid bounding current best path cost\n                sample = self._informed_sample(bounds, obstacles, is_3d, start_pos, goal_pos, best_path_cost, c_min)\n            else:\n                # Uniform random sampling within bounds free space\n                sample = self._sample_free(bounds, obstacles, is_3d)\n\n            for tree_a, tree_b in [(start_tree,goal_tree),(goal_tree,start_tree)]:\n                nearest = self._nearest(tree_a, sample)\n                new_pos = self._steer(nearest.position, sample, self.step_size)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d): continue\n                if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d): continue\n\n                new_node = Node(new_pos)\n                near_nodes = self._near(tree_a, new_pos, self.radius)\n\n                # Choose best parent among near nodes considering path cost and collision\n                min_cost = nearest.cost + self._distance(nearest.position, new_pos)\n                min_parent = nearest\n                for near in near_nodes:\n                    tent_cost = near.cost + self._distance(near.position, new_pos)\n                    if tent_cost < min_cost and not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d):\n                        min_cost = tent_cost\n                        min_parent = near\n\n                new_node.parent = min_parent\n                new_node.cost = min_cost\n                min_parent.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((min_parent, new_node))\n\n                # Rewire neighbors if new node offers a better path\n                for near in near_nodes:\n                    if near == min_parent: continue\n                    new_cost = new_node.cost + self._distance(new_node.position, near.position)\n                    if new_cost < near.cost and not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                        if near.parent:\n                            try: edges.remove((near.parent, near))\n                            except ValueError: pass\n                        near.parent = new_node\n                        near.cost = new_cost\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n\n                # Try to connect to tree_b within step size and collision free\n                connect_node = self._nearest(tree_b, new_node.position)\n                if self._distance(new_node.position, connect_node.position) <= self.step_size:\n                    if not self._is_edge_in_obstacle(new_node.position, connect_node.position, obstacles, is_3d):\n                        # Construct candidate path cost\n                        path_cost = new_node.cost + self._distance(new_node.position, connect_node.position) + connect_node.cost\n                        if path_cost < best_path_cost:\n                            best_path_cost = path_cost\n                            solution_node_start, solution_node_goal = (new_node, connect_node) if tree_a is start_tree else (connect_node, new_node)\n                        # We can continue to iterate to improve path\n\n            if best_path_cost < float('inf') and (i % 100 == 0 or i == self.max_iter -1):\n                # Extract and shortcut path every 100 iterations or at end for smoother solution\n                raw_path = self._extract_path(solution_node_start, solution_node_goal)\n                shortcut_path = self._shortcut_path(raw_path, obstacles, is_3d)\n                if shortcut_path:\n                    return PlannerResult(True, shortcut_path, start_tree + goal_tree, edges)\n\n        # No solution found; return empty path\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        while True:\n            pt = tuple(random.uniform(0, bounds[i]) for i in range(3 if is_3d else 2))\n            if not self._is_in_obstacle(pt, obstacles, is_3d): return pt\n\n    def _informed_sample(self, bounds, obstacles, is_3d, start, goal, c_max, c_min):\n        # Sample inside prolate hyperspheroid (ellipsoid) defined by start, goal, and current best cost c_max\n        # Reduces sampling space to focus search near optimal path\n        dim = 3 if is_3d else 2\n        while True:\n            # Sample unit ball point\n            if dim == 2:\n                r = random.uniform(0,1) ** 0.5\n                theta = random.uniform(0, 2*math.pi)\n                x_ball = [r * math.cos(theta), r * math.sin(theta)]\n            else:\n                # Sample from 3D ball\n                while True:\n                    x_ball = [random.uniform(-1,1), random.uniform(-1,1), random.uniform(-1,1)]\n                    if sum([xi*xi for xi in x_ball]) <= 1: break\n            # Calculate transformation parameters\n            c = c_max\n            if c == float('inf') or c <= c_min:\n                # No current solution, uniform sample\n                pt = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not self._is_in_obstacle(pt, obstacles, is_3d): return pt\n\n            center = tuple((start[i] + goal[i]) / 2 for i in range(dim))\n            dir_vec = [goal[i] - start[i] for i in range(dim)]\n            length = math.dist(start, goal)\n            # Compute rotation matrix from canonical axis to direction vector\n            if dim == 2:\n                if length == 0:\n                    R = [[1,0],[0,1]]\n                else:\n                    a1 = [1,0]\n                    a2 = [dir_vec[0]/length, dir_vec[1]/length]\n                    cos_theta = a1[0]*a2[0] + a1[1]*a2[1]\n                    sin_theta = a1[0]*a2[1] - a1[1]*a2[0]\n                    R = [[cos_theta, -sin_theta],[sin_theta, cos_theta]]\n            else:\n                # 3D rotation using axis-angle (rotation matrix)\n                from math import acos, sqrt\n                if length == 0:\n                    R = [[1,0,0],[0,1,0],[0,0,1]]\n                else:\n                    a1 = [1,0,0]\n                    a2 = [dir_vec[i]/length for i in range(3)]\n                    v = [a1[1]*a2[2]-a1[2]*a2[1], a1[2]*a2[0]-a1[0]*a2[2], a1[0]*a2[1]-a1[1]*a2[0]]\n                    s = sqrt(sum([vi*vi for vi in v]))\n                    c = sum([a1[i]*a2[i] for i in range(3)])\n                    if s == 0:\n                        R = [[1,0,0],[0,1,0],[0,0,1]]\n                    else:\n                        vx = [[0,-v[2],v[1]],[v[2],0,-v[0]],[-v[1],v[0],0]]\n                        I = [[1 if i==j else 0 for j in range(3)] for i in range(3)]\n                        vx2 = [[vx[0][0]*vx[0][0]+vx[0][1]*vx[1][0]+vx[0][2]*vx[2][0],\n                                vx[0][0]*vx[0][1]+vx[0][1]*vx[1][1]+vx[0][2]*vx[2][1],\n                                vx[0][0]*vx[0][2]+vx[0][1]*vx[1][2]+vx[0][2]*vx[2][2]],\n                               [vx[1][0]*vx[0][0]+vx[1][1]*vx[1][0]+vx[1][2]*vx[2][0],\n                                vx[1][0]*vx[0][1]+vx[1][1]*vx[1][1]+vx[1][2]*vx[2][1],\n                                vx[1][0]*vx[0][2]+vx[1][1]*vx[1][2]+vx[1][2]*vx[2][2]],\n                               [vx[2][0]*vx[0][0]+vx[2][1]*vx[1][0]+vx[2][2]*vx[2][0],\n                                vx[2][0]*vx[0][1]+vx[2][1]*vx[1][1]+vx[2][2]*vx[2][1],\n                                vx[2][0]*vx[0][2]+vx[2][1]*vx[1][2]+vx[2][2]*vx[2][2]]]\n                        R = [[I[i][j] + vx[i][j] + ((vx2[i][j]) * ((1 - c)/(s**2))) for j in range(3)] for i in range(3)]\n            # Compose scaling matrix\n            a1_val = c_max / 2.0\n            a_others = math.sqrt(c_max**2 - c_min**2) / 2.0\n            if dim == 2:\n                L = [[a1_val,0],[0,a_others]]\n                # Transform sample from unit ball: pos = R * L * x_ball + center\n                x_scaled = [L[0][0]*x_ball[0] + L[0][1]*x_ball[1], L[1][0]*x_ball[0] + L[1][1]*x_ball[1]]\n                pt = (center[0] + R[0][0]*x_scaled[0] + R[0][1]*x_scaled[1],\n                      center[1] + R[1][0]*x_scaled[0] + R[1][1]*x_scaled[1])\n            else:\n                L = [[a1_val,0,0],[0,a_others,0],[0,0,a_others]]\n                x_scaled = [L[0][0]*x_ball[0], L[1][1]*x_ball[1], L[2][2]*x_ball[2]]\n                pt = tuple(center[i] + sum(R[i][j]*x_scaled[j] for j in range(3)) for i in range(3))\n\n            # Reject points outside bounds or in obstacle\n            if any(pt[d] < 0 or pt[d] > bounds[d] for d in range(dim)):\n                continue\n            if self._is_in_obstacle(pt, obstacles, is_3d):\n                continue\n            return pt\n\n    def _nearest(self, tree, point):\n        return min(tree, key=lambda n: self._distance(n.position, point))\n\n    def _near(self, tree, point, radius):\n        radius_sq = radius * radius\n        return [node for node in tree if self._squared_distance(node.position, point) <= radius_sq]\n\n    def _steer(self, from_pos, to_pos, step_size):\n        dist = self._distance(from_pos, to_pos)\n        if dist <= step_size:\n            return to_pos\n        ratio = step_size / dist\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n    def _extract_path(self, node_start, node_goal):\n        path_start, path_goal = [], []\n        n = node_start\n        while n:\n            path_start.append(n.position)\n            n = n.parent\n        n = node_goal\n        while n:\n            path_goal.append(n.position)\n            n = n.parent\n        return list(reversed(path_start)) + path_goal\n\n    def _shortcut_path(self, path, obstacles, is_3d):\n        # Attempt to shortcut path by skipping intermediate nodes where direct edge collision free\n        if len(path) < 3:\n            return path[:]\n        shortcut_path = [path[0]]\n        i = 0\n        while i < len(path)-1:\n            j = len(path)-1\n            while j > i+1:\n                if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                    break\n                j -= 1\n            shortcut_path.append(path[j])\n            i = j\n        return shortcut_path\n\n    def _distance(self, a, b):\n        return math.dist(a, b)\n\n    def _squared_distance(self, a, b):\n        return sum((a[i] - b[i])**2 for i in range(len(a)))\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x,y,z,w,h,d = obs\n                px,py,pz = pos\n                if x<=px<=x+w and y<=py<=y+h and z<=pz<=z+d:\n                    return True\n            else:\n                x,y,w,h = obs\n                px,py = pos\n                if x<=px<=x+w and y<=py<=y+h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        dist = self._distance(from_pos, to_pos)\n        steps = max(1, int(dist/resolution))\n        for i in range(steps+1):\n            interp = tuple(from_pos[d] + (to_pos[d]-from_pos[d])*(i/steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
        "objective": -23.21547,
        "time_improvement": 21.0,
        "length_improvement": 16.0,
        "smoothness_improvement": 1469.0,
        "node_improvement": 68.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.025556087493896484,
                "num_nodes_avg": 151.3,
                "path_length_avg": 173.88763401105183,
                "smoothness_avg": 0.047474639256938476,
                "success_improvement": 0.0,
                "time_improvement": 0.9101035826373128,
                "node_improvement": 61.89876605389071,
                "length_improvement": 4.689432372653788,
                "smoothness_improvement": 643.0811972002915,
                "objective_score": 6.302096484384924
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.031405282020568845,
                "num_nodes_avg": 252.2,
                "path_length_avg": 230.86304004149935,
                "smoothness_avg": 0.09581397875517297,
                "success_improvement": 0.0,
                "time_improvement": 81.03267389975849,
                "node_improvement": 83.05449170194181,
                "length_improvement": 22.93127220998329,
                "smoothness_improvement": 2365.362685390011,
                "objective_score": 49.89537892286758
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.06047847270965576,
                "num_nodes_avg": 317.2,
                "path_length_avg": 119.93973012619429,
                "smoothness_avg": 0.11787316210161418,
                "success_improvement": 0.0,
                "time_improvement": -19.176026584091733,
                "node_improvement": 59.6694214876033,
                "length_improvement": 20.341742166387515,
                "smoothness_improvement": 1399.337921440741,
                "objective_score": 13.448926931808694
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "m2",
        "algorithm_description": "This algorithm is an enhanced bidirectional RRT* planner that incorporates adaptive rewiring radius, smarter sampling strategies incorporating goal bias and informed sampling, and a post-processing path smoothing stage using shortcutting to greatly improve path smoothness, length, and planning efficiency. It grows two trees from start and goal, alternates expansion, rewires locally for optimality, attempts early connection, and finally smooths the extracted path for a low-cost, feasible, and smooth trajectory.",
        "planning_mechanism": "The planner uses bidirectional RRT* with adaptive rewiring radius based on the logarithm of tree size for asymptotic optimality and faster rewiring, samples with a goal bias probability to focus exploration, uses a connection radius scaled to domain size, and applies a shortcut smoothing post-processing on the constructed path. Trees are alternately expanded toward random samples or the opposing tree's nearest nodes to encourage faster convergence and connection. Collision checks are extensive but efficient with early rejections.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        node, path = self, []\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=5.0, base_radius=15.0, goal_sample_rate=0.1, shortcut_iterations=150):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.base_radius = base_radius\n        self.goal_sample_rate = goal_sample_rate\n        self.shortcut_iterations = shortcut_iterations\n\n    def plan(self, map) -> 'PlannerResult':\n        import random, math\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        def dist(a,b):\n            return math.dist(a,b)\n\n        def steer(fr, to):\n            d = dist(fr, to)\n            if d <= self.step_size:\n                return to\n            ratio = self.step_size / d\n            return tuple(fr[i] + (to[i] - fr[i]) * ratio for i in range(dim))\n\n        def is_in_obstacle(p):\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d_ = obs\n                    px,py,pz = p\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d_:\n                        return True\n                else:\n                    x,y,w,h = obs\n                    px,py = p\n                    if x <= px <= x+w and y <= py <= y+h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(fr,to, resolution=1.0):\n            d = dist(fr,to)\n            steps = max(1, int(d / resolution))\n            for i in range(steps + 1):\n                interp = tuple(fr[j] + (to[j] - fr[j]) * i / steps for j in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: dist(node.position, point))\n\n        def near_nodes(tree, point, radius):\n            return [node for node in tree if dist(node.position, point) <= radius]\n\n        def rewire(tree, new_node, near_nodes_):\n            nonlocal edges\n            for near in near_nodes_:\n                if near == new_node.parent:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, near.position)\n                if new_cost + 1e-7 < near.cost:\n                    if not is_edge_in_obstacle(new_node.position, near.position):\n                        # Remove old edge\n                        if near.parent is not None:\n                            try:\n                                edges.remove((near.parent, near))\n                            except Exception:\n                                pass\n                        near.parent.children.remove(near) if near.parent else None\n                        near.parent = new_node\n                        near.cost = new_cost\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n\n        def extract_path(node_from_start, node_from_goal):\n            path_start = node_from_start.path_from_root()\n            path_goal = node_from_goal.path_from_root()[::-1]\n            if len(path_start) > 0 and len(path_goal) > 0 and path_start[-1] == path_goal[0]:\n                path_goal = path_goal[1:]\n            return path_start + path_goal\n\n        def sample_point():\n            if random.random() < self.goal_sample_rate:\n                return goal_pos\n            else:\n                return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n\n        def shortcut_path(path):\n            # Attempts shortcutting to reduce sharp turns and improve smoothness\n            for _ in range(self.shortcut_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i+2, len(path) -1)\n                p1, p2 = path[i], path[j]\n                if not is_edge_in_obstacle(p1, p2):\n                    # shortcut successful: remove intermediate points between i and j\n                    path = path[:i+1] + path[j:]\n            return path\n\n        def adaptive_radius(tree_size):\n            # follow RRT* inspired radius scaling: gamma*(log(n)/n)^(1/d)\n            gamma = self.base_radius\n            n = max(tree_size, 1)\n            radius = gamma * (math.log(n)/n)**(1.0/dim)\n            return max(radius, self.step_size*1.5)\n\n        success = False\n        connection_pair = (None, None)\n\n        # Alternate which is tree A and tree B\n        for it in range(self.max_iter):\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                q_rand = sample_point()\n                nearest_node = nearest(tree_a, q_rand)\n                q_new_pos = steer(nearest_node.position, q_rand)\n                if is_in_obstacle(q_new_pos):\n                    continue\n                if is_edge_in_obstacle(nearest_node.position, q_new_pos):\n                    continue\n\n                # Rewiring radius adaptive\n                radius = adaptive_radius(len(tree_a))\n\n                # Find near nodes in tree_a for rewiring\n                near_nodes_a = near_nodes(tree_a, q_new_pos, radius)\n\n                # Choose best parent minimizing cost\n                min_cost = nearest_node.cost + dist(nearest_node.position, q_new_pos)\n                min_parent = nearest_node\n                for near_node in near_nodes_a:\n                    c = near_node.cost + dist(near_node.position, q_new_pos)\n                    if c < min_cost and not is_edge_in_obstacle(near_node.position, q_new_pos):\n                        min_cost = c\n                        min_parent = near_node\n\n                q_new = Node(q_new_pos, parent=min_parent, cost=min_cost)\n                min_parent.add_child(q_new)\n                tree_a.append(q_new)\n                nodes.append(q_new)\n                edges.append((min_parent, q_new))\n\n                # Rewire neighbors for improved costs\n                rewire(tree_a, q_new, near_nodes_a)\n\n                # Attempt connection to other tree\n                nearest_to_new = nearest(tree_b, q_new.position)\n                dist_connect = dist(q_new.position, nearest_to_new.position)\n                radius_connect = max(self.step_size*1.5, adaptive_radius(len(tree_b)))\n                if dist_connect <= radius_connect and not is_edge_in_obstacle(q_new.position, nearest_to_new.position):\n                    # Connected trees successfully\n                    if tree_a is start_tree:\n                        node_start, node_goal = q_new, nearest_to_new\n                    else:\n                        node_start, node_goal = nearest_to_new, q_new\n                    success = True\n                    connection_pair = (node_start, node_goal)\n                    break\n            if success:\n                break\n\n        path = []\n        if success:\n            raw_path = extract_path(connection_pair[0], connection_pair[1])\n            path = shortcut_path(raw_path)\n\n        return PlannerResult(success, path, nodes, edges)",
        "objective": -33.9861,
        "time_improvement": 56.0,
        "length_improvement": 16.0,
        "smoothness_improvement": 1519.0,
        "node_improvement": 69.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.01380462646484375,
                "num_nodes_avg": 128.7,
                "path_length_avg": 166.57538852397772,
                "smoothness_avg": 0.04015959576609991,
                "success_improvement": 0.0,
                "time_improvement": 46.47463126707311,
                "node_improvement": 67.59002770083103,
                "length_improvement": 8.697389994063707,
                "smoothness_improvement": 528.5848816974815,
                "objective_score": 21.803747785047563
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.028153705596923827,
                "num_nodes_avg": 317.3,
                "path_length_avg": 238.40919577619638,
                "smoothness_avg": 0.10655923140396159,
                "success_improvement": 0.0,
                "time_improvement": 82.9964744581085,
                "node_improvement": 78.68037358059532,
                "length_improvement": 20.412148221691805,
                "smoothness_improvement": 2641.8457755359923,
                "objective_score": 50.35546014812759
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.031368589401245116,
                "num_nodes_avg": 304.4,
                "path_length_avg": 121.92947455845565,
                "smoothness_avg": 0.11683997631770895,
                "success_improvement": 0.0,
                "time_improvement": 38.186536846996304,
                "node_improvement": 61.29688493324858,
                "length_improvement": 19.020248655927677,
                "smoothness_improvement": 1386.1958745313084,
                "objective_score": 29.79908962031204
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "e2",
        "algorithm_description": "This algorithm is a bidirectional RRT* variant combining informed elliptical sampling with adaptive neighborhood radius recalibration to improve convergence speed and path quality. It grows two trees simultaneously from start and goal, performs efficient nearest and near neighbor searches, applies incremental rewiring with cost propagation, and attempts frequent connections between trees. The informed sampling targets ellipsoidal regions shaped by the best current path cost, and the radius adapts based on iteration count and node density to balance exploration and optimization. After successful connection, the algorithm extracts and performs iterated shortcut smoothing to produce shorter, smoother paths while ensuring collision-free nodes and edges within map bounds.",
        "planning_mechanism": "The planner alternates expansion of two trees using adaptive informed sampling within an ellipsoidal informed set defined by the best path cost. Each extension seeks a minimum cost parent within an adaptive radius, followed by rewiring neighbors to reduce path cost with recursive updates. Regular connection attempts between trees detect early solutions. When a solution is found, the algorithm performs iterative shortcutting with collision checks to improve smoothness and path length while respecting collision and map boundary constraints.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=5.0, base_radius=20.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.base_radius = base_radius\n\n    def plan(self, map):\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        edges = []\n\n        best_path = []\n        best_cost = float('inf')\n\n        def dist(a, b):\n            return math.dist(a,b)\n\n        def in_bounds(p):\n            return all(0 <= p[i] <= bounds[i] for i in range(dim))\n\n        def collision_node(p):\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d = obs\n                    px,py,pz = p\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                        return True\n                else:\n                    x,y,w,h = obs\n                    px,py = p\n                    if x <= px <= x+w and y <= py <= y+h:\n                        return True\n            return False\n\n        def collision_edge(a,b,res=0.5):\n            length = dist(a,b)\n            steps = max(1,int(length / res))\n            for i in range(steps+1):\n                interp = tuple(a[d] + (b[d]-a[d])*(i/steps) for d in range(dim))\n                if collision_node(interp):\n                    return True\n            return False\n\n        def steer(from_p,to_p):\n            length = dist(from_p,to_p)\n            if length <= self.step_size:\n                return to_p\n            ratio = self.step_size / length\n            return tuple(from_p[i] + (to_p[i] - from_p[i]) * ratio for i in range(dim))\n\n        def nearest(tree, p):\n            best_node = None\n            best_dist = float('inf')\n            for node in tree:\n                d = dist(node.position, p)\n                if d < best_dist:\n                    best_dist = d\n                    best_node = node\n            return best_node\n\n        def near(tree, p, radius):\n            result = []\n            r_sq = radius*radius\n            for node in tree:\n                d_sq = sum((node.position[i] - p[i])**2 for i in range(dim))\n                if d_sq <= r_sq:\n                    result.append(node)\n            return result\n\n        def heuristic_cost_to_go(p):\n            return dist(p, goal_pos)\n\n        def cost_to_come(p):\n            nn = nearest(start_tree, p)\n            return nn.cost + dist(nn.position, p)\n\n        def informed_sample():\n            c_min = dist(start_pos, goal_pos)\n            c_best = best_cost\n            if c_best == float('inf'):\n                while True:\n                    sample = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                    if not collision_node(sample):\n                        return sample\n            # Ellipsoidal informed sampling:\n            center = tuple((start_pos[i] + goal_pos[i]) / 2 for i in range(dim))\n            foci_dist = c_min\n            if c_best < c_min:\n                c_best = c_min + 1e-6\n            r1 = c_best / 2\n            val = c_best*c_best - foci_dist*foci_dist\n            r_rest = math.sqrt(val)/2 if val > 0 else 0.0\n\n            def unit_ball_sample(dim_):\n                while True:\n                    vec = [random.gauss(0,1) for _ in range(dim_)]\n                    norm = math.sqrt(sum(x*x for x in vec))\n                    if norm > 1e-8:\n                        break\n                u = [x/norm for x in vec]\n                r = random.random() ** (1/dim_)\n                return [u[i]*r for i in range(dim_)]\n\n            while True:\n                u_sample = unit_ball_sample(dim)\n                sample_ellipsoid = [0]*dim\n                sample_ellipsoid[0] = u_sample[0]*r1\n                for i in range(1,dim):\n                    sample_ellipsoid[i] = u_sample[i]*r_rest\n                point = tuple(center[i] + sample_ellipsoid[i] for i in range(dim))\n                if in_bounds(point) and not collision_node(point):\n                    return point\n\n        def new_radius(iteration, tree_size):\n            # Adaptive radius shrinking over iterations and growing tree size, per theory ~ (log n / n)^{1/d}\n            if tree_size < 2:\n                return self.base_radius\n            gamma_rrt_star = self.base_radius\n            radius = min(gamma_rrt_star, \n                         gamma_rrt_star * (math.log(tree_size)/tree_size)**(1/dim))\n            # Enforce reasonable limits\n            return max(radius, self.step_size)\n\n        def propagate_cost(node):\n            for child in node.children:\n                new_cost = node.cost + dist(node.position, child.position)\n                if new_cost < child.cost:\n                    child.cost = new_cost\n                    propagate_cost(child)\n\n        def rewire(tree, new_node, near_nodes):\n            for near_node in near_nodes:\n                if near_node is new_node.parent:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, near_node.position)\n                est_total_new = new_cost + heuristic_cost_to_go(near_node.position)\n                est_total_old = near_node.cost + heuristic_cost_to_go(near_node.position)\n                if est_total_new + 1e-9 < est_total_old and new_cost < near_node.cost:\n                    if not collision_edge(new_node.position, near_node.position):\n                        # Remove old parent-child relationship\n                        if near_node.parent:\n                            near_node.parent.remove_child(near_node)\n                            if (near_node.parent, near_node) in edges:\n                                edges.remove((near_node.parent, near_node))\n                        near_node.parent = new_node\n                        near_node.cost = new_cost\n                        new_node.add_child(near_node)\n                        edges.append((new_node, near_node))\n                        propagate_cost(near_node)\n\n        def extract_path(node_start, node_goal):\n            path_start = []\n            node = node_start\n            while node:\n                path_start.append(node.position)\n                node = node.parent\n            path_start.reverse()\n            path_goal = []\n            node = node_goal\n            while node:\n                path_goal.append(node.position)\n                node = node.parent\n            return path_start + path_goal\n\n        def shortcut_path(path, max_iters=50):\n            length = len(path)\n            if length < 3:\n                return path[:]\n            new_path = path[:]\n            for _ in range(max_iters):\n                if len(new_path) < 3:\n                    break\n                i = random.randint(0, len(new_path)-3)\n                j = random.randint(i+2, len(new_path)-1)\n                if not collision_edge(new_path[i], new_path[j]):\n                    del new_path[i+1:j]\n            return new_path\n\n        for iter in range(1, self.max_iter+1):\n            sample = informed_sample()\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nn = nearest(tree_a, sample)\n                new_pos = steer(nn.position, sample)\n                if not in_bounds(new_pos):\n                    continue\n                if collision_node(new_pos):\n                    continue\n                if collision_edge(nn.position, new_pos):\n                    continue\n\n                radius = new_radius(iter, len(tree_a))\n                near_nodes = near(tree_a, new_pos, radius)\n\n                min_cost = nn.cost + dist(nn.position, new_pos)\n                min_parent = nn\n                for near_node in near_nodes:\n                    cost_cand = near_node.cost + dist(near_node.position, new_pos)\n                    if cost_cand < min_cost and not collision_edge(near_node.position, new_pos):\n                        min_cost = cost_cand\n                        min_parent = near_node\n\n                new_node = Node(new_pos, min_parent, min_cost)\n                min_parent.add_child(new_node)\n                tree_a.append(new_node)\n                edges.append((min_parent, new_node))\n\n                rewire(tree_a, new_node, near_nodes)\n\n                conn_node = nearest(tree_b, new_node.position)\n                dist_connect = dist(conn_node.position, new_node.position)\n                if dist_connect <= self.step_size and not collision_edge(conn_node.position, new_node.position):\n                    candidate_path = extract_path(new_node, conn_node)\n                    path_cost = 0.0\n                    for k in range(len(candidate_path)-1):\n                        path_cost += dist(candidate_path[k], candidate_path[k+1])\n                    if path_cost < best_cost:\n                        best_cost = path_cost\n                        best_path = shortcut_path(candidate_path, max_iters=100)\n                        if best_cost < float('inf'):\n                            return PlannerResult(True, best_path, start_tree + goal_tree, edges)\n\n        if best_path:\n            return PlannerResult(True, best_path, start_tree + goal_tree, edges)\n        return PlannerResult(False, [], start_tree + goal_tree, edges)",
        "objective": -26.27848,
        "time_improvement": 35.0,
        "length_improvement": 15.0,
        "smoothness_improvement": 1433.0,
        "node_improvement": 70.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.018117833137512206,
                "num_nodes_avg": 114.4,
                "path_length_avg": 171.0714968515819,
                "smoothness_avg": 0.0338915604180979,
                "success_improvement": 0.0,
                "time_improvement": 29.750819278110836,
                "node_improvement": 71.19113573407203,
                "length_improvement": 6.233001774308198,
                "smoothness_improvement": 430.476517244636,
                "objective_score": 14.81742943424135
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.031439352035522464,
                "num_nodes_avg": 278.2,
                "path_length_avg": 238.74291742398609,
                "smoothness_avg": 0.10316733134869423,
                "success_improvement": 0.0,
                "time_improvement": 81.01209719920723,
                "node_improvement": 81.3075320835853,
                "length_improvement": 20.300742330014568,
                "smoothness_improvement": 2554.5697440271038,
                "objective_score": 49.25692327790643
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.05441353321075439,
                "num_nodes_avg": 340.1,
                "path_length_avg": 124.59040420304787,
                "smoothness_avg": 0.11126977220167059,
                "success_improvement": 0.0,
                "time_improvement": -7.224742787261016,
                "node_improvement": 56.75778766687858,
                "length_improvement": 17.252985885842975,
                "smoothness_improvement": 1315.3432893250001,
                "objective_score": 14.761085141952478
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "m1",
        "algorithm_description": "A bidirectional RRT* variant with adaptive informed sampling, enhanced rewiring that updates descendant costs recursively for global improvements, and curvature-aware path shortcutting to improve smoothness and path length. The planner alternates expanding trees from start and goal, samples within an ellipsoidal informed region focusing search, connects nodes with minimum cost parents, and rewires incorporating full descendant cost updates to maintain path optimality. After finding a path, it applies iterative shortcutting with curvature constraints to ensure smooth transitions and feasible trajectories.",
        "planning_mechanism": "The planner alternates expansion of two trees from start and goal, uses adaptive ellipsoidal informed sampling to focus node sampling within a progressively shrinking region defined by current best path cost, and rewires nodes with recursive cost propagation for global cost updates. It attempts early connections between the trees when nodes are within step size and the connecting edge is collision-free. Upon finding a path, it applies iterative curvature-aware shortcutting that only shortens paths if curvature constraints are met, thus improving smoothness.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=5.0, neighbor_radius=15.0, goal_sample_rate=0.15, smooth_iter=150):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.neighbor_radius = neighbor_radius\n        self.goal_sample_rate = goal_sample_rate\n        self.smooth_iter = smooth_iter\n\n    def plan(self, map):\n        bounds = map.size\n        dim = len(bounds)\n        is_3d = dim == 3\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        import random\n        import math\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def in_bounds(p):\n            for i in range(dim):\n                if not (0 <= p[i] <= bounds[i]):\n                    return False\n            return True\n\n        def collision_node(p):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = p\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    px, py = p\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def collision_edge(a, b, resolution=0.3):\n            length = dist(a, b)\n            steps = max(2, int(length / resolution))\n            for i in range(steps + 1):\n                interp = tuple(a[d] + (b[d] - a[d]) * (i / steps) for d in range(dim))\n                if collision_node(interp):\n                    return True\n            return False\n\n        def steer(from_p, to_p):\n            length = dist(from_p, to_p)\n            if length <= self.step_size:\n                return to_p\n            ratio = self.step_size / length\n            return tuple(from_p[i] + (to_p[i] - from_p[i]) * ratio for i in range(dim))\n\n        def nearest(tree, point):\n            best_node = None\n            best_dist = math.inf\n            for node in tree:\n                d = dist(node.position, point)\n                if d < best_dist:\n                    best_node = node\n                    best_dist = d\n            return best_node\n\n        def near(tree, point, radius):\n            r2 = radius * radius\n            return [node for node in tree if sum((node.position[d] - point[d]) ** 2 for d in range(dim)) <= r2]\n\n        def path_to_go(p):\n            return dist(p, goal_pos)\n\n        def informed_sample(best_cost):\n            c_min = dist(start_pos, goal_pos)\n            if best_cost == math.inf or best_cost < c_min:\n                # Uniform random sample inside bounds with collision check\n                while True:\n                    s = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                    if not collision_node(s):\n                        return s\n            # Ellipsoidal informed sampling\n            c_best = best_cost\n            foci_dist = c_min\n            center = tuple((start_pos[i] + goal_pos[i]) * 0.5 for i in range(dim))\n            a = c_best / 2.0\n            val = c_best * c_best - foci_dist * foci_dist\n            if val < 1e-12:\n                b = 0.0\n            else:\n                b = math.sqrt(val) / 2.0\n\n            while True:\n                # sample in unit ball\n                while True:\n                    vec = [random.gauss(0, 1) for _ in range(dim)]\n                    norm = math.sqrt(sum(x * x for x in vec))\n                    if norm > 1e-7:\n                        break\n                unit = [x / norm for x in vec]\n                r = random.random() ** (1.0 / dim)\n                ball = [unit[i] * r for i in range(dim)]\n\n                sample_ellipsoid = [0.0] * dim\n                sample_ellipsoid[0] = ball[0] * a\n                for i in range(1, dim):\n                    sample_ellipsoid[i] = ball[i] * b\n\n                point = tuple(center[i] + sample_ellipsoid[i] for i in range(dim))\n                if in_bounds(point) and not collision_node(point):\n                    return point\n\n        def update_parent_cost_recursive(node):\n            for child in node.children:\n                new_cost = node.cost + dist(node.position, child.position)\n                if new_cost < child.cost:\n                    child.cost = new_cost\n                    child.parent = node\n                    update_parent_cost_recursive(child)\n\n        def update_parent_and_cost(child, new_parent, new_cost):\n            if child.parent:\n                child.parent.remove_child(child)\n            child.parent = new_parent\n            child.cost = new_cost\n            new_parent.add_child(child)\n            update_parent_cost_recursive(child)\n\n        def rewire_full(tree, new_node, near_nodes):\n            for near_n in near_nodes:\n                if near_n is new_node.parent:\n                    continue\n                c_through = new_node.cost + dist(new_node.position, near_n.position)\n                if c_through < near_n.cost:\n                    if not collision_edge(new_node.position, near_n.position):\n                        update_parent_and_cost(near_n, new_node, c_through)\n\n        def extract_path(node_start, node_goal):\n            path_start = []\n            n = node_start\n            while n:\n                path_start.append(n.position)\n                n = n.parent\n            path_start.reverse()\n            path_goal = []\n            n = node_goal\n            while n:\n                path_goal.append(n.position)\n                n = n.parent\n            return path_start + path_goal\n\n        def curvature(p1, p2, p3):\n            # Approximate curvature at p2 w.r.t neighbors p1 and p3\n            import math\n            a = math.dist(p1, p2)\n            b = math.dist(p2, p3)\n            c = math.dist(p1, p3)\n            if a < 1e-6 or b < 1e-6:\n                return 0.0\n            # Law of cosines to get angle at p2\n            try:\n                cos_angle = (a*a + b*b - c*c) / (2 * a * b)\n                cos_angle = min(1.0, max(-1.0, cos_angle))\n                angle = math.acos(cos_angle)\n                radius = c / (2 * math.sin(angle)) if abs(angle) > 1e-6 else float('inf')\n                curvature_val = 1.0 / radius if radius > 1e-6 else float('inf')\n                return curvature_val\n            except:\n                return 0.0\n\n        def curvature_aware_shortcut(path, max_curvature=0.15, iterations=None):\n            if len(path) < 3:\n                return path[:]\n            import random\n            new_path = path[:]\n            iters = iterations if iterations is not None else self.smooth_iter\n            for _ in range(iters):\n                if len(new_path) < 3:\n                    break\n                i = random.randint(0, len(new_path) - 3)\n                j = random.randint(i + 2, len(new_path) - 1)\n                if collision_edge(new_path[i], new_path[j]):\n                    continue\n                # Check curvature if shortcut applied: Inspect neighbors around shortcut\n                before = new_path[max(i-1, 0)]\n                after = new_path[min(j+1, len(new_path)-1)]\n                # For indices i-1, i, j and i, j, j+1 triplets for curvature check\n                # First triplet:\n                curv1 = curvature(before, new_path[i], new_path[j]) if i > 0 else 0.0\n                # Second triplet:\n                curv2 = curvature(new_path[i], new_path[j], after) if j < len(new_path)-1 else 0.0\n                if curv1 <= max_curvature and curv2 <= max_curvature:\n                    new_path = new_path[:i+1] + new_path[j:]\n            return new_path\n\n        tree_start = [Node(start_pos)]\n        tree_goal = [Node(goal_pos)]\n        edges = []\n        best_cost = math.inf\n        best_path = []\n\n        for iter in range(self.max_iter):\n            if random.random() < self.goal_sample_rate:\n                sample = goal_pos\n            else:\n                sample = informed_sample(best_cost)\n\n            for tree_a, tree_b in [(tree_start, tree_goal), (tree_goal, tree_start)]:\n                nearest_node = nearest(tree_a, sample)\n                new_pos = steer(nearest_node.position, sample)\n                if not in_bounds(new_pos):\n                    continue\n                if collision_node(new_pos):\n                    continue\n                if collision_edge(nearest_node.position, new_pos):\n                    continue\n\n                near_nodes = near(tree_a, new_pos, self.neighbor_radius)\n                min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n                min_parent = nearest_node\n                for near_node in near_nodes:\n                    candidate_cost = near_node.cost + dist(near_node.position, new_pos)\n                    if candidate_cost < min_cost and not collision_edge(near_node.position, new_pos):\n                        min_cost = candidate_cost\n                        min_parent = near_node\n\n                new_node = Node(new_pos, min_parent, min_cost)\n                min_parent.add_child(new_node)\n                tree_a.append(new_node)\n                edges.append((min_parent, new_node))\n\n                rewire_full(tree_a, new_node, near_nodes)\n\n                nearest_other = nearest(tree_b, new_node.position)\n                if dist(new_node.position, nearest_other.position) <= self.step_size and not collision_edge(new_node.position, nearest_other.position):\n                    candidate_path = extract_path(new_node, nearest_other)\n                    cost_candidate = 0.0\n                    for k in range(len(candidate_path) - 1):\n                        cost_candidate += dist(candidate_path[k], candidate_path[k + 1])\n                    if cost_candidate < best_cost:\n                        best_cost = cost_candidate\n                        # Apply curvature-aware smoothing with more iterations after connection\n                        best_path = curvature_aware_shortcut(candidate_path, iterations=self.smooth_iter)\n                        # Early return for best found path\n                        return PlannerResult(True, best_path, tree_start + tree_goal, edges)\n\n        if best_path:\n            return PlannerResult(True, best_path, tree_start + tree_goal, edges)\n        return PlannerResult(False, [], tree_start + tree_goal, edges)",
        "objective": -5.73861,
        "time_improvement": -36.0,
        "length_improvement": 17.0,
        "smoothness_improvement": 1263.0,
        "node_improvement": 65.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.05177156925201416,
                "num_nodes_avg": 143.9,
                "path_length_avg": 165.93075816926788,
                "smoothness_avg": 0.041603726714277645,
                "success_improvement": 0.0,
                "time_improvement": -100.73649519988538,
                "node_improvement": 63.76227650465878,
                "length_improvement": 9.050722106301821,
                "smoothness_improvement": 551.1886670170101,
                "objective_score": -22.03457196109947
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.06509325504302979,
                "num_nodes_avg": 331.0,
                "path_length_avg": 233.69307486837343,
                "smoothness_avg": 0.08407213264203503,
                "success_improvement": 0.0,
                "time_improvement": 60.68670886258219,
                "node_improvement": 77.75986024323053,
                "length_improvement": 21.986525126736794,
                "smoothness_improvement": 2063.2365275890634,
                "objective_score": 41.71411037276205
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.08536667823791504,
                "num_nodes_avg": 355.9,
                "path_length_avg": 120.11866214506578,
                "smoothness_avg": 0.1001327204763105,
                "success_improvement": 0.0,
                "time_improvement": -68.21955084611585,
                "node_improvement": 54.7488874761602,
                "length_improvement": 20.2229040392802,
                "smoothness_improvement": 1173.6808134300672,
                "objective_score": -2.4637187631162982
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "m3",
        "algorithm_description": "An efficient bidirectional RRT* with adaptive informed sampling and incremental path shortcutting, focusing sampling within an ellipsoidal subset around the best path to accelerate convergence, combined with local rewiring for path optimization and progressive shortcutting to improve path smoothness and length while reducing planning time. The planner grows two trees from start and goal, alternately expanding toward sampled points focused by current best solution, connects the two trees when possible, rewires locally to optimize costs, and progressively shortcuts the path during planning for smoother results.",
        "planning_mechanism": "The planner alternates growth of two trees (start and goal) using adaptive informed sampling within an ellipsoidal subset defined by the current best path cost. At each iteration, a sample point is generated; nearest nodes are extended toward it with collision checking. The algorithm rewires nearby nodes to optimize path costs locally. Upon connecting both trees, it extracts the combined path and incrementally applies shortcutting to remove unnecessary waypoints and smooth the trajectory. This approach balances efficient exploration, path quality, and runtime performance.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n    def add_child(self, child):\n        self.children.append(child)\nclass Planner:\n    def __init__(self, max_iter=4000, step_size=6.0, radius=12.0, shortcut_interval=50):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.radius = radius\n        self.shortcut_interval = shortcut_interval\n\n    def plan(self, map):\n        import random\n        import math\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = (len(bounds) == 3)\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        best_cost = float('inf')\n        solution_start, solution_goal = None, None\n\n        c_min = math.dist(start_pos, goal_pos)\n        dim = 3 if is_3d else 2\n\n        for i in range(self.max_iter):\n            # Adaptive Sample\n            if best_cost < float('inf'):\n                sample = self._informed_sample(bounds, obstacles, is_3d, start_pos, goal_pos, best_cost, c_min)\n            else:\n                sample = self._sample_free(bounds, obstacles, is_3d)\n\n            # Alternate tree expansion\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest = self._nearest(tree_a, sample)\n                new_pos = self._steer(nearest.position, sample, self.step_size)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                    continue\n\n                new_node = Node(new_pos)\n                near_nodes = self._near(tree_a, new_pos, self.radius)\n\n                min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n                min_parent = nearest\n                for near in near_nodes:\n                    tentative_cost = near.cost + math.dist(near.position, new_pos)\n                    if tentative_cost < min_cost and not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d):\n                        min_cost = tentative_cost\n                        min_parent = near\n\n                new_node.parent = min_parent\n                new_node.cost = min_cost\n                min_parent.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((min_parent, new_node))\n\n                # Rewire near nodes to new_node if beneficial\n                for near in near_nodes:\n                    if near is min_parent:\n                        continue\n                    new_cost = new_node.cost + math.dist(new_node.position, near.position)\n                    if new_cost < near.cost and not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                        if near.parent:\n                            try: edges.remove((near.parent, near))\n                            except ValueError: pass\n                            # Remove near from old parent's children list safely\n                            try: near.parent.children.remove(near)\n                            except ValueError: pass\n                        near.parent = new_node\n                        near.cost = new_cost\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n\n                # Try to connect both trees to form path\n                connect_node = self._nearest(tree_b, new_node.position)\n                dist_connect = math.dist(new_node.position, connect_node.position)\n                if dist_connect <= self.step_size:\n                    if not self._is_edge_in_obstacle(new_node.position, connect_node.position, obstacles, is_3d):\n                        path_cost = new_node.cost + dist_connect + connect_node.cost\n                        if path_cost < best_cost:\n                            best_cost = path_cost\n                            if tree_a is start_tree:\n                                solution_start, solution_goal = new_node, connect_node\n                            else:\n                                solution_start, solution_goal = connect_node, new_node\n\n            # Progressive shortcutting for smoother path every shortcut_interval iterations\n            if best_cost < float('inf') and solution_start and solution_goal and (i % self.shortcut_interval == 0 or i == self.max_iter-1):\n                raw_path = self._extract_path(solution_start, solution_goal)\n                shortcut_path = self._shortcut_path(raw_path, obstacles, is_3d, max_attempts=50)\n                if shortcut_path:\n                    return PlannerResult(True, shortcut_path, nodes, edges)\n\n        # No solution found\n        return PlannerResult(False, [], nodes, edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        import random\n        while True:\n            pt = tuple(random.uniform(0, bounds[i]) for i in range(len(bounds)))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def _informed_sample(self, bounds, obstacles, is_3d, start, goal, c_max, c_min):\n        import random\n        import math\n        dim = 3 if is_3d else 2\n\n        # Reject sample if no valid ellipsoid (e.g. c_max <= c_min)\n        if c_max <= c_min:\n            return self._sample_free(bounds, obstacles, is_3d)\n\n        center = tuple((start[i]+goal[i])/2 for i in range(dim))\n        dir_vec = [goal[i]-start[i] for i in range(dim)]\n        length = math.dist(start, goal)\n        if length == 0:\n            # No interval, uniform sample fallback\n            return self._sample_free(bounds, obstacles, is_3d)\n\n        # Compute rotation matrix R from canonical axis to direction vector\n        if dim == 2:\n            a1 = [1,0]\n            a2 = [dir_vec[0]/length, dir_vec[1]/length]\n            cos_theta = a1[0]*a2[0] + a1[1]*a2[1]\n            sin_theta = a1[0]*a2[1] - a1[1]*a2[0]\n            R = [[cos_theta, -sin_theta],[sin_theta, cos_theta]]\n        else:\n            from math import sqrt\n            a1 = [1,0,0]\n            a2 = [dir_vec[i]/length for i in range(3)]\n            v = [a1[1]*a2[2]-a1[2]*a2[1], a1[2]*a2[0]-a1[0]*a2[2], a1[0]*a2[1]-a1[1]*a2[0]]\n            s = sqrt(sum([vi*vi for vi in v]))\n            c = sum([a1[i]*a2[i] for i in range(3)])\n            if s == 0:\n                R = [[1,0,0],[0,1,0],[0,0,1]]\n            else:\n                vx = [[0,-v[2],v[1]],[v[2],0,-v[0]],[-v[1],v[0],0]]\n                I = [[1 if i==j else 0 for j in range(3)] for i in range(3)]\n                vx2 = [[sum(vx[i][k]*vx[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n                R = [[I[i][j] + vx[i][j] + vx2[i][j]*((1 - c)/(s**2)) for j in range(3)] for i in range(3)]\n\n        # Sample point inside unit ball\n        if dim == 2:\n            r = random.uniform(0,1)**0.5\n            theta = random.uniform(0, 2*math.pi)\n            x_ball = [r*math.cos(theta), r*math.sin(theta)]\n        else:\n            while True:\n                x_ball = [random.uniform(-1,1) for _ in range(3)]\n                if sum(xi*xi for xi in x_ball) <= 1:\n                    break\n\n        a1_val = c_max / 2.0\n        a_other = math.sqrt(c_max**2 - c_min**2) / 2.0\n\n        # Scaling matrix\n        if dim == 2:\n            L = [[a1_val, 0],[0, a_other]]\n            x_scaled = [L[0][0]*x_ball[0] + L[0][1]*x_ball[1],\n                        L[1][0]*x_ball[0] + L[1][1]*x_ball[1]]\n            pt = (center[0] + R[0][0]*x_scaled[0] + R[0][1]*x_scaled[1],\n                  center[1] + R[1][0]*x_scaled[0] + R[1][1]*x_scaled[1])\n        else:\n            L = [[a1_val, 0, 0],[0, a_other, 0],[0, 0, a_other]]\n            x_scaled = [L[0][0]*x_ball[0], L[1][1]*x_ball[1], L[2][2]*x_ball[2]]\n            pt = tuple(center[i] + sum(R[i][j]*x_scaled[j] for j in range(3)) for i in range(3))\n\n        # Reject if outside bounds or in obstacle\n        if any(pt[d] < 0 or pt[d] > bounds[d] for d in range(dim)):\n            return self._sample_free(bounds, obstacles, is_3d)\n        if self._is_in_obstacle(pt, obstacles, is_3d):\n            return self._sample_free(bounds, obstacles, is_3d)\n\n        return pt\n\n    def _nearest(self, tree, point):\n        import math\n        return min(tree, key=lambda n: math.dist(n.position, point))\n\n    def _near(self, tree, point, radius):\n        r_sq = radius*radius\n        return [n for n in tree if sum((n.position[i]-point[i])**2 for i in range(len(point))) <= r_sq]\n\n    def _steer(self, from_pos, to_pos, step_size):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        if dist <= step_size:\n            return to_pos\n        ratio = step_size / dist\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i])*ratio for i in range(len(from_pos)))\n\n    def _extract_path(self, node_start, node_goal):\n        path_start, path_goal = [], []\n        n = node_start\n        while n:\n            path_start.append(n.position)\n            n = n.parent\n        n = node_goal\n        while n:\n            path_goal.append(n.position)\n            n = n.parent\n        return list(reversed(path_start)) + path_goal\n\n    def _shortcut_path(self, path, obstacles, is_3d, max_attempts=30):\n        # Attempt bounded shortcutting to improve smoothness by removing redundant waypoints\n        if len(path) < 3:\n            return path[:]\n        import random\n        new_path = path[:]\n        attempts = 0\n        while attempts < max_attempts:\n            if len(new_path) < 3:\n                break\n            i = random.randint(0, len(new_path)-3)\n            j = random.randint(i+2, len(new_path)-1)\n            if not self._is_edge_in_obstacle(new_path[i], new_path[j], obstacles, is_3d):\n                # Remove intermediate nodes between i and j\n                new_path = new_path[:i+1] + new_path[j:]\n                attempts = 0  # reset attempts after successful shortcut\n            else:\n                attempts += 1\n        return new_path\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x,y,z,w,h,d=obs\n                px,py,pz=pos\n                if x<=px<=x+w and y<=py<=y+h and z<=pz<=z+d:\n                    return True\n            else:\n                x,y,w,h=obs\n                px,py=pos\n                if x<=px<=x+w and y<=py<=y+h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist/resolution))\n        for i in range(steps+1):\n            interp = tuple(from_pos[d] + (to_pos[d]-from_pos[d])*(i/steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
        "objective": -30.55144,
        "time_improvement": 46.0,
        "length_improvement": 18.0,
        "smoothness_improvement": 1254.0,
        "node_improvement": 72.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.019833183288574217,
                "num_nodes_avg": 147.4,
                "path_length_avg": 162.65169192869433,
                "smoothness_avg": 0.04547432196696187,
                "success_improvement": 0.0,
                "time_improvement": 23.09980633143671,
                "node_improvement": 62.880886426592795,
                "length_improvement": 10.848030272889844,
                "smoothness_improvement": 611.7718878536382,
                "objective_score": 16.49761950243311
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.023508524894714354,
                "num_nodes_avg": 236.2,
                "path_length_avg": 226.91038346862007,
                "smoothness_avg": 0.07885871014571852,
                "success_improvement": 0.0,
                "time_improvement": 85.80194702529162,
                "node_improvement": 84.12954377477658,
                "length_improvement": 24.250782744921644,
                "smoothness_improvement": 1929.091411682397,
                "objective_score": 49.936510812952456
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.036681842803955075,
                "num_nodes_avg": 255.1,
                "path_length_avg": 123.45751291252664,
                "smoothness_avg": 0.10380569995332274,
                "success_improvement": 0.0,
                "time_improvement": 27.71649022711396,
                "node_improvement": 67.56516211061665,
                "length_improvement": 18.005398338521033,
                "smoothness_improvement": 1220.4008412665191,
                "objective_score": 25.220190277579402
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "m1",
        "algorithm_description": "A novel bidirectional RRT* variant with adaptive informed sampling based on current best path cost combined with a heuristic-driven prioritized rewiring scheme. Instead of uniform or vanilla informed sampling, the algorithm dynamically shrinks its sampling ellipsoid region as solutions improve for faster convergence. The rewiring phase favors nodes estimated closer to the goal using a heuristic distance, guiding tree restructuring to yield shorter, smoother paths. Post-processing employs an iterative shortcutting approach that refines path smoothness while preserving collision-free guarantees. This approach balances global exploration and local optimization to enhance planning efficiency, path length, and smoothness while reducing runtime.",
        "planning_mechanism": "The planner grows two bidirectional trees from start and goal, sampling adaptive informed points inside a shrinking ellipsoid focused by the best path cost. It extends and rewires nodes by prioritizing neighbors nearer the goal heuristic, striving for low-cost rewiring. Trees attempt to connect continuously, updating best solutions. Upon finishing, the path undergoes iterative shortcut smoothing to remove unnecessary waypoints. This coordinated mechanism improves convergence speed, reduces excessive edge checks, and enhances solution quality.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n    def add_child(self, child):\n        self.children.append(child)\nclass Planner:\n    def __init__(self, max_iter=4000, step_size=6.0, max_radius=20.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.max_radius = max_radius\n\n    def plan(self, map):\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        c_min = math.dist(start_pos, goal_pos)\n        best_cost = float('inf')\n        solution_nodes = (None, None)\n\n        # Precompute dimension for convenience\n        dim = 3 if is_3d else 2\n\n        def heuristic_to_goal(p):\n            return math.dist(p, goal_pos)\n\n        def heuristic_to_start(p):\n            return math.dist(p, start_pos)\n\n        for iter in range(self.max_iter):\n            # Adaptive informed sampling inside ellipsoid shrinking as best_cost improves\n            sample = self._adaptive_informed_sample(bounds, obstacles, is_3d, start_pos, goal_pos, best_cost, c_min)\n            \n            # Alternate tree roles each iteration\n            if iter % 2 == 0:\n                tree_a, tree_b = start_tree, goal_tree\n                heuristic_a, heuristic_b = heuristic_to_goal, heuristic_to_start\n            else:\n                tree_a, tree_b = goal_tree, start_tree\n                heuristic_a, heuristic_b = heuristic_to_start, heuristic_to_goal\n            \n            nearest = self._nearest(tree_a, sample)\n            new_pos = self._steer(nearest.position, sample)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d): continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d): continue\n            \n            near_nodes = self._near(tree_a, new_pos, self.max_radius)\n            # Prioritize near nodes by heuristic to goal (or start)\n            near_nodes.sort(key=lambda n: heuristic_a(n.position))\n            \n            # Choose best parent based on cost + heuristic + collision free\n            min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n            best_parent = nearest\n            for nnode in near_nodes:\n                if nnode is nearest:\n                    continue\n                tentative_cost = nnode.cost + math.dist(nnode.position, new_pos)\n                if tentative_cost + heuristic_a(new_pos) >= min_cost + heuristic_a(new_pos):\n                    # Prune candidates that are not better in cost + heuristic\n                    continue\n                if self._is_edge_in_obstacle(nnode.position, new_pos, obstacles, is_3d):\n                    continue\n                min_cost = tentative_cost\n                best_parent = nnode\n            \n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n            \n            # Rewire neighbors that improve cost with heuristic guidance\n            for neighbor in near_nodes:\n                if neighbor is best_parent or neighbor is new_node:\n                    continue\n                new_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n                # Only rewire if new cost + heuristic less than existing\n                if new_cost + heuristic_a(neighbor.position) + 1e-8 < neighbor.cost + heuristic_a(neighbor.position):\n                    if self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        continue\n                    if neighbor.parent:\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        if neighbor in neighbor.parent.children:\n                            neighbor.parent.children.remove(neighbor)\n                    neighbor.parent = new_node\n                    neighbor.cost = new_cost\n                    new_node.add_child(neighbor)\n                    edges.append((new_node, neighbor))\n            \n            # Try connection to other tree within step size and free space\n            conn_node = self._nearest(tree_b, new_node.position)\n            dist_conn = math.dist(new_node.position, conn_node.position)\n            if dist_conn <= self.step_size:\n                if not self._is_edge_in_obstacle(new_node.position, conn_node.position, obstacles, is_3d):\n                    path_cost = new_node.cost + dist_conn + conn_node.cost\n                    if path_cost < best_cost:\n                        best_cost = path_cost\n                        if iter % 2 == 0:\n                            solution_nodes = (new_node, conn_node)\n                        else:\n                            solution_nodes = (conn_node, new_node)\n            \n            # Periodically extract and iteratively shortcut path for smoothness improvement\n            if solution_nodes[0] and solution_nodes[1] and (iter % 150 == 0 or iter == self.max_iter - 1):\n                raw_path = self._extract_path(solution_nodes[0], solution_nodes[1])\n                shortcut_path = self._iterative_shortcut(raw_path, obstacles, is_3d)\n                if shortcut_path:\n                    return PlannerResult(True, shortcut_path, nodes, edges)\n\n        # Final check after iterations\n        if solution_nodes[0] and solution_nodes[1]:\n            raw_path = self._extract_path(solution_nodes[0], solution_nodes[1])\n            shortcut_path = self._iterative_shortcut(raw_path, obstacles, is_3d)\n            return PlannerResult(True, shortcut_path, nodes, edges)\n        else:\n            return PlannerResult(False, [], nodes, edges)\n\n    def _adaptive_informed_sample(self, bounds, obstacles, is_3d, start, goal, c_max, c_min):\n        dim = 3 if is_3d else 2\n        if c_max == float('inf') or c_max <= c_min:\n            # Uniform random sampling if no valid path found yet\n            while True:\n                pt = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not self._is_in_obstacle(pt, obstacles, is_3d):\n                    return pt\n\n        c_max = min(c_max, sum(bounds)*10)  # Clamp c_max to reasonable upper bound\n        center = tuple((start[i] + goal[i]) / 2 for i in range(dim))\n        dir_vec = [goal[i] - start[i] for i in range(dim)]\n        length = math.dist(start, goal)\n        if length == 0:\n            # Degenerate case\n            return start\n\n        # Rotation matrix to align x-axis to direction vector (2D or 3D)\n        if dim == 2:\n            a1 = [1, 0]\n            a2 = [dir_vec[0]/length, dir_vec[1]/length]\n            cos_theta = a1[0]*a2[0] + a1[1]*a2[1]\n            sin_theta = a1[0]*a2[1] - a1[1]*a2[0]\n            R = [[cos_theta, -sin_theta],[sin_theta, cos_theta]]\n        else:\n            # 3D rotation matrix from x-axis to dir_vec using Rodrigues formula\n            a1 = [1, 0, 0]\n            a2 = [dir_vec[i]/length for i in range(3)]\n            v = [a1[1]*a2[2] - a1[2]*a2[1],\n                 a1[2]*a2[0] - a1[0]*a2[2],\n                 a1[0]*a2[1] - a1[1]*a2[0]]\n            s = math.sqrt(sum(vi*vi for vi in v))\n            c = sum(a1[i]*a2[i] for i in range(3))\n            if s == 0:\n                R = [[1,0,0],[0,1,0],[0,0,1]]\n            else:\n                vx = [[0, -v[2], v[1]],\n                      [v[2], 0, -v[0]],\n                      [-v[1], v[0], 0]]\n                I = [[1 if i == j else 0 for j in range(3)] for i in range(3)]\n                vx2 = [[sum(vx[i][k]*vx[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n                R = [[I[i][j] + vx[i][j] + ((1 - c)/(s**2))*vx2[i][j] for j in range(3)] for i in range(3)]\n\n        a1_val = c_max / 2.0\n        try:\n            a_others = math.sqrt(abs(c_max*c_max - c_min*c_min)) / 2.0\n        except Exception:\n            a_others = a1_val\n\n        while True:\n            # Sample point in unit ball\n            if dim == 2:\n                r = random.uniform(0, 1)**0.5\n                theta = random.uniform(0, 2*math.pi)\n                x_ball = [r*math.cos(theta), r*math.sin(theta)]\n                L = [[a1_val, 0], [0, a_others]]\n                x_scaled = [L[0][0]*x_ball[0] + L[0][1]*x_ball[1],\n                            L[1][0]*x_ball[0] + L[1][1]*x_ball[1]]\n                pt_rot = (R[0][0]*x_scaled[0] + R[0][1]*x_scaled[1],\n                          R[1][0]*x_scaled[0] + R[1][1]*x_scaled[1])\n                pt = tuple(center[i] + pt_rot[i] for i in range(dim))\n            else:\n                while True:\n                    x_ball = [random.uniform(-1,1) for _ in range(3)]\n                    if sum(xi*xi for xi in x_ball) <= 1:\n                        break\n                L = [[a1_val,0,0],[0,a_others,0],[0,0,a_others]]\n                x_scaled = [L[0][0]*x_ball[0], L[1][1]*x_ball[1], L[2][2]*x_ball[2]]\n                pt_rot = [sum(R[i][j]*x_scaled[j] for j in range(3)) for i in range(3)]\n                pt = tuple(center[i] + pt_rot[i] for i in range(dim))\n\n            # Check bounds\n            if any(pt[d] < 0 or pt[d] > bounds[d] for d in range(dim)):\n                continue\n            if self._is_in_obstacle(pt, obstacles, is_3d):\n                continue\n            return pt\n\n    def _nearest(self, tree, point):\n        return min(tree, key=lambda node: math.dist(node.position, point))\n\n    def _near(self, tree, point, radius):\n        radius_sq = radius*radius\n        return [node for node in tree if self._squared_distance(node.position, point) <= radius_sq]\n\n    def _steer(self, from_pos, to_pos):\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[i] + (to_pos[i]-from_pos[i])*ratio for i in range(len(from_pos)))\n\n    def _extract_path(self, node_start, node_goal):\n        path_start = []\n        n = node_start\n        while n:\n            path_start.append(n.position)\n            n = n.parent\n        path_goal = []\n        n = node_goal\n        while n:\n            path_goal.append(n.position)\n            n = n.parent\n        return list(reversed(path_start)) + path_goal\n\n    def _iterative_shortcut(self, path, obstacles, is_3d, max_attempts=150):\n        if len(path) < 3:\n            return path[:]\n        path = path[:]\n        for _ in range(max_attempts):\n            if len(path) < 3:\n                break\n            i = random.randint(0, len(path)-3)\n            j = random.randint(i+2, len(path)-1)\n            if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                # Remove intermediate nodes between i and j\n                path = path[:i+1] + path[j:]\n        return path\n\n    def _squared_distance(self, a, b):\n        return sum((a[i] - b[i])**2 for i in range(len(a)))\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x,y,z,w,h,d = obs\n                px,py,pz = pos\n                if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                    return True\n            else:\n                x,y,w,h = obs\n                px,py = pos\n                if x <= px <= x+w and y <= py <= y+h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist/resolution))\n        for i in range(steps+1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d])*(i/steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
        "objective": -14.08602,
        "time_improvement": -15.0,
        "length_improvement": 20.0,
        "smoothness_improvement": 1402.0,
        "node_improvement": 63.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.05029592514038086,
                "num_nodes_avg": 197.7,
                "path_length_avg": 161.93878883699725,
                "smoothness_avg": 0.047628044606518545,
                "success_improvement": 0.0,
                "time_improvement": -95.01490647056376,
                "node_improvement": 50.21405187610174,
                "length_improvement": 11.23878375412141,
                "smoothness_improvement": 645.482324046268,
                "objective_score": -18.53379006846494
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.059864473342895505,
                "num_nodes_avg": 338.1,
                "path_length_avg": 225.87643224817134,
                "smoothness_avg": 0.0890107769545784,
                "success_improvement": 0.0,
                "time_improvement": 63.844649222693185,
                "node_improvement": 77.2828058859101,
                "length_improvement": 24.59594542294319,
                "smoothness_improvement": 2190.3114029125213,
                "objective_score": 44.86251903513647
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.05845465660095215,
                "num_nodes_avg": 311.2,
                "path_length_avg": 116.34668105324462,
                "smoothness_avg": 0.11554898589311344,
                "success_improvement": 0.0,
                "time_improvement": -15.18798998915194,
                "node_improvement": 60.43229497774952,
                "length_improvement": 22.7280742780298,
                "smoothness_improvement": 1369.7745716214542,
                "objective_score": 15.929320428179569
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "m2",
        "algorithm_description": "An enhanced bidirectional RRT* algorithm with adaptive radius rewiring, probabilistic goal bias sampling, dynamic local rewiring for cost optimization, adaptive informed sampling to accelerate convergence, and progressive path shortcutting to improve smoothness and shorten path length. The planner grows two trees alternately, samples with goal bias and informed sampling when available, connects trees when possible, rewires nodes within a dynamic radius based on tree size and dimension for path improvement, and applies shortcutting regularly during planning to enhance path smoothness and reduce planning time.",
        "planning_mechanism": "The planner alternately expands two trees from start and goal, using a probabilistic goal bias combined with adaptive informed sampling inside an ellipsoidal subset of the search space bounded by the current best path cost to efficiently explore relevant regions. Each expansion step selects the nearest node, steers toward the sample within step size, performs collision checks, and attempts rewirings in an adaptively scaled neighborhood radius for path quality optimization. Upon connecting both trees, the path is extracted and progressively shortcut during planning iterations to smooth and shorten it, which significantly improves convergence speed, path length and smoothness, while reducing overall planning time.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n    def add_child(self, child):\n        self.children.append(child)\nclass Planner:\n    def __init__(self, max_iter=4000, step_size=6.0, radius_constant=30.0, goal_bias=0.15, shortcut_interval=40):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.radius_constant = radius_constant\n        self.goal_bias = goal_bias\n        self.shortcut_interval = shortcut_interval\n\n    def plan(self, map):\n        import random\n        import math\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = (len(bounds) == 3)\n        dim = 3 if is_3d else 2\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        best_cost = float('inf')\n        solution_start, solution_goal = None, None\n\n        c_min = math.dist(start_pos, goal_pos)\n\n        for iter in range(self.max_iter):\n            # Sample with goal bias and informed sampling if best cost known\n            if best_cost < float('inf'):\n                if random.random() < self.goal_bias:\n                    sample = goal_pos\n                else:\n                    sample = self._informed_sample(bounds, obstacles, is_3d, start_pos, goal_pos, best_cost, c_min)\n            else:\n                sample = self._sample_free(bounds, obstacles, is_3d)\n\n            # Expand both trees alternately\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest = self._nearest(tree_a, sample)\n                new_pos = self._steer(nearest.position, sample, self.step_size)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                    continue\n\n                new_node = Node(new_pos)\n                # Adaptive radius based on tree size and dimension\n                radius = min(self.radius_constant * ((math.log(len(tree_a)+1) / (len(tree_a)+1))**(1/dim)), self.step_size*30)\n\n                near_nodes = self._near(tree_a, new_pos, radius)\n\n                # Choose best parent among near nodes\n                min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n                min_parent = nearest\n                for near in near_nodes:\n                    tentative_cost = near.cost + math.dist(near.position, new_pos)\n                    if tentative_cost < min_cost and not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d):\n                        min_cost = tentative_cost\n                        min_parent = near\n\n                new_node.parent = min_parent\n                new_node.cost = min_cost\n                min_parent.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((min_parent, new_node))\n\n                # Rewire near nodes to new_node if beneficial\n                for near in near_nodes:\n                    if near is min_parent:\n                        continue\n                    new_cost = new_node.cost + math.dist(new_node.position, near.position)\n                    if new_cost < near.cost and not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                        if near.parent:\n                            try:\n                                edges.remove((near.parent, near))\n                            except ValueError:\n                                pass\n                            try:\n                                near.parent.children.remove(near)\n                            except ValueError:\n                                pass\n                        near.parent = new_node\n                        near.cost = new_cost\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n\n                # Attempt to connect trees\n                connect_node = self._nearest(tree_b, new_node.position)\n                dist_connect = math.dist(new_node.position, connect_node.position)\n                if dist_connect <= self.step_size and not self._is_edge_in_obstacle(new_node.position, connect_node.position, obstacles, is_3d):\n                    path_cost = new_node.cost + dist_connect + connect_node.cost\n                    if path_cost < best_cost:\n                        best_cost = path_cost\n                        if tree_a is start_tree:\n                            solution_start, solution_goal = new_node, connect_node\n                        else:\n                            solution_start, solution_goal = connect_node, new_node\n\n            # Progressive shortcutting applied regularly\n            if best_cost < float('inf') and solution_start and solution_goal and (iter % self.shortcut_interval == 0 or iter == self.max_iter - 1):\n                raw_path = self._extract_path(solution_start, solution_goal)\n                shortcut_path = self._shortcut_path(raw_path, obstacles, is_3d, max_attempts=60)\n                if shortcut_path:\n                    return PlannerResult(True, shortcut_path, nodes, edges)\n\n        return PlannerResult(False, [], nodes, edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        import random\n        while True:\n            pt = tuple(random.uniform(0, bounds[i]) for i in range(len(bounds)))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def _informed_sample(self, bounds, obstacles, is_3d, start, goal, c_max, c_min):\n        import random\n        import math\n        dim = 3 if is_3d else 2\n        if c_max <= c_min:\n            return self._sample_free(bounds, obstacles, is_3d)\n\n        center = tuple((start[i]+goal[i])/2 for i in range(dim))\n        dir_vec = [goal[i]-start[i] for i in range(dim)]\n        length = math.dist(start, goal)\n        if length == 0:\n            return self._sample_free(bounds, obstacles, is_3d)\n\n        if dim == 2:\n            a1 = [1,0]\n            a2 = [dir_vec[0]/length, dir_vec[1]/length]\n            cos_theta = a1[0]*a2[0] + a1[1]*a2[1]\n            sin_theta = a1[0]*a2[1] - a1[1]*a2[0]\n            R = [[cos_theta, -sin_theta],[sin_theta, cos_theta]]\n        else:\n            from math import sqrt\n            a1 = [1,0,0]\n            a2 = [dir_vec[i]/length for i in range(3)]\n            v = [a1[1]*a2[2]-a1[2]*a2[1], a1[2]*a2[0]-a1[0]*a2[2], a1[0]*a2[1]-a1[1]*a2[0]]\n            s = sqrt(sum([vi*vi for vi in v]))\n            c = sum([a1[i]*a2[i] for i in range(3)])\n            if s == 0:\n                R = [[1,0,0],[0,1,0],[0,0,1]]\n            else:\n                vx = [[0,-v[2],v[1]],[v[2],0,-v[0]],[-v[1],v[0],0]]\n                I = [[1 if i==j else 0 for j in range(3)] for i in range(3)]\n                vx2 = [[sum(vx[i][k]*vx[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n                R = [[I[i][j] + vx[i][j] + vx2[i][j]*((1 - c)/(s**2)) for j in range(3)] for i in range(3)]\n\n        if dim == 2:\n            r = random.uniform(0,1)**0.5\n            theta = random.uniform(0, 2*math.pi)\n            x_ball = [r*math.cos(theta), r*math.sin(theta)]\n        else:\n            while True:\n                x_ball = [random.uniform(-1,1) for _ in range(3)]\n                if sum(xi*xi for xi in x_ball) <= 1:\n                    break\n\n        a1_val = c_max / 2.0\n        a_other = math.sqrt(c_max**2 - c_min**2) / 2.0\n\n        if dim == 2:\n            L = [[a1_val, 0],[0, a_other]]\n            x_scaled = [L[0][0]*x_ball[0] + L[0][1]*x_ball[1],\n                        L[1][0]*x_ball[0] + L[1][1]*x_ball[1]]\n            pt = (center[0] + R[0][0]*x_scaled[0] + R[0][1]*x_scaled[1],\n                  center[1] + R[1][0]*x_scaled[0] + R[1][1]*x_scaled[1])\n        else:\n            L = [[a1_val, 0, 0],[0, a_other, 0],[0, 0, a_other]]\n            x_scaled = [L[0][0]*x_ball[0], L[1][1]*x_ball[1], L[2][2]*x_ball[2]]\n            pt = tuple(center[i] + sum(R[i][j]*x_scaled[j] for j in range(3)) for i in range(3))\n\n        if any(pt[d] < 0 or pt[d] > bounds[d] for d in range(dim)):\n            return self._sample_free(bounds, obstacles, is_3d)\n        if self._is_in_obstacle(pt, obstacles, is_3d):\n            return self._sample_free(bounds, obstacles, is_3d)\n\n        return pt\n\n    def _nearest(self, tree, point):\n        import math\n        return min(tree, key=lambda n: math.dist(n.position, point))\n\n    def _near(self, tree, point, radius):\n        r_sq = radius*radius\n        return [n for n in tree if sum((n.position[i]-point[i])**2 for i in range(len(point))) <= r_sq]\n\n    def _steer(self, from_pos, to_pos, step_size):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        if dist <= step_size:\n            return to_pos\n        ratio = step_size / dist\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i])*ratio for i in range(len(from_pos)))\n\n    def _extract_path(self, node_start, node_goal):\n        path_start, path_goal = [], []\n        n = node_start\n        while n:\n            path_start.append(n.position)\n            n = n.parent\n        n = node_goal\n        while n:\n            path_goal.append(n.position)\n            n = n.parent\n        return list(reversed(path_start)) + path_goal\n\n    def _shortcut_path(self, path, obstacles, is_3d, max_attempts=60):\n        if len(path) < 3:\n            return path[:]\n        import random\n        new_path = path[:]\n        attempts = 0\n        while attempts < max_attempts:\n            if len(new_path) < 3:\n                break\n            i = random.randint(0, len(new_path)-3)\n            j = random.randint(i+2, len(new_path)-1)\n            if not self._is_edge_in_obstacle(new_path[i], new_path[j], obstacles, is_3d):\n                new_path = new_path[:i+1] + new_path[j:]\n                attempts = 0\n            else:\n                attempts += 1\n        return new_path\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x,y,z,w,h,d = obs\n                px,py,pz = pos\n                if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                    return True\n            else:\n                x,y,w,h = obs\n                px,py = pos\n                if x <= px <= x+w and y <= py <= y+h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist/resolution))\n        for i in range(steps+1):\n            interp = tuple(from_pos[d] + (to_pos[d]-from_pos[d])*(i/steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
        "objective": -22.60434,
        "time_improvement": 28.0,
        "length_improvement": 11.0,
        "smoothness_improvement": 1504.0,
        "node_improvement": 68.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.021024632453918456,
                "num_nodes_avg": 149.4,
                "path_length_avg": 179.86562069368742,
                "smoothness_avg": 0.04340391432894737,
                "success_improvement": 0.0,
                "time_improvement": 18.480140883479937,
                "node_improvement": 62.37723495341224,
                "length_improvement": 1.41280314464036,
                "smoothness_improvement": 579.365512356565,
                "objective_score": 9.288551713611021
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.02810840606689453,
                "num_nodes_avg": 272.4,
                "path_length_avg": 245.75216437677005,
                "smoothness_avg": 0.0991357257905606,
                "success_improvement": 0.0,
                "time_improvement": 83.02383326220045,
                "node_improvement": 81.69723845998791,
                "length_improvement": 17.960853947188074,
                "smoothness_improvement": 2450.8336291682162,
                "objective_score": 47.93783049281406
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.0594691276550293,
                "num_nodes_avg": 313.1,
                "path_length_avg": 129.64938979692397,
                "smoothness_avg": 0.1243235500601021,
                "success_improvement": 0.0,
                "time_improvement": -17.187058813027633,
                "node_improvement": 60.19071837253656,
                "length_improvement": 13.893048537397146,
                "smoothness_improvement": 1481.3863801545947,
                "objective_score": 10.586643379302972
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "m3",
        "algorithm_description": "A streamlined bidirectional RRT* planner that alternates tree expansions with goal bias, fixed-radius rewiring, and straightforward path shortcutting for efficient planning and improved path quality. It uses simple nearest neighbor searches and basic collision checks to maintain clarity and generalizability.",
        "planning_mechanism": "The planner grows two trees from start and goal alternately, samples points biased towards the goal, connects nodes using fixed step sizes and radius for rewiring, and upon connecting the trees, extracts and shortcuts the path to reduce length and improve smoothness.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\nclass Planner:\n    def __init__(self, max_iter=3000, step_size=5.0, goal_sample_rate=0.1, radius=10.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.radius = radius\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n\n        start_tree = [Node(start)]\n        goal_tree = [Node(goal)]\n        edges = []\n        for i in range(self.max_iter):\n            sample = goal if self._random() < self.goal_sample_rate else self._sample_free(bounds, obstacles, dim)\n\n            trees = [(start_tree, goal_tree), (goal_tree, start_tree)]\n            active_tree, other_tree = trees[i % 2]\n\n            nearest = self._nearest(active_tree, sample)\n            new_pos = self._steer(nearest.position, sample, self.step_size)\n            if self._collides(new_pos, obstacles, dim):\n                continue\n            if self._edge_collides(nearest.position, new_pos, obstacles, dim):\n                continue\n\n            new_node = Node(new_pos)\n            near_nodes = self._near(active_tree, new_pos, self.radius)\n            min_cost, min_parent = nearest.cost + self._dist(nearest.position, new_pos), nearest\n\n            for near in near_nodes:\n                cost = near.cost + self._dist(near.position, new_pos)\n                if cost < min_cost and not self._edge_collides(near.position, new_pos, obstacles, dim):\n                    min_cost, min_parent = cost, near\n\n            new_node.parent = min_parent\n            new_node.cost = min_cost\n            min_parent.add_child(new_node)\n            active_tree.append(new_node)\n            edges.append((min_parent, new_node))\n\n            for near in near_nodes:\n                if near is min_parent:\n                    continue\n                new_cost = new_node.cost + self._dist(new_node.position, near.position)\n                if new_cost < near.cost and not self._edge_collides(new_node.position, near.position, obstacles, dim):\n                    if near.parent:\n                        try:\n                            edges.remove((near.parent, near))\n                        except ValueError:\n                            pass\n                        near.parent.children.remove(near)\n                    near.parent = new_node\n                    near.cost = new_cost\n                    new_node.add_child(near)\n                    edges.append((new_node, near))\n\n            connect_node = self._nearest(other_tree, new_node.position)\n            if self._dist(new_node.position, connect_node.position) <= self.step_size and not self._edge_collides(new_node.position, connect_node.position, obstacles, dim):\n                path = self._extract_path(new_node, connect_node)\n                path = self._shortcut_path(path, obstacles, dim)\n                return PlannerResult(True, path, start_tree + goal_tree, edges)\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    def _sample_free(self, bounds, obstacles, dim):\n        while True:\n            point = tuple(self._random() * bounds[i] for i in range(dim))\n            if not self._collides(point, obstacles, dim):\n                return point\n\n    def _nearest(self, tree, point):\n        best, best_dist = None, float('inf')\n        for node in tree:\n            dist = self._dist(node.position, point)\n            if dist < best_dist:\n                best, best_dist = node, dist\n        return best\n\n    def _near(self, tree, point, radius):\n        r_sq = radius * radius\n        return [node for node in tree if self._dist_sq(node.position, point) <= r_sq]\n\n    def _steer(self, from_pos, to_pos, step):\n        dist = self._dist(from_pos, to_pos)\n        if dist <= step:\n            return to_pos\n        ratio = step / dist\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n    def _dist(self, a, b):\n        return self._dist_sq(a, b) ** 0.5\n\n    def _dist_sq(self, a, b):\n        return sum((a[i] - b[i]) ** 2 for i in range(len(a)))\n\n    def _collides(self, pos, obstacles, dim):\n        if dim == 3:\n            x, y, z = pos\n            for obs in obstacles:\n                ox, oy, oz, w, h, d = obs\n                if ox <= x <= ox + w and oy <= y <= oy + h and oz <= z <= oz + d:\n                    return True\n        else:\n            x, y = pos\n            for obs in obstacles:\n                ox, oy, w, h = obs\n                if ox <= x <= ox + w and oy <= y <= oy + h:\n                    return True\n        return False\n\n    def _edge_collides(self, start, end, obstacles, dim, resolution=0.5):\n        dist = self._dist(start, end)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            point = tuple(start[j] + (end[j] - start[j]) * i / steps for j in range(dim))\n            if self._collides(point, obstacles, dim):\n                return True\n        return False\n\n    def _extract_path(self, node_a, node_b):\n        path_a = []\n        while node_a:\n            path_a.append(node_a.position)\n            node_a = node_a.parent\n        path_b = []\n        while node_b:\n            path_b.append(node_b.position)\n            node_b = node_b.parent\n        return list(reversed(path_a)) + path_b\n\n    def _shortcut_path(self, path, obstacles, dim, max_attempts=40):\n        path = path[:]\n        attempts = 0\n        while attempts < max_attempts and len(path) > 2:\n            i = int(self._random() * (len(path) - 2))\n            j = int(i + 2 + self._random() * (len(path) - i - 2))\n            if j >= len(path):\n                j = len(path) - 1\n            if not self._edge_collides(path[i], path[j], obstacles, dim):\n                del path[i+1:j]\n            attempts += 1\n        return path\n\n    def _random(self):\n        # To allow testing replace with random.random(), here stub for determinism if needed\n        import random\n        return random.random()",
        "objective": -6.82375,
        "time_improvement": -25.0,
        "length_improvement": 16.0,
        "smoothness_improvement": 998.0,
        "node_improvement": 69.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.04590208530426025,
                "num_nodes_avg": 161.1,
                "path_length_avg": 170.32708573767837,
                "smoothness_avg": 0.02884305512385804,
                "success_improvement": 0.0,
                "time_improvement": -77.97845148348269,
                "node_improvement": 59.430873835305974,
                "length_improvement": 6.641025301787684,
                "smoothness_improvement": 351.4564463850669,
                "objective_score": -17.65163803204686
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.09899413585662842,
                "num_nodes_avg": 319.9,
                "path_length_avg": 232.70596040537356,
                "smoothness_avg": 0.06308823090997337,
                "success_improvement": 0.0,
                "time_improvement": 40.21215744617372,
                "node_improvement": 78.50567761875966,
                "length_improvement": 22.316052347000596,
                "smoothness_improvement": 1523.3056219296157,
                "objective_score": 33.069806751700554
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.06967871189117432,
                "num_nodes_avg": 249.0,
                "path_length_avg": 123.85483726002462,
                "smoothness_avg": 0.09591030345606508,
                "success_improvement": 0.0,
                "time_improvement": -37.30558409690246,
                "node_improvement": 68.34075015893197,
                "length_improvement": 17.741514425465155,
                "smoothness_improvement": 1119.97198059895,
                "objective_score": 5.053093329203105
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "e2",
        "algorithm_description": "A unified bidirectional RRT* planner leveraging ellipsoidal informed sampling, dynamic neighborhood radius scaling based on node density, and incremental path shortcutting to enhance efficiency, path length, and smoothness. It alternates tree expansions from start and goal states, samples intelligently within a biasing ellipsoid after initial solutions, rewires neighbors using an adaptive radius following theoretical optimal connection distances, and progressively shortcuts the current best path to maintain smoothness. This approach integrates adaptive rewiring radius, efficient collision checking with early exit, and continuous path refinement to robustly reduce planning time and improve path quality.",
        "planning_mechanism": "The planner maintains two rapidly exploring trees from start and goal, alternately extending them toward samples constrained inside an ellipsoidal informed subset after the first solution. It estimates an adaptive near radius based on theoretical RRT* bounds and current node count to optimize local rewiring. After each improved solution, it extracts and incrementally shortcuts the path to remove unnecessary waypoints and smooth turns, thus continuously improving path quality while minimizing overall runtime.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n    def add_child(self, child):\n        self.children.append(child)\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except ValueError:\n            pass\nclass Planner:\n    def __init__(self, max_iter=4500, step_size=6.5, gamma_rrt_star=50.0, shortcut_interval=40, max_shortcut_attempts=40):\n        # max_iter: max number of iterations\n        # step_size: max extension distance per step\n        # gamma_rrt_star: scaling factor for radius: typically > unit ball volume constant\n        # shortcut_interval: iterations frequency to apply path shortcutting\n        # max_shortcut_attempts: max attempts per incremental shortcutting\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.gamma_rrt_star = gamma_rrt_star\n        self.shortcut_interval = shortcut_interval\n        self.max_shortcut_attempts = max_shortcut_attempts\n\n    def plan(self, map):\n        import random\n        import math\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = (len(bounds) == 3)\n        dim = 3 if is_3d else 2\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        best_cost = float('inf')\n        solution_start, solution_goal = None, None\n        c_min = math.dist(start_pos, goal_pos)\n        volume_unit_ball = self._unit_ball_volume(dim)  # used for radius adapt\n\n        def near_radius(n_nodes):\n            # Adaptive near radius per RRT* theory: gamma * (log(n)/n)^{1/d}\n            if n_nodes <= 1:\n                return self.step_size * 2.5  # fallback large radius initially\n            return min(self.step_size * 50,\n                       self.gamma_rrt_star * (math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n\n        def attempt_connection(tree_a, tree_b, sample):\n            # Extend tree_a toward sample, rewire and try connecting with tree_b\n            nearest = self._nearest(tree_a, sample)\n            new_pos = self._steer(nearest.position, sample, self.step_size)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                return None\n\n            new_node = Node(new_pos)\n            radius = near_radius(len(tree_a))\n            near_nodes = self._near(tree_a, new_pos, radius)\n\n            min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n            min_parent = nearest\n            # Select best parent from near nodes with collision-check\n            for near in near_nodes:\n                tentative_cost = near.cost + math.dist(near.position, new_pos)\n                if tentative_cost < min_cost:\n                    if not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d):\n                        min_cost = tentative_cost\n                        min_parent = near\n\n            new_node.parent = min_parent\n            new_node.cost = min_cost\n            min_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((min_parent, new_node))\n\n            # Rewire neighbors to new_node if improves cost and collision-free\n            for near in near_nodes:\n                if near is min_parent:\n                    continue\n                new_cost = new_node.cost + math.dist(new_node.position, near.position)\n                if new_cost < near.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                        # Remove old edge\n                        if near.parent:\n                            try:\n                                edges.remove((near.parent, near))\n                            except ValueError:\n                                pass\n                            near.parent.remove_child(near)\n                        near.parent = new_node\n                        near.cost = new_cost\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n\n            # Attempt to connect new_node with nearest node in tree_b within step size\n            connect_candidate = self._nearest(tree_b, new_node.position)\n            dist_connect = math.dist(new_node.position, connect_candidate.position)\n            if dist_connect <= self.step_size:\n                if not self._is_edge_in_obstacle(new_node.position, connect_candidate.position, obstacles, is_3d):\n                    total_cost = new_node.cost + dist_connect + connect_candidate.cost\n                    if total_cost < best_cost:\n                        return new_node, connect_candidate, total_cost\n            return None\n\n        def informed_sample():\n            # Ellipsoidal informed sampling inside prolate hyperspheroid given current best_cost\n            if best_cost == float('inf') or best_cost <= c_min:\n                return self._sample_free(bounds, obstacles, is_3d)\n            center = tuple((start_pos[i] + goal_pos[i]) / 2 for i in range(dim))\n            dir_vec = [goal_pos[i] - start_pos[i] for i in range(dim)]\n            length = math.dist(start_pos, goal_pos)\n            # Compute rotation matrix R from canonical axis to direction\n            if dim == 2:\n                if length < 1e-10:\n                    R = [[1, 0], [0, 1]]\n                else:\n                    a1 = [1, 0]\n                    a2 = [dir_vec[0] / length, dir_vec[1] / length]\n                    cos_theta = a1[0] * a2[0] + a1[1] * a2[1]\n                    sin_theta = a1[0] * a2[1] - a1[1] * a2[0]\n                    R = [[cos_theta, -sin_theta], [sin_theta, cos_theta]]\n            else:\n                # 3D rotation matrix by axis-angle\n                from math import sqrt\n                if length < 1e-10:\n                    R = [[1,0,0],[0,1,0],[0,0,1]]\n                else:\n                    a1 = [1,0,0]\n                    a2 = [dir_vec[i] / length for i in range(3)]\n                    v = [a1[1]*a2[2]-a1[2]*a2[1], a1[2]*a2[0]-a1[0]*a2[2], a1[0]*a2[1]-a1[1]*a2[0]]\n                    s = sqrt(sum(vi*vi for vi in v))\n                    c = sum(a1[i]*a2[i] for i in range(3))\n                    if s < 1e-10:\n                        R = [[1,0,0],[0,1,0],[0,0,1]]\n                    else:\n                        vx = [[0,-v[2],v[1]],[v[2],0,-v[0]],[-v[1],v[0],0]]\n                        I = [[1 if i==j else 0 for j in range(3)] for i in range(3)]\n                        vx2 = [[sum(vx[i][k]*vx[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n                        R = [[I[i][j] + vx[i][j] + vx2[i][j]*((1 - c)/(s**2)) for j in range(3)] for i in range(3)]\n\n            a1_val = best_cost / 2.0\n            a_other = math.sqrt(best_cost**2 - c_min**2) / 2.0\n            import random\n\n            while True:\n                # Sample unit ball point\n                if dim == 2:\n                    r = random.uniform(0,1)**0.5\n                    theta = random.uniform(0, 2*math.pi)\n                    x_ball = [r*math.cos(theta), r*math.sin(theta)]\n                    L = [[a1_val, 0],[0, a_other]]\n                    x_scaled = [L[0][0]*x_ball[0] + L[0][1]*x_ball[1],\n                                L[1][0]*x_ball[0] + L[1][1]*x_ball[1]]\n                    pt = (center[0] + R[0][0]*x_scaled[0] + R[0][1]*x_scaled[1],\n                          center[1] + R[1][0]*x_scaled[0] + R[1][1]*x_scaled[1])\n                else:\n                    while True:\n                        x_ball = [random.uniform(-1,1) for _ in range(3)]\n                        if sum(xi*xi for xi in x_ball) <= 1:\n                            break\n                    L = [[a1_val, 0, 0],[0, a_other, 0],[0, 0, a_other]]\n                    x_scaled = [L[0][0]*x_ball[0], L[1][1]*x_ball[1], L[2][2]*x_ball[2]]\n                    pt = tuple(center[i] + sum(R[i][j]*x_scaled[j] for j in range(dim)) for i in range(dim))\n\n                # Check bounds and obstacles\n                if any(pt[d] < 0 or pt[d] > bounds[d] for d in range(dim)):\n                    continue\n                if self._is_in_obstacle(pt, obstacles, is_3d):\n                    continue\n                return pt\n\n        # Progressive path shortcutting with limited attempts to improve smoothness incrementally\n        def progressive_shortcut(path):\n            if len(path) < 3:\n                return path[:]\n            import random\n            new_path = path[:]\n            attempts = 0\n            while attempts < self.max_shortcut_attempts:\n                if len(new_path) < 3:\n                    break\n                i = random.randint(0, len(new_path)-3)\n                j = random.randint(i+2, len(new_path)-1)\n                if not self._is_edge_in_obstacle(new_path[i], new_path[j], obstacles, is_3d):\n                    new_path = new_path[:i+1] + new_path[j:]\n                    attempts = 0  # reset on success\n                else:\n                    attempts += 1\n            return new_path\n\n        for iteration in range(self.max_iter):\n            sample = informed_sample() if (best_cost < float('inf')) else self._sample_free(bounds, obstacles, is_3d)\n\n            # Alternate tree expansion\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                result = attempt_connection(tree_a, tree_b, sample)\n                if result is not None:\n                    new_node, connect_node, total_cost = result\n                    if total_cost < best_cost:\n                        best_cost = total_cost\n                        if tree_a is start_tree:\n                            solution_start, solution_goal = new_node, connect_node\n                        else:\n                            solution_start, solution_goal = connect_node, new_node\n\n            # Incremental shortcut every shortcut_interval iterations after finding a solution\n            if best_cost < float('inf') and solution_start and solution_goal:\n                if iteration % self.shortcut_interval == 0 or iteration == self.max_iter - 1:\n                    raw_path = self._extract_path(solution_start, solution_goal)\n                    improved_path = progressive_shortcut(raw_path)\n                    if improved_path and len(improved_path) >= 2:\n                        return PlannerResult(True, improved_path, nodes, edges)\n\n        # No solution found\n        return PlannerResult(False, [], nodes, edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        import random\n        while True:\n            pt = tuple(random.uniform(0, bounds[i]) for i in range(len(bounds)))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def _nearest(self, tree, point):\n        import math\n        best_node = None\n        best_dist = float('inf')\n        for node in tree:\n            d = 0.0\n            for i in range(len(point)):\n                diff = node.position[i] - point[i]\n                d += diff*diff\n            if d < best_dist:\n                best_dist = d\n                best_node = node\n        return best_node\n\n    def _near(self, tree, point, radius):\n        r_sq = radius*radius\n        near_nodes = []\n        for n in tree:\n            d = 0.0\n            for i in range(len(point)):\n                diff = n.position[i] - point[i]\n                d += diff*diff\n            if d <= r_sq:\n                near_nodes.append(n)\n        return near_nodes\n\n    def _steer(self, from_pos, to_pos, step_size):\n        import math\n        dist = 0.0\n        for i in range(len(from_pos)):\n            diff = to_pos[i] - from_pos[i]\n            dist += diff*diff\n        dist = dist**0.5\n        if dist <= step_size:\n            return to_pos\n        ratio = step_size / dist\n        new_pos = tuple(from_pos[i] + ratio * (to_pos[i] - from_pos[i]) for i in range(len(from_pos)))\n        return new_pos\n\n    def _extract_path(self, node_start, node_goal):\n        path_start = []\n        n = node_start\n        while n is not None:\n            path_start.append(n.position)\n            n = n.parent\n        path_goal = []\n        n = node_goal\n        while n is not None:\n            path_goal.append(n.position)\n            n = n.parent\n        return list(reversed(path_start)) + path_goal\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x,y,z,w,h,d = obs\n                px,py,pz = pos\n                if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                    return True\n            else:\n                x,y,w,h = obs\n                px,py = pos\n                if x <= px <= x+w and y <= py <= y+h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        dist = 0.0\n        for i in range(len(from_pos)):\n            diff = to_pos[i] - from_pos[i]\n            dist += diff*diff\n        dist = dist**0.5\n        steps = max(1, int(dist / resolution))\n        for step in range(steps+1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (step / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _unit_ball_volume(self, dim):\n        import math\n        # Volume of unit ball in dimension dim\n        if dim == 2:\n            return math.pi\n        elif dim == 3:\n            return 4.0/3.0 * math.pi\n        else:\n            # General formula using gamma function approximation\n            from math import gamma\n            return (math.pi**(dim/2)) / gamma(dim/2 + 1)",
        "objective": -28.03557,
        "time_improvement": 38.0,
        "length_improvement": 15.0,
        "smoothness_improvement": 1533.0,
        "node_improvement": 72.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.023175954818725586,
                "num_nodes_avg": 135.3,
                "path_length_avg": 175.79982556162778,
                "smoothness_avg": 0.04886810478019664,
                "success_improvement": 0.0,
                "time_improvement": 10.13871106406778,
                "node_improvement": 65.92797783933518,
                "length_improvement": 3.641329883168963,
                "smoothness_improvement": 664.8919585980976,
                "objective_score": 8.550871042112199
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.03271842002868652,
                "num_nodes_avg": 261.1,
                "path_length_avg": 229.80246953520958,
                "smoothness_avg": 0.09634245712495317,
                "success_improvement": 0.0,
                "time_improvement": 80.239599766615,
                "node_improvement": 82.45649398642746,
                "length_improvement": 23.28532117181223,
                "smoothness_improvement": 2378.9608144920394,
                "objective_score": 49.937876705532034
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.03931493759155273,
                "num_nodes_avg": 263.8,
                "path_length_avg": 122.75935520727265,
                "smoothness_avg": 0.13016053434098707,
                "success_improvement": 0.0,
                "time_improvement": 22.527837796824144,
                "node_improvement": 66.45899554990464,
                "length_improvement": 18.469081443653348,
                "smoothness_improvement": 1555.6323893660885,
                "objective_score": 25.617962152069694
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "m3",
        "algorithm_description": "This algorithm implements an adaptive bidirectional RRT* planner with goal bias and progressive shortcutting for improved path quality, smoothness, and planning efficiency. It alternately expands two trees from start and goal, dynamically adjusts rewiring radius based on tree size, leverages goal bias sampling to focus exploration, and employs repeated path shortcutting to smooth and shorten the resulting path before returning it. This balanced approach enhances convergence speed, reduces path length, and significantly improves smoothness while maintaining collision-free guarantees.",
        "planning_mechanism": "The planner grows two trees from start and goal positions using an RRT* framework with adaptive radius rewiring for local optimality. It samples random points with goal bias, extends each tree towards samples, rewires to reduce path cost, and attempts to connect the trees when close. Upon connecting, it extracts the combined path and performs multiple shortcutting passes to smooth the path before outputting the result.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.children.remove(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=4.0, goal_sample_rate=0.1, gamma=30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.gamma = gamma  # tuning parameter for adaptive radius\n\n    def plan(self, map):\n        import math\n        import random\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = dim == 3\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    px, py = pos\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def edge_in_obstacle(p1, p2, resolution=1.0):\n            d = dist(p1, p2)\n            steps = max(1, int(d / resolution))\n            for i in range(steps + 1):\n                interp = tuple(p1[j] + (p2[j] - p1[j]) * i / steps for j in range(dim))\n                if in_obstacle(interp):\n                    return True\n            return False\n\n        def steer(from_p, to_p, max_step):\n            d = dist(from_p, to_p)\n            if d <= max_step:\n                return to_p\n            ratio = max_step / d\n            return tuple(from_p[i] + (to_p[i] - from_p[i]) * ratio for i in range(dim))\n\n        def get_nearest(tree, point):\n            return min(tree, key=lambda node: dist(node.position, point))\n\n        def get_near_nodes(tree, new_pos, radius):\n            return [node for node in tree if dist(node.position, new_pos) <= radius]\n\n        def adaptive_radius(n):\n            # Based on RRT* radius scaling law\n            if n == 0:\n                return self.step_size * 2\n            return min(self.gamma * (math.log(n) / n) ** (1 / dim), self.step_size * 20)\n\n        def rewire(tree, nodes, edges, new_node, near_nodes):\n            for near_node in near_nodes:\n                if near_node is new_node.parent:\n                    continue\n                cost_through_new = new_node.cost + dist(new_node.position, near_node.position)\n                if cost_through_new + 1e-7 < near_node.cost:\n                    if not edge_in_obstacle(new_node.position, near_node.position):\n                        if (near_node.parent, near_node) in edges:\n                            edges.remove((near_node.parent, near_node))\n                        near_node.update_parent(new_node, cost_through_new)\n                        edges.append((new_node, near_node))\n\n        nodes_start = [Node(start_pos)]\n        nodes_goal = [Node(goal_pos)]\n        edges = []\n        forward_tree = nodes_start\n        backward_tree = nodes_goal\n        success = False\n        connect_node_start = None\n        connect_node_goal = None\n\n        for it in range(self.max_iter):\n            # Alternate growing trees\n            for grow_start_tree_first in (True, False):\n                if grow_start_tree_first:\n                    tree_a, tree_b = forward_tree, backward_tree\n                else:\n                    tree_a, tree_b = backward_tree, forward_tree\n\n                # Sample with goal bias toward other tree's root\n                if random.random() < self.goal_sample_rate:\n                    sample = tree_b[0].position\n                else:\n                    sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if in_obstacle(sample):\n                    continue\n\n                nearest = get_nearest(tree_a, sample)\n                new_pos = steer(nearest.position, sample, self.step_size)\n                if in_obstacle(new_pos) or edge_in_obstacle(nearest.position, new_pos):\n                    continue\n\n                # Adaptive radius dependent on current tree size\n                radius = adaptive_radius(len(tree_a) + 1)\n                near_nodes = get_near_nodes(tree_a, new_pos, radius)\n\n                # Choose best parent among near nodes\n                min_cost = nearest.cost + dist(nearest.position, new_pos)\n                best_parent = nearest\n                for near in near_nodes:\n                    if not edge_in_obstacle(near.position, new_pos):\n                        cost_candidate = near.cost + dist(near.position, new_pos)\n                        if cost_candidate < min_cost:\n                            min_cost = cost_candidate\n                            best_parent = near\n\n                new_node = Node(new_pos)\n                new_node.parent = best_parent\n                new_node.cost = min_cost\n                best_parent.add_child(new_node)\n                tree_a.append(new_node)\n                edges.append((best_parent, new_node))\n\n                # Rewire near nodes to new node if cost improves and collision free\n                rewire(tree_a, tree_a, edges, new_node, near_nodes)\n\n                # Try to connect trees\n                nearest_in_other = get_nearest(tree_b, new_node.position)\n                if dist(new_node.position, nearest_in_other.position) <= self.step_size:\n                    if not edge_in_obstacle(new_node.position, nearest_in_other.position):\n                        # Connect trees\n                        connect_node_start = new_node if grow_start_tree_first else nearest_in_other\n                        connect_node_goal = nearest_in_other if grow_start_tree_first else new_node\n                        success = True\n                        break\n            if success:\n                break\n\n        def extract_path(node_start, node_goal):\n            path_start = []\n            cur = node_start\n            while cur:\n                path_start.append(cur.position)\n                cur = cur.parent\n            path_goal = []\n            cur = node_goal\n            while cur:\n                path_goal.append(cur.position)\n                cur = cur.parent\n            return path_start[::-1] + path_goal\n\n        def shortcut_path(path, max_attempts=100):\n            if len(path) < 3:\n                return path\n            for _ in range(max_attempts):\n                if len(path) <= 2:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if not edge_in_obstacle(p1, p2):\n                    # Remove intermediate points between i and j\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        nodes_all = nodes_start + nodes_goal\n        if success:\n            raw_path = extract_path(connect_node_start, connect_node_goal)\n            smoothed_path = shortcut_path(raw_path, max_attempts=200)\n            return PlannerResult(True, smoothed_path, nodes_all, edges)\n        else:\n            return PlannerResult(False, [], nodes_all, edges)",
        "objective": -26.77328,
        "time_improvement": 30.0,
        "length_improvement": 17.0,
        "smoothness_improvement": 1515.0,
        "node_improvement": 64.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.026349878311157225,
                "num_nodes_avg": 131.5,
                "path_length_avg": 161.50533767083496,
                "smoothness_avg": 0.04633540991002978,
                "success_improvement": 0.0,
                "time_improvement": -2.1677012604634127,
                "node_improvement": 66.88491563837825,
                "length_improvement": 11.476365206768222,
                "smoothness_improvement": 625.2497840450478,
                "objective_score": 9.361757666147147
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.0372589111328125,
                "num_nodes_avg": 338.9,
                "path_length_avg": 239.0656007486035,
                "smoothness_avg": 0.10263753383464265,
                "success_improvement": 0.0,
                "time_improvement": 77.49735483562543,
                "node_improvement": 77.22905328226837,
                "length_improvement": 20.193021348332763,
                "smoothness_improvement": 2540.9376723928312,
                "objective_score": 48.069707621651446
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.0440518856048584,
                "num_nodes_avg": 400.8,
                "path_length_avg": 120.37369996551419,
                "smoothness_avg": 0.11632493211416521,
                "success_improvement": 0.0,
                "time_improvement": 13.193431402810726,
                "node_improvement": 49.040050858232675,
                "length_improvement": 20.053520062534325,
                "smoothness_improvement": 1379.6445502788406,
                "objective_score": 22.888364209758016
            }
        ],
        "success_rate": 1.0
    }
]