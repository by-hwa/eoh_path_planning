[
    {
        "parents": [
            {
                "operator": "initial",
                "algorithm_description": "This algorithm grows two trees simultaneously, one from the start position and one from the goal position, and attempts to connect them to find a feasible path. This bidirectional approach accelerates convergence and increases the success rate compared to a single tree RRT.",
                "planning_mechanism": "The planning mechanism involves randomly sampling points within the map bounds, extending each tree towards the sampled points, and attempting to connect the two trees whenever new nodes are added. Collision checks are performed for nodes and edges to ensure safety, and once the two trees connect, the final path is reconstructed by backtracking through the parent nodes of each tree.",
                "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map) -> PlannerResult:\n        import math, random\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position)\n        goal_root = Node(goal_position)\n        nodes.extend([start_root, goal_root])\n        tree_a, tree_b = [start_root], [goal_root]\n\n        for _ in range(self.max_iter):\n            rand_point = self._sample_free(bounds, obstacles, is_3d)\n            new_a = self._extend_tree(tree_a, rand_point, obstacles, is_3d, nodes, edges)\n            if new_a is None:\n                continue\n\n            new_b = self._connect_trees(tree_b, new_a, obstacles, is_3d, nodes, edges)\n            if new_b:\n                success_state = True\n                path_a = new_a.path_from_root()\n                path_b = new_b.path_from_root()\n                extracted_path = path_a + path_b[::-1]\n                break\n\n            tree_a, tree_b = tree_b, tree_a  # Swap trees\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        import random\n        while True:\n            if is_3d:\n                p = (random.uniform(0, bounds[0]),\n                     random.uniform(0, bounds[1]),\n                     random.uniform(0, bounds[2]))\n            else:\n                p = (random.uniform(0, bounds[0]),\n                     random.uniform(0, bounds[1]))\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    def _nearest(self, tree, point):\n        import math\n        return min(tree, key=lambda node: math.dist(node.position, point))\n\n    def _steer(self, from_pos, to_pos):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _extend_tree(self, tree, point, obstacles, is_3d, nodes, edges):\n        nearest_node = self._nearest(tree, point)\n        new_pos = self._steer(nearest_node.position, point)\n        if not self._is_in_obstacle(new_pos, obstacles, is_3d) and not self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n            new_node = Node(new_pos, parent=nearest_node)\n            nearest_node.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n            return new_node\n        return None\n\n    def _connect_trees(self, tree, new_node, obstacles, is_3d, nodes, edges):\n        import math\n        nearest_node = self._nearest(tree, new_node.position)\n        while True:\n            new_pos = self._steer(nearest_node.position, new_node.position)\n            if (not self._is_in_obstacle(new_pos, obstacles, is_3d) and\n                not self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d)):\n                next_node = Node(new_pos, parent=nearest_node)\n                nearest_node.add_child(next_node)\n                tree.append(next_node)\n                nodes.append(next_node)\n                edges.append((nearest_node, next_node))\n\n                if math.dist(next_node.position, new_node.position) <= self.step_size:\n                    if not self._is_edge_in_obstacle(next_node.position, new_node.position, obstacles, is_3d):\n                        final_node = Node(new_node.position, parent=next_node)\n                        next_node.add_child(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((next_node, final_node))\n                        return final_node\n                    else:\n                        return None\n                nearest_node = next_node\n            else:\n                return None\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n",
                "objective": -26.362545864580685,
                "time_improvement": 90.0,
                "length_improvement": -1.0,
                "smoothness_improvement": 66.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.003386783599853516,
                        "num_nodes_avg": 73.4,
                        "path_length_avg": 177.51024218247147,
                        "smoothness_avg": 0.010853898808599488,
                        "success_improvement": 0.0,
                        "time_improvement": 86.62742971615343,
                        "node_improvement": 81.51599093427349,
                        "length_improvement": 2.703823429998762,
                        "smoothness_improvement": 69.8870859730897,
                        "objective_score": 27.959958402710736
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.009759879112243653,
                        "num_nodes_avg": 243.3,
                        "path_length_avg": 305.6633464494545,
                        "smoothness_avg": 0.00635818912126643,
                        "success_improvement": 0.0,
                        "time_improvement": 94.10558227316062,
                        "node_improvement": 83.65248941745615,
                        "length_improvement": -2.0392230764353463,
                        "smoothness_improvement": 63.60078570869974,
                        "objective_score": 27.326144764630474
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.006081390380859375,
                        "num_nodes_avg": 146.7,
                        "path_length_avg": 157.76295455386602,
                        "smoothness_avg": 0.012848764272999446,
                        "success_improvement": 0.0,
                        "time_improvement": 87.83847763555195,
                        "node_improvement": 81.34774316592498,
                        "length_improvement": -4.778642550069787,
                        "smoothness_improvement": 63.43533315542768,
                        "objective_score": 23.801534426400853
                    }
                ],
                "success_rate": 1.0
            },
            {
                "operator": "initial",
                "algorithm_description": "This algorithm is a dual-tree variant of Rapidly-exploring Random Tree (RRT) that grows two trees from the start and goal positions, attempting to connect them as they expand. It is efficient for single-query problems due to its bidirectional search and reduced redundant exploration.",
                "planning_mechanism": "The planner alternates between growing the start and goal trees by extending towards randomly sampled points. Each extension step involves checking for collision-free motion and attempting to connect the two trees. The algorithm terminates when a valid path is formed connecting the trees.",
                "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n        nodes = []\n        edges = []\n        success_state = False\n        extracted_path = []\n\n        for iter in range(self.max_iter):\n            rand = self._sample_free(bounds, obstacles, is_3d)\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest = self._nearest(tree_a, rand)\n                new_pos = self._steer(nearest.position, rand, self.step_size)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                    continue\n                new_node = Node(new_pos, parent=nearest, cost=nearest.cost + self._distance(nearest.position, new_pos))\n                nearest.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((nearest, new_node))\n\n                connect_node = self._nearest(tree_b, new_pos)\n                if self._connect_trees(new_node, connect_node, obstacles, is_3d, tree_b, nodes, edges):\n                    success_state = True\n                    extracted_path = self._extract_path(new_node, connect_node)\n                    return PlannerResult(True, extracted_path, start_tree + goal_tree, edges)\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        while True:\n            if is_3d:\n                point = tuple(random.uniform(0, bounds[i]) for i in range(3))\n            else:\n                point = tuple(random.uniform(0, bounds[i]) for i in range(2))\n            if not self._is_in_obstacle(point, obstacles, is_3d):\n                return point\n\n    def _nearest(self, tree, point):\n        return min(tree, key=lambda node: self._distance(node.position, point))\n\n    def _steer(self, from_pos, to_pos, step_size):\n        dist = self._distance(from_pos, to_pos)\n        if dist <= step_size:\n            return to_pos\n        ratio = step_size / dist\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n    def _connect_trees(self, node_a, node_b, obstacles, is_3d, tree, nodes, edges):\n        from_pos = node_a.position\n        to_pos = node_b.position\n        if self._is_edge_in_obstacle(from_pos, to_pos, obstacles, is_3d):\n            return False\n        curr = node_b\n        path = []\n        while True:\n            new_pos = self._steer(curr.position, from_pos, self.step_size)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return False\n            if self._is_edge_in_obstacle(curr.position, new_pos, obstacles, is_3d):\n                return False\n            new_node = Node(new_pos, parent=curr, cost=curr.cost + self._distance(curr.position, new_pos))\n            curr.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((curr, new_node))\n            if self._distance(new_pos, from_pos) < self.step_size:\n                new_node_final = Node(from_pos, parent=new_node, cost=new_node.cost + self._distance(new_pos, from_pos))\n                new_node.add_child(new_node_final)\n                tree.append(new_node_final)\n                nodes.append(new_node_final)\n                edges.append((new_node, new_node_final))\n                return True\n            curr = new_node\n\n    def _extract_path(self, node_a, node_b):\n        path_a = []\n        while node_a:\n            path_a.append(node_a.position)\n            node_a = node_a.parent\n        path_b = []\n        while node_b:\n            path_b.append(node_b.position)\n            node_b = node_b.parent\n        return list(reversed(path_a)) + path_b\n\n    def _distance(self, a, b):\n        return math.dist(a, b)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = self._distance(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n    ",
                "objective": -22.450973911227255,
                "time_improvement": 82.0,
                "length_improvement": -4.0,
                "smoothness_improvement": 82.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.008191466331481934,
                        "num_nodes_avg": 101.7,
                        "path_length_avg": 199.02574462734881,
                        "smoothness_avg": 0.010842564826318065,
                        "success_improvement": 0.0,
                        "time_improvement": 67.65634531528886,
                        "node_improvement": 74.38932258876858,
                        "length_improvement": -9.089164394992178,
                        "smoothness_improvement": 69.70968453824895,
                        "objective_score": 15.191953380282595
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.01688723564147949,
                        "num_nodes_avg": 251.2,
                        "path_length_avg": 297.0173008036888,
                        "smoothness_avg": 0.007253491237686249,
                        "success_improvement": 0.0,
                        "time_improvement": 89.8010600359201,
                        "node_improvement": 83.12168245649399,
                        "length_improvement": 0.8470758227465935,
                        "smoothness_improvement": 86.6375540242307,
                        "objective_score": 27.881751274545138
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.006025266647338867,
                        "num_nodes_avg": 132.4,
                        "path_length_avg": 156.99251189437436,
                        "smoothness_avg": 0.015002819200954195,
                        "success_improvement": 0.0,
                        "time_improvement": 87.95071348913807,
                        "node_improvement": 83.16592498410681,
                        "length_improvement": -4.266951220172442,
                        "smoothness_improvement": 90.83475284321622,
                        "objective_score": 24.279217078854035
                    }
                ],
                "success_rate": 1.0
            }
        ],
        "offspring": {
            "operator": "e2",
            "algorithm_description": "A bidirectional RRT* inspired planner with rewiring and path smoothing that grows two trees from start and goal. It efficiently samples collision-free nodes, extends trees with batch rewiring for shorter and smoother paths, and attempts early connections. Final path is further smoothed using shortcutting to improve length and smoothness while reducing planning time.",
            "planning_mechanism": "The planner alternates growing two trees toward sampled points with a fixed step size, uses nearest rewiring within radius to optimize path cost, checks collisions thoroughly, tries quick connection after each extension, and applies a post-processing path shortcutting for smoothness and length improvements.",
            "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=4000, step_size=6.0, rewire_radius=12.0, shortcut_trials=150):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.rewire_radius = rewire_radius\n        self.shortcut_trials = shortcut_trials\n\n    def plan(self, map) -> 'PlannerResult':\n        import math, random\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        # Initialize start and goal trees\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n\n        nodes = [start_root, goal_root]\n        edges = []\n        connected_node_start = None\n        connected_node_goal = None\n        success = False\n\n        # Precompute squared radius for efficiency\n        radius_sq = self.rewire_radius * self.rewire_radius\n\n        def dist_sq(a, b):\n            return sum((a[d]-b[d])**2 for d in range(len(a)))\n\n        def dist(a,b):\n            return math.sqrt(dist_sq(a,b))\n\n        def in_radius(tree, point, radius):\n            r_sq = radius * radius\n            return [node for node in tree if dist_sq(node.position, point) <= r_sq]\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            ratio = self.step_size / d\n            return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n        def collision_free_edge(p1, p2):\n            if self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution=1.0):\n                return False\n            return True\n\n        def no_collision_node(p):\n            return not self._is_in_obstacle(p, obstacles, is_3d)\n\n        def rewire(new_node, near_nodes, tree, nodes, edges):\n            for near_node in near_nodes:\n                if near_node == new_node.parent:\n                    continue\n                potential_cost = new_node.cost + dist(new_node.position, near_node.position)\n                if potential_cost < near_node.cost:\n                    if collision_free_edge(new_node.position, near_node.position):\n                        old_parent = near_node.parent\n                        if old_parent:\n                            if near_node in old_parent.children:\n                                old_parent.children.remove(near_node)\n                            try:\n                                edges.remove((old_parent, near_node))\n                            except ValueError:\n                                pass\n                        near_node.parent = new_node\n                        near_node.cost = potential_cost\n                        new_node.children.append(near_node)\n                        edges.append((new_node, near_node))\n                        # Update costs recursively for descendants\n                        self._update_costs(near_node, edges)\n\n        def extend(tree, point):\n            nearest = min(tree, key=lambda n: dist(n.position, point))\n            new_pos = steer(nearest.position, point)\n            if not no_collision_node(new_pos):\n                return None\n            if not collision_free_edge(nearest.position, new_pos):\n                return None\n            new_cost = nearest.cost + dist(nearest.position, new_pos)\n            new_node = Node(new_pos, parent=nearest, cost=new_cost)\n            nearest.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest, new_node))\n            # Rewire nearby nodes for optimization\n            near_nodes = in_radius(tree, new_pos, self.rewire_radius)\n            rewire(new_node, near_nodes, tree, nodes, edges)\n            return new_node\n\n        def try_connect(node_start, node_goal):\n            # Try connect by direct edge if collision free\n            if collision_free_edge(node_start.position, node_goal.position):\n                # Create connecting nodes on goal tree side for consistency\n                connecting_node = Node(node_start.position, parent=node_goal,\n                                      cost=node_goal.cost + dist(node_goal.position, node_start.position))\n                node_goal.children.append(connecting_node)\n                nodes.append(connecting_node)\n                edges.append((node_goal, connecting_node))\n                return connecting_node\n            return None\n\n        def extract_path(n_start, n_goal):\n            path_start = n_start.path_from_root()\n            path_goal = n_goal.path_from_root()\n            return path_start + path_goal[::-1]\n\n        def path_shortcut(path):\n            # Attempt shortcutting random pairs to smooth path\n            import random\n            if len(path) < 3:\n                return path\n            for _ in range(self.shortcut_trials):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) -1)\n                if self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d, resolution=1.0):\n                    continue\n                path = path[:i+1] + path[j:]\n            return path\n\n        # Main loop alternating tree expansion\n        for iter in range(self.max_iter):\n            rand_pt = self._sample_free(bounds, obstacles, is_3d)\n\n            new_node_start = extend(tree_start, rand_pt)\n            if new_node_start:\n                nearest_goal = min(tree_goal, key=lambda n: dist(n.position, new_node_start.position))\n                connecting_node = try_connect(new_node_start, nearest_goal)\n                if connecting_node:\n                    connected_node_start = new_node_start\n                    connected_node_goal = connecting_node\n                    success = True\n                    break\n\n            new_node_goal = extend(tree_goal, rand_pt)\n            if new_node_goal:\n                nearest_start = min(tree_start, key=lambda n: dist(n.position, new_node_goal.position))\n                connecting_node = try_connect(new_node_goal, nearest_start)\n                if connecting_node:\n                    connected_node_goal = new_node_goal\n                    connected_node_start = connecting_node\n                    success = True\n                    break\n\n        if success:\n            raw_path = extract_path(connected_node_start, connected_node_goal)\n            smoothed_path = path_shortcut(raw_path)\n            return PlannerResult(True, smoothed_path, nodes, edges)\n\n        # If fail, empty path\n        return PlannerResult(False, [], nodes, edges)\n\n    def _update_costs(self, node, edges):\n        import math\n        for child in node.children:\n            child.cost = node.cost + math.dist(node.position, child.position)\n            self._update_costs(child, edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        import random\n        while True:\n            if is_3d:\n                p = (random.uniform(0, bounds[0]),\n                     random.uniform(0, bounds[1]),\n                     random.uniform(0, bounds[2]))\n            else:\n                p = (random.uniform(0, bounds[0]),\n                     random.uniform(0, bounds[1]))\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
            "objective": -22.16212,
            "time_improvement": 20.0,
            "length_improvement": 13.0,
            "smoothness_improvement": 1613.0,
            "other_inf": [
                {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.018953418731689452,
                    "num_nodes_avg": 81.0,
                    "path_length_avg": 171.68715107805457,
                    "smoothness_avg": 0.052197424039673826,
                    "success_improvement": 0.0,
                    "time_improvement": 25.163236257653466,
                    "node_improvement": 79.60211533618737,
                    "length_improvement": 5.895551937113022,
                    "smoothness_improvement": 717.0030347414034,
                    "objective_score": 14.67131721327087
                },
                {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.05427415370941162,
                    "num_nodes_avg": 223.1,
                    "path_length_avg": 248.40557495835523,
                    "smoothness_avg": 0.10736639107141233,
                    "success_improvement": 0.0,
                    "time_improvement": 67.22146554739268,
                    "node_improvement": 85.00974265941007,
                    "length_improvement": 17.075069120866036,
                    "smoothness_improvement": 2662.614575153109,
                    "objective_score": 43.72455401250298
                },
                {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.06621241569519043,
                    "num_nodes_avg": 221.6,
                    "path_length_avg": 124.19023230834314,
                    "smoothness_avg": 0.12268260456847457,
                    "success_improvement": 0.0,
                    "time_improvement": -32.411130325660395,
                    "node_improvement": 71.82453909726637,
                    "length_improvement": 17.518761004167946,
                    "smoothness_improvement": 1460.5136746230896,
                    "objective_score": 8.090485877918098
                }
            ],
            "success_rate": 1.0
        },
        "objective": 355.4,
        "analysis": {
            "problem": [
                "Problem of the parents algorithm:\n   - Absence of path rewiring or optimization, leading to longer and less efficient routes.\n   - Naive tree connection methods without smooth merging, resulting in jagged and abrupt turns.\n   - Repeated expensive collision checking with fixed resolution along edges, increasing planning time.\n   - Lack of effective post-processing for path smoothing, causing low smoothness in final solutions.\n   - Alternating tree growth without spatial acceleration, leading to inefficient nearest neighbor queries and extended planning durations."
            ],
            "solution": "1. Primary contributors to the performance improvement:\n   - Incorporation of rewiring steps to locally optimize path costs and connections during tree expansion.\n   - Implementation of a path shortcutting post-processing procedure that removes unnecessary waypoints and smooths abrupt turns.\n   - Use of an increased step size and rewiring radius to explore and connect the space more efficiently.\n2. Expected mechanism of impact:\n   - Rewiring reduces overall path length and improves path consistency by continuously optimizing neighbor connections.\n   - Shortcutting greatly enhances smoothness by removing intermediate points causing sharp angles, resulting in more natural trajectories.\n   - Efficient collision checking combined with smoother tree growth reduces redundant computations, improving planning time.\n   - Balanced bidirectional tree expansion and cost updates enable earlier successful connections with higher-quality paths."
        }
    },
    {
        "parents": [
            {
                "operator": "initial",
                "algorithm_description": "This algorithm is a dual-tree variant of Rapidly-exploring Random Tree (RRT) that grows two trees from the start and goal positions, attempting to connect them as they expand. It is efficient for single-query problems due to its bidirectional search and reduced redundant exploration.",
                "planning_mechanism": "The planner alternates between growing the start and goal trees by extending towards randomly sampled points. Each extension step involves checking for collision-free motion and attempting to connect the two trees. The algorithm terminates when a valid path is formed connecting the trees.",
                "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n        nodes = []\n        edges = []\n        success_state = False\n        extracted_path = []\n\n        for iter in range(self.max_iter):\n            rand = self._sample_free(bounds, obstacles, is_3d)\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest = self._nearest(tree_a, rand)\n                new_pos = self._steer(nearest.position, rand, self.step_size)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                    continue\n                new_node = Node(new_pos, parent=nearest, cost=nearest.cost + self._distance(nearest.position, new_pos))\n                nearest.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((nearest, new_node))\n\n                connect_node = self._nearest(tree_b, new_pos)\n                if self._connect_trees(new_node, connect_node, obstacles, is_3d, tree_b, nodes, edges):\n                    success_state = True\n                    extracted_path = self._extract_path(new_node, connect_node)\n                    return PlannerResult(True, extracted_path, start_tree + goal_tree, edges)\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        while True:\n            if is_3d:\n                point = tuple(random.uniform(0, bounds[i]) for i in range(3))\n            else:\n                point = tuple(random.uniform(0, bounds[i]) for i in range(2))\n            if not self._is_in_obstacle(point, obstacles, is_3d):\n                return point\n\n    def _nearest(self, tree, point):\n        return min(tree, key=lambda node: self._distance(node.position, point))\n\n    def _steer(self, from_pos, to_pos, step_size):\n        dist = self._distance(from_pos, to_pos)\n        if dist <= step_size:\n            return to_pos\n        ratio = step_size / dist\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n    def _connect_trees(self, node_a, node_b, obstacles, is_3d, tree, nodes, edges):\n        from_pos = node_a.position\n        to_pos = node_b.position\n        if self._is_edge_in_obstacle(from_pos, to_pos, obstacles, is_3d):\n            return False\n        curr = node_b\n        path = []\n        while True:\n            new_pos = self._steer(curr.position, from_pos, self.step_size)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return False\n            if self._is_edge_in_obstacle(curr.position, new_pos, obstacles, is_3d):\n                return False\n            new_node = Node(new_pos, parent=curr, cost=curr.cost + self._distance(curr.position, new_pos))\n            curr.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((curr, new_node))\n            if self._distance(new_pos, from_pos) < self.step_size:\n                new_node_final = Node(from_pos, parent=new_node, cost=new_node.cost + self._distance(new_pos, from_pos))\n                new_node.add_child(new_node_final)\n                tree.append(new_node_final)\n                nodes.append(new_node_final)\n                edges.append((new_node, new_node_final))\n                return True\n            curr = new_node\n\n    def _extract_path(self, node_a, node_b):\n        path_a = []\n        while node_a:\n            path_a.append(node_a.position)\n            node_a = node_a.parent\n        path_b = []\n        while node_b:\n            path_b.append(node_b.position)\n            node_b = node_b.parent\n        return list(reversed(path_a)) + path_b\n\n    def _distance(self, a, b):\n        return math.dist(a, b)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = self._distance(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n    ",
                "objective": -17.795854854811235,
                "time_improvement": 71.0,
                "length_improvement": -6.0,
                "smoothness_improvement": 75.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.015041923522949219,
                        "num_nodes_avg": 140.4,
                        "path_length_avg": 205.55369204774252,
                        "smoothness_avg": 0.01041684624247792,
                        "success_improvement": 0.0,
                        "time_improvement": 41.67719749109079,
                        "node_improvement": 64.64366658272476,
                        "length_improvement": -12.667235818056396,
                        "smoothness_improvement": 63.046264238449346,
                        "objective_score": 5.218049077685646
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.016628527641296388,
                        "num_nodes_avg": 235.2,
                        "path_length_avg": 305.1784824883373,
                        "smoothness_avg": 0.00711472502770238,
                        "success_improvement": 0.0,
                        "time_improvement": 89.95714459329555,
                        "node_improvement": 84.19673452932877,
                        "length_improvement": -1.8773615301791229,
                        "smoothness_improvement": 83.06699949208468,
                        "objective_score": 26.276061457341616
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.010075998306274415,
                        "num_nodes_avg": 181.0,
                        "path_length_avg": 156.9681958591822,
                        "smoothness_avg": 0.014159220130581652,
                        "success_improvement": 0.0,
                        "time_improvement": 80.14471285055937,
                        "node_improvement": 76.98664971392245,
                        "length_improvement": -4.250801667402978,
                        "smoothness_improvement": 80.10423493608366,
                        "objective_score": 21.89345402940644
                    }
                ],
                "success_rate": 1.0
            },
            {
                "operator": "initial",
                "algorithm_description": "This algorithm is a bidirectional extension of RRT* that grows two trees from start and goal while optimizing paths via rewiring. It combines RRT*\u2018s asymptotic optimality with RRT-Connect\u2019s fast convergence through connection attempts between the trees.",
                "planning_mechanism": "The planner alternates growing two trees with sampling, extension, and rewiring. After each extension, it attempts to connect both trees. When connection is successful, a rewired optimal path is extracted across both trees.",
                "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, radius: float = 10.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.radius = radius\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n        nodes = []\n        edges = []\n        success_state = False\n        extracted_path = []\n\n        for iter in range(self.max_iter):\n            rand = self._sample_free(bounds, obstacles, is_3d)\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest = self._nearest(tree_a, rand)\n                new_pos = self._steer(nearest.position, rand, self.step_size)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                    continue\n\n                new_node = Node(new_pos)\n                near_nodes = self._near(tree_a, new_pos, self.radius)\n                min_cost = nearest.cost + self._distance(nearest.position, new_pos)\n                min_parent = nearest\n\n                for near in near_nodes:\n                    cost = near.cost + self._distance(near.position, new_pos)\n                    if cost < min_cost and not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d):\n                        min_cost = cost\n                        min_parent = near\n\n                new_node.parent = min_parent\n                new_node.cost = min_cost\n                min_parent.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((min_parent, new_node))\n\n                for near in near_nodes:\n                    if near == min_parent:\n                        continue\n                    new_cost = new_node.cost + self._distance(new_node.position, near.position)\n                    if new_cost < near.cost and not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                        if near.parent:\n                            edges.remove((near.parent, near))\n                        near.parent = new_node\n                        near.cost = new_cost\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n\n                connect_node = self._nearest(tree_b, new_node.position)\n                if self._distance(new_node.position, connect_node.position) < self.step_size and not self._is_edge_in_obstacle(new_node.position, connect_node.position, obstacles, is_3d):\n                    success_state = True\n                    extracted_path = self._extract_path(new_node, connect_node)\n                    return PlannerResult(True, extracted_path, start_tree + goal_tree, edges)\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        while True:\n            point = tuple(random.uniform(0, bounds[i]) for i in range(3 if is_3d else 2))\n            if not self._is_in_obstacle(point, obstacles, is_3d):\n                return point\n\n    def _nearest(self, tree, point):\n        return min(tree, key=lambda node: self._distance(node.position, point))\n\n    def _near(self, tree, point, radius):\n        return [node for node in tree if self._distance(node.position, point) <= radius]\n\n    def _steer(self, from_pos, to_pos, step_size):\n        dist = self._distance(from_pos, to_pos)\n        if dist <= step_size:\n            return to_pos\n        ratio = step_size / dist\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n    def _extract_path(self, node_a, node_b):\n        path_a = []\n        while node_a:\n            path_a.append(node_a.position)\n            node_a = node_a.parent\n        path_b = []\n        while node_b:\n            path_b.append(node_b.position)\n            node_b = node_b.parent\n        return list(reversed(path_a)) + path_b\n\n    def _distance(self, a, b):\n        return math.dist(a, b)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = self._distance(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n    ",
                "objective": -26.062040773062417,
                "time_improvement": 66.0,
                "length_improvement": 9.0,
                "smoothness_improvement": 167.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.012016057968139648,
                        "num_nodes_avg": 134.5,
                        "path_length_avg": 175.84673815929608,
                        "smoothness_avg": 0.016310939143948412,
                        "success_improvement": 0.0,
                        "time_improvement": 53.409537367863955,
                        "node_improvement": 66.1294384286074,
                        "length_improvement": 3.6156163450092893,
                        "smoothness_improvement": 155.30161737405683,
                        "objective_score": 18.96873910423504
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.018314409255981445,
                        "num_nodes_avg": 253.0,
                        "path_length_avg": 257.3377355314211,
                        "smoothness_avg": 0.010767991223558952,
                        "success_improvement": 0.0,
                        "time_improvement": 88.93895070058699,
                        "node_improvement": 83.00073909830007,
                        "length_improvement": 14.093256823589732,
                        "smoothness_improvement": 177.06817005275553,
                        "objective_score": 36.02298015459372
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.022396659851074217,
                        "num_nodes_avg": 265.9,
                        "path_length_avg": 136.5245362961063,
                        "smoothness_avg": 0.0210441701583257,
                        "success_improvement": 0.0,
                        "time_improvement": 55.86619816574277,
                        "node_improvement": 66.19198982835347,
                        "length_improvement": 9.326903591935762,
                        "smoothness_improvement": 167.68029109483984,
                        "objective_score": 23.19440306035849
                    }
                ],
                "success_rate": 1.0
            }
        ],
        "offspring": {
            "operator": "e1",
            "algorithm_description": "A bidirectional informed RRT* with adaptive sampling and post-processing path shortcutting. The algorithm grows two trees from start and goal, but restricts sampling within an ellipsoidal region (informed sampling) to focus search around the best solution path. It performs rewiring to optimize local connections and applies an efficient post-processing shortcutting procedure to smooth the final path, which improves path quality and smoothness while reducing planning time.",
            "planning_mechanism": "The planner alternates expanding two trees by sampling random points within an informed ellipsoidal subset after an initial solution is found. It performs steer, collision checks, rewiring, and attempts to connect the trees continuously. Upon success, it extracts the path and applies post-processing shortcutting to remove unnecessary waypoints and smooth sharp turns, leading to a shorter, smoother trajectory with improved efficiency.",
            "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n    def add_child(self, child):\n        self.children.append(child)\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=7.0, radius=15.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.radius = radius\n\n    def plan(self, map):\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = (len(bounds) == 3)\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = []\n        edges = []\n\n        best_path_cost = float('inf')\n        solution_node_start = None\n        solution_node_goal = None\n\n        # Basic heuristic distance for informed sampling\n        c_min = self._distance(start_pos, goal_pos)\n\n        for i in range(self.max_iter):\n            if solution_node_start and solution_node_goal:\n                # Informed sampling inside ellipsoid bounding current best path cost\n                sample = self._informed_sample(bounds, obstacles, is_3d, start_pos, goal_pos, best_path_cost, c_min)\n            else:\n                # Uniform random sampling within bounds free space\n                sample = self._sample_free(bounds, obstacles, is_3d)\n\n            for tree_a, tree_b in [(start_tree,goal_tree),(goal_tree,start_tree)]:\n                nearest = self._nearest(tree_a, sample)\n                new_pos = self._steer(nearest.position, sample, self.step_size)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d): continue\n                if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d): continue\n\n                new_node = Node(new_pos)\n                near_nodes = self._near(tree_a, new_pos, self.radius)\n\n                # Choose best parent among near nodes considering path cost and collision\n                min_cost = nearest.cost + self._distance(nearest.position, new_pos)\n                min_parent = nearest\n                for near in near_nodes:\n                    tent_cost = near.cost + self._distance(near.position, new_pos)\n                    if tent_cost < min_cost and not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d):\n                        min_cost = tent_cost\n                        min_parent = near\n\n                new_node.parent = min_parent\n                new_node.cost = min_cost\n                min_parent.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((min_parent, new_node))\n\n                # Rewire neighbors if new node offers a better path\n                for near in near_nodes:\n                    if near == min_parent: continue\n                    new_cost = new_node.cost + self._distance(new_node.position, near.position)\n                    if new_cost < near.cost and not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                        if near.parent:\n                            try: edges.remove((near.parent, near))\n                            except ValueError: pass\n                        near.parent = new_node\n                        near.cost = new_cost\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n\n                # Try to connect to tree_b within step size and collision free\n                connect_node = self._nearest(tree_b, new_node.position)\n                if self._distance(new_node.position, connect_node.position) <= self.step_size:\n                    if not self._is_edge_in_obstacle(new_node.position, connect_node.position, obstacles, is_3d):\n                        # Construct candidate path cost\n                        path_cost = new_node.cost + self._distance(new_node.position, connect_node.position) + connect_node.cost\n                        if path_cost < best_path_cost:\n                            best_path_cost = path_cost\n                            solution_node_start, solution_node_goal = (new_node, connect_node) if tree_a is start_tree else (connect_node, new_node)\n                        # We can continue to iterate to improve path\n\n            if best_path_cost < float('inf') and (i % 100 == 0 or i == self.max_iter -1):\n                # Extract and shortcut path every 100 iterations or at end for smoother solution\n                raw_path = self._extract_path(solution_node_start, solution_node_goal)\n                shortcut_path = self._shortcut_path(raw_path, obstacles, is_3d)\n                if shortcut_path:\n                    return PlannerResult(True, shortcut_path, start_tree + goal_tree, edges)\n\n        # No solution found; return empty path\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        while True:\n            pt = tuple(random.uniform(0, bounds[i]) for i in range(3 if is_3d else 2))\n            if not self._is_in_obstacle(pt, obstacles, is_3d): return pt\n\n    def _informed_sample(self, bounds, obstacles, is_3d, start, goal, c_max, c_min):\n        # Sample inside prolate hyperspheroid (ellipsoid) defined by start, goal, and current best cost c_max\n        # Reduces sampling space to focus search near optimal path\n        dim = 3 if is_3d else 2\n        while True:\n            # Sample unit ball point\n            if dim == 2:\n                r = random.uniform(0,1) ** 0.5\n                theta = random.uniform(0, 2*math.pi)\n                x_ball = [r * math.cos(theta), r * math.sin(theta)]\n            else:\n                # Sample from 3D ball\n                while True:\n                    x_ball = [random.uniform(-1,1), random.uniform(-1,1), random.uniform(-1,1)]\n                    if sum([xi*xi for xi in x_ball]) <= 1: break\n            # Calculate transformation parameters\n            c = c_max\n            if c == float('inf') or c <= c_min:\n                # No current solution, uniform sample\n                pt = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not self._is_in_obstacle(pt, obstacles, is_3d): return pt\n\n            center = tuple((start[i] + goal[i]) / 2 for i in range(dim))\n            dir_vec = [goal[i] - start[i] for i in range(dim)]\n            length = math.dist(start, goal)\n            # Compute rotation matrix from canonical axis to direction vector\n            if dim == 2:\n                if length == 0:\n                    R = [[1,0],[0,1]]\n                else:\n                    a1 = [1,0]\n                    a2 = [dir_vec[0]/length, dir_vec[1]/length]\n                    cos_theta = a1[0]*a2[0] + a1[1]*a2[1]\n                    sin_theta = a1[0]*a2[1] - a1[1]*a2[0]\n                    R = [[cos_theta, -sin_theta],[sin_theta, cos_theta]]\n            else:\n                # 3D rotation using axis-angle (rotation matrix)\n                from math import acos, sqrt\n                if length == 0:\n                    R = [[1,0,0],[0,1,0],[0,0,1]]\n                else:\n                    a1 = [1,0,0]\n                    a2 = [dir_vec[i]/length for i in range(3)]\n                    v = [a1[1]*a2[2]-a1[2]*a2[1], a1[2]*a2[0]-a1[0]*a2[2], a1[0]*a2[1]-a1[1]*a2[0]]\n                    s = sqrt(sum([vi*vi for vi in v]))\n                    c = sum([a1[i]*a2[i] for i in range(3)])\n                    if s == 0:\n                        R = [[1,0,0],[0,1,0],[0,0,1]]\n                    else:\n                        vx = [[0,-v[2],v[1]],[v[2],0,-v[0]],[-v[1],v[0],0]]\n                        I = [[1 if i==j else 0 for j in range(3)] for i in range(3)]\n                        vx2 = [[vx[0][0]*vx[0][0]+vx[0][1]*vx[1][0]+vx[0][2]*vx[2][0],\n                                vx[0][0]*vx[0][1]+vx[0][1]*vx[1][1]+vx[0][2]*vx[2][1],\n                                vx[0][0]*vx[0][2]+vx[0][1]*vx[1][2]+vx[0][2]*vx[2][2]],\n                               [vx[1][0]*vx[0][0]+vx[1][1]*vx[1][0]+vx[1][2]*vx[2][0],\n                                vx[1][0]*vx[0][1]+vx[1][1]*vx[1][1]+vx[1][2]*vx[2][1],\n                                vx[1][0]*vx[0][2]+vx[1][1]*vx[1][2]+vx[1][2]*vx[2][2]],\n                               [vx[2][0]*vx[0][0]+vx[2][1]*vx[1][0]+vx[2][2]*vx[2][0],\n                                vx[2][0]*vx[0][1]+vx[2][1]*vx[1][1]+vx[2][2]*vx[2][1],\n                                vx[2][0]*vx[0][2]+vx[2][1]*vx[1][2]+vx[2][2]*vx[2][2]]]\n                        R = [[I[i][j] + vx[i][j] + ((vx2[i][j]) * ((1 - c)/(s**2))) for j in range(3)] for i in range(3)]\n            # Compose scaling matrix\n            a1_val = c_max / 2.0\n            a_others = math.sqrt(c_max**2 - c_min**2) / 2.0\n            if dim == 2:\n                L = [[a1_val,0],[0,a_others]]\n                # Transform sample from unit ball: pos = R * L * x_ball + center\n                x_scaled = [L[0][0]*x_ball[0] + L[0][1]*x_ball[1], L[1][0]*x_ball[0] + L[1][1]*x_ball[1]]\n                pt = (center[0] + R[0][0]*x_scaled[0] + R[0][1]*x_scaled[1],\n                      center[1] + R[1][0]*x_scaled[0] + R[1][1]*x_scaled[1])\n            else:\n                L = [[a1_val,0,0],[0,a_others,0],[0,0,a_others]]\n                x_scaled = [L[0][0]*x_ball[0], L[1][1]*x_ball[1], L[2][2]*x_ball[2]]\n                pt = tuple(center[i] + sum(R[i][j]*x_scaled[j] for j in range(3)) for i in range(3))\n\n            # Reject points outside bounds or in obstacle\n            if any(pt[d] < 0 or pt[d] > bounds[d] for d in range(dim)):\n                continue\n            if self._is_in_obstacle(pt, obstacles, is_3d):\n                continue\n            return pt\n\n    def _nearest(self, tree, point):\n        return min(tree, key=lambda n: self._distance(n.position, point))\n\n    def _near(self, tree, point, radius):\n        radius_sq = radius * radius\n        return [node for node in tree if self._squared_distance(node.position, point) <= radius_sq]\n\n    def _steer(self, from_pos, to_pos, step_size):\n        dist = self._distance(from_pos, to_pos)\n        if dist <= step_size:\n            return to_pos\n        ratio = step_size / dist\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n    def _extract_path(self, node_start, node_goal):\n        path_start, path_goal = [], []\n        n = node_start\n        while n:\n            path_start.append(n.position)\n            n = n.parent\n        n = node_goal\n        while n:\n            path_goal.append(n.position)\n            n = n.parent\n        return list(reversed(path_start)) + path_goal\n\n    def _shortcut_path(self, path, obstacles, is_3d):\n        # Attempt to shortcut path by skipping intermediate nodes where direct edge collision free\n        if len(path) < 3:\n            return path[:]\n        shortcut_path = [path[0]]\n        i = 0\n        while i < len(path)-1:\n            j = len(path)-1\n            while j > i+1:\n                if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                    break\n                j -= 1\n            shortcut_path.append(path[j])\n            i = j\n        return shortcut_path\n\n    def _distance(self, a, b):\n        return math.dist(a, b)\n\n    def _squared_distance(self, a, b):\n        return sum((a[i] - b[i])**2 for i in range(len(a)))\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x,y,z,w,h,d = obs\n                px,py,pz = pos\n                if x<=px<=x+w and y<=py<=y+h and z<=pz<=z+d:\n                    return True\n            else:\n                x,y,w,h = obs\n                px,py = pos\n                if x<=px<=x+w and y<=py<=y+h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        dist = self._distance(from_pos, to_pos)\n        steps = max(1, int(dist/resolution))\n        for i in range(steps+1):\n            interp = tuple(from_pos[d] + (to_pos[d]-from_pos[d])*(i/steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
            "objective": -23.21547,
            "time_improvement": 21.0,
            "length_improvement": 16.0,
            "smoothness_improvement": 1469.0,
            "node_improvement": 68.0,
            "other_inf": [
                {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.025556087493896484,
                    "num_nodes_avg": 151.3,
                    "path_length_avg": 173.88763401105183,
                    "smoothness_avg": 0.047474639256938476,
                    "success_improvement": 0.0,
                    "time_improvement": 0.9101035826373128,
                    "node_improvement": 61.89876605389071,
                    "length_improvement": 4.689432372653788,
                    "smoothness_improvement": 643.0811972002915,
                    "objective_score": 6.302096484384924
                },
                {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.031405282020568845,
                    "num_nodes_avg": 252.2,
                    "path_length_avg": 230.86304004149935,
                    "smoothness_avg": 0.09581397875517297,
                    "success_improvement": 0.0,
                    "time_improvement": 81.03267389975849,
                    "node_improvement": 83.05449170194181,
                    "length_improvement": 22.93127220998329,
                    "smoothness_improvement": 2365.362685390011,
                    "objective_score": 49.89537892286758
                },
                {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.06047847270965576,
                    "num_nodes_avg": 317.2,
                    "path_length_avg": 119.93973012619429,
                    "smoothness_avg": 0.11787316210161418,
                    "success_improvement": 0.0,
                    "time_improvement": -19.176026584091733,
                    "node_improvement": 59.6694214876033,
                    "length_improvement": 20.341742166387515,
                    "smoothness_improvement": 1399.337921440741,
                    "objective_score": 13.448926931808694
                }
            ],
            "success_rate": 1.0
        },
        "objective": 360.5999999999999,
        "analysis": {
            "problem": [
                "Problem of the parents algorithm:\n   - Inefficient exploration due to uniform random sampling without focus on promising regions, leading to longer planning times.\n   - Lack of effective path shortcutting or smoothing post-processing, resulting in longer and less smooth paths.\n   - Limited or no effective rewiring mechanisms causing suboptimal path length and degraded smoothness.\n   - Incremental tree connection procedures adding excessive intermediate nodes and zigzag patterns, negatively impacting smoothness and path length."
            ],
            "solution": "1. Primary contributors to the performance improvement:\n   - Incorporation of informed sampling restricting samples to an ellipsoidal region around the current best path, focusing exploration.\n   - Implementation of path shortcutting that removes unnecessary intermediate nodes and smooths the final trajectory.\n   - Enhanced rewiring procedures ensuring locally optimal parent selection and improved connectivity.\n   - Increased step size and connection radius facilitating faster convergence and convergence towards a smoother path.\n2. Expected mechanism of impact:\n   - Focused sampling reduces wasted exploration in irrelevant areas, lowering overall planning time.\n   - Shortcutting reduces path length and smooths sharp turns, greatly improving path smoothness.\n   - Improved rewiring decreases total path cost by favoring lower-cost connections, enhancing length and smoothness.\n   - Larger step and rewiring radius reduce excessive branching and zigzagging, contributing to smoother, more efficient paths."
        }
    },
    {
        "parents": [
            {
                "operator": "initial",
                "algorithm_description": "This algorithm grows two trees simultaneously, one from the start position and one from the goal position, and attempts to connect them to find a feasible path. This bidirectional approach accelerates convergence and increases the success rate compared to a single tree RRT.",
                "planning_mechanism": "The planning mechanism involves randomly sampling points within the map bounds, extending each tree towards the sampled points, and attempting to connect the two trees whenever new nodes are added. Collision checks are performed for nodes and edges to ensure safety, and once the two trees connect, the final path is reconstructed by backtracking through the parent nodes of each tree.",
                "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map) -> PlannerResult:\n        import math, random\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position)\n        goal_root = Node(goal_position)\n        nodes.extend([start_root, goal_root])\n        tree_a, tree_b = [start_root], [goal_root]\n\n        for _ in range(self.max_iter):\n            rand_point = self._sample_free(bounds, obstacles, is_3d)\n            new_a = self._extend_tree(tree_a, rand_point, obstacles, is_3d, nodes, edges)\n            if new_a is None:\n                continue\n\n            new_b = self._connect_trees(tree_b, new_a, obstacles, is_3d, nodes, edges)\n            if new_b:\n                success_state = True\n                path_a = new_a.path_from_root()\n                path_b = new_b.path_from_root()\n                extracted_path = path_a + path_b[::-1]\n                break\n\n            tree_a, tree_b = tree_b, tree_a  # Swap trees\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        import random\n        while True:\n            if is_3d:\n                p = (random.uniform(0, bounds[0]),\n                     random.uniform(0, bounds[1]),\n                     random.uniform(0, bounds[2]))\n            else:\n                p = (random.uniform(0, bounds[0]),\n                     random.uniform(0, bounds[1]))\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    def _nearest(self, tree, point):\n        import math\n        return min(tree, key=lambda node: math.dist(node.position, point))\n\n    def _steer(self, from_pos, to_pos):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _extend_tree(self, tree, point, obstacles, is_3d, nodes, edges):\n        nearest_node = self._nearest(tree, point)\n        new_pos = self._steer(nearest_node.position, point)\n        if not self._is_in_obstacle(new_pos, obstacles, is_3d) and not self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n            new_node = Node(new_pos, parent=nearest_node)\n            nearest_node.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n            return new_node\n        return None\n\n    def _connect_trees(self, tree, new_node, obstacles, is_3d, nodes, edges):\n        import math\n        nearest_node = self._nearest(tree, new_node.position)\n        while True:\n            new_pos = self._steer(nearest_node.position, new_node.position)\n            if (not self._is_in_obstacle(new_pos, obstacles, is_3d) and\n                not self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d)):\n                next_node = Node(new_pos, parent=nearest_node)\n                nearest_node.add_child(next_node)\n                tree.append(next_node)\n                nodes.append(next_node)\n                edges.append((nearest_node, next_node))\n\n                if math.dist(next_node.position, new_node.position) <= self.step_size:\n                    if not self._is_edge_in_obstacle(next_node.position, new_node.position, obstacles, is_3d):\n                        final_node = Node(new_node.position, parent=next_node)\n                        next_node.add_child(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((next_node, final_node))\n                        return final_node\n                    else:\n                        return None\n                nearest_node = next_node\n            else:\n                return None\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n",
                "objective": -26.16492572596105,
                "time_improvement": 92.0,
                "length_improvement": -3.0,
                "smoothness_improvement": 63.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.003008270263671875,
                        "num_nodes_avg": 68.1,
                        "path_length_avg": 184.17006126805845,
                        "smoothness_avg": 0.01054995558932253,
                        "success_improvement": 0.0,
                        "time_improvement": 88.33588322571401,
                        "node_improvement": 82.85066733820196,
                        "length_improvement": -0.9465289423981464,
                        "smoothness_improvement": 65.12971456814059,
                        "objective_score": 26.25849617511602
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.008660387992858887,
                        "num_nodes_avg": 222.5,
                        "path_length_avg": 300.8164456420612,
                        "smoothness_avg": 0.0064472474436514295,
                        "success_improvement": 0.0,
                        "time_improvement": 94.76952943432936,
                        "node_improvement": 85.05005711214136,
                        "length_improvement": -0.4211880766230819,
                        "smoothness_improvement": 65.89232048978258,
                        "objective_score": 28.50760758677387
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.0042524576187133786,
                        "num_nodes_avg": 126.3,
                        "path_length_avg": 160.72624335922288,
                        "smoothness_avg": 0.012431076585876402,
                        "success_improvement": 0.0,
                        "time_improvement": 91.62030753242554,
                        "node_improvement": 83.94151303242214,
                        "length_improvement": -6.746717877938324,
                        "smoothness_improvement": 58.122376605720596,
                        "objective_score": 23.72867341599327
                    }
                ],
                "success_rate": 1.0
            },
            {
                "operator": "initial",
                "algorithm_description": "This algorithm is a bidirectional extension of RRT* that grows two trees from start and goal while optimizing paths via rewiring. It combines RRT*\u2018s asymptotic optimality with RRT-Connect\u2019s fast convergence through connection attempts between the trees.",
                "planning_mechanism": "The planner alternates growing two trees with sampling, extension, and rewiring. After each extension, it attempts to connect both trees. When connection is successful, a rewired optimal path is extracted across both trees.",
                "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, radius: float = 10.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.radius = radius\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n        nodes = []\n        edges = []\n        success_state = False\n        extracted_path = []\n\n        for iter in range(self.max_iter):\n            rand = self._sample_free(bounds, obstacles, is_3d)\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest = self._nearest(tree_a, rand)\n                new_pos = self._steer(nearest.position, rand, self.step_size)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                    continue\n\n                new_node = Node(new_pos)\n                near_nodes = self._near(tree_a, new_pos, self.radius)\n                min_cost = nearest.cost + self._distance(nearest.position, new_pos)\n                min_parent = nearest\n\n                for near in near_nodes:\n                    cost = near.cost + self._distance(near.position, new_pos)\n                    if cost < min_cost and not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d):\n                        min_cost = cost\n                        min_parent = near\n\n                new_node.parent = min_parent\n                new_node.cost = min_cost\n                min_parent.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((min_parent, new_node))\n\n                for near in near_nodes:\n                    if near == min_parent:\n                        continue\n                    new_cost = new_node.cost + self._distance(new_node.position, near.position)\n                    if new_cost < near.cost and not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                        if near.parent:\n                            edges.remove((near.parent, near))\n                        near.parent = new_node\n                        near.cost = new_cost\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n\n                connect_node = self._nearest(tree_b, new_node.position)\n                if self._distance(new_node.position, connect_node.position) < self.step_size and not self._is_edge_in_obstacle(new_node.position, connect_node.position, obstacles, is_3d):\n                    success_state = True\n                    extracted_path = self._extract_path(new_node, connect_node)\n                    return PlannerResult(True, extracted_path, start_tree + goal_tree, edges)\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        while True:\n            point = tuple(random.uniform(0, bounds[i]) for i in range(3 if is_3d else 2))\n            if not self._is_in_obstacle(point, obstacles, is_3d):\n                return point\n\n    def _nearest(self, tree, point):\n        return min(tree, key=lambda node: self._distance(node.position, point))\n\n    def _near(self, tree, point, radius):\n        return [node for node in tree if self._distance(node.position, point) <= radius]\n\n    def _steer(self, from_pos, to_pos, step_size):\n        dist = self._distance(from_pos, to_pos)\n        if dist <= step_size:\n            return to_pos\n        ratio = step_size / dist\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n    def _extract_path(self, node_a, node_b):\n        path_a = []\n        while node_a:\n            path_a.append(node_a.position)\n            node_a = node_a.parent\n        path_b = []\n        while node_b:\n            path_b.append(node_b.position)\n            node_b = node_b.parent\n        return list(reversed(path_a)) + path_b\n\n    def _distance(self, a, b):\n        return math.dist(a, b)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = self._distance(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n    ",
                "objective": -26.062040773062417,
                "time_improvement": 66.0,
                "length_improvement": 9.0,
                "smoothness_improvement": 167.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.012016057968139648,
                        "num_nodes_avg": 134.5,
                        "path_length_avg": 175.84673815929608,
                        "smoothness_avg": 0.016310939143948412,
                        "success_improvement": 0.0,
                        "time_improvement": 53.409537367863955,
                        "node_improvement": 66.1294384286074,
                        "length_improvement": 3.6156163450092893,
                        "smoothness_improvement": 155.30161737405683,
                        "objective_score": 18.96873910423504
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.018314409255981445,
                        "num_nodes_avg": 253.0,
                        "path_length_avg": 257.3377355314211,
                        "smoothness_avg": 0.010767991223558952,
                        "success_improvement": 0.0,
                        "time_improvement": 88.93895070058699,
                        "node_improvement": 83.00073909830007,
                        "length_improvement": 14.093256823589732,
                        "smoothness_improvement": 177.06817005275553,
                        "objective_score": 36.02298015459372
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.022396659851074217,
                        "num_nodes_avg": 265.9,
                        "path_length_avg": 136.5245362961063,
                        "smoothness_avg": 0.0210441701583257,
                        "success_improvement": 0.0,
                        "time_improvement": 55.86619816574277,
                        "node_improvement": 66.19198982835347,
                        "length_improvement": 9.326903591935762,
                        "smoothness_improvement": 167.68029109483984,
                        "objective_score": 23.19440306035849
                    }
                ],
                "success_rate": 1.0
            }
        ],
        "offspring": {
            "operator": "m2",
            "algorithm_description": "This algorithm is an enhanced bidirectional RRT* planner that incorporates adaptive rewiring radius, smarter sampling strategies incorporating goal bias and informed sampling, and a post-processing path smoothing stage using shortcutting to greatly improve path smoothness, length, and planning efficiency. It grows two trees from start and goal, alternates expansion, rewires locally for optimality, attempts early connection, and finally smooths the extracted path for a low-cost, feasible, and smooth trajectory.",
            "planning_mechanism": "The planner uses bidirectional RRT* with adaptive rewiring radius based on the logarithm of tree size for asymptotic optimality and faster rewiring, samples with a goal bias probability to focus exploration, uses a connection radius scaled to domain size, and applies a shortcut smoothing post-processing on the constructed path. Trees are alternately expanded toward random samples or the opposing tree's nearest nodes to encourage faster convergence and connection. Collision checks are extensive but efficient with early rejections.",
            "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        node, path = self, []\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=5.0, base_radius=15.0, goal_sample_rate=0.1, shortcut_iterations=150):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.base_radius = base_radius\n        self.goal_sample_rate = goal_sample_rate\n        self.shortcut_iterations = shortcut_iterations\n\n    def plan(self, map) -> 'PlannerResult':\n        import random, math\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        def dist(a,b):\n            return math.dist(a,b)\n\n        def steer(fr, to):\n            d = dist(fr, to)\n            if d <= self.step_size:\n                return to\n            ratio = self.step_size / d\n            return tuple(fr[i] + (to[i] - fr[i]) * ratio for i in range(dim))\n\n        def is_in_obstacle(p):\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d_ = obs\n                    px,py,pz = p\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d_:\n                        return True\n                else:\n                    x,y,w,h = obs\n                    px,py = p\n                    if x <= px <= x+w and y <= py <= y+h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(fr,to, resolution=1.0):\n            d = dist(fr,to)\n            steps = max(1, int(d / resolution))\n            for i in range(steps + 1):\n                interp = tuple(fr[j] + (to[j] - fr[j]) * i / steps for j in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: dist(node.position, point))\n\n        def near_nodes(tree, point, radius):\n            return [node for node in tree if dist(node.position, point) <= radius]\n\n        def rewire(tree, new_node, near_nodes_):\n            nonlocal edges\n            for near in near_nodes_:\n                if near == new_node.parent:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, near.position)\n                if new_cost + 1e-7 < near.cost:\n                    if not is_edge_in_obstacle(new_node.position, near.position):\n                        # Remove old edge\n                        if near.parent is not None:\n                            try:\n                                edges.remove((near.parent, near))\n                            except Exception:\n                                pass\n                        near.parent.children.remove(near) if near.parent else None\n                        near.parent = new_node\n                        near.cost = new_cost\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n\n        def extract_path(node_from_start, node_from_goal):\n            path_start = node_from_start.path_from_root()\n            path_goal = node_from_goal.path_from_root()[::-1]\n            if len(path_start) > 0 and len(path_goal) > 0 and path_start[-1] == path_goal[0]:\n                path_goal = path_goal[1:]\n            return path_start + path_goal\n\n        def sample_point():\n            if random.random() < self.goal_sample_rate:\n                return goal_pos\n            else:\n                return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n\n        def shortcut_path(path):\n            # Attempts shortcutting to reduce sharp turns and improve smoothness\n            for _ in range(self.shortcut_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i+2, len(path) -1)\n                p1, p2 = path[i], path[j]\n                if not is_edge_in_obstacle(p1, p2):\n                    # shortcut successful: remove intermediate points between i and j\n                    path = path[:i+1] + path[j:]\n            return path\n\n        def adaptive_radius(tree_size):\n            # follow RRT* inspired radius scaling: gamma*(log(n)/n)^(1/d)\n            gamma = self.base_radius\n            n = max(tree_size, 1)\n            radius = gamma * (math.log(n)/n)**(1.0/dim)\n            return max(radius, self.step_size*1.5)\n\n        success = False\n        connection_pair = (None, None)\n\n        # Alternate which is tree A and tree B\n        for it in range(self.max_iter):\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                q_rand = sample_point()\n                nearest_node = nearest(tree_a, q_rand)\n                q_new_pos = steer(nearest_node.position, q_rand)\n                if is_in_obstacle(q_new_pos):\n                    continue\n                if is_edge_in_obstacle(nearest_node.position, q_new_pos):\n                    continue\n\n                # Rewiring radius adaptive\n                radius = adaptive_radius(len(tree_a))\n\n                # Find near nodes in tree_a for rewiring\n                near_nodes_a = near_nodes(tree_a, q_new_pos, radius)\n\n                # Choose best parent minimizing cost\n                min_cost = nearest_node.cost + dist(nearest_node.position, q_new_pos)\n                min_parent = nearest_node\n                for near_node in near_nodes_a:\n                    c = near_node.cost + dist(near_node.position, q_new_pos)\n                    if c < min_cost and not is_edge_in_obstacle(near_node.position, q_new_pos):\n                        min_cost = c\n                        min_parent = near_node\n\n                q_new = Node(q_new_pos, parent=min_parent, cost=min_cost)\n                min_parent.add_child(q_new)\n                tree_a.append(q_new)\n                nodes.append(q_new)\n                edges.append((min_parent, q_new))\n\n                # Rewire neighbors for improved costs\n                rewire(tree_a, q_new, near_nodes_a)\n\n                # Attempt connection to other tree\n                nearest_to_new = nearest(tree_b, q_new.position)\n                dist_connect = dist(q_new.position, nearest_to_new.position)\n                radius_connect = max(self.step_size*1.5, adaptive_radius(len(tree_b)))\n                if dist_connect <= radius_connect and not is_edge_in_obstacle(q_new.position, nearest_to_new.position):\n                    # Connected trees successfully\n                    if tree_a is start_tree:\n                        node_start, node_goal = q_new, nearest_to_new\n                    else:\n                        node_start, node_goal = nearest_to_new, q_new\n                    success = True\n                    connection_pair = (node_start, node_goal)\n                    break\n            if success:\n                break\n\n        path = []\n        if success:\n            raw_path = extract_path(connection_pair[0], connection_pair[1])\n            path = shortcut_path(raw_path)\n\n        return PlannerResult(success, path, nodes, edges)",
            "objective": -33.9861,
            "time_improvement": 56.0,
            "length_improvement": 16.0,
            "smoothness_improvement": 1519.0,
            "node_improvement": 69.0,
            "other_inf": [
                {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.01380462646484375,
                    "num_nodes_avg": 128.7,
                    "path_length_avg": 166.57538852397772,
                    "smoothness_avg": 0.04015959576609991,
                    "success_improvement": 0.0,
                    "time_improvement": 46.47463126707311,
                    "node_improvement": 67.59002770083103,
                    "length_improvement": 8.697389994063707,
                    "smoothness_improvement": 528.5848816974815,
                    "objective_score": 21.803747785047563
                },
                {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.028153705596923827,
                    "num_nodes_avg": 317.3,
                    "path_length_avg": 238.40919577619638,
                    "smoothness_avg": 0.10655923140396159,
                    "success_improvement": 0.0,
                    "time_improvement": 82.9964744581085,
                    "node_improvement": 78.68037358059532,
                    "length_improvement": 20.412148221691805,
                    "smoothness_improvement": 2641.8457755359923,
                    "objective_score": 50.35546014812759
                },
                {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.031368589401245116,
                    "num_nodes_avg": 304.4,
                    "path_length_avg": 121.92947455845565,
                    "smoothness_avg": 0.11683997631770895,
                    "success_improvement": 0.0,
                    "time_improvement": 38.186536846996304,
                    "node_improvement": 61.29688493324858,
                    "length_improvement": 19.020248655927677,
                    "smoothness_improvement": 1386.1958745313084,
                    "objective_score": 29.79908962031204
                }
            ],
            "success_rate": 1.0
        },
        "objective": 370.5999999999999,
        "analysis": {
            "problem": [
                "Problem of the parents algorithm:\n   - Inefficient exploration strategies without goal bias, leading to slower tree growth and longer planning times.\n   - Fixed or simplistic rewiring procedures lacking adaptive neighborhood radius, causing suboptimal path length and higher computational overhead.\n   - Direct concatenation of paths from bidirectional trees without post-processing, resulting in jagged, less smooth paths.\n   - Repeated and sometimes coarse obstacle checking, increasing planning time and reducing efficiency.\n   - Absence of systematic path smoothing or shortcutting, leading to lower path smoothness and rough trajectories."
            ],
            "solution": "1. Primary contributors to the performance improvement:\n   - Introduction of adaptive rewiring radius scaled by tree size and dimensionality, enabling more efficient local cost minimization.\n   - Use of goal-biased sampling to focus exploration towards the target, accelerating tree convergence and reducing planning time.\n   - Implementation of a post-planning shortcutting procedure to smooth the final path, significantly improving smoothness metrics.\n   - Efficient and selective rewiring of nearby nodes to optimize path length and geometry incrementally during planning.\n2. Expected mechanism of impact:\n   - Adaptive radius focuses rewiring on relevant neighbors, enhancing path optimality and reducing unnecessary rewiring computations.\n   - Goal bias promotes quicker tree expansion towards the goal region, shortening planning time.\n   - Shortcutting removes unnecessary waypoints and sharp turns, drastically improving path smoothness.\n   - Incremental rewiring rearranges connections for lower cost paths, thereby shortening overall path length and improving trajectory quality."
        }
    },
    {
        "parents": [
            {
                "operator": "m1",
                "algorithm_description": "This algorithm is a bidirectional RRT* variant enhanced with an informed sampling heuristic that biases sampling towards an ellipsoidal subset defined by the current best path cost. It further integrates incremental rewiring with cost-to-come and cost-to-go estimations to improve path optimality. The planner grows two trees from start and goal, extends nodes toward sampled points within the informed subset to reduce unnecessary explorations, performs local rewiring with proper cost propagation to descendants, and attempts to connect the trees for early success detection. The resulting path is extracted and finally post-processed by shortcutting to improve smoothness and path length.<The planner alternates growth of two trees using informed sampling bounded by the best path cost to focus the search. Each extension chooses parents minimizing cost-to-come, performs rewiring with cost propagation, and attempts to connect the trees within step size. On success, a composed path is extracted and shortcutting post-processing is applied to enhance smoothness and reduce length, all while performing collision checks on nodes and edges within map bounds.>",
                "planning_mechanism": "The planner alternates growth of two trees using informed sampling bounded by the best path cost to focus the search. Each extension chooses parents minimizing cost-to-come, performs rewiring with cost propagation, and attempts to connect the trees within step size. On success, a composed path is extracted and shortcutting post-processing is applied to enhance smoothness and reduce length, all while performing collision checks on nodes and edges within map bounds.",
                "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=5.0, radius=15.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.radius = radius\n\n    def plan(self, map):\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        edges = []\n        best_cost = math.inf\n        best_path = []\n        # For convenience: track all nodes with costs for pruning informed sampling\n        all_nodes_start = start_tree\n        all_nodes_goal = goal_tree\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def in_bounds(p):\n            return all(0 <= p[i] <= bounds[i] for i in range(len(p)))\n\n        def collision_node(p):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = p\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    px, py = p\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def collision_edge(a, b, resolution=0.5):\n            length = dist(a, b)\n            steps = max(1, int(length / resolution))\n            for i in range(steps + 1):\n                interp = tuple(a[d] + (b[d] - a[d]) * (i / steps) for d in range(len(a)))\n                if collision_node(interp):\n                    return True\n            return False\n\n        def steer(from_p, to_p):\n            length = dist(from_p, to_p)\n            if length <= self.step_size:\n                return to_p\n            ratio = self.step_size / length\n            return tuple(from_p[i] + (to_p[i] - from_p[i]) * ratio for i in range(len(from_p)))\n\n        def nearest(tree, point):\n            best = None\n            best_dist = math.inf\n            for node in tree:\n                d = dist(node.position, point)\n                if d < best_dist:\n                    best = node\n                    best_dist = d\n            return best\n\n        def near(tree, point, radius):\n            return [node for node in tree if dist(node.position, point) <= radius]\n\n        def path_cost_to_go(p):\n            # Use Euclidean distance heuristic from point p to goal (lower bound cost-to-go)\n            return dist(p, goal_pos)\n\n        def path_cost_start_to(p):\n            # Simple heuristic: find nearest start tree node cost + dist\n            near_node = nearest(start_tree, p)\n            return near_node.cost + dist(near_node.position, p)\n\n        def informed_sample():\n            # Informed sampling inside an ellipsoid defined by c_min and foci start/goal\n            # If no solution yet, uniform random\n            if best_cost == math.inf:\n                while True:\n                    sample = tuple(random.uniform(0, bounds[i]) for i in range(len(bounds)))\n                    if not collision_node(sample):\n                        return sample\n            # Ellipsoidal sampling\n            c_min = dist(start_pos, goal_pos)\n            c_best = best_cost\n            if c_best == math.inf or c_best < c_min:\n                c_best = math.inf\n            # Construct ellipsoid with foci start_pos and goal_pos, axis1 length c_best/2\n            # Sample uniformly within unit ball and map to ellipsoid\n            foci_dist = c_min\n            if c_best == math.inf:\n                # fallback uniform\n                while True:\n                    sample = tuple(random.uniform(0, bounds[i]) for i in range(len(bounds)))\n                    if not collision_node(sample):\n                        return sample\n            else:\n                # 2D or 3D informed sampling\n                dimension = len(bounds)\n                center = tuple((start_pos[i] + goal_pos[i]) / 2 for i in range(dimension))\n\n                def unit_ball_sample(dim):\n                    while True:\n                        vec = [random.gauss(0, 1) for _ in range(dim)]\n                        norm = math.sqrt(sum(x * x for x in vec))\n                        if norm > 1e-8:\n                            break\n                    u = [x / norm for x in vec]\n                    r = random.random() ** (1 / dim)\n                    return [u[i] * r for i in range(dim)]\n\n                # Rotation matrix to align line start->goal to x-axis\n                # For simplicity, apply translation and scale without rotation:\n                # Sample in a prolate hyperspheroid axis aligned along x with radius c_best/2 along x and sqrt(c_best^2 - c_min^2)/2 along others\n\n                c1 = c_best / 2\n                if c_best*c_best - foci_dist*foci_dist < 0:\n                    # Numerical stability fallback\n                    rb = 0\n                else:\n                    rb = math.sqrt(c_best * c_best - foci_dist * foci_dist) / 2\n\n                while True:\n                    x_ball = unit_ball_sample(dimension)\n                    # Scale unit ball coordinate to ellipsoid radii\n                    sample_ellipsoid = [0]*dimension\n                    sample_ellipsoid[0] = x_ball[0] * c1\n                    for i in range(1, dimension):\n                        sample_ellipsoid[i] = x_ball[i] * rb\n                    # Translate to center\n                    point = tuple(center[i] + sample_ellipsoid[i] for i in range(dimension))\n                    if in_bounds(point) and not collision_node(point):\n                        return point\n\n        def rewire(tree, new_node, near_nodes):\n            # For each near node, try to improve cost by rerouting through new_node\n            for near_node in near_nodes:\n                if near_node is new_node.parent:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, near_node.position)\n                if new_cost + path_cost_to_go(near_node.position) < near_node.cost + path_cost_to_go(near_node.position):\n                    if new_cost < near_node.cost:\n                        # Check edge collision\n                        if not collision_edge(new_node.position, near_node.position):\n                            # Remove from old parent children list\n                            if near_node.parent:\n                                near_node.parent.remove_child(near_node)\n                                if (near_node.parent, near_node) in edges:\n                                    edges.remove((near_node.parent, near_node))\n                            # Update parent and cost\n                            near_node.parent = new_node\n                            near_node.cost = new_cost\n                            new_node.add_child(near_node)\n                            edges.append((new_node, near_node))\n                            propagate_cost(near_node)\n\n        def propagate_cost(node):\n            # Recursively update cost of descendants after rewiring\n            for child in node.children:\n                old_cost = child.cost\n                child.cost = node.cost + dist(node.position, child.position)\n                if child.cost < old_cost:\n                    propagate_cost(child)\n\n        def extract_path(conn_start_node, conn_goal_node):\n            path_start = []\n            node = conn_start_node\n            while node:\n                path_start.append(node.position)\n                node = node.parent\n            path_start.reverse()\n            path_goal = []\n            node = conn_goal_node\n            while node:\n                path_goal.append(node.position)\n                node = node.parent\n            return path_start + path_goal\n\n        def shortcut_path(path):\n            # Post process path to smooth by shortcutting\n            if len(path) < 3:\n                return path[:]\n            new_path = [path[0]]\n            i = 0\n            while i < len(path) - 1:\n                j = len(path) - 1\n                while j > i + 1:\n                    if not collision_edge(path[i], path[j]):\n                        break\n                    j -= 1\n                new_path.append(path[j])\n                i = j\n            return new_path\n\n        for _ in range(self.max_iter):\n            sample = informed_sample()\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest_node = nearest(tree_a, sample)\n                new_pos = steer(nearest_node.position, sample)\n                if not in_bounds(new_pos):\n                    continue\n                if collision_node(new_pos):\n                    continue\n                if collision_edge(nearest_node.position, new_pos):\n                    continue\n\n                near_nodes = near(tree_a, new_pos, self.radius)\n                # Choose parent minimizing cost-to-come + edge cost\n                min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n                min_parent = nearest_node\n                for near_node in near_nodes:\n                    if collision_edge(near_node.position, new_pos):\n                        continue\n                    cost = near_node.cost + dist(near_node.position, new_pos)\n                    if cost < min_cost:\n                        min_cost = cost\n                        min_parent = near_node\n                new_node = Node(new_pos, min_parent, min_cost)\n                min_parent.add_child(new_node)\n                tree_a.append(new_node)\n                edges.append((min_parent, new_node))\n\n                rewire(tree_a, new_node, near_nodes)\n\n                # Try to connect trees with the newly added node\n                nearest_to_new = nearest(tree_b, new_node.position)\n                dist_connect = dist(new_node.position, nearest_to_new.position)\n                if dist_connect <= self.step_size:\n                    if not collision_edge(new_node.position, nearest_to_new.position):\n                        # Build path and update best if improved\n                        path_candidate = extract_path(new_node, nearest_to_new)\n                        cost_candidate = 0.0\n                        for i in range(len(path_candidate) -1):\n                            cost_candidate += dist(path_candidate[i], path_candidate[i+1])\n                        if cost_candidate < best_cost:\n                            best_cost = cost_candidate\n                            best_path = path_candidate\n                            best_path = shortcut_path(best_path)\n                            # Early success return with improved path\n                            return PlannerResult(True, best_path, start_tree + goal_tree, edges)\n\n        if best_path:\n            return PlannerResult(True, best_path, start_tree + goal_tree, edges)\n        return PlannerResult(False, [], start_tree + goal_tree, edges)",
                "objective": 28.38357,
                "time_improvement": -149.0,
                "length_improvement": 16.0,
                "smoothness_improvement": 1332.0,
                "node_improvement": 66.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.10150227546691895,
                        "num_nodes_avg": 168.5,
                        "path_length_avg": 173.97986388023872,
                        "smoothness_avg": 0.04949234554306939,
                        "success_improvement": 0.0,
                        "time_improvement": -293.5598500570837,
                        "node_improvement": 57.567363384537906,
                        "length_improvement": 4.63887971987665,
                        "smoothness_improvement": 674.6626820975691,
                        "objective_score": -81.91131377471126
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.08119781017303467,
                        "num_nodes_avg": 277.4,
                        "path_length_avg": 229.5331563084081,
                        "smoothness_avg": 0.08293948567098822,
                        "success_improvement": 0.0,
                        "time_improvement": 50.960308422998224,
                        "node_improvement": 81.36128468722704,
                        "length_improvement": 23.375225678669988,
                        "smoothness_improvement": 2034.0927052113911,
                        "objective_score": 39.48369146015841
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.15377495288848878,
                        "num_nodes_avg": 319.0,
                        "path_length_avg": 121.10263595371161,
                        "smoothness_avg": 0.10914829386804074,
                        "success_improvement": 0.0,
                        "time_improvement": -203.0216712215368,
                        "node_improvement": 59.44055944055944,
                        "length_improvement": 19.56939548737532,
                        "smoothness_improvement": 1288.35824151247,
                        "objective_score": -42.7230728664735
                    }
                ],
                "success_rate": 1.0
            },
            {
                "operator": "initial",
                "algorithm_description": "This algorithm is a bidirectional extension of RRT* that grows two trees from start and goal while optimizing paths via rewiring. It combines RRT*\u2018s asymptotic optimality with RRT-Connect\u2019s fast convergence through connection attempts between the trees.",
                "planning_mechanism": "The planner alternates growing two trees with sampling, extension, and rewiring. After each extension, it attempts to connect both trees. When connection is successful, a rewired optimal path is extracted across both trees.",
                "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, radius: float = 10.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.radius = radius\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n        nodes = []\n        edges = []\n        success_state = False\n        extracted_path = []\n\n        for iter in range(self.max_iter):\n            rand = self._sample_free(bounds, obstacles, is_3d)\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest = self._nearest(tree_a, rand)\n                new_pos = self._steer(nearest.position, rand, self.step_size)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                    continue\n\n                new_node = Node(new_pos)\n                near_nodes = self._near(tree_a, new_pos, self.radius)\n                min_cost = nearest.cost + self._distance(nearest.position, new_pos)\n                min_parent = nearest\n\n                for near in near_nodes:\n                    cost = near.cost + self._distance(near.position, new_pos)\n                    if cost < min_cost and not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d):\n                        min_cost = cost\n                        min_parent = near\n\n                new_node.parent = min_parent\n                new_node.cost = min_cost\n                min_parent.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((min_parent, new_node))\n\n                for near in near_nodes:\n                    if near == min_parent:\n                        continue\n                    new_cost = new_node.cost + self._distance(new_node.position, near.position)\n                    if new_cost < near.cost and not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                        if near.parent:\n                            edges.remove((near.parent, near))\n                        near.parent = new_node\n                        near.cost = new_cost\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n\n                connect_node = self._nearest(tree_b, new_node.position)\n                if self._distance(new_node.position, connect_node.position) < self.step_size and not self._is_edge_in_obstacle(new_node.position, connect_node.position, obstacles, is_3d):\n                    success_state = True\n                    extracted_path = self._extract_path(new_node, connect_node)\n                    return PlannerResult(True, extracted_path, start_tree + goal_tree, edges)\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        while True:\n            point = tuple(random.uniform(0, bounds[i]) for i in range(3 if is_3d else 2))\n            if not self._is_in_obstacle(point, obstacles, is_3d):\n                return point\n\n    def _nearest(self, tree, point):\n        return min(tree, key=lambda node: self._distance(node.position, point))\n\n    def _near(self, tree, point, radius):\n        return [node for node in tree if self._distance(node.position, point) <= radius]\n\n    def _steer(self, from_pos, to_pos, step_size):\n        dist = self._distance(from_pos, to_pos)\n        if dist <= step_size:\n            return to_pos\n        ratio = step_size / dist\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n    def _extract_path(self, node_a, node_b):\n        path_a = []\n        while node_a:\n            path_a.append(node_a.position)\n            node_a = node_a.parent\n        path_b = []\n        while node_b:\n            path_b.append(node_b.position)\n            node_b = node_b.parent\n        return list(reversed(path_a)) + path_b\n\n    def _distance(self, a, b):\n        return math.dist(a, b)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = self._distance(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n    ",
                "objective": -26.062040773062417,
                "time_improvement": 66.0,
                "length_improvement": 9.0,
                "smoothness_improvement": 167.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.012016057968139648,
                        "num_nodes_avg": 134.5,
                        "path_length_avg": 175.84673815929608,
                        "smoothness_avg": 0.016310939143948412,
                        "success_improvement": 0.0,
                        "time_improvement": 53.409537367863955,
                        "node_improvement": 66.1294384286074,
                        "length_improvement": 3.6156163450092893,
                        "smoothness_improvement": 155.30161737405683,
                        "objective_score": 18.96873910423504
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.018314409255981445,
                        "num_nodes_avg": 253.0,
                        "path_length_avg": 257.3377355314211,
                        "smoothness_avg": 0.010767991223558952,
                        "success_improvement": 0.0,
                        "time_improvement": 88.93895070058699,
                        "node_improvement": 83.00073909830007,
                        "length_improvement": 14.093256823589732,
                        "smoothness_improvement": 177.06817005275553,
                        "objective_score": 36.02298015459372
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.022396659851074217,
                        "num_nodes_avg": 265.9,
                        "path_length_avg": 136.5245362961063,
                        "smoothness_avg": 0.0210441701583257,
                        "success_improvement": 0.0,
                        "time_improvement": 55.86619816574277,
                        "node_improvement": 66.19198982835347,
                        "length_improvement": 9.326903591935762,
                        "smoothness_improvement": 167.68029109483984,
                        "objective_score": 23.19440306035849
                    }
                ],
                "success_rate": 1.0
            }
        ],
        "offspring": {
            "operator": "e2",
            "algorithm_description": "This algorithm is a bidirectional RRT* variant combining informed elliptical sampling with adaptive neighborhood radius recalibration to improve convergence speed and path quality. It grows two trees simultaneously from start and goal, performs efficient nearest and near neighbor searches, applies incremental rewiring with cost propagation, and attempts frequent connections between trees. The informed sampling targets ellipsoidal regions shaped by the best current path cost, and the radius adapts based on iteration count and node density to balance exploration and optimization. After successful connection, the algorithm extracts and performs iterated shortcut smoothing to produce shorter, smoother paths while ensuring collision-free nodes and edges within map bounds.",
            "planning_mechanism": "The planner alternates expansion of two trees using adaptive informed sampling within an ellipsoidal informed set defined by the best path cost. Each extension seeks a minimum cost parent within an adaptive radius, followed by rewiring neighbors to reduce path cost with recursive updates. Regular connection attempts between trees detect early solutions. When a solution is found, the algorithm performs iterative shortcutting with collision checks to improve smoothness and path length while respecting collision and map boundary constraints.",
            "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=5.0, base_radius=20.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.base_radius = base_radius\n\n    def plan(self, map):\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        edges = []\n\n        best_path = []\n        best_cost = float('inf')\n\n        def dist(a, b):\n            return math.dist(a,b)\n\n        def in_bounds(p):\n            return all(0 <= p[i] <= bounds[i] for i in range(dim))\n\n        def collision_node(p):\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d = obs\n                    px,py,pz = p\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                        return True\n                else:\n                    x,y,w,h = obs\n                    px,py = p\n                    if x <= px <= x+w and y <= py <= y+h:\n                        return True\n            return False\n\n        def collision_edge(a,b,res=0.5):\n            length = dist(a,b)\n            steps = max(1,int(length / res))\n            for i in range(steps+1):\n                interp = tuple(a[d] + (b[d]-a[d])*(i/steps) for d in range(dim))\n                if collision_node(interp):\n                    return True\n            return False\n\n        def steer(from_p,to_p):\n            length = dist(from_p,to_p)\n            if length <= self.step_size:\n                return to_p\n            ratio = self.step_size / length\n            return tuple(from_p[i] + (to_p[i] - from_p[i]) * ratio for i in range(dim))\n\n        def nearest(tree, p):\n            best_node = None\n            best_dist = float('inf')\n            for node in tree:\n                d = dist(node.position, p)\n                if d < best_dist:\n                    best_dist = d\n                    best_node = node\n            return best_node\n\n        def near(tree, p, radius):\n            result = []\n            r_sq = radius*radius\n            for node in tree:\n                d_sq = sum((node.position[i] - p[i])**2 for i in range(dim))\n                if d_sq <= r_sq:\n                    result.append(node)\n            return result\n\n        def heuristic_cost_to_go(p):\n            return dist(p, goal_pos)\n\n        def cost_to_come(p):\n            nn = nearest(start_tree, p)\n            return nn.cost + dist(nn.position, p)\n\n        def informed_sample():\n            c_min = dist(start_pos, goal_pos)\n            c_best = best_cost\n            if c_best == float('inf'):\n                while True:\n                    sample = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                    if not collision_node(sample):\n                        return sample\n            # Ellipsoidal informed sampling:\n            center = tuple((start_pos[i] + goal_pos[i]) / 2 for i in range(dim))\n            foci_dist = c_min\n            if c_best < c_min:\n                c_best = c_min + 1e-6\n            r1 = c_best / 2\n            val = c_best*c_best - foci_dist*foci_dist\n            r_rest = math.sqrt(val)/2 if val > 0 else 0.0\n\n            def unit_ball_sample(dim_):\n                while True:\n                    vec = [random.gauss(0,1) for _ in range(dim_)]\n                    norm = math.sqrt(sum(x*x for x in vec))\n                    if norm > 1e-8:\n                        break\n                u = [x/norm for x in vec]\n                r = random.random() ** (1/dim_)\n                return [u[i]*r for i in range(dim_)]\n\n            while True:\n                u_sample = unit_ball_sample(dim)\n                sample_ellipsoid = [0]*dim\n                sample_ellipsoid[0] = u_sample[0]*r1\n                for i in range(1,dim):\n                    sample_ellipsoid[i] = u_sample[i]*r_rest\n                point = tuple(center[i] + sample_ellipsoid[i] for i in range(dim))\n                if in_bounds(point) and not collision_node(point):\n                    return point\n\n        def new_radius(iteration, tree_size):\n            # Adaptive radius shrinking over iterations and growing tree size, per theory ~ (log n / n)^{1/d}\n            if tree_size < 2:\n                return self.base_radius\n            gamma_rrt_star = self.base_radius\n            radius = min(gamma_rrt_star, \n                         gamma_rrt_star * (math.log(tree_size)/tree_size)**(1/dim))\n            # Enforce reasonable limits\n            return max(radius, self.step_size)\n\n        def propagate_cost(node):\n            for child in node.children:\n                new_cost = node.cost + dist(node.position, child.position)\n                if new_cost < child.cost:\n                    child.cost = new_cost\n                    propagate_cost(child)\n\n        def rewire(tree, new_node, near_nodes):\n            for near_node in near_nodes:\n                if near_node is new_node.parent:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, near_node.position)\n                est_total_new = new_cost + heuristic_cost_to_go(near_node.position)\n                est_total_old = near_node.cost + heuristic_cost_to_go(near_node.position)\n                if est_total_new + 1e-9 < est_total_old and new_cost < near_node.cost:\n                    if not collision_edge(new_node.position, near_node.position):\n                        # Remove old parent-child relationship\n                        if near_node.parent:\n                            near_node.parent.remove_child(near_node)\n                            if (near_node.parent, near_node) in edges:\n                                edges.remove((near_node.parent, near_node))\n                        near_node.parent = new_node\n                        near_node.cost = new_cost\n                        new_node.add_child(near_node)\n                        edges.append((new_node, near_node))\n                        propagate_cost(near_node)\n\n        def extract_path(node_start, node_goal):\n            path_start = []\n            node = node_start\n            while node:\n                path_start.append(node.position)\n                node = node.parent\n            path_start.reverse()\n            path_goal = []\n            node = node_goal\n            while node:\n                path_goal.append(node.position)\n                node = node.parent\n            return path_start + path_goal\n\n        def shortcut_path(path, max_iters=50):\n            length = len(path)\n            if length < 3:\n                return path[:]\n            new_path = path[:]\n            for _ in range(max_iters):\n                if len(new_path) < 3:\n                    break\n                i = random.randint(0, len(new_path)-3)\n                j = random.randint(i+2, len(new_path)-1)\n                if not collision_edge(new_path[i], new_path[j]):\n                    del new_path[i+1:j]\n            return new_path\n\n        for iter in range(1, self.max_iter+1):\n            sample = informed_sample()\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nn = nearest(tree_a, sample)\n                new_pos = steer(nn.position, sample)\n                if not in_bounds(new_pos):\n                    continue\n                if collision_node(new_pos):\n                    continue\n                if collision_edge(nn.position, new_pos):\n                    continue\n\n                radius = new_radius(iter, len(tree_a))\n                near_nodes = near(tree_a, new_pos, radius)\n\n                min_cost = nn.cost + dist(nn.position, new_pos)\n                min_parent = nn\n                for near_node in near_nodes:\n                    cost_cand = near_node.cost + dist(near_node.position, new_pos)\n                    if cost_cand < min_cost and not collision_edge(near_node.position, new_pos):\n                        min_cost = cost_cand\n                        min_parent = near_node\n\n                new_node = Node(new_pos, min_parent, min_cost)\n                min_parent.add_child(new_node)\n                tree_a.append(new_node)\n                edges.append((min_parent, new_node))\n\n                rewire(tree_a, new_node, near_nodes)\n\n                conn_node = nearest(tree_b, new_node.position)\n                dist_connect = dist(conn_node.position, new_node.position)\n                if dist_connect <= self.step_size and not collision_edge(conn_node.position, new_node.position):\n                    candidate_path = extract_path(new_node, conn_node)\n                    path_cost = 0.0\n                    for k in range(len(candidate_path)-1):\n                        path_cost += dist(candidate_path[k], candidate_path[k+1])\n                    if path_cost < best_cost:\n                        best_cost = path_cost\n                        best_path = shortcut_path(candidate_path, max_iters=100)\n                        if best_cost < float('inf'):\n                            return PlannerResult(True, best_path, start_tree + goal_tree, edges)\n\n        if best_path:\n            return PlannerResult(True, best_path, start_tree + goal_tree, edges)\n        return PlannerResult(False, [], start_tree + goal_tree, edges)",
            "objective": -26.27848,
            "time_improvement": 35.0,
            "length_improvement": 15.0,
            "smoothness_improvement": 1433.0,
            "node_improvement": 70.0,
            "other_inf": [
                {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.018117833137512206,
                    "num_nodes_avg": 114.4,
                    "path_length_avg": 171.0714968515819,
                    "smoothness_avg": 0.0338915604180979,
                    "success_improvement": 0.0,
                    "time_improvement": 29.750819278110836,
                    "node_improvement": 71.19113573407203,
                    "length_improvement": 6.233001774308198,
                    "smoothness_improvement": 430.476517244636,
                    "objective_score": 14.81742943424135
                },
                {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.031439352035522464,
                    "num_nodes_avg": 278.2,
                    "path_length_avg": 238.74291742398609,
                    "smoothness_avg": 0.10316733134869423,
                    "success_improvement": 0.0,
                    "time_improvement": 81.01209719920723,
                    "node_improvement": 81.3075320835853,
                    "length_improvement": 20.300742330014568,
                    "smoothness_improvement": 2554.5697440271038,
                    "objective_score": 49.25692327790643
                },
                {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.05441353321075439,
                    "num_nodes_avg": 340.1,
                    "path_length_avg": 124.59040420304787,
                    "smoothness_avg": 0.11126977220167059,
                    "success_improvement": 0.0,
                    "time_improvement": -7.224742787261016,
                    "node_improvement": 56.75778766687858,
                    "length_improvement": 17.252985885842975,
                    "smoothness_improvement": 1315.3432893250001,
                    "objective_score": 14.761085141952478
                }
            ],
            "success_rate": 1.0
        },
        "objective": 819.4,
        "analysis": {
            "problem": [
                "Problem of the parents algorithm:\n   - Use of fixed or non-adaptive neighbor radius for rewiring, limiting effective optimization as trees grow.\n   - Inefficient and uniform sampling strategies resulting in slower convergence and exploration of irrelevant regions.\n   - Limited or greedy path smoothing techniques applied only once, reducing potential for improving smoothness.\n   - Redundant and frequent collision checks during rewiring increasing computational time.\n   - Early termination upon first solution without iterative improvement limiting path quality."
            ],
            "solution": "1. Primary contributors to the performance improvement:\n   - Introduction of adaptive neighbor radius shrinking based on iteration count and tree size, enabling more focused and efficient rewiring.\n   - Integration of informed elliptical sampling aligned with current best path costs, directing exploration toward promising regions.\n   - Use of iterative shortcut path smoothing as post-processing to further reduce path length and improve smoothness.\n   - Cost propagation through rewired nodes enhancing subtree cost consistency.\n   - Balanced bidirectional expansion with frequent connection attempts improving solution discovery speed.\n\n2. Expected mechanism of impact:\n   - Adaptive radius focuses rewiring on relevant nearby nodes, improving path cost and smoothness while reducing unnecessary computations.\n   - Informed sampling reduces sampling in low-potential regions, accelerating convergence towards high-quality paths.\n   - Iterative shortcutting removes unnecessary waypoints and smoothes transitions, directly enhancing path smoothness and shortening length.\n   - Cost propagation maintains consistent cost updates across descendants, reducing suboptimal branching.\n   - Early and frequent connection attempts between expanding trees allow faster identification and refinement of feasible paths."
        }
    },
    {
        "parents": [
            {
                "operator": "m1",
                "algorithm_description": "A hybrid bidirectional incremental sampling planner with goal biasing, adaptive informed sampling region shrinking, efficient nearest neighbor search with pruning, and a lazy rewiring scheme to balance speed and path quality. The planner grows two trees toward each other using adaptive ellipsoidal informed sampling, selects parents and rewires based on collision-checked cost improvements, and attempts early tree connections for fast solution finding. After a successful connection, the path is refined using iterative shortcut smoothing to optimize length and smoothness while respecting map constraints.",
                "planning_mechanism": "The planner alternates expanding two trees from the start and goal, sampling adaptively within an ellipsoid defined by the current best path length to focus exploration. Nodes are connected considering minimum cost-to-come, with rewiring applied lazily only when cost improvements are detected without full descendant propagation for efficiency. Tree connection attempts are made whenever nodes get close, with early termination on success. Final path extraction is followed by iterative shortcutting to enhance smoothness and length reduction while ensuring collision-free paths.",
                "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\nclass Planner:\n    def __init__(self, max_iter=4000, step_size=4.5, neighbor_radius=12.0, goal_sample_rate=0.1):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.neighbor_radius = neighbor_radius\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map):\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = dim == 3\n\n        import random\n        import math\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def in_bounds(p):\n            return all(0 <= p[i] <= bounds[i] for i in range(dim))\n\n        def collision_node(p):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = p\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    px, py = p\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def collision_edge(a, b, resolution=0.4):\n            length = dist(a, b)\n            steps = max(2, int(length / resolution))\n            for i in range(steps + 1):\n                interp = tuple(a[d] + (b[d] - a[d]) * (i / steps) for d in range(dim))\n                if collision_node(interp):\n                    return True\n            return False\n\n        def steer(from_p, to_p):\n            length = dist(from_p, to_p)\n            if length <= self.step_size:\n                return to_p\n            ratio = self.step_size / length\n            return tuple(from_p[i] + (to_p[i] - from_p[i]) * ratio for i in range(dim))\n\n        def nearest(tree, point):\n            best_node = None\n            best_dist = math.inf\n            for node in tree:\n                d = dist(node.position, point)\n                if d < best_dist:\n                    best_node = node\n                    best_dist = d\n            return best_node\n\n        def near(tree, point, radius):\n            result = []\n            r2 = radius * radius\n            for node in tree:\n                # squared dist faster for rough pruning\n                d2 = sum((node.position[i] - point[i]) ** 2 for i in range(dim))\n                if d2 <= r2:\n                    result.append(node)\n            return result\n\n        def path_cost_to_go(p):\n            return dist(p, goal_pos)\n\n        def informed_sample(best_cost):\n            c_min = dist(start_pos, goal_pos)\n            if best_cost == math.inf or best_cost < c_min:\n                # Uniform random sample inside bounds with collision check\n                while True:\n                    s = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                    if not collision_node(s):\n                        return s\n            # Ellipsoidal informed sampling\n            c_best = best_cost\n            foci_dist = c_min\n            center = tuple((start_pos[i] + goal_pos[i]) * 0.5 for i in range(dim))\n            c1 = c_best * 0.5\n            val = c_best * c_best - foci_dist * foci_dist\n            if val < 1e-12:\n                rb = 0.0\n            else:\n                rb = math.sqrt(val) * 0.5\n\n            while True:\n                # sample in unit ball\n                while True:\n                    vec = [random.gauss(0, 1) for _ in range(dim)]\n                    norm = math.sqrt(sum(x * x for x in vec))\n                    if norm > 1e-7:\n                        break\n                unit = [x / norm for x in vec]\n                r = random.random() ** (1.0 / dim)\n                ball_sample = [unit[i] * r for i in range(dim)]\n\n                sample_ellipsoid = [0.0] * dim\n                sample_ellipsoid[0] = ball_sample[0] * c1\n                for i in range(1, dim):\n                    sample_ellipsoid[i] = ball_sample[i] * rb\n\n                point = tuple(center[i] + sample_ellipsoid[i] for i in range(dim))\n                if in_bounds(point) and not collision_node(point):\n                    return point\n\n        def update_parent_and_cost(child, new_parent, new_cost):\n            if child.parent:\n                child.parent.remove_child(child)\n            child.parent = new_parent\n            child.cost = new_cost\n            new_parent.add_child(child)\n\n        def rewire_lazy(tree, new_node, near_nodes):\n            # Rewire near nodes without recursive descendant cost update for speed\n            for near_n in near_nodes:\n                if near_n is new_node.parent:\n                    continue\n                c_through = new_node.cost + dist(new_node.position, near_n.position)\n                if c_through + path_cost_to_go(near_n.position) < near_n.cost + path_cost_to_go(near_n.position):\n                    if c_through < near_n.cost:\n                        if not collision_edge(new_node.position, near_n.position):\n                            update_parent_and_cost(near_n, new_node, c_through)\n\n        def extract_path(node_start, node_goal):\n            path_start = []\n            node = node_start\n            while node:\n                path_start.append(node.position)\n                node = node.parent\n            path_start.reverse()\n            path_goal = []\n            node = node_goal\n            while node:\n                path_goal.append(node.position)\n                node = node.parent\n            return path_start + path_goal\n\n        def shortcut_path(path, iterations=80):\n            if len(path) < 3:\n                return path[:]\n            import random\n            new_path = path[:]\n            for _ in range(iterations):\n                if len(new_path) < 3:\n                    break\n                i = random.randint(0, len(new_path) - 3)\n                j = random.randint(i + 2, len(new_path) - 1)\n                if not collision_edge(new_path[i], new_path[j]):\n                    new_path = new_path[:i + 1] + new_path[j:]\n            return new_path\n\n        # Initialization\n        tree_start = [Node(start_pos)]\n        tree_goal = [Node(goal_pos)]\n        edges = []\n        best_cost = math.inf\n        best_path = []\n\n        for iter in range(self.max_iter):\n            sample = None\n            # Goal biasing with chance to pick exact goal\n            if random.random() < self.goal_sample_rate:\n                sample = goal_pos\n            else:\n                sample = informed_sample(best_cost)\n\n            # Alternate tree: start_tree expands on even, goal_tree on odd\n            for tree_a, tree_b in [(tree_start, tree_goal), (tree_goal, tree_start)]:\n                nearest_node = nearest(tree_a, sample)\n                new_pos = steer(nearest_node.position, sample)\n\n                if not in_bounds(new_pos):\n                    continue\n                if collision_node(new_pos):\n                    continue\n                if collision_edge(nearest_node.position, new_pos):\n                    continue\n\n                near_nodes = near(tree_a, new_pos, self.neighbor_radius)\n\n                min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n                min_parent = nearest_node\n                for near_node in near_nodes:\n                    cost_through = near_node.cost + dist(near_node.position, new_pos)\n                    if cost_through < min_cost and not collision_edge(near_node.position, new_pos):\n                        min_cost = cost_through\n                        min_parent = near_node\n\n                new_node = Node(new_pos, min_parent, min_cost)\n                min_parent.add_child(new_node)\n                tree_a.append(new_node)\n                edges.append((min_parent, new_node))\n\n                rewire_lazy(tree_a, new_node, near_nodes)\n\n                nearest_other = nearest(tree_b, new_node.position)\n                dist_connect = dist(new_node.position, nearest_other.position)\n                if dist_connect <= self.step_size and not collision_edge(new_node.position, nearest_other.position):\n                    # Connection found; build path and update if better\n                    candidate_path = extract_path(new_node, nearest_other)\n                    cost_candidate = 0.0\n                    for k in range(len(candidate_path) - 1):\n                        cost_candidate += dist(candidate_path[k], candidate_path[k + 1])\n                    if cost_candidate < best_cost:\n                        best_cost = cost_candidate\n                        best_path = shortcut_path(candidate_path, iterations=120)\n                        return PlannerResult(True, best_path, tree_start + tree_goal, edges)\n        # If no early success, return best found\n        if best_path:\n            return PlannerResult(True, best_path, tree_start + tree_goal, edges)\n        return PlannerResult(False, [], tree_start + tree_goal, edges)",
                "objective": 21.77758,
                "time_improvement": -18.0,
                "length_improvement": 18.0,
                "smoothness_improvement": 1269.0,
                "node_improvement": 62.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 0.9,
                        "time_avg": 0.05129904747009277,
                        "num_nodes_avg": 202.0,
                        "path_length_avg": 163.44161697755194,
                        "smoothness_avg": 0.03924094037064722,
                        "success_improvement": -9.999999999999998,
                        "time_improvement": -98.90436285815973,
                        "node_improvement": 49.131201208763535,
                        "length_improvement": 10.415059836447577,
                        "smoothness_improvement": 514.2059298665263,
                        "objective_score": -70.85124330624673
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.04442298412322998,
                        "num_nodes_avg": 290.2,
                        "path_length_avg": 234.79142538469895,
                        "smoothness_avg": 0.09046310773776003,
                        "success_improvement": 0.0,
                        "time_improvement": 73.1705887672238,
                        "node_improvement": 80.50124302895921,
                        "length_improvement": 21.619864110120623,
                        "smoothness_improvement": 2227.6809200353655,
                        "objective_score": 46.06149969641634
                    },
                    {
                        "map_id": 2,
                        "success_rate": 0.9,
                        "time_avg": 0.06482896804809571,
                        "num_nodes_avg": 345.4,
                        "path_length_avg": 119.31466829628096,
                        "smoothness_avg": 0.09162844930897038,
                        "success_improvement": -9.999999999999998,
                        "time_improvement": -27.74890755939302,
                        "node_improvement": 56.08391608391609,
                        "length_improvement": 20.756878471570115,
                        "smoothness_improvement": 1065.5071119015024,
                        "objective_score": -40.54300962536833
                    }
                ],
                "success_rate": 0.9333333333333332
            }
        ],
        "offspring": {
            "operator": "m1",
            "algorithm_description": "A bidirectional RRT* variant with adaptive informed sampling, enhanced rewiring that updates descendant costs recursively for global improvements, and curvature-aware path shortcutting to improve smoothness and path length. The planner alternates expanding trees from start and goal, samples within an ellipsoidal informed region focusing search, connects nodes with minimum cost parents, and rewires incorporating full descendant cost updates to maintain path optimality. After finding a path, it applies iterative shortcutting with curvature constraints to ensure smooth transitions and feasible trajectories.",
            "planning_mechanism": "The planner alternates expansion of two trees from start and goal, uses adaptive ellipsoidal informed sampling to focus node sampling within a progressively shrinking region defined by current best path cost, and rewires nodes with recursive cost propagation for global cost updates. It attempts early connections between the trees when nodes are within step size and the connecting edge is collision-free. Upon finding a path, it applies iterative curvature-aware shortcutting that only shortens paths if curvature constraints are met, thus improving smoothness.",
            "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=5.0, neighbor_radius=15.0, goal_sample_rate=0.15, smooth_iter=150):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.neighbor_radius = neighbor_radius\n        self.goal_sample_rate = goal_sample_rate\n        self.smooth_iter = smooth_iter\n\n    def plan(self, map):\n        bounds = map.size\n        dim = len(bounds)\n        is_3d = dim == 3\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        import random\n        import math\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def in_bounds(p):\n            for i in range(dim):\n                if not (0 <= p[i] <= bounds[i]):\n                    return False\n            return True\n\n        def collision_node(p):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = p\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    px, py = p\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def collision_edge(a, b, resolution=0.3):\n            length = dist(a, b)\n            steps = max(2, int(length / resolution))\n            for i in range(steps + 1):\n                interp = tuple(a[d] + (b[d] - a[d]) * (i / steps) for d in range(dim))\n                if collision_node(interp):\n                    return True\n            return False\n\n        def steer(from_p, to_p):\n            length = dist(from_p, to_p)\n            if length <= self.step_size:\n                return to_p\n            ratio = self.step_size / length\n            return tuple(from_p[i] + (to_p[i] - from_p[i]) * ratio for i in range(dim))\n\n        def nearest(tree, point):\n            best_node = None\n            best_dist = math.inf\n            for node in tree:\n                d = dist(node.position, point)\n                if d < best_dist:\n                    best_node = node\n                    best_dist = d\n            return best_node\n\n        def near(tree, point, radius):\n            r2 = radius * radius\n            return [node for node in tree if sum((node.position[d] - point[d]) ** 2 for d in range(dim)) <= r2]\n\n        def path_to_go(p):\n            return dist(p, goal_pos)\n\n        def informed_sample(best_cost):\n            c_min = dist(start_pos, goal_pos)\n            if best_cost == math.inf or best_cost < c_min:\n                # Uniform random sample inside bounds with collision check\n                while True:\n                    s = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                    if not collision_node(s):\n                        return s\n            # Ellipsoidal informed sampling\n            c_best = best_cost\n            foci_dist = c_min\n            center = tuple((start_pos[i] + goal_pos[i]) * 0.5 for i in range(dim))\n            a = c_best / 2.0\n            val = c_best * c_best - foci_dist * foci_dist\n            if val < 1e-12:\n                b = 0.0\n            else:\n                b = math.sqrt(val) / 2.0\n\n            while True:\n                # sample in unit ball\n                while True:\n                    vec = [random.gauss(0, 1) for _ in range(dim)]\n                    norm = math.sqrt(sum(x * x for x in vec))\n                    if norm > 1e-7:\n                        break\n                unit = [x / norm for x in vec]\n                r = random.random() ** (1.0 / dim)\n                ball = [unit[i] * r for i in range(dim)]\n\n                sample_ellipsoid = [0.0] * dim\n                sample_ellipsoid[0] = ball[0] * a\n                for i in range(1, dim):\n                    sample_ellipsoid[i] = ball[i] * b\n\n                point = tuple(center[i] + sample_ellipsoid[i] for i in range(dim))\n                if in_bounds(point) and not collision_node(point):\n                    return point\n\n        def update_parent_cost_recursive(node):\n            for child in node.children:\n                new_cost = node.cost + dist(node.position, child.position)\n                if new_cost < child.cost:\n                    child.cost = new_cost\n                    child.parent = node\n                    update_parent_cost_recursive(child)\n\n        def update_parent_and_cost(child, new_parent, new_cost):\n            if child.parent:\n                child.parent.remove_child(child)\n            child.parent = new_parent\n            child.cost = new_cost\n            new_parent.add_child(child)\n            update_parent_cost_recursive(child)\n\n        def rewire_full(tree, new_node, near_nodes):\n            for near_n in near_nodes:\n                if near_n is new_node.parent:\n                    continue\n                c_through = new_node.cost + dist(new_node.position, near_n.position)\n                if c_through < near_n.cost:\n                    if not collision_edge(new_node.position, near_n.position):\n                        update_parent_and_cost(near_n, new_node, c_through)\n\n        def extract_path(node_start, node_goal):\n            path_start = []\n            n = node_start\n            while n:\n                path_start.append(n.position)\n                n = n.parent\n            path_start.reverse()\n            path_goal = []\n            n = node_goal\n            while n:\n                path_goal.append(n.position)\n                n = n.parent\n            return path_start + path_goal\n\n        def curvature(p1, p2, p3):\n            # Approximate curvature at p2 w.r.t neighbors p1 and p3\n            import math\n            a = math.dist(p1, p2)\n            b = math.dist(p2, p3)\n            c = math.dist(p1, p3)\n            if a < 1e-6 or b < 1e-6:\n                return 0.0\n            # Law of cosines to get angle at p2\n            try:\n                cos_angle = (a*a + b*b - c*c) / (2 * a * b)\n                cos_angle = min(1.0, max(-1.0, cos_angle))\n                angle = math.acos(cos_angle)\n                radius = c / (2 * math.sin(angle)) if abs(angle) > 1e-6 else float('inf')\n                curvature_val = 1.0 / radius if radius > 1e-6 else float('inf')\n                return curvature_val\n            except:\n                return 0.0\n\n        def curvature_aware_shortcut(path, max_curvature=0.15, iterations=None):\n            if len(path) < 3:\n                return path[:]\n            import random\n            new_path = path[:]\n            iters = iterations if iterations is not None else self.smooth_iter\n            for _ in range(iters):\n                if len(new_path) < 3:\n                    break\n                i = random.randint(0, len(new_path) - 3)\n                j = random.randint(i + 2, len(new_path) - 1)\n                if collision_edge(new_path[i], new_path[j]):\n                    continue\n                # Check curvature if shortcut applied: Inspect neighbors around shortcut\n                before = new_path[max(i-1, 0)]\n                after = new_path[min(j+1, len(new_path)-1)]\n                # For indices i-1, i, j and i, j, j+1 triplets for curvature check\n                # First triplet:\n                curv1 = curvature(before, new_path[i], new_path[j]) if i > 0 else 0.0\n                # Second triplet:\n                curv2 = curvature(new_path[i], new_path[j], after) if j < len(new_path)-1 else 0.0\n                if curv1 <= max_curvature and curv2 <= max_curvature:\n                    new_path = new_path[:i+1] + new_path[j:]\n            return new_path\n\n        tree_start = [Node(start_pos)]\n        tree_goal = [Node(goal_pos)]\n        edges = []\n        best_cost = math.inf\n        best_path = []\n\n        for iter in range(self.max_iter):\n            if random.random() < self.goal_sample_rate:\n                sample = goal_pos\n            else:\n                sample = informed_sample(best_cost)\n\n            for tree_a, tree_b in [(tree_start, tree_goal), (tree_goal, tree_start)]:\n                nearest_node = nearest(tree_a, sample)\n                new_pos = steer(nearest_node.position, sample)\n                if not in_bounds(new_pos):\n                    continue\n                if collision_node(new_pos):\n                    continue\n                if collision_edge(nearest_node.position, new_pos):\n                    continue\n\n                near_nodes = near(tree_a, new_pos, self.neighbor_radius)\n                min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n                min_parent = nearest_node\n                for near_node in near_nodes:\n                    candidate_cost = near_node.cost + dist(near_node.position, new_pos)\n                    if candidate_cost < min_cost and not collision_edge(near_node.position, new_pos):\n                        min_cost = candidate_cost\n                        min_parent = near_node\n\n                new_node = Node(new_pos, min_parent, min_cost)\n                min_parent.add_child(new_node)\n                tree_a.append(new_node)\n                edges.append((min_parent, new_node))\n\n                rewire_full(tree_a, new_node, near_nodes)\n\n                nearest_other = nearest(tree_b, new_node.position)\n                if dist(new_node.position, nearest_other.position) <= self.step_size and not collision_edge(new_node.position, nearest_other.position):\n                    candidate_path = extract_path(new_node, nearest_other)\n                    cost_candidate = 0.0\n                    for k in range(len(candidate_path) - 1):\n                        cost_candidate += dist(candidate_path[k], candidate_path[k + 1])\n                    if cost_candidate < best_cost:\n                        best_cost = cost_candidate\n                        # Apply curvature-aware smoothing with more iterations after connection\n                        best_path = curvature_aware_shortcut(candidate_path, iterations=self.smooth_iter)\n                        # Early return for best found path\n                        return PlannerResult(True, best_path, tree_start + tree_goal, edges)\n\n        if best_path:\n            return PlannerResult(True, best_path, tree_start + tree_goal, edges)\n        return PlannerResult(False, [], tree_start + tree_goal, edges)",
            "objective": -5.73861,
            "time_improvement": -36.0,
            "length_improvement": 17.0,
            "smoothness_improvement": 1263.0,
            "node_improvement": 65.0,
            "other_inf": [
                {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.05177156925201416,
                    "num_nodes_avg": 143.9,
                    "path_length_avg": 165.93075816926788,
                    "smoothness_avg": 0.041603726714277645,
                    "success_improvement": 0.0,
                    "time_improvement": -100.73649519988538,
                    "node_improvement": 63.76227650465878,
                    "length_improvement": 9.050722106301821,
                    "smoothness_improvement": 551.1886670170101,
                    "objective_score": -22.03457196109947
                },
                {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.06509325504302979,
                    "num_nodes_avg": 331.0,
                    "path_length_avg": 233.69307486837343,
                    "smoothness_avg": 0.08407213264203503,
                    "success_improvement": 0.0,
                    "time_improvement": 60.68670886258219,
                    "node_improvement": 77.75986024323053,
                    "length_improvement": 21.986525126736794,
                    "smoothness_improvement": 2063.2365275890634,
                    "objective_score": 41.71411037276205
                },
                {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.08536667823791504,
                    "num_nodes_avg": 355.9,
                    "path_length_avg": 120.11866214506578,
                    "smoothness_avg": 0.1001327204763105,
                    "success_improvement": 0.0,
                    "time_improvement": -68.21955084611585,
                    "node_improvement": 54.7488874761602,
                    "length_improvement": 20.2229040392802,
                    "smoothness_improvement": 1173.6808134300672,
                    "objective_score": -2.4637187631162982
                }
            ],
            "success_rate": 1.0
        },
        "objective": 760.1999999999999,
        "analysis": {
            "problem": [
                "Problem of the parents algorithm:\n   - Inefficient rewiring that does not recursively update descendant nodes, leading to suboptimal path cost propagation and less optimal solutions.\n   - Limited goal biasing and fixed sampling parameters, resulting in slower convergence and less focused exploration.\n   - Post-processing shortcut smoothing without curvature consideration, possibly generating paths with abrupt turns and lower smoothness."
            ],
            "solution": "1. Primary contributors to the performance improvement:\n   - Recursive descendant cost updates during rewiring enabling more global path cost optimization.\n   - Increased goal bias rate and slightly larger step and neighbor radius enhancing exploration efficiency and faster path convergence.\n   - Curvature-aware shortcut smoothing applied in post-processing to produce smoother, more feasible trajectories.\n\n2. Expected mechanism of impact:\n   - Recursive rewiring ensures consistent cost updates along the tree, leading to improved path optimality and possibly shorter path lengths.\n   - Enhanced sampling and connection parameters increase the chance of quickly finding better connections, reducing planning time and improving path quality.\n   - Incorporating curvature constraints in smoothing avoids sharp turns, increasing path smoothness and making paths more realistic for practical applications."
        }
    },
    {
        "parents": [
            {
                "operator": "initial",
                "algorithm_description": "This algorithm is an optimal variant of RRT that improves path quality over time by rewiring the tree to minimize path cost. It incrementally builds a space-filling tree from start toward the goal while performing local optimizations by choosing better parents and rewiring nearby nodes.",
                "planning_mechanism": "The planner samples a point, extends the nearest node toward it, finds nearby nodes within a radius, selects the node offering the lowest-cost path as the parent, and rewires suboptimal neighbors to the new node if a shorter path through it is possible and valid.",
                "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.children.remove(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 3.0, goal_sample_rate: float = 0.05, neighbor_radius: float = 10.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n\n    def plan(self, map) -> PlannerResult:\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        root = Node(start_position)\n        nodes.append(root)\n\n        for _ in range(self.max_iter):\n            # Goal biasing\n            if random.random() < self.goal_sample_rate:\n                sample = goal_position\n            else:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n\n            # Nearest node\n            nearest_node = min(nodes, key=lambda n: math.dist(n.position, sample))\n            direction = tuple(sample[d] - nearest_node.position[d] for d in range(len(bounds)))\n            dist_to_sample = math.dist(nearest_node.position, sample)\n            if dist_to_sample == 0:\n                continue\n            unit = tuple(d / dist_to_sample for d in direction)\n            new_position = tuple(nearest_node.position[d] + unit[d] * min(self.step_size, dist_to_sample) for d in range(len(bounds)))\n\n            if self._is_in_obstacle(new_position, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_position, obstacles, is_3d):\n                continue\n\n            # Nearby nodes for choosing best parent\n            new_node = Node(new_position)\n            near_nodes = [n for n in nodes if math.dist(n.position, new_position) <= self.neighbor_radius]\n\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_position)\n            best_parent = nearest_node\n\n            for near_node in near_nodes:\n                temp_cost = near_node.cost + math.dist(near_node.position, new_position)\n                if temp_cost < min_cost and not self._is_edge_in_obstacle(near_node.position, new_position, obstacles, is_3d):\n                    min_cost = temp_cost\n                    best_parent = near_node\n\n            new_node.update_parent(best_parent, min_cost)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewiring\n            for near_node in near_nodes:\n                if near_node == best_parent:\n                    continue\n                cost_through_new = new_node.cost + math.dist(near_node.position, new_position)\n                if cost_through_new < near_node.cost and not self._is_edge_in_obstacle(new_position, near_node.position, obstacles, is_3d):\n                    edges.remove((near_node.parent, near_node))\n                    near_node.update_parent(new_node, cost_through_new)\n                    edges.append((new_node, near_node))\n\n            # Check goal connection\n            if math.dist(new_position, goal_position) <= self.step_size:\n                if not self._is_edge_in_obstacle(new_position, goal_position, obstacles, is_3d) and not self._is_in_obstacle(goal_position, obstacles, is_3d):\n                    goal_node = Node(goal_position)\n                    goal_cost = new_node.cost + math.dist(new_position, goal_position)\n                    goal_node.update_parent(new_node, goal_cost)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    success_state = True\n                    break\n\n        if success_state:\n            path = []\n            node = nodes[-1]\n            while node:\n                path.append(node.position)\n                node = node.parent\n            extracted_path = path[::-1]\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n    ",
                "objective": 61.63121923444826,
                "time_improvement": -248.0,
                "length_improvement": 20.0,
                "smoothness_improvement": 156.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.047614216804504395,
                        "num_nodes_avg": 367.4,
                        "path_length_avg": 156.97575072701764,
                        "smoothness_avg": 0.014377694677398786,
                        "success_improvement": 0.0,
                        "time_improvement": -84.616984594336,
                        "node_improvement": 7.479224376731312,
                        "length_improvement": 13.959103586572772,
                        "smoothness_improvement": 125.04214336500303,
                        "objective_score": -16.384422509532122
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.685749626159668,
                        "num_nodes_avg": 1656.6,
                        "path_length_avg": 226.92574635006446,
                        "smoothness_avg": 0.010969967745561136,
                        "success_improvement": 0.0,
                        "time_improvement": -314.1608018030315,
                        "node_improvement": -11.308203991130817,
                        "length_improvement": 24.245654172899485,
                        "smoothness_improvement": 182.26517144168025,
                        "objective_score": -78.78952217996137
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.22639145851135253,
                        "num_nodes_avg": 780.9,
                        "path_length_avg": 117.18066902366226,
                        "smoothness_avg": 0.020608286494296014,
                        "success_improvement": 0.0,
                        "time_improvement": -346.11633312050645,
                        "node_improvement": 0.7120152574698059,
                        "length_improvement": 22.174179178317964,
                        "smoothness_improvement": 162.13588306196758,
                        "objective_score": -89.71971301385132
                    }
                ],
                "success_rate": 1.0
            },
            {
                "operator": "e1",
                "algorithm_description": "A bidirectional informed RRT* with adaptive sampling and post-processing path shortcutting. The algorithm grows two trees from start and goal, but restricts sampling within an ellipsoidal region (informed sampling) to focus search around the best solution path. It performs rewiring to optimize local connections and applies an efficient post-processing shortcutting procedure to smooth the final path, which improves path quality and smoothness while reducing planning time.",
                "planning_mechanism": "The planner alternates expanding two trees by sampling random points within an informed ellipsoidal subset after an initial solution is found. It performs steer, collision checks, rewiring, and attempts to connect the trees continuously. Upon success, it extracts the path and applies post-processing shortcutting to remove unnecessary waypoints and smooth sharp turns, leading to a shorter, smoother trajectory with improved efficiency.",
                "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n    def add_child(self, child):\n        self.children.append(child)\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=7.0, radius=15.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.radius = radius\n\n    def plan(self, map):\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = (len(bounds) == 3)\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = []\n        edges = []\n\n        best_path_cost = float('inf')\n        solution_node_start = None\n        solution_node_goal = None\n\n        # Basic heuristic distance for informed sampling\n        c_min = self._distance(start_pos, goal_pos)\n\n        for i in range(self.max_iter):\n            if solution_node_start and solution_node_goal:\n                # Informed sampling inside ellipsoid bounding current best path cost\n                sample = self._informed_sample(bounds, obstacles, is_3d, start_pos, goal_pos, best_path_cost, c_min)\n            else:\n                # Uniform random sampling within bounds free space\n                sample = self._sample_free(bounds, obstacles, is_3d)\n\n            for tree_a, tree_b in [(start_tree,goal_tree),(goal_tree,start_tree)]:\n                nearest = self._nearest(tree_a, sample)\n                new_pos = self._steer(nearest.position, sample, self.step_size)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d): continue\n                if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d): continue\n\n                new_node = Node(new_pos)\n                near_nodes = self._near(tree_a, new_pos, self.radius)\n\n                # Choose best parent among near nodes considering path cost and collision\n                min_cost = nearest.cost + self._distance(nearest.position, new_pos)\n                min_parent = nearest\n                for near in near_nodes:\n                    tent_cost = near.cost + self._distance(near.position, new_pos)\n                    if tent_cost < min_cost and not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d):\n                        min_cost = tent_cost\n                        min_parent = near\n\n                new_node.parent = min_parent\n                new_node.cost = min_cost\n                min_parent.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((min_parent, new_node))\n\n                # Rewire neighbors if new node offers a better path\n                for near in near_nodes:\n                    if near == min_parent: continue\n                    new_cost = new_node.cost + self._distance(new_node.position, near.position)\n                    if new_cost < near.cost and not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                        if near.parent:\n                            try: edges.remove((near.parent, near))\n                            except ValueError: pass\n                        near.parent = new_node\n                        near.cost = new_cost\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n\n                # Try to connect to tree_b within step size and collision free\n                connect_node = self._nearest(tree_b, new_node.position)\n                if self._distance(new_node.position, connect_node.position) <= self.step_size:\n                    if not self._is_edge_in_obstacle(new_node.position, connect_node.position, obstacles, is_3d):\n                        # Construct candidate path cost\n                        path_cost = new_node.cost + self._distance(new_node.position, connect_node.position) + connect_node.cost\n                        if path_cost < best_path_cost:\n                            best_path_cost = path_cost\n                            solution_node_start, solution_node_goal = (new_node, connect_node) if tree_a is start_tree else (connect_node, new_node)\n                        # We can continue to iterate to improve path\n\n            if best_path_cost < float('inf') and (i % 100 == 0 or i == self.max_iter -1):\n                # Extract and shortcut path every 100 iterations or at end for smoother solution\n                raw_path = self._extract_path(solution_node_start, solution_node_goal)\n                shortcut_path = self._shortcut_path(raw_path, obstacles, is_3d)\n                if shortcut_path:\n                    return PlannerResult(True, shortcut_path, start_tree + goal_tree, edges)\n\n        # No solution found; return empty path\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        while True:\n            pt = tuple(random.uniform(0, bounds[i]) for i in range(3 if is_3d else 2))\n            if not self._is_in_obstacle(pt, obstacles, is_3d): return pt\n\n    def _informed_sample(self, bounds, obstacles, is_3d, start, goal, c_max, c_min):\n        # Sample inside prolate hyperspheroid (ellipsoid) defined by start, goal, and current best cost c_max\n        # Reduces sampling space to focus search near optimal path\n        dim = 3 if is_3d else 2\n        while True:\n            # Sample unit ball point\n            if dim == 2:\n                r = random.uniform(0,1) ** 0.5\n                theta = random.uniform(0, 2*math.pi)\n                x_ball = [r * math.cos(theta), r * math.sin(theta)]\n            else:\n                # Sample from 3D ball\n                while True:\n                    x_ball = [random.uniform(-1,1), random.uniform(-1,1), random.uniform(-1,1)]\n                    if sum([xi*xi for xi in x_ball]) <= 1: break\n            # Calculate transformation parameters\n            c = c_max\n            if c == float('inf') or c <= c_min:\n                # No current solution, uniform sample\n                pt = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not self._is_in_obstacle(pt, obstacles, is_3d): return pt\n\n            center = tuple((start[i] + goal[i]) / 2 for i in range(dim))\n            dir_vec = [goal[i] - start[i] for i in range(dim)]\n            length = math.dist(start, goal)\n            # Compute rotation matrix from canonical axis to direction vector\n            if dim == 2:\n                if length == 0:\n                    R = [[1,0],[0,1]]\n                else:\n                    a1 = [1,0]\n                    a2 = [dir_vec[0]/length, dir_vec[1]/length]\n                    cos_theta = a1[0]*a2[0] + a1[1]*a2[1]\n                    sin_theta = a1[0]*a2[1] - a1[1]*a2[0]\n                    R = [[cos_theta, -sin_theta],[sin_theta, cos_theta]]\n            else:\n                # 3D rotation using axis-angle (rotation matrix)\n                from math import acos, sqrt\n                if length == 0:\n                    R = [[1,0,0],[0,1,0],[0,0,1]]\n                else:\n                    a1 = [1,0,0]\n                    a2 = [dir_vec[i]/length for i in range(3)]\n                    v = [a1[1]*a2[2]-a1[2]*a2[1], a1[2]*a2[0]-a1[0]*a2[2], a1[0]*a2[1]-a1[1]*a2[0]]\n                    s = sqrt(sum([vi*vi for vi in v]))\n                    c = sum([a1[i]*a2[i] for i in range(3)])\n                    if s == 0:\n                        R = [[1,0,0],[0,1,0],[0,0,1]]\n                    else:\n                        vx = [[0,-v[2],v[1]],[v[2],0,-v[0]],[-v[1],v[0],0]]\n                        I = [[1 if i==j else 0 for j in range(3)] for i in range(3)]\n                        vx2 = [[vx[0][0]*vx[0][0]+vx[0][1]*vx[1][0]+vx[0][2]*vx[2][0],\n                                vx[0][0]*vx[0][1]+vx[0][1]*vx[1][1]+vx[0][2]*vx[2][1],\n                                vx[0][0]*vx[0][2]+vx[0][1]*vx[1][2]+vx[0][2]*vx[2][2]],\n                               [vx[1][0]*vx[0][0]+vx[1][1]*vx[1][0]+vx[1][2]*vx[2][0],\n                                vx[1][0]*vx[0][1]+vx[1][1]*vx[1][1]+vx[1][2]*vx[2][1],\n                                vx[1][0]*vx[0][2]+vx[1][1]*vx[1][2]+vx[1][2]*vx[2][2]],\n                               [vx[2][0]*vx[0][0]+vx[2][1]*vx[1][0]+vx[2][2]*vx[2][0],\n                                vx[2][0]*vx[0][1]+vx[2][1]*vx[1][1]+vx[2][2]*vx[2][1],\n                                vx[2][0]*vx[0][2]+vx[2][1]*vx[1][2]+vx[2][2]*vx[2][2]]]\n                        R = [[I[i][j] + vx[i][j] + ((vx2[i][j]) * ((1 - c)/(s**2))) for j in range(3)] for i in range(3)]\n            # Compose scaling matrix\n            a1_val = c_max / 2.0\n            a_others = math.sqrt(c_max**2 - c_min**2) / 2.0\n            if dim == 2:\n                L = [[a1_val,0],[0,a_others]]\n                # Transform sample from unit ball: pos = R * L * x_ball + center\n                x_scaled = [L[0][0]*x_ball[0] + L[0][1]*x_ball[1], L[1][0]*x_ball[0] + L[1][1]*x_ball[1]]\n                pt = (center[0] + R[0][0]*x_scaled[0] + R[0][1]*x_scaled[1],\n                      center[1] + R[1][0]*x_scaled[0] + R[1][1]*x_scaled[1])\n            else:\n                L = [[a1_val,0,0],[0,a_others,0],[0,0,a_others]]\n                x_scaled = [L[0][0]*x_ball[0], L[1][1]*x_ball[1], L[2][2]*x_ball[2]]\n                pt = tuple(center[i] + sum(R[i][j]*x_scaled[j] for j in range(3)) for i in range(3))\n\n            # Reject points outside bounds or in obstacle\n            if any(pt[d] < 0 or pt[d] > bounds[d] for d in range(dim)):\n                continue\n            if self._is_in_obstacle(pt, obstacles, is_3d):\n                continue\n            return pt\n\n    def _nearest(self, tree, point):\n        return min(tree, key=lambda n: self._distance(n.position, point))\n\n    def _near(self, tree, point, radius):\n        radius_sq = radius * radius\n        return [node for node in tree if self._squared_distance(node.position, point) <= radius_sq]\n\n    def _steer(self, from_pos, to_pos, step_size):\n        dist = self._distance(from_pos, to_pos)\n        if dist <= step_size:\n            return to_pos\n        ratio = step_size / dist\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n    def _extract_path(self, node_start, node_goal):\n        path_start, path_goal = [], []\n        n = node_start\n        while n:\n            path_start.append(n.position)\n            n = n.parent\n        n = node_goal\n        while n:\n            path_goal.append(n.position)\n            n = n.parent\n        return list(reversed(path_start)) + path_goal\n\n    def _shortcut_path(self, path, obstacles, is_3d):\n        # Attempt to shortcut path by skipping intermediate nodes where direct edge collision free\n        if len(path) < 3:\n            return path[:]\n        shortcut_path = [path[0]]\n        i = 0\n        while i < len(path)-1:\n            j = len(path)-1\n            while j > i+1:\n                if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                    break\n                j -= 1\n            shortcut_path.append(path[j])\n            i = j\n        return shortcut_path\n\n    def _distance(self, a, b):\n        return math.dist(a, b)\n\n    def _squared_distance(self, a, b):\n        return sum((a[i] - b[i])**2 for i in range(len(a)))\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x,y,z,w,h,d = obs\n                px,py,pz = pos\n                if x<=px<=x+w and y<=py<=y+h and z<=pz<=z+d:\n                    return True\n            else:\n                x,y,w,h = obs\n                px,py = pos\n                if x<=px<=x+w and y<=py<=y+h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        dist = self._distance(from_pos, to_pos)\n        steps = max(1, int(dist/resolution))\n        for i in range(steps+1):\n            interp = tuple(from_pos[d] + (to_pos[d]-from_pos[d])*(i/steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
                "objective": -23.21547,
                "time_improvement": 21.0,
                "length_improvement": 16.0,
                "smoothness_improvement": 1469.0,
                "node_improvement": 68.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.025556087493896484,
                        "num_nodes_avg": 151.3,
                        "path_length_avg": 173.88763401105183,
                        "smoothness_avg": 0.047474639256938476,
                        "success_improvement": 0.0,
                        "time_improvement": 0.9101035826373128,
                        "node_improvement": 61.89876605389071,
                        "length_improvement": 4.689432372653788,
                        "smoothness_improvement": 643.0811972002915,
                        "objective_score": 6.302096484384924
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.031405282020568845,
                        "num_nodes_avg": 252.2,
                        "path_length_avg": 230.86304004149935,
                        "smoothness_avg": 0.09581397875517297,
                        "success_improvement": 0.0,
                        "time_improvement": 81.03267389975849,
                        "node_improvement": 83.05449170194181,
                        "length_improvement": 22.93127220998329,
                        "smoothness_improvement": 2365.362685390011,
                        "objective_score": 49.89537892286758
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.06047847270965576,
                        "num_nodes_avg": 317.2,
                        "path_length_avg": 119.93973012619429,
                        "smoothness_avg": 0.11787316210161418,
                        "success_improvement": 0.0,
                        "time_improvement": -19.176026584091733,
                        "node_improvement": 59.6694214876033,
                        "length_improvement": 20.341742166387515,
                        "smoothness_improvement": 1399.337921440741,
                        "objective_score": 13.448926931808694
                    }
                ],
                "success_rate": 1.0
            }
        ],
        "offspring": {
            "operator": "m3",
            "algorithm_description": "An efficient bidirectional RRT* with adaptive informed sampling and incremental path shortcutting, focusing sampling within an ellipsoidal subset around the best path to accelerate convergence, combined with local rewiring for path optimization and progressive shortcutting to improve path smoothness and length while reducing planning time. The planner grows two trees from start and goal, alternately expanding toward sampled points focused by current best solution, connects the two trees when possible, rewires locally to optimize costs, and progressively shortcuts the path during planning for smoother results.",
            "planning_mechanism": "The planner alternates growth of two trees (start and goal) using adaptive informed sampling within an ellipsoidal subset defined by the current best path cost. At each iteration, a sample point is generated; nearest nodes are extended toward it with collision checking. The algorithm rewires nearby nodes to optimize path costs locally. Upon connecting both trees, it extracts the combined path and incrementally applies shortcutting to remove unnecessary waypoints and smooth the trajectory. This approach balances efficient exploration, path quality, and runtime performance.",
            "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n    def add_child(self, child):\n        self.children.append(child)\nclass Planner:\n    def __init__(self, max_iter=4000, step_size=6.0, radius=12.0, shortcut_interval=50):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.radius = radius\n        self.shortcut_interval = shortcut_interval\n\n    def plan(self, map):\n        import random\n        import math\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = (len(bounds) == 3)\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        best_cost = float('inf')\n        solution_start, solution_goal = None, None\n\n        c_min = math.dist(start_pos, goal_pos)\n        dim = 3 if is_3d else 2\n\n        for i in range(self.max_iter):\n            # Adaptive Sample\n            if best_cost < float('inf'):\n                sample = self._informed_sample(bounds, obstacles, is_3d, start_pos, goal_pos, best_cost, c_min)\n            else:\n                sample = self._sample_free(bounds, obstacles, is_3d)\n\n            # Alternate tree expansion\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest = self._nearest(tree_a, sample)\n                new_pos = self._steer(nearest.position, sample, self.step_size)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                    continue\n\n                new_node = Node(new_pos)\n                near_nodes = self._near(tree_a, new_pos, self.radius)\n\n                min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n                min_parent = nearest\n                for near in near_nodes:\n                    tentative_cost = near.cost + math.dist(near.position, new_pos)\n                    if tentative_cost < min_cost and not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d):\n                        min_cost = tentative_cost\n                        min_parent = near\n\n                new_node.parent = min_parent\n                new_node.cost = min_cost\n                min_parent.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((min_parent, new_node))\n\n                # Rewire near nodes to new_node if beneficial\n                for near in near_nodes:\n                    if near is min_parent:\n                        continue\n                    new_cost = new_node.cost + math.dist(new_node.position, near.position)\n                    if new_cost < near.cost and not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                        if near.parent:\n                            try: edges.remove((near.parent, near))\n                            except ValueError: pass\n                            # Remove near from old parent's children list safely\n                            try: near.parent.children.remove(near)\n                            except ValueError: pass\n                        near.parent = new_node\n                        near.cost = new_cost\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n\n                # Try to connect both trees to form path\n                connect_node = self._nearest(tree_b, new_node.position)\n                dist_connect = math.dist(new_node.position, connect_node.position)\n                if dist_connect <= self.step_size:\n                    if not self._is_edge_in_obstacle(new_node.position, connect_node.position, obstacles, is_3d):\n                        path_cost = new_node.cost + dist_connect + connect_node.cost\n                        if path_cost < best_cost:\n                            best_cost = path_cost\n                            if tree_a is start_tree:\n                                solution_start, solution_goal = new_node, connect_node\n                            else:\n                                solution_start, solution_goal = connect_node, new_node\n\n            # Progressive shortcutting for smoother path every shortcut_interval iterations\n            if best_cost < float('inf') and solution_start and solution_goal and (i % self.shortcut_interval == 0 or i == self.max_iter-1):\n                raw_path = self._extract_path(solution_start, solution_goal)\n                shortcut_path = self._shortcut_path(raw_path, obstacles, is_3d, max_attempts=50)\n                if shortcut_path:\n                    return PlannerResult(True, shortcut_path, nodes, edges)\n\n        # No solution found\n        return PlannerResult(False, [], nodes, edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        import random\n        while True:\n            pt = tuple(random.uniform(0, bounds[i]) for i in range(len(bounds)))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def _informed_sample(self, bounds, obstacles, is_3d, start, goal, c_max, c_min):\n        import random\n        import math\n        dim = 3 if is_3d else 2\n\n        # Reject sample if no valid ellipsoid (e.g. c_max <= c_min)\n        if c_max <= c_min:\n            return self._sample_free(bounds, obstacles, is_3d)\n\n        center = tuple((start[i]+goal[i])/2 for i in range(dim))\n        dir_vec = [goal[i]-start[i] for i in range(dim)]\n        length = math.dist(start, goal)\n        if length == 0:\n            # No interval, uniform sample fallback\n            return self._sample_free(bounds, obstacles, is_3d)\n\n        # Compute rotation matrix R from canonical axis to direction vector\n        if dim == 2:\n            a1 = [1,0]\n            a2 = [dir_vec[0]/length, dir_vec[1]/length]\n            cos_theta = a1[0]*a2[0] + a1[1]*a2[1]\n            sin_theta = a1[0]*a2[1] - a1[1]*a2[0]\n            R = [[cos_theta, -sin_theta],[sin_theta, cos_theta]]\n        else:\n            from math import sqrt\n            a1 = [1,0,0]\n            a2 = [dir_vec[i]/length for i in range(3)]\n            v = [a1[1]*a2[2]-a1[2]*a2[1], a1[2]*a2[0]-a1[0]*a2[2], a1[0]*a2[1]-a1[1]*a2[0]]\n            s = sqrt(sum([vi*vi for vi in v]))\n            c = sum([a1[i]*a2[i] for i in range(3)])\n            if s == 0:\n                R = [[1,0,0],[0,1,0],[0,0,1]]\n            else:\n                vx = [[0,-v[2],v[1]],[v[2],0,-v[0]],[-v[1],v[0],0]]\n                I = [[1 if i==j else 0 for j in range(3)] for i in range(3)]\n                vx2 = [[sum(vx[i][k]*vx[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n                R = [[I[i][j] + vx[i][j] + vx2[i][j]*((1 - c)/(s**2)) for j in range(3)] for i in range(3)]\n\n        # Sample point inside unit ball\n        if dim == 2:\n            r = random.uniform(0,1)**0.5\n            theta = random.uniform(0, 2*math.pi)\n            x_ball = [r*math.cos(theta), r*math.sin(theta)]\n        else:\n            while True:\n                x_ball = [random.uniform(-1,1) for _ in range(3)]\n                if sum(xi*xi for xi in x_ball) <= 1:\n                    break\n\n        a1_val = c_max / 2.0\n        a_other = math.sqrt(c_max**2 - c_min**2) / 2.0\n\n        # Scaling matrix\n        if dim == 2:\n            L = [[a1_val, 0],[0, a_other]]\n            x_scaled = [L[0][0]*x_ball[0] + L[0][1]*x_ball[1],\n                        L[1][0]*x_ball[0] + L[1][1]*x_ball[1]]\n            pt = (center[0] + R[0][0]*x_scaled[0] + R[0][1]*x_scaled[1],\n                  center[1] + R[1][0]*x_scaled[0] + R[1][1]*x_scaled[1])\n        else:\n            L = [[a1_val, 0, 0],[0, a_other, 0],[0, 0, a_other]]\n            x_scaled = [L[0][0]*x_ball[0], L[1][1]*x_ball[1], L[2][2]*x_ball[2]]\n            pt = tuple(center[i] + sum(R[i][j]*x_scaled[j] for j in range(3)) for i in range(3))\n\n        # Reject if outside bounds or in obstacle\n        if any(pt[d] < 0 or pt[d] > bounds[d] for d in range(dim)):\n            return self._sample_free(bounds, obstacles, is_3d)\n        if self._is_in_obstacle(pt, obstacles, is_3d):\n            return self._sample_free(bounds, obstacles, is_3d)\n\n        return pt\n\n    def _nearest(self, tree, point):\n        import math\n        return min(tree, key=lambda n: math.dist(n.position, point))\n\n    def _near(self, tree, point, radius):\n        r_sq = radius*radius\n        return [n for n in tree if sum((n.position[i]-point[i])**2 for i in range(len(point))) <= r_sq]\n\n    def _steer(self, from_pos, to_pos, step_size):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        if dist <= step_size:\n            return to_pos\n        ratio = step_size / dist\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i])*ratio for i in range(len(from_pos)))\n\n    def _extract_path(self, node_start, node_goal):\n        path_start, path_goal = [], []\n        n = node_start\n        while n:\n            path_start.append(n.position)\n            n = n.parent\n        n = node_goal\n        while n:\n            path_goal.append(n.position)\n            n = n.parent\n        return list(reversed(path_start)) + path_goal\n\n    def _shortcut_path(self, path, obstacles, is_3d, max_attempts=30):\n        # Attempt bounded shortcutting to improve smoothness by removing redundant waypoints\n        if len(path) < 3:\n            return path[:]\n        import random\n        new_path = path[:]\n        attempts = 0\n        while attempts < max_attempts:\n            if len(new_path) < 3:\n                break\n            i = random.randint(0, len(new_path)-3)\n            j = random.randint(i+2, len(new_path)-1)\n            if not self._is_edge_in_obstacle(new_path[i], new_path[j], obstacles, is_3d):\n                # Remove intermediate nodes between i and j\n                new_path = new_path[:i+1] + new_path[j:]\n                attempts = 0  # reset attempts after successful shortcut\n            else:\n                attempts += 1\n        return new_path\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x,y,z,w,h,d=obs\n                px,py,pz=pos\n                if x<=px<=x+w and y<=py<=y+h and z<=pz<=z+d:\n                    return True\n            else:\n                x,y,w,h=obs\n                px,py=pos\n                if x<=px<=x+w and y<=py<=y+h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist/resolution))\n        for i in range(steps+1):\n            interp = tuple(from_pos[d] + (to_pos[d]-from_pos[d])*(i/steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
            "objective": -30.55144,
            "time_improvement": 46.0,
            "length_improvement": 18.0,
            "smoothness_improvement": 1254.0,
            "node_improvement": 72.0,
            "other_inf": [
                {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.019833183288574217,
                    "num_nodes_avg": 147.4,
                    "path_length_avg": 162.65169192869433,
                    "smoothness_avg": 0.04547432196696187,
                    "success_improvement": 0.0,
                    "time_improvement": 23.09980633143671,
                    "node_improvement": 62.880886426592795,
                    "length_improvement": 10.848030272889844,
                    "smoothness_improvement": 611.7718878536382,
                    "objective_score": 16.49761950243311
                },
                {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.023508524894714354,
                    "num_nodes_avg": 236.2,
                    "path_length_avg": 226.91038346862007,
                    "smoothness_avg": 0.07885871014571852,
                    "success_improvement": 0.0,
                    "time_improvement": 85.80194702529162,
                    "node_improvement": 84.12954377477658,
                    "length_improvement": 24.250782744921644,
                    "smoothness_improvement": 1929.091411682397,
                    "objective_score": 49.936510812952456
                },
                {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.036681842803955075,
                    "num_nodes_avg": 255.1,
                    "path_length_avg": 123.45751291252664,
                    "smoothness_avg": 0.10380569995332274,
                    "success_improvement": 0.0,
                    "time_improvement": 27.71649022711396,
                    "node_improvement": 67.56516211061665,
                    "length_improvement": 18.005398338521033,
                    "smoothness_improvement": 1220.4008412665191,
                    "objective_score": 25.220190277579402
                }
            ],
            "success_rate": 1.0
        },
        "objective": 838.4,
        "analysis": {
            "problem": [
                "Problem of the parents algorithm:\n   - Inefficient or uniform spatial sampling leading to slower convergence and longer planning times.\n   - Sparse or infrequent path shortcutting reducing path smoothness and leading to jagged trajectories.\n   - Computational overhead due to exhaustive nearest neighbor searches and limited data structure optimizations.\n   - Rewiring and tree connection attempts lack adaptive guidance resulting in suboptimal path refinement."
            ],
            "solution": "1. Primary contributors to the performance improvement:\n   - Use of adaptive informed sampling focusing exploration within an ellipsoidal subset near the current best path.\n   - Implementation of progressive and frequent path shortcutting applied during planning iterations.\n   - Balanced bidirectional tree expansion with local rewiring that improves path connectivity and cost.\n   - Incorporation of bounded shortcutting attempts offering controlled smoothing without excessive computation.\n2. Expected mechanism of impact:\n   - Adaptive sampling reduces exploration in irrelevant areas, accelerating convergence and improving planning time.\n   - Incremental shortcutting removes unnecessary waypoints earlier, significantly enhancing path smoothness and shortening path length.\n   - Efficient rewiring maintains low-cost connections enhancing global path optimality.\n   - Controlled shortcutting iterations provide smooth paths while keeping computational cost manageable, leading to balanced improvements in time, length, and smoothness."
        }
    },
    {
        "parents": [
            {
                "operator": "e1",
                "algorithm_description": "A bidirectional informed RRT* with adaptive sampling and post-processing path shortcutting. The algorithm grows two trees from start and goal, but restricts sampling within an ellipsoidal region (informed sampling) to focus search around the best solution path. It performs rewiring to optimize local connections and applies an efficient post-processing shortcutting procedure to smooth the final path, which improves path quality and smoothness while reducing planning time.",
                "planning_mechanism": "The planner alternates expanding two trees by sampling random points within an informed ellipsoidal subset after an initial solution is found. It performs steer, collision checks, rewiring, and attempts to connect the trees continuously. Upon success, it extracts the path and applies post-processing shortcutting to remove unnecessary waypoints and smooth sharp turns, leading to a shorter, smoother trajectory with improved efficiency.",
                "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n    def add_child(self, child):\n        self.children.append(child)\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=7.0, radius=15.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.radius = radius\n\n    def plan(self, map):\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = (len(bounds) == 3)\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = []\n        edges = []\n\n        best_path_cost = float('inf')\n        solution_node_start = None\n        solution_node_goal = None\n\n        # Basic heuristic distance for informed sampling\n        c_min = self._distance(start_pos, goal_pos)\n\n        for i in range(self.max_iter):\n            if solution_node_start and solution_node_goal:\n                # Informed sampling inside ellipsoid bounding current best path cost\n                sample = self._informed_sample(bounds, obstacles, is_3d, start_pos, goal_pos, best_path_cost, c_min)\n            else:\n                # Uniform random sampling within bounds free space\n                sample = self._sample_free(bounds, obstacles, is_3d)\n\n            for tree_a, tree_b in [(start_tree,goal_tree),(goal_tree,start_tree)]:\n                nearest = self._nearest(tree_a, sample)\n                new_pos = self._steer(nearest.position, sample, self.step_size)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d): continue\n                if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d): continue\n\n                new_node = Node(new_pos)\n                near_nodes = self._near(tree_a, new_pos, self.radius)\n\n                # Choose best parent among near nodes considering path cost and collision\n                min_cost = nearest.cost + self._distance(nearest.position, new_pos)\n                min_parent = nearest\n                for near in near_nodes:\n                    tent_cost = near.cost + self._distance(near.position, new_pos)\n                    if tent_cost < min_cost and not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d):\n                        min_cost = tent_cost\n                        min_parent = near\n\n                new_node.parent = min_parent\n                new_node.cost = min_cost\n                min_parent.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((min_parent, new_node))\n\n                # Rewire neighbors if new node offers a better path\n                for near in near_nodes:\n                    if near == min_parent: continue\n                    new_cost = new_node.cost + self._distance(new_node.position, near.position)\n                    if new_cost < near.cost and not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                        if near.parent:\n                            try: edges.remove((near.parent, near))\n                            except ValueError: pass\n                        near.parent = new_node\n                        near.cost = new_cost\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n\n                # Try to connect to tree_b within step size and collision free\n                connect_node = self._nearest(tree_b, new_node.position)\n                if self._distance(new_node.position, connect_node.position) <= self.step_size:\n                    if not self._is_edge_in_obstacle(new_node.position, connect_node.position, obstacles, is_3d):\n                        # Construct candidate path cost\n                        path_cost = new_node.cost + self._distance(new_node.position, connect_node.position) + connect_node.cost\n                        if path_cost < best_path_cost:\n                            best_path_cost = path_cost\n                            solution_node_start, solution_node_goal = (new_node, connect_node) if tree_a is start_tree else (connect_node, new_node)\n                        # We can continue to iterate to improve path\n\n            if best_path_cost < float('inf') and (i % 100 == 0 or i == self.max_iter -1):\n                # Extract and shortcut path every 100 iterations or at end for smoother solution\n                raw_path = self._extract_path(solution_node_start, solution_node_goal)\n                shortcut_path = self._shortcut_path(raw_path, obstacles, is_3d)\n                if shortcut_path:\n                    return PlannerResult(True, shortcut_path, start_tree + goal_tree, edges)\n\n        # No solution found; return empty path\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        while True:\n            pt = tuple(random.uniform(0, bounds[i]) for i in range(3 if is_3d else 2))\n            if not self._is_in_obstacle(pt, obstacles, is_3d): return pt\n\n    def _informed_sample(self, bounds, obstacles, is_3d, start, goal, c_max, c_min):\n        # Sample inside prolate hyperspheroid (ellipsoid) defined by start, goal, and current best cost c_max\n        # Reduces sampling space to focus search near optimal path\n        dim = 3 if is_3d else 2\n        while True:\n            # Sample unit ball point\n            if dim == 2:\n                r = random.uniform(0,1) ** 0.5\n                theta = random.uniform(0, 2*math.pi)\n                x_ball = [r * math.cos(theta), r * math.sin(theta)]\n            else:\n                # Sample from 3D ball\n                while True:\n                    x_ball = [random.uniform(-1,1), random.uniform(-1,1), random.uniform(-1,1)]\n                    if sum([xi*xi for xi in x_ball]) <= 1: break\n            # Calculate transformation parameters\n            c = c_max\n            if c == float('inf') or c <= c_min:\n                # No current solution, uniform sample\n                pt = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not self._is_in_obstacle(pt, obstacles, is_3d): return pt\n\n            center = tuple((start[i] + goal[i]) / 2 for i in range(dim))\n            dir_vec = [goal[i] - start[i] for i in range(dim)]\n            length = math.dist(start, goal)\n            # Compute rotation matrix from canonical axis to direction vector\n            if dim == 2:\n                if length == 0:\n                    R = [[1,0],[0,1]]\n                else:\n                    a1 = [1,0]\n                    a2 = [dir_vec[0]/length, dir_vec[1]/length]\n                    cos_theta = a1[0]*a2[0] + a1[1]*a2[1]\n                    sin_theta = a1[0]*a2[1] - a1[1]*a2[0]\n                    R = [[cos_theta, -sin_theta],[sin_theta, cos_theta]]\n            else:\n                # 3D rotation using axis-angle (rotation matrix)\n                from math import acos, sqrt\n                if length == 0:\n                    R = [[1,0,0],[0,1,0],[0,0,1]]\n                else:\n                    a1 = [1,0,0]\n                    a2 = [dir_vec[i]/length for i in range(3)]\n                    v = [a1[1]*a2[2]-a1[2]*a2[1], a1[2]*a2[0]-a1[0]*a2[2], a1[0]*a2[1]-a1[1]*a2[0]]\n                    s = sqrt(sum([vi*vi for vi in v]))\n                    c = sum([a1[i]*a2[i] for i in range(3)])\n                    if s == 0:\n                        R = [[1,0,0],[0,1,0],[0,0,1]]\n                    else:\n                        vx = [[0,-v[2],v[1]],[v[2],0,-v[0]],[-v[1],v[0],0]]\n                        I = [[1 if i==j else 0 for j in range(3)] for i in range(3)]\n                        vx2 = [[vx[0][0]*vx[0][0]+vx[0][1]*vx[1][0]+vx[0][2]*vx[2][0],\n                                vx[0][0]*vx[0][1]+vx[0][1]*vx[1][1]+vx[0][2]*vx[2][1],\n                                vx[0][0]*vx[0][2]+vx[0][1]*vx[1][2]+vx[0][2]*vx[2][2]],\n                               [vx[1][0]*vx[0][0]+vx[1][1]*vx[1][0]+vx[1][2]*vx[2][0],\n                                vx[1][0]*vx[0][1]+vx[1][1]*vx[1][1]+vx[1][2]*vx[2][1],\n                                vx[1][0]*vx[0][2]+vx[1][1]*vx[1][2]+vx[1][2]*vx[2][2]],\n                               [vx[2][0]*vx[0][0]+vx[2][1]*vx[1][0]+vx[2][2]*vx[2][0],\n                                vx[2][0]*vx[0][1]+vx[2][1]*vx[1][1]+vx[2][2]*vx[2][1],\n                                vx[2][0]*vx[0][2]+vx[2][1]*vx[1][2]+vx[2][2]*vx[2][2]]]\n                        R = [[I[i][j] + vx[i][j] + ((vx2[i][j]) * ((1 - c)/(s**2))) for j in range(3)] for i in range(3)]\n            # Compose scaling matrix\n            a1_val = c_max / 2.0\n            a_others = math.sqrt(c_max**2 - c_min**2) / 2.0\n            if dim == 2:\n                L = [[a1_val,0],[0,a_others]]\n                # Transform sample from unit ball: pos = R * L * x_ball + center\n                x_scaled = [L[0][0]*x_ball[0] + L[0][1]*x_ball[1], L[1][0]*x_ball[0] + L[1][1]*x_ball[1]]\n                pt = (center[0] + R[0][0]*x_scaled[0] + R[0][1]*x_scaled[1],\n                      center[1] + R[1][0]*x_scaled[0] + R[1][1]*x_scaled[1])\n            else:\n                L = [[a1_val,0,0],[0,a_others,0],[0,0,a_others]]\n                x_scaled = [L[0][0]*x_ball[0], L[1][1]*x_ball[1], L[2][2]*x_ball[2]]\n                pt = tuple(center[i] + sum(R[i][j]*x_scaled[j] for j in range(3)) for i in range(3))\n\n            # Reject points outside bounds or in obstacle\n            if any(pt[d] < 0 or pt[d] > bounds[d] for d in range(dim)):\n                continue\n            if self._is_in_obstacle(pt, obstacles, is_3d):\n                continue\n            return pt\n\n    def _nearest(self, tree, point):\n        return min(tree, key=lambda n: self._distance(n.position, point))\n\n    def _near(self, tree, point, radius):\n        radius_sq = radius * radius\n        return [node for node in tree if self._squared_distance(node.position, point) <= radius_sq]\n\n    def _steer(self, from_pos, to_pos, step_size):\n        dist = self._distance(from_pos, to_pos)\n        if dist <= step_size:\n            return to_pos\n        ratio = step_size / dist\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n    def _extract_path(self, node_start, node_goal):\n        path_start, path_goal = [], []\n        n = node_start\n        while n:\n            path_start.append(n.position)\n            n = n.parent\n        n = node_goal\n        while n:\n            path_goal.append(n.position)\n            n = n.parent\n        return list(reversed(path_start)) + path_goal\n\n    def _shortcut_path(self, path, obstacles, is_3d):\n        # Attempt to shortcut path by skipping intermediate nodes where direct edge collision free\n        if len(path) < 3:\n            return path[:]\n        shortcut_path = [path[0]]\n        i = 0\n        while i < len(path)-1:\n            j = len(path)-1\n            while j > i+1:\n                if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                    break\n                j -= 1\n            shortcut_path.append(path[j])\n            i = j\n        return shortcut_path\n\n    def _distance(self, a, b):\n        return math.dist(a, b)\n\n    def _squared_distance(self, a, b):\n        return sum((a[i] - b[i])**2 for i in range(len(a)))\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x,y,z,w,h,d = obs\n                px,py,pz = pos\n                if x<=px<=x+w and y<=py<=y+h and z<=pz<=z+d:\n                    return True\n            else:\n                x,y,w,h = obs\n                px,py = pos\n                if x<=px<=x+w and y<=py<=y+h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        dist = self._distance(from_pos, to_pos)\n        steps = max(1, int(dist/resolution))\n        for i in range(steps+1):\n            interp = tuple(from_pos[d] + (to_pos[d]-from_pos[d])*(i/steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
                "objective": -23.21547,
                "time_improvement": 21.0,
                "length_improvement": 16.0,
                "smoothness_improvement": 1469.0,
                "node_improvement": 68.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.025556087493896484,
                        "num_nodes_avg": 151.3,
                        "path_length_avg": 173.88763401105183,
                        "smoothness_avg": 0.047474639256938476,
                        "success_improvement": 0.0,
                        "time_improvement": 0.9101035826373128,
                        "node_improvement": 61.89876605389071,
                        "length_improvement": 4.689432372653788,
                        "smoothness_improvement": 643.0811972002915,
                        "objective_score": 6.302096484384924
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.031405282020568845,
                        "num_nodes_avg": 252.2,
                        "path_length_avg": 230.86304004149935,
                        "smoothness_avg": 0.09581397875517297,
                        "success_improvement": 0.0,
                        "time_improvement": 81.03267389975849,
                        "node_improvement": 83.05449170194181,
                        "length_improvement": 22.93127220998329,
                        "smoothness_improvement": 2365.362685390011,
                        "objective_score": 49.89537892286758
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.06047847270965576,
                        "num_nodes_avg": 317.2,
                        "path_length_avg": 119.93973012619429,
                        "smoothness_avg": 0.11787316210161418,
                        "success_improvement": 0.0,
                        "time_improvement": -19.176026584091733,
                        "node_improvement": 59.6694214876033,
                        "length_improvement": 20.341742166387515,
                        "smoothness_improvement": 1399.337921440741,
                        "objective_score": 13.448926931808694
                    }
                ],
                "success_rate": 1.0
            },
            {
                "operator": "initial",
                "algorithm_description": "This algorithm enhances the standard BI-RRT by incorporating an optimization step that rewires nearby nodes to minimize cost, resulting in asymptotically optimal paths. It grows two trees\u2014one from the start and one from the goal\u2014and attempts to connect them while optimizing the path cost dynamically.",
                "planning_mechanism": "The planning mechanism includes sampling a random point, extending each tree toward it, rewiring neighbors within a radius to optimize the cost, and attempting to connect the two trees. When a connection is established, the combined path is extracted from both trees. Node validity and edge collision checks are strictly enforced throughout the process.",
                "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost: float = 0.0):\n        self.position = position              # Tuple[float, ...]\n        self.parent: Optional[\"Node\"] = parent\n        self.cost: float = cost\n        self.children: List[\"Node\"] = []\n        self.valid = True\n\n    def add_child(self, child_node: \"Node\"):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n\nclass Planner:\n    def __init__(\n        self,\n        max_iter: int = 5000,\n        step_size: float = 5.0,\n        gamma_rrt_star: float = 50.0,\n        max_radius: float = 60.0,\n    ):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.gamma_rrt_star = gamma_rrt_star\n        self.max_radius = max_radius\n\n    # ======================= Public API =======================\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        start_root = Node(start_position, parent=None, cost=0.0)\n        goal_root  = Node(goal_position,  parent=None, cost=0.0)\n        nodes.extend([start_root, goal_root])\n\n        tree_a: List[Node] = [start_root]\n        tree_b: List[Node] = [goal_root]\n\n        for _ in range(self.max_iter):\n            rand_point = self._sample_free(bounds, obstacles, is_3d)\n\n            new_a = self._extend_and_rewire(tree_a, rand_point, obstacles, is_3d, nodes, edges, bounds)\n            if new_a is None:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            new_b = self._connect_and_rewire(tree_b, new_a, obstacles, is_3d, nodes, edges, bounds)\n            if new_b:\n                success_state = True\n                path_a = new_a.path_from_root()\n                path_b = new_b.path_from_root()\n                if path_a and path_b and path_a[-1] == path_b[-1]:\n                    path_b = path_b[:-1]\n                extracted_path = path_a + path_b[::-1]\n                break\n\n            tree_a, tree_b = tree_b, tree_a\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        while True:\n            p = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    def _nearest(self, tree: List[Node], point):\n        return min(tree, key=lambda node: math.dist(node.position, point))\n\n    def _steer(self, from_pos, to_pos):\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _near_nodes(self, tree: List[Node], position, bounds) -> List[Node]:\n        n = max(1, len(tree))\n        d = len(position)\n        # \uacf5\uac04 \uc2a4\ucf00\uc77c\uc744 \uac04\ub2e8\ud788 bounds\ub85c \ucd94\uc815 (\uc815\ubc00 X, \uc2e4\uc6a9\uc801)\n        scale = max(1.0, sum(bounds) / d)\n        r_theory = self.gamma_rrt_star * ((math.log(n + 1) / (n + 1)) ** (1.0 / d))\n        radius = max(self.step_size * 2.0, min(self.max_radius, r_theory * 0.5 + scale * 0.02))\n        return [node for node in tree if math.dist(node.position, position) <= radius]\n\n    def _choose_parent_and_add(self, tree, new_pos, obstacles, is_3d, nodes, edges, bounds):\n        nearest = self._nearest(tree, new_pos)\n        neighbors = self._near_nodes(tree, new_pos, bounds)\n\n        min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n        best_parent = nearest\n\n        for nb in neighbors:\n            if not self._is_edge_in_obstacle(nb.position, new_pos, obstacles, is_3d):\n                cand = nb.cost + math.dist(nb.position, new_pos)\n                if cand < min_cost:\n                    min_cost = cand\n                    best_parent = nb\n\n        new_node = Node(new_pos, parent=None, cost=min_cost)\n        best_parent.add_child(new_node)\n        tree.append(new_node)\n        nodes.append(new_node)\n        edges.append((best_parent, new_node))\n        return new_node, neighbors\n\n    def _rewire_from(self, pivot: Node, neighbors: List[Node], obstacles, is_3d, edges):\n        for nb in neighbors:\n            if not self._is_edge_in_obstacle(pivot.position, nb.position, obstacles, is_3d):\n                new_cost = pivot.cost + math.dist(pivot.position, nb.position)\n                if new_cost + 1e-12 < nb.cost:  # \uc791\uc740 \uc218\uce58 \ubc84\ud37c\n                    if nb.parent is not None:\n                        try:\n                            edges.remove((nb.parent, nb))\n                        except ValueError:\n                            pass\n                        if nb in nb.parent.children:\n                            nb.parent.children.remove(nb)\n                    pivot.add_child(nb)\n                    nb.cost = new_cost\n                    edges.append((pivot, nb))\n\n    def _extend_and_rewire(self, tree, sample_point, obstacles, is_3d, nodes, edges, bounds):\n        nearest = self._nearest(tree, sample_point)\n        new_pos = self._steer(nearest.position, sample_point)\n\n        if self._is_in_obstacle(new_pos, obstacles, is_3d):\n            return None\n        if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n            return None\n\n        new_node, neighbors = self._choose_parent_and_add(tree, new_pos, obstacles, is_3d, nodes, edges, bounds)\n        self._rewire_from(new_node, neighbors, obstacles, is_3d, edges)\n        return new_node\n\n    def _connect_and_rewire(self, tree, target_node: Node, obstacles, is_3d, nodes, edges, bounds):\n        nearest = self._nearest(tree, target_node.position)\n\n        while True:\n            new_pos = self._steer(nearest.position, target_node.position)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                return None\n\n            connect_node, neighbors = self._choose_parent_and_add(tree, new_pos, obstacles, is_3d, nodes, edges, bounds)\n            self._rewire_from(connect_node, neighbors, obstacles, is_3d, edges)\n\n            if math.dist(connect_node.position, target_node.position) <= self.step_size:\n                if (not self._is_edge_in_obstacle(connect_node.position, target_node.position, obstacles, is_3d) and\n                    not self._is_in_obstacle(target_node.position, obstacles, is_3d)):\n                    final_node = Node(target_node.position, parent=None, cost=connect_node.cost + math.dist(connect_node.position, target_node.position))\n                    connect_node.add_child(final_node)\n                    tree.append(final_node)\n                    nodes.append(final_node)\n                    edges.append((connect_node, final_node))\n                    return final_node\n                else:\n                    return None\n\n            nearest = connect_node\n\n        \n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n        \n        \n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n",
                "objective": -18.483327093247905,
                "time_improvement": 35.0,
                "length_improvement": 12.0,
                "smoothness_improvement": 180.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.022586989402770995,
                        "num_nodes_avg": 95.7,
                        "path_length_avg": 168.64313046948791,
                        "smoothness_avg": 0.017505839022252202,
                        "success_improvement": 0.0,
                        "time_improvement": 12.422336132822434,
                        "node_improvement": 75.90027700831025,
                        "length_improvement": 7.564027868261686,
                        "smoothness_improvement": 174.00439523612755,
                        "objective_score": 9.13513953698438
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.03670787811279297,
                        "num_nodes_avg": 248.8,
                        "path_length_avg": 257.74323422045836,
                        "smoothness_avg": 0.010534876218801273,
                        "success_improvement": 0.0,
                        "time_improvement": 77.83015308834821,
                        "node_improvement": 83.2829402674192,
                        "length_improvement": 13.957889689556485,
                        "smoothness_improvement": 171.06995307438933,
                        "objective_score": 32.5791295056103
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.04266858100891113,
                        "num_nodes_avg": 241.6,
                        "path_length_avg": 130.54377171187787,
                        "smoothness_avg": 0.023278354893991073,
                        "success_improvement": 0.0,
                        "time_improvement": 15.919306212711263,
                        "node_improvement": 69.28162746344564,
                        "length_improvement": 13.299042655374924,
                        "smoothness_improvement": 196.09895602214036,
                        "objective_score": 13.735712237149036
                    }
                ],
                "success_rate": 1.0
            }
        ],
        "offspring": {
            "operator": "m1",
            "algorithm_description": "A novel bidirectional RRT* variant with adaptive informed sampling based on current best path cost combined with a heuristic-driven prioritized rewiring scheme. Instead of uniform or vanilla informed sampling, the algorithm dynamically shrinks its sampling ellipsoid region as solutions improve for faster convergence. The rewiring phase favors nodes estimated closer to the goal using a heuristic distance, guiding tree restructuring to yield shorter, smoother paths. Post-processing employs an iterative shortcutting approach that refines path smoothness while preserving collision-free guarantees. This approach balances global exploration and local optimization to enhance planning efficiency, path length, and smoothness while reducing runtime.",
            "planning_mechanism": "The planner grows two bidirectional trees from start and goal, sampling adaptive informed points inside a shrinking ellipsoid focused by the best path cost. It extends and rewires nodes by prioritizing neighbors nearer the goal heuristic, striving for low-cost rewiring. Trees attempt to connect continuously, updating best solutions. Upon finishing, the path undergoes iterative shortcut smoothing to remove unnecessary waypoints. This coordinated mechanism improves convergence speed, reduces excessive edge checks, and enhances solution quality.",
            "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n    def add_child(self, child):\n        self.children.append(child)\nclass Planner:\n    def __init__(self, max_iter=4000, step_size=6.0, max_radius=20.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.max_radius = max_radius\n\n    def plan(self, map):\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        c_min = math.dist(start_pos, goal_pos)\n        best_cost = float('inf')\n        solution_nodes = (None, None)\n\n        # Precompute dimension for convenience\n        dim = 3 if is_3d else 2\n\n        def heuristic_to_goal(p):\n            return math.dist(p, goal_pos)\n\n        def heuristic_to_start(p):\n            return math.dist(p, start_pos)\n\n        for iter in range(self.max_iter):\n            # Adaptive informed sampling inside ellipsoid shrinking as best_cost improves\n            sample = self._adaptive_informed_sample(bounds, obstacles, is_3d, start_pos, goal_pos, best_cost, c_min)\n            \n            # Alternate tree roles each iteration\n            if iter % 2 == 0:\n                tree_a, tree_b = start_tree, goal_tree\n                heuristic_a, heuristic_b = heuristic_to_goal, heuristic_to_start\n            else:\n                tree_a, tree_b = goal_tree, start_tree\n                heuristic_a, heuristic_b = heuristic_to_start, heuristic_to_goal\n            \n            nearest = self._nearest(tree_a, sample)\n            new_pos = self._steer(nearest.position, sample)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d): continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d): continue\n            \n            near_nodes = self._near(tree_a, new_pos, self.max_radius)\n            # Prioritize near nodes by heuristic to goal (or start)\n            near_nodes.sort(key=lambda n: heuristic_a(n.position))\n            \n            # Choose best parent based on cost + heuristic + collision free\n            min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n            best_parent = nearest\n            for nnode in near_nodes:\n                if nnode is nearest:\n                    continue\n                tentative_cost = nnode.cost + math.dist(nnode.position, new_pos)\n                if tentative_cost + heuristic_a(new_pos) >= min_cost + heuristic_a(new_pos):\n                    # Prune candidates that are not better in cost + heuristic\n                    continue\n                if self._is_edge_in_obstacle(nnode.position, new_pos, obstacles, is_3d):\n                    continue\n                min_cost = tentative_cost\n                best_parent = nnode\n            \n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n            \n            # Rewire neighbors that improve cost with heuristic guidance\n            for neighbor in near_nodes:\n                if neighbor is best_parent or neighbor is new_node:\n                    continue\n                new_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n                # Only rewire if new cost + heuristic less than existing\n                if new_cost + heuristic_a(neighbor.position) + 1e-8 < neighbor.cost + heuristic_a(neighbor.position):\n                    if self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        continue\n                    if neighbor.parent:\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        if neighbor in neighbor.parent.children:\n                            neighbor.parent.children.remove(neighbor)\n                    neighbor.parent = new_node\n                    neighbor.cost = new_cost\n                    new_node.add_child(neighbor)\n                    edges.append((new_node, neighbor))\n            \n            # Try connection to other tree within step size and free space\n            conn_node = self._nearest(tree_b, new_node.position)\n            dist_conn = math.dist(new_node.position, conn_node.position)\n            if dist_conn <= self.step_size:\n                if not self._is_edge_in_obstacle(new_node.position, conn_node.position, obstacles, is_3d):\n                    path_cost = new_node.cost + dist_conn + conn_node.cost\n                    if path_cost < best_cost:\n                        best_cost = path_cost\n                        if iter % 2 == 0:\n                            solution_nodes = (new_node, conn_node)\n                        else:\n                            solution_nodes = (conn_node, new_node)\n            \n            # Periodically extract and iteratively shortcut path for smoothness improvement\n            if solution_nodes[0] and solution_nodes[1] and (iter % 150 == 0 or iter == self.max_iter - 1):\n                raw_path = self._extract_path(solution_nodes[0], solution_nodes[1])\n                shortcut_path = self._iterative_shortcut(raw_path, obstacles, is_3d)\n                if shortcut_path:\n                    return PlannerResult(True, shortcut_path, nodes, edges)\n\n        # Final check after iterations\n        if solution_nodes[0] and solution_nodes[1]:\n            raw_path = self._extract_path(solution_nodes[0], solution_nodes[1])\n            shortcut_path = self._iterative_shortcut(raw_path, obstacles, is_3d)\n            return PlannerResult(True, shortcut_path, nodes, edges)\n        else:\n            return PlannerResult(False, [], nodes, edges)\n\n    def _adaptive_informed_sample(self, bounds, obstacles, is_3d, start, goal, c_max, c_min):\n        dim = 3 if is_3d else 2\n        if c_max == float('inf') or c_max <= c_min:\n            # Uniform random sampling if no valid path found yet\n            while True:\n                pt = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not self._is_in_obstacle(pt, obstacles, is_3d):\n                    return pt\n\n        c_max = min(c_max, sum(bounds)*10)  # Clamp c_max to reasonable upper bound\n        center = tuple((start[i] + goal[i]) / 2 for i in range(dim))\n        dir_vec = [goal[i] - start[i] for i in range(dim)]\n        length = math.dist(start, goal)\n        if length == 0:\n            # Degenerate case\n            return start\n\n        # Rotation matrix to align x-axis to direction vector (2D or 3D)\n        if dim == 2:\n            a1 = [1, 0]\n            a2 = [dir_vec[0]/length, dir_vec[1]/length]\n            cos_theta = a1[0]*a2[0] + a1[1]*a2[1]\n            sin_theta = a1[0]*a2[1] - a1[1]*a2[0]\n            R = [[cos_theta, -sin_theta],[sin_theta, cos_theta]]\n        else:\n            # 3D rotation matrix from x-axis to dir_vec using Rodrigues formula\n            a1 = [1, 0, 0]\n            a2 = [dir_vec[i]/length for i in range(3)]\n            v = [a1[1]*a2[2] - a1[2]*a2[1],\n                 a1[2]*a2[0] - a1[0]*a2[2],\n                 a1[0]*a2[1] - a1[1]*a2[0]]\n            s = math.sqrt(sum(vi*vi for vi in v))\n            c = sum(a1[i]*a2[i] for i in range(3))\n            if s == 0:\n                R = [[1,0,0],[0,1,0],[0,0,1]]\n            else:\n                vx = [[0, -v[2], v[1]],\n                      [v[2], 0, -v[0]],\n                      [-v[1], v[0], 0]]\n                I = [[1 if i == j else 0 for j in range(3)] for i in range(3)]\n                vx2 = [[sum(vx[i][k]*vx[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n                R = [[I[i][j] + vx[i][j] + ((1 - c)/(s**2))*vx2[i][j] for j in range(3)] for i in range(3)]\n\n        a1_val = c_max / 2.0\n        try:\n            a_others = math.sqrt(abs(c_max*c_max - c_min*c_min)) / 2.0\n        except Exception:\n            a_others = a1_val\n\n        while True:\n            # Sample point in unit ball\n            if dim == 2:\n                r = random.uniform(0, 1)**0.5\n                theta = random.uniform(0, 2*math.pi)\n                x_ball = [r*math.cos(theta), r*math.sin(theta)]\n                L = [[a1_val, 0], [0, a_others]]\n                x_scaled = [L[0][0]*x_ball[0] + L[0][1]*x_ball[1],\n                            L[1][0]*x_ball[0] + L[1][1]*x_ball[1]]\n                pt_rot = (R[0][0]*x_scaled[0] + R[0][1]*x_scaled[1],\n                          R[1][0]*x_scaled[0] + R[1][1]*x_scaled[1])\n                pt = tuple(center[i] + pt_rot[i] for i in range(dim))\n            else:\n                while True:\n                    x_ball = [random.uniform(-1,1) for _ in range(3)]\n                    if sum(xi*xi for xi in x_ball) <= 1:\n                        break\n                L = [[a1_val,0,0],[0,a_others,0],[0,0,a_others]]\n                x_scaled = [L[0][0]*x_ball[0], L[1][1]*x_ball[1], L[2][2]*x_ball[2]]\n                pt_rot = [sum(R[i][j]*x_scaled[j] for j in range(3)) for i in range(3)]\n                pt = tuple(center[i] + pt_rot[i] for i in range(dim))\n\n            # Check bounds\n            if any(pt[d] < 0 or pt[d] > bounds[d] for d in range(dim)):\n                continue\n            if self._is_in_obstacle(pt, obstacles, is_3d):\n                continue\n            return pt\n\n    def _nearest(self, tree, point):\n        return min(tree, key=lambda node: math.dist(node.position, point))\n\n    def _near(self, tree, point, radius):\n        radius_sq = radius*radius\n        return [node for node in tree if self._squared_distance(node.position, point) <= radius_sq]\n\n    def _steer(self, from_pos, to_pos):\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[i] + (to_pos[i]-from_pos[i])*ratio for i in range(len(from_pos)))\n\n    def _extract_path(self, node_start, node_goal):\n        path_start = []\n        n = node_start\n        while n:\n            path_start.append(n.position)\n            n = n.parent\n        path_goal = []\n        n = node_goal\n        while n:\n            path_goal.append(n.position)\n            n = n.parent\n        return list(reversed(path_start)) + path_goal\n\n    def _iterative_shortcut(self, path, obstacles, is_3d, max_attempts=150):\n        if len(path) < 3:\n            return path[:]\n        path = path[:]\n        for _ in range(max_attempts):\n            if len(path) < 3:\n                break\n            i = random.randint(0, len(path)-3)\n            j = random.randint(i+2, len(path)-1)\n            if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                # Remove intermediate nodes between i and j\n                path = path[:i+1] + path[j:]\n        return path\n\n    def _squared_distance(self, a, b):\n        return sum((a[i] - b[i])**2 for i in range(len(a)))\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x,y,z,w,h,d = obs\n                px,py,pz = pos\n                if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                    return True\n            else:\n                x,y,w,h = obs\n                px,py = pos\n                if x <= px <= x+w and y <= py <= y+h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist/resolution))\n        for i in range(steps+1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d])*(i/steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
            "objective": -14.08602,
            "time_improvement": -15.0,
            "length_improvement": 20.0,
            "smoothness_improvement": 1402.0,
            "node_improvement": 63.0,
            "other_inf": [
                {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.05029592514038086,
                    "num_nodes_avg": 197.7,
                    "path_length_avg": 161.93878883699725,
                    "smoothness_avg": 0.047628044606518545,
                    "success_improvement": 0.0,
                    "time_improvement": -95.01490647056376,
                    "node_improvement": 50.21405187610174,
                    "length_improvement": 11.23878375412141,
                    "smoothness_improvement": 645.482324046268,
                    "objective_score": -18.53379006846494
                },
                {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.059864473342895505,
                    "num_nodes_avg": 338.1,
                    "path_length_avg": 225.87643224817134,
                    "smoothness_avg": 0.0890107769545784,
                    "success_improvement": 0.0,
                    "time_improvement": 63.844649222693185,
                    "node_improvement": 77.2828058859101,
                    "length_improvement": 24.59594542294319,
                    "smoothness_improvement": 2190.3114029125213,
                    "objective_score": 44.86251903513647
                },
                {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.05845465660095215,
                    "num_nodes_avg": 311.2,
                    "path_length_avg": 116.34668105324462,
                    "smoothness_avg": 0.11554898589311344,
                    "success_improvement": 0.0,
                    "time_improvement": -15.18798998915194,
                    "node_improvement": 60.43229497774952,
                    "length_improvement": 22.7280742780298,
                    "smoothness_improvement": 1369.7745716214542,
                    "objective_score": 15.929320428179569
                }
            ],
            "success_rate": 1.0
        },
        "objective": 867.9999999999999,
        "analysis": {
            "problem": [
                "Problem of the parents algorithm:\n   - Sampling methods sometimes overly uniform or insufficiently focused on promising solution regions, leading to inefficient exploration.\n   - Rewiring strategies lacked prioritization by heuristic cost-to-goal, causing suboptimal parent selection and less effective tree restructuring.\n   - Edge collision checking used fixed resolution without adaptivity, increasing computational overhead and sometimes missing smoother paths.\n   - Path smoothing techniques were simplistic or infrequent, limiting overall path smoothness improvements.\n   - Tree expansion alternated without heuristic guidance, sometimes causing uncoordinated growth and slower convergence."
            ],
            "solution": "1. Primary contributors to the performance improvement:\n   - Implementation of adaptive informed sampling that progressively constrains samples within a shrinking ellipsoid around the best known path, focusing search.\n   - Heuristic-driven prioritized rewiring that considers cost-to-go along with collision checks, leading to improved parent selection and shorter, smoother connections.\n   - Integration of iterative shortcutting post-processing that aggressively refines the path by removing unnecessary waypoints while maintaining collision-free guarantees.\n   - Coordinated bidirectional tree expansion guided by heuristic measures to accelerate convergence.\n\n2. Expected mechanism of impact:\n   - Focused sampling reduces wasted exploration in irrelevant areas, improving computational efficiency and planning time.\n   - Heuristic-based rewiring enhances path quality by restructuring connections toward lower-cost routes and improving path length and smoothness.\n   - Iterative shortcutting effectively smooths the path beyond simple greedy shortcuts, significantly boosting smoothness metrics.\n   - Coordinated tree growth guided by heuristics promotes faster discovery of near-optimal connections, enhancing convergence rate and final path quality."
        }
    },
    {
        "parents": [
            {
                "operator": "m3",
                "algorithm_description": "An efficient bidirectional RRT* with adaptive informed sampling and incremental path shortcutting, focusing sampling within an ellipsoidal subset around the best path to accelerate convergence, combined with local rewiring for path optimization and progressive shortcutting to improve path smoothness and length while reducing planning time. The planner grows two trees from start and goal, alternately expanding toward sampled points focused by current best solution, connects the two trees when possible, rewires locally to optimize costs, and progressively shortcuts the path during planning for smoother results.",
                "planning_mechanism": "The planner alternates growth of two trees (start and goal) using adaptive informed sampling within an ellipsoidal subset defined by the current best path cost. At each iteration, a sample point is generated; nearest nodes are extended toward it with collision checking. The algorithm rewires nearby nodes to optimize path costs locally. Upon connecting both trees, it extracts the combined path and incrementally applies shortcutting to remove unnecessary waypoints and smooth the trajectory. This approach balances efficient exploration, path quality, and runtime performance.",
                "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n    def add_child(self, child):\n        self.children.append(child)\nclass Planner:\n    def __init__(self, max_iter=4000, step_size=6.0, radius=12.0, shortcut_interval=50):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.radius = radius\n        self.shortcut_interval = shortcut_interval\n\n    def plan(self, map):\n        import random\n        import math\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = (len(bounds) == 3)\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        best_cost = float('inf')\n        solution_start, solution_goal = None, None\n\n        c_min = math.dist(start_pos, goal_pos)\n        dim = 3 if is_3d else 2\n\n        for i in range(self.max_iter):\n            # Adaptive Sample\n            if best_cost < float('inf'):\n                sample = self._informed_sample(bounds, obstacles, is_3d, start_pos, goal_pos, best_cost, c_min)\n            else:\n                sample = self._sample_free(bounds, obstacles, is_3d)\n\n            # Alternate tree expansion\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest = self._nearest(tree_a, sample)\n                new_pos = self._steer(nearest.position, sample, self.step_size)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                    continue\n\n                new_node = Node(new_pos)\n                near_nodes = self._near(tree_a, new_pos, self.radius)\n\n                min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n                min_parent = nearest\n                for near in near_nodes:\n                    tentative_cost = near.cost + math.dist(near.position, new_pos)\n                    if tentative_cost < min_cost and not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d):\n                        min_cost = tentative_cost\n                        min_parent = near\n\n                new_node.parent = min_parent\n                new_node.cost = min_cost\n                min_parent.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((min_parent, new_node))\n\n                # Rewire near nodes to new_node if beneficial\n                for near in near_nodes:\n                    if near is min_parent:\n                        continue\n                    new_cost = new_node.cost + math.dist(new_node.position, near.position)\n                    if new_cost < near.cost and not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                        if near.parent:\n                            try: edges.remove((near.parent, near))\n                            except ValueError: pass\n                            # Remove near from old parent's children list safely\n                            try: near.parent.children.remove(near)\n                            except ValueError: pass\n                        near.parent = new_node\n                        near.cost = new_cost\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n\n                # Try to connect both trees to form path\n                connect_node = self._nearest(tree_b, new_node.position)\n                dist_connect = math.dist(new_node.position, connect_node.position)\n                if dist_connect <= self.step_size:\n                    if not self._is_edge_in_obstacle(new_node.position, connect_node.position, obstacles, is_3d):\n                        path_cost = new_node.cost + dist_connect + connect_node.cost\n                        if path_cost < best_cost:\n                            best_cost = path_cost\n                            if tree_a is start_tree:\n                                solution_start, solution_goal = new_node, connect_node\n                            else:\n                                solution_start, solution_goal = connect_node, new_node\n\n            # Progressive shortcutting for smoother path every shortcut_interval iterations\n            if best_cost < float('inf') and solution_start and solution_goal and (i % self.shortcut_interval == 0 or i == self.max_iter-1):\n                raw_path = self._extract_path(solution_start, solution_goal)\n                shortcut_path = self._shortcut_path(raw_path, obstacles, is_3d, max_attempts=50)\n                if shortcut_path:\n                    return PlannerResult(True, shortcut_path, nodes, edges)\n\n        # No solution found\n        return PlannerResult(False, [], nodes, edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        import random\n        while True:\n            pt = tuple(random.uniform(0, bounds[i]) for i in range(len(bounds)))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def _informed_sample(self, bounds, obstacles, is_3d, start, goal, c_max, c_min):\n        import random\n        import math\n        dim = 3 if is_3d else 2\n\n        # Reject sample if no valid ellipsoid (e.g. c_max <= c_min)\n        if c_max <= c_min:\n            return self._sample_free(bounds, obstacles, is_3d)\n\n        center = tuple((start[i]+goal[i])/2 for i in range(dim))\n        dir_vec = [goal[i]-start[i] for i in range(dim)]\n        length = math.dist(start, goal)\n        if length == 0:\n            # No interval, uniform sample fallback\n            return self._sample_free(bounds, obstacles, is_3d)\n\n        # Compute rotation matrix R from canonical axis to direction vector\n        if dim == 2:\n            a1 = [1,0]\n            a2 = [dir_vec[0]/length, dir_vec[1]/length]\n            cos_theta = a1[0]*a2[0] + a1[1]*a2[1]\n            sin_theta = a1[0]*a2[1] - a1[1]*a2[0]\n            R = [[cos_theta, -sin_theta],[sin_theta, cos_theta]]\n        else:\n            from math import sqrt\n            a1 = [1,0,0]\n            a2 = [dir_vec[i]/length for i in range(3)]\n            v = [a1[1]*a2[2]-a1[2]*a2[1], a1[2]*a2[0]-a1[0]*a2[2], a1[0]*a2[1]-a1[1]*a2[0]]\n            s = sqrt(sum([vi*vi for vi in v]))\n            c = sum([a1[i]*a2[i] for i in range(3)])\n            if s == 0:\n                R = [[1,0,0],[0,1,0],[0,0,1]]\n            else:\n                vx = [[0,-v[2],v[1]],[v[2],0,-v[0]],[-v[1],v[0],0]]\n                I = [[1 if i==j else 0 for j in range(3)] for i in range(3)]\n                vx2 = [[sum(vx[i][k]*vx[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n                R = [[I[i][j] + vx[i][j] + vx2[i][j]*((1 - c)/(s**2)) for j in range(3)] for i in range(3)]\n\n        # Sample point inside unit ball\n        if dim == 2:\n            r = random.uniform(0,1)**0.5\n            theta = random.uniform(0, 2*math.pi)\n            x_ball = [r*math.cos(theta), r*math.sin(theta)]\n        else:\n            while True:\n                x_ball = [random.uniform(-1,1) for _ in range(3)]\n                if sum(xi*xi for xi in x_ball) <= 1:\n                    break\n\n        a1_val = c_max / 2.0\n        a_other = math.sqrt(c_max**2 - c_min**2) / 2.0\n\n        # Scaling matrix\n        if dim == 2:\n            L = [[a1_val, 0],[0, a_other]]\n            x_scaled = [L[0][0]*x_ball[0] + L[0][1]*x_ball[1],\n                        L[1][0]*x_ball[0] + L[1][1]*x_ball[1]]\n            pt = (center[0] + R[0][0]*x_scaled[0] + R[0][1]*x_scaled[1],\n                  center[1] + R[1][0]*x_scaled[0] + R[1][1]*x_scaled[1])\n        else:\n            L = [[a1_val, 0, 0],[0, a_other, 0],[0, 0, a_other]]\n            x_scaled = [L[0][0]*x_ball[0], L[1][1]*x_ball[1], L[2][2]*x_ball[2]]\n            pt = tuple(center[i] + sum(R[i][j]*x_scaled[j] for j in range(3)) for i in range(3))\n\n        # Reject if outside bounds or in obstacle\n        if any(pt[d] < 0 or pt[d] > bounds[d] for d in range(dim)):\n            return self._sample_free(bounds, obstacles, is_3d)\n        if self._is_in_obstacle(pt, obstacles, is_3d):\n            return self._sample_free(bounds, obstacles, is_3d)\n\n        return pt\n\n    def _nearest(self, tree, point):\n        import math\n        return min(tree, key=lambda n: math.dist(n.position, point))\n\n    def _near(self, tree, point, radius):\n        r_sq = radius*radius\n        return [n for n in tree if sum((n.position[i]-point[i])**2 for i in range(len(point))) <= r_sq]\n\n    def _steer(self, from_pos, to_pos, step_size):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        if dist <= step_size:\n            return to_pos\n        ratio = step_size / dist\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i])*ratio for i in range(len(from_pos)))\n\n    def _extract_path(self, node_start, node_goal):\n        path_start, path_goal = [], []\n        n = node_start\n        while n:\n            path_start.append(n.position)\n            n = n.parent\n        n = node_goal\n        while n:\n            path_goal.append(n.position)\n            n = n.parent\n        return list(reversed(path_start)) + path_goal\n\n    def _shortcut_path(self, path, obstacles, is_3d, max_attempts=30):\n        # Attempt bounded shortcutting to improve smoothness by removing redundant waypoints\n        if len(path) < 3:\n            return path[:]\n        import random\n        new_path = path[:]\n        attempts = 0\n        while attempts < max_attempts:\n            if len(new_path) < 3:\n                break\n            i = random.randint(0, len(new_path)-3)\n            j = random.randint(i+2, len(new_path)-1)\n            if not self._is_edge_in_obstacle(new_path[i], new_path[j], obstacles, is_3d):\n                # Remove intermediate nodes between i and j\n                new_path = new_path[:i+1] + new_path[j:]\n                attempts = 0  # reset attempts after successful shortcut\n            else:\n                attempts += 1\n        return new_path\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x,y,z,w,h,d=obs\n                px,py,pz=pos\n                if x<=px<=x+w and y<=py<=y+h and z<=pz<=z+d:\n                    return True\n            else:\n                x,y,w,h=obs\n                px,py=pos\n                if x<=px<=x+w and y<=py<=y+h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist/resolution))\n        for i in range(steps+1):\n            interp = tuple(from_pos[d] + (to_pos[d]-from_pos[d])*(i/steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
                "objective": -30.55144,
                "time_improvement": 46.0,
                "length_improvement": 18.0,
                "smoothness_improvement": 1254.0,
                "node_improvement": 72.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.019833183288574217,
                        "num_nodes_avg": 147.4,
                        "path_length_avg": 162.65169192869433,
                        "smoothness_avg": 0.04547432196696187,
                        "success_improvement": 0.0,
                        "time_improvement": 23.09980633143671,
                        "node_improvement": 62.880886426592795,
                        "length_improvement": 10.848030272889844,
                        "smoothness_improvement": 611.7718878536382,
                        "objective_score": 16.49761950243311
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.023508524894714354,
                        "num_nodes_avg": 236.2,
                        "path_length_avg": 226.91038346862007,
                        "smoothness_avg": 0.07885871014571852,
                        "success_improvement": 0.0,
                        "time_improvement": 85.80194702529162,
                        "node_improvement": 84.12954377477658,
                        "length_improvement": 24.250782744921644,
                        "smoothness_improvement": 1929.091411682397,
                        "objective_score": 49.936510812952456
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.036681842803955075,
                        "num_nodes_avg": 255.1,
                        "path_length_avg": 123.45751291252664,
                        "smoothness_avg": 0.10380569995332274,
                        "success_improvement": 0.0,
                        "time_improvement": 27.71649022711396,
                        "node_improvement": 67.56516211061665,
                        "length_improvement": 18.005398338521033,
                        "smoothness_improvement": 1220.4008412665191,
                        "objective_score": 25.220190277579402
                    }
                ],
                "success_rate": 1.0
            },
            {
                "operator": "initial",
                "algorithm_description": "This algorithm is a dual-tree variant of Rapidly-exploring Random Tree (RRT) that grows two trees from the start and goal positions, attempting to connect them as they expand. It is efficient for single-query problems due to its bidirectional search and reduced redundant exploration.",
                "planning_mechanism": "The planner alternates between growing the start and goal trees by extending towards randomly sampled points. Each extension step involves checking for collision-free motion and attempting to connect the two trees. The algorithm terminates when a valid path is formed connecting the trees.",
                "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n        nodes = []\n        edges = []\n        success_state = False\n        extracted_path = []\n\n        for iter in range(self.max_iter):\n            rand = self._sample_free(bounds, obstacles, is_3d)\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest = self._nearest(tree_a, rand)\n                new_pos = self._steer(nearest.position, rand, self.step_size)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                    continue\n                new_node = Node(new_pos, parent=nearest, cost=nearest.cost + self._distance(nearest.position, new_pos))\n                nearest.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((nearest, new_node))\n\n                connect_node = self._nearest(tree_b, new_pos)\n                if self._connect_trees(new_node, connect_node, obstacles, is_3d, tree_b, nodes, edges):\n                    success_state = True\n                    extracted_path = self._extract_path(new_node, connect_node)\n                    return PlannerResult(True, extracted_path, start_tree + goal_tree, edges)\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        while True:\n            if is_3d:\n                point = tuple(random.uniform(0, bounds[i]) for i in range(3))\n            else:\n                point = tuple(random.uniform(0, bounds[i]) for i in range(2))\n            if not self._is_in_obstacle(point, obstacles, is_3d):\n                return point\n\n    def _nearest(self, tree, point):\n        return min(tree, key=lambda node: self._distance(node.position, point))\n\n    def _steer(self, from_pos, to_pos, step_size):\n        dist = self._distance(from_pos, to_pos)\n        if dist <= step_size:\n            return to_pos\n        ratio = step_size / dist\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n    def _connect_trees(self, node_a, node_b, obstacles, is_3d, tree, nodes, edges):\n        from_pos = node_a.position\n        to_pos = node_b.position\n        if self._is_edge_in_obstacle(from_pos, to_pos, obstacles, is_3d):\n            return False\n        curr = node_b\n        path = []\n        while True:\n            new_pos = self._steer(curr.position, from_pos, self.step_size)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return False\n            if self._is_edge_in_obstacle(curr.position, new_pos, obstacles, is_3d):\n                return False\n            new_node = Node(new_pos, parent=curr, cost=curr.cost + self._distance(curr.position, new_pos))\n            curr.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((curr, new_node))\n            if self._distance(new_pos, from_pos) < self.step_size:\n                new_node_final = Node(from_pos, parent=new_node, cost=new_node.cost + self._distance(new_pos, from_pos))\n                new_node.add_child(new_node_final)\n                tree.append(new_node_final)\n                nodes.append(new_node_final)\n                edges.append((new_node, new_node_final))\n                return True\n            curr = new_node\n\n    def _extract_path(self, node_a, node_b):\n        path_a = []\n        while node_a:\n            path_a.append(node_a.position)\n            node_a = node_a.parent\n        path_b = []\n        while node_b:\n            path_b.append(node_b.position)\n            node_b = node_b.parent\n        return list(reversed(path_a)) + path_b\n\n    def _distance(self, a, b):\n        return math.dist(a, b)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = self._distance(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n    ",
                "objective": -17.795854854811235,
                "time_improvement": 71.0,
                "length_improvement": -6.0,
                "smoothness_improvement": 75.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.015041923522949219,
                        "num_nodes_avg": 140.4,
                        "path_length_avg": 205.55369204774252,
                        "smoothness_avg": 0.01041684624247792,
                        "success_improvement": 0.0,
                        "time_improvement": 41.67719749109079,
                        "node_improvement": 64.64366658272476,
                        "length_improvement": -12.667235818056396,
                        "smoothness_improvement": 63.046264238449346,
                        "objective_score": 5.218049077685646
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.016628527641296388,
                        "num_nodes_avg": 235.2,
                        "path_length_avg": 305.1784824883373,
                        "smoothness_avg": 0.00711472502770238,
                        "success_improvement": 0.0,
                        "time_improvement": 89.95714459329555,
                        "node_improvement": 84.19673452932877,
                        "length_improvement": -1.8773615301791229,
                        "smoothness_improvement": 83.06699949208468,
                        "objective_score": 26.276061457341616
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.010075998306274415,
                        "num_nodes_avg": 181.0,
                        "path_length_avg": 156.9681958591822,
                        "smoothness_avg": 0.014159220130581652,
                        "success_improvement": 0.0,
                        "time_improvement": 80.14471285055937,
                        "node_improvement": 76.98664971392245,
                        "length_improvement": -4.250801667402978,
                        "smoothness_improvement": 80.10423493608366,
                        "objective_score": 21.89345402940644
                    }
                ],
                "success_rate": 1.0
            }
        ],
        "offspring": {
            "operator": "m2",
            "algorithm_description": "An enhanced bidirectional RRT* algorithm with adaptive radius rewiring, probabilistic goal bias sampling, dynamic local rewiring for cost optimization, adaptive informed sampling to accelerate convergence, and progressive path shortcutting to improve smoothness and shorten path length. The planner grows two trees alternately, samples with goal bias and informed sampling when available, connects trees when possible, rewires nodes within a dynamic radius based on tree size and dimension for path improvement, and applies shortcutting regularly during planning to enhance path smoothness and reduce planning time.",
            "planning_mechanism": "The planner alternately expands two trees from start and goal, using a probabilistic goal bias combined with adaptive informed sampling inside an ellipsoidal subset of the search space bounded by the current best path cost to efficiently explore relevant regions. Each expansion step selects the nearest node, steers toward the sample within step size, performs collision checks, and attempts rewirings in an adaptively scaled neighborhood radius for path quality optimization. Upon connecting both trees, the path is extracted and progressively shortcut during planning iterations to smooth and shorten it, which significantly improves convergence speed, path length and smoothness, while reducing overall planning time.",
            "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n    def add_child(self, child):\n        self.children.append(child)\nclass Planner:\n    def __init__(self, max_iter=4000, step_size=6.0, radius_constant=30.0, goal_bias=0.15, shortcut_interval=40):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.radius_constant = radius_constant\n        self.goal_bias = goal_bias\n        self.shortcut_interval = shortcut_interval\n\n    def plan(self, map):\n        import random\n        import math\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = (len(bounds) == 3)\n        dim = 3 if is_3d else 2\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        best_cost = float('inf')\n        solution_start, solution_goal = None, None\n\n        c_min = math.dist(start_pos, goal_pos)\n\n        for iter in range(self.max_iter):\n            # Sample with goal bias and informed sampling if best cost known\n            if best_cost < float('inf'):\n                if random.random() < self.goal_bias:\n                    sample = goal_pos\n                else:\n                    sample = self._informed_sample(bounds, obstacles, is_3d, start_pos, goal_pos, best_cost, c_min)\n            else:\n                sample = self._sample_free(bounds, obstacles, is_3d)\n\n            # Expand both trees alternately\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest = self._nearest(tree_a, sample)\n                new_pos = self._steer(nearest.position, sample, self.step_size)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                    continue\n\n                new_node = Node(new_pos)\n                # Adaptive radius based on tree size and dimension\n                radius = min(self.radius_constant * ((math.log(len(tree_a)+1) / (len(tree_a)+1))**(1/dim)), self.step_size*30)\n\n                near_nodes = self._near(tree_a, new_pos, radius)\n\n                # Choose best parent among near nodes\n                min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n                min_parent = nearest\n                for near in near_nodes:\n                    tentative_cost = near.cost + math.dist(near.position, new_pos)\n                    if tentative_cost < min_cost and not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d):\n                        min_cost = tentative_cost\n                        min_parent = near\n\n                new_node.parent = min_parent\n                new_node.cost = min_cost\n                min_parent.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((min_parent, new_node))\n\n                # Rewire near nodes to new_node if beneficial\n                for near in near_nodes:\n                    if near is min_parent:\n                        continue\n                    new_cost = new_node.cost + math.dist(new_node.position, near.position)\n                    if new_cost < near.cost and not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                        if near.parent:\n                            try:\n                                edges.remove((near.parent, near))\n                            except ValueError:\n                                pass\n                            try:\n                                near.parent.children.remove(near)\n                            except ValueError:\n                                pass\n                        near.parent = new_node\n                        near.cost = new_cost\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n\n                # Attempt to connect trees\n                connect_node = self._nearest(tree_b, new_node.position)\n                dist_connect = math.dist(new_node.position, connect_node.position)\n                if dist_connect <= self.step_size and not self._is_edge_in_obstacle(new_node.position, connect_node.position, obstacles, is_3d):\n                    path_cost = new_node.cost + dist_connect + connect_node.cost\n                    if path_cost < best_cost:\n                        best_cost = path_cost\n                        if tree_a is start_tree:\n                            solution_start, solution_goal = new_node, connect_node\n                        else:\n                            solution_start, solution_goal = connect_node, new_node\n\n            # Progressive shortcutting applied regularly\n            if best_cost < float('inf') and solution_start and solution_goal and (iter % self.shortcut_interval == 0 or iter == self.max_iter - 1):\n                raw_path = self._extract_path(solution_start, solution_goal)\n                shortcut_path = self._shortcut_path(raw_path, obstacles, is_3d, max_attempts=60)\n                if shortcut_path:\n                    return PlannerResult(True, shortcut_path, nodes, edges)\n\n        return PlannerResult(False, [], nodes, edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        import random\n        while True:\n            pt = tuple(random.uniform(0, bounds[i]) for i in range(len(bounds)))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def _informed_sample(self, bounds, obstacles, is_3d, start, goal, c_max, c_min):\n        import random\n        import math\n        dim = 3 if is_3d else 2\n        if c_max <= c_min:\n            return self._sample_free(bounds, obstacles, is_3d)\n\n        center = tuple((start[i]+goal[i])/2 for i in range(dim))\n        dir_vec = [goal[i]-start[i] for i in range(dim)]\n        length = math.dist(start, goal)\n        if length == 0:\n            return self._sample_free(bounds, obstacles, is_3d)\n\n        if dim == 2:\n            a1 = [1,0]\n            a2 = [dir_vec[0]/length, dir_vec[1]/length]\n            cos_theta = a1[0]*a2[0] + a1[1]*a2[1]\n            sin_theta = a1[0]*a2[1] - a1[1]*a2[0]\n            R = [[cos_theta, -sin_theta],[sin_theta, cos_theta]]\n        else:\n            from math import sqrt\n            a1 = [1,0,0]\n            a2 = [dir_vec[i]/length for i in range(3)]\n            v = [a1[1]*a2[2]-a1[2]*a2[1], a1[2]*a2[0]-a1[0]*a2[2], a1[0]*a2[1]-a1[1]*a2[0]]\n            s = sqrt(sum([vi*vi for vi in v]))\n            c = sum([a1[i]*a2[i] for i in range(3)])\n            if s == 0:\n                R = [[1,0,0],[0,1,0],[0,0,1]]\n            else:\n                vx = [[0,-v[2],v[1]],[v[2],0,-v[0]],[-v[1],v[0],0]]\n                I = [[1 if i==j else 0 for j in range(3)] for i in range(3)]\n                vx2 = [[sum(vx[i][k]*vx[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n                R = [[I[i][j] + vx[i][j] + vx2[i][j]*((1 - c)/(s**2)) for j in range(3)] for i in range(3)]\n\n        if dim == 2:\n            r = random.uniform(0,1)**0.5\n            theta = random.uniform(0, 2*math.pi)\n            x_ball = [r*math.cos(theta), r*math.sin(theta)]\n        else:\n            while True:\n                x_ball = [random.uniform(-1,1) for _ in range(3)]\n                if sum(xi*xi for xi in x_ball) <= 1:\n                    break\n\n        a1_val = c_max / 2.0\n        a_other = math.sqrt(c_max**2 - c_min**2) / 2.0\n\n        if dim == 2:\n            L = [[a1_val, 0],[0, a_other]]\n            x_scaled = [L[0][0]*x_ball[0] + L[0][1]*x_ball[1],\n                        L[1][0]*x_ball[0] + L[1][1]*x_ball[1]]\n            pt = (center[0] + R[0][0]*x_scaled[0] + R[0][1]*x_scaled[1],\n                  center[1] + R[1][0]*x_scaled[0] + R[1][1]*x_scaled[1])\n        else:\n            L = [[a1_val, 0, 0],[0, a_other, 0],[0, 0, a_other]]\n            x_scaled = [L[0][0]*x_ball[0], L[1][1]*x_ball[1], L[2][2]*x_ball[2]]\n            pt = tuple(center[i] + sum(R[i][j]*x_scaled[j] for j in range(3)) for i in range(3))\n\n        if any(pt[d] < 0 or pt[d] > bounds[d] for d in range(dim)):\n            return self._sample_free(bounds, obstacles, is_3d)\n        if self._is_in_obstacle(pt, obstacles, is_3d):\n            return self._sample_free(bounds, obstacles, is_3d)\n\n        return pt\n\n    def _nearest(self, tree, point):\n        import math\n        return min(tree, key=lambda n: math.dist(n.position, point))\n\n    def _near(self, tree, point, radius):\n        r_sq = radius*radius\n        return [n for n in tree if sum((n.position[i]-point[i])**2 for i in range(len(point))) <= r_sq]\n\n    def _steer(self, from_pos, to_pos, step_size):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        if dist <= step_size:\n            return to_pos\n        ratio = step_size / dist\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i])*ratio for i in range(len(from_pos)))\n\n    def _extract_path(self, node_start, node_goal):\n        path_start, path_goal = [], []\n        n = node_start\n        while n:\n            path_start.append(n.position)\n            n = n.parent\n        n = node_goal\n        while n:\n            path_goal.append(n.position)\n            n = n.parent\n        return list(reversed(path_start)) + path_goal\n\n    def _shortcut_path(self, path, obstacles, is_3d, max_attempts=60):\n        if len(path) < 3:\n            return path[:]\n        import random\n        new_path = path[:]\n        attempts = 0\n        while attempts < max_attempts:\n            if len(new_path) < 3:\n                break\n            i = random.randint(0, len(new_path)-3)\n            j = random.randint(i+2, len(new_path)-1)\n            if not self._is_edge_in_obstacle(new_path[i], new_path[j], obstacles, is_3d):\n                new_path = new_path[:i+1] + new_path[j:]\n                attempts = 0\n            else:\n                attempts += 1\n        return new_path\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x,y,z,w,h,d = obs\n                px,py,pz = pos\n                if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                    return True\n            else:\n                x,y,w,h = obs\n                px,py = pos\n                if x <= px <= x+w and y <= py <= y+h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist/resolution))\n        for i in range(steps+1):\n            interp = tuple(from_pos[d] + (to_pos[d]-from_pos[d])*(i/steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
            "objective": -22.60434,
            "time_improvement": 28.0,
            "length_improvement": 11.0,
            "smoothness_improvement": 1504.0,
            "node_improvement": 68.0,
            "other_inf": [
                {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.021024632453918456,
                    "num_nodes_avg": 149.4,
                    "path_length_avg": 179.86562069368742,
                    "smoothness_avg": 0.04340391432894737,
                    "success_improvement": 0.0,
                    "time_improvement": 18.480140883479937,
                    "node_improvement": 62.37723495341224,
                    "length_improvement": 1.41280314464036,
                    "smoothness_improvement": 579.365512356565,
                    "objective_score": 9.288551713611021
                },
                {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.02810840606689453,
                    "num_nodes_avg": 272.4,
                    "path_length_avg": 245.75216437677005,
                    "smoothness_avg": 0.0991357257905606,
                    "success_improvement": 0.0,
                    "time_improvement": 83.02383326220045,
                    "node_improvement": 81.69723845998791,
                    "length_improvement": 17.960853947188074,
                    "smoothness_improvement": 2450.8336291682162,
                    "objective_score": 47.93783049281406
                },
                {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.0594691276550293,
                    "num_nodes_avg": 313.1,
                    "path_length_avg": 129.64938979692397,
                    "smoothness_avg": 0.1243235500601021,
                    "success_improvement": 0.0,
                    "time_improvement": -17.187058813027633,
                    "node_improvement": 60.19071837253656,
                    "length_improvement": 13.893048537397146,
                    "smoothness_improvement": 1481.3863801545947,
                    "objective_score": 10.586643379302972
                }
            ],
            "success_rate": 1.0
        },
        "objective": 802.4,
        "analysis": {
            "problem": [
                "Problem of the parents algorithm:\n   - Limited or fixed-radius rewiring mechanisms leading to less effective path optimization and lower smoothness.\n   - Lack of integrated goal bias in sampling, resulting in slower convergence towards the goal.\n   - Infrequent or insufficient shortcutting attempts, reducing the opportunity to smooth and shorten the path.\n   - Static tree expansion without adaptive neighborhood scaling, potentially causing inefficient rewiring and exploration.\n   - Tree connection procedures that may introduce redundant nodes or do not efficiently optimize the path cost."
            ],
            "solution": "1. Primary contributors to the performance improvement:\n   - Implementation of adaptive radius rewiring that scales with tree size and dimensionality to enhance local path optimization.\n   - Incorporation of probabilistic goal bias sampling combined with informed sampling to focus exploration around promising regions.\n   - Increased frequency and maximum attempts of progressive shortcutting to significantly improve path smoothness and length.\n   - Balanced bidirectional tree expansion with better parent selection and rewiring strategies to reduce unnecessary edges.\n2. Expected mechanism of impact:\n   - Adaptive rewiring dynamically improves the connectivity and cost-effectiveness of the growing trees, resulting in smoother, shorter paths.\n   - Goal bias and adaptive sampling focus computations in relevant search space areas, reducing planning time.\n   - More aggressive and frequent shortcutting removes redundant waypoints, enhancing smoothness and reducing path length.\n   - Efficient tree connection and rewiring reduce redundant expansions and improve convergence speed, collectively enhancing overall planning performance."
        }
    },
    {
        "parents": [
            {
                "operator": "m3",
                "algorithm_description": "A simplified bidirectional RRT* planner that grows two trees alternately with goal-biased sampling and radius-based rewiring for improved path quality and efficiency. The planner avoids costly adaptive radius calculations by using a fixed radius and performs basic shortcutting after connection to reduce path length.",
                "planning_mechanism": "The planner alternately expands start and goal trees by sampling free space biased to the goal. New nodes are connected based on a fixed rewiring radius to optimize local path cost. When trees connect, the combined path is extracted and simplified by shortcutting to improve smoothness and length before returning the solution.",
                "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\nclass Planner:\n    def __init__(self, max_iter=3000, step_size=5.0, goal_sample_rate=0.1, radius=10.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.radius = radius\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n\n        start_tree = [Node(start)]\n        goal_tree = [Node(goal)]\n        edges = []\n        success = False\n        final_path = []\n\n        for iter in range(self.max_iter):\n            sample = goal if random.random() < self.goal_sample_rate else self._sample_free(bounds, obstacles, dim)\n\n            # Alternate expansion order\n            grow_orders = [(start_tree, goal_tree), (goal_tree, start_tree)]\n            active_tree, other_tree = grow_orders[iter % 2]\n\n            nearest = self._nearest(active_tree, sample)\n            new_pos = self._steer(nearest.position, sample, self.step_size)\n            if self._is_in_obstacle(new_pos, obstacles, dim):\n                continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, dim):\n                continue\n\n            new_node = Node(new_pos)\n            near_nodes = self._near(active_tree, new_pos, self.radius)\n            min_cost = nearest.cost + self._distance(nearest.position, new_pos)\n            min_parent = nearest\n\n            for near in near_nodes:\n                cost = near.cost + self._distance(near.position, new_pos)\n                if cost < min_cost and not self._is_edge_in_obstacle(near.position, new_pos, obstacles, dim):\n                    min_cost = cost\n                    min_parent = near\n\n            new_node.parent = min_parent\n            new_node.cost = min_cost\n            min_parent.add_child(new_node)\n            active_tree.append(new_node)\n            edges.append((min_parent, new_node))\n\n            # Rewire near nodes\n            for near in near_nodes:\n                if near is min_parent:\n                    continue\n                new_cost = new_node.cost + self._distance(new_node.position, near.position)\n                if new_cost < near.cost and not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, dim):\n                    if near.parent:\n                        try:\n                            edges.remove((near.parent, near))\n                        except ValueError:\n                            pass\n                        near.parent.children.remove(near)\n                    near.parent = new_node\n                    near.cost = new_cost\n                    new_node.add_child(near)\n                    edges.append((new_node, near))\n\n            connect_node = self._nearest(other_tree, new_node.position)\n            dist = self._distance(new_node.position, connect_node.position)\n            if dist <= self.step_size and not self._is_edge_in_obstacle(new_node.position, connect_node.position, obstacles, dim):\n                success = True\n                path = self._extract_path(new_node, connect_node)\n                final_path = self._shortcut_path(path, obstacles, dim)\n                return PlannerResult(True, final_path, start_tree + goal_tree, edges)\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    def _sample_free(self, bounds, obstacles, dim):\n        while True:\n            point = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n            if not self._is_in_obstacle(point, obstacles, dim):\n                return point\n\n    def _nearest(self, tree, point):\n        best = None\n        best_dist = float('inf')\n        for node in tree:\n            dist = self._distance(node.position, point)\n            if dist < best_dist:\n                best_dist = dist\n                best = node\n        return best\n\n    def _near(self, tree, point, radius):\n        r_sq = radius * radius\n        res = []\n        for node in tree:\n            if self._distance_sq(node.position, point) <= r_sq:\n                res.append(node)\n        return res\n\n    def _steer(self, from_pos, to_pos, step_size):\n        dist = self._distance(from_pos, to_pos)\n        if dist <= step_size:\n            return to_pos\n        ratio = step_size / dist\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n    def _distance(self, a, b):\n        return sum((a[i] - b[i])**2 for i in range(len(a)))**0.5\n\n    def _distance_sq(self, a, b):\n        return sum((a[i] - b[i]) ** 2 for i in range(len(a)))\n\n    def _is_in_obstacle(self, pos, obstacles, dim):\n        if dim == 3:\n            px, py, pz = pos\n            for obs in obstacles:\n                x, y, z, w, h, d = obs\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n        else:\n            px, py = pos\n            for obs in obstacles:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, start, end, obstacles, dim, resolution=0.5):\n        dist = self._distance(start, end)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(start[j] + (end[j] - start[j]) * i / steps for j in range(dim))\n            if self._is_in_obstacle(interp, obstacles, dim):\n                return True\n        return False\n\n    def _extract_path(self, node_a, node_b):\n        path_a = []\n        while node_a:\n            path_a.append(node_a.position)\n            node_a = node_a.parent\n        path_b = []\n        while node_b:\n            path_b.append(node_b.position)\n            node_b = node_b.parent\n        return list(reversed(path_a)) + path_b\n\n    def _shortcut_path(self, path, obstacles, dim, max_attempts=60):\n        path = path[:]\n        n = len(path)\n        if n < 3:\n            return path\n        attempts = 0\n        while attempts < max_attempts:\n            if len(path) < 3:\n                break\n            i = random.randint(0, len(path) - 3)\n            j = random.randint(i + 2, len(path) - 1)\n            if not self._is_edge_in_obstacle(path[i], path[j], obstacles, dim):\n                del path[i+1:j]\n            attempts += 1\n        return path",
                "objective": 29.44466,
                "time_improvement": -89.0,
                "length_improvement": 14.0,
                "smoothness_improvement": 1095.0,
                "node_improvement": 62.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.057877111434936526,
                        "num_nodes_avg": 191.6,
                        "path_length_avg": 179.5990760833037,
                        "smoothness_avg": 0.029601785789212263,
                        "success_improvement": 0.0,
                        "time_improvement": -124.4098193197103,
                        "node_improvement": 51.75018886930245,
                        "length_improvement": 1.5589004692613202,
                        "smoothness_improvement": 363.3322289078712,
                        "objective_score": -34.57094436981694
                    },
                    {
                        "map_id": 1,
                        "success_rate": 0.9,
                        "time_avg": 0.08499889373779297,
                        "num_nodes_avg": 309.7,
                        "path_length_avg": 237.08159559281012,
                        "smoothness_avg": 0.07809325221118524,
                        "success_improvement": -9.999999999999998,
                        "time_improvement": 48.66463117164223,
                        "node_improvement": 79.19102331519183,
                        "length_improvement": 20.855339375758646,
                        "smoothness_improvement": 1909.3956276897907,
                        "objective_score": -13.340428884603185
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.1474992275238037,
                        "num_nodes_avg": 343.5,
                        "path_length_avg": 121.17184534181081,
                        "smoothness_avg": 0.08741921392895938,
                        "success_improvement": 0.0,
                        "time_improvement": -190.65502273676515,
                        "node_improvement": 56.32549268912905,
                        "length_improvement": 19.523429907196746,
                        "smoothness_improvement": 1011.9659485611995,
                        "objective_score": -40.4226191339055
                    }
                ],
                "success_rate": 0.9666666666666667
            }
        ],
        "offspring": {
            "operator": "m3",
            "algorithm_description": "A streamlined bidirectional RRT* planner that alternates tree expansions with goal bias, fixed-radius rewiring, and straightforward path shortcutting for efficient planning and improved path quality. It uses simple nearest neighbor searches and basic collision checks to maintain clarity and generalizability.",
            "planning_mechanism": "The planner grows two trees from start and goal alternately, samples points biased towards the goal, connects nodes using fixed step sizes and radius for rewiring, and upon connecting the trees, extracts and shortcuts the path to reduce length and improve smoothness.",
            "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\nclass Planner:\n    def __init__(self, max_iter=3000, step_size=5.0, goal_sample_rate=0.1, radius=10.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.radius = radius\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n\n        start_tree = [Node(start)]\n        goal_tree = [Node(goal)]\n        edges = []\n        for i in range(self.max_iter):\n            sample = goal if self._random() < self.goal_sample_rate else self._sample_free(bounds, obstacles, dim)\n\n            trees = [(start_tree, goal_tree), (goal_tree, start_tree)]\n            active_tree, other_tree = trees[i % 2]\n\n            nearest = self._nearest(active_tree, sample)\n            new_pos = self._steer(nearest.position, sample, self.step_size)\n            if self._collides(new_pos, obstacles, dim):\n                continue\n            if self._edge_collides(nearest.position, new_pos, obstacles, dim):\n                continue\n\n            new_node = Node(new_pos)\n            near_nodes = self._near(active_tree, new_pos, self.radius)\n            min_cost, min_parent = nearest.cost + self._dist(nearest.position, new_pos), nearest\n\n            for near in near_nodes:\n                cost = near.cost + self._dist(near.position, new_pos)\n                if cost < min_cost and not self._edge_collides(near.position, new_pos, obstacles, dim):\n                    min_cost, min_parent = cost, near\n\n            new_node.parent = min_parent\n            new_node.cost = min_cost\n            min_parent.add_child(new_node)\n            active_tree.append(new_node)\n            edges.append((min_parent, new_node))\n\n            for near in near_nodes:\n                if near is min_parent:\n                    continue\n                new_cost = new_node.cost + self._dist(new_node.position, near.position)\n                if new_cost < near.cost and not self._edge_collides(new_node.position, near.position, obstacles, dim):\n                    if near.parent:\n                        try:\n                            edges.remove((near.parent, near))\n                        except ValueError:\n                            pass\n                        near.parent.children.remove(near)\n                    near.parent = new_node\n                    near.cost = new_cost\n                    new_node.add_child(near)\n                    edges.append((new_node, near))\n\n            connect_node = self._nearest(other_tree, new_node.position)\n            if self._dist(new_node.position, connect_node.position) <= self.step_size and not self._edge_collides(new_node.position, connect_node.position, obstacles, dim):\n                path = self._extract_path(new_node, connect_node)\n                path = self._shortcut_path(path, obstacles, dim)\n                return PlannerResult(True, path, start_tree + goal_tree, edges)\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    def _sample_free(self, bounds, obstacles, dim):\n        while True:\n            point = tuple(self._random() * bounds[i] for i in range(dim))\n            if not self._collides(point, obstacles, dim):\n                return point\n\n    def _nearest(self, tree, point):\n        best, best_dist = None, float('inf')\n        for node in tree:\n            dist = self._dist(node.position, point)\n            if dist < best_dist:\n                best, best_dist = node, dist\n        return best\n\n    def _near(self, tree, point, radius):\n        r_sq = radius * radius\n        return [node for node in tree if self._dist_sq(node.position, point) <= r_sq]\n\n    def _steer(self, from_pos, to_pos, step):\n        dist = self._dist(from_pos, to_pos)\n        if dist <= step:\n            return to_pos\n        ratio = step / dist\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n    def _dist(self, a, b):\n        return self._dist_sq(a, b) ** 0.5\n\n    def _dist_sq(self, a, b):\n        return sum((a[i] - b[i]) ** 2 for i in range(len(a)))\n\n    def _collides(self, pos, obstacles, dim):\n        if dim == 3:\n            x, y, z = pos\n            for obs in obstacles:\n                ox, oy, oz, w, h, d = obs\n                if ox <= x <= ox + w and oy <= y <= oy + h and oz <= z <= oz + d:\n                    return True\n        else:\n            x, y = pos\n            for obs in obstacles:\n                ox, oy, w, h = obs\n                if ox <= x <= ox + w and oy <= y <= oy + h:\n                    return True\n        return False\n\n    def _edge_collides(self, start, end, obstacles, dim, resolution=0.5):\n        dist = self._dist(start, end)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            point = tuple(start[j] + (end[j] - start[j]) * i / steps for j in range(dim))\n            if self._collides(point, obstacles, dim):\n                return True\n        return False\n\n    def _extract_path(self, node_a, node_b):\n        path_a = []\n        while node_a:\n            path_a.append(node_a.position)\n            node_a = node_a.parent\n        path_b = []\n        while node_b:\n            path_b.append(node_b.position)\n            node_b = node_b.parent\n        return list(reversed(path_a)) + path_b\n\n    def _shortcut_path(self, path, obstacles, dim, max_attempts=40):\n        path = path[:]\n        attempts = 0\n        while attempts < max_attempts and len(path) > 2:\n            i = int(self._random() * (len(path) - 2))\n            j = int(i + 2 + self._random() * (len(path) - i - 2))\n            if j >= len(path):\n                j = len(path) - 1\n            if not self._edge_collides(path[i], path[j], obstacles, dim):\n                del path[i+1:j]\n            attempts += 1\n        return path\n\n    def _random(self):\n        # To allow testing replace with random.random(), here stub for determinism if needed\n        import random\n        return random.random()",
            "objective": -6.82375,
            "time_improvement": -25.0,
            "length_improvement": 16.0,
            "smoothness_improvement": 998.0,
            "node_improvement": 69.0,
            "other_inf": [
                {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.04590208530426025,
                    "num_nodes_avg": 161.1,
                    "path_length_avg": 170.32708573767837,
                    "smoothness_avg": 0.02884305512385804,
                    "success_improvement": 0.0,
                    "time_improvement": -77.97845148348269,
                    "node_improvement": 59.430873835305974,
                    "length_improvement": 6.641025301787684,
                    "smoothness_improvement": 351.4564463850669,
                    "objective_score": -17.65163803204686
                },
                {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.09899413585662842,
                    "num_nodes_avg": 319.9,
                    "path_length_avg": 232.70596040537356,
                    "smoothness_avg": 0.06308823090997337,
                    "success_improvement": 0.0,
                    "time_improvement": 40.21215744617372,
                    "node_improvement": 78.50567761875966,
                    "length_improvement": 22.316052347000596,
                    "smoothness_improvement": 1523.3056219296157,
                    "objective_score": 33.069806751700554
                },
                {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.06967871189117432,
                    "num_nodes_avg": 249.0,
                    "path_length_avg": 123.85483726002462,
                    "smoothness_avg": 0.09591030345606508,
                    "success_improvement": 0.0,
                    "time_improvement": -37.30558409690246,
                    "node_improvement": 68.34075015893197,
                    "length_improvement": 17.741514425465155,
                    "smoothness_improvement": 1119.97198059895,
                    "objective_score": 5.053093329203105
                }
            ],
            "success_rate": 1.0
        },
        "objective": 637.5999999999999,
        "analysis": {
            "problem": [
                "Problem of the parents algorithm:\n   - Alternating tree expansion without sufficient control leads to redundant computations and inefficient exploration.\n   - Rewiring operations and neighborhood searches were performed with simple linear methods, causing computational overhead.\n   - Path extraction and shortcutting parameters were limited, resulting in less effective path smoothing and suboptimal solution quality."
            ],
            "solution": "1. Primary contributors to the performance improvement:\n   - Enhanced randomness control in sampling and improved shortcutting strategy reduced unnecessary waypoint retention in the path.\n   - Streamlined collision checking minimized redundant edge validations, improving planning speed stability and path refinement.\n2. Expected mechanism of impact:\n   - Reduced path complexity through more effective shortcutting results in smoother trajectories.\n   - More efficient pruning and rewiring lead to shorter and less jagged paths, contributing to improved smoothness metrics without sacrificing solution feasibility."
        }
    },
    {
        "parents": [
            {
                "operator": "e1",
                "algorithm_description": "A bidirectional informed RRT* with adaptive sampling and post-processing path shortcutting. The algorithm grows two trees from start and goal, but restricts sampling within an ellipsoidal region (informed sampling) to focus search around the best solution path. It performs rewiring to optimize local connections and applies an efficient post-processing shortcutting procedure to smooth the final path, which improves path quality and smoothness while reducing planning time.",
                "planning_mechanism": "The planner alternates expanding two trees by sampling random points within an informed ellipsoidal subset after an initial solution is found. It performs steer, collision checks, rewiring, and attempts to connect the trees continuously. Upon success, it extracts the path and applies post-processing shortcutting to remove unnecessary waypoints and smooth sharp turns, leading to a shorter, smoother trajectory with improved efficiency.",
                "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n    def add_child(self, child):\n        self.children.append(child)\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=7.0, radius=15.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.radius = radius\n\n    def plan(self, map):\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = (len(bounds) == 3)\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = []\n        edges = []\n\n        best_path_cost = float('inf')\n        solution_node_start = None\n        solution_node_goal = None\n\n        # Basic heuristic distance for informed sampling\n        c_min = self._distance(start_pos, goal_pos)\n\n        for i in range(self.max_iter):\n            if solution_node_start and solution_node_goal:\n                # Informed sampling inside ellipsoid bounding current best path cost\n                sample = self._informed_sample(bounds, obstacles, is_3d, start_pos, goal_pos, best_path_cost, c_min)\n            else:\n                # Uniform random sampling within bounds free space\n                sample = self._sample_free(bounds, obstacles, is_3d)\n\n            for tree_a, tree_b in [(start_tree,goal_tree),(goal_tree,start_tree)]:\n                nearest = self._nearest(tree_a, sample)\n                new_pos = self._steer(nearest.position, sample, self.step_size)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d): continue\n                if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d): continue\n\n                new_node = Node(new_pos)\n                near_nodes = self._near(tree_a, new_pos, self.radius)\n\n                # Choose best parent among near nodes considering path cost and collision\n                min_cost = nearest.cost + self._distance(nearest.position, new_pos)\n                min_parent = nearest\n                for near in near_nodes:\n                    tent_cost = near.cost + self._distance(near.position, new_pos)\n                    if tent_cost < min_cost and not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d):\n                        min_cost = tent_cost\n                        min_parent = near\n\n                new_node.parent = min_parent\n                new_node.cost = min_cost\n                min_parent.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((min_parent, new_node))\n\n                # Rewire neighbors if new node offers a better path\n                for near in near_nodes:\n                    if near == min_parent: continue\n                    new_cost = new_node.cost + self._distance(new_node.position, near.position)\n                    if new_cost < near.cost and not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                        if near.parent:\n                            try: edges.remove((near.parent, near))\n                            except ValueError: pass\n                        near.parent = new_node\n                        near.cost = new_cost\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n\n                # Try to connect to tree_b within step size and collision free\n                connect_node = self._nearest(tree_b, new_node.position)\n                if self._distance(new_node.position, connect_node.position) <= self.step_size:\n                    if not self._is_edge_in_obstacle(new_node.position, connect_node.position, obstacles, is_3d):\n                        # Construct candidate path cost\n                        path_cost = new_node.cost + self._distance(new_node.position, connect_node.position) + connect_node.cost\n                        if path_cost < best_path_cost:\n                            best_path_cost = path_cost\n                            solution_node_start, solution_node_goal = (new_node, connect_node) if tree_a is start_tree else (connect_node, new_node)\n                        # We can continue to iterate to improve path\n\n            if best_path_cost < float('inf') and (i % 100 == 0 or i == self.max_iter -1):\n                # Extract and shortcut path every 100 iterations or at end for smoother solution\n                raw_path = self._extract_path(solution_node_start, solution_node_goal)\n                shortcut_path = self._shortcut_path(raw_path, obstacles, is_3d)\n                if shortcut_path:\n                    return PlannerResult(True, shortcut_path, start_tree + goal_tree, edges)\n\n        # No solution found; return empty path\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        while True:\n            pt = tuple(random.uniform(0, bounds[i]) for i in range(3 if is_3d else 2))\n            if not self._is_in_obstacle(pt, obstacles, is_3d): return pt\n\n    def _informed_sample(self, bounds, obstacles, is_3d, start, goal, c_max, c_min):\n        # Sample inside prolate hyperspheroid (ellipsoid) defined by start, goal, and current best cost c_max\n        # Reduces sampling space to focus search near optimal path\n        dim = 3 if is_3d else 2\n        while True:\n            # Sample unit ball point\n            if dim == 2:\n                r = random.uniform(0,1) ** 0.5\n                theta = random.uniform(0, 2*math.pi)\n                x_ball = [r * math.cos(theta), r * math.sin(theta)]\n            else:\n                # Sample from 3D ball\n                while True:\n                    x_ball = [random.uniform(-1,1), random.uniform(-1,1), random.uniform(-1,1)]\n                    if sum([xi*xi for xi in x_ball]) <= 1: break\n            # Calculate transformation parameters\n            c = c_max\n            if c == float('inf') or c <= c_min:\n                # No current solution, uniform sample\n                pt = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not self._is_in_obstacle(pt, obstacles, is_3d): return pt\n\n            center = tuple((start[i] + goal[i]) / 2 for i in range(dim))\n            dir_vec = [goal[i] - start[i] for i in range(dim)]\n            length = math.dist(start, goal)\n            # Compute rotation matrix from canonical axis to direction vector\n            if dim == 2:\n                if length == 0:\n                    R = [[1,0],[0,1]]\n                else:\n                    a1 = [1,0]\n                    a2 = [dir_vec[0]/length, dir_vec[1]/length]\n                    cos_theta = a1[0]*a2[0] + a1[1]*a2[1]\n                    sin_theta = a1[0]*a2[1] - a1[1]*a2[0]\n                    R = [[cos_theta, -sin_theta],[sin_theta, cos_theta]]\n            else:\n                # 3D rotation using axis-angle (rotation matrix)\n                from math import acos, sqrt\n                if length == 0:\n                    R = [[1,0,0],[0,1,0],[0,0,1]]\n                else:\n                    a1 = [1,0,0]\n                    a2 = [dir_vec[i]/length for i in range(3)]\n                    v = [a1[1]*a2[2]-a1[2]*a2[1], a1[2]*a2[0]-a1[0]*a2[2], a1[0]*a2[1]-a1[1]*a2[0]]\n                    s = sqrt(sum([vi*vi for vi in v]))\n                    c = sum([a1[i]*a2[i] for i in range(3)])\n                    if s == 0:\n                        R = [[1,0,0],[0,1,0],[0,0,1]]\n                    else:\n                        vx = [[0,-v[2],v[1]],[v[2],0,-v[0]],[-v[1],v[0],0]]\n                        I = [[1 if i==j else 0 for j in range(3)] for i in range(3)]\n                        vx2 = [[vx[0][0]*vx[0][0]+vx[0][1]*vx[1][0]+vx[0][2]*vx[2][0],\n                                vx[0][0]*vx[0][1]+vx[0][1]*vx[1][1]+vx[0][2]*vx[2][1],\n                                vx[0][0]*vx[0][2]+vx[0][1]*vx[1][2]+vx[0][2]*vx[2][2]],\n                               [vx[1][0]*vx[0][0]+vx[1][1]*vx[1][0]+vx[1][2]*vx[2][0],\n                                vx[1][0]*vx[0][1]+vx[1][1]*vx[1][1]+vx[1][2]*vx[2][1],\n                                vx[1][0]*vx[0][2]+vx[1][1]*vx[1][2]+vx[1][2]*vx[2][2]],\n                               [vx[2][0]*vx[0][0]+vx[2][1]*vx[1][0]+vx[2][2]*vx[2][0],\n                                vx[2][0]*vx[0][1]+vx[2][1]*vx[1][1]+vx[2][2]*vx[2][1],\n                                vx[2][0]*vx[0][2]+vx[2][1]*vx[1][2]+vx[2][2]*vx[2][2]]]\n                        R = [[I[i][j] + vx[i][j] + ((vx2[i][j]) * ((1 - c)/(s**2))) for j in range(3)] for i in range(3)]\n            # Compose scaling matrix\n            a1_val = c_max / 2.0\n            a_others = math.sqrt(c_max**2 - c_min**2) / 2.0\n            if dim == 2:\n                L = [[a1_val,0],[0,a_others]]\n                # Transform sample from unit ball: pos = R * L * x_ball + center\n                x_scaled = [L[0][0]*x_ball[0] + L[0][1]*x_ball[1], L[1][0]*x_ball[0] + L[1][1]*x_ball[1]]\n                pt = (center[0] + R[0][0]*x_scaled[0] + R[0][1]*x_scaled[1],\n                      center[1] + R[1][0]*x_scaled[0] + R[1][1]*x_scaled[1])\n            else:\n                L = [[a1_val,0,0],[0,a_others,0],[0,0,a_others]]\n                x_scaled = [L[0][0]*x_ball[0], L[1][1]*x_ball[1], L[2][2]*x_ball[2]]\n                pt = tuple(center[i] + sum(R[i][j]*x_scaled[j] for j in range(3)) for i in range(3))\n\n            # Reject points outside bounds or in obstacle\n            if any(pt[d] < 0 or pt[d] > bounds[d] for d in range(dim)):\n                continue\n            if self._is_in_obstacle(pt, obstacles, is_3d):\n                continue\n            return pt\n\n    def _nearest(self, tree, point):\n        return min(tree, key=lambda n: self._distance(n.position, point))\n\n    def _near(self, tree, point, radius):\n        radius_sq = radius * radius\n        return [node for node in tree if self._squared_distance(node.position, point) <= radius_sq]\n\n    def _steer(self, from_pos, to_pos, step_size):\n        dist = self._distance(from_pos, to_pos)\n        if dist <= step_size:\n            return to_pos\n        ratio = step_size / dist\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n    def _extract_path(self, node_start, node_goal):\n        path_start, path_goal = [], []\n        n = node_start\n        while n:\n            path_start.append(n.position)\n            n = n.parent\n        n = node_goal\n        while n:\n            path_goal.append(n.position)\n            n = n.parent\n        return list(reversed(path_start)) + path_goal\n\n    def _shortcut_path(self, path, obstacles, is_3d):\n        # Attempt to shortcut path by skipping intermediate nodes where direct edge collision free\n        if len(path) < 3:\n            return path[:]\n        shortcut_path = [path[0]]\n        i = 0\n        while i < len(path)-1:\n            j = len(path)-1\n            while j > i+1:\n                if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                    break\n                j -= 1\n            shortcut_path.append(path[j])\n            i = j\n        return shortcut_path\n\n    def _distance(self, a, b):\n        return math.dist(a, b)\n\n    def _squared_distance(self, a, b):\n        return sum((a[i] - b[i])**2 for i in range(len(a)))\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x,y,z,w,h,d = obs\n                px,py,pz = pos\n                if x<=px<=x+w and y<=py<=y+h and z<=pz<=z+d:\n                    return True\n            else:\n                x,y,w,h = obs\n                px,py = pos\n                if x<=px<=x+w and y<=py<=y+h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        dist = self._distance(from_pos, to_pos)\n        steps = max(1, int(dist/resolution))\n        for i in range(steps+1):\n            interp = tuple(from_pos[d] + (to_pos[d]-from_pos[d])*(i/steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
                "objective": -23.21547,
                "time_improvement": 21.0,
                "length_improvement": 16.0,
                "smoothness_improvement": 1469.0,
                "node_improvement": 68.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.025556087493896484,
                        "num_nodes_avg": 151.3,
                        "path_length_avg": 173.88763401105183,
                        "smoothness_avg": 0.047474639256938476,
                        "success_improvement": 0.0,
                        "time_improvement": 0.9101035826373128,
                        "node_improvement": 61.89876605389071,
                        "length_improvement": 4.689432372653788,
                        "smoothness_improvement": 643.0811972002915,
                        "objective_score": 6.302096484384924
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.031405282020568845,
                        "num_nodes_avg": 252.2,
                        "path_length_avg": 230.86304004149935,
                        "smoothness_avg": 0.09581397875517297,
                        "success_improvement": 0.0,
                        "time_improvement": 81.03267389975849,
                        "node_improvement": 83.05449170194181,
                        "length_improvement": 22.93127220998329,
                        "smoothness_improvement": 2365.362685390011,
                        "objective_score": 49.89537892286758
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.06047847270965576,
                        "num_nodes_avg": 317.2,
                        "path_length_avg": 119.93973012619429,
                        "smoothness_avg": 0.11787316210161418,
                        "success_improvement": 0.0,
                        "time_improvement": -19.176026584091733,
                        "node_improvement": 59.6694214876033,
                        "length_improvement": 20.341742166387515,
                        "smoothness_improvement": 1399.337921440741,
                        "objective_score": 13.448926931808694
                    }
                ],
                "success_rate": 1.0
            },
            {
                "operator": "m3",
                "algorithm_description": "An efficient bidirectional RRT* with adaptive informed sampling and incremental path shortcutting, focusing sampling within an ellipsoidal subset around the best path to accelerate convergence, combined with local rewiring for path optimization and progressive shortcutting to improve path smoothness and length while reducing planning time. The planner grows two trees from start and goal, alternately expanding toward sampled points focused by current best solution, connects the two trees when possible, rewires locally to optimize costs, and progressively shortcuts the path during planning for smoother results.",
                "planning_mechanism": "The planner alternates growth of two trees (start and goal) using adaptive informed sampling within an ellipsoidal subset defined by the current best path cost. At each iteration, a sample point is generated; nearest nodes are extended toward it with collision checking. The algorithm rewires nearby nodes to optimize path costs locally. Upon connecting both trees, it extracts the combined path and incrementally applies shortcutting to remove unnecessary waypoints and smooth the trajectory. This approach balances efficient exploration, path quality, and runtime performance.",
                "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n    def add_child(self, child):\n        self.children.append(child)\nclass Planner:\n    def __init__(self, max_iter=4000, step_size=6.0, radius=12.0, shortcut_interval=50):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.radius = radius\n        self.shortcut_interval = shortcut_interval\n\n    def plan(self, map):\n        import random\n        import math\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = (len(bounds) == 3)\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        best_cost = float('inf')\n        solution_start, solution_goal = None, None\n\n        c_min = math.dist(start_pos, goal_pos)\n        dim = 3 if is_3d else 2\n\n        for i in range(self.max_iter):\n            # Adaptive Sample\n            if best_cost < float('inf'):\n                sample = self._informed_sample(bounds, obstacles, is_3d, start_pos, goal_pos, best_cost, c_min)\n            else:\n                sample = self._sample_free(bounds, obstacles, is_3d)\n\n            # Alternate tree expansion\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest = self._nearest(tree_a, sample)\n                new_pos = self._steer(nearest.position, sample, self.step_size)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                    continue\n\n                new_node = Node(new_pos)\n                near_nodes = self._near(tree_a, new_pos, self.radius)\n\n                min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n                min_parent = nearest\n                for near in near_nodes:\n                    tentative_cost = near.cost + math.dist(near.position, new_pos)\n                    if tentative_cost < min_cost and not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d):\n                        min_cost = tentative_cost\n                        min_parent = near\n\n                new_node.parent = min_parent\n                new_node.cost = min_cost\n                min_parent.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((min_parent, new_node))\n\n                # Rewire near nodes to new_node if beneficial\n                for near in near_nodes:\n                    if near is min_parent:\n                        continue\n                    new_cost = new_node.cost + math.dist(new_node.position, near.position)\n                    if new_cost < near.cost and not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                        if near.parent:\n                            try: edges.remove((near.parent, near))\n                            except ValueError: pass\n                            # Remove near from old parent's children list safely\n                            try: near.parent.children.remove(near)\n                            except ValueError: pass\n                        near.parent = new_node\n                        near.cost = new_cost\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n\n                # Try to connect both trees to form path\n                connect_node = self._nearest(tree_b, new_node.position)\n                dist_connect = math.dist(new_node.position, connect_node.position)\n                if dist_connect <= self.step_size:\n                    if not self._is_edge_in_obstacle(new_node.position, connect_node.position, obstacles, is_3d):\n                        path_cost = new_node.cost + dist_connect + connect_node.cost\n                        if path_cost < best_cost:\n                            best_cost = path_cost\n                            if tree_a is start_tree:\n                                solution_start, solution_goal = new_node, connect_node\n                            else:\n                                solution_start, solution_goal = connect_node, new_node\n\n            # Progressive shortcutting for smoother path every shortcut_interval iterations\n            if best_cost < float('inf') and solution_start and solution_goal and (i % self.shortcut_interval == 0 or i == self.max_iter-1):\n                raw_path = self._extract_path(solution_start, solution_goal)\n                shortcut_path = self._shortcut_path(raw_path, obstacles, is_3d, max_attempts=50)\n                if shortcut_path:\n                    return PlannerResult(True, shortcut_path, nodes, edges)\n\n        # No solution found\n        return PlannerResult(False, [], nodes, edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        import random\n        while True:\n            pt = tuple(random.uniform(0, bounds[i]) for i in range(len(bounds)))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def _informed_sample(self, bounds, obstacles, is_3d, start, goal, c_max, c_min):\n        import random\n        import math\n        dim = 3 if is_3d else 2\n\n        # Reject sample if no valid ellipsoid (e.g. c_max <= c_min)\n        if c_max <= c_min:\n            return self._sample_free(bounds, obstacles, is_3d)\n\n        center = tuple((start[i]+goal[i])/2 for i in range(dim))\n        dir_vec = [goal[i]-start[i] for i in range(dim)]\n        length = math.dist(start, goal)\n        if length == 0:\n            # No interval, uniform sample fallback\n            return self._sample_free(bounds, obstacles, is_3d)\n\n        # Compute rotation matrix R from canonical axis to direction vector\n        if dim == 2:\n            a1 = [1,0]\n            a2 = [dir_vec[0]/length, dir_vec[1]/length]\n            cos_theta = a1[0]*a2[0] + a1[1]*a2[1]\n            sin_theta = a1[0]*a2[1] - a1[1]*a2[0]\n            R = [[cos_theta, -sin_theta],[sin_theta, cos_theta]]\n        else:\n            from math import sqrt\n            a1 = [1,0,0]\n            a2 = [dir_vec[i]/length for i in range(3)]\n            v = [a1[1]*a2[2]-a1[2]*a2[1], a1[2]*a2[0]-a1[0]*a2[2], a1[0]*a2[1]-a1[1]*a2[0]]\n            s = sqrt(sum([vi*vi for vi in v]))\n            c = sum([a1[i]*a2[i] for i in range(3)])\n            if s == 0:\n                R = [[1,0,0],[0,1,0],[0,0,1]]\n            else:\n                vx = [[0,-v[2],v[1]],[v[2],0,-v[0]],[-v[1],v[0],0]]\n                I = [[1 if i==j else 0 for j in range(3)] for i in range(3)]\n                vx2 = [[sum(vx[i][k]*vx[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n                R = [[I[i][j] + vx[i][j] + vx2[i][j]*((1 - c)/(s**2)) for j in range(3)] for i in range(3)]\n\n        # Sample point inside unit ball\n        if dim == 2:\n            r = random.uniform(0,1)**0.5\n            theta = random.uniform(0, 2*math.pi)\n            x_ball = [r*math.cos(theta), r*math.sin(theta)]\n        else:\n            while True:\n                x_ball = [random.uniform(-1,1) for _ in range(3)]\n                if sum(xi*xi for xi in x_ball) <= 1:\n                    break\n\n        a1_val = c_max / 2.0\n        a_other = math.sqrt(c_max**2 - c_min**2) / 2.0\n\n        # Scaling matrix\n        if dim == 2:\n            L = [[a1_val, 0],[0, a_other]]\n            x_scaled = [L[0][0]*x_ball[0] + L[0][1]*x_ball[1],\n                        L[1][0]*x_ball[0] + L[1][1]*x_ball[1]]\n            pt = (center[0] + R[0][0]*x_scaled[0] + R[0][1]*x_scaled[1],\n                  center[1] + R[1][0]*x_scaled[0] + R[1][1]*x_scaled[1])\n        else:\n            L = [[a1_val, 0, 0],[0, a_other, 0],[0, 0, a_other]]\n            x_scaled = [L[0][0]*x_ball[0], L[1][1]*x_ball[1], L[2][2]*x_ball[2]]\n            pt = tuple(center[i] + sum(R[i][j]*x_scaled[j] for j in range(3)) for i in range(3))\n\n        # Reject if outside bounds or in obstacle\n        if any(pt[d] < 0 or pt[d] > bounds[d] for d in range(dim)):\n            return self._sample_free(bounds, obstacles, is_3d)\n        if self._is_in_obstacle(pt, obstacles, is_3d):\n            return self._sample_free(bounds, obstacles, is_3d)\n\n        return pt\n\n    def _nearest(self, tree, point):\n        import math\n        return min(tree, key=lambda n: math.dist(n.position, point))\n\n    def _near(self, tree, point, radius):\n        r_sq = radius*radius\n        return [n for n in tree if sum((n.position[i]-point[i])**2 for i in range(len(point))) <= r_sq]\n\n    def _steer(self, from_pos, to_pos, step_size):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        if dist <= step_size:\n            return to_pos\n        ratio = step_size / dist\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i])*ratio for i in range(len(from_pos)))\n\n    def _extract_path(self, node_start, node_goal):\n        path_start, path_goal = [], []\n        n = node_start\n        while n:\n            path_start.append(n.position)\n            n = n.parent\n        n = node_goal\n        while n:\n            path_goal.append(n.position)\n            n = n.parent\n        return list(reversed(path_start)) + path_goal\n\n    def _shortcut_path(self, path, obstacles, is_3d, max_attempts=30):\n        # Attempt bounded shortcutting to improve smoothness by removing redundant waypoints\n        if len(path) < 3:\n            return path[:]\n        import random\n        new_path = path[:]\n        attempts = 0\n        while attempts < max_attempts:\n            if len(new_path) < 3:\n                break\n            i = random.randint(0, len(new_path)-3)\n            j = random.randint(i+2, len(new_path)-1)\n            if not self._is_edge_in_obstacle(new_path[i], new_path[j], obstacles, is_3d):\n                # Remove intermediate nodes between i and j\n                new_path = new_path[:i+1] + new_path[j:]\n                attempts = 0  # reset attempts after successful shortcut\n            else:\n                attempts += 1\n        return new_path\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x,y,z,w,h,d=obs\n                px,py,pz=pos\n                if x<=px<=x+w and y<=py<=y+h and z<=pz<=z+d:\n                    return True\n            else:\n                x,y,w,h=obs\n                px,py=pos\n                if x<=px<=x+w and y<=py<=y+h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist/resolution))\n        for i in range(steps+1):\n            interp = tuple(from_pos[d] + (to_pos[d]-from_pos[d])*(i/steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
                "objective": -30.55144,
                "time_improvement": 46.0,
                "length_improvement": 18.0,
                "smoothness_improvement": 1254.0,
                "node_improvement": 72.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.019833183288574217,
                        "num_nodes_avg": 147.4,
                        "path_length_avg": 162.65169192869433,
                        "smoothness_avg": 0.04547432196696187,
                        "success_improvement": 0.0,
                        "time_improvement": 23.09980633143671,
                        "node_improvement": 62.880886426592795,
                        "length_improvement": 10.848030272889844,
                        "smoothness_improvement": 611.7718878536382,
                        "objective_score": 16.49761950243311
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.023508524894714354,
                        "num_nodes_avg": 236.2,
                        "path_length_avg": 226.91038346862007,
                        "smoothness_avg": 0.07885871014571852,
                        "success_improvement": 0.0,
                        "time_improvement": 85.80194702529162,
                        "node_improvement": 84.12954377477658,
                        "length_improvement": 24.250782744921644,
                        "smoothness_improvement": 1929.091411682397,
                        "objective_score": 49.936510812952456
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.036681842803955075,
                        "num_nodes_avg": 255.1,
                        "path_length_avg": 123.45751291252664,
                        "smoothness_avg": 0.10380569995332274,
                        "success_improvement": 0.0,
                        "time_improvement": 27.71649022711396,
                        "node_improvement": 67.56516211061665,
                        "length_improvement": 18.005398338521033,
                        "smoothness_improvement": 1220.4008412665191,
                        "objective_score": 25.220190277579402
                    }
                ],
                "success_rate": 1.0
            }
        ],
        "offspring": {
            "operator": "e2",
            "algorithm_description": "A unified bidirectional RRT* planner leveraging ellipsoidal informed sampling, dynamic neighborhood radius scaling based on node density, and incremental path shortcutting to enhance efficiency, path length, and smoothness. It alternates tree expansions from start and goal states, samples intelligently within a biasing ellipsoid after initial solutions, rewires neighbors using an adaptive radius following theoretical optimal connection distances, and progressively shortcuts the current best path to maintain smoothness. This approach integrates adaptive rewiring radius, efficient collision checking with early exit, and continuous path refinement to robustly reduce planning time and improve path quality.",
            "planning_mechanism": "The planner maintains two rapidly exploring trees from start and goal, alternately extending them toward samples constrained inside an ellipsoidal informed subset after the first solution. It estimates an adaptive near radius based on theoretical RRT* bounds and current node count to optimize local rewiring. After each improved solution, it extracts and incrementally shortcuts the path to remove unnecessary waypoints and smooth turns, thus continuously improving path quality while minimizing overall runtime.",
            "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n    def add_child(self, child):\n        self.children.append(child)\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except ValueError:\n            pass\nclass Planner:\n    def __init__(self, max_iter=4500, step_size=6.5, gamma_rrt_star=50.0, shortcut_interval=40, max_shortcut_attempts=40):\n        # max_iter: max number of iterations\n        # step_size: max extension distance per step\n        # gamma_rrt_star: scaling factor for radius: typically > unit ball volume constant\n        # shortcut_interval: iterations frequency to apply path shortcutting\n        # max_shortcut_attempts: max attempts per incremental shortcutting\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.gamma_rrt_star = gamma_rrt_star\n        self.shortcut_interval = shortcut_interval\n        self.max_shortcut_attempts = max_shortcut_attempts\n\n    def plan(self, map):\n        import random\n        import math\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = (len(bounds) == 3)\n        dim = 3 if is_3d else 2\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        best_cost = float('inf')\n        solution_start, solution_goal = None, None\n        c_min = math.dist(start_pos, goal_pos)\n        volume_unit_ball = self._unit_ball_volume(dim)  # used for radius adapt\n\n        def near_radius(n_nodes):\n            # Adaptive near radius per RRT* theory: gamma * (log(n)/n)^{1/d}\n            if n_nodes <= 1:\n                return self.step_size * 2.5  # fallback large radius initially\n            return min(self.step_size * 50,\n                       self.gamma_rrt_star * (math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n\n        def attempt_connection(tree_a, tree_b, sample):\n            # Extend tree_a toward sample, rewire and try connecting with tree_b\n            nearest = self._nearest(tree_a, sample)\n            new_pos = self._steer(nearest.position, sample, self.step_size)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                return None\n\n            new_node = Node(new_pos)\n            radius = near_radius(len(tree_a))\n            near_nodes = self._near(tree_a, new_pos, radius)\n\n            min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n            min_parent = nearest\n            # Select best parent from near nodes with collision-check\n            for near in near_nodes:\n                tentative_cost = near.cost + math.dist(near.position, new_pos)\n                if tentative_cost < min_cost:\n                    if not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d):\n                        min_cost = tentative_cost\n                        min_parent = near\n\n            new_node.parent = min_parent\n            new_node.cost = min_cost\n            min_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((min_parent, new_node))\n\n            # Rewire neighbors to new_node if improves cost and collision-free\n            for near in near_nodes:\n                if near is min_parent:\n                    continue\n                new_cost = new_node.cost + math.dist(new_node.position, near.position)\n                if new_cost < near.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                        # Remove old edge\n                        if near.parent:\n                            try:\n                                edges.remove((near.parent, near))\n                            except ValueError:\n                                pass\n                            near.parent.remove_child(near)\n                        near.parent = new_node\n                        near.cost = new_cost\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n\n            # Attempt to connect new_node with nearest node in tree_b within step size\n            connect_candidate = self._nearest(tree_b, new_node.position)\n            dist_connect = math.dist(new_node.position, connect_candidate.position)\n            if dist_connect <= self.step_size:\n                if not self._is_edge_in_obstacle(new_node.position, connect_candidate.position, obstacles, is_3d):\n                    total_cost = new_node.cost + dist_connect + connect_candidate.cost\n                    if total_cost < best_cost:\n                        return new_node, connect_candidate, total_cost\n            return None\n\n        def informed_sample():\n            # Ellipsoidal informed sampling inside prolate hyperspheroid given current best_cost\n            if best_cost == float('inf') or best_cost <= c_min:\n                return self._sample_free(bounds, obstacles, is_3d)\n            center = tuple((start_pos[i] + goal_pos[i]) / 2 for i in range(dim))\n            dir_vec = [goal_pos[i] - start_pos[i] for i in range(dim)]\n            length = math.dist(start_pos, goal_pos)\n            # Compute rotation matrix R from canonical axis to direction\n            if dim == 2:\n                if length < 1e-10:\n                    R = [[1, 0], [0, 1]]\n                else:\n                    a1 = [1, 0]\n                    a2 = [dir_vec[0] / length, dir_vec[1] / length]\n                    cos_theta = a1[0] * a2[0] + a1[1] * a2[1]\n                    sin_theta = a1[0] * a2[1] - a1[1] * a2[0]\n                    R = [[cos_theta, -sin_theta], [sin_theta, cos_theta]]\n            else:\n                # 3D rotation matrix by axis-angle\n                from math import sqrt\n                if length < 1e-10:\n                    R = [[1,0,0],[0,1,0],[0,0,1]]\n                else:\n                    a1 = [1,0,0]\n                    a2 = [dir_vec[i] / length for i in range(3)]\n                    v = [a1[1]*a2[2]-a1[2]*a2[1], a1[2]*a2[0]-a1[0]*a2[2], a1[0]*a2[1]-a1[1]*a2[0]]\n                    s = sqrt(sum(vi*vi for vi in v))\n                    c = sum(a1[i]*a2[i] for i in range(3))\n                    if s < 1e-10:\n                        R = [[1,0,0],[0,1,0],[0,0,1]]\n                    else:\n                        vx = [[0,-v[2],v[1]],[v[2],0,-v[0]],[-v[1],v[0],0]]\n                        I = [[1 if i==j else 0 for j in range(3)] for i in range(3)]\n                        vx2 = [[sum(vx[i][k]*vx[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n                        R = [[I[i][j] + vx[i][j] + vx2[i][j]*((1 - c)/(s**2)) for j in range(3)] for i in range(3)]\n\n            a1_val = best_cost / 2.0\n            a_other = math.sqrt(best_cost**2 - c_min**2) / 2.0\n            import random\n\n            while True:\n                # Sample unit ball point\n                if dim == 2:\n                    r = random.uniform(0,1)**0.5\n                    theta = random.uniform(0, 2*math.pi)\n                    x_ball = [r*math.cos(theta), r*math.sin(theta)]\n                    L = [[a1_val, 0],[0, a_other]]\n                    x_scaled = [L[0][0]*x_ball[0] + L[0][1]*x_ball[1],\n                                L[1][0]*x_ball[0] + L[1][1]*x_ball[1]]\n                    pt = (center[0] + R[0][0]*x_scaled[0] + R[0][1]*x_scaled[1],\n                          center[1] + R[1][0]*x_scaled[0] + R[1][1]*x_scaled[1])\n                else:\n                    while True:\n                        x_ball = [random.uniform(-1,1) for _ in range(3)]\n                        if sum(xi*xi for xi in x_ball) <= 1:\n                            break\n                    L = [[a1_val, 0, 0],[0, a_other, 0],[0, 0, a_other]]\n                    x_scaled = [L[0][0]*x_ball[0], L[1][1]*x_ball[1], L[2][2]*x_ball[2]]\n                    pt = tuple(center[i] + sum(R[i][j]*x_scaled[j] for j in range(dim)) for i in range(dim))\n\n                # Check bounds and obstacles\n                if any(pt[d] < 0 or pt[d] > bounds[d] for d in range(dim)):\n                    continue\n                if self._is_in_obstacle(pt, obstacles, is_3d):\n                    continue\n                return pt\n\n        # Progressive path shortcutting with limited attempts to improve smoothness incrementally\n        def progressive_shortcut(path):\n            if len(path) < 3:\n                return path[:]\n            import random\n            new_path = path[:]\n            attempts = 0\n            while attempts < self.max_shortcut_attempts:\n                if len(new_path) < 3:\n                    break\n                i = random.randint(0, len(new_path)-3)\n                j = random.randint(i+2, len(new_path)-1)\n                if not self._is_edge_in_obstacle(new_path[i], new_path[j], obstacles, is_3d):\n                    new_path = new_path[:i+1] + new_path[j:]\n                    attempts = 0  # reset on success\n                else:\n                    attempts += 1\n            return new_path\n\n        for iteration in range(self.max_iter):\n            sample = informed_sample() if (best_cost < float('inf')) else self._sample_free(bounds, obstacles, is_3d)\n\n            # Alternate tree expansion\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                result = attempt_connection(tree_a, tree_b, sample)\n                if result is not None:\n                    new_node, connect_node, total_cost = result\n                    if total_cost < best_cost:\n                        best_cost = total_cost\n                        if tree_a is start_tree:\n                            solution_start, solution_goal = new_node, connect_node\n                        else:\n                            solution_start, solution_goal = connect_node, new_node\n\n            # Incremental shortcut every shortcut_interval iterations after finding a solution\n            if best_cost < float('inf') and solution_start and solution_goal:\n                if iteration % self.shortcut_interval == 0 or iteration == self.max_iter - 1:\n                    raw_path = self._extract_path(solution_start, solution_goal)\n                    improved_path = progressive_shortcut(raw_path)\n                    if improved_path and len(improved_path) >= 2:\n                        return PlannerResult(True, improved_path, nodes, edges)\n\n        # No solution found\n        return PlannerResult(False, [], nodes, edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        import random\n        while True:\n            pt = tuple(random.uniform(0, bounds[i]) for i in range(len(bounds)))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def _nearest(self, tree, point):\n        import math\n        best_node = None\n        best_dist = float('inf')\n        for node in tree:\n            d = 0.0\n            for i in range(len(point)):\n                diff = node.position[i] - point[i]\n                d += diff*diff\n            if d < best_dist:\n                best_dist = d\n                best_node = node\n        return best_node\n\n    def _near(self, tree, point, radius):\n        r_sq = radius*radius\n        near_nodes = []\n        for n in tree:\n            d = 0.0\n            for i in range(len(point)):\n                diff = n.position[i] - point[i]\n                d += diff*diff\n            if d <= r_sq:\n                near_nodes.append(n)\n        return near_nodes\n\n    def _steer(self, from_pos, to_pos, step_size):\n        import math\n        dist = 0.0\n        for i in range(len(from_pos)):\n            diff = to_pos[i] - from_pos[i]\n            dist += diff*diff\n        dist = dist**0.5\n        if dist <= step_size:\n            return to_pos\n        ratio = step_size / dist\n        new_pos = tuple(from_pos[i] + ratio * (to_pos[i] - from_pos[i]) for i in range(len(from_pos)))\n        return new_pos\n\n    def _extract_path(self, node_start, node_goal):\n        path_start = []\n        n = node_start\n        while n is not None:\n            path_start.append(n.position)\n            n = n.parent\n        path_goal = []\n        n = node_goal\n        while n is not None:\n            path_goal.append(n.position)\n            n = n.parent\n        return list(reversed(path_start)) + path_goal\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x,y,z,w,h,d = obs\n                px,py,pz = pos\n                if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                    return True\n            else:\n                x,y,w,h = obs\n                px,py = pos\n                if x <= px <= x+w and y <= py <= y+h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        dist = 0.0\n        for i in range(len(from_pos)):\n            diff = to_pos[i] - from_pos[i]\n            dist += diff*diff\n        dist = dist**0.5\n        steps = max(1, int(dist / resolution))\n        for step in range(steps+1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (step / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _unit_ball_volume(self, dim):\n        import math\n        # Volume of unit ball in dimension dim\n        if dim == 2:\n            return math.pi\n        elif dim == 3:\n            return 4.0/3.0 * math.pi\n        else:\n            # General formula using gamma function approximation\n            from math import gamma\n            return (math.pi**(dim/2)) / gamma(dim/2 + 1)",
            "objective": -28.03557,
            "time_improvement": 38.0,
            "length_improvement": 15.0,
            "smoothness_improvement": 1533.0,
            "node_improvement": 72.0,
            "other_inf": [
                {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.023175954818725586,
                    "num_nodes_avg": 135.3,
                    "path_length_avg": 175.79982556162778,
                    "smoothness_avg": 0.04886810478019664,
                    "success_improvement": 0.0,
                    "time_improvement": 10.13871106406778,
                    "node_improvement": 65.92797783933518,
                    "length_improvement": 3.641329883168963,
                    "smoothness_improvement": 664.8919585980976,
                    "objective_score": 8.550871042112199
                },
                {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.03271842002868652,
                    "num_nodes_avg": 261.1,
                    "path_length_avg": 229.80246953520958,
                    "smoothness_avg": 0.09634245712495317,
                    "success_improvement": 0.0,
                    "time_improvement": 80.239599766615,
                    "node_improvement": 82.45649398642746,
                    "length_improvement": 23.28532117181223,
                    "smoothness_improvement": 2378.9608144920394,
                    "objective_score": 49.937876705532034
                },
                {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.03931493759155273,
                    "num_nodes_avg": 263.8,
                    "path_length_avg": 122.75935520727265,
                    "smoothness_avg": 0.13016053434098707,
                    "success_improvement": 0.0,
                    "time_improvement": 22.527837796824144,
                    "node_improvement": 66.45899554990464,
                    "length_improvement": 18.469081443653348,
                    "smoothness_improvement": 1555.6323893660885,
                    "objective_score": 25.617962152069694
                }
            ],
            "success_rate": 1.0
        },
        "objective": 894.1999999999999,
        "analysis": {
            "problem": [
                "Problem of the parents algorithm:\n   - Use of fixed neighborhood radius limiting effective rewiring and adaptive connectivity.\n   - Infrequent or less adaptive path shortcutting restricting improvement of path smoothness and length.\n   - Maintaining and updating children lists without robust pruning, causing overhead and less effective rewiring.\n   - Collision checking performed frequently without efficient early exits, increasing planning time.\n   - Sampling strategies focusing on either uniform or ellipse-based informed sampling but without integration of adaptive radius or continuous refinement, leading to slower convergence and exploration inefficiency."
            ],
            "solution": "1. Primary contributors to the performance improvement:\n   - Implementation of an adaptive neighborhood radius scaling with node density enabling more optimal rewiring.\n   - More frequent and incremental path shortcutting improving path smoothness and length progressively.\n   - Pruning of child-parent connections during rewiring reducing overhead and increasing rewiring effectiveness.\n   - Efficient collision checking with early rejection optimizing runtime.\n   - Continued use of ellipsoidal informed sampling combined with adaptive rewiring and incremental refinement for focused exploration and faster convergence.\n2. Expected mechanism of impact:\n   - Adaptive radius enhances local connectivity as the tree expands, enabling improved path shortening and smoothing opportunities.\n   - Incremental shortcutting removes redundant waypoints steadily, smoothing paths without spikes in computation.\n   - Pruning children links prevents overhead and inconsistent tree relationships, making rewiring more effective.\n   - Efficient collision checks reduce unnecessary computational burden, speeding planning.\n   - Focused sampling within informed regions accelerates discovery and refinement of high-quality paths."
        }
    },
    {
        "parents": [
            {
                "operator": "initial",
                "algorithm_description": "This algorithm is a dual-tree variant of Rapidly-exploring Random Tree (RRT) that grows two trees from the start and goal positions, attempting to connect them as they expand. It is efficient for single-query problems due to its bidirectional search and reduced redundant exploration.",
                "planning_mechanism": "The planner alternates between growing the start and goal trees by extending towards randomly sampled points. Each extension step involves checking for collision-free motion and attempting to connect the two trees. The algorithm terminates when a valid path is formed connecting the trees.",
                "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n        nodes = []\n        edges = []\n        success_state = False\n        extracted_path = []\n\n        for iter in range(self.max_iter):\n            rand = self._sample_free(bounds, obstacles, is_3d)\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest = self._nearest(tree_a, rand)\n                new_pos = self._steer(nearest.position, rand, self.step_size)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                    continue\n                new_node = Node(new_pos, parent=nearest, cost=nearest.cost + self._distance(nearest.position, new_pos))\n                nearest.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((nearest, new_node))\n\n                connect_node = self._nearest(tree_b, new_pos)\n                if self._connect_trees(new_node, connect_node, obstacles, is_3d, tree_b, nodes, edges):\n                    success_state = True\n                    extracted_path = self._extract_path(new_node, connect_node)\n                    return PlannerResult(True, extracted_path, start_tree + goal_tree, edges)\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        while True:\n            if is_3d:\n                point = tuple(random.uniform(0, bounds[i]) for i in range(3))\n            else:\n                point = tuple(random.uniform(0, bounds[i]) for i in range(2))\n            if not self._is_in_obstacle(point, obstacles, is_3d):\n                return point\n\n    def _nearest(self, tree, point):\n        return min(tree, key=lambda node: self._distance(node.position, point))\n\n    def _steer(self, from_pos, to_pos, step_size):\n        dist = self._distance(from_pos, to_pos)\n        if dist <= step_size:\n            return to_pos\n        ratio = step_size / dist\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n    def _connect_trees(self, node_a, node_b, obstacles, is_3d, tree, nodes, edges):\n        from_pos = node_a.position\n        to_pos = node_b.position\n        if self._is_edge_in_obstacle(from_pos, to_pos, obstacles, is_3d):\n            return False\n        curr = node_b\n        path = []\n        while True:\n            new_pos = self._steer(curr.position, from_pos, self.step_size)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return False\n            if self._is_edge_in_obstacle(curr.position, new_pos, obstacles, is_3d):\n                return False\n            new_node = Node(new_pos, parent=curr, cost=curr.cost + self._distance(curr.position, new_pos))\n            curr.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((curr, new_node))\n            if self._distance(new_pos, from_pos) < self.step_size:\n                new_node_final = Node(from_pos, parent=new_node, cost=new_node.cost + self._distance(new_pos, from_pos))\n                new_node.add_child(new_node_final)\n                tree.append(new_node_final)\n                nodes.append(new_node_final)\n                edges.append((new_node, new_node_final))\n                return True\n            curr = new_node\n\n    def _extract_path(self, node_a, node_b):\n        path_a = []\n        while node_a:\n            path_a.append(node_a.position)\n            node_a = node_a.parent\n        path_b = []\n        while node_b:\n            path_b.append(node_b.position)\n            node_b = node_b.parent\n        return list(reversed(path_a)) + path_b\n\n    def _distance(self, a, b):\n        return math.dist(a, b)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = self._distance(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n    ",
                "objective": -17.795854854811235,
                "time_improvement": 71.0,
                "length_improvement": -6.0,
                "smoothness_improvement": 75.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.015041923522949219,
                        "num_nodes_avg": 140.4,
                        "path_length_avg": 205.55369204774252,
                        "smoothness_avg": 0.01041684624247792,
                        "success_improvement": 0.0,
                        "time_improvement": 41.67719749109079,
                        "node_improvement": 64.64366658272476,
                        "length_improvement": -12.667235818056396,
                        "smoothness_improvement": 63.046264238449346,
                        "objective_score": 5.218049077685646
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.016628527641296388,
                        "num_nodes_avg": 235.2,
                        "path_length_avg": 305.1784824883373,
                        "smoothness_avg": 0.00711472502770238,
                        "success_improvement": 0.0,
                        "time_improvement": 89.95714459329555,
                        "node_improvement": 84.19673452932877,
                        "length_improvement": -1.8773615301791229,
                        "smoothness_improvement": 83.06699949208468,
                        "objective_score": 26.276061457341616
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.010075998306274415,
                        "num_nodes_avg": 181.0,
                        "path_length_avg": 156.9681958591822,
                        "smoothness_avg": 0.014159220130581652,
                        "success_improvement": 0.0,
                        "time_improvement": 80.14471285055937,
                        "node_improvement": 76.98664971392245,
                        "length_improvement": -4.250801667402978,
                        "smoothness_improvement": 80.10423493608366,
                        "objective_score": 21.89345402940644
                    }
                ],
                "success_rate": 1.0
            },
            {
                "operator": "initial",
                "algorithm_description": "This algorithm is an optimal variant of RRT that improves path quality over time by rewiring the tree to minimize path cost. It incrementally builds a space-filling tree from start toward the goal while performing local optimizations by choosing better parents and rewiring nearby nodes.",
                "planning_mechanism": "The planner samples a point, extends the nearest node toward it, finds nearby nodes within a radius, selects the node offering the lowest-cost path as the parent, and rewires suboptimal neighbors to the new node if a shorter path through it is possible and valid.",
                "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.children.remove(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 3.0, goal_sample_rate: float = 0.05, neighbor_radius: float = 10.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n\n    def plan(self, map) -> PlannerResult:\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        root = Node(start_position)\n        nodes.append(root)\n\n        for _ in range(self.max_iter):\n            # Goal biasing\n            if random.random() < self.goal_sample_rate:\n                sample = goal_position\n            else:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n\n            # Nearest node\n            nearest_node = min(nodes, key=lambda n: math.dist(n.position, sample))\n            direction = tuple(sample[d] - nearest_node.position[d] for d in range(len(bounds)))\n            dist_to_sample = math.dist(nearest_node.position, sample)\n            if dist_to_sample == 0:\n                continue\n            unit = tuple(d / dist_to_sample for d in direction)\n            new_position = tuple(nearest_node.position[d] + unit[d] * min(self.step_size, dist_to_sample) for d in range(len(bounds)))\n\n            if self._is_in_obstacle(new_position, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_position, obstacles, is_3d):\n                continue\n\n            # Nearby nodes for choosing best parent\n            new_node = Node(new_position)\n            near_nodes = [n for n in nodes if math.dist(n.position, new_position) <= self.neighbor_radius]\n\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_position)\n            best_parent = nearest_node\n\n            for near_node in near_nodes:\n                temp_cost = near_node.cost + math.dist(near_node.position, new_position)\n                if temp_cost < min_cost and not self._is_edge_in_obstacle(near_node.position, new_position, obstacles, is_3d):\n                    min_cost = temp_cost\n                    best_parent = near_node\n\n            new_node.update_parent(best_parent, min_cost)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewiring\n            for near_node in near_nodes:\n                if near_node == best_parent:\n                    continue\n                cost_through_new = new_node.cost + math.dist(near_node.position, new_position)\n                if cost_through_new < near_node.cost and not self._is_edge_in_obstacle(new_position, near_node.position, obstacles, is_3d):\n                    edges.remove((near_node.parent, near_node))\n                    near_node.update_parent(new_node, cost_through_new)\n                    edges.append((new_node, near_node))\n\n            # Check goal connection\n            if math.dist(new_position, goal_position) <= self.step_size:\n                if not self._is_edge_in_obstacle(new_position, goal_position, obstacles, is_3d) and not self._is_in_obstacle(goal_position, obstacles, is_3d):\n                    goal_node = Node(goal_position)\n                    goal_cost = new_node.cost + math.dist(new_position, goal_position)\n                    goal_node.update_parent(new_node, goal_cost)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    success_state = True\n                    break\n\n        if success_state:\n            path = []\n            node = nodes[-1]\n            while node:\n                path.append(node.position)\n                node = node.parent\n            extracted_path = path[::-1]\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n    ",
                "objective": 61.63121923444826,
                "time_improvement": -248.0,
                "length_improvement": 20.0,
                "smoothness_improvement": 156.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.047614216804504395,
                        "num_nodes_avg": 367.4,
                        "path_length_avg": 156.97575072701764,
                        "smoothness_avg": 0.014377694677398786,
                        "success_improvement": 0.0,
                        "time_improvement": -84.616984594336,
                        "node_improvement": 7.479224376731312,
                        "length_improvement": 13.959103586572772,
                        "smoothness_improvement": 125.04214336500303,
                        "objective_score": -16.384422509532122
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.685749626159668,
                        "num_nodes_avg": 1656.6,
                        "path_length_avg": 226.92574635006446,
                        "smoothness_avg": 0.010969967745561136,
                        "success_improvement": 0.0,
                        "time_improvement": -314.1608018030315,
                        "node_improvement": -11.308203991130817,
                        "length_improvement": 24.245654172899485,
                        "smoothness_improvement": 182.26517144168025,
                        "objective_score": -78.78952217996137
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.22639145851135253,
                        "num_nodes_avg": 780.9,
                        "path_length_avg": 117.18066902366226,
                        "smoothness_avg": 0.020608286494296014,
                        "success_improvement": 0.0,
                        "time_improvement": -346.11633312050645,
                        "node_improvement": 0.7120152574698059,
                        "length_improvement": 22.174179178317964,
                        "smoothness_improvement": 162.13588306196758,
                        "objective_score": -89.71971301385132
                    }
                ],
                "success_rate": 1.0
            }
        ],
        "offspring": {
            "operator": "m3",
            "algorithm_description": "This algorithm implements an adaptive bidirectional RRT* planner with goal bias and progressive shortcutting for improved path quality, smoothness, and planning efficiency. It alternately expands two trees from start and goal, dynamically adjusts rewiring radius based on tree size, leverages goal bias sampling to focus exploration, and employs repeated path shortcutting to smooth and shorten the resulting path before returning it. This balanced approach enhances convergence speed, reduces path length, and significantly improves smoothness while maintaining collision-free guarantees.",
            "planning_mechanism": "The planner grows two trees from start and goal positions using an RRT* framework with adaptive radius rewiring for local optimality. It samples random points with goal bias, extends each tree towards samples, rewires to reduce path cost, and attempts to connect the trees when close. Upon connecting, it extracts the combined path and performs multiple shortcutting passes to smooth the path before outputting the result.",
            "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.children.remove(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=4.0, goal_sample_rate=0.1, gamma=30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.gamma = gamma  # tuning parameter for adaptive radius\n\n    def plan(self, map):\n        import math\n        import random\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = dim == 3\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    px, py = pos\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def edge_in_obstacle(p1, p2, resolution=1.0):\n            d = dist(p1, p2)\n            steps = max(1, int(d / resolution))\n            for i in range(steps + 1):\n                interp = tuple(p1[j] + (p2[j] - p1[j]) * i / steps for j in range(dim))\n                if in_obstacle(interp):\n                    return True\n            return False\n\n        def steer(from_p, to_p, max_step):\n            d = dist(from_p, to_p)\n            if d <= max_step:\n                return to_p\n            ratio = max_step / d\n            return tuple(from_p[i] + (to_p[i] - from_p[i]) * ratio for i in range(dim))\n\n        def get_nearest(tree, point):\n            return min(tree, key=lambda node: dist(node.position, point))\n\n        def get_near_nodes(tree, new_pos, radius):\n            return [node for node in tree if dist(node.position, new_pos) <= radius]\n\n        def adaptive_radius(n):\n            # Based on RRT* radius scaling law\n            if n == 0:\n                return self.step_size * 2\n            return min(self.gamma * (math.log(n) / n) ** (1 / dim), self.step_size * 20)\n\n        def rewire(tree, nodes, edges, new_node, near_nodes):\n            for near_node in near_nodes:\n                if near_node is new_node.parent:\n                    continue\n                cost_through_new = new_node.cost + dist(new_node.position, near_node.position)\n                if cost_through_new + 1e-7 < near_node.cost:\n                    if not edge_in_obstacle(new_node.position, near_node.position):\n                        if (near_node.parent, near_node) in edges:\n                            edges.remove((near_node.parent, near_node))\n                        near_node.update_parent(new_node, cost_through_new)\n                        edges.append((new_node, near_node))\n\n        nodes_start = [Node(start_pos)]\n        nodes_goal = [Node(goal_pos)]\n        edges = []\n        forward_tree = nodes_start\n        backward_tree = nodes_goal\n        success = False\n        connect_node_start = None\n        connect_node_goal = None\n\n        for it in range(self.max_iter):\n            # Alternate growing trees\n            for grow_start_tree_first in (True, False):\n                if grow_start_tree_first:\n                    tree_a, tree_b = forward_tree, backward_tree\n                else:\n                    tree_a, tree_b = backward_tree, forward_tree\n\n                # Sample with goal bias toward other tree's root\n                if random.random() < self.goal_sample_rate:\n                    sample = tree_b[0].position\n                else:\n                    sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if in_obstacle(sample):\n                    continue\n\n                nearest = get_nearest(tree_a, sample)\n                new_pos = steer(nearest.position, sample, self.step_size)\n                if in_obstacle(new_pos) or edge_in_obstacle(nearest.position, new_pos):\n                    continue\n\n                # Adaptive radius dependent on current tree size\n                radius = adaptive_radius(len(tree_a) + 1)\n                near_nodes = get_near_nodes(tree_a, new_pos, radius)\n\n                # Choose best parent among near nodes\n                min_cost = nearest.cost + dist(nearest.position, new_pos)\n                best_parent = nearest\n                for near in near_nodes:\n                    if not edge_in_obstacle(near.position, new_pos):\n                        cost_candidate = near.cost + dist(near.position, new_pos)\n                        if cost_candidate < min_cost:\n                            min_cost = cost_candidate\n                            best_parent = near\n\n                new_node = Node(new_pos)\n                new_node.parent = best_parent\n                new_node.cost = min_cost\n                best_parent.add_child(new_node)\n                tree_a.append(new_node)\n                edges.append((best_parent, new_node))\n\n                # Rewire near nodes to new node if cost improves and collision free\n                rewire(tree_a, tree_a, edges, new_node, near_nodes)\n\n                # Try to connect trees\n                nearest_in_other = get_nearest(tree_b, new_node.position)\n                if dist(new_node.position, nearest_in_other.position) <= self.step_size:\n                    if not edge_in_obstacle(new_node.position, nearest_in_other.position):\n                        # Connect trees\n                        connect_node_start = new_node if grow_start_tree_first else nearest_in_other\n                        connect_node_goal = nearest_in_other if grow_start_tree_first else new_node\n                        success = True\n                        break\n            if success:\n                break\n\n        def extract_path(node_start, node_goal):\n            path_start = []\n            cur = node_start\n            while cur:\n                path_start.append(cur.position)\n                cur = cur.parent\n            path_goal = []\n            cur = node_goal\n            while cur:\n                path_goal.append(cur.position)\n                cur = cur.parent\n            return path_start[::-1] + path_goal\n\n        def shortcut_path(path, max_attempts=100):\n            if len(path) < 3:\n                return path\n            for _ in range(max_attempts):\n                if len(path) <= 2:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if not edge_in_obstacle(p1, p2):\n                    # Remove intermediate points between i and j\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        nodes_all = nodes_start + nodes_goal\n        if success:\n            raw_path = extract_path(connect_node_start, connect_node_goal)\n            smoothed_path = shortcut_path(raw_path, max_attempts=200)\n            return PlannerResult(True, smoothed_path, nodes_all, edges)\n        else:\n            return PlannerResult(False, [], nodes_all, edges)",
            "objective": -26.77328,
            "time_improvement": 30.0,
            "length_improvement": 17.0,
            "smoothness_improvement": 1515.0,
            "node_improvement": 64.0,
            "other_inf": [
                {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.026349878311157225,
                    "num_nodes_avg": 131.5,
                    "path_length_avg": 161.50533767083496,
                    "smoothness_avg": 0.04633540991002978,
                    "success_improvement": 0.0,
                    "time_improvement": -2.1677012604634127,
                    "node_improvement": 66.88491563837825,
                    "length_improvement": 11.476365206768222,
                    "smoothness_improvement": 625.2497840450478,
                    "objective_score": 9.361757666147147
                },
                {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.0372589111328125,
                    "num_nodes_avg": 338.9,
                    "path_length_avg": 239.0656007486035,
                    "smoothness_avg": 0.10263753383464265,
                    "success_improvement": 0.0,
                    "time_improvement": 77.49735483562543,
                    "node_improvement": 77.22905328226837,
                    "length_improvement": 20.193021348332763,
                    "smoothness_improvement": 2540.9376723928312,
                    "objective_score": 48.069707621651446
                },
                {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.0440518856048584,
                    "num_nodes_avg": 400.8,
                    "path_length_avg": 120.37369996551419,
                    "smoothness_avg": 0.11632493211416521,
                    "success_improvement": 0.0,
                    "time_improvement": 13.193431402810726,
                    "node_improvement": 49.040050858232675,
                    "length_improvement": 20.053520062534325,
                    "smoothness_improvement": 1379.6445502788406,
                    "objective_score": 22.888364209758016
                }
            ],
            "success_rate": 1.0
        },
        "objective": 365.4,
        "analysis": {
            "problem": [
                ""
            ],
            "solution": "1. Primary contributors to the performance improvement:\n   - Incorporation of adaptive rewiring radius that scales with the tree size, enabling more effective local optimization of the path.\n   - Use of bidirectional tree expansion combined with goal bias sampling improving exploration efficiency and speeding up convergence.\n   - Implementation of path shortcutting post-processing, significantly reducing unnecessary waypoints and improving smoothness.\n   - Dynamic parameter adjustment allowing balanced exploration and exploitation, reducing redundant computations and improving planning time.\n2. Expected mechanism of impact:\n   - Adaptive rewiring enhances parent selection for new nodes, decreasing overall path cost and thereby reducing path length and improving smoothness.\n   - Goal-biased bidirectional growth quickly connects the trees, shortening planning time by avoiding excessive sampling in irrelevant regions.\n   - Path shortcutting removes redundant intermediate nodes and sharp turns, dramatically increasing smoothness and often shortening path length.\n   - The combination of these strategies results in faster, more optimal, and smoother path generation compared to static-parameter or single-tree methods."
        }
    }
]