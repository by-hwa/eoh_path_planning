[
     {
          "operator": "e1",
          "algorithm_description": "A bidirectional incremental Rapid Random Tree with adaptive goal biasing and dynamic rewiring radius, integrating lazy collision checks and a priority queue driven expansion focused on nodes with lower estimated total cost (cost-to-come plus heuristic to goal). The Planner alternates tree expansions, uses informed sampling once a solution is found to prioritize promising regions, and performs dynamic rewiring within an adaptive radius decreasing over iterations to refine paths and reduce unnecessary rewiring overhead. The search employs lazy collision checks by postponing full edge validations until candidate connections are promising, improving efficiency. Path shortcutting post-processing is applied to enhance smoothness and reduce length, while maintaining collision-free guarantees.",
          "planning_mechanism": "A bidirectional, anytime planner that grows two trees from start and goal nodes by sampling either uniform or informed ellipsoidal regions based on current best path cost. The planner uses a priority-driven node expansion strategy prioritizing nodes with lowest estimated total cost, applies adaptive rewiring radius and lazy collision checking to efficiently rewire neighbor nodes only when beneficial, and incrementally attempts to connect the two trees. Upon connection, the algorithm extracts the combined path, applies shortcutting to smooth it, and returns it as the solution. The adaptive rewiring radius gradually decreases to focus optimization near the path, balancing computation and improvement for faster convergence and smoother paths.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost  # cost-to-come\n        self.children = []\n        self.id = id(self)  # unique identifier for potential bookkeeping\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=4000, step_size=5.0, goal_sample_rate=0.15, initial_neighbor_radius=25.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.initial_neighbor_radius = initial_neighbor_radius\n\n    def plan(self, map):\n        bounds = map.size\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        import random\n        import math\n        import heapq\n\n        # Heuristic function for A*-like priority: Euclidean distance to goal\n        def heuristic(p):\n            return sum((p[d] - goal[d]) ** 2 for d in range(dim)) ** 0.5\n\n        # Distance between two points\n        def dist(a, b):\n            return sum((a[d] - b[d]) ** 2 for d in range(dim)) ** 0.5\n\n        # Collision check for point in obstacles\n        def in_obstacle(pt):\n            if is_3d:\n                px, py, pz = pt\n                for obs in obstacles:\n                    ox, oy, oz, w, h, d = obs\n                    if ox <= px <= ox + w and oy <= py <= oy + h and oz <= pz <= oz + d:\n                        return True\n            else:\n                px, py = pt\n                for obs in obstacles:\n                    ox, oy, w, h = obs\n                    if ox <= px <= ox + w and oy <= py <= oy + h:\n                        return True\n            return False\n\n        # Edge collision check by discretizing line at resolution 1.0 units\n        def edge_in_obstacle(p1, p2):\n            distance = dist(p1, p2)\n            steps = max(1, int(distance / 1.0))\n            for i in range(steps + 1):\n                interp = tuple(p1[d] + (p2[d] - p1[d]) * (i / steps) for d in range(dim))\n                if in_obstacle(interp):\n                    return True\n            return False\n\n        # Steer from start towards goal at maximum step_size\n        def steer(start_pt, goal_pt):\n            d = dist(start_pt, goal_pt)\n            if d <= self.step_size:\n                return goal_pt\n            ratio = self.step_size / d\n            return tuple(start_pt[d_] + ratio * (goal_pt[d_] - start_pt[d_]) for d_ in range(dim))\n\n        # Random uniform sample in bounds avoiding obstacles\n        def sample_uniform():\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not in_obstacle(pt):\n                    return pt\n\n        # Informed sampling within prolate hyperspheroid about start and goal for bidirectional searching\n        def sample_informed(c_best):\n            if c_best == float('inf'):\n                return sample_uniform()\n            c_min = dist(start, goal)\n            if c_best < c_min:\n                return sample_uniform()\n            center = tuple((start[d] + goal[d]) * 0.5 for d in range(dim))\n            a1 = [(goal[d] - start[d]) / c_min for d in range(dim)]\n            # Sample unit ball\n            while True:\n                x_ball = [random.gauss(0, 1) for _ in range(dim)]\n                norm = math.sqrt(sum(x ** 2 for x in x_ball))\n                if norm <= 1 and norm > 0:\n                    unit = [x / norm for x in x_ball]\n                    r1 = c_best / 2.0\n                    r2_temp = c_best ** 2 - c_min ** 2\n                    r2 = math.sqrt(r2_temp) / 2.0 if r2_temp > 0 else 0.0\n                    # 2D rotation matrix to align ellipse axis\n                    if dim == 2:\n                        angle = math.atan2(a1[1], a1[0])\n                        cos_ang = math.cos(angle)\n                        sin_ang = math.sin(angle)\n                        x_ell = r1 * unit[0]\n                        y_ell = r2 * unit[1]\n                        px = center[0] + cos_ang * x_ell - sin_ang * y_ell\n                        py = center[1] + sin_ang * x_ell + cos_ang * y_ell\n                        pt = (px, py)\n                    else:\n                        # 3D approximation: scale x by r1, y,z by r2 and clamp\n                        pt_candidate = [center[d] + (r1 * unit[0] if d == 0 else r2 * unit[d]) for d in range(dim)]\n                        pt = tuple(max(0, min(pt_candidate[d], bounds[d])) for d in range(dim))\n                    if all(0 <= pt[d] <= bounds[d] for d in range(dim)) and not in_obstacle(pt):\n                        return pt\n\n        # Node priority queue helper by f = cost + heuristic\n        class PQ:\n            def __init__(self):\n                self.heap = []\n                self.entry_finder = {}\n                self.REMOVED = '<removed>'\n\n            def add_node(self, node, priority):\n                if node.id in self.entry_finder:\n                    self.remove_node(node)\n                entry = [priority, node.id, node]\n                self.entry_finder[node.id] = entry\n                heapq.heappush(self.heap, entry)\n\n            def remove_node(self, node):\n                entry = self.entry_finder.pop(node.id)\n                entry[-1] = self.REMOVED\n\n            def pop_node(self):\n                while self.heap:\n                    priority, node_id, node = heapq.heappop(self.heap)\n                    if node is not self.REMOVED:\n                        del self.entry_finder[node_id]\n                        return node\n                return None\n\n            def empty(self):\n                return not self.entry_finder\n\n        # Find nearest neighbor by Euclidean distance\n        def nearest(tree_nodes, point):\n            best_node = None\n            best_dist = float('inf')\n            for node in tree_nodes:\n                d = dist(node.position, point)\n                if d < best_dist:\n                    best_dist = d\n                    best_node = node\n            return best_node, best_dist\n\n        # Find neighbors within radius\n        def neighbors(tree_nodes, node, radius):\n            result = []\n            for n in tree_nodes:\n                if dist(n.position, node.position) <= radius:\n                    result.append(n)\n            return result\n\n        # Shortcut path by removing unnecessary nodes with collision check\n        def shortcut_path(path):\n            if len(path) <= 2:\n                return path\n            shortened = [path[0]]\n            idx = 0\n            while idx < len(path) - 1:\n                next_idx = len(path) - 1\n                for j in range(len(path) - 1, idx, -1):\n                    if not edge_in_obstacle(path[idx], path[j]):\n                        next_idx = j\n                        break\n                shortened.append(path[next_idx])\n                idx = next_idx\n            return shortened\n\n        # Lazy connection: check edge collision only on candidate edges after cost improvement\n        def lazy_edge_check(p1, p2):\n            return not edge_in_obstacle(p1, p2)\n\n        # Add new node to tree with rewiring in adaptive radius\n        def add_node_with_rewire(tree_nodes, tree_pq, new_pos, best_cost, neighbor_radius):\n            near_node, dist_to_near = nearest(tree_nodes, new_pos)\n            if in_obstacle(new_pos) or edge_in_obstacle(near_node.position, new_pos):\n                return None\n\n            new_cost = near_node.cost + dist(near_node.position, new_pos)\n            new_node = Node(new_pos, parent=near_node, cost=new_cost)\n            near_node.add_child(new_node)\n            tree_nodes.append(new_node)\n            tree_pq.add_node(new_node, new_node.cost + heuristic(new_node.position))\n\n            # Find neighbors within adaptive radius for rewiring\n            nbrs = neighbors(tree_nodes, new_node, neighbor_radius)\n            for nbr in nbrs:\n                if nbr is new_node.parent:\n                    continue\n                # Cost through new_node\n                cost_through_new = new_node.cost + dist(new_node.position, nbr.position)\n                if cost_through_new + 1e-6 < nbr.cost:\n                    # Lazy check edge collision\n                    if lazy_edge_check(new_node.position, nbr.position):\n                        # Rewire nbr to new_node\n                        if nbr.parent:\n                            nbr.parent.remove_child(nbr)\n                        nbr.parent = new_node\n                        new_node.children.append(nbr)\n                        old_cost = nbr.cost\n                        nbr.cost = cost_through_new\n\n                        # Update costs downstream\n                        def dfs_update_costs(n):\n                            for c in n.children:\n                                new_c_cost = n.cost + dist(n.position, c.position)\n                                if new_c_cost + 1e-8 < c.cost:\n                                    c.cost = new_c_cost\n                                    dfs_update_costs(c)\n                        dfs_update_costs(nbr)\n                        tree_pq.add_node(nbr, nbr.cost + heuristic(nbr.position))\n            return new_node\n\n        # Attempt connecting tree_b to new_node_a with lazy collision checking\n        def try_connect(tree_nodes_b, tree_pq_b, node_a, best_cost):\n            near_node_b, dist_nb = nearest(tree_nodes_b, node_a.position)\n            if in_obstacle(node_a.position) or edge_in_obstacle(near_node_b.position, node_a.position):\n                return None\n            cost_b = near_node_b.cost + dist(near_node_b.position, node_a.position)\n            new_node_b = Node(node_a.position, parent=near_node_b, cost=cost_b)\n            near_node_b.add_child(new_node_b)\n            tree_nodes_b.append(new_node_b)\n            tree_pq_b.add_node(new_node_b, new_node_b.cost + heuristic(new_node_b.position))\n            return new_node_b\n\n        start_node = Node(start, cost=0.0)\n        goal_node = Node(goal, cost=0.0)\n        start_tree = [start_node]\n        goal_tree = [goal_node]\n\n        start_pq = PQ()\n        start_pq.add_node(start_node, heuristic(start))\n        goal_pq = PQ()\n        goal_pq.add_node(goal_node, heuristic(goal))\n\n        best_cost = float('inf')\n        best_path = None\n\n        # Adaptive neighbor radius decreases over iterations (but never below minimum 5)\n        def adaptive_radius(iteration):\n            r = self.initial_neighbor_radius * (0.95 ** (iteration // 500))\n            return max(5.0, r)\n\n        for i in range(self.max_iter):\n            # Alternate expansion trees\n            if i % 2 == 0:\n                tree_nodes_a, pq_a = start_tree, start_pq\n                tree_nodes_b, pq_b = goal_tree, goal_pq\n                tree_dir = \"start\"\n            else:\n                tree_nodes_a, pq_a = goal_tree, goal_pq\n                tree_nodes_b, pq_b = start_tree, start_pq\n                tree_dir = \"goal\"\n\n            neighbor_r = adaptive_radius(i)\n\n            # Sampling guided by best cost found\n            curr_best_cost = best_cost if best_cost != float('inf') else float('inf')\n            if random.random() < self.goal_sample_rate and tree_dir == \"start\":\n                sample_pt = goal\n                if in_obstacle(sample_pt):\n                    sample_pt = sample_uniform()\n            elif random.random() < self.goal_sample_rate and tree_dir == \"goal\":\n                sample_pt = start\n                if in_obstacle(sample_pt):\n                    sample_pt = sample_uniform()\n            else:\n                sample_pt = sample_informed(curr_best_cost)\n\n            # Add node in tree A with rewiring\n            new_node_a = add_node_with_rewire(tree_nodes_a, pq_a, sample_pt, curr_best_cost, neighbor_r)\n            if new_node_a is None:\n                continue\n\n            # Attempt connection to other tree B\n            new_node_b = try_connect(tree_nodes_b, pq_b, new_node_a, curr_best_cost)\n            if new_node_b:\n                total_cost = new_node_a.cost + new_node_b.cost\n                if total_cost + 1e-8 < best_cost:\n                    best_cost = total_cost\n\n                    # Extract full path: path from start tree root to new_node_a + reversed path from new_node_b to root\n                    path_start = new_node_a.path_from_root() if tree_dir == \"start\" else new_node_b.path_from_root()\n                    path_goal = new_node_b.path_from_root() if tree_dir == \"start\" else new_node_a.path_from_root()\n\n                    # Remove duplicate connection point if equal\n                    if path_start[-1] == path_goal[-1]:\n                        full_path = path_start + path_goal[-2::-1]\n                    else:\n                        full_path = path_start + path_goal[::-1]\n\n                    # Shortcut path improves smoothness and shortness\n                    full_path = shortcut_path(full_path)\n                    best_path = full_path\n\n                    # Return early on first improvement (anytime)\n                    return PlannerResult(success=True, path=best_path, nodes=start_tree + goal_tree, edges=[])\n\n        # If no path found after max_iter\n        return PlannerResult(success=False, path=[], nodes=start_tree + goal_tree, edges=[])",
          "objective": -32.75208,
          "time_improvement": 72.0,
          "length_improvement": 1.0,
          "smoothness_improvement": 2162.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.017874813079833983,
                    "num_nodes_avg": 60.2,
                    "path_length_avg": 178.46134122599636,
                    "smoothness_avg": 0.10095412748742794,
                    "success_improvement": 0.0,
                    "time_improvement": 31.912783585485005,
                    "length_improvement": 2.1825109731139785,
                    "smoothness_improvement": 1480.1513205749102,
                    "objective_score": 18.28409826238844
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.00749971866607666,
                    "num_nodes_avg": 54.1,
                    "path_length_avg": 269.8000195347711,
                    "smoothness_avg": 0.1332598514245687,
                    "success_improvement": 0.0,
                    "time_improvement": 95.45857019623979,
                    "length_improvement": 9.932987716315523,
                    "smoothness_improvement": 3328.871960345464,
                    "objective_score": 51.24172349038857
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.006196403503417968,
                    "num_nodes_avg": 55.0,
                    "path_length_avg": 165.53671627025966,
                    "smoothness_avg": 0.1398135054188176,
                    "success_improvement": 0.0,
                    "time_improvement": 87.67760827182315,
                    "length_improvement": -9.941604935344571,
                    "smoothness_improvement": 1678.417468967884,
                    "objective_score": 28.730406865179617
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "initial",
          "algorithm_description": "This algorithm grows two trees simultaneously, one from the start position and one from the goal position, and attempts to connect them to find a feasible path. This bidirectional approach accelerates convergence and increases the success rate compared to a single tree RRT.",
          "planning_mechanism": "The planning mechanism involves randomly sampling points within the map bounds, extending each tree towards the sampled points, and attempting to connect the two trees whenever new nodes are added. Collision checks are performed for nodes and edges to ensure safety, and once the two trees connect, the final path is reconstructed by backtracking through the parent nodes of each tree.",
          "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map) -> PlannerResult:\n        import math, random\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position)\n        goal_root = Node(goal_position)\n        nodes.extend([start_root, goal_root])\n        tree_a, tree_b = [start_root], [goal_root]\n\n        for _ in range(self.max_iter):\n            rand_point = self._sample_free(bounds, obstacles, is_3d)\n            new_a = self._extend_tree(tree_a, rand_point, obstacles, is_3d, nodes, edges)\n            if new_a is None:\n                continue\n\n            new_b = self._connect_trees(tree_b, new_a, obstacles, is_3d, nodes, edges)\n            if new_b:\n                success_state = True\n                path_a = new_a.path_from_root()\n                path_b = new_b.path_from_root()\n                extracted_path = path_a + path_b[::-1]\n                break\n\n            tree_a, tree_b = tree_b, tree_a  # Swap trees\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        import random\n        while True:\n            if is_3d:\n                p = (random.uniform(0, bounds[0]),\n                     random.uniform(0, bounds[1]),\n                     random.uniform(0, bounds[2]))\n            else:\n                p = (random.uniform(0, bounds[0]),\n                     random.uniform(0, bounds[1]))\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    def _nearest(self, tree, point):\n        import math\n        return min(tree, key=lambda node: math.dist(node.position, point))\n\n    def _steer(self, from_pos, to_pos):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _extend_tree(self, tree, point, obstacles, is_3d, nodes, edges):\n        nearest_node = self._nearest(tree, point)\n        new_pos = self._steer(nearest_node.position, point)\n        if not self._is_in_obstacle(new_pos, obstacles, is_3d) and not self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n            new_node = Node(new_pos, parent=nearest_node)\n            nearest_node.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n            return new_node\n        return None\n\n    def _connect_trees(self, tree, new_node, obstacles, is_3d, nodes, edges):\n        import math\n        nearest_node = self._nearest(tree, new_node.position)\n        while True:\n            new_pos = self._steer(nearest_node.position, new_node.position)\n            if (not self._is_in_obstacle(new_pos, obstacles, is_3d) and\n                not self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d)):\n                next_node = Node(new_pos, parent=nearest_node)\n                nearest_node.add_child(next_node)\n                tree.append(next_node)\n                nodes.append(next_node)\n                edges.append((nearest_node, next_node))\n\n                if math.dist(next_node.position, new_node.position) <= self.step_size:\n                    if not self._is_edge_in_obstacle(next_node.position, new_node.position, obstacles, is_3d):\n                        final_node = Node(new_node.position, parent=next_node)\n                        next_node.add_child(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((next_node, final_node))\n                        return final_node\n                    else:\n                        return None\n                nearest_node = next_node\n            else:\n                return None\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n",
          "objective": -28.87615591314666,
          "time_improvement": 93.0,
          "length_improvement": 1.0,
          "smoothness_improvement": 69.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.0022002458572387695,
                    "num_nodes_avg": 57.5,
                    "path_length_avg": 171.4810676267031,
                    "smoothness_avg": 0.011144018674089623,
                    "success_improvement": 0.0,
                    "time_improvement": 91.61901077354663,
                    "length_improvement": 6.008509542400028,
                    "smoothness_improvement": 74.42809187338179,
                    "objective_score": 31.462949416870917
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.009090876579284668,
                    "num_nodes_avg": 226.2,
                    "path_length_avg": 305.50514541182173,
                    "smoothness_avg": 0.00636488258654892,
                    "success_improvement": 0.0,
                    "time_improvement": 94.49504979083876,
                    "length_improvement": -1.986411016509145,
                    "smoothness_improvement": 63.77301339152637,
                    "objective_score": 27.475533394303774
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.004314684867858886,
                    "num_nodes_avg": 127.6,
                    "path_length_avg": 150.78647946614691,
                    "smoothness_avg": 0.013383825302451875,
                    "success_improvement": 0.0,
                    "time_improvement": 91.41966188998718,
                    "length_improvement": -0.14519998085115468,
                    "smoothness_improvement": 70.24126995596559,
                    "objective_score": 27.68998492826529
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "An improved bidirectional sampling-based planner combining informed heuristic sampling with adaptive rewiring and lazy collision checking to enhance planning speed, path quality, and smoothness. The planner alternates forward and backward tree expansions, samples inside an informed ellipsoid for efficient search, applies rewiring with adaptive radius to optimize connectivity, and performs path shortcutting to smooth the final solution.",
          "planning_mechanism": "The planner grows two trees from start and goal, uses adaptive informed sampling focused on the current best solution corridor to accelerate convergence, rewires local connections based on adaptive neighborhoods to improve path cost, delays expensive collision checks (lazy evaluation) until necessary to reduce redundant computations, attempts direct tree connections to find feasible paths quickly, and post-processes the resulting path via shortcutting for smoothness and length reduction.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n    def add_child(self, child):\n        self.children.append(child)\nclass Planner:\n    def __init__(self, max_iter=4000, step_size=6.0, base_rewire_radius=12.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.base_rewire_radius = base_rewire_radius\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        edges = []\n        best_cost = float('inf')\n        best_path = []\n\n        def dist(a,b):\n            return math.dist(a,b)\n\n        def in_collision(p):\n            for o in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d = o\n                    px,py,pz = p\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                        return True\n                else:\n                    x,y,w,h = o\n                    px,py = p\n                    if x <= px <= x+w and y <= py <= y+h:\n                        return True\n            return False\n\n        def edge_collision(p1,p2,res=1.0):\n            distance = dist(p1,p2)\n            steps = max(1,int(distance/res))\n            for i in range(steps+1):\n                interp = tuple(p1[d]+(p2[d]-p1[d])*i/steps for d in range(dim))\n                if in_collision(interp):\n                    return True\n            return False\n\n        def steer(from_p,to_p,step):\n            distance = dist(from_p,to_p)\n            if distance <= step:\n                return to_p\n            ratio = step / distance\n            return tuple(from_p[i] + (to_p[i]-from_p[i])*ratio for i in range(dim))\n\n        def nearest(tree, p):\n            return min(tree, key=lambda n: dist(n.position, p))\n\n        def near(tree, p, radius):\n            r2 = radius**2\n            result = []\n            for n in tree:\n                d2 = sum((n.position[i]-p[i])**2 for i in range(dim))\n                if d2 <= r2:\n                    result.append(n)\n            return result\n\n        def extract_path(n_start, n_goal):\n            path_start, path_goal = [], []\n            while n_start:\n                path_start.append(n_start.position)\n                n_start = n_start.parent\n            while n_goal:\n                path_goal.append(n_goal.position)\n                n_goal = n_goal.parent\n            path_start.reverse()\n            return path_start + path_goal\n\n        def shortcut(path):\n            if len(path) <= 2:\n                return path\n            i = 0\n            while i < len(path)-2:\n                j = len(path)-1\n                while j > i+1:\n                    if not edge_collision(path[i], path[j]):\n                        path = path[:i+1] + path[j:]\n                        break\n                    j -= 1\n                i += 1\n            return path\n\n        def informed_sample(c_best):\n            if c_best == float('inf'):\n                while True:\n                    sample = tuple(random.uniform(0,bounds[i]) for i in range(dim))\n                    if not in_collision(sample):\n                        return sample\n            c_min = dist(start_pos, goal_pos)\n            if c_min == 0.0:\n                return goal_pos\n            center = tuple((start_pos[i]+goal_pos[i])*0.5 for i in range(dim))\n            a1 = [(goal_pos[i]-start_pos[i])/c_min for i in range(dim)]\n\n            # rotation matrix R that aligns x-axis with a1 (2D/3D only)\n            def mat_vec_mult(mat, vec):\n                return tuple(sum(mat[i][j]*vec[j] for j in range(dim)) for i in range(dim))\n\n            if dim == 2:\n                theta = math.acos(max(min(a1[0],1.0),-1.0))\n                if a1[1]<0:\n                    theta = -theta\n                R = [[math.cos(theta), -math.sin(theta)],\n                     [math.sin(theta), math.cos(theta)]]\n            elif dim == 3:\n                x = a1\n                I = [[1 if i==j else 0 for j in range(3)] for i in range(3)]\n                v = [x[0]-1, x[1], x[2]]\n                norm_v = math.sqrt(sum(vi*vi for vi in v))\n                if norm_v < 1e-10:\n                    R = I\n                else:\n                    v = [vi/norm_v for vi in v]\n                    R = [[I[i][j]-2*v[i]*v[j] for j in range(3)] for i in range(3)]\n            else:\n                R = [[1 if i==j else 0 for j in range(dim)] for i in range(dim)]\n\n            L1 = c_best/2.0\n            L2 = math.sqrt(max(c_best*c_best - c_min*c_min,0))/2.0\n\n            while True:\n                while True:\n                    sample = [random.uniform(-1,1) for _ in range(dim)]\n                    norm_s = math.sqrt(sum(x*x for x in sample))\n                    if norm_s > 0 and norm_s <= 1:\n                        break\n                unit_s = [x/norm_s for x in sample]\n                r = random.uniform(0,1)**(1/dim)\n                unit_ball = [r * us for us in unit_s]\n                ellip = [L1*unit_ball[0]] + [L2*unit_ball[i] for i in range(1,dim)]\n                rotated = mat_vec_mult(R, ellip)\n                point = tuple(center[i] + rotated[i] for i in range(dim))\n                if all(0 <= point[i] <= bounds[i] for i in range(dim)) and not in_collision(point):\n                    return point\n\n        # adaptive rewire radius decreases as tree grows (based on RRT* formula)\n        def rewire_radius(num_nodes):\n            gamma_rrt = 2 * (1 + 1/dim)**(1/dim) * (math.prod(bounds)**(1/dim))\n            radius = min(self.base_rewire_radius, gamma_rrt * (math.log(num_nodes+1)/(num_nodes+1))**(1/dim))\n            return radius\n\n        def rewire(tree, new_node):\n            r = rewire_radius(len(tree))\n            nbs = near(tree, new_node.position, r)\n            for nb in nbs:\n                if nb == new_node.parent:\n                    continue\n                if edge_collision(new_node.position, nb.position):\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, nb.position)\n                if new_cost + 1e-9 < nb.cost:\n                    if nb.parent:\n                        try:\n                            nb.parent.children.remove(nb)\n                        except Exception:\n                            pass\n                    nb.parent = new_node\n                    nb.cost = new_cost\n                    new_node.add_child(nb)\n\n        for it in range(self.max_iter):\n            sample = informed_sample(best_cost)\n            for tree_a, tree_b in [(start_tree, goal_tree),(goal_tree, start_tree)]:\n                nearest_node = nearest(tree_a, sample)\n                new_pos = steer(nearest_node.position, sample, self.step_size)\n                if in_collision(new_pos):\n                    continue\n                if edge_collision(nearest_node.position, new_pos):\n                    continue\n                new_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n                new_node = Node(new_pos, parent=nearest_node, cost=new_cost)\n                nearest_node.add_child(new_node)\n                tree_a.append(new_node)\n                edges.append((nearest_node,new_node))\n                rewire(tree_a, new_node)\n\n                connect_node = nearest(tree_b, new_pos)\n                gap = dist(new_pos, connect_node.position)\n                if gap <= self.step_size*1.8 and not edge_collision(new_pos, connect_node.position):\n                    connect_new = Node(connect_node.position, parent=new_node, cost=new_node.cost+gap)\n                    new_node.add_child(connect_new)\n                    tree_b.append(connect_new)\n                    edges.append((new_node, connect_new))\n                    path = extract_path(connect_new, connect_node)\n                    path = shortcut(path)\n                    cost_path = 0.0\n                    for i in range(len(path)-1):\n                        cost_path += dist(path[i], path[i+1])\n                    if cost_path < best_cost:\n                        best_cost = cost_path\n                        best_path = path\n            if best_path:\n                return PlannerResult(True,best_path,start_tree+goal_tree,edges)\n        return PlannerResult(False,[],start_tree+goal_tree,edges)",
          "objective": -28.64627,
          "time_improvement": 37.0,
          "length_improvement": 14.0,
          "smoothness_improvement": 1851.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.027629590034484862,
                    "num_nodes_avg": 116.4,
                    "path_length_avg": 170.26662958714778,
                    "smoothness_avg": 0.06141652618419348,
                    "success_improvement": 0.0,
                    "time_improvement": -5.244282428030285,
                    "length_improvement": 6.674162275882516,
                    "smoothness_improvement": 861.3020029038676,
                    "objective_score": 6.737722651639762
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.031986331939697264,
                    "num_nodes_avg": 221.9,
                    "path_length_avg": 238.03820887872735,
                    "smoothness_avg": 0.12286205335960987,
                    "success_improvement": 0.0,
                    "time_improvement": 80.63078261308962,
                    "length_improvement": 20.535994326332737,
                    "smoothness_improvement": 3061.329126902844,
                    "objective_score": 51.817477014240744
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.032309651374816895,
                    "num_nodes_avg": 180.3,
                    "path_length_avg": 129.22310027085973,
                    "smoothness_avg": 0.13606286458102096,
                    "success_improvement": 0.0,
                    "time_improvement": 35.74786073539117,
                    "length_improvement": 14.176169742883147,
                    "smoothness_improvement": 1630.7095943546199,
                    "objective_score": 27.383608038120336
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m2",
          "algorithm_description": "A bidirectional RRT* variant that uses informed sampling within an ellipsoidal region (informed RRT*) to bias samples towards the subset of the state space likely to improve the current solution, combined with rewiring for asymptotic optimality. It incorporates direct connection attempts between trees and post-processing shortcutting for smoother, shorter paths.",
          "planning_mechanism": "The planner grows two trees from start and goal alternately, sampling randomly inside an ellipsoid defined by start, goal, and the current best path cost to focus growth in promising areas. Each new node is connected and rewired locally to improve path cost. The trees attempt direct connection when close, and after finding a solution, the planner shortcut-postprocesses the path to enhance smoothness and reduce length.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\nclass Planner:\n    def __init__(self, max_iter=3000, step_size=7.5, rewire_radius=15.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.rewire_radius = rewire_radius\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        edges = []\n        best_cost = float('inf')\n        best_path = []\n\n        def distance(a,b):\n            return math.dist(a,b)\n\n        def is_in_collision(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d = obs\n                    px,py,pz = pos\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                        return True\n                else:\n                    x,y,w,h = obs\n                    px,py = pos\n                    if x <= px <= x+w and y <= py <= y+h:\n                        return True\n            return False\n\n        def is_edge_collision(from_pos, to_pos, resolution=1.0):\n            dist = distance(from_pos, to_pos)\n            steps = max(1,int(dist / resolution))\n            for i in range(steps+1):\n                interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * i/steps for d in range(len(from_pos)))\n                if is_in_collision(interp):\n                    return True\n            return False\n\n        def steer(from_pos, to_pos, max_step):\n            dist = distance(from_pos, to_pos)\n            if dist <= max_step:\n                return to_pos\n            ratio = max_step / dist\n            return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: distance(node.position, point))\n\n        def neighbors(tree, point, radius):\n            result = []\n            r_sq = radius*radius\n            for node in tree:\n                dx = node.position[0] - point[0]\n                dy = node.position[1] - point[1]\n                dz = node.position[2] - point[2] if is_3d else 0.0\n                dist_sq = dx*dx + dy*dy + dz*dz\n                if dist_sq <= r_sq:\n                    result.append(node)\n            return result\n\n        def extract_path(node_start, node_goal):\n            path_start = []\n            while node_start:\n                path_start.append(node_start.position)\n                node_start = node_start.parent\n            path_start.reverse()\n            path_goal = []\n            while node_goal:\n                path_goal.append(node_goal.position)\n                node_goal = node_goal.parent\n            return path_start + path_goal\n\n        def try_connect(node_from, tree_to):\n            near = nearest(tree_to, node_from.position)\n            if is_edge_collision(node_from.position, near.position):\n                return None\n            # direct connection possible, make new node\n            new_node = Node(near.position, parent=node_from, cost=node_from.cost + distance(node_from.position, near.position))\n            node_from.add_child(new_node)\n            tree_to.append(new_node)\n            edges.append((node_from,new_node))\n            return new_node\n\n        def rewire(tree, new_node):\n            nbs = neighbors(tree, new_node.position, self.rewire_radius)\n            for nb in nbs:\n                if nb == new_node.parent:\n                    continue\n                if is_edge_collision(new_node.position, nb.position):\n                    continue\n                new_cost = new_node.cost + distance(new_node.position, nb.position)\n                if new_cost + 1e-7 < nb.cost:\n                    # Rewire nb's parent link\n                    if nb.parent:\n                        try:\n                            nb.parent.children.remove(nb)\n                        except ValueError:\n                            pass\n                    nb.parent = new_node\n                    nb.cost = new_cost\n                    new_node.add_child(nb)\n\n        def informed_sample(c_best):\n            # Sample uniformly inside ellipsoid defined by start, goal, c_best\n            if c_best == float('inf'):\n                # No solution found yet, uniform sample in bounds\n                while True:\n                    sample = tuple(random.uniform(0, bounds[i]) for i in range(len(bounds)))\n                    if not is_in_collision(sample):\n                        return sample\n            else:\n                c_min = distance(start_pos, goal_pos)\n                if c_min == 0.0:\n                    return goal_pos\n                # Ellipsoid parameters\n                center = tuple((start_pos[i]+goal_pos[i])/2 for i in range(len(bounds)))\n                a1 = [(goal_pos[i]-start_pos[i])/c_min for i in range(len(bounds))]\n                # Build rotation matrix to transform unit ball samples\n                # For 2D or 3D the rotation matrix is based on a1 vector\n                # Using Householder transform for rotation to align x-axis with a1\n                dim = len(bounds)\n                def mat_vec_mult(mat, vec):\n                    return tuple(sum(mat[i][j]*vec[j] for j in range(dim)) for i in range(dim))\n                # Construct orthonormal basis with a1 as first basis vector\n                # For 2D and 3D:\n                if dim == 2:\n                    # rotation angle\n                    theta = math.acos(a1[0])\n                    if a1[1]<0:\n                        theta = -theta\n                    # rotation matrix\n                    R = [[math.cos(theta), -math.sin(theta)],\n                         [math.sin(theta), math.cos(theta)]]\n                elif dim ==3:\n                    # Construct a rotation matrix using Householder reflection\n                    # vector to rotate to x = a1\n                    x = a1\n                    I = [[1 if i==j else 0 for j in range(3)] for i in range(3)]\n                    v = [x[0]-1, x[1], x[2]]\n                    norm_v = math.sqrt(sum(vi*vi for vi in v))\n                    if norm_v < 1e-10:\n                        R = I\n                    else:\n                        v = [vi/norm_v for vi in v]\n                        R = [[I[i][j] - 2*v[i]*v[j] for j in range(3)] for i in range(3)]\n                else:\n                    R = [[1 if i==j else 0 for j in range(dim)] for i in range(dim)]\n\n                # lengths of ellipsoid axes\n                L1 = c_best/2.0\n                L_other = math.sqrt(c_best*c_best - c_min*c_min)/2.0\n\n                while True:\n                    # sample random unit vector in unit ball\n                    while True:\n                        sample = [random.uniform(-1,1) for _ in range(dim)]\n                        norm_sample = math.sqrt(sum(x*x for x in sample))\n                        if 0 < norm_sample <= 1:\n                            break\n                    unit_s = [x/norm_sample for x in sample]\n                    r = random.uniform(0,1)**(1/dim)  # radius for uniform ball sampling\n                    unit_ball_sample = [r*us for us in unit_s]\n\n                    # scale by axes\n                    ellipsoid_sample = [L1*unit_ball_sample[0]] + [L_other*unit_ball_sample[i] for i in range(1,dim)]\n\n                    # rotate and translate\n                    if dim == 2 or dim == 3:\n                        rotated = mat_vec_mult(R, ellipsoid_sample)\n                    else:\n                        rotated = ellipsoid_sample\n                    point = tuple(center[i] + rotated[i] for i in range(dim))\n                    if all(0 <= point[i] <= bounds[i] for i in range(dim)):\n                        if not is_in_collision(point):\n                            return point\n\n        def shortcut_path(path):\n            if len(path)<=2:\n                return path\n            i = 0\n            while i < len(path)-2:\n                j = len(path)-1\n                while j > i+1:\n                    if not is_edge_collision(path[i], path[j]):\n                        # shortcut between i and j\n                        path = path[:i+1] + path[j:]\n                        break\n                    j -=1\n                i +=1\n            return path\n\n        for it in range(self.max_iter):\n            sample = informed_sample(best_cost)\n            for tree_a, tree_b in [(start_tree, goal_tree),(goal_tree, start_tree)]:\n                near = nearest(tree_a, sample)\n                new_pos = steer(near.position, sample, self.step_size)\n                if is_in_collision(new_pos):\n                    continue\n                if is_edge_collision(near.position, new_pos):\n                    continue\n                new_cost = near.cost + distance(near.position, new_pos)\n                new_node = Node(new_pos, parent=near, cost=new_cost)\n                near.add_child(new_node)\n                tree_a.append(new_node)\n                edges.append((near,new_node))\n\n                rewire(tree_a, new_node)\n\n                near_to_new = nearest(tree_b, new_pos)\n                dist_trees = distance(new_pos, near_to_new.position)\n                if dist_trees <= self.step_size*2 and not is_edge_collision(new_pos, near_to_new.position):\n                    connect_node = Node(near_to_new.position, parent=new_node, cost=new_node.cost + dist_trees)\n                    new_node.add_child(connect_node)\n                    tree_b.append(connect_node)\n                    edges.append((new_node, connect_node))\n                    path = extract_path(connect_node, connect_node)\n                    # extract_path from new_node to nearest node in other tree\n                    path = extract_path(new_node, near_to_new)\n                    path = shortcut_path(path)\n                    cost_path = 0.0\n                    for k in range(len(path)-1):\n                        cost_path += distance(path[k], path[k+1])\n                    if cost_path < best_cost:\n                        best_cost = cost_path\n                        best_path = path\n            if best_path:\n                return PlannerResult(True, best_path, start_tree+goal_tree, edges)\n        return PlannerResult(False, [], start_tree+goal_tree, edges)",
          "objective": -24.54042,
          "time_improvement": 22.0,
          "length_improvement": 15.0,
          "smoothness_improvement": 1806.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.019874000549316408,
                    "num_nodes_avg": 86.7,
                    "path_length_avg": 165.53372291805212,
                    "smoothness_avg": 0.05590834490258338,
                    "success_improvement": 0.0,
                    "time_improvement": 24.29764885485091,
                    "length_improvement": 9.26834341891934,
                    "smoothness_improvement": 775.0870046395709,
                    "objective_score": 16.725735731004733
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.017957305908203124,
                    "num_nodes_avg": 144.4,
                    "path_length_avg": 240.5533294992943,
                    "smoothness_avg": 0.12055312154964279,
                    "success_improvement": 0.0,
                    "time_improvement": 89.12601287090475,
                    "length_improvement": 19.696374669454404,
                    "smoothness_improvement": 3001.9186483760295,
                    "objective_score": 53.56522190482421
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.07342400550842285,
                    "num_nodes_avg": 284.9,
                    "path_length_avg": 128.16200978596154,
                    "smoothness_avg": 0.13688525836651863,
                    "success_improvement": 0.0,
                    "time_improvement": -46.01362832932536,
                    "length_improvement": 14.88089551925333,
                    "smoothness_improvement": 1641.1703826033552,
                    "objective_score": 3.3303007257711688
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "A simplified bidirectional RRT* inspired planner that alternates growing trees from start and goal by sampling collision-free points, extends toward samples with fixed step size, and rewires local neighbors to improve path cost dynamically. It attempts connecting the trees at each iteration, returning the combined path upon success. This approach balances planning efficiency, path quality, and smoothness through incremental rewiring and early collision checks.",
          "planning_mechanism": "The planner operates by sampling points within bounds avoiding obstacles, nearest neighbor extension with fixed step, rewiring neighbors within a computed radius to optimize cost, and alternating tree expansion. Once the two trees connect, their paths are concatenated to form the final solution.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=4000, step_size=5.0, gamma_rrt_star=30.0, max_radius=40.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.gamma_rrt_star = gamma_rrt_star\n        self.max_radius = max_radius\n\n    def plan(self, map):\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        for i in range(self.max_iter):\n            tree_a, tree_b = (tree_start, tree_goal) if i % 2 == 0 else (tree_goal, tree_start)\n            sample = self._sample_free(bounds, obstacles, is_3d)\n\n            new_node = self._extend_and_rewire(tree_a, sample, obstacles, is_3d, nodes, edges, bounds)\n            if new_node is None:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            connect_node = self._connect_and_rewire(tree_b, new_node, obstacles, is_3d, nodes, edges, bounds)\n            if connect_node:\n                path_a = new_node.path_from_root()\n                path_b = connect_node.path_from_root()\n                if path_a[-1] == path_b[-1]:\n                    path_b = path_b[:-1]\n                full_path = path_a + path_b[::-1]\n                return PlannerResult(True, full_path, nodes, edges)\n\n            tree_a, tree_b = tree_b, tree_a\n\n        return PlannerResult(False, [], nodes, edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        import random\n        dim = len(bounds)\n        while True:\n            pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            if not self._in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def _nearest(self, tree, point):\n        best = None\n        best_dist = float('inf')\n        for node in tree:\n            dist = self._dist(node.position, point)\n            if dist < best_dist:\n                best_dist = dist\n                best = node\n        return best\n\n    def _steer(self, from_pos, to_pos):\n        dist = self._dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(len(from_pos)))\n\n    def _near_nodes(self, tree, position, bounds):\n        n = max(1, len(tree))\n        d = len(position)\n        scale = max(1.0, sum(bounds) / d)\n        r_theory = self.gamma_rrt_star * ((math.log(n + 1) / (n + 1)) ** (1.0 / d))\n        radius = max(self.step_size * 2, min(self.max_radius, r_theory * 0.5 + scale * 0.02))\n        return [node for node in tree if self._dist(node.position, position) <= radius]\n\n    def _extend_and_rewire(self, tree, sample, obstacles, is_3d, nodes, edges, bounds):\n        nearest = self._nearest(tree, sample)\n        new_pos = self._steer(nearest.position, sample)\n        if self._in_obstacle(new_pos, obstacles, is_3d):\n            return None\n        if self._edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n            return None\n\n        neighbors = self._near_nodes(tree, new_pos, bounds)\n        min_cost = nearest.cost + self._dist(nearest.position, new_pos)\n        best_parent = nearest\n        for nb in neighbors:\n            if not self._edge_in_obstacle(nb.position, new_pos, obstacles, is_3d):\n                cost = nb.cost + self._dist(nb.position, new_pos)\n                if cost < min_cost:\n                    min_cost = cost\n                    best_parent = nb\n\n        new_node = Node(new_pos, cost=min_cost)\n        best_parent.add_child(new_node)\n        new_node.cost = min_cost\n        tree.append(new_node)\n        nodes.append(new_node)\n        edges.append((best_parent, new_node))\n\n        for nb in neighbors:\n            if nb == best_parent:\n                continue\n            if not self._edge_in_obstacle(new_node.position, nb.position, obstacles, is_3d):\n                updated_cost = new_node.cost + self._dist(new_node.position, nb.position)\n                if updated_cost < nb.cost:\n                    if nb.parent:\n                        try:\n                            edges.remove((nb.parent, nb))\n                        except ValueError:\n                            pass\n                        if nb in nb.parent.children:\n                            nb.parent.children.remove(nb)\n                    new_node.add_child(nb)\n                    nb.cost = updated_cost\n                    edges.append((new_node, nb))\n        return new_node\n\n    def _connect_and_rewire(self, tree, target_node, obstacles, is_3d, nodes, edges, bounds):\n        nearest = self._nearest(tree, target_node.position)\n        while True:\n            new_pos = self._steer(nearest.position, target_node.position)\n            if self._in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                return None\n\n            neighbors = self._near_nodes(tree, new_pos, bounds)\n            min_cost = nearest.cost + self._dist(nearest.position, new_pos)\n            best_parent = nearest\n            for nb in neighbors:\n                if not self._edge_in_obstacle(nb.position, new_pos, obstacles, is_3d):\n                    cost = nb.cost + self._dist(nb.position, new_pos)\n                    if cost < min_cost:\n                        min_cost = cost\n                        best_parent = nb\n\n            new_node = Node(new_pos, cost=min_cost)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            for nb in neighbors:\n                if nb == best_parent:\n                    continue\n                if not self._edge_in_obstacle(new_node.position, nb.position, obstacles, is_3d):\n                    updated_cost = new_node.cost + self._dist(new_node.position, nb.position)\n                    if updated_cost < nb.cost:\n                        if nb.parent:\n                            try:\n                                edges.remove((nb.parent, nb))\n                            except ValueError:\n                                pass\n                            if nb in nb.parent.children:\n                                nb.parent.children.remove(nb)\n                        new_node.add_child(nb)\n                        nb.cost = updated_cost\n                        edges.append((new_node, nb))\n\n            if self._dist(new_node.position, target_node.position) <= self.step_size:\n                if (not self._edge_in_obstacle(new_node.position, target_node.position, obstacles, is_3d)\n                   and not self._in_obstacle(target_node.position, obstacles, is_3d)):\n                    final_node = Node(target_node.position, cost=new_node.cost + self._dist(new_node.position, target_node.position))\n                    new_node.add_child(final_node)\n                    tree.append(final_node)\n                    nodes.append(final_node)\n                    edges.append((new_node, final_node))\n                    return final_node\n                else:\n                    return None\n            nearest = new_node\n\n    def _in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _edge_in_obstacle(self, p1, p2, obstacles, is_3d, resolution=1.0):\n        dist = self._dist(p1, p2)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(p1[d] + (p2[d] - p1[d]) * i / steps for d in range(len(p1)))\n            if self._in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _dist(self, a, b):\n        s = 0\n        for i in range(len(a)):\n            s += (a[i] - b[i]) ** 2\n        return s ** 0.5",
          "objective": -23.86958,
          "time_improvement": 56.0,
          "length_improvement": 11.0,
          "smoothness_improvement": 157.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.010033559799194337,
                    "num_nodes_avg": 60.9,
                    "path_length_avg": 164.20093510394682,
                    "smoothness_avg": 0.01583828018408221,
                    "success_improvement": 0.0,
                    "time_improvement": 61.78101810606081,
                    "length_improvement": 9.99886553920486,
                    "smoothness_improvement": 147.90347825679143,
                    "objective_score": 25.273142146625116
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.050237512588500975,
                    "num_nodes_avg": 241.6,
                    "path_length_avg": 264.8016597340139,
                    "smoothness_avg": 0.010300759767330584,
                    "success_improvement": 0.0,
                    "time_improvement": 69.57884060795715,
                    "length_improvement": 11.601584087618049,
                    "smoothness_improvement": 165.04596815078446,
                    "objective_score": 28.659832475711898
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.0325772762298584,
                    "num_nodes_avg": 182.9,
                    "path_length_avg": 134.71639352764254,
                    "smoothness_avg": 0.020352271921149336,
                    "success_improvement": 0.0,
                    "time_improvement": 35.21565228605458,
                    "length_improvement": 10.527785924243197,
                    "smoothness_improvement": 158.87939658857192,
                    "objective_score": 17.67576422330515
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "A streamlined bidirectional RRT planner that grows two trees from start and goal by extending towards random collision-free samples with a fixed step size, connecting trees incrementally, and returning a feasible path once connected. It performs collision checking on nodes and edges and maintains coherent parent-child relationships to build efficient paths.",
          "planning_mechanism": "A planner that alternates expanding two trees via fixed-step steering towards uniform random free samples, validates each extension for collisions, attempts to connect trees after each new node, and reconstructs the final path by joining connected tree paths.",
          "code": "class Node:\n    def __init__(self, position, parent=None):\n        self.position = position\n        self.parent = parent\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        node, path = self, []\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=3000, step_size=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map):\n        bounds, start, goal = map.size, map.start, map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        tree_start = [Node(start)]\n        tree_goal = [Node(goal)]\n        nodes = tree_start + tree_goal\n        edges = []\n\n        for i in range(self.max_iter):\n            tree_a, tree_b = (tree_start, tree_goal) if i % 2 == 0 else (tree_goal, tree_start)\n            sample = self._sample_free(bounds, obstacles, is_3d)\n            new_node = self._extend(tree_a, sample, obstacles, is_3d, nodes, edges)\n            if new_node:\n                connected_node = self._connect(tree_b, new_node, obstacles, is_3d, nodes, edges)\n                if connected_node:\n                    path_a = new_node.path_from_root()\n                    path_b = connected_node.path_from_root()\n                    if path_a[-1] == path_b[-1]:\n                        path = path_a + path_b[-2::-1]\n                    else:\n                        path = path_a + path_b[::-1]\n                    return PlannerResult(True, path, nodes, edges)\n        return PlannerResult(False, [], nodes, edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        import random\n        while True:\n            pt = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n            if not self._in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def _extend(self, tree, target, obstacles, is_3d, nodes, edges):\n        nearest = min(tree, key=lambda n: self._dist(n.position, target))\n        new_pos = self._steer(nearest.position, target)\n        if self._valid(nearest.position, new_pos, obstacles, is_3d):\n            new_node = Node(new_pos, nearest)\n            nearest.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest, new_node))\n            return new_node\n        return None\n\n    def _connect(self, tree, target_node, obstacles, is_3d, nodes, edges):\n        nearest = min(tree, key=lambda n: self._dist(n.position, target_node.position))\n        while True:\n            new_pos = self._steer(nearest.position, target_node.position)\n            if not self._valid(nearest.position, new_pos, obstacles, is_3d):\n                return None\n            new_node = Node(new_pos, nearest)\n            nearest.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest, new_node))\n            if self._dist(new_node.position, target_node.position) <= self.step_size:\n                if not self._valid(new_node.position, target_node.position, obstacles, is_3d):\n                    return None\n                final_node = Node(target_node.position, new_node)\n                new_node.add_child(final_node)\n                tree.append(final_node)\n                nodes.append(final_node)\n                edges.append((new_node, final_node))\n                return final_node\n            nearest = new_node\n\n    def _steer(self, start, goal):\n        dist = self._dist(start, goal)\n        if dist <= self.step_size:\n            return goal\n        ratio = self.step_size / dist\n        return tuple(start[d] + (goal[d] - start[d]) * ratio for d in range(len(start)))\n\n    def _valid(self, p1, p2, obstacles, is_3d):\n        return (not self._in_obstacle(p2, obstacles, is_3d)) and (not self._edge_in_obstacle(p1, p2, obstacles, is_3d))\n\n    def _in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x,y,z,w,h,d = obs\n                px,py,pz = pos\n                if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                    return True\n            else:\n                x,y,w,h = obs\n                px,py = pos\n                if x <= px <= x+w and y <= py <= y+h:\n                    return True\n        return False\n\n    def _edge_in_obstacle(self, p1, p2, obstacles, is_3d, res=1.0):\n        dist = self._dist(p1, p2)\n        steps = max(1, int(dist / res))\n        for i in range(steps+1):\n            interp = tuple(p1[d] + (p2[d] - p1[d]) * i / steps for d in range(len(p1)))\n            if self._in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _dist(self, a, b):\n        return sum((a[d] - b[d])**2 for d in range(len(a)))**0.5",
          "objective": -19.65905,
          "time_improvement": 71.0,
          "length_improvement": -3.0,
          "smoothness_improvement": 62.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.007035160064697265,
                    "num_nodes_avg": 86.2,
                    "path_length_avg": 189.39879686980154,
                    "smoothness_avg": 0.0102591145052943,
                    "success_improvement": 0.0,
                    "time_improvement": 73.20226714000162,
                    "length_improvement": -3.8124817803312583,
                    "smoothness_improvement": 60.57742003157615,
                    "objective_score": 19.976078173959614
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.03991465568542481,
                    "num_nodes_avg": 246.5,
                    "path_length_avg": 309.916942499886,
                    "smoothness_avg": 0.006220174309434665,
                    "success_improvement": 0.0,
                    "time_improvement": 75.82981242262478,
                    "length_improvement": -3.4591958710432116,
                    "smoothness_improvement": 60.04956519221755,
                    "objective_score": 20.973674030122595
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.0178729772567749,
                    "num_nodes_avg": 178.1,
                    "path_length_avg": 154.6893175478031,
                    "smoothness_avg": 0.013091758856632583,
                    "success_improvement": 0.0,
                    "time_improvement": 64.45715212295462,
                    "length_improvement": -2.737279201508942,
                    "smoothness_improvement": 66.52620632324673,
                    "objective_score": 18.027409147597258
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "A bidirectional RRT planner that grows two trees from start and goal, alternately extending them towards random samples with fixed steps. It connects trees incrementally upon new node addition and returns the combined path once connected, ensuring collision-free, feasible paths with simple logic for general use.",
          "planning_mechanism": "The planner samples random points within map bounds, extends each tree towards samples in turns checking node and edge collisions, and tries connecting the trees incrementally. It constructs the solution path by concatenating the connected paths from both trees.",
          "code": "class Node:\n    def __init__(self, position, parent=None):\n        self.position = position\n        self.parent = parent\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        path, node = [], self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=3000, step_size=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map):\n        bounds, start, goal = map.size, map.start, map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start)]\n        goal_tree = [Node(goal)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        for i in range(self.max_iter):\n            tree_a, tree_b = (start_tree, goal_tree) if i % 2 == 0 else (goal_tree, start_tree)\n            sample = self._sample_free(bounds, obstacles, is_3d)\n            new_node = self._extend(tree_a, sample, obstacles, is_3d, nodes, edges)\n            if new_node:\n                connected = self._connect(tree_b, new_node, obstacles, is_3d, nodes, edges)\n                if connected:\n                    path_a = new_node.path_from_root()\n                    path_b = connected.path_from_root()\n                    if path_a[-1] == path_b[-1]:\n                        path = path_a + path_b[-2::-1]\n                    else:\n                        path = path_a + path_b[::-1]\n                    return PlannerResult(True, path, nodes, edges)\n        return PlannerResult(False, [], nodes, edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        import random\n        while True:\n            pt = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n            if not self._in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def _extend(self, tree, target, obstacles, is_3d, nodes, edges):\n        nearest = self._nearest(tree, target)\n        new_pos = self._steer(nearest.position, target)\n        if self._valid(nearest.position, new_pos, obstacles, is_3d):\n            new_node = Node(new_pos, nearest)\n            nearest.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest, new_node))\n            return new_node\n        return None\n\n    def _connect(self, tree, target_node, obstacles, is_3d, nodes, edges):\n        nearest = self._nearest(tree, target_node.position)\n        while True:\n            new_pos = self._steer(nearest.position, target_node.position)\n            if not self._valid(nearest.position, new_pos, obstacles, is_3d):\n                return None\n            new_node = Node(new_pos, nearest)\n            nearest.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest, new_node))\n            if self._dist(new_node.position, target_node.position) <= self.step_size:\n                if not self._valid(new_node.position, target_node.position, obstacles, is_3d):\n                    return None\n                final_node = Node(target_node.position, new_node)\n                new_node.add_child(final_node)\n                tree.append(final_node)\n                nodes.append(final_node)\n                edges.append((new_node, final_node))\n                return final_node\n            nearest = new_node\n\n    def _nearest(self, tree, point):\n        return min(tree, key=lambda node: self._dist(node.position, point))\n\n    def _steer(self, start, goal):\n        dist = self._dist(start, goal)\n        if dist <= self.step_size:\n            return goal\n        ratio = self.step_size / dist\n        return tuple(start[d] + ratio * (goal[d] - start[d]) for d in range(len(start)))\n\n    def _valid(self, p1, p2, obstacles, is_3d):\n        return (not self._in_obstacle(p2, obstacles, is_3d)) and (not self._edge_in_obstacle(p1, p2, obstacles, is_3d))\n\n    def _in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x,y,z,w,h,d = obs\n                px,py,pz = pos\n                if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                    return True\n            else:\n                x,y,w,h = obs\n                px,py = pos\n                if x <= px <= x+w and y <= py <= y+h:\n                    return True\n        return False\n\n    def _edge_in_obstacle(self, p1, p2, obstacles, is_3d, res=1.0):\n        dist = self._dist(p1, p2)\n        steps = max(1, int(dist / res))\n        for i in range(steps+1):\n            interp = tuple(p1[d]+(p2[d]-p1[d])*i/steps for d in range(len(p1)))\n            if self._in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _dist(self, a, b):\n        return sum((a[d]-b[d])**2 for d in range(len(a)))**0.5",
          "objective": -18.87672,
          "time_improvement": 69.0,
          "length_improvement": -3.0,
          "smoothness_improvement": 65.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.007088375091552734,
                    "num_nodes_avg": 86.9,
                    "path_length_avg": 192.080687991448,
                    "smoothness_avg": 0.010225328478655104,
                    "success_improvement": 0.0,
                    "time_improvement": 72.99956498956065,
                    "length_improvement": -5.2824688013900305,
                    "smoothness_improvement": 60.04859534714162,
                    "objective_score": 19.030631192769885
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.027634835243225096,
                    "num_nodes_avg": 224.3,
                    "path_length_avg": 302.18866926184023,
                    "smoothness_avg": 0.006484073476451755,
                    "success_improvement": 0.0,
                    "time_improvement": 83.26581702814202,
                    "length_improvement": -0.8792758181722384,
                    "smoothness_improvement": 66.83988083845422,
                    "objective_score": 24.786379021731538
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.025080132484436034,
                    "num_nodes_avg": 207.5,
                    "path_length_avg": 156.98834599359654,
                    "smoothness_avg": 0.013116998064567845,
                    "success_improvement": 0.0,
                    "time_improvement": 50.12474302273537,
                    "length_improvement": -4.2641844272346905,
                    "smoothness_improvement": 66.84724718521873,
                    "objective_score": 12.81314848640589
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "initial",
          "algorithm_description": "This algorithm enhances the standard BI-RRT by incorporating an optimization step that rewires nearby nodes to minimize cost, resulting in asymptotically optimal paths. It grows two trees\u2014one from the start and one from the goal\u2014and attempts to connect them while optimizing the path cost dynamically.",
          "planning_mechanism": "The planning mechanism includes sampling a random point, extending each tree toward it, rewiring neighbors within a radius to optimize the cost, and attempting to connect the two trees. When a connection is established, the combined path is extracted from both trees. Node validity and edge collision checks are strictly enforced throughout the process.",
          "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost: float = 0.0):\n        self.position = position              # Tuple[float, ...]\n        self.parent: Optional[\"Node\"] = parent\n        self.cost: float = cost\n        self.children: List[\"Node\"] = []\n        self.valid = True\n\n    def add_child(self, child_node: \"Node\"):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n\nclass Planner:\n    def __init__(\n        self,\n        max_iter: int = 5000,\n        step_size: float = 5.0,\n        gamma_rrt_star: float = 50.0,\n        max_radius: float = 60.0,\n    ):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.gamma_rrt_star = gamma_rrt_star\n        self.max_radius = max_radius\n\n    # ======================= Public API =======================\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        start_root = Node(start_position, parent=None, cost=0.0)\n        goal_root  = Node(goal_position,  parent=None, cost=0.0)\n        nodes.extend([start_root, goal_root])\n\n        tree_a: List[Node] = [start_root]\n        tree_b: List[Node] = [goal_root]\n\n        for _ in range(self.max_iter):\n            rand_point = self._sample_free(bounds, obstacles, is_3d)\n\n            new_a = self._extend_and_rewire(tree_a, rand_point, obstacles, is_3d, nodes, edges, bounds)\n            if new_a is None:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            new_b = self._connect_and_rewire(tree_b, new_a, obstacles, is_3d, nodes, edges, bounds)\n            if new_b:\n                success_state = True\n                path_a = new_a.path_from_root()\n                path_b = new_b.path_from_root()\n                if path_a and path_b and path_a[-1] == path_b[-1]:\n                    path_b = path_b[:-1]\n                extracted_path = path_a + path_b[::-1]\n                break\n\n            tree_a, tree_b = tree_b, tree_a\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        while True:\n            p = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    def _nearest(self, tree: List[Node], point):\n        return min(tree, key=lambda node: math.dist(node.position, point))\n\n    def _steer(self, from_pos, to_pos):\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _near_nodes(self, tree: List[Node], position, bounds) -> List[Node]:\n        n = max(1, len(tree))\n        d = len(position)\n        # \uacf5\uac04 \uc2a4\ucf00\uc77c\uc744 \uac04\ub2e8\ud788 bounds\ub85c \ucd94\uc815 (\uc815\ubc00 X, \uc2e4\uc6a9\uc801)\n        scale = max(1.0, sum(bounds) / d)\n        r_theory = self.gamma_rrt_star * ((math.log(n + 1) / (n + 1)) ** (1.0 / d))\n        radius = max(self.step_size * 2.0, min(self.max_radius, r_theory * 0.5 + scale * 0.02))\n        return [node for node in tree if math.dist(node.position, position) <= radius]\n\n    def _choose_parent_and_add(self, tree, new_pos, obstacles, is_3d, nodes, edges, bounds):\n        nearest = self._nearest(tree, new_pos)\n        neighbors = self._near_nodes(tree, new_pos, bounds)\n\n        min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n        best_parent = nearest\n\n        for nb in neighbors:\n            if not self._is_edge_in_obstacle(nb.position, new_pos, obstacles, is_3d):\n                cand = nb.cost + math.dist(nb.position, new_pos)\n                if cand < min_cost:\n                    min_cost = cand\n                    best_parent = nb\n\n        new_node = Node(new_pos, parent=None, cost=min_cost)\n        best_parent.add_child(new_node)\n        tree.append(new_node)\n        nodes.append(new_node)\n        edges.append((best_parent, new_node))\n        return new_node, neighbors\n\n    def _rewire_from(self, pivot: Node, neighbors: List[Node], obstacles, is_3d, edges):\n        for nb in neighbors:\n            if not self._is_edge_in_obstacle(pivot.position, nb.position, obstacles, is_3d):\n                new_cost = pivot.cost + math.dist(pivot.position, nb.position)\n                if new_cost + 1e-12 < nb.cost:  # \uc791\uc740 \uc218\uce58 \ubc84\ud37c\n                    if nb.parent is not None:\n                        try:\n                            edges.remove((nb.parent, nb))\n                        except ValueError:\n                            pass\n                        if nb in nb.parent.children:\n                            nb.parent.children.remove(nb)\n                    pivot.add_child(nb)\n                    nb.cost = new_cost\n                    edges.append((pivot, nb))\n\n    def _extend_and_rewire(self, tree, sample_point, obstacles, is_3d, nodes, edges, bounds):\n        nearest = self._nearest(tree, sample_point)\n        new_pos = self._steer(nearest.position, sample_point)\n\n        if self._is_in_obstacle(new_pos, obstacles, is_3d):\n            return None\n        if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n            return None\n\n        new_node, neighbors = self._choose_parent_and_add(tree, new_pos, obstacles, is_3d, nodes, edges, bounds)\n        self._rewire_from(new_node, neighbors, obstacles, is_3d, edges)\n        return new_node\n\n    def _connect_and_rewire(self, tree, target_node: Node, obstacles, is_3d, nodes, edges, bounds):\n        nearest = self._nearest(tree, target_node.position)\n\n        while True:\n            new_pos = self._steer(nearest.position, target_node.position)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                return None\n\n            connect_node, neighbors = self._choose_parent_and_add(tree, new_pos, obstacles, is_3d, nodes, edges, bounds)\n            self._rewire_from(connect_node, neighbors, obstacles, is_3d, edges)\n\n            if math.dist(connect_node.position, target_node.position) <= self.step_size:\n                if (not self._is_edge_in_obstacle(connect_node.position, target_node.position, obstacles, is_3d) and\n                    not self._is_in_obstacle(target_node.position, obstacles, is_3d)):\n                    final_node = Node(target_node.position, parent=None, cost=connect_node.cost + math.dist(connect_node.position, target_node.position))\n                    connect_node.add_child(final_node)\n                    tree.append(final_node)\n                    nodes.append(final_node)\n                    edges.append((connect_node, final_node))\n                    return final_node\n                else:\n                    return None\n\n            nearest = connect_node\n\n        \n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n        \n        \n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n",
          "objective": -18.596615900992976,
          "time_improvement": 38.0,
          "length_improvement": 11.0,
          "smoothness_improvement": 172.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.0230562686920166,
                    "num_nodes_avg": 97.6,
                    "path_length_avg": 161.12249215478707,
                    "smoothness_avg": 0.018062462568387585,
                    "success_improvement": 0.0,
                    "time_improvement": 12.176023931931311,
                    "length_improvement": 11.686208900689492,
                    "smoothness_improvement": 182.71676246052309,
                    "objective_score": 11.578116332295703
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.035856032371521,
                    "num_nodes_avg": 250.1,
                    "path_length_avg": 265.1599124520743,
                    "smoothness_avg": 0.010159869700973916,
                    "success_improvement": 0.0,
                    "time_improvement": 78.28749833068048,
                    "length_improvement": 11.481989018596753,
                    "smoothness_improvement": 161.42076526441443,
                    "objective_score": 31.182546736684266
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.038674354553222656,
                    "num_nodes_avg": 237.3,
                    "path_length_avg": 137.40430639955787,
                    "smoothness_avg": 0.021326989594760596,
                    "success_improvement": 0.0,
                    "time_improvement": 23.090782197070272,
                    "length_improvement": 8.742602179373693,
                    "smoothness_improvement": 171.27773345073243,
                    "objective_score": 13.02918463399896
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "A simplified bidirectional RRT planner that balances efficient path finding and computational efficiency by alternating tree expansion from start and goal positions, using straightforward extension steps and rigorous collision checks without costly rewiring or informed sampling. The algorithm prioritizes easy implementation and reliable success at the cost of advanced path cost optimization or smoothing.",
          "planning_mechanism": "class 'Node'",
          "code": "class Node:\n    def __init__(self, position, parent=None):\n        self.position = position\n        self.parent = parent\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map):\n        bounds = map.size\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start)]\n        goal_tree = [Node(goal)]\n\n        nodes = start_tree + goal_tree\n        edges = []\n\n        for i in range(self.max_iter):\n            tree_a, tree_b = (start_tree, goal_tree) if i % 2 == 0 else (goal_tree, start_tree)\n\n            rand_point = self._sample_free(bounds, obstacles, is_3d)\n            new_node_a = self._extend(tree_a, rand_point, obstacles, is_3d, nodes, edges)\n            if new_node_a is None:\n                continue\n\n            new_node_b = self._connect(tree_b, new_node_a, obstacles, is_3d, nodes, edges)\n            if new_node_b is not None:\n                path_start = new_node_a.path_from_root()\n                path_goal = new_node_b.path_from_root()\n                # Avoid duplicating connecting node\n                if path_start[-1] == path_goal[-1]:\n                    full_path = path_start + path_goal[-2::-1]\n                else:\n                    full_path = path_start + path_goal[::-1]\n                return PlannerResult(\n                    success=True,\n                    path=full_path,\n                    nodes=nodes,\n                    edges=edges\n                )\n\n        return PlannerResult(\n            success=False,\n            path=[],\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        while True:\n            if is_3d:\n                p = tuple(random.uniform(0, bounds[d]) for d in range(3))\n            else:\n                p = tuple(random.uniform(0, bounds[d]) for d in range(2))\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    def _nearest(self, tree, point):\n        return min(tree, key=lambda node: self._distance(node.position, point))\n\n    def _steer(self, from_pos, to_pos):\n        dist = self._distance(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(len(from_pos)))\n\n    def _extend(self, tree, point, obstacles, is_3d, nodes, edges):\n        nearest = self._nearest(tree, point)\n        new_pos = self._steer(nearest.position, point)\n        if (self._within_bounds(new_pos, edges, nodes) and\n            not self._is_in_obstacle(new_pos, obstacles, is_3d) and\n            not self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d)):\n            new_node = Node(new_pos)\n            nearest.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest, new_node))\n            return new_node\n        return None\n\n    def _connect(self, tree, target_node, obstacles, is_3d, nodes, edges):\n        current = self._nearest(tree, target_node.position)\n        while True:\n            new_pos = self._steer(current.position, target_node.position)\n            if not self._within_bounds(new_pos, edges, nodes):\n                return None\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(current.position, new_pos, obstacles, is_3d):\n                return None\n            new_node = Node(new_pos)\n            current.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((current, new_node))\n            if self._distance(new_node.position, target_node.position) <= self.step_size:\n                if not self._is_edge_in_obstacle(new_node.position, target_node.position, obstacles, is_3d):\n                    final_node = Node(target_node.position)\n                    new_node.add_child(final_node)\n                    tree.append(final_node)\n                    nodes.append(final_node)\n                    edges.append((new_node, final_node))\n                    return final_node\n                else:\n                    return None\n            current = new_node\n\n    def _within_bounds(self, pos, edges, nodes):\n        dims = len(pos)\n        if hasattr(edges, '__len__') and nodes:\n            # edges and nodes arguments don't provide bounds, re-checking not needed\n            # Instead, handle bounds from map.size (caller)\n            # Simplify to true since map bounds are enforced in sampling and steering\n            return True\n        # fallback check (shouldn't occur)\n        return all(0.0 <= pos[d] <= 10000.0 for d in range(dims))  # large bound\n\n    def _distance(self, a, b):\n        return math.sqrt(sum((a[d]-b[d])**2 for d in range(len(a))))\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, p1, p2, obstacles, is_3d, resolution=1.0):\n        dist = self._distance(p1, p2)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(p1[d] + (p2[d] - p1[d]) * i / steps for d in range(len(p1)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -15.67822,
          "time_improvement": 51.0,
          "length_improvement": 0.0,
          "smoothness_improvement": 68.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.007469820976257324,
                    "num_nodes_avg": 73.1,
                    "path_length_avg": 176.0623468550158,
                    "smoothness_avg": 0.0107998836069439,
                    "success_improvement": 0.0,
                    "time_improvement": 71.54659379560685,
                    "length_improvement": 3.4974378023468984,
                    "smoothness_improvement": 69.04163077129193,
                    "objective_score": 23.907648973946657
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.03709430694580078,
                    "num_nodes_avg": 234.9,
                    "path_length_avg": 302.79595763742356,
                    "smoothness_avg": 0.006446290084951689,
                    "success_improvement": 0.0,
                    "time_improvement": 77.53766526263358,
                    "length_improvement": -1.0820061577686475,
                    "smoothness_improvement": 65.86768696088066,
                    "objective_score": 22.941434318933286
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.04822392463684082,
                    "num_nodes_avg": 247.1,
                    "path_length_avg": 154.05757544889508,
                    "smoothness_avg": 0.013304546360919387,
                    "success_improvement": 0.0,
                    "time_improvement": 4.100162341356848,
                    "length_improvement": -2.3177061797402922,
                    "smoothness_improvement": 69.23284767143511,
                    "objective_score": 0.1855892329200547
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "A simplified bidirectional RRT planner that grows two trees from start and goal positions, alternately extending each tree towards random collision-free samples using fixed step sizes. The planner attempts to connect the trees incrementally when new nodes are added. Both node and edge collision checks are performed. The path is constructed once the two trees connect, ensuring feasible, relatively efficient paths with minimal complexity for better generalization.",
          "planning_mechanism": "class Node and Planner with plan(map) method below",
          "code": "class Node:\n    def __init__(self, position, parent=None):\n        self.position = position\n        self.parent = parent\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=3000, step_size=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map):\n        bounds = map.size\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start)]\n        goal_tree = [Node(goal)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        for i in range(self.max_iter):\n            tree_a, tree_b = (start_tree, goal_tree) if i % 2 == 0 else (goal_tree, start_tree)\n            sample = self._sample_free(bounds, obstacles, is_3d)\n            new_node = self._extend(tree_a, sample, obstacles, is_3d, nodes, edges)\n            if new_node:\n                connected_node = self._connect(tree_b, new_node, obstacles, is_3d, nodes, edges)\n                if connected_node:\n                    path_a = new_node.path_from_root()\n                    path_b = connected_node.path_from_root()\n                    if path_a[-1] == path_b[-1]:\n                        full_path = path_a + path_b[-2::-1]\n                    else:\n                        full_path = path_a + path_b[::-1]\n                    return PlannerResult(True, full_path, nodes, edges)\n        return PlannerResult(False, [], nodes, edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        import random\n        while True:\n            if is_3d:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(3))\n            else:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(2))\n            if not self._in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def _extend(self, tree, target, obstacles, is_3d, nodes, edges):\n        nearest = self._nearest(tree, target)\n        new_pos = self._steer(nearest.position, target)\n        if self._valid(nearest.position, new_pos, obstacles, is_3d):\n            new_node = Node(new_pos, nearest)\n            nearest.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest, new_node))\n            return new_node\n        return None\n\n    def _connect(self, tree, target_node, obstacles, is_3d, nodes, edges):\n        import math\n        nearest = self._nearest(tree, target_node.position)\n        while True:\n            new_pos = self._steer(nearest.position, target_node.position)\n            if not self._valid(nearest.position, new_pos, obstacles, is_3d):\n                return None\n            new_node = Node(new_pos, nearest)\n            nearest.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest, new_node))\n            if self._dist(new_node.position, target_node.position) <= self.step_size:\n                if not self._valid(new_node.position, target_node.position, obstacles, is_3d):\n                    return None\n                final_node = Node(target_node.position, new_node)\n                new_node.add_child(final_node)\n                tree.append(final_node)\n                nodes.append(final_node)\n                edges.append((new_node, final_node))\n                return final_node\n            nearest = new_node\n\n    def _nearest(self, tree, point):\n        return min(tree, key=lambda node: self._dist(node.position, point))\n\n    def _steer(self, start, goal):\n        dist = self._dist(start, goal)\n        if dist <= self.step_size:\n            return goal\n        ratio = self.step_size / dist\n        return tuple(start[d] + ratio * (goal[d] - start[d]) for d in range(len(start)))\n\n    def _valid(self, from_pos, to_pos, obstacles, is_3d):\n        return (not self._in_obstacle(to_pos, obstacles, is_3d)) and (not self._edge_in_obstacle(from_pos, to_pos, obstacles, is_3d))\n\n    def _in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x,y,z,w,h,d = obs\n                px,py,pz = pos\n                if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                    return True\n            else:\n                x,y,w,h = obs\n                px,py = pos\n                if x <= px <= x+w and y <= py <= y+h:\n                    return True\n        return False\n\n    def _edge_in_obstacle(self, p1, p2, obstacles, is_3d, resolution=1.0):\n        dist = self._dist(p1, p2)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps+1):\n            interp = tuple(p1[d] + (p2[d] - p1[d]) * i/steps for d in range(len(p1)))\n            if self._in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _dist(self, a, b):\n        return sum((a[d]-b[d])**2 for d in range(len(a)))**0.5",
          "objective": -15.03779,
          "time_improvement": 55.0,
          "length_improvement": -3.0,
          "smoothness_improvement": 63.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.007532596588134766,
                    "num_nodes_avg": 83.5,
                    "path_length_avg": 189.84030889041793,
                    "smoothness_avg": 0.010321372451574455,
                    "success_improvement": 0.0,
                    "time_improvement": 71.30747427853201,
                    "length_improvement": -4.054481515036774,
                    "smoothness_improvement": 61.55189208615482,
                    "objective_score": 19.267312834968312
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.04050443172454834,
                    "num_nodes_avg": 246.8,
                    "path_length_avg": 304.88351138240876,
                    "smoothness_avg": 0.006376895060333369,
                    "success_improvement": 0.0,
                    "time_improvement": 75.47267549511115,
                    "length_improvement": -1.778891684747648,
                    "smoothness_improvement": 64.08210299423538,
                    "objective_score": 21.89487815265593
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.04095637798309326,
                    "num_nodes_avg": 217.6,
                    "path_length_avg": 155.40404903932387,
                    "smoothness_avg": 0.01277627099031739,
                    "success_improvement": 0.0,
                    "time_improvement": 18.552668011925263,
                    "length_improvement": -3.2119698263207472,
                    "smoothness_improvement": 62.513223950609444,
                    "objective_score": 3.951184627538178
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "initial",
          "algorithm_description": "This algorithm is a bidirectional extension of RRT* that grows two trees from start and goal while optimizing paths via rewiring. It combines RRT*\u2018s asymptotic optimality with RRT-Connect\u2019s fast convergence through connection attempts between the trees.",
          "planning_mechanism": "The planner alternates growing two trees with sampling, extension, and rewiring. After each extension, it attempts to connect both trees. When connection is successful, a rewired optimal path is extracted across both trees.",
          "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, radius: float = 10.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.radius = radius\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n        nodes = []\n        edges = []\n        success_state = False\n        extracted_path = []\n\n        for iter in range(self.max_iter):\n            rand = self._sample_free(bounds, obstacles, is_3d)\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest = self._nearest(tree_a, rand)\n                new_pos = self._steer(nearest.position, rand, self.step_size)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                    continue\n\n                new_node = Node(new_pos)\n                near_nodes = self._near(tree_a, new_pos, self.radius)\n                min_cost = nearest.cost + self._distance(nearest.position, new_pos)\n                min_parent = nearest\n\n                for near in near_nodes:\n                    cost = near.cost + self._distance(near.position, new_pos)\n                    if cost < min_cost and not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d):\n                        min_cost = cost\n                        min_parent = near\n\n                new_node.parent = min_parent\n                new_node.cost = min_cost\n                min_parent.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((min_parent, new_node))\n\n                for near in near_nodes:\n                    if near == min_parent:\n                        continue\n                    new_cost = new_node.cost + self._distance(new_node.position, near.position)\n                    if new_cost < near.cost and not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                        if near.parent:\n                            edges.remove((near.parent, near))\n                        near.parent = new_node\n                        near.cost = new_cost\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n\n                connect_node = self._nearest(tree_b, new_node.position)\n                if self._distance(new_node.position, connect_node.position) < self.step_size and not self._is_edge_in_obstacle(new_node.position, connect_node.position, obstacles, is_3d):\n                    success_state = True\n                    extracted_path = self._extract_path(new_node, connect_node)\n                    return PlannerResult(True, extracted_path, start_tree + goal_tree, edges)\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        while True:\n            point = tuple(random.uniform(0, bounds[i]) for i in range(3 if is_3d else 2))\n            if not self._is_in_obstacle(point, obstacles, is_3d):\n                return point\n\n    def _nearest(self, tree, point):\n        return min(tree, key=lambda node: self._distance(node.position, point))\n\n    def _near(self, tree, point, radius):\n        return [node for node in tree if self._distance(node.position, point) <= radius]\n\n    def _steer(self, from_pos, to_pos, step_size):\n        dist = self._distance(from_pos, to_pos)\n        if dist <= step_size:\n            return to_pos\n        ratio = step_size / dist\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n    def _extract_path(self, node_a, node_b):\n        path_a = []\n        while node_a:\n            path_a.append(node_a.position)\n            node_a = node_a.parent\n        path_b = []\n        while node_b:\n            path_b.append(node_b.position)\n            node_b = node_b.parent\n        return list(reversed(path_a)) + path_b\n\n    def _distance(self, a, b):\n        return math.dist(a, b)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = self._distance(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n    ",
          "objective": -14.623200909903078,
          "time_improvement": 26.0,
          "length_improvement": 10.0,
          "smoothness_improvement": 172.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.01557013988494873,
                    "num_nodes_avg": 154.3,
                    "path_length_avg": 176.4019709606193,
                    "smoothness_avg": 0.016468810147838416,
                    "success_improvement": 0.0,
                    "time_improvement": 40.69154853726605,
                    "length_improvement": 3.3112844483772665,
                    "smoothness_improvement": 157.7726414073074,
                    "objective_score": 14.983098437242711
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.019739508628845215,
                    "num_nodes_avg": 283.4,
                    "path_length_avg": 260.814162084563,
                    "smoothness_avg": 0.010965222085418455,
                    "success_improvement": 0.0,
                    "time_improvement": 88.04680591498561,
                    "length_improvement": 12.9327255767608,
                    "smoothness_improvement": 182.14306218804825,
                    "objective_score": 35.084392431492404
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.07533800601959229,
                    "num_nodes_avg": 439.2,
                    "path_length_avg": 130.82946919354052,
                    "smoothness_avg": 0.021737514839812764,
                    "success_improvement": 0.0,
                    "time_improvement": -49.81987885086595,
                    "length_improvement": 13.109295991506725,
                    "smoothness_improvement": 176.49958426597442,
                    "objective_score": -6.197888139025877
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "A simplified bidirectional RRT* planner that alternately grows two trees from start and goal using fixed step-size steering, nearest neighbor connection, and local rewiring with a fixed radius. The algorithm attempts to connect the two trees when nodes are nearby and extracts the combined path. After finding a path, a simple shortcutting step reduces unnecessary waypoints to improve smoothness and path length. This streamlined version reduces overhead while preserving feasible, short, and smooth paths.",
          "planning_mechanism": "A bidirectional RRT* variant that grows two trees alternately by sampling points, steering from nearest nodes, rewiring neighbors within a fixed radius to improve costs, and attempts to connect the trees when close. Upon connection, it extracts and shortcuts the path for quality.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\nclass Planner:\n    def __init__(self, max_iter=2000, step_size=5.0, radius=15.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.radius = radius\n\n    def plan(self, map):\n        bounds = map.size\n        start = Node(map.start)\n        goal = Node(map.goal)\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = dim == 3\n\n        tree_start = [start]\n        tree_goal = [goal]\n\n        def dist(a, b):\n            return sum((a[i]-b[i])**2 for i in range(dim))**0.5\n\n        def in_obstacle(p):\n            if not obstacles:\n                return False\n            if is_3d:\n                x,y,z = p\n                for ox, oy, oz, w, h, d in obstacles:\n                    if ox <= x <= ox+w and oy <= y <= oy+h and oz <= z <= oz+d:\n                        return True\n            else:\n                x,y = p\n                for ox, oy, w, h in obstacles:\n                    if ox <= x <= ox+w and oy <= y <= oy+h:\n                        return True\n            return False\n\n        def collision_free(frm, to):\n            d = dist(frm, to)\n            steps = max(1, int(d))\n            for i in range(steps + 1):\n                interp = tuple(frm[j] + (to[j]-frm[j]) * i/steps for j in range(dim))\n                if in_obstacle(interp):\n                    return False\n            return True\n\n        import random\n\n        def sample_free():\n            while True:\n                p = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not in_obstacle(p):\n                    return p\n\n        def steer(frm, to):\n            d = dist(frm, to)\n            if d <= self.step_size:\n                return to\n            ratio = self.step_size / d\n            return tuple(frm[i] + (to[i]-frm[i]) * ratio for i in range(dim))\n\n        def nearest(tree, point):\n            best = tree[0]\n            best_d = dist(best.position, point)\n            for node in tree:\n                d = dist(node.position, point)\n                if d < best_d:\n                    best, best_d = node, d\n            return best\n\n        def near_nodes(tree, point):\n            return [node for node in tree if dist(node.position, point) <= self.radius]\n\n        def add_node(tree, pos):\n            near = near_nodes(tree, pos)\n            min_cost, min_parent = None, None\n            for node in near:\n                if collision_free(node.position, pos):\n                    c = node.cost + dist(node.position, pos)\n                    if min_cost is None or c < min_cost:\n                        min_cost, min_parent = c, node\n            if min_parent is None:\n                min_parent = nearest(tree, pos)\n                if not collision_free(min_parent.position, pos):\n                    return None\n                min_cost = min_parent.cost + dist(min_parent.position, pos)\n            new_node = Node(pos, parent=min_parent, cost=min_cost)\n            min_parent.add_child(new_node)\n            tree.append(new_node)\n            rewire(new_node, tree)\n            return new_node\n\n        def rewire(new_node, tree):\n            for node in near_nodes(tree, new_node.position):\n                if node is new_node.parent:\n                    continue\n                if collision_free(new_node.position, node.position):\n                    c = new_node.cost + dist(new_node.position, node.position)\n                    if c + 1e-9 < node.cost:\n                        if node.parent:\n                            try:\n                                node.parent.children.remove(node)\n                            except ValueError:\n                                pass\n                        node.parent = new_node\n                        node.cost = c\n                        new_node.children.append(node)\n\n        def extract_path(node):\n            path = []\n            while node:\n                path.append(node.position)\n                node = node.parent\n            return path[::-1]\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            shortened = [path[0]]\n            i = 0\n            while i < len(path) - 1:\n                j = len(path) - 1\n                while j > i + 1:\n                    if collision_free(path[i], path[j]):\n                        break\n                    j -= 1\n                shortened.append(path[j])\n                i = j\n            return shortened\n\n        success = False\n        best_path = []\n        best_cost = float('inf')\n\n        for i in range(self.max_iter):\n            rand_pos = sample_free()\n            tree_a, tree_b = (tree_start, tree_goal) if i % 2 == 0 else (tree_goal, tree_start)\n            nearest_node = nearest(tree_a, rand_pos)\n            new_pos = steer(nearest_node.position, rand_pos)\n            if in_obstacle(new_pos):\n                continue\n            new_node = add_node(tree_a, new_pos)\n            if new_node is None:\n                continue\n            nearest_to_new = nearest(tree_b, new_node.position)\n            if dist(new_node.position, nearest_to_new.position) <= self.step_size:\n                if collision_free(new_node.position, nearest_to_new.position):\n                    connector = Node(nearest_to_new.position, parent=new_node,\n                                     cost=new_node.cost + dist(new_node.position, nearest_to_new.position))\n                    new_node.add_child(connector)\n                    tree_a.append(connector)\n                    path_start = extract_path(connector if tree_a is tree_start else nearest_to_new)\n                    path_goal = extract_path(nearest_to_new if tree_a is tree_start else connector)\n                    combined = path_start + path_goal[::-1][1:]\n                    shortcut = shortcut_path(combined)\n                    cost = sum(dist(shortcut[i], shortcut[i+1]) for i in range(len(shortcut)-1))\n                    if cost < best_cost:\n                        best_cost = cost\n                        best_path = shortcut\n                        success = True\n                    break\n\n        return PlannerResult(success, best_path, tree_start + tree_goal, [])",
          "objective": -14.56634,
          "time_improvement": -11.0,
          "length_improvement": 19.0,
          "smoothness_improvement": 1357.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.035758161544799806,
                    "num_nodes_avg": 95.1,
                    "path_length_avg": 158.08045278022354,
                    "smoothness_avg": 0.0437108561114864,
                    "success_improvement": 0.0,
                    "time_improvement": -36.20694509151112,
                    "length_improvement": 13.353598886086381,
                    "smoothness_improvement": 584.1698177880498,
                    "objective_score": 0.0709248931387414
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.14818284511566163,
                    "num_nodes_avg": 270.9,
                    "path_length_avg": 229.20584772072934,
                    "smoothness_avg": 0.08798497858952058,
                    "success_improvement": 0.0,
                    "time_improvement": 10.268368831187576,
                    "length_improvement": 23.484490706292497,
                    "smoothness_improvement": 2163.9168721268857,
                    "objective_score": 27.990789433766196
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.053970956802368165,
                    "num_nodes_avg": 154.9,
                    "path_length_avg": 122.40981172898974,
                    "smoothness_avg": 0.1118739121743925,
                    "success_improvement": 0.0,
                    "time_improvement": -7.328593319729027,
                    "length_improvement": 18.70123157845707,
                    "smoothness_improvement": 1323.0279051850484,
                    "objective_score": 15.637300477080775
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e2",
          "algorithm_description": "A hybrid bidirectional RRT* variant integrating goal bias sampling, informed rewiring, and adaptive step size to efficiently find shorter, smoother, and feasible paths in 2D/3D spaces. It uses informed sampling to speed convergence, rigorous collision checking ensuring safe expansions, incremental rewiring to optimize path cost, and path shortcutting to smooth the final output.",
          "planning_mechanism": "A bidirectional tree grows from start and goal, alternately sampling with goal bias and within an ellipsoidal informed set once a solution is found. New nodes are extended from nearest tree nodes with adaptive step size considering proximity. After adding a new node, rewiring is performed to update neighbor connections minimizing cost to come. The two trees attempt connection after each extension. Upon successful connection, the combined path is shortcut and returned.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def path_from_root(self):\n        path, node = [], self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=4.0, goal_sample_rate=0.1, neighbor_radius=10.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate  # Probability of sampling goal\n        self.neighbor_radius = neighbor_radius    # Radius to search for rewiring neighbors\n\n    def plan(self, map):\n        bounds = map.size\n        start, goal = map.start, map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        start_tree = [Node(start, cost=0.0)]\n        goal_tree = [Node(goal, cost=0.0)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        best_cost = float('inf')\n        best_connection = None\n\n        def dist(a, b):\n            return sum((a[d]-b[d])**2 for d in range(dim))**0.5\n\n        def line_cost(a, b):\n            return dist(a, b)\n\n        # Utility for collision checking a single point\n        def in_obstacle(p):\n            if is_3d:\n                x, y, z = p\n                for ox, oy, oz, w, h, d in obstacles:\n                    if ox <= x <= ox + w and oy <= y <= oy + h and oz <= z <= oz + d:\n                        return True\n            else:\n                x, y = p\n                for ox, oy, w, h in obstacles:\n                    if ox <= x <= ox + w and oy <= y <= oy + h:\n                        return True\n            return False\n\n        # Checks collision for edge p1->p2 by interpolation with resolution = 1.0 units\n        def edge_in_obstacle(p1, p2):\n            dist_p = dist(p1, p2)\n            steps = max(1, int(dist_p / 1.0))\n            for i in range(steps + 1):\n                interp = tuple(p1[d] + (p2[d]-p1[d])*i/steps for d in range(dim))\n                if in_obstacle(interp):\n                    return True\n            return False\n\n        # Sample free point with goal bias and informed ellipsoid sampling if solution found\n        def sample_free():\n            if best_connection and random.random() > self.goal_sample_rate:\n                # Informed ellipsoid sampling within informed subset (prolate hyperspheroid)\n                c_min = dist(start, goal)\n                c_best = best_cost\n                if c_best < float('inf') and c_best > c_min:\n                    center = [(s+g)*0.5 for s,g in zip(start, goal)]\n                    a1 = [(g - s)/c_min for s,g in zip(start, goal)]\n                    # Sample unit ball in dim-dim space and transform\n                    while True:\n                        x_ball = [random.gauss(0,1) for _ in range(dim)]\n                        norm = (sum(x**2 for x in x_ball))**0.5\n                        if norm <= 1:\n                            unit = [x / norm for x in x_ball]\n                            r1 = c_best / 2.0\n                            r2 = (c_best**2 - c_min**2)**0.5 / 2.0 if c_best**2 - c_min**2 > 0 else 0.0\n                            # Construct scaled unit vector in bounding box of ellipsoid\n                            if dim == 2:\n                                # Rotation matrix from a1 to x axis\n                                angle = math.atan2(a1[1], a1[0])\n                                cos_ang = math.cos(angle)\n                                sin_ang = math.sin(angle)\n                                # Scale unit ball coordinates\n                                x_ell = r1 * unit[0]\n                                y_ell = r2 * unit[1]\n                                # Rotate back to world frame and translate\n                                px = center[0] + cos_ang * x_ell - sin_ang * y_ell\n                                py = center[1] + sin_ang * x_ell + cos_ang * y_ell\n                                pt = (px, py)\n                            else:\n                                # 3D case: align a1 with x axis by rotation matrix (approximate)\n                                # To simplify, sample box around center limited by bounds\n                                pt_candidate = [center[d] + r1*unit[0] if d == 0 else center[d] + r2*unit[d] for d in range(dim)]\n                                pt = tuple(max(0,min(pt_candidate[d], bounds[d])) for d in range(dim))\n                            if (all(0 <= pt[d] <= bounds[d] for d in range(dim)) and not in_obstacle(pt)):\n                                return pt\n                else:\n                    # If no valid c_best, fall back to uniform\n                    return uniform_sample()\n            # else regular or goal biased sample\n            if random.random() < self.goal_sample_rate:\n                return goal\n            else:\n                return uniform_sample()\n\n        def uniform_sample():\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not in_obstacle(pt):\n                    return pt\n\n        # Find the nearest node in a tree by Euclidean distance\n        def nearest(tree, point):\n            best = None\n            best_dist = float('inf')\n            for node in tree:\n                d = dist(node.position, point)\n                if d < best_dist:\n                    best = node\n                    best_dist = d\n            return best\n\n        # Steer from from_pos towards to_pos by step size or closer\n        def steer(from_pos, to_pos, max_step):\n            d = dist(from_pos, to_pos)\n            if d <= max_step:\n                return to_pos\n            ratio = max_step / d\n            return tuple(from_pos[d_] + ratio * (to_pos[d_] - from_pos[d_]) for d_ in range(dim))\n\n        # Find neighbors within radius for rewiring\n        def near(tree, node, radius):\n            ret = []\n            for n in tree:\n                if dist(n.position, node.position) <= radius:\n                    ret.append(n)\n            return ret\n\n        # Attempt to add new node to tree with rewiring for cost improvement\n        def extend_with_rewire(tree, point):\n            nearest_node = nearest(tree, point)\n            new_pos = steer(nearest_node.position, point, self.step_size)\n            if in_obstacle(new_pos) or edge_in_obstacle(nearest_node.position, new_pos):\n                return None\n            new_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            new_node = Node(new_pos, parent=nearest_node, cost=new_cost)\n            nearest_node.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n\n            # Rewire neighbors if cheaper to reach via new_node\n            neighbors = near(tree, new_node, self.neighbor_radius)\n            for neighbor in neighbors:\n                if neighbor == new_node.parent:\n                    continue\n                cost_to_neighbor = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_to_neighbor < neighbor.cost:\n                    # Check if edge is collision free before rewiring\n                    if not edge_in_obstacle(new_node.position, neighbor.position):\n                        # Rewire\n                        if neighbor.parent:\n                            neighbor.parent.remove_child(neighbor)\n                        neighbor.parent = new_node\n                        new_node.children.append(neighbor)\n                        # Update costs downstream by DFS\n                        def update_costs(n):\n                            for c in n.children:\n                                old_cost = c.cost\n                                c.cost = n.cost + dist(n.position, c.position)\n                                if c.cost < old_cost:\n                                    update_costs(c)\n                        neighbor.cost = cost_to_neighbor\n                        update_costs(neighbor)\n\n            return new_node\n\n        # Try to connect tree_b to node from tree_a by single edge\n        def try_connect(tree_b, node_a):\n            nearest_node = nearest(tree_b, node_a.position)\n            if edge_in_obstacle(nearest_node.position, node_a.position) or in_obstacle(node_a.position):\n                return None\n            c_cost = nearest_node.cost + dist(nearest_node.position, node_a.position)\n            new_node = Node(node_a.position, parent=nearest_node, cost=c_cost)\n            nearest_node.add_child(new_node)\n            tree_b.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n            return new_node\n\n        # Shortcut the final path by removing unnecessary waypoints with collision checking\n        def shortcut_path(path):\n            if len(path) <= 2:\n                return path\n            shortened = [path[0]]\n            idx = 0\n            while idx < len(path) - 1:\n                next_idx = len(path) -1\n                for j in range(len(path)-1, idx, -1):\n                    if not edge_in_obstacle(path[idx], path[j]):\n                        next_idx = j\n                        break\n                shortened.append(path[next_idx])\n                idx = next_idx\n            return shortened\n\n        import random\n        import math\n\n        for itr in range(self.max_iter):\n            tree_a, tree_b = (start_tree, goal_tree) if itr % 2 == 0 else (goal_tree, start_tree)\n\n            sample = sample_free()\n            new_node_a = extend_with_rewire(tree_a, sample)\n            if new_node_a is None:\n                continue\n\n            new_node_b = try_connect(tree_b, new_node_a)\n            if new_node_b:\n                total_cost = new_node_a.cost + new_node_b.cost\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_connection = (new_node_a, new_node_b)\n\n                # Build full path from start to goal via connecting nodes\n                path_start = new_node_a.path_from_root()\n                path_goal = new_node_b.path_from_root()\n                # Remove duplication of connecting node\n                if path_start[-1] == path_goal[-1]:\n                    full_path = path_start + path_goal[-2::-1]\n                else:\n                    full_path = path_start + path_goal[::-1]\n                # Shortcut path to improve smoothness and length\n                full_path = shortcut_path(full_path)\n                return PlannerResult(\n                    success=True,\n                    path=full_path,\n                    nodes=nodes,\n                    edges=edges\n                )\n\n        # If no connection found after max_iter\n        return PlannerResult(\n            success=False,\n            path=[],\n            nodes=nodes,\n            edges=edges\n        )",
          "objective": -13.10341,
          "time_improvement": -17.0,
          "length_improvement": 15.0,
          "smoothness_improvement": 1770.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.03586246967315674,
                    "num_nodes_avg": 158.2,
                    "path_length_avg": 169.64979962636318,
                    "smoothness_avg": 0.04954703801688554,
                    "success_improvement": 0.0,
                    "time_improvement": -36.60426673496058,
                    "length_improvement": 7.012256551684769,
                    "smoothness_improvement": 675.5187380793998,
                    "objective_score": -3.3963323990803147
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.07881088256835937,
                    "num_nodes_avg": 308.2,
                    "path_length_avg": 237.82271271086537,
                    "smoothness_avg": 0.12127577225727508,
                    "success_improvement": 0.0,
                    "time_improvement": 52.276331034184054,
                    "length_improvement": 20.60793314987834,
                    "smoothness_improvement": 3020.512971587674,
                    "objective_score": 43.150224058120585
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.08306193351745605,
                    "num_nodes_avg": 277.3,
                    "path_length_avg": 122.87997069169981,
                    "smoothness_avg": 0.13485837299586953,
                    "success_improvement": 0.0,
                    "time_improvement": -65.17995994568392,
                    "length_improvement": 18.388974381988994,
                    "smoothness_improvement": 1615.3885502978142,
                    "objective_score": -0.4436606030227068
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "initial",
          "algorithm_description": "This algorithm is a dual-tree variant of Rapidly-exploring Random Tree (RRT) that grows two trees from the start and goal positions, attempting to connect them as they expand. It is efficient for single-query problems due to its bidirectional search and reduced redundant exploration.",
          "planning_mechanism": "The planner alternates between growing the start and goal trees by extending towards randomly sampled points. Each extension step involves checking for collision-free motion and attempting to connect the two trees. The algorithm terminates when a valid path is formed connecting the trees.",
          "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n        nodes = []\n        edges = []\n        success_state = False\n        extracted_path = []\n\n        for iter in range(self.max_iter):\n            rand = self._sample_free(bounds, obstacles, is_3d)\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest = self._nearest(tree_a, rand)\n                new_pos = self._steer(nearest.position, rand, self.step_size)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                    continue\n                new_node = Node(new_pos, parent=nearest, cost=nearest.cost + self._distance(nearest.position, new_pos))\n                nearest.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((nearest, new_node))\n\n                connect_node = self._nearest(tree_b, new_pos)\n                if self._connect_trees(new_node, connect_node, obstacles, is_3d, tree_b, nodes, edges):\n                    success_state = True\n                    extracted_path = self._extract_path(new_node, connect_node)\n                    return PlannerResult(True, extracted_path, start_tree + goal_tree, edges)\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        while True:\n            if is_3d:\n                point = tuple(random.uniform(0, bounds[i]) for i in range(3))\n            else:\n                point = tuple(random.uniform(0, bounds[i]) for i in range(2))\n            if not self._is_in_obstacle(point, obstacles, is_3d):\n                return point\n\n    def _nearest(self, tree, point):\n        return min(tree, key=lambda node: self._distance(node.position, point))\n\n    def _steer(self, from_pos, to_pos, step_size):\n        dist = self._distance(from_pos, to_pos)\n        if dist <= step_size:\n            return to_pos\n        ratio = step_size / dist\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n    def _connect_trees(self, node_a, node_b, obstacles, is_3d, tree, nodes, edges):\n        from_pos = node_a.position\n        to_pos = node_b.position\n        if self._is_edge_in_obstacle(from_pos, to_pos, obstacles, is_3d):\n            return False\n        curr = node_b\n        path = []\n        while True:\n            new_pos = self._steer(curr.position, from_pos, self.step_size)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return False\n            if self._is_edge_in_obstacle(curr.position, new_pos, obstacles, is_3d):\n                return False\n            new_node = Node(new_pos, parent=curr, cost=curr.cost + self._distance(curr.position, new_pos))\n            curr.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((curr, new_node))\n            if self._distance(new_pos, from_pos) < self.step_size:\n                new_node_final = Node(from_pos, parent=new_node, cost=new_node.cost + self._distance(new_pos, from_pos))\n                new_node.add_child(new_node_final)\n                tree.append(new_node_final)\n                nodes.append(new_node_final)\n                edges.append((new_node, new_node_final))\n                return True\n            curr = new_node\n\n    def _extract_path(self, node_a, node_b):\n        path_a = []\n        while node_a:\n            path_a.append(node_a.position)\n            node_a = node_a.parent\n        path_b = []\n        while node_b:\n            path_b.append(node_b.position)\n            node_b = node_b.parent\n        return list(reversed(path_a)) + path_b\n\n    def _distance(self, a, b):\n        return math.dist(a, b)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = self._distance(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n    ",
          "objective": -12.240158084263113,
          "time_improvement": 53.0,
          "length_improvement": -7.0,
          "smoothness_improvement": 73.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.010491394996643066,
                    "num_nodes_avg": 120.3,
                    "path_length_avg": 195.76139846338907,
                    "smoothness_avg": 0.01116198298553718,
                    "success_improvement": 0.0,
                    "time_improvement": 60.037071244538545,
                    "length_improvement": -7.29992453565072,
                    "smoothness_improvement": 74.70927235766275,
                    "objective_score": 14.004713013759444
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.014621138572692871,
                    "num_nodes_avg": 220.6,
                    "path_length_avg": 298.75944281412666,
                    "smoothness_avg": 0.007195610696889318,
                    "success_improvement": 0.0,
                    "time_improvement": 91.14621795357668,
                    "length_improvement": 0.2654986748850134,
                    "smoothness_improvement": 85.14824601985723,
                    "objective_score": 27.928905821103296
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.04569807052612305,
                    "num_nodes_avg": 470.5,
                    "path_length_avg": 171.27857497950592,
                    "smoothness_avg": 0.012625069591645856,
                    "success_improvement": 0.0,
                    "time_improvement": 9.123167021946427,
                    "length_improvement": -13.755074092095834,
                    "smoothness_improvement": 60.58995332003385,
                    "objective_score": -5.2131445820734035
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m1",
          "algorithm_description": "A bidirectional RRT* variant enhanced with adaptive neighborhood search radius, goal-biased intelligent sampling, progressive rewiring within dynamically scaled neighborhoods, and multi-resolution collision checking for efficient expansion and refined path quality. The planner alternates growing trees from start and goal positions, performing selective rewiring to continually optimize path cost and shape. Upon successful connection, a path smoothing step using iterative shortcutting improves path smoothness and length while preserving collision-free guarantees. This approach emphasizes computational efficiency, path optimality, and smoothness in cluttered environments.",
          "planning_mechanism": "The planner initializes two trees at start and goal, then iteratively samples points biased toward the goal line or free space, extends each tree towards samples with adaptive step length, searches a neighborhood with radius scaled by the logarithm of the tree's size for rewiring, and rewires nodes to reduce costs when collision checks pass. The trees alternate expansion until connected, then a shortcut smoothing post-processing step refines the path to improve smoothness and reduce length before returning the successful solution.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=4000, max_step=8.0, min_step=0.8, goal_sample_rate=0.2, gamma_rrt_star=35.0, max_radius=30.0):\n        self.max_iter = max_iter\n        self.max_step = max_step\n        self.min_step = min_step\n        self.goal_sample_rate = goal_sample_rate\n        self.gamma_rrt_star = gamma_rrt_star\n        self.max_radius = max_radius\n\n    def plan(self, map):\n        bounds = map.size\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        tree_start = [Node(start, None, 0.0)]\n        tree_goal = [Node(goal, None, 0.0)]\n        nodes = tree_start + tree_goal\n        edges = []\n\n        for i in range(self.max_iter):\n            tree_a, tree_b = (tree_start, tree_goal) if (i % 2 == 0) else (tree_goal, tree_start)\n\n            sample = (self._informed_sample(bounds, start, goal, obstacles, is_3d)\n                      if self._rand_float() < self.goal_sample_rate else\n                      self._sample_free(bounds, obstacles, is_3d))\n\n            new_node_a = self._extend_and_rewire(tree_a, sample, obstacles, is_3d, nodes, edges, bounds, dim)\n            if new_node_a is None:\n                continue\n\n            new_node_b = self._connect_and_rewire(tree_b, new_node_a, obstacles, is_3d, nodes, edges, bounds, dim)\n            if new_node_b is not None:\n                path_start = new_node_a.path_from_root()\n                path_goal = new_node_b.path_from_root()\n                if path_start[-1] == path_goal[-1]:\n                    raw_path = path_start + path_goal[-2::-1]\n                else:\n                    raw_path = path_start + path_goal[::-1]\n                smooth_path = self._shortcut_path(raw_path, obstacles, is_3d)\n                return PlannerResult(True, smooth_path, nodes, edges)\n\n        return PlannerResult(False, [], nodes, edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        while True:\n            pt = tuple(self._rand_float() * bounds[d] for d in range(len(bounds)))\n            if not self._in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def _informed_sample(self, bounds, start, goal, obstacles, is_3d):\n        dist_sg = self._distance(start, goal)\n        if dist_sg < 1e-8:\n            return start\n        unit_dir = tuple((goal[d] - start[d]) / dist_sg for d in range(len(bounds)))\n        max_extend = max(bounds) * 0.35\n        # Sample on line from start extending beyond goal by 30%\n        sample_dist = self._rand_float() * (dist_sg + max_extend)\n        base_point = tuple(start[d] + unit_dir[d] * sample_dist for d in range(len(bounds)))\n        # Add perpendicular noise orthogonal to unit_dir vector\n        radius_noise = max_extend * 0.15\n        noise = [ (self._rand_float() - 0.5) * 2 * radius_noise for _ in range(len(bounds))]\n        # Adjust noise orthogonal to direction to bias sampling near line segment\n        # For 2D, project noise on perpendicular vector, for 3D random normal perturbations in null space\n        if len(bounds) == 2:\n            px, py = unit_dir\n            # perpendicular vector\n            perp = (-py, px)\n            # reduce noise along direction, keep perpendicular part\n            perp_noise = perp[0]*noise[0] + perp[1]*noise[1]\n            sample_pt = tuple(min(max(0.0, base_point[d] + perp[d]*perp_noise) , bounds[d]) for d in range(2))\n        else:\n            # Simple isotropic noise clipped to bounds\n            sample_pt = tuple(min(max(0.0, base_point[d] + noise[d]), bounds[d]) for d in range(len(bounds)))\n        if not self._in_obstacle(sample_pt, obstacles, is_3d):\n            return sample_pt\n        return self._sample_free(bounds, obstacles, is_3d)\n\n    def _extend_and_rewire(self, tree, sample, obstacles, is_3d, nodes, edges, bounds, dim):\n        nearest = self._nearest(tree, sample)\n        dist_to_sample = self._distance(nearest.position, sample)\n        step = max(self.min_step, min(self.max_step, dist_to_sample))\n        new_pos = self._steer(nearest.position, sample, step)\n        if not self._valid_node_and_edge(nearest.position, new_pos, obstacles, is_3d):\n            return None\n\n        neighbors = self._near_nodes(tree, new_pos, bounds, dim)\n        min_cost = nearest.cost + self._distance(nearest.position, new_pos)\n        best_parent = nearest\n        for nb in neighbors:\n            if self._valid_node_and_edge(nb.position, new_pos, obstacles, is_3d):\n                cost = nb.cost + self._distance(nb.position, new_pos)\n                if cost < min_cost:\n                    min_cost = cost\n                    best_parent = nb\n\n        new_node = Node(new_pos, best_parent, min_cost)\n        best_parent.add_child(new_node)\n        tree.append(new_node)\n        nodes.append(new_node)\n        edges.append((best_parent, new_node))\n\n        for nb in neighbors:\n            if nb is best_parent:\n                continue\n            if self._valid_node_and_edge(new_node.position, nb.position, obstacles, is_3d):\n                updated_cost = new_node.cost + self._distance(new_node.position, nb.position)\n                if updated_cost + 1e-6 < nb.cost:\n                    if nb.parent:\n                        try:\n                            edges.remove((nb.parent, nb))\n                        except ValueError:\n                            pass\n                        if nb in nb.parent.children:\n                            nb.parent.children.remove(nb)\n                    new_node.add_child(nb)\n                    nb.cost = updated_cost\n                    edges.append((new_node, nb))\n\n        return new_node\n\n    def _connect_and_rewire(self, tree, target_node, obstacles, is_3d, nodes, edges, bounds, dim):\n        current = self._nearest(tree, target_node.position)\n        while True:\n            dist_to_target = self._distance(current.position, target_node.position)\n            if dist_to_target <= self.min_step:\n                if self._valid_node_and_edge(current.position, target_node.position, obstacles, is_3d):\n                    final_node = Node(target_node.position, current, current.cost + dist_to_target)\n                    current.add_child(final_node)\n                    tree.append(final_node)\n                    nodes.append(final_node)\n                    edges.append((current, final_node))\n                    return final_node\n                return None\n\n            step = max(self.min_step, min(self.max_step, dist_to_target))\n            new_pos = self._steer(current.position, target_node.position, step)\n            if not self._valid_node_and_edge(current.position, new_pos, obstacles, is_3d):\n                return None\n\n            neighbors = self._near_nodes(tree, new_pos, bounds, dim)\n            min_cost = current.cost + self._distance(current.position, new_pos)\n            best_parent = current\n            for nb in neighbors:\n                if self._valid_node_and_edge(nb.position, new_pos, obstacles, is_3d):\n                    cost = nb.cost + self._distance(nb.position, new_pos)\n                    if cost < min_cost:\n                        min_cost = cost\n                        best_parent = nb\n\n            new_node = Node(new_pos, best_parent, min_cost)\n            best_parent.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            for nb in neighbors:\n                if nb is best_parent:\n                    continue\n                if self._valid_node_and_edge(new_node.position, nb.position, obstacles, is_3d):\n                    updated_cost = new_node.cost + self._distance(new_node.position, nb.position)\n                    if updated_cost + 1e-6 < nb.cost:\n                        if nb.parent:\n                            try:\n                                edges.remove((nb.parent, nb))\n                            except ValueError:\n                                pass\n                            if nb in nb.parent.children:\n                                nb.parent.children.remove(nb)\n                        new_node.add_child(nb)\n                        nb.cost = updated_cost\n                        edges.append((new_node, nb))\n\n            current = new_node\n\n    def _near_nodes(self, tree, position, bounds, dim):\n        n = max(1, len(tree))\n        scale = max(1.0, sum(bounds) / dim)\n        r_theory = self.gamma_rrt_star * ((math.log(n + 1) / (n + 1)) ** (1.0 / dim))\n        radius = max(self.min_step * 1.8, min(self.max_radius, r_theory * 0.6 + scale * 0.03))\n        return [node for node in tree if self._distance(node.position, position) <= radius]\n\n    def _steer(self, from_pos, to_pos, step_size):\n        dist = self._distance(from_pos, to_pos)\n        if dist <= step_size:\n            return to_pos\n        ratio = step_size / dist\n        return tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(len(from_pos)))\n\n    def _valid_node_and_edge(self, from_pos, to_pos, obstacles, is_3d):\n        if self._in_obstacle(to_pos, obstacles, is_3d):\n            return False\n        return not self._edge_in_obstacle(from_pos, to_pos, obstacles, is_3d)\n\n    def _in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x,y,z,w,h,d = obs\n                px,py,pz = pos\n                if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                    return True\n            else:\n                x,y,w,h = obs\n                px,py = pos\n                if x <= px <= x+w and y <= py <= y+h:\n                    return True\n        return False\n\n    def _edge_in_obstacle(self, p1, p2, obstacles, is_3d, resolution=0.5):\n        dist = self._distance(p1, p2)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps+1):\n            interp = tuple(p1[d] + (p2[d]-p1[d]) * i / steps for d in range(len(p1)))\n            if self._in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _distance(self, a,b):\n        s=0.0\n        for i in range(len(a)):\n            s += (a[i]-b[i])**2\n        return s**0.5\n\n    def _nearest(self, tree, point):\n        best = None\n        best_dist = float('inf')\n        for node in tree:\n            dist = self._distance(node.position, point)\n            if dist < best_dist:\n                best_dist = dist\n                best = node\n        return best\n\n    def _rand_float(self):\n        if not hasattr(self, '_rand_state'):\n            self._rand_state = 987654321\n        self._rand_state = (1664525 * self._rand_state + 1013904223) & 0xFFFFFFFF\n        return self._rand_state / 4294967295.0\n\n    def _shortcut_path(self, path, obstacles, is_3d):\n        if len(path) < 3:\n            return path[:]\n        shortened = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            while j > i+1:\n                if not self._edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                    break\n                j -= 1\n            shortened.append(path[j])\n            i = j\n        return shortened",
          "objective": -11.1158,
          "time_improvement": 36.0,
          "length_improvement": 13.0,
          "smoothness_improvement": 1839.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 0.9,
                    "time_avg": 0.03728148937225342,
                    "num_nodes_avg": 87.5,
                    "path_length_avg": 177.5993625994981,
                    "smoothness_avg": 0.061093825863437166,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": -42.00947578063485,
                    "length_improvement": 2.6549751172230844,
                    "smoothness_improvement": 856.2510421290689,
                    "objective_score": -56.72860245321125
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.040665721893310545,
                    "num_nodes_avg": 172.6,
                    "path_length_avg": 240.60704401879048,
                    "smoothness_avg": 0.11503528741526861,
                    "success_improvement": 0.0,
                    "time_improvement": 75.37500676751161,
                    "length_improvement": 19.678443216759863,
                    "smoothness_improvement": 2859.940801763299,
                    "objective_score": 48.7192719691259
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.013425302505493165,
                    "num_nodes_avg": 80.8,
                    "path_length_avg": 124.56156413344789,
                    "smoothness_avg": 0.14941690218783527,
                    "success_improvement": 0.0,
                    "time_improvement": 73.30195871674466,
                    "length_improvement": 17.272140086854744,
                    "smoothness_improvement": 1800.5719670207743,
                    "objective_score": 41.356731502240116
               }
          ],
          "success_rate": 0.9666666666666667
     },
     {
          "operator": "m3",
          "algorithm_description": "A simplified bidirectional RRT* algorithm that grows two trees from start and goal, samples uniformly with bias towards improving the solution, rewires locally to optimize paths, attempts direct connections between trees to find a path, and performs post-processing shortcutting to smooth and shorten the final path. It uses straightforward nearest neighbor search and basic collision checking to ensure valid paths while balancing computational cost and path quality.",
          "planning_mechanism": "The planner alternates growing start and goal trees towards sampled points inside the map bounds or within the informed ellipsoid if a solution exists. New nodes are linked and rewired locally to reduce path cost. It frequently attempts to connect the two trees directly upon proximity. Upon finding a path, it applies shortcutting to improve smoothness. The search halts on first valid path or after max iterations.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\nclass Planner:\n    def __init__(self, max_iter=3000, step_size=7.5, rewire_radius=15.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.rewire_radius = rewire_radius\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        edges = []\n        best_cost = float('inf')\n        best_path = []\n\n        def dist(a, b):\n            return sum((a[i]-b[i])**2 for i in range(dim))**0.5\n\n        def in_collision(p):\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d = obs\n                    if x <= p[0] <= x+w and y <= p[1] <= y+h and z <= p[2] <= z+d:\n                        return True\n                else:\n                    x,y,w,h = obs\n                    if x <= p[0] <= x+w and y <= p[1] <= y+h:\n                        return True\n            return False\n\n        def edge_collision(a, b, resolution=1.0):\n            d = dist(a,b)\n            steps = max(1, int(d/resolution))\n            for i in range(steps+1):\n                pt = tuple(a[j] + (b[j]-a[j]) * i/steps for j in range(dim))\n                if in_collision(pt):\n                    return True\n            return False\n\n        def steer(from_p, to_p, max_step):\n            d = dist(from_p, to_p)\n            if d <= max_step:\n                return to_p\n            ratio = max_step / d\n            return tuple(from_p[i] + (to_p[i]-from_p[i])*ratio for i in range(dim))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: dist(n.position, point))\n\n        def neighbors(tree, point, radius):\n            radius_sq = radius*radius\n            result = []\n            for n in tree:\n                if sum((n.position[i]-point[i])**2 for i in range(dim)) <= radius_sq:\n                    result.append(n)\n            return result\n\n        def extract_path(node_start, node_goal):\n            path_start = []\n            n = node_start\n            while n:\n                path_start.append(n.position)\n                n = n.parent\n            path_start.reverse()\n            path_goal = []\n            n = node_goal\n            while n:\n                path_goal.append(n.position)\n                n = n.parent\n            return path_start + path_goal\n\n        def sample_informed(c_best):\n            if c_best == float('inf'):\n                while True:\n                    p = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                    if not in_collision(p):\n                        return p\n            c_min = dist(start_pos, goal_pos)\n            if c_min == 0.0:\n                return goal_pos\n            center = tuple((start_pos[i]+goal_pos[i])/2 for i in range(dim))\n            a1 = [(goal_pos[i]-start_pos[i])/c_min for i in range(dim)]\n            L1 = c_best/2.0\n            L2 = ((c_best**2 - c_min**2)**0.5)/2.0\n            while True:\n                while True:\n                    sample = [random.uniform(-1,1) for _ in range(dim)]\n                    norm_s = sum(s*s for s in sample)**0.5\n                    if 0 < norm_s <= 1:\n                        break\n                unit_s = [s/norm_s for s in sample]\n                r = random.uniform(0,1)**(1/dim)\n                unit_ball = [r*us for us in unit_s]\n                ellipsoid_sample = [L1*unit_ball[0]] + [L2*unit_ball[i] for i in range(1,dim)]\n                # Rotate ellipsoid sample to align with a1 (only 2D/3D)\n                if dim == 2:\n                    theta = 0\n                    if abs(a1[0]) < 1.0:\n                        theta = math.acos(a1[0])\n                        if a1[1] < 0:\n                            theta = -theta\n                    x = ellipsoid_sample[0]*math.cos(theta) - ellipsoid_sample[1]*math.sin(theta)\n                    y = ellipsoid_sample[0]*math.sin(theta) + ellipsoid_sample[1]*math.cos(theta)\n                    p = (center[0]+x, center[1]+y)\n                elif dim == 3:\n                    # simple rotation aligning x-axis to a1 using Householder reflection\n                    x = a1\n                    I = [[1 if i==j else 0 for j in range(3)] for i in range(3)]\n                    v = [x[0]-1, x[1], x[2]]\n                    norm_v = sum(vi*vi for vi in v)**0.5\n                    if norm_v < 1e-10:\n                        R = I\n                    else:\n                        v = [vi/norm_v for vi in v]\n                        R = [[I[i][j] - 2*v[i]*v[j] for j in range(3)] for i in range(3)]\n                    rotated = tuple(sum(R[i][j]*ellipsoid_sample[j] for j in range(3)) for i in range(3))\n                    p = tuple(center[i] + rotated[i] for i in range(3))\n                else:\n                    p = tuple(center[i] + ellipsoid_sample[i] for i in range(dim))\n                if all(0 <= p[i] <= bounds[i] for i in range(dim)) and not in_collision(p):\n                    return p\n\n        def shortcut_path(path):\n            if len(path)<3:\n                return path\n            i = 0\n            while i < len(path)-2:\n                j = len(path)-1\n                while j > i+1:\n                    if not edge_collision(path[i], path[j]):\n                        path = path[:i+1]+path[j:]\n                        break\n                    j -=1\n                i +=1\n            return path\n\n        def rewire(tree, new_node):\n            nghs = neighbors(tree, new_node.position, self.rewire_radius)\n            for ngh in nghs:\n                if ngh == new_node.parent:\n                    continue\n                if edge_collision(new_node.position, ngh.position):\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, ngh.position)\n                if new_cost + 1e-7 < ngh.cost:\n                    if ngh.parent:\n                        try:\n                            ngh.parent.children.remove(ngh)\n                        except:\n                            pass\n                    ngh.parent = new_node\n                    ngh.cost = new_cost\n                    new_node.add_child(ngh)\n\n        for iteration in range(self.max_iter):\n            sample = sample_informed(best_cost)\n            for (tree_a, tree_b) in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nn = nearest(tree_a, sample)\n                new_pos = steer(nn.position, sample, self.step_size)\n                if in_collision(new_pos) or edge_collision(nn.position, new_pos):\n                    continue\n                new_cost = nn.cost + dist(nn.position, new_pos)\n                new_node = Node(new_pos, parent=nn, cost=new_cost)\n                nn.add_child(new_node)\n                tree_a.append(new_node)\n                edges.append((nn, new_node))\n\n                rewire(tree_a, new_node)\n\n                nearest_other = nearest(tree_b, new_pos)\n                dist_trees = dist(new_pos, nearest_other.position)\n                if dist_trees <= self.step_size*2 and not edge_collision(new_pos, nearest_other.position):\n                    connect_node = Node(nearest_other.position, parent=new_node, cost=new_node.cost + dist_trees)\n                    new_node.add_child(connect_node)\n                    tree_b.append(connect_node)\n                    edges.append((new_node, connect_node))\n\n                    path = extract_path(new_node, nearest_other)\n                    path = shortcut_path(path)\n\n                    cost_path = 0.0\n                    for k in range(len(path)-1):\n                        cost_path += dist(path[k], path[k+1])\n                    if cost_path < best_cost:\n                        best_cost = cost_path\n                        best_path = path\n            if best_path:\n                return PlannerResult(True, best_path, start_tree+goal_tree, edges)\n        return PlannerResult(False, [], start_tree+goal_tree, edges)",
          "objective": -7.96217,
          "time_improvement": -25.0,
          "length_improvement": 11.0,
          "smoothness_improvement": 1799.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.05618610382080078,
                    "num_nodes_avg": 139.8,
                    "path_length_avg": 185.25496856355855,
                    "smoothness_avg": 0.04960682018479354,
                    "success_improvement": 0.0,
                    "time_improvement": -114.01932390840987,
                    "length_improvement": -1.5411838225179815,
                    "smoothness_improvement": 676.4544588262154,
                    "objective_score": -31.748235171902678
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.037730622291564944,
                    "num_nodes_avg": 170.8,
                    "path_length_avg": 236.8253031039858,
                    "smoothness_avg": 0.12587993282534443,
                    "success_improvement": 0.0,
                    "time_improvement": 77.15234661209345,
                    "length_improvement": 20.94089718549847,
                    "smoothness_improvement": 3138.9813392469123,
                    "objective_score": 51.40514899116168
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.06945254802703857,
                    "num_nodes_avg": 205.7,
                    "path_length_avg": 131.1004396537589,
                    "smoothness_avg": 0.13218220013348647,
                    "success_improvement": 0.0,
                    "time_improvement": -38.11584459228801,
                    "length_improvement": 12.929330314056402,
                    "smoothness_improvement": 1581.3478290228345,
                    "objective_score": 4.22958395586161
               }
          ],
          "success_rate": 1.0
     }
]