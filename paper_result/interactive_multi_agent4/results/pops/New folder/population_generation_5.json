[
     {
          "operator": "initial",
          "algorithm_description": "This algorithm grows two trees simultaneously, one from the start position and one from the goal position, and attempts to connect them to find a feasible path. This bidirectional approach accelerates convergence and increases the success rate compared to a single tree RRT.",
          "planning_mechanism": "The planning mechanism involves randomly sampling points within the map bounds, extending each tree towards the sampled points, and attempting to connect the two trees whenever new nodes are added. Collision checks are performed for nodes and edges to ensure safety, and once the two trees connect, the final path is reconstructed by backtracking through the parent nodes of each tree.",
          "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map) -> PlannerResult:\n        import math, random\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position)\n        goal_root = Node(goal_position)\n        nodes.extend([start_root, goal_root])\n        tree_a, tree_b = [start_root], [goal_root]\n\n        for _ in range(self.max_iter):\n            rand_point = self._sample_free(bounds, obstacles, is_3d)\n            new_a = self._extend_tree(tree_a, rand_point, obstacles, is_3d, nodes, edges)\n            if new_a is None:\n                continue\n\n            new_b = self._connect_trees(tree_b, new_a, obstacles, is_3d, nodes, edges)\n            if new_b:\n                success_state = True\n                path_a = new_a.path_from_root()\n                path_b = new_b.path_from_root()\n                extracted_path = path_a + path_b[::-1]\n                break\n\n            tree_a, tree_b = tree_b, tree_a  # Swap trees\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        import random\n        while True:\n            if is_3d:\n                p = (random.uniform(0, bounds[0]),\n                     random.uniform(0, bounds[1]),\n                     random.uniform(0, bounds[2]))\n            else:\n                p = (random.uniform(0, bounds[0]),\n                     random.uniform(0, bounds[1]))\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    def _nearest(self, tree, point):\n        import math\n        return min(tree, key=lambda node: math.dist(node.position, point))\n\n    def _steer(self, from_pos, to_pos):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _extend_tree(self, tree, point, obstacles, is_3d, nodes, edges):\n        nearest_node = self._nearest(tree, point)\n        new_pos = self._steer(nearest_node.position, point)\n        if not self._is_in_obstacle(new_pos, obstacles, is_3d) and not self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n            new_node = Node(new_pos, parent=nearest_node)\n            nearest_node.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n            return new_node\n        return None\n\n    def _connect_trees(self, tree, new_node, obstacles, is_3d, nodes, edges):\n        import math\n        nearest_node = self._nearest(tree, new_node.position)\n        while True:\n            new_pos = self._steer(nearest_node.position, new_node.position)\n            if (not self._is_in_obstacle(new_pos, obstacles, is_3d) and\n                not self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d)):\n                next_node = Node(new_pos, parent=nearest_node)\n                nearest_node.add_child(next_node)\n                tree.append(next_node)\n                nodes.append(next_node)\n                edges.append((nearest_node, next_node))\n\n                if math.dist(next_node.position, new_node.position) <= self.step_size:\n                    if not self._is_edge_in_obstacle(next_node.position, new_node.position, obstacles, is_3d):\n                        final_node = Node(new_node.position, parent=next_node)\n                        next_node.add_child(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((next_node, final_node))\n                        return final_node\n                    else:\n                        return None\n                nearest_node = next_node\n            else:\n                return None\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n",
          "objective": -28.87615591314666,
          "time_improvement": 93.0,
          "length_improvement": 1.0,
          "smoothness_improvement": 69.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.0022002458572387695,
                    "num_nodes_avg": 57.5,
                    "path_length_avg": 171.4810676267031,
                    "smoothness_avg": 0.011144018674089623,
                    "success_improvement": 0.0,
                    "time_improvement": 91.61901077354663,
                    "length_improvement": 6.008509542400028,
                    "smoothness_improvement": 74.42809187338179,
                    "objective_score": 31.462949416870917
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.009090876579284668,
                    "num_nodes_avg": 226.2,
                    "path_length_avg": 305.50514541182173,
                    "smoothness_avg": 0.00636488258654892,
                    "success_improvement": 0.0,
                    "time_improvement": 94.49504979083876,
                    "length_improvement": -1.986411016509145,
                    "smoothness_improvement": 63.77301339152637,
                    "objective_score": 27.475533394303774
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.004314684867858886,
                    "num_nodes_avg": 127.6,
                    "path_length_avg": 150.78647946614691,
                    "smoothness_avg": 0.013383825302451875,
                    "success_improvement": 0.0,
                    "time_improvement": 91.41966188998718,
                    "length_improvement": -0.14519998085115468,
                    "smoothness_improvement": 70.24126995596559,
                    "objective_score": 27.68998492826529
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m2",
          "algorithm_description": "A bidirectional RRT* variant that uses informed sampling within an ellipsoidal region (informed RRT*) to bias samples towards the subset of the state space likely to improve the current solution, combined with rewiring for asymptotic optimality. It incorporates direct connection attempts between trees and post-processing shortcutting for smoother, shorter paths.",
          "planning_mechanism": "The planner grows two trees from start and goal alternately, sampling randomly inside an ellipsoid defined by start, goal, and the current best path cost to focus growth in promising areas. Each new node is connected and rewired locally to improve path cost. The trees attempt direct connection when close, and after finding a solution, the planner shortcut-postprocesses the path to enhance smoothness and reduce length.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\nclass Planner:\n    def __init__(self, max_iter=3000, step_size=7.5, rewire_radius=15.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.rewire_radius = rewire_radius\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        edges = []\n        best_cost = float('inf')\n        best_path = []\n\n        def distance(a,b):\n            return math.dist(a,b)\n\n        def is_in_collision(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d = obs\n                    px,py,pz = pos\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                        return True\n                else:\n                    x,y,w,h = obs\n                    px,py = pos\n                    if x <= px <= x+w and y <= py <= y+h:\n                        return True\n            return False\n\n        def is_edge_collision(from_pos, to_pos, resolution=1.0):\n            dist = distance(from_pos, to_pos)\n            steps = max(1,int(dist / resolution))\n            for i in range(steps+1):\n                interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * i/steps for d in range(len(from_pos)))\n                if is_in_collision(interp):\n                    return True\n            return False\n\n        def steer(from_pos, to_pos, max_step):\n            dist = distance(from_pos, to_pos)\n            if dist <= max_step:\n                return to_pos\n            ratio = max_step / dist\n            return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: distance(node.position, point))\n\n        def neighbors(tree, point, radius):\n            result = []\n            r_sq = radius*radius\n            for node in tree:\n                dx = node.position[0] - point[0]\n                dy = node.position[1] - point[1]\n                dz = node.position[2] - point[2] if is_3d else 0.0\n                dist_sq = dx*dx + dy*dy + dz*dz\n                if dist_sq <= r_sq:\n                    result.append(node)\n            return result\n\n        def extract_path(node_start, node_goal):\n            path_start = []\n            while node_start:\n                path_start.append(node_start.position)\n                node_start = node_start.parent\n            path_start.reverse()\n            path_goal = []\n            while node_goal:\n                path_goal.append(node_goal.position)\n                node_goal = node_goal.parent\n            return path_start + path_goal\n\n        def try_connect(node_from, tree_to):\n            near = nearest(tree_to, node_from.position)\n            if is_edge_collision(node_from.position, near.position):\n                return None\n            # direct connection possible, make new node\n            new_node = Node(near.position, parent=node_from, cost=node_from.cost + distance(node_from.position, near.position))\n            node_from.add_child(new_node)\n            tree_to.append(new_node)\n            edges.append((node_from,new_node))\n            return new_node\n\n        def rewire(tree, new_node):\n            nbs = neighbors(tree, new_node.position, self.rewire_radius)\n            for nb in nbs:\n                if nb == new_node.parent:\n                    continue\n                if is_edge_collision(new_node.position, nb.position):\n                    continue\n                new_cost = new_node.cost + distance(new_node.position, nb.position)\n                if new_cost + 1e-7 < nb.cost:\n                    # Rewire nb's parent link\n                    if nb.parent:\n                        try:\n                            nb.parent.children.remove(nb)\n                        except ValueError:\n                            pass\n                    nb.parent = new_node\n                    nb.cost = new_cost\n                    new_node.add_child(nb)\n\n        def informed_sample(c_best):\n            # Sample uniformly inside ellipsoid defined by start, goal, c_best\n            if c_best == float('inf'):\n                # No solution found yet, uniform sample in bounds\n                while True:\n                    sample = tuple(random.uniform(0, bounds[i]) for i in range(len(bounds)))\n                    if not is_in_collision(sample):\n                        return sample\n            else:\n                c_min = distance(start_pos, goal_pos)\n                if c_min == 0.0:\n                    return goal_pos\n                # Ellipsoid parameters\n                center = tuple((start_pos[i]+goal_pos[i])/2 for i in range(len(bounds)))\n                a1 = [(goal_pos[i]-start_pos[i])/c_min for i in range(len(bounds))]\n                # Build rotation matrix to transform unit ball samples\n                # For 2D or 3D the rotation matrix is based on a1 vector\n                # Using Householder transform for rotation to align x-axis with a1\n                dim = len(bounds)\n                def mat_vec_mult(mat, vec):\n                    return tuple(sum(mat[i][j]*vec[j] for j in range(dim)) for i in range(dim))\n                # Construct orthonormal basis with a1 as first basis vector\n                # For 2D and 3D:\n                if dim == 2:\n                    # rotation angle\n                    theta = math.acos(a1[0])\n                    if a1[1]<0:\n                        theta = -theta\n                    # rotation matrix\n                    R = [[math.cos(theta), -math.sin(theta)],\n                         [math.sin(theta), math.cos(theta)]]\n                elif dim ==3:\n                    # Construct a rotation matrix using Householder reflection\n                    # vector to rotate to x = a1\n                    x = a1\n                    I = [[1 if i==j else 0 for j in range(3)] for i in range(3)]\n                    v = [x[0]-1, x[1], x[2]]\n                    norm_v = math.sqrt(sum(vi*vi for vi in v))\n                    if norm_v < 1e-10:\n                        R = I\n                    else:\n                        v = [vi/norm_v for vi in v]\n                        R = [[I[i][j] - 2*v[i]*v[j] for j in range(3)] for i in range(3)]\n                else:\n                    R = [[1 if i==j else 0 for j in range(dim)] for i in range(dim)]\n\n                # lengths of ellipsoid axes\n                L1 = c_best/2.0\n                L_other = math.sqrt(c_best*c_best - c_min*c_min)/2.0\n\n                while True:\n                    # sample random unit vector in unit ball\n                    while True:\n                        sample = [random.uniform(-1,1) for _ in range(dim)]\n                        norm_sample = math.sqrt(sum(x*x for x in sample))\n                        if 0 < norm_sample <= 1:\n                            break\n                    unit_s = [x/norm_sample for x in sample]\n                    r = random.uniform(0,1)**(1/dim)  # radius for uniform ball sampling\n                    unit_ball_sample = [r*us for us in unit_s]\n\n                    # scale by axes\n                    ellipsoid_sample = [L1*unit_ball_sample[0]] + [L_other*unit_ball_sample[i] for i in range(1,dim)]\n\n                    # rotate and translate\n                    if dim == 2 or dim == 3:\n                        rotated = mat_vec_mult(R, ellipsoid_sample)\n                    else:\n                        rotated = ellipsoid_sample\n                    point = tuple(center[i] + rotated[i] for i in range(dim))\n                    if all(0 <= point[i] <= bounds[i] for i in range(dim)):\n                        if not is_in_collision(point):\n                            return point\n\n        def shortcut_path(path):\n            if len(path)<=2:\n                return path\n            i = 0\n            while i < len(path)-2:\n                j = len(path)-1\n                while j > i+1:\n                    if not is_edge_collision(path[i], path[j]):\n                        # shortcut between i and j\n                        path = path[:i+1] + path[j:]\n                        break\n                    j -=1\n                i +=1\n            return path\n\n        for it in range(self.max_iter):\n            sample = informed_sample(best_cost)\n            for tree_a, tree_b in [(start_tree, goal_tree),(goal_tree, start_tree)]:\n                near = nearest(tree_a, sample)\n                new_pos = steer(near.position, sample, self.step_size)\n                if is_in_collision(new_pos):\n                    continue\n                if is_edge_collision(near.position, new_pos):\n                    continue\n                new_cost = near.cost + distance(near.position, new_pos)\n                new_node = Node(new_pos, parent=near, cost=new_cost)\n                near.add_child(new_node)\n                tree_a.append(new_node)\n                edges.append((near,new_node))\n\n                rewire(tree_a, new_node)\n\n                near_to_new = nearest(tree_b, new_pos)\n                dist_trees = distance(new_pos, near_to_new.position)\n                if dist_trees <= self.step_size*2 and not is_edge_collision(new_pos, near_to_new.position):\n                    connect_node = Node(near_to_new.position, parent=new_node, cost=new_node.cost + dist_trees)\n                    new_node.add_child(connect_node)\n                    tree_b.append(connect_node)\n                    edges.append((new_node, connect_node))\n                    path = extract_path(connect_node, connect_node)\n                    # extract_path from new_node to nearest node in other tree\n                    path = extract_path(new_node, near_to_new)\n                    path = shortcut_path(path)\n                    cost_path = 0.0\n                    for k in range(len(path)-1):\n                        cost_path += distance(path[k], path[k+1])\n                    if cost_path < best_cost:\n                        best_cost = cost_path\n                        best_path = path\n            if best_path:\n                return PlannerResult(True, best_path, start_tree+goal_tree, edges)\n        return PlannerResult(False, [], start_tree+goal_tree, edges)",
          "objective": -24.54042,
          "time_improvement": 22.0,
          "length_improvement": 15.0,
          "smoothness_improvement": 1806.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.019874000549316408,
                    "num_nodes_avg": 86.7,
                    "path_length_avg": 165.53372291805212,
                    "smoothness_avg": 0.05590834490258338,
                    "success_improvement": 0.0,
                    "time_improvement": 24.29764885485091,
                    "length_improvement": 9.26834341891934,
                    "smoothness_improvement": 775.0870046395709,
                    "objective_score": 16.725735731004733
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.017957305908203124,
                    "num_nodes_avg": 144.4,
                    "path_length_avg": 240.5533294992943,
                    "smoothness_avg": 0.12055312154964279,
                    "success_improvement": 0.0,
                    "time_improvement": 89.12601287090475,
                    "length_improvement": 19.696374669454404,
                    "smoothness_improvement": 3001.9186483760295,
                    "objective_score": 53.56522190482421
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.07342400550842285,
                    "num_nodes_avg": 284.9,
                    "path_length_avg": 128.16200978596154,
                    "smoothness_avg": 0.13688525836651863,
                    "success_improvement": 0.0,
                    "time_improvement": -46.01362832932536,
                    "length_improvement": 14.88089551925333,
                    "smoothness_improvement": 1641.1703826033552,
                    "objective_score": 3.3303007257711688
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "A simplified bidirectional RRT* inspired planner that alternates growing trees from start and goal by sampling collision-free points, extends toward samples with fixed step size, and rewires local neighbors to improve path cost dynamically. It attempts connecting the trees at each iteration, returning the combined path upon success. This approach balances planning efficiency, path quality, and smoothness through incremental rewiring and early collision checks.",
          "planning_mechanism": "The planner operates by sampling points within bounds avoiding obstacles, nearest neighbor extension with fixed step, rewiring neighbors within a computed radius to optimize cost, and alternating tree expansion. Once the two trees connect, their paths are concatenated to form the final solution.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=4000, step_size=5.0, gamma_rrt_star=30.0, max_radius=40.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.gamma_rrt_star = gamma_rrt_star\n        self.max_radius = max_radius\n\n    def plan(self, map):\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        for i in range(self.max_iter):\n            tree_a, tree_b = (tree_start, tree_goal) if i % 2 == 0 else (tree_goal, tree_start)\n            sample = self._sample_free(bounds, obstacles, is_3d)\n\n            new_node = self._extend_and_rewire(tree_a, sample, obstacles, is_3d, nodes, edges, bounds)\n            if new_node is None:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            connect_node = self._connect_and_rewire(tree_b, new_node, obstacles, is_3d, nodes, edges, bounds)\n            if connect_node:\n                path_a = new_node.path_from_root()\n                path_b = connect_node.path_from_root()\n                if path_a[-1] == path_b[-1]:\n                    path_b = path_b[:-1]\n                full_path = path_a + path_b[::-1]\n                return PlannerResult(True, full_path, nodes, edges)\n\n            tree_a, tree_b = tree_b, tree_a\n\n        return PlannerResult(False, [], nodes, edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        import random\n        dim = len(bounds)\n        while True:\n            pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            if not self._in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def _nearest(self, tree, point):\n        best = None\n        best_dist = float('inf')\n        for node in tree:\n            dist = self._dist(node.position, point)\n            if dist < best_dist:\n                best_dist = dist\n                best = node\n        return best\n\n    def _steer(self, from_pos, to_pos):\n        dist = self._dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(len(from_pos)))\n\n    def _near_nodes(self, tree, position, bounds):\n        n = max(1, len(tree))\n        d = len(position)\n        scale = max(1.0, sum(bounds) / d)\n        r_theory = self.gamma_rrt_star * ((math.log(n + 1) / (n + 1)) ** (1.0 / d))\n        radius = max(self.step_size * 2, min(self.max_radius, r_theory * 0.5 + scale * 0.02))\n        return [node for node in tree if self._dist(node.position, position) <= radius]\n\n    def _extend_and_rewire(self, tree, sample, obstacles, is_3d, nodes, edges, bounds):\n        nearest = self._nearest(tree, sample)\n        new_pos = self._steer(nearest.position, sample)\n        if self._in_obstacle(new_pos, obstacles, is_3d):\n            return None\n        if self._edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n            return None\n\n        neighbors = self._near_nodes(tree, new_pos, bounds)\n        min_cost = nearest.cost + self._dist(nearest.position, new_pos)\n        best_parent = nearest\n        for nb in neighbors:\n            if not self._edge_in_obstacle(nb.position, new_pos, obstacles, is_3d):\n                cost = nb.cost + self._dist(nb.position, new_pos)\n                if cost < min_cost:\n                    min_cost = cost\n                    best_parent = nb\n\n        new_node = Node(new_pos, cost=min_cost)\n        best_parent.add_child(new_node)\n        new_node.cost = min_cost\n        tree.append(new_node)\n        nodes.append(new_node)\n        edges.append((best_parent, new_node))\n\n        for nb in neighbors:\n            if nb == best_parent:\n                continue\n            if not self._edge_in_obstacle(new_node.position, nb.position, obstacles, is_3d):\n                updated_cost = new_node.cost + self._dist(new_node.position, nb.position)\n                if updated_cost < nb.cost:\n                    if nb.parent:\n                        try:\n                            edges.remove((nb.parent, nb))\n                        except ValueError:\n                            pass\n                        if nb in nb.parent.children:\n                            nb.parent.children.remove(nb)\n                    new_node.add_child(nb)\n                    nb.cost = updated_cost\n                    edges.append((new_node, nb))\n        return new_node\n\n    def _connect_and_rewire(self, tree, target_node, obstacles, is_3d, nodes, edges, bounds):\n        nearest = self._nearest(tree, target_node.position)\n        while True:\n            new_pos = self._steer(nearest.position, target_node.position)\n            if self._in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                return None\n\n            neighbors = self._near_nodes(tree, new_pos, bounds)\n            min_cost = nearest.cost + self._dist(nearest.position, new_pos)\n            best_parent = nearest\n            for nb in neighbors:\n                if not self._edge_in_obstacle(nb.position, new_pos, obstacles, is_3d):\n                    cost = nb.cost + self._dist(nb.position, new_pos)\n                    if cost < min_cost:\n                        min_cost = cost\n                        best_parent = nb\n\n            new_node = Node(new_pos, cost=min_cost)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            for nb in neighbors:\n                if nb == best_parent:\n                    continue\n                if not self._edge_in_obstacle(new_node.position, nb.position, obstacles, is_3d):\n                    updated_cost = new_node.cost + self._dist(new_node.position, nb.position)\n                    if updated_cost < nb.cost:\n                        if nb.parent:\n                            try:\n                                edges.remove((nb.parent, nb))\n                            except ValueError:\n                                pass\n                            if nb in nb.parent.children:\n                                nb.parent.children.remove(nb)\n                        new_node.add_child(nb)\n                        nb.cost = updated_cost\n                        edges.append((new_node, nb))\n\n            if self._dist(new_node.position, target_node.position) <= self.step_size:\n                if (not self._edge_in_obstacle(new_node.position, target_node.position, obstacles, is_3d)\n                   and not self._in_obstacle(target_node.position, obstacles, is_3d)):\n                    final_node = Node(target_node.position, cost=new_node.cost + self._dist(new_node.position, target_node.position))\n                    new_node.add_child(final_node)\n                    tree.append(final_node)\n                    nodes.append(final_node)\n                    edges.append((new_node, final_node))\n                    return final_node\n                else:\n                    return None\n            nearest = new_node\n\n    def _in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _edge_in_obstacle(self, p1, p2, obstacles, is_3d, resolution=1.0):\n        dist = self._dist(p1, p2)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(p1[d] + (p2[d] - p1[d]) * i / steps for d in range(len(p1)))\n            if self._in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _dist(self, a, b):\n        s = 0\n        for i in range(len(a)):\n            s += (a[i] - b[i]) ** 2\n        return s ** 0.5",
          "objective": -23.86958,
          "time_improvement": 56.0,
          "length_improvement": 11.0,
          "smoothness_improvement": 157.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.010033559799194337,
                    "num_nodes_avg": 60.9,
                    "path_length_avg": 164.20093510394682,
                    "smoothness_avg": 0.01583828018408221,
                    "success_improvement": 0.0,
                    "time_improvement": 61.78101810606081,
                    "length_improvement": 9.99886553920486,
                    "smoothness_improvement": 147.90347825679143,
                    "objective_score": 25.273142146625116
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.050237512588500975,
                    "num_nodes_avg": 241.6,
                    "path_length_avg": 264.8016597340139,
                    "smoothness_avg": 0.010300759767330584,
                    "success_improvement": 0.0,
                    "time_improvement": 69.57884060795715,
                    "length_improvement": 11.601584087618049,
                    "smoothness_improvement": 165.04596815078446,
                    "objective_score": 28.659832475711898
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.0325772762298584,
                    "num_nodes_avg": 182.9,
                    "path_length_avg": 134.71639352764254,
                    "smoothness_avg": 0.020352271921149336,
                    "success_improvement": 0.0,
                    "time_improvement": 35.21565228605458,
                    "length_improvement": 10.527785924243197,
                    "smoothness_improvement": 158.87939658857192,
                    "objective_score": 17.67576422330515
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "initial",
          "algorithm_description": "This algorithm enhances the standard BI-RRT by incorporating an optimization step that rewires nearby nodes to minimize cost, resulting in asymptotically optimal paths. It grows two trees\u2014one from the start and one from the goal\u2014and attempts to connect them while optimizing the path cost dynamically.",
          "planning_mechanism": "The planning mechanism includes sampling a random point, extending each tree toward it, rewiring neighbors within a radius to optimize the cost, and attempting to connect the two trees. When a connection is established, the combined path is extracted from both trees. Node validity and edge collision checks are strictly enforced throughout the process.",
          "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost: float = 0.0):\n        self.position = position              # Tuple[float, ...]\n        self.parent: Optional[\"Node\"] = parent\n        self.cost: float = cost\n        self.children: List[\"Node\"] = []\n        self.valid = True\n\n    def add_child(self, child_node: \"Node\"):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n\nclass Planner:\n    def __init__(\n        self,\n        max_iter: int = 5000,\n        step_size: float = 5.0,\n        gamma_rrt_star: float = 50.0,\n        max_radius: float = 60.0,\n    ):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.gamma_rrt_star = gamma_rrt_star\n        self.max_radius = max_radius\n\n    # ======================= Public API =======================\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        start_root = Node(start_position, parent=None, cost=0.0)\n        goal_root  = Node(goal_position,  parent=None, cost=0.0)\n        nodes.extend([start_root, goal_root])\n\n        tree_a: List[Node] = [start_root]\n        tree_b: List[Node] = [goal_root]\n\n        for _ in range(self.max_iter):\n            rand_point = self._sample_free(bounds, obstacles, is_3d)\n\n            new_a = self._extend_and_rewire(tree_a, rand_point, obstacles, is_3d, nodes, edges, bounds)\n            if new_a is None:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            new_b = self._connect_and_rewire(tree_b, new_a, obstacles, is_3d, nodes, edges, bounds)\n            if new_b:\n                success_state = True\n                path_a = new_a.path_from_root()\n                path_b = new_b.path_from_root()\n                if path_a and path_b and path_a[-1] == path_b[-1]:\n                    path_b = path_b[:-1]\n                extracted_path = path_a + path_b[::-1]\n                break\n\n            tree_a, tree_b = tree_b, tree_a\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        while True:\n            p = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    def _nearest(self, tree: List[Node], point):\n        return min(tree, key=lambda node: math.dist(node.position, point))\n\n    def _steer(self, from_pos, to_pos):\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _near_nodes(self, tree: List[Node], position, bounds) -> List[Node]:\n        n = max(1, len(tree))\n        d = len(position)\n        # \uacf5\uac04 \uc2a4\ucf00\uc77c\uc744 \uac04\ub2e8\ud788 bounds\ub85c \ucd94\uc815 (\uc815\ubc00 X, \uc2e4\uc6a9\uc801)\n        scale = max(1.0, sum(bounds) / d)\n        r_theory = self.gamma_rrt_star * ((math.log(n + 1) / (n + 1)) ** (1.0 / d))\n        radius = max(self.step_size * 2.0, min(self.max_radius, r_theory * 0.5 + scale * 0.02))\n        return [node for node in tree if math.dist(node.position, position) <= radius]\n\n    def _choose_parent_and_add(self, tree, new_pos, obstacles, is_3d, nodes, edges, bounds):\n        nearest = self._nearest(tree, new_pos)\n        neighbors = self._near_nodes(tree, new_pos, bounds)\n\n        min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n        best_parent = nearest\n\n        for nb in neighbors:\n            if not self._is_edge_in_obstacle(nb.position, new_pos, obstacles, is_3d):\n                cand = nb.cost + math.dist(nb.position, new_pos)\n                if cand < min_cost:\n                    min_cost = cand\n                    best_parent = nb\n\n        new_node = Node(new_pos, parent=None, cost=min_cost)\n        best_parent.add_child(new_node)\n        tree.append(new_node)\n        nodes.append(new_node)\n        edges.append((best_parent, new_node))\n        return new_node, neighbors\n\n    def _rewire_from(self, pivot: Node, neighbors: List[Node], obstacles, is_3d, edges):\n        for nb in neighbors:\n            if not self._is_edge_in_obstacle(pivot.position, nb.position, obstacles, is_3d):\n                new_cost = pivot.cost + math.dist(pivot.position, nb.position)\n                if new_cost + 1e-12 < nb.cost:  # \uc791\uc740 \uc218\uce58 \ubc84\ud37c\n                    if nb.parent is not None:\n                        try:\n                            edges.remove((nb.parent, nb))\n                        except ValueError:\n                            pass\n                        if nb in nb.parent.children:\n                            nb.parent.children.remove(nb)\n                    pivot.add_child(nb)\n                    nb.cost = new_cost\n                    edges.append((pivot, nb))\n\n    def _extend_and_rewire(self, tree, sample_point, obstacles, is_3d, nodes, edges, bounds):\n        nearest = self._nearest(tree, sample_point)\n        new_pos = self._steer(nearest.position, sample_point)\n\n        if self._is_in_obstacle(new_pos, obstacles, is_3d):\n            return None\n        if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n            return None\n\n        new_node, neighbors = self._choose_parent_and_add(tree, new_pos, obstacles, is_3d, nodes, edges, bounds)\n        self._rewire_from(new_node, neighbors, obstacles, is_3d, edges)\n        return new_node\n\n    def _connect_and_rewire(self, tree, target_node: Node, obstacles, is_3d, nodes, edges, bounds):\n        nearest = self._nearest(tree, target_node.position)\n\n        while True:\n            new_pos = self._steer(nearest.position, target_node.position)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                return None\n\n            connect_node, neighbors = self._choose_parent_and_add(tree, new_pos, obstacles, is_3d, nodes, edges, bounds)\n            self._rewire_from(connect_node, neighbors, obstacles, is_3d, edges)\n\n            if math.dist(connect_node.position, target_node.position) <= self.step_size:\n                if (not self._is_edge_in_obstacle(connect_node.position, target_node.position, obstacles, is_3d) and\n                    not self._is_in_obstacle(target_node.position, obstacles, is_3d)):\n                    final_node = Node(target_node.position, parent=None, cost=connect_node.cost + math.dist(connect_node.position, target_node.position))\n                    connect_node.add_child(final_node)\n                    tree.append(final_node)\n                    nodes.append(final_node)\n                    edges.append((connect_node, final_node))\n                    return final_node\n                else:\n                    return None\n\n            nearest = connect_node\n\n        \n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n        \n        \n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n",
          "objective": -18.596615900992976,
          "time_improvement": 38.0,
          "length_improvement": 11.0,
          "smoothness_improvement": 172.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.0230562686920166,
                    "num_nodes_avg": 97.6,
                    "path_length_avg": 161.12249215478707,
                    "smoothness_avg": 0.018062462568387585,
                    "success_improvement": 0.0,
                    "time_improvement": 12.176023931931311,
                    "length_improvement": 11.686208900689492,
                    "smoothness_improvement": 182.71676246052309,
                    "objective_score": 11.578116332295703
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.035856032371521,
                    "num_nodes_avg": 250.1,
                    "path_length_avg": 265.1599124520743,
                    "smoothness_avg": 0.010159869700973916,
                    "success_improvement": 0.0,
                    "time_improvement": 78.28749833068048,
                    "length_improvement": 11.481989018596753,
                    "smoothness_improvement": 161.42076526441443,
                    "objective_score": 31.182546736684266
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.038674354553222656,
                    "num_nodes_avg": 237.3,
                    "path_length_avg": 137.40430639955787,
                    "smoothness_avg": 0.021326989594760596,
                    "success_improvement": 0.0,
                    "time_improvement": 23.090782197070272,
                    "length_improvement": 8.742602179373693,
                    "smoothness_improvement": 171.27773345073243,
                    "objective_score": 13.02918463399896
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "A simplified bidirectional RRT planner that balances efficient path finding and computational efficiency by alternating tree expansion from start and goal positions, using straightforward extension steps and rigorous collision checks without costly rewiring or informed sampling. The algorithm prioritizes easy implementation and reliable success at the cost of advanced path cost optimization or smoothing.",
          "planning_mechanism": "class 'Node'",
          "code": "class Node:\n    def __init__(self, position, parent=None):\n        self.position = position\n        self.parent = parent\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map):\n        bounds = map.size\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start)]\n        goal_tree = [Node(goal)]\n\n        nodes = start_tree + goal_tree\n        edges = []\n\n        for i in range(self.max_iter):\n            tree_a, tree_b = (start_tree, goal_tree) if i % 2 == 0 else (goal_tree, start_tree)\n\n            rand_point = self._sample_free(bounds, obstacles, is_3d)\n            new_node_a = self._extend(tree_a, rand_point, obstacles, is_3d, nodes, edges)\n            if new_node_a is None:\n                continue\n\n            new_node_b = self._connect(tree_b, new_node_a, obstacles, is_3d, nodes, edges)\n            if new_node_b is not None:\n                path_start = new_node_a.path_from_root()\n                path_goal = new_node_b.path_from_root()\n                # Avoid duplicating connecting node\n                if path_start[-1] == path_goal[-1]:\n                    full_path = path_start + path_goal[-2::-1]\n                else:\n                    full_path = path_start + path_goal[::-1]\n                return PlannerResult(\n                    success=True,\n                    path=full_path,\n                    nodes=nodes,\n                    edges=edges\n                )\n\n        return PlannerResult(\n            success=False,\n            path=[],\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        while True:\n            if is_3d:\n                p = tuple(random.uniform(0, bounds[d]) for d in range(3))\n            else:\n                p = tuple(random.uniform(0, bounds[d]) for d in range(2))\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    def _nearest(self, tree, point):\n        return min(tree, key=lambda node: self._distance(node.position, point))\n\n    def _steer(self, from_pos, to_pos):\n        dist = self._distance(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(len(from_pos)))\n\n    def _extend(self, tree, point, obstacles, is_3d, nodes, edges):\n        nearest = self._nearest(tree, point)\n        new_pos = self._steer(nearest.position, point)\n        if (self._within_bounds(new_pos, edges, nodes) and\n            not self._is_in_obstacle(new_pos, obstacles, is_3d) and\n            not self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d)):\n            new_node = Node(new_pos)\n            nearest.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest, new_node))\n            return new_node\n        return None\n\n    def _connect(self, tree, target_node, obstacles, is_3d, nodes, edges):\n        current = self._nearest(tree, target_node.position)\n        while True:\n            new_pos = self._steer(current.position, target_node.position)\n            if not self._within_bounds(new_pos, edges, nodes):\n                return None\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(current.position, new_pos, obstacles, is_3d):\n                return None\n            new_node = Node(new_pos)\n            current.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((current, new_node))\n            if self._distance(new_node.position, target_node.position) <= self.step_size:\n                if not self._is_edge_in_obstacle(new_node.position, target_node.position, obstacles, is_3d):\n                    final_node = Node(target_node.position)\n                    new_node.add_child(final_node)\n                    tree.append(final_node)\n                    nodes.append(final_node)\n                    edges.append((new_node, final_node))\n                    return final_node\n                else:\n                    return None\n            current = new_node\n\n    def _within_bounds(self, pos, edges, nodes):\n        dims = len(pos)\n        if hasattr(edges, '__len__') and nodes:\n            # edges and nodes arguments don't provide bounds, re-checking not needed\n            # Instead, handle bounds from map.size (caller)\n            # Simplify to true since map bounds are enforced in sampling and steering\n            return True\n        # fallback check (shouldn't occur)\n        return all(0.0 <= pos[d] <= 10000.0 for d in range(dims))  # large bound\n\n    def _distance(self, a, b):\n        return math.sqrt(sum((a[d]-b[d])**2 for d in range(len(a))))\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, p1, p2, obstacles, is_3d, resolution=1.0):\n        dist = self._distance(p1, p2)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(p1[d] + (p2[d] - p1[d]) * i / steps for d in range(len(p1)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -15.67822,
          "time_improvement": 51.0,
          "length_improvement": 0.0,
          "smoothness_improvement": 68.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.007469820976257324,
                    "num_nodes_avg": 73.1,
                    "path_length_avg": 176.0623468550158,
                    "smoothness_avg": 0.0107998836069439,
                    "success_improvement": 0.0,
                    "time_improvement": 71.54659379560685,
                    "length_improvement": 3.4974378023468984,
                    "smoothness_improvement": 69.04163077129193,
                    "objective_score": 23.907648973946657
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.03709430694580078,
                    "num_nodes_avg": 234.9,
                    "path_length_avg": 302.79595763742356,
                    "smoothness_avg": 0.006446290084951689,
                    "success_improvement": 0.0,
                    "time_improvement": 77.53766526263358,
                    "length_improvement": -1.0820061577686475,
                    "smoothness_improvement": 65.86768696088066,
                    "objective_score": 22.941434318933286
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.04822392463684082,
                    "num_nodes_avg": 247.1,
                    "path_length_avg": 154.05757544889508,
                    "smoothness_avg": 0.013304546360919387,
                    "success_improvement": 0.0,
                    "time_improvement": 4.100162341356848,
                    "length_improvement": -2.3177061797402922,
                    "smoothness_improvement": 69.23284767143511,
                    "objective_score": 0.1855892329200547
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "initial",
          "algorithm_description": "This algorithm is a bidirectional extension of RRT* that grows two trees from start and goal while optimizing paths via rewiring. It combines RRT*\u2018s asymptotic optimality with RRT-Connect\u2019s fast convergence through connection attempts between the trees.",
          "planning_mechanism": "The planner alternates growing two trees with sampling, extension, and rewiring. After each extension, it attempts to connect both trees. When connection is successful, a rewired optimal path is extracted across both trees.",
          "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, radius: float = 10.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.radius = radius\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n        nodes = []\n        edges = []\n        success_state = False\n        extracted_path = []\n\n        for iter in range(self.max_iter):\n            rand = self._sample_free(bounds, obstacles, is_3d)\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest = self._nearest(tree_a, rand)\n                new_pos = self._steer(nearest.position, rand, self.step_size)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                    continue\n\n                new_node = Node(new_pos)\n                near_nodes = self._near(tree_a, new_pos, self.radius)\n                min_cost = nearest.cost + self._distance(nearest.position, new_pos)\n                min_parent = nearest\n\n                for near in near_nodes:\n                    cost = near.cost + self._distance(near.position, new_pos)\n                    if cost < min_cost and not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d):\n                        min_cost = cost\n                        min_parent = near\n\n                new_node.parent = min_parent\n                new_node.cost = min_cost\n                min_parent.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((min_parent, new_node))\n\n                for near in near_nodes:\n                    if near == min_parent:\n                        continue\n                    new_cost = new_node.cost + self._distance(new_node.position, near.position)\n                    if new_cost < near.cost and not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                        if near.parent:\n                            edges.remove((near.parent, near))\n                        near.parent = new_node\n                        near.cost = new_cost\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n\n                connect_node = self._nearest(tree_b, new_node.position)\n                if self._distance(new_node.position, connect_node.position) < self.step_size and not self._is_edge_in_obstacle(new_node.position, connect_node.position, obstacles, is_3d):\n                    success_state = True\n                    extracted_path = self._extract_path(new_node, connect_node)\n                    return PlannerResult(True, extracted_path, start_tree + goal_tree, edges)\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        while True:\n            point = tuple(random.uniform(0, bounds[i]) for i in range(3 if is_3d else 2))\n            if not self._is_in_obstacle(point, obstacles, is_3d):\n                return point\n\n    def _nearest(self, tree, point):\n        return min(tree, key=lambda node: self._distance(node.position, point))\n\n    def _near(self, tree, point, radius):\n        return [node for node in tree if self._distance(node.position, point) <= radius]\n\n    def _steer(self, from_pos, to_pos, step_size):\n        dist = self._distance(from_pos, to_pos)\n        if dist <= step_size:\n            return to_pos\n        ratio = step_size / dist\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n    def _extract_path(self, node_a, node_b):\n        path_a = []\n        while node_a:\n            path_a.append(node_a.position)\n            node_a = node_a.parent\n        path_b = []\n        while node_b:\n            path_b.append(node_b.position)\n            node_b = node_b.parent\n        return list(reversed(path_a)) + path_b\n\n    def _distance(self, a, b):\n        return math.dist(a, b)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = self._distance(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n    ",
          "objective": -14.623200909903078,
          "time_improvement": 26.0,
          "length_improvement": 10.0,
          "smoothness_improvement": 172.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.01557013988494873,
                    "num_nodes_avg": 154.3,
                    "path_length_avg": 176.4019709606193,
                    "smoothness_avg": 0.016468810147838416,
                    "success_improvement": 0.0,
                    "time_improvement": 40.69154853726605,
                    "length_improvement": 3.3112844483772665,
                    "smoothness_improvement": 157.7726414073074,
                    "objective_score": 14.983098437242711
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.019739508628845215,
                    "num_nodes_avg": 283.4,
                    "path_length_avg": 260.814162084563,
                    "smoothness_avg": 0.010965222085418455,
                    "success_improvement": 0.0,
                    "time_improvement": 88.04680591498561,
                    "length_improvement": 12.9327255767608,
                    "smoothness_improvement": 182.14306218804825,
                    "objective_score": 35.084392431492404
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.07533800601959229,
                    "num_nodes_avg": 439.2,
                    "path_length_avg": 130.82946919354052,
                    "smoothness_avg": 0.021737514839812764,
                    "success_improvement": 0.0,
                    "time_improvement": -49.81987885086595,
                    "length_improvement": 13.109295991506725,
                    "smoothness_improvement": 176.49958426597442,
                    "objective_score": -6.197888139025877
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e2",
          "algorithm_description": "A hybrid bidirectional RRT* variant integrating goal bias sampling, informed rewiring, and adaptive step size to efficiently find shorter, smoother, and feasible paths in 2D/3D spaces. It uses informed sampling to speed convergence, rigorous collision checking ensuring safe expansions, incremental rewiring to optimize path cost, and path shortcutting to smooth the final output.",
          "planning_mechanism": "A bidirectional tree grows from start and goal, alternately sampling with goal bias and within an ellipsoidal informed set once a solution is found. New nodes are extended from nearest tree nodes with adaptive step size considering proximity. After adding a new node, rewiring is performed to update neighbor connections minimizing cost to come. The two trees attempt connection after each extension. Upon successful connection, the combined path is shortcut and returned.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def path_from_root(self):\n        path, node = [], self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=4.0, goal_sample_rate=0.1, neighbor_radius=10.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate  # Probability of sampling goal\n        self.neighbor_radius = neighbor_radius    # Radius to search for rewiring neighbors\n\n    def plan(self, map):\n        bounds = map.size\n        start, goal = map.start, map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        start_tree = [Node(start, cost=0.0)]\n        goal_tree = [Node(goal, cost=0.0)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        best_cost = float('inf')\n        best_connection = None\n\n        def dist(a, b):\n            return sum((a[d]-b[d])**2 for d in range(dim))**0.5\n\n        def line_cost(a, b):\n            return dist(a, b)\n\n        # Utility for collision checking a single point\n        def in_obstacle(p):\n            if is_3d:\n                x, y, z = p\n                for ox, oy, oz, w, h, d in obstacles:\n                    if ox <= x <= ox + w and oy <= y <= oy + h and oz <= z <= oz + d:\n                        return True\n            else:\n                x, y = p\n                for ox, oy, w, h in obstacles:\n                    if ox <= x <= ox + w and oy <= y <= oy + h:\n                        return True\n            return False\n\n        # Checks collision for edge p1->p2 by interpolation with resolution = 1.0 units\n        def edge_in_obstacle(p1, p2):\n            dist_p = dist(p1, p2)\n            steps = max(1, int(dist_p / 1.0))\n            for i in range(steps + 1):\n                interp = tuple(p1[d] + (p2[d]-p1[d])*i/steps for d in range(dim))\n                if in_obstacle(interp):\n                    return True\n            return False\n\n        # Sample free point with goal bias and informed ellipsoid sampling if solution found\n        def sample_free():\n            if best_connection and random.random() > self.goal_sample_rate:\n                # Informed ellipsoid sampling within informed subset (prolate hyperspheroid)\n                c_min = dist(start, goal)\n                c_best = best_cost\n                if c_best < float('inf') and c_best > c_min:\n                    center = [(s+g)*0.5 for s,g in zip(start, goal)]\n                    a1 = [(g - s)/c_min for s,g in zip(start, goal)]\n                    # Sample unit ball in dim-dim space and transform\n                    while True:\n                        x_ball = [random.gauss(0,1) for _ in range(dim)]\n                        norm = (sum(x**2 for x in x_ball))**0.5\n                        if norm <= 1:\n                            unit = [x / norm for x in x_ball]\n                            r1 = c_best / 2.0\n                            r2 = (c_best**2 - c_min**2)**0.5 / 2.0 if c_best**2 - c_min**2 > 0 else 0.0\n                            # Construct scaled unit vector in bounding box of ellipsoid\n                            if dim == 2:\n                                # Rotation matrix from a1 to x axis\n                                angle = math.atan2(a1[1], a1[0])\n                                cos_ang = math.cos(angle)\n                                sin_ang = math.sin(angle)\n                                # Scale unit ball coordinates\n                                x_ell = r1 * unit[0]\n                                y_ell = r2 * unit[1]\n                                # Rotate back to world frame and translate\n                                px = center[0] + cos_ang * x_ell - sin_ang * y_ell\n                                py = center[1] + sin_ang * x_ell + cos_ang * y_ell\n                                pt = (px, py)\n                            else:\n                                # 3D case: align a1 with x axis by rotation matrix (approximate)\n                                # To simplify, sample box around center limited by bounds\n                                pt_candidate = [center[d] + r1*unit[0] if d == 0 else center[d] + r2*unit[d] for d in range(dim)]\n                                pt = tuple(max(0,min(pt_candidate[d], bounds[d])) for d in range(dim))\n                            if (all(0 <= pt[d] <= bounds[d] for d in range(dim)) and not in_obstacle(pt)):\n                                return pt\n                else:\n                    # If no valid c_best, fall back to uniform\n                    return uniform_sample()\n            # else regular or goal biased sample\n            if random.random() < self.goal_sample_rate:\n                return goal\n            else:\n                return uniform_sample()\n\n        def uniform_sample():\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not in_obstacle(pt):\n                    return pt\n\n        # Find the nearest node in a tree by Euclidean distance\n        def nearest(tree, point):\n            best = None\n            best_dist = float('inf')\n            for node in tree:\n                d = dist(node.position, point)\n                if d < best_dist:\n                    best = node\n                    best_dist = d\n            return best\n\n        # Steer from from_pos towards to_pos by step size or closer\n        def steer(from_pos, to_pos, max_step):\n            d = dist(from_pos, to_pos)\n            if d <= max_step:\n                return to_pos\n            ratio = max_step / d\n            return tuple(from_pos[d_] + ratio * (to_pos[d_] - from_pos[d_]) for d_ in range(dim))\n\n        # Find neighbors within radius for rewiring\n        def near(tree, node, radius):\n            ret = []\n            for n in tree:\n                if dist(n.position, node.position) <= radius:\n                    ret.append(n)\n            return ret\n\n        # Attempt to add new node to tree with rewiring for cost improvement\n        def extend_with_rewire(tree, point):\n            nearest_node = nearest(tree, point)\n            new_pos = steer(nearest_node.position, point, self.step_size)\n            if in_obstacle(new_pos) or edge_in_obstacle(nearest_node.position, new_pos):\n                return None\n            new_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            new_node = Node(new_pos, parent=nearest_node, cost=new_cost)\n            nearest_node.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n\n            # Rewire neighbors if cheaper to reach via new_node\n            neighbors = near(tree, new_node, self.neighbor_radius)\n            for neighbor in neighbors:\n                if neighbor == new_node.parent:\n                    continue\n                cost_to_neighbor = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_to_neighbor < neighbor.cost:\n                    # Check if edge is collision free before rewiring\n                    if not edge_in_obstacle(new_node.position, neighbor.position):\n                        # Rewire\n                        if neighbor.parent:\n                            neighbor.parent.remove_child(neighbor)\n                        neighbor.parent = new_node\n                        new_node.children.append(neighbor)\n                        # Update costs downstream by DFS\n                        def update_costs(n):\n                            for c in n.children:\n                                old_cost = c.cost\n                                c.cost = n.cost + dist(n.position, c.position)\n                                if c.cost < old_cost:\n                                    update_costs(c)\n                        neighbor.cost = cost_to_neighbor\n                        update_costs(neighbor)\n\n            return new_node\n\n        # Try to connect tree_b to node from tree_a by single edge\n        def try_connect(tree_b, node_a):\n            nearest_node = nearest(tree_b, node_a.position)\n            if edge_in_obstacle(nearest_node.position, node_a.position) or in_obstacle(node_a.position):\n                return None\n            c_cost = nearest_node.cost + dist(nearest_node.position, node_a.position)\n            new_node = Node(node_a.position, parent=nearest_node, cost=c_cost)\n            nearest_node.add_child(new_node)\n            tree_b.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n            return new_node\n\n        # Shortcut the final path by removing unnecessary waypoints with collision checking\n        def shortcut_path(path):\n            if len(path) <= 2:\n                return path\n            shortened = [path[0]]\n            idx = 0\n            while idx < len(path) - 1:\n                next_idx = len(path) -1\n                for j in range(len(path)-1, idx, -1):\n                    if not edge_in_obstacle(path[idx], path[j]):\n                        next_idx = j\n                        break\n                shortened.append(path[next_idx])\n                idx = next_idx\n            return shortened\n\n        import random\n        import math\n\n        for itr in range(self.max_iter):\n            tree_a, tree_b = (start_tree, goal_tree) if itr % 2 == 0 else (goal_tree, start_tree)\n\n            sample = sample_free()\n            new_node_a = extend_with_rewire(tree_a, sample)\n            if new_node_a is None:\n                continue\n\n            new_node_b = try_connect(tree_b, new_node_a)\n            if new_node_b:\n                total_cost = new_node_a.cost + new_node_b.cost\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_connection = (new_node_a, new_node_b)\n\n                # Build full path from start to goal via connecting nodes\n                path_start = new_node_a.path_from_root()\n                path_goal = new_node_b.path_from_root()\n                # Remove duplication of connecting node\n                if path_start[-1] == path_goal[-1]:\n                    full_path = path_start + path_goal[-2::-1]\n                else:\n                    full_path = path_start + path_goal[::-1]\n                # Shortcut path to improve smoothness and length\n                full_path = shortcut_path(full_path)\n                return PlannerResult(\n                    success=True,\n                    path=full_path,\n                    nodes=nodes,\n                    edges=edges\n                )\n\n        # If no connection found after max_iter\n        return PlannerResult(\n            success=False,\n            path=[],\n            nodes=nodes,\n            edges=edges\n        )",
          "objective": -13.10341,
          "time_improvement": -17.0,
          "length_improvement": 15.0,
          "smoothness_improvement": 1770.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.03586246967315674,
                    "num_nodes_avg": 158.2,
                    "path_length_avg": 169.64979962636318,
                    "smoothness_avg": 0.04954703801688554,
                    "success_improvement": 0.0,
                    "time_improvement": -36.60426673496058,
                    "length_improvement": 7.012256551684769,
                    "smoothness_improvement": 675.5187380793998,
                    "objective_score": -3.3963323990803147
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.07881088256835937,
                    "num_nodes_avg": 308.2,
                    "path_length_avg": 237.82271271086537,
                    "smoothness_avg": 0.12127577225727508,
                    "success_improvement": 0.0,
                    "time_improvement": 52.276331034184054,
                    "length_improvement": 20.60793314987834,
                    "smoothness_improvement": 3020.512971587674,
                    "objective_score": 43.150224058120585
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.08306193351745605,
                    "num_nodes_avg": 277.3,
                    "path_length_avg": 122.87997069169981,
                    "smoothness_avg": 0.13485837299586953,
                    "success_improvement": 0.0,
                    "time_improvement": -65.17995994568392,
                    "length_improvement": 18.388974381988994,
                    "smoothness_improvement": 1615.3885502978142,
                    "objective_score": -0.4436606030227068
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "initial",
          "algorithm_description": "This algorithm is a dual-tree variant of Rapidly-exploring Random Tree (RRT) that grows two trees from the start and goal positions, attempting to connect them as they expand. It is efficient for single-query problems due to its bidirectional search and reduced redundant exploration.",
          "planning_mechanism": "The planner alternates between growing the start and goal trees by extending towards randomly sampled points. Each extension step involves checking for collision-free motion and attempting to connect the two trees. The algorithm terminates when a valid path is formed connecting the trees.",
          "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n        nodes = []\n        edges = []\n        success_state = False\n        extracted_path = []\n\n        for iter in range(self.max_iter):\n            rand = self._sample_free(bounds, obstacles, is_3d)\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest = self._nearest(tree_a, rand)\n                new_pos = self._steer(nearest.position, rand, self.step_size)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                    continue\n                new_node = Node(new_pos, parent=nearest, cost=nearest.cost + self._distance(nearest.position, new_pos))\n                nearest.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((nearest, new_node))\n\n                connect_node = self._nearest(tree_b, new_pos)\n                if self._connect_trees(new_node, connect_node, obstacles, is_3d, tree_b, nodes, edges):\n                    success_state = True\n                    extracted_path = self._extract_path(new_node, connect_node)\n                    return PlannerResult(True, extracted_path, start_tree + goal_tree, edges)\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        while True:\n            if is_3d:\n                point = tuple(random.uniform(0, bounds[i]) for i in range(3))\n            else:\n                point = tuple(random.uniform(0, bounds[i]) for i in range(2))\n            if not self._is_in_obstacle(point, obstacles, is_3d):\n                return point\n\n    def _nearest(self, tree, point):\n        return min(tree, key=lambda node: self._distance(node.position, point))\n\n    def _steer(self, from_pos, to_pos, step_size):\n        dist = self._distance(from_pos, to_pos)\n        if dist <= step_size:\n            return to_pos\n        ratio = step_size / dist\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n    def _connect_trees(self, node_a, node_b, obstacles, is_3d, tree, nodes, edges):\n        from_pos = node_a.position\n        to_pos = node_b.position\n        if self._is_edge_in_obstacle(from_pos, to_pos, obstacles, is_3d):\n            return False\n        curr = node_b\n        path = []\n        while True:\n            new_pos = self._steer(curr.position, from_pos, self.step_size)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return False\n            if self._is_edge_in_obstacle(curr.position, new_pos, obstacles, is_3d):\n                return False\n            new_node = Node(new_pos, parent=curr, cost=curr.cost + self._distance(curr.position, new_pos))\n            curr.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((curr, new_node))\n            if self._distance(new_pos, from_pos) < self.step_size:\n                new_node_final = Node(from_pos, parent=new_node, cost=new_node.cost + self._distance(new_pos, from_pos))\n                new_node.add_child(new_node_final)\n                tree.append(new_node_final)\n                nodes.append(new_node_final)\n                edges.append((new_node, new_node_final))\n                return True\n            curr = new_node\n\n    def _extract_path(self, node_a, node_b):\n        path_a = []\n        while node_a:\n            path_a.append(node_a.position)\n            node_a = node_a.parent\n        path_b = []\n        while node_b:\n            path_b.append(node_b.position)\n            node_b = node_b.parent\n        return list(reversed(path_a)) + path_b\n\n    def _distance(self, a, b):\n        return math.dist(a, b)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = self._distance(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n    ",
          "objective": -12.240158084263113,
          "time_improvement": 53.0,
          "length_improvement": -7.0,
          "smoothness_improvement": 73.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.010491394996643066,
                    "num_nodes_avg": 120.3,
                    "path_length_avg": 195.76139846338907,
                    "smoothness_avg": 0.01116198298553718,
                    "success_improvement": 0.0,
                    "time_improvement": 60.037071244538545,
                    "length_improvement": -7.29992453565072,
                    "smoothness_improvement": 74.70927235766275,
                    "objective_score": 14.004713013759444
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.014621138572692871,
                    "num_nodes_avg": 220.6,
                    "path_length_avg": 298.75944281412666,
                    "smoothness_avg": 0.007195610696889318,
                    "success_improvement": 0.0,
                    "time_improvement": 91.14621795357668,
                    "length_improvement": 0.2654986748850134,
                    "smoothness_improvement": 85.14824601985723,
                    "objective_score": 27.928905821103296
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.04569807052612305,
                    "num_nodes_avg": 470.5,
                    "path_length_avg": 171.27857497950592,
                    "smoothness_avg": 0.012625069591645856,
                    "success_improvement": 0.0,
                    "time_improvement": 9.123167021946427,
                    "length_improvement": -13.755074092095834,
                    "smoothness_improvement": 60.58995332003385,
                    "objective_score": -5.2131445820734035
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m1",
          "algorithm_description": "A bidirectional RRT* variant enhanced with adaptive neighborhood search radius, goal-biased intelligent sampling, progressive rewiring within dynamically scaled neighborhoods, and multi-resolution collision checking for efficient expansion and refined path quality. The planner alternates growing trees from start and goal positions, performing selective rewiring to continually optimize path cost and shape. Upon successful connection, a path smoothing step using iterative shortcutting improves path smoothness and length while preserving collision-free guarantees. This approach emphasizes computational efficiency, path optimality, and smoothness in cluttered environments.",
          "planning_mechanism": "The planner initializes two trees at start and goal, then iteratively samples points biased toward the goal line or free space, extends each tree towards samples with adaptive step length, searches a neighborhood with radius scaled by the logarithm of the tree's size for rewiring, and rewires nodes to reduce costs when collision checks pass. The trees alternate expansion until connected, then a shortcut smoothing post-processing step refines the path to improve smoothness and reduce length before returning the successful solution.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=4000, max_step=8.0, min_step=0.8, goal_sample_rate=0.2, gamma_rrt_star=35.0, max_radius=30.0):\n        self.max_iter = max_iter\n        self.max_step = max_step\n        self.min_step = min_step\n        self.goal_sample_rate = goal_sample_rate\n        self.gamma_rrt_star = gamma_rrt_star\n        self.max_radius = max_radius\n\n    def plan(self, map):\n        bounds = map.size\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        tree_start = [Node(start, None, 0.0)]\n        tree_goal = [Node(goal, None, 0.0)]\n        nodes = tree_start + tree_goal\n        edges = []\n\n        for i in range(self.max_iter):\n            tree_a, tree_b = (tree_start, tree_goal) if (i % 2 == 0) else (tree_goal, tree_start)\n\n            sample = (self._informed_sample(bounds, start, goal, obstacles, is_3d)\n                      if self._rand_float() < self.goal_sample_rate else\n                      self._sample_free(bounds, obstacles, is_3d))\n\n            new_node_a = self._extend_and_rewire(tree_a, sample, obstacles, is_3d, nodes, edges, bounds, dim)\n            if new_node_a is None:\n                continue\n\n            new_node_b = self._connect_and_rewire(tree_b, new_node_a, obstacles, is_3d, nodes, edges, bounds, dim)\n            if new_node_b is not None:\n                path_start = new_node_a.path_from_root()\n                path_goal = new_node_b.path_from_root()\n                if path_start[-1] == path_goal[-1]:\n                    raw_path = path_start + path_goal[-2::-1]\n                else:\n                    raw_path = path_start + path_goal[::-1]\n                smooth_path = self._shortcut_path(raw_path, obstacles, is_3d)\n                return PlannerResult(True, smooth_path, nodes, edges)\n\n        return PlannerResult(False, [], nodes, edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        while True:\n            pt = tuple(self._rand_float() * bounds[d] for d in range(len(bounds)))\n            if not self._in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def _informed_sample(self, bounds, start, goal, obstacles, is_3d):\n        dist_sg = self._distance(start, goal)\n        if dist_sg < 1e-8:\n            return start\n        unit_dir = tuple((goal[d] - start[d]) / dist_sg for d in range(len(bounds)))\n        max_extend = max(bounds) * 0.35\n        # Sample on line from start extending beyond goal by 30%\n        sample_dist = self._rand_float() * (dist_sg + max_extend)\n        base_point = tuple(start[d] + unit_dir[d] * sample_dist for d in range(len(bounds)))\n        # Add perpendicular noise orthogonal to unit_dir vector\n        radius_noise = max_extend * 0.15\n        noise = [ (self._rand_float() - 0.5) * 2 * radius_noise for _ in range(len(bounds))]\n        # Adjust noise orthogonal to direction to bias sampling near line segment\n        # For 2D, project noise on perpendicular vector, for 3D random normal perturbations in null space\n        if len(bounds) == 2:\n            px, py = unit_dir\n            # perpendicular vector\n            perp = (-py, px)\n            # reduce noise along direction, keep perpendicular part\n            perp_noise = perp[0]*noise[0] + perp[1]*noise[1]\n            sample_pt = tuple(min(max(0.0, base_point[d] + perp[d]*perp_noise) , bounds[d]) for d in range(2))\n        else:\n            # Simple isotropic noise clipped to bounds\n            sample_pt = tuple(min(max(0.0, base_point[d] + noise[d]), bounds[d]) for d in range(len(bounds)))\n        if not self._in_obstacle(sample_pt, obstacles, is_3d):\n            return sample_pt\n        return self._sample_free(bounds, obstacles, is_3d)\n\n    def _extend_and_rewire(self, tree, sample, obstacles, is_3d, nodes, edges, bounds, dim):\n        nearest = self._nearest(tree, sample)\n        dist_to_sample = self._distance(nearest.position, sample)\n        step = max(self.min_step, min(self.max_step, dist_to_sample))\n        new_pos = self._steer(nearest.position, sample, step)\n        if not self._valid_node_and_edge(nearest.position, new_pos, obstacles, is_3d):\n            return None\n\n        neighbors = self._near_nodes(tree, new_pos, bounds, dim)\n        min_cost = nearest.cost + self._distance(nearest.position, new_pos)\n        best_parent = nearest\n        for nb in neighbors:\n            if self._valid_node_and_edge(nb.position, new_pos, obstacles, is_3d):\n                cost = nb.cost + self._distance(nb.position, new_pos)\n                if cost < min_cost:\n                    min_cost = cost\n                    best_parent = nb\n\n        new_node = Node(new_pos, best_parent, min_cost)\n        best_parent.add_child(new_node)\n        tree.append(new_node)\n        nodes.append(new_node)\n        edges.append((best_parent, new_node))\n\n        for nb in neighbors:\n            if nb is best_parent:\n                continue\n            if self._valid_node_and_edge(new_node.position, nb.position, obstacles, is_3d):\n                updated_cost = new_node.cost + self._distance(new_node.position, nb.position)\n                if updated_cost + 1e-6 < nb.cost:\n                    if nb.parent:\n                        try:\n                            edges.remove((nb.parent, nb))\n                        except ValueError:\n                            pass\n                        if nb in nb.parent.children:\n                            nb.parent.children.remove(nb)\n                    new_node.add_child(nb)\n                    nb.cost = updated_cost\n                    edges.append((new_node, nb))\n\n        return new_node\n\n    def _connect_and_rewire(self, tree, target_node, obstacles, is_3d, nodes, edges, bounds, dim):\n        current = self._nearest(tree, target_node.position)\n        while True:\n            dist_to_target = self._distance(current.position, target_node.position)\n            if dist_to_target <= self.min_step:\n                if self._valid_node_and_edge(current.position, target_node.position, obstacles, is_3d):\n                    final_node = Node(target_node.position, current, current.cost + dist_to_target)\n                    current.add_child(final_node)\n                    tree.append(final_node)\n                    nodes.append(final_node)\n                    edges.append((current, final_node))\n                    return final_node\n                return None\n\n            step = max(self.min_step, min(self.max_step, dist_to_target))\n            new_pos = self._steer(current.position, target_node.position, step)\n            if not self._valid_node_and_edge(current.position, new_pos, obstacles, is_3d):\n                return None\n\n            neighbors = self._near_nodes(tree, new_pos, bounds, dim)\n            min_cost = current.cost + self._distance(current.position, new_pos)\n            best_parent = current\n            for nb in neighbors:\n                if self._valid_node_and_edge(nb.position, new_pos, obstacles, is_3d):\n                    cost = nb.cost + self._distance(nb.position, new_pos)\n                    if cost < min_cost:\n                        min_cost = cost\n                        best_parent = nb\n\n            new_node = Node(new_pos, best_parent, min_cost)\n            best_parent.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            for nb in neighbors:\n                if nb is best_parent:\n                    continue\n                if self._valid_node_and_edge(new_node.position, nb.position, obstacles, is_3d):\n                    updated_cost = new_node.cost + self._distance(new_node.position, nb.position)\n                    if updated_cost + 1e-6 < nb.cost:\n                        if nb.parent:\n                            try:\n                                edges.remove((nb.parent, nb))\n                            except ValueError:\n                                pass\n                            if nb in nb.parent.children:\n                                nb.parent.children.remove(nb)\n                        new_node.add_child(nb)\n                        nb.cost = updated_cost\n                        edges.append((new_node, nb))\n\n            current = new_node\n\n    def _near_nodes(self, tree, position, bounds, dim):\n        n = max(1, len(tree))\n        scale = max(1.0, sum(bounds) / dim)\n        r_theory = self.gamma_rrt_star * ((math.log(n + 1) / (n + 1)) ** (1.0 / dim))\n        radius = max(self.min_step * 1.8, min(self.max_radius, r_theory * 0.6 + scale * 0.03))\n        return [node for node in tree if self._distance(node.position, position) <= radius]\n\n    def _steer(self, from_pos, to_pos, step_size):\n        dist = self._distance(from_pos, to_pos)\n        if dist <= step_size:\n            return to_pos\n        ratio = step_size / dist\n        return tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(len(from_pos)))\n\n    def _valid_node_and_edge(self, from_pos, to_pos, obstacles, is_3d):\n        if self._in_obstacle(to_pos, obstacles, is_3d):\n            return False\n        return not self._edge_in_obstacle(from_pos, to_pos, obstacles, is_3d)\n\n    def _in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x,y,z,w,h,d = obs\n                px,py,pz = pos\n                if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                    return True\n            else:\n                x,y,w,h = obs\n                px,py = pos\n                if x <= px <= x+w and y <= py <= y+h:\n                    return True\n        return False\n\n    def _edge_in_obstacle(self, p1, p2, obstacles, is_3d, resolution=0.5):\n        dist = self._distance(p1, p2)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps+1):\n            interp = tuple(p1[d] + (p2[d]-p1[d]) * i / steps for d in range(len(p1)))\n            if self._in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _distance(self, a,b):\n        s=0.0\n        for i in range(len(a)):\n            s += (a[i]-b[i])**2\n        return s**0.5\n\n    def _nearest(self, tree, point):\n        best = None\n        best_dist = float('inf')\n        for node in tree:\n            dist = self._distance(node.position, point)\n            if dist < best_dist:\n                best_dist = dist\n                best = node\n        return best\n\n    def _rand_float(self):\n        if not hasattr(self, '_rand_state'):\n            self._rand_state = 987654321\n        self._rand_state = (1664525 * self._rand_state + 1013904223) & 0xFFFFFFFF\n        return self._rand_state / 4294967295.0\n\n    def _shortcut_path(self, path, obstacles, is_3d):\n        if len(path) < 3:\n            return path[:]\n        shortened = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            while j > i+1:\n                if not self._edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                    break\n                j -= 1\n            shortened.append(path[j])\n            i = j\n        return shortened",
          "objective": -11.1158,
          "time_improvement": 36.0,
          "length_improvement": 13.0,
          "smoothness_improvement": 1839.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 0.9,
                    "time_avg": 0.03728148937225342,
                    "num_nodes_avg": 87.5,
                    "path_length_avg": 177.5993625994981,
                    "smoothness_avg": 0.061093825863437166,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": -42.00947578063485,
                    "length_improvement": 2.6549751172230844,
                    "smoothness_improvement": 856.2510421290689,
                    "objective_score": -56.72860245321125
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.040665721893310545,
                    "num_nodes_avg": 172.6,
                    "path_length_avg": 240.60704401879048,
                    "smoothness_avg": 0.11503528741526861,
                    "success_improvement": 0.0,
                    "time_improvement": 75.37500676751161,
                    "length_improvement": 19.678443216759863,
                    "smoothness_improvement": 2859.940801763299,
                    "objective_score": 48.7192719691259
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.013425302505493165,
                    "num_nodes_avg": 80.8,
                    "path_length_avg": 124.56156413344789,
                    "smoothness_avg": 0.14941690218783527,
                    "success_improvement": 0.0,
                    "time_improvement": 73.30195871674466,
                    "length_improvement": 17.272140086854744,
                    "smoothness_improvement": 1800.5719670207743,
                    "objective_score": 41.356731502240116
               }
          ],
          "success_rate": 0.9666666666666667
     },
     {
          "operator": "m3",
          "algorithm_description": "A simplified bidirectional RRT* algorithm that grows two trees from start and goal, samples uniformly with bias towards improving the solution, rewires locally to optimize paths, attempts direct connections between trees to find a path, and performs post-processing shortcutting to smooth and shorten the final path. It uses straightforward nearest neighbor search and basic collision checking to ensure valid paths while balancing computational cost and path quality.",
          "planning_mechanism": "The planner alternates growing start and goal trees towards sampled points inside the map bounds or within the informed ellipsoid if a solution exists. New nodes are linked and rewired locally to reduce path cost. It frequently attempts to connect the two trees directly upon proximity. Upon finding a path, it applies shortcutting to improve smoothness. The search halts on first valid path or after max iterations.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\nclass Planner:\n    def __init__(self, max_iter=3000, step_size=7.5, rewire_radius=15.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.rewire_radius = rewire_radius\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        edges = []\n        best_cost = float('inf')\n        best_path = []\n\n        def dist(a, b):\n            return sum((a[i]-b[i])**2 for i in range(dim))**0.5\n\n        def in_collision(p):\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d = obs\n                    if x <= p[0] <= x+w and y <= p[1] <= y+h and z <= p[2] <= z+d:\n                        return True\n                else:\n                    x,y,w,h = obs\n                    if x <= p[0] <= x+w and y <= p[1] <= y+h:\n                        return True\n            return False\n\n        def edge_collision(a, b, resolution=1.0):\n            d = dist(a,b)\n            steps = max(1, int(d/resolution))\n            for i in range(steps+1):\n                pt = tuple(a[j] + (b[j]-a[j]) * i/steps for j in range(dim))\n                if in_collision(pt):\n                    return True\n            return False\n\n        def steer(from_p, to_p, max_step):\n            d = dist(from_p, to_p)\n            if d <= max_step:\n                return to_p\n            ratio = max_step / d\n            return tuple(from_p[i] + (to_p[i]-from_p[i])*ratio for i in range(dim))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: dist(n.position, point))\n\n        def neighbors(tree, point, radius):\n            radius_sq = radius*radius\n            result = []\n            for n in tree:\n                if sum((n.position[i]-point[i])**2 for i in range(dim)) <= radius_sq:\n                    result.append(n)\n            return result\n\n        def extract_path(node_start, node_goal):\n            path_start = []\n            n = node_start\n            while n:\n                path_start.append(n.position)\n                n = n.parent\n            path_start.reverse()\n            path_goal = []\n            n = node_goal\n            while n:\n                path_goal.append(n.position)\n                n = n.parent\n            return path_start + path_goal\n\n        def sample_informed(c_best):\n            if c_best == float('inf'):\n                while True:\n                    p = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                    if not in_collision(p):\n                        return p\n            c_min = dist(start_pos, goal_pos)\n            if c_min == 0.0:\n                return goal_pos\n            center = tuple((start_pos[i]+goal_pos[i])/2 for i in range(dim))\n            a1 = [(goal_pos[i]-start_pos[i])/c_min for i in range(dim)]\n            L1 = c_best/2.0\n            L2 = ((c_best**2 - c_min**2)**0.5)/2.0\n            while True:\n                while True:\n                    sample = [random.uniform(-1,1) for _ in range(dim)]\n                    norm_s = sum(s*s for s in sample)**0.5\n                    if 0 < norm_s <= 1:\n                        break\n                unit_s = [s/norm_s for s in sample]\n                r = random.uniform(0,1)**(1/dim)\n                unit_ball = [r*us for us in unit_s]\n                ellipsoid_sample = [L1*unit_ball[0]] + [L2*unit_ball[i] for i in range(1,dim)]\n                # Rotate ellipsoid sample to align with a1 (only 2D/3D)\n                if dim == 2:\n                    theta = 0\n                    if abs(a1[0]) < 1.0:\n                        theta = math.acos(a1[0])\n                        if a1[1] < 0:\n                            theta = -theta\n                    x = ellipsoid_sample[0]*math.cos(theta) - ellipsoid_sample[1]*math.sin(theta)\n                    y = ellipsoid_sample[0]*math.sin(theta) + ellipsoid_sample[1]*math.cos(theta)\n                    p = (center[0]+x, center[1]+y)\n                elif dim == 3:\n                    # simple rotation aligning x-axis to a1 using Householder reflection\n                    x = a1\n                    I = [[1 if i==j else 0 for j in range(3)] for i in range(3)]\n                    v = [x[0]-1, x[1], x[2]]\n                    norm_v = sum(vi*vi for vi in v)**0.5\n                    if norm_v < 1e-10:\n                        R = I\n                    else:\n                        v = [vi/norm_v for vi in v]\n                        R = [[I[i][j] - 2*v[i]*v[j] for j in range(3)] for i in range(3)]\n                    rotated = tuple(sum(R[i][j]*ellipsoid_sample[j] for j in range(3)) for i in range(3))\n                    p = tuple(center[i] + rotated[i] for i in range(3))\n                else:\n                    p = tuple(center[i] + ellipsoid_sample[i] for i in range(dim))\n                if all(0 <= p[i] <= bounds[i] for i in range(dim)) and not in_collision(p):\n                    return p\n\n        def shortcut_path(path):\n            if len(path)<3:\n                return path\n            i = 0\n            while i < len(path)-2:\n                j = len(path)-1\n                while j > i+1:\n                    if not edge_collision(path[i], path[j]):\n                        path = path[:i+1]+path[j:]\n                        break\n                    j -=1\n                i +=1\n            return path\n\n        def rewire(tree, new_node):\n            nghs = neighbors(tree, new_node.position, self.rewire_radius)\n            for ngh in nghs:\n                if ngh == new_node.parent:\n                    continue\n                if edge_collision(new_node.position, ngh.position):\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, ngh.position)\n                if new_cost + 1e-7 < ngh.cost:\n                    if ngh.parent:\n                        try:\n                            ngh.parent.children.remove(ngh)\n                        except:\n                            pass\n                    ngh.parent = new_node\n                    ngh.cost = new_cost\n                    new_node.add_child(ngh)\n\n        for iteration in range(self.max_iter):\n            sample = sample_informed(best_cost)\n            for (tree_a, tree_b) in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nn = nearest(tree_a, sample)\n                new_pos = steer(nn.position, sample, self.step_size)\n                if in_collision(new_pos) or edge_collision(nn.position, new_pos):\n                    continue\n                new_cost = nn.cost + dist(nn.position, new_pos)\n                new_node = Node(new_pos, parent=nn, cost=new_cost)\n                nn.add_child(new_node)\n                tree_a.append(new_node)\n                edges.append((nn, new_node))\n\n                rewire(tree_a, new_node)\n\n                nearest_other = nearest(tree_b, new_pos)\n                dist_trees = dist(new_pos, nearest_other.position)\n                if dist_trees <= self.step_size*2 and not edge_collision(new_pos, nearest_other.position):\n                    connect_node = Node(nearest_other.position, parent=new_node, cost=new_node.cost + dist_trees)\n                    new_node.add_child(connect_node)\n                    tree_b.append(connect_node)\n                    edges.append((new_node, connect_node))\n\n                    path = extract_path(new_node, nearest_other)\n                    path = shortcut_path(path)\n\n                    cost_path = 0.0\n                    for k in range(len(path)-1):\n                        cost_path += dist(path[k], path[k+1])\n                    if cost_path < best_cost:\n                        best_cost = cost_path\n                        best_path = path\n            if best_path:\n                return PlannerResult(True, best_path, start_tree+goal_tree, edges)\n        return PlannerResult(False, [], start_tree+goal_tree, edges)",
          "objective": -7.96217,
          "time_improvement": -25.0,
          "length_improvement": 11.0,
          "smoothness_improvement": 1799.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.05618610382080078,
                    "num_nodes_avg": 139.8,
                    "path_length_avg": 185.25496856355855,
                    "smoothness_avg": 0.04960682018479354,
                    "success_improvement": 0.0,
                    "time_improvement": -114.01932390840987,
                    "length_improvement": -1.5411838225179815,
                    "smoothness_improvement": 676.4544588262154,
                    "objective_score": -31.748235171902678
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.037730622291564944,
                    "num_nodes_avg": 170.8,
                    "path_length_avg": 236.8253031039858,
                    "smoothness_avg": 0.12587993282534443,
                    "success_improvement": 0.0,
                    "time_improvement": 77.15234661209345,
                    "length_improvement": 20.94089718549847,
                    "smoothness_improvement": 3138.9813392469123,
                    "objective_score": 51.40514899116168
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.06945254802703857,
                    "num_nodes_avg": 205.7,
                    "path_length_avg": 131.1004396537589,
                    "smoothness_avg": 0.13218220013348647,
                    "success_improvement": 0.0,
                    "time_improvement": -38.11584459228801,
                    "length_improvement": 12.929330314056402,
                    "smoothness_improvement": 1581.3478290228345,
                    "objective_score": 4.22958395586161
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "A simplified and efficient bidirectional RRT* planner that incrementally grows two trees from start and goal, sampling free space with goal bias, extending one tree towards samples stepwise, choosing best parents within a radius, rewiring neighbors to reduce costs, and attempting connection between trees for fast solution. It ensures collision-free nodes and edges with minimal overhead and prioritized early stopping on solution discovery.",
          "planning_mechanism": "The planner alternates growing two trees toward random samples, connecting new nodes by selecting lowest cost parents in a neighborhood, rewires neighbors to optimize paths locally, and greedily connects trees incrementally. Planning stops on first found solution or max iterations.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        node, path = self, []\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=3000, step_size=4.0, gamma=50.0, max_radius=40.0, goal_sample_rate=0.05):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.gamma = gamma\n        self.max_radius = max_radius\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map):\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        tree_start = [Node(start_pos)]\n        tree_goal = [Node(goal_pos)]\n        nodes = tree_start + tree_goal\n        edges = []\n\n        def in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    px, py = pos\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def edge_collision(p1, p2, resolution=1.0):\n            dist = math.dist(p1, p2)\n            steps = max(1, int(dist / resolution))\n            for i in range(steps + 1):\n                interm = tuple(p1[d] + (p2[d] - p1[d]) * i / steps for d in range(dim))\n                if in_obstacle(interm):\n                    return True\n            return False\n\n        def sample_free():\n            if random.random() < self.goal_sample_rate:\n                return goal_pos\n            while True:\n                s = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not in_obstacle(s):\n                    return s\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: math.dist(n.position, point))\n\n        def steer(from_p, to_p):\n            dist = math.dist(from_p, to_p)\n            if dist <= self.step_size:\n                return to_p\n            ratio = self.step_size / dist\n            return tuple(from_p[d] + (to_p[d] - from_p[d]) * ratio for d in range(dim))\n\n        def neighbor_radius(n):\n            if n < 2:\n                return self.step_size * 2.0\n            r = self.gamma * ((math.log(n) / n) ** (1 / dim))\n            return min(max(self.step_size * 2, r), self.max_radius)\n\n        def near_nodes(tree, pos):\n            radius = neighbor_radius(len(tree))\n            return [n for n in tree if math.dist(n.position, pos) <= radius]\n\n        def can_connect(p1, p2):\n            return (not in_obstacle(p2) and not edge_collision(p1, p2))\n\n        def add_node(tree, new_pos):\n            near = near_nodes(tree, new_pos)\n            candidates = [n for n in near if can_connect(n.position, new_pos)]\n            if not candidates:\n                parent = nearest(tree, new_pos)\n                if not can_connect(parent.position, new_pos):\n                    return None\n                best_parent = parent\n                best_cost = parent.cost + math.dist(parent.position, new_pos)\n            else:\n                best_parent, best_cost = min(\n                    ((n, n.cost + math.dist(n.position, new_pos)) for n in candidates),\n                    key=lambda x: x[1]\n                )\n            new_node = Node(new_pos, parent=None, cost=best_cost)\n            best_parent.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n            return new_node\n\n        def rewire(new_node, neighbors):\n            for nb in neighbors:\n                if nb is new_node:\n                    continue\n                if can_connect(new_node.position, nb.position):\n                    new_cost = new_node.cost + math.dist(new_node.position, nb.position)\n                    if new_cost + 1e-12 < nb.cost:\n                        if nb.parent:\n                            try:\n                                edges.remove((nb.parent, nb))\n                            except ValueError:\n                                pass\n                            if nb in nb.parent.children:\n                                nb.parent.children.remove(nb)\n                        new_node.add_child(nb)\n                        nb.cost = new_cost\n                        edges.append((new_node, nb))\n\n        def extend(tree, target, other_tree):\n            nearest_node = nearest(tree, target)\n            new_pos = steer(nearest_node.position, target)\n            if not can_connect(nearest_node.position, new_pos):\n                return None\n            new_node = add_node(tree, new_pos)\n            if not new_node:\n                return None\n            near = near_nodes(tree, new_pos)\n            rewire(new_node, near)\n            connect_node = attempt_connect(other_tree, new_node)\n            if connect_node:\n                return new_node, connect_node\n            return new_node, None\n\n        def attempt_connect(tree, target_node):\n            nearest_node = nearest(tree, target_node.position)\n            current = nearest_node\n            while True:\n                new_pos = steer(current.position, target_node.position)\n                if not can_connect(current.position, new_pos):\n                    return None\n                new_node = add_node(tree, new_pos)\n                if not new_node:\n                    return None\n                near = near_nodes(tree, new_pos)\n                rewire(new_node, near)\n                current = new_node\n                if math.dist(current.position, target_node.position) <= self.step_size:\n                    if can_connect(current.position, target_node.position):\n                        final_node = Node(target_node.position, parent=None, cost=current.cost + math.dist(current.position, target_node.position))\n                        current.add_child(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((current, final_node))\n                        return final_node\n                    else:\n                        return None\n\n        best_path = []\n        found = False\n        for _ in range(self.max_iter):\n            sample = sample_free()\n            res = extend(tree_start, sample, tree_goal)\n            if res is None:\n                tree_start, tree_goal = tree_goal, tree_start\n                continue\n            new_node, connect_node = res\n            if connect_node:\n                path_start = new_node.path_from_root()\n                path_goal = connect_node.path_from_root()\n                if path_start[-1] == path_goal[-1]:\n                    path_goal = path_goal[:-1]\n                best_path = path_start + path_goal[::-1]\n                found = True\n                break\n            tree_start, tree_goal = tree_goal, tree_start\n\n        return PlannerResult(success=found, path=best_path, nodes=nodes, edges=edges)",
          "objective": -3.14348,
          "time_improvement": -23.0,
          "length_improvement": 15.0,
          "smoothness_improvement": 270.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.04289665222167969,
                    "num_nodes_avg": 86.2,
                    "path_length_avg": 154.80487257571312,
                    "smoothness_avg": 0.029055568068706832,
                    "success_improvement": 0.0,
                    "time_improvement": -63.398276123557494,
                    "length_improvement": 15.14899630106843,
                    "smoothness_improvement": 354.7827354511964,
                    "objective_score": -8.156171379170209
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.07331087589263915,
                    "num_nodes_avg": 305.3,
                    "path_length_avg": 256.0586439039306,
                    "smoothness_avg": 0.012268278642848006,
                    "success_improvement": 0.0,
                    "time_improvement": 55.60684186400731,
                    "length_improvement": 14.52025442545721,
                    "smoothness_improvement": 215.67164596441225,
                    "objective_score": 26.472563444298576
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.08116095066070557,
                    "num_nodes_avg": 297.7,
                    "path_length_avg": 129.65699918833218,
                    "smoothness_avg": 0.02674729664510849,
                    "success_improvement": 0.0,
                    "time_improvement": -61.399596801723554,
                    "length_improvement": 13.887994741944096,
                    "smoothness_improvement": 240.22363904570852,
                    "objective_score": -8.885964000122067
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "A bidirectional RRT planner integrating incremental tree growth with dynamic bidirectional connection attempts, enhanced by adaptive stepping and early collision pruning to improve planning efficiency, path length, and smoothness. The planner grows two trees from start and goal positions alternately, samples collision-free points within bounds, and attempts to connect the trees efficiently by extending towards the nearest nodes with collision checks and dynamic step sizes proportional to target distance. It extracts a collision-free path once the trees connect, producing streamlined, robust, and smooth paths efficiently.",
          "planning_mechanism": "The planner alternates growing two trees from start and goal, sampling free points and extending each tree towards them with adaptive step sizes. After each extension, it tries to connect the newly added node to the other tree by incremental, collision-checked steps. Upon connecting nodes from both trees within a step, it extracts the path by concatenating the two tree paths, ensuring collision-free, smooth, and relatively short paths with efficient exploration.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=4000, max_step=7.0, min_step=1.0):\n        self.max_iter = max_iter\n        self.max_step = max_step\n        self.min_step = min_step\n\n    def plan(self, map):\n        bounds = map.size\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start, None, 0.0)]\n        goal_tree = [Node(goal, None, 0.0)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        for i in range(self.max_iter):\n            tree_a, tree_b = (start_tree, goal_tree) if (i % 2 == 0) else (goal_tree, start_tree)\n            rand = self._sample_free(bounds, obstacles, is_3d)\n            new_node_a = self._extend(tree_a, rand, obstacles, is_3d, nodes, edges)\n            if new_node_a is None:\n                continue\n            new_node_b = self._connect(tree_b, new_node_a, obstacles, is_3d, nodes, edges)\n            if new_node_b:\n                path_start = new_node_a.path_from_root()\n                path_goal = new_node_b.path_from_root()\n                if path_start[-1] == path_goal[-1]:\n                    full_path = path_start + path_goal[-2::-1]\n                else:\n                    full_path = path_start + path_goal[::-1]\n                return PlannerResult(True, full_path, nodes, edges)\n\n        return PlannerResult(False, [], nodes, edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        while True:\n            if is_3d:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(3))\n            else:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(2))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def _nearest(self, tree, point):\n        return min(tree, key=lambda node: self._distance(node.position, point))\n\n    def _steer(self, from_pos, to_pos, step_size):\n        dist = self._distance(from_pos, to_pos)\n        if dist <= step_size:\n            return to_pos\n        ratio = step_size / dist\n        return tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(len(from_pos)))\n\n    def _extend(self, tree, point, obstacles, is_3d, nodes, edges):\n        nearest = self._nearest(tree, point)\n        dist = self._distance(nearest.position, point)\n        step = max(self.min_step, min(self.max_step, dist))\n        new_pos = self._steer(nearest.position, point, step)\n        if not self._valid_node_and_edge(nearest.position, new_pos, obstacles, is_3d):\n            return None\n        cost = nearest.cost + self._distance(nearest.position, new_pos)\n        new_node = Node(new_pos, nearest, cost)\n        nearest.add_child(new_node)\n        tree.append(new_node)\n        nodes.append(new_node)\n        edges.append((nearest, new_node))\n        return new_node\n\n    def _connect(self, tree, target_node, obstacles, is_3d, nodes, edges):\n        current = self._nearest(tree, target_node.position)\n        while True:\n            dist = self._distance(current.position, target_node.position)\n            if dist <= self.min_step:\n                if self._valid_node_and_edge(current.position, target_node.position, obstacles, is_3d):\n                    final_node = Node(target_node.position, current, current.cost + dist)\n                    current.add_child(final_node)\n                    tree.append(final_node)\n                    nodes.append(final_node)\n                    edges.append((current, final_node))\n                    return final_node\n                else:\n                    return None\n            step = max(self.min_step, min(self.max_step, dist))\n            new_pos = self._steer(current.position, target_node.position, step)\n            if not self._valid_node_and_edge(current.position, new_pos, obstacles, is_3d):\n                return None\n            cost = current.cost + self._distance(current.position, new_pos)\n            new_node = Node(new_pos, current, cost)\n            current.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((current, new_node))\n            current = new_node\n\n    def _valid_node_and_edge(self, from_pos, to_pos, obstacles, is_3d):\n        return (not self._is_in_obstacle(to_pos, obstacles, is_3d)) and (not self._is_edge_in_obstacle(from_pos, to_pos, obstacles, is_3d))\n\n    def _distance(self, a, b):\n        return sum((a[d] - b[d]) ** 2 for d in range(len(a))) ** 0.5\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, p1, p2, obstacles, is_3d, resolution=0.75):\n        dist = self._distance(p1, p2)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(p1[d] + (p2[d] - p1[d]) * i / steps for d in range(len(p1)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -2.9445,
          "time_improvement": 71.0,
          "length_improvement": -4.0,
          "smoothness_improvement": 135.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 0.9,
                    "time_avg": 0.0052031993865966795,
                    "num_nodes_avg": 66.1,
                    "path_length_avg": 179.52586487195038,
                    "smoothness_avg": 0.015996258195269022,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": 80.18041581185753,
                    "length_improvement": 1.599028694309952,
                    "smoothness_improvement": 150.37617718660707,
                    "objective_score": -24.234577153923727
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.025962257385253908,
                    "num_nodes_avg": 183.2,
                    "path_length_avg": 311.53884259076005,
                    "smoothness_avg": 0.008952320893406817,
                    "success_improvement": 0.0,
                    "time_improvement": 84.27864101148131,
                    "length_improvement": -4.00063280518264,
                    "smoothness_improvement": 130.34966468346292,
                    "objective_score": 23.534960943752125
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.02556898593902588,
                    "num_nodes_avg": 173.0,
                    "path_length_avg": 165.20684003090693,
                    "smoothness_avg": 0.017623676399170646,
                    "success_improvement": 0.0,
                    "time_improvement": 49.15259139287367,
                    "length_improvement": -9.722516844185002,
                    "smoothness_improvement": 124.17186295297415,
                    "objective_score": 9.533126626115969
               }
          ],
          "success_rate": 0.9666666666666667
     },
     {
          "operator": "m3",
          "algorithm_description": "A simplified bidirectional RRT planner alternating tree expansions, sampling collision-free points, extending towards sampled points with fixed step size, and attempting quick connection between trees. It efficiently grows two trees in 2D or 3D spaces while validating nodes and edges against obstacles, stopping upon connection to return a feasible path.",
          "planning_mechanism": "The planner grows a start and goal tree alternately by sampling random free points in the space, extending toward them with a fixed step size while checking for collisions. After each extension, it attempts to connect the other tree to the new node directly in a single step. Once connected, the full path is reconstructed and returned.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        path, node = [], self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=3000, step_size=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map):\n        bounds = map.size\n        start, goal = map.start, map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n\n        start_tree = [Node(start)]\n        goal_tree = [Node(goal)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        for i in range(self.max_iter):\n            tree_a, tree_b = (start_tree, goal_tree) if i % 2 == 0 else (goal_tree, start_tree)\n            rand = self._sample_free(bounds, obstacles, dim)\n            new_node = self._extend(tree_a, rand, obstacles, dim)\n            if not new_node:\n                continue\n            connected = self._try_connect(tree_b, new_node, obstacles, dim)\n            if connected:\n                path_start = new_node.path_from_root()\n                path_goal = connected.path_from_root()\n                if path_start[-1] == path_goal[-1]:\n                    path = path_start + path_goal[-2::-1]\n                else:\n                    path = path_start + path_goal[::-1]\n                return PlannerResult(True, path, nodes, edges)\n\n        return PlannerResult(False, [], nodes, edges)\n\n    def _sample_free(self, bounds, obstacles, dim):\n        import random\n        while True:\n            pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            if not self._is_in_obstacle(pt, obstacles, dim):\n                return pt\n\n    def _nearest(self, tree, point):\n        return min(tree, key=lambda n: self._distance(n.position, point))\n\n    def _steer(self, from_pos, to_pos):\n        dist = self._distance(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(len(from_pos)))\n\n    def _extend(self, tree, point, obstacles, dim):\n        nearest = self._nearest(tree, point)\n        new_pos = self._steer(nearest.position, point)\n        if not self._valid_move(nearest.position, new_pos, obstacles, dim):\n            return None\n        cost = nearest.cost + self._distance(nearest.position, new_pos)\n        new_node = Node(new_pos, nearest, cost)\n        nearest.add_child(new_node)\n        tree.append(new_node)\n        return new_node\n\n    def _try_connect(self, tree, target_node, obstacles, dim):\n        nearest = self._nearest(tree, target_node.position)\n        if not self._valid_move(nearest.position, target_node.position, obstacles, dim):\n            return None\n        cost = nearest.cost + self._distance(nearest.position, target_node.position)\n        new_node = Node(target_node.position, nearest, cost)\n        nearest.add_child(new_node)\n        tree.append(new_node)\n        return new_node\n\n    def _valid_move(self, from_pos, to_pos, obstacles, dim):\n        return (not self._is_in_obstacle(to_pos, obstacles, dim)) and (not self._edge_in_obstacle(from_pos, to_pos, obstacles, dim))\n\n    def _distance(self, a, b):\n        return sum((a[d]-b[d])**2 for d in range(len(a)))**0.5\n\n    def _is_in_obstacle(self, pos, obstacles, dim):\n        if dim == 3:\n            x, y, z = pos\n            for ox, oy, oz, w, h, d in obstacles:\n                if ox <= x <= ox+w and oy <= y <= oy+h and oz <= z <= oz+d:\n                    return True\n        else:\n            x, y = pos\n            for ox, oy, w, h in obstacles:\n                if ox <= x <= ox+w and oy <= y <= oy+h:\n                    return True\n        return False\n\n    def _edge_in_obstacle(self, p1, p2, obstacles, dim, res=1.0):\n        dist = self._distance(p1, p2)\n        steps = max(1, int(dist / res))\n        for i in range(steps+1):\n            interp = tuple(p1[d] + (p2[d] - p1[d]) * i / steps for d in range(dim))\n            if self._is_in_obstacle(interp, obstacles, dim):\n                return True\n        return False",
          "objective": 0.15112,
          "time_improvement": 64.0,
          "length_improvement": -5.0,
          "smoothness_improvement": 80.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 0.9,
                    "time_avg": 0.011497068405151366,
                    "num_nodes_avg": 2.0,
                    "path_length_avg": 198.14674835764038,
                    "smoothness_avg": 0.011015579939297184,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": 56.20634570343186,
                    "length_improvement": -8.607372610977757,
                    "smoothness_improvement": 72.41774676470342,
                    "objective_score": -37.940431121733575
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.035675334930419925,
                    "num_nodes_avg": 2.0,
                    "path_length_avg": 303.7268747444005,
                    "smoothness_avg": 0.006990144131000228,
                    "success_improvement": 0.0,
                    "time_improvement": 78.39691906777979,
                    "length_improvement": -1.3927730830407905,
                    "smoothness_improvement": 79.8614432879454,
                    "objective_score": 23.08271908694919
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.021834397315979005,
                    "num_nodes_avg": 2.0,
                    "path_length_avg": 158.12349228379125,
                    "smoothness_avg": 0.01480234075208045,
                    "success_improvement": 0.0,
                    "time_improvement": 56.5793291660661,
                    "length_improvement": -5.018094543324328,
                    "smoothness_improvement": 88.284681771322,
                    "objective_score": 14.404365432681844
               }
          ],
          "success_rate": 0.9666666666666667
     },
     {
          "operator": "m3",
          "algorithm_description": "A simplified bidirectional RRT* planner that balances exploration and optimization with clear structure. It grows two trees from start and goal, alternates extension towards random samples with mild goal bias, uses radius-based neighbor rewiring to improve paths, and attempts greedy connection of the two trees for fast solution discovery. Strict collision checking ensures robustness.",
          "planning_mechanism": "The planner samples in free space, extends one tree towards the sample with step-wise steering, chooses the best parent among neighbors within a neighborhood radius, rewires neighbors to reduce path costs, then attempts to connect the other tree greedily. Upon connecting, it extracts and returns the combined path, iterating until a solution is found or iteration limit is reached.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent: Optional[\"Node\"]=None, cost: float=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children: List[\"Node\"] = []\n\n    def add_child(self, child: \"Node\"):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        node, path = self, []\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 3000, step_size: float = 4.0, gamma_rrt_star: float = 50.0, max_radius: float = 40.0, goal_sample_rate: float = 0.05):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.gamma_rrt_star = gamma_rrt_star\n        self.max_radius = max_radius\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map) -> \"PlannerResult\":\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        tree_start = [Node(start_pos)]\n        tree_goal = [Node(goal_pos)]\n        nodes = tree_start + tree_goal\n        edges: List[Tuple[Node,Node]] = []\n\n        def sample_free():\n            if random.random() < self.goal_sample_rate:\n                return goal_pos\n            while True:\n                s = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(s, obstacles, is_3d):\n                    return s\n\n        def nearest(tree: List[Node], point: Tuple[float, ...]) -> Node:\n            return min(tree, key=lambda n: math.dist(n.position, point))\n\n        def steer(from_pos, to_pos) -> Tuple[float, ...]:\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dim))\n\n        def neighbor_radius(n_nodes: int) -> float:\n            if n_nodes < 2:\n                return self.step_size * 2.0\n            r = self.gamma_rrt_star * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            return min(max(self.step_size*2.0, r), self.max_radius)\n\n        def near_nodes(tree: List[Node], pos: Tuple[float,...]) -> List[Node]:\n            r = neighbor_radius(len(tree))\n            return [n for n in tree if math.dist(n.position, pos) <= r]\n\n        def can_connect(from_p, to_p) -> bool:\n            return (not self._is_in_obstacle(to_p, obstacles, is_3d)\n                    and not self._is_edge_in_obstacle(from_p, to_p, obstacles, is_3d))\n\n        def add_node_with_parent(tree: List[Node], new_pos: Tuple[float, ...]) -> Optional[Node]:\n            near = near_nodes(tree, new_pos)\n            candidates = [n for n in near if can_connect(n.position, new_pos)]\n            if not candidates:\n                parent = nearest(tree, new_pos)\n                if not can_connect(parent.position, new_pos):\n                    return None\n                best_parent = parent\n                best_cost = parent.cost + math.dist(parent.position, new_pos)\n            else:\n                best_parent, best_cost = min(\n                    ((n, n.cost + math.dist(n.position, new_pos)) for n in candidates),\n                    key=lambda x: x[1]\n                )\n            new_node = Node(new_pos, parent=None, cost=best_cost)\n            best_parent.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n            return new_node\n\n        def rewire(node: Node, neighbors: List[Node]):\n            for nb in neighbors:\n                if nb is node:\n                    continue\n                if can_connect(node.position, nb.position):\n                    new_cost = node.cost + math.dist(node.position, nb.position)\n                    if new_cost + 1e-12 < nb.cost:\n                        if nb.parent is not None:\n                            try:\n                                edges.remove((nb.parent, nb))\n                            except ValueError:\n                                pass\n                            if nb in nb.parent.children:\n                                nb.parent.children.remove(nb)\n                        node.add_child(nb)\n                        nb.cost = new_cost\n                        edges.append((node, nb))\n\n        def extend(tree: List[Node], target_point: Tuple[float, ...], other_tree: List[Node]) -> Optional[Node]:\n            nearest_node = nearest(tree, target_point)\n            new_pos = steer(nearest_node.position, target_point)\n            if not can_connect(nearest_node.position, new_pos):\n                return None\n            new_node = add_node_with_parent(tree, new_pos)\n            if not new_node:\n                return None\n            near = near_nodes(tree, new_pos)\n            rewire(new_node, near)\n            # Attempt connect with other_tree greedily\n            connect_node = attempt_connect(other_tree, new_node)\n            if connect_node:\n                return (new_node, connect_node)\n            return (new_node, None)\n\n        def attempt_connect(tree: List[Node], target_node: Node) -> Optional[Node]:\n            nearest_node = nearest(tree, target_node.position)\n            current = nearest_node\n            while True:\n                new_pos = steer(current.position, target_node.position)\n                if not can_connect(current.position, new_pos):\n                    return None\n                new_node = add_node_with_parent(tree, new_pos)\n                if new_node is None:\n                    return None\n                near = near_nodes(tree, new_pos)\n                rewire(new_node, near)\n                current = new_node\n                if math.dist(current.position, target_node.position) <= self.step_size:\n                    if can_connect(current.position, target_node.position):\n                        final_node = Node(target_node.position, parent=None, cost=current.cost + math.dist(current.position, target_node.position))\n                        current.add_child(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((current, final_node))\n                        return final_node\n                    else:\n                        return None\n\n        best_path: List[Tuple[float,...]] = []\n        solution_found = False\n\n        for _ in range(self.max_iter):\n            sample = sample_free()\n            result = extend(tree_start, sample, tree_goal)\n            if result is None:\n                tree_start, tree_goal = tree_goal, tree_start\n                continue\n            new_node, connect_node = result\n            if connect_node:\n                path_start = new_node.path_from_root()\n                path_goal = connect_node.path_from_root()\n                if path_start[-1] == path_goal[-1]:\n                    path_goal = path_goal[:-1]\n                best_path = path_start + path_goal[::-1]\n                solution_found = True\n                break\n            tree_start, tree_goal = tree_goal, tree_start\n\n        return PlannerResult(success=solution_found, path=best_path, nodes=nodes, edges=edges)\n\n    def _is_in_obstacle(self, pos: Tuple[float,...], obstacles, is_3d: bool) -> bool:\n        for obs in obstacles:\n            if is_3d:\n                x,y,z,w,h,d = obs\n                px,py,pz = pos\n                if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                    return True\n            else:\n                x,y,w,h = obs\n                px,py = pos\n                if x <= px <= x+w and y <= py <= y+h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_p: Tuple[float,...], to_p: Tuple[float,...], obstacles, is_3d: bool, resolution: float=1.0) -> bool:\n        dist = math.dist(from_p, to_p)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps+1):\n            interm = tuple(from_p[d] + (to_p[d] - from_p[d]) * i/steps for d in range(len(from_p)))\n            if self._is_in_obstacle(interm, obstacles, is_3d):\n                return True\n        return False",
          "objective": 2.60201,
          "time_improvement": -40.0,
          "length_improvement": 14.0,
          "smoothness_improvement": 242.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.049528646469116214,
                    "num_nodes_avg": 102.8,
                    "path_length_avg": 163.73573386408458,
                    "smoothness_avg": 0.024721319861977082,
                    "success_improvement": 0.0,
                    "time_improvement": -88.66030407138894,
                    "length_improvement": 10.253849710358729,
                    "smoothness_improvement": 286.9423390452511,
                    "objective_score": -19.011069699975188
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.07662971019744873,
                    "num_nodes_avg": 315.6,
                    "path_length_avg": 257.08848163237656,
                    "smoothness_avg": 0.011895872353594215,
                    "success_improvement": 0.0,
                    "time_improvement": 53.59713274067979,
                    "length_improvement": 14.176464949466494,
                    "smoothness_improvement": 206.0893639085042,
                    "objective_score": 25.615465611426355
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.09266290664672852,
                    "num_nodes_avg": 359.9,
                    "path_length_avg": 126.19502968546935,
                    "smoothness_avg": 0.02608580925521416,
                    "success_improvement": 0.0,
                    "time_improvement": -84.27280175389355,
                    "length_improvement": 16.18727004447308,
                    "smoothness_improvement": 231.80956827217284,
                    "objective_score": -14.410430658123351
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "A streamlined bidirectional RRT planner using uniform random sampling, fixed incremental extensions, and direct tree connections, ensuring collision-free node and edge additions. It alternates expanding from start and goal trees and returns a feasible path upon connecting both trees.",
          "planning_mechanism": "The planner iteratively samples random configurations within bounds avoiding obstacles, extends the active tree incrementally toward samples verifying collision-free paths, then tries to directly connect the other tree with a collision-free edge. Once the trees connect, the combined path from start to goal is returned.",
          "code": "class Node:\n    def __init__(self, pos, parent=None, cost=0.0):\n        self.pos = pos\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n    def path(self):\n        node, path = self, []\n        while node:\n            path.append(node.pos)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=3000, step=5.0):\n        self.max_iter = max_iter\n        self.step = step\n\n    def plan(self, map):\n        bounds = map.size\n        start, goal = map.start, map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n\n        tree_start = [Node(start)]\n        tree_goal = [Node(goal)]\n        nodes = tree_start + tree_goal\n        edges = []\n\n        for i in range(self.max_iter):\n            active_tree, other_tree = (tree_start, tree_goal) if i % 2 == 0 else (tree_goal, tree_start)\n            sample = self._random_free(bounds, obstacles, dim)\n            new_node = self._extend_tree(active_tree, sample, obstacles, dim)\n            if not new_node:\n                continue\n            connected_node = self._connect_tree(other_tree, new_node, obstacles, dim)\n            if connected_node:\n                path_start = new_node.path()\n                path_goal = connected_node.path()\n                if path_start[-1] == path_goal[-1]:\n                    path = path_start + path_goal[-2::-1]\n                else:\n                    path = path_start + path_goal[::-1]\n                return PlannerResult(True, path, nodes, edges)\n        return PlannerResult(False, [], nodes, edges)\n\n    def _random_free(self, bounds, obstacles, dim):\n        import random\n        while True:\n            pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            if not self._in_obstacle(pt, obstacles, dim):\n                return pt\n\n    def _nearest(self, tree, pt):\n        return min(tree, key=lambda n: self._dist(n.pos, pt))\n\n    def _steer(self, from_p, to_p):\n        dist = self._dist(from_p, to_p)\n        if dist <= self.step:\n            return to_p\n        ratio = self.step / dist\n        return tuple(from_p[d] + ratio * (to_p[d] - from_p[d]) for d in range(len(from_p)))\n\n    def _extend_tree(self, tree, target, obstacles, dim):\n        nearest = self._nearest(tree, target)\n        new_pos = self._steer(nearest.pos, target)\n        if self._valid_move(nearest.pos, new_pos, obstacles, dim):\n            cost = nearest.cost + self._dist(nearest.pos, new_pos)\n            new_node = Node(new_pos, nearest, cost)\n            nearest.add_child(new_node)\n            tree.append(new_node)\n            return new_node\n        return None\n\n    def _connect_tree(self, tree, node, obstacles, dim):\n        nearest = self._nearest(tree, node.pos)\n        if self._valid_move(nearest.pos, node.pos, obstacles, dim):\n            cost = nearest.cost + self._dist(nearest.pos, node.pos)\n            new_node = Node(node.pos, nearest, cost)\n            nearest.add_child(new_node)\n            tree.append(new_node)\n            return new_node\n        return None\n\n    def _valid_move(self, p1, p2, obstacles, dim):\n        return not self._in_obstacle(p2, obstacles, dim) and not self._edge_in_obstacle(p1, p2, obstacles, dim)\n\n    def _dist(self, a, b):\n        return sum((a[d] - b[d]) ** 2 for d in range(len(a))) ** 0.5\n\n    def _in_obstacle(self, pos, obstacles, dim):\n        if dim == 3:\n            x, y, z = pos\n            for ox, oy, oz, w, h, d in obstacles:\n                if ox <= x <= ox + w and oy <= y <= oy + h and oz <= z <= oz + d:\n                    return True\n        else:\n            x, y = pos\n            for ox, oy, w, h in obstacles:\n                if ox <= x <= ox + w and oy <= y <= oy + h:\n                    return True\n        return False\n\n    def _edge_in_obstacle(self, p1, p2, obstacles, dim, res=1.0):\n        dist = self._dist(p1, p2)\n        steps = max(1, int(dist / res))\n        for i in range(steps + 1):\n            interp = tuple(p1[d] + (p2[d] - p1[d]) * i / steps for d in range(dim))\n            if self._in_obstacle(interp, obstacles, dim):\n                return True\n        return False",
          "objective": 3.31752,
          "time_improvement": 56.0,
          "length_improvement": -6.0,
          "smoothness_improvement": 78.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 0.9,
                    "time_avg": 0.011667585372924805,
                    "num_nodes_avg": 2.0,
                    "path_length_avg": 199.7506003496484,
                    "smoothness_avg": 0.010986406240193407,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": 55.55682698481459,
                    "length_improvement": -9.486469302458534,
                    "smoothness_improvement": 71.96111502202773,
                    "objective_score": -38.6650279109206
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.042991256713867186,
                    "num_nodes_avg": 2.0,
                    "path_length_avg": 314.05205420211536,
                    "smoothness_avg": 0.006785880616944327,
                    "success_improvement": 0.0,
                    "time_improvement": 73.9667868576729,
                    "length_improvement": -4.839615179838341,
                    "smoothness_improvement": 74.60559594622474,
                    "objective_score": 19.659294929129988
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.03116497993469238,
                    "num_nodes_avg": 2.0,
                    "path_length_avg": 157.5621983172945,
                    "smoothness_avg": 0.014671261501278421,
                    "success_improvement": 0.0,
                    "time_improvement": 38.0241956896094,
                    "length_improvement": -4.645309816723679,
                    "smoothness_improvement": 86.61736337638406,
                    "objective_score": 9.053159633730532
               }
          ],
          "success_rate": 0.9666666666666667
     },
     {
          "operator": "initial",
          "algorithm_description": "This algorithm is a sampling-based path planning algorithm that incrementally builds a space-filling tree rooted at the start position by randomly sampling the configuration space and extending the nearest existing node toward the sample. It continues this process until the goal is reached or a maximum number of iterations is exceeded.",
          "planning_mechanism": "The planner randomly samples free configurations, finds the nearest node in the current tree, attempts to extend toward the sample by a fixed step size, and adds the new node if the move is valid. This repeats until the goal is reached or iteration limit is hit.",
          "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 3.0, goal_sample_rate: float = 0.05):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map) -> PlannerResult:\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        root = Node(start_position)\n        nodes.append(root)\n\n        for _ in range(self.max_iter):\n            # Goal biasing\n            if random.random() < self.goal_sample_rate:\n                sample = goal_position\n            else:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n\n            # Find nearest node\n            nearest_node = min(nodes, key=lambda n: math.dist(n.position, sample))\n\n            # Steer\n            direction = tuple(sample[d] - nearest_node.position[d] for d in range(len(bounds)))\n            length = math.dist(nearest_node.position, sample)\n            if length == 0:\n                continue\n            unit = tuple(d / length for d in direction)\n            new_position = tuple(nearest_node.position[d] + unit[d] * min(self.step_size, length) for d in range(len(bounds)))\n\n            if self._is_in_obstacle(new_position, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_position, obstacles, is_3d):\n                continue\n\n            new_node = Node(new_position, parent=nearest_node, cost=nearest_node.cost + math.dist(nearest_node.position, new_position))\n            nearest_node.add_child(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n\n            # Check if goal reached\n            if math.dist(new_position, goal_position) <= self.step_size:\n                if not self._is_edge_in_obstacle(new_position, goal_position, obstacles, is_3d) and not self._is_in_obstacle(goal_position, obstacles, is_3d):\n                    goal_node = Node(goal_position, parent=new_node, cost=new_node.cost + math.dist(new_position, goal_position))\n                    new_node.add_child(goal_node)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    success_state = True\n                    break\n\n        if success_state:\n            path = []\n            node = nodes[-1]\n            while node:\n                path.append(node.position)\n                node = node.parent\n            extracted_path = path[::-1]\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n    ",
          "objective": 13.539658367700772,
          "time_improvement": -37.0,
          "length_improvement": -4.0,
          "smoothness_improvement": -3.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.031679368019104,
                    "num_nodes_avg": 450.7,
                    "path_length_avg": 193.62088691148162,
                    "smoothness_avg": 0.006040635098414152,
                    "success_improvement": 0.0,
                    "time_improvement": -20.670351995190355,
                    "length_improvement": -6.126676235474156,
                    "smoothness_improvement": -5.45094326075027,
                    "objective_score": -9.904366056145351
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.197274112701416,
                    "num_nodes_avg": 1615.1,
                    "path_length_avg": 307.8542325921529,
                    "smoothness_avg": 0.0037980890505142787,
                    "success_improvement": 0.0,
                    "time_improvement": -19.45868569510465,
                    "length_improvement": -2.770603932029184,
                    "smoothness_improvement": -2.2724330773004446,
                    "objective_score": -7.511330233135406
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.08638930320739746,
                    "num_nodes_avg": 827.4,
                    "path_length_avg": 154.71370064881916,
                    "smoothness_avg": 0.007670978439019678,
                    "success_improvement": 0.0,
                    "time_improvement": -71.7968874458546,
                    "length_improvement": -2.7534732962052977,
                    "smoothness_improvement": -2.4257204683999647,
                    "objective_score": -23.203278813821555
               }
          ],
          "success_rate": 1.0
     }
]