[
     {
          "operator": "initial",
          "algorithm_description": "This algorithm grows two trees simultaneously, one from the start position and one from the goal position, and attempts to connect them to find a feasible path. This bidirectional approach accelerates convergence and increases the success rate compared to a single tree RRT.",
          "planning_mechanism": "The planning mechanism involves randomly sampling points within the map bounds, extending each tree towards the sampled points, and attempting to connect the two trees whenever new nodes are added. Collision checks are performed for nodes and edges to ensure safety, and once the two trees connect, the final path is reconstructed by backtracking through the parent nodes of each tree.",
          "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map) -> PlannerResult:\n        import math, random\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position)\n        goal_root = Node(goal_position)\n        nodes.extend([start_root, goal_root])\n        tree_a, tree_b = [start_root], [goal_root]\n\n        for _ in range(self.max_iter):\n            rand_point = self._sample_free(bounds, obstacles, is_3d)\n            new_a = self._extend_tree(tree_a, rand_point, obstacles, is_3d, nodes, edges)\n            if new_a is None:\n                continue\n\n            new_b = self._connect_trees(tree_b, new_a, obstacles, is_3d, nodes, edges)\n            if new_b:\n                success_state = True\n                path_a = new_a.path_from_root()\n                path_b = new_b.path_from_root()\n                extracted_path = path_a + path_b[::-1]\n                break\n\n            tree_a, tree_b = tree_b, tree_a  # Swap trees\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        import random\n        while True:\n            if is_3d:\n                p = (random.uniform(0, bounds[0]),\n                     random.uniform(0, bounds[1]),\n                     random.uniform(0, bounds[2]))\n            else:\n                p = (random.uniform(0, bounds[0]),\n                     random.uniform(0, bounds[1]))\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    def _nearest(self, tree, point):\n        import math\n        return min(tree, key=lambda node: math.dist(node.position, point))\n\n    def _steer(self, from_pos, to_pos):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _extend_tree(self, tree, point, obstacles, is_3d, nodes, edges):\n        nearest_node = self._nearest(tree, point)\n        new_pos = self._steer(nearest_node.position, point)\n        if not self._is_in_obstacle(new_pos, obstacles, is_3d) and not self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n            new_node = Node(new_pos, parent=nearest_node)\n            nearest_node.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n            return new_node\n        return None\n\n    def _connect_trees(self, tree, new_node, obstacles, is_3d, nodes, edges):\n        import math\n        nearest_node = self._nearest(tree, new_node.position)\n        while True:\n            new_pos = self._steer(nearest_node.position, new_node.position)\n            if (not self._is_in_obstacle(new_pos, obstacles, is_3d) and\n                not self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d)):\n                next_node = Node(new_pos, parent=nearest_node)\n                nearest_node.add_child(next_node)\n                tree.append(next_node)\n                nodes.append(next_node)\n                edges.append((nearest_node, next_node))\n\n                if math.dist(next_node.position, new_node.position) <= self.step_size:\n                    if not self._is_edge_in_obstacle(next_node.position, new_node.position, obstacles, is_3d):\n                        final_node = Node(new_node.position, parent=next_node)\n                        next_node.add_child(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((next_node, final_node))\n                        return final_node\n                    else:\n                        return None\n                nearest_node = next_node\n            else:\n                return None\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n",
          "objective": -28.87615591314666,
          "time_improvement": 93.0,
          "length_improvement": 1.0,
          "smoothness_improvement": 69.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.0022002458572387695,
                    "num_nodes_avg": 57.5,
                    "path_length_avg": 171.4810676267031,
                    "smoothness_avg": 0.011144018674089623,
                    "success_improvement": 0.0,
                    "time_improvement": 91.61901077354663,
                    "length_improvement": 6.008509542400028,
                    "smoothness_improvement": 74.42809187338179,
                    "objective_score": 31.462949416870917
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.009090876579284668,
                    "num_nodes_avg": 226.2,
                    "path_length_avg": 305.50514541182173,
                    "smoothness_avg": 0.00636488258654892,
                    "success_improvement": 0.0,
                    "time_improvement": 94.49504979083876,
                    "length_improvement": -1.986411016509145,
                    "smoothness_improvement": 63.77301339152637,
                    "objective_score": 27.475533394303774
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.004314684867858886,
                    "num_nodes_avg": 127.6,
                    "path_length_avg": 150.78647946614691,
                    "smoothness_avg": 0.013383825302451875,
                    "success_improvement": 0.0,
                    "time_improvement": 91.41966188998718,
                    "length_improvement": -0.14519998085115468,
                    "smoothness_improvement": 70.24126995596559,
                    "objective_score": 27.68998492826529
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "initial",
          "algorithm_description": "This algorithm enhances the standard BI-RRT by incorporating an optimization step that rewires nearby nodes to minimize cost, resulting in asymptotically optimal paths. It grows two trees\u2014one from the start and one from the goal\u2014and attempts to connect them while optimizing the path cost dynamically.",
          "planning_mechanism": "The planning mechanism includes sampling a random point, extending each tree toward it, rewiring neighbors within a radius to optimize the cost, and attempting to connect the two trees. When a connection is established, the combined path is extracted from both trees. Node validity and edge collision checks are strictly enforced throughout the process.",
          "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost: float = 0.0):\n        self.position = position              # Tuple[float, ...]\n        self.parent: Optional[\"Node\"] = parent\n        self.cost: float = cost\n        self.children: List[\"Node\"] = []\n        self.valid = True\n\n    def add_child(self, child_node: \"Node\"):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n\nclass Planner:\n    def __init__(\n        self,\n        max_iter: int = 5000,\n        step_size: float = 5.0,\n        gamma_rrt_star: float = 50.0,\n        max_radius: float = 60.0,\n    ):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.gamma_rrt_star = gamma_rrt_star\n        self.max_radius = max_radius\n\n    # ======================= Public API =======================\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        start_root = Node(start_position, parent=None, cost=0.0)\n        goal_root  = Node(goal_position,  parent=None, cost=0.0)\n        nodes.extend([start_root, goal_root])\n\n        tree_a: List[Node] = [start_root]\n        tree_b: List[Node] = [goal_root]\n\n        for _ in range(self.max_iter):\n            rand_point = self._sample_free(bounds, obstacles, is_3d)\n\n            new_a = self._extend_and_rewire(tree_a, rand_point, obstacles, is_3d, nodes, edges, bounds)\n            if new_a is None:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            new_b = self._connect_and_rewire(tree_b, new_a, obstacles, is_3d, nodes, edges, bounds)\n            if new_b:\n                success_state = True\n                path_a = new_a.path_from_root()\n                path_b = new_b.path_from_root()\n                if path_a and path_b and path_a[-1] == path_b[-1]:\n                    path_b = path_b[:-1]\n                extracted_path = path_a + path_b[::-1]\n                break\n\n            tree_a, tree_b = tree_b, tree_a\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        while True:\n            p = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    def _nearest(self, tree: List[Node], point):\n        return min(tree, key=lambda node: math.dist(node.position, point))\n\n    def _steer(self, from_pos, to_pos):\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _near_nodes(self, tree: List[Node], position, bounds) -> List[Node]:\n        n = max(1, len(tree))\n        d = len(position)\n        # \uacf5\uac04 \uc2a4\ucf00\uc77c\uc744 \uac04\ub2e8\ud788 bounds\ub85c \ucd94\uc815 (\uc815\ubc00 X, \uc2e4\uc6a9\uc801)\n        scale = max(1.0, sum(bounds) / d)\n        r_theory = self.gamma_rrt_star * ((math.log(n + 1) / (n + 1)) ** (1.0 / d))\n        radius = max(self.step_size * 2.0, min(self.max_radius, r_theory * 0.5 + scale * 0.02))\n        return [node for node in tree if math.dist(node.position, position) <= radius]\n\n    def _choose_parent_and_add(self, tree, new_pos, obstacles, is_3d, nodes, edges, bounds):\n        nearest = self._nearest(tree, new_pos)\n        neighbors = self._near_nodes(tree, new_pos, bounds)\n\n        min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n        best_parent = nearest\n\n        for nb in neighbors:\n            if not self._is_edge_in_obstacle(nb.position, new_pos, obstacles, is_3d):\n                cand = nb.cost + math.dist(nb.position, new_pos)\n                if cand < min_cost:\n                    min_cost = cand\n                    best_parent = nb\n\n        new_node = Node(new_pos, parent=None, cost=min_cost)\n        best_parent.add_child(new_node)\n        tree.append(new_node)\n        nodes.append(new_node)\n        edges.append((best_parent, new_node))\n        return new_node, neighbors\n\n    def _rewire_from(self, pivot: Node, neighbors: List[Node], obstacles, is_3d, edges):\n        for nb in neighbors:\n            if not self._is_edge_in_obstacle(pivot.position, nb.position, obstacles, is_3d):\n                new_cost = pivot.cost + math.dist(pivot.position, nb.position)\n                if new_cost + 1e-12 < nb.cost:  # \uc791\uc740 \uc218\uce58 \ubc84\ud37c\n                    if nb.parent is not None:\n                        try:\n                            edges.remove((nb.parent, nb))\n                        except ValueError:\n                            pass\n                        if nb in nb.parent.children:\n                            nb.parent.children.remove(nb)\n                    pivot.add_child(nb)\n                    nb.cost = new_cost\n                    edges.append((pivot, nb))\n\n    def _extend_and_rewire(self, tree, sample_point, obstacles, is_3d, nodes, edges, bounds):\n        nearest = self._nearest(tree, sample_point)\n        new_pos = self._steer(nearest.position, sample_point)\n\n        if self._is_in_obstacle(new_pos, obstacles, is_3d):\n            return None\n        if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n            return None\n\n        new_node, neighbors = self._choose_parent_and_add(tree, new_pos, obstacles, is_3d, nodes, edges, bounds)\n        self._rewire_from(new_node, neighbors, obstacles, is_3d, edges)\n        return new_node\n\n    def _connect_and_rewire(self, tree, target_node: Node, obstacles, is_3d, nodes, edges, bounds):\n        nearest = self._nearest(tree, target_node.position)\n\n        while True:\n            new_pos = self._steer(nearest.position, target_node.position)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                return None\n\n            connect_node, neighbors = self._choose_parent_and_add(tree, new_pos, obstacles, is_3d, nodes, edges, bounds)\n            self._rewire_from(connect_node, neighbors, obstacles, is_3d, edges)\n\n            if math.dist(connect_node.position, target_node.position) <= self.step_size:\n                if (not self._is_edge_in_obstacle(connect_node.position, target_node.position, obstacles, is_3d) and\n                    not self._is_in_obstacle(target_node.position, obstacles, is_3d)):\n                    final_node = Node(target_node.position, parent=None, cost=connect_node.cost + math.dist(connect_node.position, target_node.position))\n                    connect_node.add_child(final_node)\n                    tree.append(final_node)\n                    nodes.append(final_node)\n                    edges.append((connect_node, final_node))\n                    return final_node\n                else:\n                    return None\n\n            nearest = connect_node\n\n        \n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n        \n        \n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n",
          "objective": -18.596615900992976,
          "time_improvement": 38.0,
          "length_improvement": 11.0,
          "smoothness_improvement": 172.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.0230562686920166,
                    "num_nodes_avg": 97.6,
                    "path_length_avg": 161.12249215478707,
                    "smoothness_avg": 0.018062462568387585,
                    "success_improvement": 0.0,
                    "time_improvement": 12.176023931931311,
                    "length_improvement": 11.686208900689492,
                    "smoothness_improvement": 182.71676246052309,
                    "objective_score": 11.578116332295703
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.035856032371521,
                    "num_nodes_avg": 250.1,
                    "path_length_avg": 265.1599124520743,
                    "smoothness_avg": 0.010159869700973916,
                    "success_improvement": 0.0,
                    "time_improvement": 78.28749833068048,
                    "length_improvement": 11.481989018596753,
                    "smoothness_improvement": 161.42076526441443,
                    "objective_score": 31.182546736684266
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.038674354553222656,
                    "num_nodes_avg": 237.3,
                    "path_length_avg": 137.40430639955787,
                    "smoothness_avg": 0.021326989594760596,
                    "success_improvement": 0.0,
                    "time_improvement": 23.090782197070272,
                    "length_improvement": 8.742602179373693,
                    "smoothness_improvement": 171.27773345073243,
                    "objective_score": 13.02918463399896
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "A simplified bidirectional RRT planner that balances efficient path finding and computational efficiency by alternating tree expansion from start and goal positions, using straightforward extension steps and rigorous collision checks without costly rewiring or informed sampling. The algorithm prioritizes easy implementation and reliable success at the cost of advanced path cost optimization or smoothing.",
          "planning_mechanism": "class 'Node'",
          "code": "class Node:\n    def __init__(self, position, parent=None):\n        self.position = position\n        self.parent = parent\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map):\n        bounds = map.size\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start)]\n        goal_tree = [Node(goal)]\n\n        nodes = start_tree + goal_tree\n        edges = []\n\n        for i in range(self.max_iter):\n            tree_a, tree_b = (start_tree, goal_tree) if i % 2 == 0 else (goal_tree, start_tree)\n\n            rand_point = self._sample_free(bounds, obstacles, is_3d)\n            new_node_a = self._extend(tree_a, rand_point, obstacles, is_3d, nodes, edges)\n            if new_node_a is None:\n                continue\n\n            new_node_b = self._connect(tree_b, new_node_a, obstacles, is_3d, nodes, edges)\n            if new_node_b is not None:\n                path_start = new_node_a.path_from_root()\n                path_goal = new_node_b.path_from_root()\n                # Avoid duplicating connecting node\n                if path_start[-1] == path_goal[-1]:\n                    full_path = path_start + path_goal[-2::-1]\n                else:\n                    full_path = path_start + path_goal[::-1]\n                return PlannerResult(\n                    success=True,\n                    path=full_path,\n                    nodes=nodes,\n                    edges=edges\n                )\n\n        return PlannerResult(\n            success=False,\n            path=[],\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        while True:\n            if is_3d:\n                p = tuple(random.uniform(0, bounds[d]) for d in range(3))\n            else:\n                p = tuple(random.uniform(0, bounds[d]) for d in range(2))\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    def _nearest(self, tree, point):\n        return min(tree, key=lambda node: self._distance(node.position, point))\n\n    def _steer(self, from_pos, to_pos):\n        dist = self._distance(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(len(from_pos)))\n\n    def _extend(self, tree, point, obstacles, is_3d, nodes, edges):\n        nearest = self._nearest(tree, point)\n        new_pos = self._steer(nearest.position, point)\n        if (self._within_bounds(new_pos, edges, nodes) and\n            not self._is_in_obstacle(new_pos, obstacles, is_3d) and\n            not self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d)):\n            new_node = Node(new_pos)\n            nearest.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest, new_node))\n            return new_node\n        return None\n\n    def _connect(self, tree, target_node, obstacles, is_3d, nodes, edges):\n        current = self._nearest(tree, target_node.position)\n        while True:\n            new_pos = self._steer(current.position, target_node.position)\n            if not self._within_bounds(new_pos, edges, nodes):\n                return None\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(current.position, new_pos, obstacles, is_3d):\n                return None\n            new_node = Node(new_pos)\n            current.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((current, new_node))\n            if self._distance(new_node.position, target_node.position) <= self.step_size:\n                if not self._is_edge_in_obstacle(new_node.position, target_node.position, obstacles, is_3d):\n                    final_node = Node(target_node.position)\n                    new_node.add_child(final_node)\n                    tree.append(final_node)\n                    nodes.append(final_node)\n                    edges.append((new_node, final_node))\n                    return final_node\n                else:\n                    return None\n            current = new_node\n\n    def _within_bounds(self, pos, edges, nodes):\n        dims = len(pos)\n        if hasattr(edges, '__len__') and nodes:\n            # edges and nodes arguments don't provide bounds, re-checking not needed\n            # Instead, handle bounds from map.size (caller)\n            # Simplify to true since map bounds are enforced in sampling and steering\n            return True\n        # fallback check (shouldn't occur)\n        return all(0.0 <= pos[d] <= 10000.0 for d in range(dims))  # large bound\n\n    def _distance(self, a, b):\n        return math.sqrt(sum((a[d]-b[d])**2 for d in range(len(a))))\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, p1, p2, obstacles, is_3d, resolution=1.0):\n        dist = self._distance(p1, p2)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(p1[d] + (p2[d] - p1[d]) * i / steps for d in range(len(p1)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -15.67822,
          "time_improvement": 51.0,
          "length_improvement": 0.0,
          "smoothness_improvement": 68.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.007469820976257324,
                    "num_nodes_avg": 73.1,
                    "path_length_avg": 176.0623468550158,
                    "smoothness_avg": 0.0107998836069439,
                    "success_improvement": 0.0,
                    "time_improvement": 71.54659379560685,
                    "length_improvement": 3.4974378023468984,
                    "smoothness_improvement": 69.04163077129193,
                    "objective_score": 23.907648973946657
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.03709430694580078,
                    "num_nodes_avg": 234.9,
                    "path_length_avg": 302.79595763742356,
                    "smoothness_avg": 0.006446290084951689,
                    "success_improvement": 0.0,
                    "time_improvement": 77.53766526263358,
                    "length_improvement": -1.0820061577686475,
                    "smoothness_improvement": 65.86768696088066,
                    "objective_score": 22.941434318933286
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.04822392463684082,
                    "num_nodes_avg": 247.1,
                    "path_length_avg": 154.05757544889508,
                    "smoothness_avg": 0.013304546360919387,
                    "success_improvement": 0.0,
                    "time_improvement": 4.100162341356848,
                    "length_improvement": -2.3177061797402922,
                    "smoothness_improvement": 69.23284767143511,
                    "objective_score": 0.1855892329200547
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "initial",
          "algorithm_description": "This algorithm is a bidirectional extension of RRT* that grows two trees from start and goal while optimizing paths via rewiring. It combines RRT*\u2018s asymptotic optimality with RRT-Connect\u2019s fast convergence through connection attempts between the trees.",
          "planning_mechanism": "The planner alternates growing two trees with sampling, extension, and rewiring. After each extension, it attempts to connect both trees. When connection is successful, a rewired optimal path is extracted across both trees.",
          "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, radius: float = 10.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.radius = radius\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n        nodes = []\n        edges = []\n        success_state = False\n        extracted_path = []\n\n        for iter in range(self.max_iter):\n            rand = self._sample_free(bounds, obstacles, is_3d)\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest = self._nearest(tree_a, rand)\n                new_pos = self._steer(nearest.position, rand, self.step_size)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                    continue\n\n                new_node = Node(new_pos)\n                near_nodes = self._near(tree_a, new_pos, self.radius)\n                min_cost = nearest.cost + self._distance(nearest.position, new_pos)\n                min_parent = nearest\n\n                for near in near_nodes:\n                    cost = near.cost + self._distance(near.position, new_pos)\n                    if cost < min_cost and not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d):\n                        min_cost = cost\n                        min_parent = near\n\n                new_node.parent = min_parent\n                new_node.cost = min_cost\n                min_parent.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((min_parent, new_node))\n\n                for near in near_nodes:\n                    if near == min_parent:\n                        continue\n                    new_cost = new_node.cost + self._distance(new_node.position, near.position)\n                    if new_cost < near.cost and not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                        if near.parent:\n                            edges.remove((near.parent, near))\n                        near.parent = new_node\n                        near.cost = new_cost\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n\n                connect_node = self._nearest(tree_b, new_node.position)\n                if self._distance(new_node.position, connect_node.position) < self.step_size and not self._is_edge_in_obstacle(new_node.position, connect_node.position, obstacles, is_3d):\n                    success_state = True\n                    extracted_path = self._extract_path(new_node, connect_node)\n                    return PlannerResult(True, extracted_path, start_tree + goal_tree, edges)\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        while True:\n            point = tuple(random.uniform(0, bounds[i]) for i in range(3 if is_3d else 2))\n            if not self._is_in_obstacle(point, obstacles, is_3d):\n                return point\n\n    def _nearest(self, tree, point):\n        return min(tree, key=lambda node: self._distance(node.position, point))\n\n    def _near(self, tree, point, radius):\n        return [node for node in tree if self._distance(node.position, point) <= radius]\n\n    def _steer(self, from_pos, to_pos, step_size):\n        dist = self._distance(from_pos, to_pos)\n        if dist <= step_size:\n            return to_pos\n        ratio = step_size / dist\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n    def _extract_path(self, node_a, node_b):\n        path_a = []\n        while node_a:\n            path_a.append(node_a.position)\n            node_a = node_a.parent\n        path_b = []\n        while node_b:\n            path_b.append(node_b.position)\n            node_b = node_b.parent\n        return list(reversed(path_a)) + path_b\n\n    def _distance(self, a, b):\n        return math.dist(a, b)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = self._distance(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n    ",
          "objective": -14.623200909903078,
          "time_improvement": 26.0,
          "length_improvement": 10.0,
          "smoothness_improvement": 172.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.01557013988494873,
                    "num_nodes_avg": 154.3,
                    "path_length_avg": 176.4019709606193,
                    "smoothness_avg": 0.016468810147838416,
                    "success_improvement": 0.0,
                    "time_improvement": 40.69154853726605,
                    "length_improvement": 3.3112844483772665,
                    "smoothness_improvement": 157.7726414073074,
                    "objective_score": 14.983098437242711
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.019739508628845215,
                    "num_nodes_avg": 283.4,
                    "path_length_avg": 260.814162084563,
                    "smoothness_avg": 0.010965222085418455,
                    "success_improvement": 0.0,
                    "time_improvement": 88.04680591498561,
                    "length_improvement": 12.9327255767608,
                    "smoothness_improvement": 182.14306218804825,
                    "objective_score": 35.084392431492404
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.07533800601959229,
                    "num_nodes_avg": 439.2,
                    "path_length_avg": 130.82946919354052,
                    "smoothness_avg": 0.021737514839812764,
                    "success_improvement": 0.0,
                    "time_improvement": -49.81987885086595,
                    "length_improvement": 13.109295991506725,
                    "smoothness_improvement": 176.49958426597442,
                    "objective_score": -6.197888139025877
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "initial",
          "algorithm_description": "This algorithm is a dual-tree variant of Rapidly-exploring Random Tree (RRT) that grows two trees from the start and goal positions, attempting to connect them as they expand. It is efficient for single-query problems due to its bidirectional search and reduced redundant exploration.",
          "planning_mechanism": "The planner alternates between growing the start and goal trees by extending towards randomly sampled points. Each extension step involves checking for collision-free motion and attempting to connect the two trees. The algorithm terminates when a valid path is formed connecting the trees.",
          "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n        nodes = []\n        edges = []\n        success_state = False\n        extracted_path = []\n\n        for iter in range(self.max_iter):\n            rand = self._sample_free(bounds, obstacles, is_3d)\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest = self._nearest(tree_a, rand)\n                new_pos = self._steer(nearest.position, rand, self.step_size)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                    continue\n                new_node = Node(new_pos, parent=nearest, cost=nearest.cost + self._distance(nearest.position, new_pos))\n                nearest.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((nearest, new_node))\n\n                connect_node = self._nearest(tree_b, new_pos)\n                if self._connect_trees(new_node, connect_node, obstacles, is_3d, tree_b, nodes, edges):\n                    success_state = True\n                    extracted_path = self._extract_path(new_node, connect_node)\n                    return PlannerResult(True, extracted_path, start_tree + goal_tree, edges)\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        while True:\n            if is_3d:\n                point = tuple(random.uniform(0, bounds[i]) for i in range(3))\n            else:\n                point = tuple(random.uniform(0, bounds[i]) for i in range(2))\n            if not self._is_in_obstacle(point, obstacles, is_3d):\n                return point\n\n    def _nearest(self, tree, point):\n        return min(tree, key=lambda node: self._distance(node.position, point))\n\n    def _steer(self, from_pos, to_pos, step_size):\n        dist = self._distance(from_pos, to_pos)\n        if dist <= step_size:\n            return to_pos\n        ratio = step_size / dist\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n    def _connect_trees(self, node_a, node_b, obstacles, is_3d, tree, nodes, edges):\n        from_pos = node_a.position\n        to_pos = node_b.position\n        if self._is_edge_in_obstacle(from_pos, to_pos, obstacles, is_3d):\n            return False\n        curr = node_b\n        path = []\n        while True:\n            new_pos = self._steer(curr.position, from_pos, self.step_size)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return False\n            if self._is_edge_in_obstacle(curr.position, new_pos, obstacles, is_3d):\n                return False\n            new_node = Node(new_pos, parent=curr, cost=curr.cost + self._distance(curr.position, new_pos))\n            curr.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((curr, new_node))\n            if self._distance(new_pos, from_pos) < self.step_size:\n                new_node_final = Node(from_pos, parent=new_node, cost=new_node.cost + self._distance(new_pos, from_pos))\n                new_node.add_child(new_node_final)\n                tree.append(new_node_final)\n                nodes.append(new_node_final)\n                edges.append((new_node, new_node_final))\n                return True\n            curr = new_node\n\n    def _extract_path(self, node_a, node_b):\n        path_a = []\n        while node_a:\n            path_a.append(node_a.position)\n            node_a = node_a.parent\n        path_b = []\n        while node_b:\n            path_b.append(node_b.position)\n            node_b = node_b.parent\n        return list(reversed(path_a)) + path_b\n\n    def _distance(self, a, b):\n        return math.dist(a, b)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = self._distance(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n    ",
          "objective": -12.240158084263113,
          "time_improvement": 53.0,
          "length_improvement": -7.0,
          "smoothness_improvement": 73.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.010491394996643066,
                    "num_nodes_avg": 120.3,
                    "path_length_avg": 195.76139846338907,
                    "smoothness_avg": 0.01116198298553718,
                    "success_improvement": 0.0,
                    "time_improvement": 60.037071244538545,
                    "length_improvement": -7.29992453565072,
                    "smoothness_improvement": 74.70927235766275,
                    "objective_score": 14.004713013759444
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.014621138572692871,
                    "num_nodes_avg": 220.6,
                    "path_length_avg": 298.75944281412666,
                    "smoothness_avg": 0.007195610696889318,
                    "success_improvement": 0.0,
                    "time_improvement": 91.14621795357668,
                    "length_improvement": 0.2654986748850134,
                    "smoothness_improvement": 85.14824601985723,
                    "objective_score": 27.928905821103296
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.04569807052612305,
                    "num_nodes_avg": 470.5,
                    "path_length_avg": 171.27857497950592,
                    "smoothness_avg": 0.012625069591645856,
                    "success_improvement": 0.0,
                    "time_improvement": 9.123167021946427,
                    "length_improvement": -13.755074092095834,
                    "smoothness_improvement": 60.58995332003385,
                    "objective_score": -5.2131445820734035
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "A simplified bidirectional RRT* planner that balances exploration and optimization with clear structure. It grows two trees from start and goal, alternates extension towards random samples with mild goal bias, uses radius-based neighbor rewiring to improve paths, and attempts greedy connection of the two trees for fast solution discovery. Strict collision checking ensures robustness.",
          "planning_mechanism": "The planner samples in free space, extends one tree towards the sample with step-wise steering, chooses the best parent among neighbors within a neighborhood radius, rewires neighbors to reduce path costs, then attempts to connect the other tree greedily. Upon connecting, it extracts and returns the combined path, iterating until a solution is found or iteration limit is reached.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent: Optional[\"Node\"]=None, cost: float=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children: List[\"Node\"] = []\n\n    def add_child(self, child: \"Node\"):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        node, path = self, []\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 3000, step_size: float = 4.0, gamma_rrt_star: float = 50.0, max_radius: float = 40.0, goal_sample_rate: float = 0.05):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.gamma_rrt_star = gamma_rrt_star\n        self.max_radius = max_radius\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map) -> \"PlannerResult\":\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        tree_start = [Node(start_pos)]\n        tree_goal = [Node(goal_pos)]\n        nodes = tree_start + tree_goal\n        edges: List[Tuple[Node,Node]] = []\n\n        def sample_free():\n            if random.random() < self.goal_sample_rate:\n                return goal_pos\n            while True:\n                s = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(s, obstacles, is_3d):\n                    return s\n\n        def nearest(tree: List[Node], point: Tuple[float, ...]) -> Node:\n            return min(tree, key=lambda n: math.dist(n.position, point))\n\n        def steer(from_pos, to_pos) -> Tuple[float, ...]:\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dim))\n\n        def neighbor_radius(n_nodes: int) -> float:\n            if n_nodes < 2:\n                return self.step_size * 2.0\n            r = self.gamma_rrt_star * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            return min(max(self.step_size*2.0, r), self.max_radius)\n\n        def near_nodes(tree: List[Node], pos: Tuple[float,...]) -> List[Node]:\n            r = neighbor_radius(len(tree))\n            return [n for n in tree if math.dist(n.position, pos) <= r]\n\n        def can_connect(from_p, to_p) -> bool:\n            return (not self._is_in_obstacle(to_p, obstacles, is_3d)\n                    and not self._is_edge_in_obstacle(from_p, to_p, obstacles, is_3d))\n\n        def add_node_with_parent(tree: List[Node], new_pos: Tuple[float, ...]) -> Optional[Node]:\n            near = near_nodes(tree, new_pos)\n            candidates = [n for n in near if can_connect(n.position, new_pos)]\n            if not candidates:\n                parent = nearest(tree, new_pos)\n                if not can_connect(parent.position, new_pos):\n                    return None\n                best_parent = parent\n                best_cost = parent.cost + math.dist(parent.position, new_pos)\n            else:\n                best_parent, best_cost = min(\n                    ((n, n.cost + math.dist(n.position, new_pos)) for n in candidates),\n                    key=lambda x: x[1]\n                )\n            new_node = Node(new_pos, parent=None, cost=best_cost)\n            best_parent.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n            return new_node\n\n        def rewire(node: Node, neighbors: List[Node]):\n            for nb in neighbors:\n                if nb is node:\n                    continue\n                if can_connect(node.position, nb.position):\n                    new_cost = node.cost + math.dist(node.position, nb.position)\n                    if new_cost + 1e-12 < nb.cost:\n                        if nb.parent is not None:\n                            try:\n                                edges.remove((nb.parent, nb))\n                            except ValueError:\n                                pass\n                            if nb in nb.parent.children:\n                                nb.parent.children.remove(nb)\n                        node.add_child(nb)\n                        nb.cost = new_cost\n                        edges.append((node, nb))\n\n        def extend(tree: List[Node], target_point: Tuple[float, ...], other_tree: List[Node]) -> Optional[Node]:\n            nearest_node = nearest(tree, target_point)\n            new_pos = steer(nearest_node.position, target_point)\n            if not can_connect(nearest_node.position, new_pos):\n                return None\n            new_node = add_node_with_parent(tree, new_pos)\n            if not new_node:\n                return None\n            near = near_nodes(tree, new_pos)\n            rewire(new_node, near)\n            # Attempt connect with other_tree greedily\n            connect_node = attempt_connect(other_tree, new_node)\n            if connect_node:\n                return (new_node, connect_node)\n            return (new_node, None)\n\n        def attempt_connect(tree: List[Node], target_node: Node) -> Optional[Node]:\n            nearest_node = nearest(tree, target_node.position)\n            current = nearest_node\n            while True:\n                new_pos = steer(current.position, target_node.position)\n                if not can_connect(current.position, new_pos):\n                    return None\n                new_node = add_node_with_parent(tree, new_pos)\n                if new_node is None:\n                    return None\n                near = near_nodes(tree, new_pos)\n                rewire(new_node, near)\n                current = new_node\n                if math.dist(current.position, target_node.position) <= self.step_size:\n                    if can_connect(current.position, target_node.position):\n                        final_node = Node(target_node.position, parent=None, cost=current.cost + math.dist(current.position, target_node.position))\n                        current.add_child(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((current, final_node))\n                        return final_node\n                    else:\n                        return None\n\n        best_path: List[Tuple[float,...]] = []\n        solution_found = False\n\n        for _ in range(self.max_iter):\n            sample = sample_free()\n            result = extend(tree_start, sample, tree_goal)\n            if result is None:\n                tree_start, tree_goal = tree_goal, tree_start\n                continue\n            new_node, connect_node = result\n            if connect_node:\n                path_start = new_node.path_from_root()\n                path_goal = connect_node.path_from_root()\n                if path_start[-1] == path_goal[-1]:\n                    path_goal = path_goal[:-1]\n                best_path = path_start + path_goal[::-1]\n                solution_found = True\n                break\n            tree_start, tree_goal = tree_goal, tree_start\n\n        return PlannerResult(success=solution_found, path=best_path, nodes=nodes, edges=edges)\n\n    def _is_in_obstacle(self, pos: Tuple[float,...], obstacles, is_3d: bool) -> bool:\n        for obs in obstacles:\n            if is_3d:\n                x,y,z,w,h,d = obs\n                px,py,pz = pos\n                if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                    return True\n            else:\n                x,y,w,h = obs\n                px,py = pos\n                if x <= px <= x+w and y <= py <= y+h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_p: Tuple[float,...], to_p: Tuple[float,...], obstacles, is_3d: bool, resolution: float=1.0) -> bool:\n        dist = math.dist(from_p, to_p)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps+1):\n            interm = tuple(from_p[d] + (to_p[d] - from_p[d]) * i/steps for d in range(len(from_p)))\n            if self._is_in_obstacle(interm, obstacles, is_3d):\n                return True\n        return False",
          "objective": 2.60201,
          "time_improvement": -40.0,
          "length_improvement": 14.0,
          "smoothness_improvement": 242.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.049528646469116214,
                    "num_nodes_avg": 102.8,
                    "path_length_avg": 163.73573386408458,
                    "smoothness_avg": 0.024721319861977082,
                    "success_improvement": 0.0,
                    "time_improvement": -88.66030407138894,
                    "length_improvement": 10.253849710358729,
                    "smoothness_improvement": 286.9423390452511,
                    "objective_score": -19.011069699975188
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.07662971019744873,
                    "num_nodes_avg": 315.6,
                    "path_length_avg": 257.08848163237656,
                    "smoothness_avg": 0.011895872353594215,
                    "success_improvement": 0.0,
                    "time_improvement": 53.59713274067979,
                    "length_improvement": 14.176464949466494,
                    "smoothness_improvement": 206.0893639085042,
                    "objective_score": 25.615465611426355
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.09266290664672852,
                    "num_nodes_avg": 359.9,
                    "path_length_avg": 126.19502968546935,
                    "smoothness_avg": 0.02608580925521416,
                    "success_improvement": 0.0,
                    "time_improvement": -84.27280175389355,
                    "length_improvement": 16.18727004447308,
                    "smoothness_improvement": 231.80956827217284,
                    "objective_score": -14.410430658123351
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "initial",
          "algorithm_description": "This algorithm is a sampling-based path planning algorithm that incrementally builds a space-filling tree rooted at the start position by randomly sampling the configuration space and extending the nearest existing node toward the sample. It continues this process until the goal is reached or a maximum number of iterations is exceeded.",
          "planning_mechanism": "The planner randomly samples free configurations, finds the nearest node in the current tree, attempts to extend toward the sample by a fixed step size, and adds the new node if the move is valid. This repeats until the goal is reached or iteration limit is hit.",
          "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 3.0, goal_sample_rate: float = 0.05):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map) -> PlannerResult:\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        root = Node(start_position)\n        nodes.append(root)\n\n        for _ in range(self.max_iter):\n            # Goal biasing\n            if random.random() < self.goal_sample_rate:\n                sample = goal_position\n            else:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n\n            # Find nearest node\n            nearest_node = min(nodes, key=lambda n: math.dist(n.position, sample))\n\n            # Steer\n            direction = tuple(sample[d] - nearest_node.position[d] for d in range(len(bounds)))\n            length = math.dist(nearest_node.position, sample)\n            if length == 0:\n                continue\n            unit = tuple(d / length for d in direction)\n            new_position = tuple(nearest_node.position[d] + unit[d] * min(self.step_size, length) for d in range(len(bounds)))\n\n            if self._is_in_obstacle(new_position, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_position, obstacles, is_3d):\n                continue\n\n            new_node = Node(new_position, parent=nearest_node, cost=nearest_node.cost + math.dist(nearest_node.position, new_position))\n            nearest_node.add_child(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n\n            # Check if goal reached\n            if math.dist(new_position, goal_position) <= self.step_size:\n                if not self._is_edge_in_obstacle(new_position, goal_position, obstacles, is_3d) and not self._is_in_obstacle(goal_position, obstacles, is_3d):\n                    goal_node = Node(goal_position, parent=new_node, cost=new_node.cost + math.dist(new_position, goal_position))\n                    new_node.add_child(goal_node)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    success_state = True\n                    break\n\n        if success_state:\n            path = []\n            node = nodes[-1]\n            while node:\n                path.append(node.position)\n                node = node.parent\n            extracted_path = path[::-1]\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n    ",
          "objective": 13.539658367700772,
          "time_improvement": -37.0,
          "length_improvement": -4.0,
          "smoothness_improvement": -3.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.031679368019104,
                    "num_nodes_avg": 450.7,
                    "path_length_avg": 193.62088691148162,
                    "smoothness_avg": 0.006040635098414152,
                    "success_improvement": 0.0,
                    "time_improvement": -20.670351995190355,
                    "length_improvement": -6.126676235474156,
                    "smoothness_improvement": -5.45094326075027,
                    "objective_score": -9.904366056145351
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.197274112701416,
                    "num_nodes_avg": 1615.1,
                    "path_length_avg": 307.8542325921529,
                    "smoothness_avg": 0.0037980890505142787,
                    "success_improvement": 0.0,
                    "time_improvement": -19.45868569510465,
                    "length_improvement": -2.770603932029184,
                    "smoothness_improvement": -2.2724330773004446,
                    "objective_score": -7.511330233135406
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.08638930320739746,
                    "num_nodes_avg": 827.4,
                    "path_length_avg": 154.71370064881916,
                    "smoothness_avg": 0.007670978439019678,
                    "success_improvement": 0.0,
                    "time_improvement": -71.7968874458546,
                    "length_improvement": -2.7534732962052977,
                    "smoothness_improvement": -2.4257204683999647,
                    "objective_score": -23.203278813821555
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e2",
          "algorithm_description": "A Hybrid Bidirectional Informed RRT* with Adaptive Neighborhood and Smooth Path Post-processing. The planner alternates growing two asymptotically optimal trees from start and goal using informed sampling within ellipsoidal bounds after first solution. It uses an adaptive neighborhood radius for rewiring and best parent selection to improve path quality while ensuring collision-free incremental expansion. Upon connecting trees, the algorithm performs shortcut smoothing on the path to enhance smoothness and reduce length before returning the result. This combination accelerates convergence, improves path optimality, and produces smoother feasible paths efficiently.",
          "planning_mechanism": "The planner initializes two trees at start and goal, grows them iteratively by sampling points either uniformly or informed within an ellipsoid after first solution, selecting parents for new nodes based on minimal path cost, and rewires neighbors within a dynamically computed radius to optimize local subtrees. Trees attempt connection after new node insertion; a feasible connection yields a combined path which is then shortcut-smoothed to reduce unnecessary turns and path length. This hybrid approach balances exploration and exploitation, improves computation efficiency, and delivers practical high-quality solutions.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        path = []\n        n = self\n        while n:\n            path.append(n.position)\n            n = n.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=5.0, gamma=60.0, \n                 post_opt_iters=300, max_no_improve=100, time_limit_sec=30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.gamma = gamma\n        self.post_opt_iters = post_opt_iters\n        self.max_no_improve = max_no_improve\n        self.time_limit_sec = time_limit_sec\n\n    def plan(self, map):\n        import math\n        import random\n        import time\n\n        bounds = map.size\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        def within_bounds(p):\n            return all(0.0 <= p[d] <= bounds[d] for d in range(dim))\n\n        # Initialize trees and data containers\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        tree_a = [start_root]\n        tree_b = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        c_min = math.dist(start_pos, goal_pos)\n        best_cost = float(\"inf\")\n        best_path = []\n        found_solution = False\n        no_improve_count = 0\n        post_opt_count = 0\n        start_time = time.time()\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_p, to_p):\n            d = dist(from_p, to_p)\n            if d <= self.step_size:\n                return to_p\n            r = self.step_size / d\n            return tuple(from_p[i] + (to_p[i] - from_p[i]) * r for i in range(dim))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: dist(n.position, point))\n\n        def neighbor_radius(n_nodes):\n            if n_nodes < 2:\n                return self.step_size * 2.0\n            r = self.gamma * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            max_r = max(bounds) * 0.30\n            min_r = max(10.0, self.step_size * 2.0)\n            return max(min_r, min(max_r, r))\n\n        def near_nodes(tree, point, radius):\n            return [n for n in tree if dist(n.position, point) <= radius]\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    px, py = pos\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(a, b, resolution=1.0):\n            length = dist(a, b)\n            steps = max(1, int(length / resolution))\n            for i in range(steps + 1):\n                interp = tuple(a[d] + (b[d] - a[d]) * (i / steps) for d in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def sample_uniform():\n            while True:\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle(p):\n                    return p\n\n        def sample_unit_ball():\n            while True:\n                v = [random.gauss(0, 1) for _ in range(dim)]\n                nrm = math.sqrt(sum(x*x for x in v))\n                if nrm > 1e-12:\n                    v = [x / nrm for x in v]\n                    r = random.random() ** (1.0 / dim)\n                    return tuple(v[i]*r for i in range(dim))\n\n        # Informed sampling inside the ellipsoid (or uniform if no solution)\n        def sample_informed(c_best):\n            if not found_solution or c_best == float(\"inf\") or c_min <= 1e-12:\n                return sample_uniform()\n            r1 = c_best / 2.0\n            r_other_sq = max(c_best * c_best - c_min * c_min, 0.0)\n            r_other = math.sqrt(r_other_sq) / 2.0\n            center = tuple((start_pos[d] + goal_pos[d]) / 2.0 for d in range(dim))\n            unit_vec = tuple((goal_pos[d] - start_pos[d]) / c_min for d in range(dim))\n\n            # Construct orthonormal basis for the ellipsoid axes\n            if dim == 2:\n                # Perp vector in 2D\n                perp_vec = (-unit_vec[1], unit_vec[0])\n                basis = [unit_vec, perp_vec]\n                radii = [r1, r_other]\n            else:  # 3D\n                # Create two perpendicular vectors using cross products\n                def cross(u,v):\n                    return (u[1]*v[2]-u[2]*v[1], u[2]*v[0]-u[0]*v[2], u[0]*v[1]-u[1]*v[0])\n                def norm(v):\n                    return math.sqrt(sum(x*x for x in v))\n                def normalize(v):\n                    n = norm(v)\n                    if n < 1e-12:\n                        return v\n                    return tuple(x/n for x in v)\n                ref = (1.0, 0.0, 0.0) if abs(unit_vec[0]) < 0.9 else (0.0, 1.0, 0.0)\n                b2 = normalize(cross(unit_vec, ref))\n                if norm(b2) < 1e-12:\n                    ref = (0.0, 0.0, 1.0)\n                    b2 = normalize(cross(unit_vec, ref))\n                b3 = cross(unit_vec, b2)\n                basis = [unit_vec, b2, b3]\n                radii = [r1, r_other, r_other]\n\n            u = sample_unit_ball()\n            mapped = []\n            for d in range(dim):\n                val = center[d]\n                for i in range(dim):\n                    val += basis[i][d] * radii[i] * u[i]\n                # Clamp to bounds\n                val = max(0.0, min(bounds[d], val))\n                mapped.append(val)\n            return tuple(mapped)\n\n        def add_node_with_best_parent(tree, pos):\n            r = neighbor_radius(len(tree))\n            neighbors = near_nodes(tree, pos, r)\n            if not neighbors:\n                # Use nearest if no neighbor within radius\n                neighbors = [nearest(tree, pos)]\n            candidates = [p for p in neighbors if not is_edge_in_obstacle(p.position, pos)]\n            if not candidates:\n                return None, []\n            parent = min(candidates, key=lambda p: p.cost + dist(p.position, pos))\n            cost_new = parent.cost + dist(parent.position, pos)\n            if is_in_obstacle(pos):\n                return None, []\n            new_node = Node(pos)\n            new_node.parent = parent\n            new_node.cost = cost_new\n            parent.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((parent, new_node))\n            return new_node, neighbors\n\n        def rewire(node, neighbors):\n            for n in neighbors:\n                if n is node:\n                    continue\n                if is_edge_in_obstacle(node.position, n.position):\n                    continue\n                new_cost = node.cost + dist(node.position, n.position)\n                if new_cost + 1e-12 < n.cost:\n                    if n.parent:\n                        try:\n                            edges.remove((n.parent, n))\n                        except ValueError:\n                            pass\n                        if n in n.parent.children:\n                            n.parent.children.remove(n)\n                    node.add_child(n)\n                    n.cost = new_cost\n                    edges.append((node, n))\n\n        def connect_trees(new_node, other_tree):\n            nearest_to_new = nearest(other_tree, new_node.position)\n            d = dist(new_node.position, nearest_to_new.position)\n            if d > self.step_size * 2.5:\n                return None\n            if is_edge_in_obstacle(new_node.position, nearest_to_new.position):\n                return None\n            return nearest_to_new\n\n        def extract_combined_path(n_start, n_goal, start_side=True):\n            path_from_start = n_start.path_from_root()\n            path_from_goal = n_goal.path_from_root()\n            if path_from_start[-1] == path_from_goal[-1]:\n                combined = path_from_start + path_from_goal[-2::-1]\n            else:\n                combined = path_from_start + path_from_goal[::-1]\n            if start_side:\n                return combined\n            else:\n                return combined[::-1]\n\n        def path_cost(path):\n            if not path or len(path) < 2:\n                return 0.0\n            c = 0.0\n            for i in range(len(path)-1):\n                c += dist(path[i], path[i+1])\n            return c\n\n        # Shortcut smoothing: tries to shortcut path pairs if collision free\n        def shortcut_path(path, attempts=40):\n            if len(path) < 3:\n                return path[:]\n            import random as rand\n            path_smoothed = path[:]\n            for _ in range(attempts):\n                if len(path_smoothed) < 3:\n                    break\n                i = rand.randint(0, len(path_smoothed)-3)\n                j = rand.randint(i+2, len(path_smoothed)-1)\n                if j <= i+1:\n                    continue\n                if not is_edge_in_obstacle(path_smoothed[i], path_smoothed[j]):\n                    # Shortcut possible, remove intermediate nodes\n                    path_smoothed = path_smoothed[:i+1] + path_smoothed[j:]\n            return path_smoothed\n\n        # Main planning loop\n        for it in range(self.max_iter):\n            # Time limit check\n            if time.time() - start_time > self.time_limit_sec:\n                break\n\n            # Alternate growth\n            grow_tree = tree_a if it % 2 == 0 else tree_b\n            other_tree = tree_b if it % 2 == 0 else tree_a\n            start_side = (grow_tree == tree_a)\n\n            sample = sample_informed(best_cost)\n            nearest_node = nearest(grow_tree, sample)\n            new_pos = steer(nearest_node.position, sample)\n\n            if not within_bounds(new_pos):\n                # Count post optimization if solution found\n                if found_solution:\n                    post_opt_count += 1\n                    no_improve_count += 1\n                    if post_opt_count >= self.post_opt_iters or no_improve_count >= self.max_no_improve:\n                        break\n                continue\n\n            if is_in_obstacle(new_pos) or is_edge_in_obstacle(nearest_node.position, new_pos):\n                if found_solution:\n                    post_opt_count += 1\n                    no_improve_count += 1\n                    if post_opt_count >= self.post_opt_iters or no_improve_count >= self.max_no_improve:\n                        break\n                continue\n\n            new_node, neighbors = add_node_with_best_parent(grow_tree, new_pos)\n            if new_node is None:\n                if found_solution:\n                    post_opt_count += 1\n                    no_improve_count += 1\n                    if post_opt_count >= self.post_opt_iters or no_improve_count >= self.max_no_improve:\n                        break\n                continue\n\n            rewire(new_node, neighbors)\n\n            # Attempt connection to other tree\n            connect_node = connect_trees(new_node, other_tree)\n            if connect_node:\n                # Join trees\n                if connect_node.parent is None or new_node.parent is None:\n                    # Should not happen, skip if roots\n                    continue\n                # Combine paths\n                candidate_path = extract_combined_path(new_node, connect_node, start_side)\n                candidate_cost = path_cost(candidate_path)\n                # If improved path found\n                if candidate_cost + 1e-7 < best_cost:\n                    best_cost = candidate_cost\n                    # Smooth path before recording\n                    best_path = shortcut_path(candidate_path, attempts=50)\n                    found_solution = True\n                    no_improve_count = 0\n                    post_opt_count = 0\n                else:\n                    if found_solution:\n                        no_improve_count += 1\n                        post_opt_count += 1\n                        if post_opt_count >= self.post_opt_iters or no_improve_count >= self.max_no_improve:\n                            break\n            else:\n                if found_solution:\n                    no_improve_count += 1\n                    post_opt_count += 1\n                    if post_opt_count >= self.post_opt_iters or no_improve_count >= self.max_no_improve:\n                        break\n\n        return PlannerResult(\n            success=found_solution,\n            path=best_path if found_solution else [],\n            nodes=nodes,\n            edges=edges\n        )",
          "objective": 14.32975,
          "time_improvement": -103.0,
          "length_improvement": 19.0,
          "smoothness_improvement": 1026.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.11174523830413818,
                    "num_nodes_avg": 170.3,
                    "path_length_avg": 155.95946117163558,
                    "smoothness_avg": 0.04431890634175788,
                    "success_improvement": 0.0,
                    "time_improvement": -325.65044958646763,
                    "length_improvement": 14.516147996016231,
                    "smoothness_improvement": 593.6871242940072,
                    "objective_score": -86.0170104568605
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.08233952522277832,
                    "num_nodes_avg": 319.1,
                    "path_length_avg": 230.98919001369396,
                    "smoothness_avg": 0.06524519533690301,
                    "success_improvement": 0.0,
                    "time_improvement": 50.13957315950754,
                    "length_improvement": 22.889159718239107,
                    "smoothness_improvement": 1578.8058702331955,
                    "objective_score": 36.6693971299617
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.06728522777557373,
                    "num_nodes_avg": 254.4,
                    "path_length_avg": 120.52492557718756,
                    "smoothness_avg": 0.0790609987636083,
                    "success_improvement": 0.0,
                    "time_improvement": -33.805833289081406,
                    "length_improvement": 19.953083211850664,
                    "smoothness_improvement": 905.6500685972023,
                    "objective_score": 6.358350283371988
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m1",
          "algorithm_description": "This algorithm introduces an enhanced informed sampling, tree pruning, and adaptive neighborhood to improve planning speed, path length, and smoothness in a unidirectional RRT* variant with post-optimization. It prunes the tree to remove unreachable nodes, dynamically adjusts the search neighborhood radius based on the number of nodes, and smoothens the final path with shortcutting to better reduce unnecessary zigzags and length.",
          "planning_mechanism": "The planner initially explores the entire map by uniform sampling, then once a feasible path is found, it switches to informed sampling within the ellipsoidal region defined by start, goal, and best path cost. It prunes nodes outside this region to focus search, dynamically calculates rewiring radius for better efficiency, performs rewiring to optimize locally, and finally applies shortcut-based path smoothing for improved smoothness and length.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=4000, step_size=5.0, improve_tol=1e-6, max_no_improve=100, post_opt_iters=300):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.improve_tol = improve_tol\n        self.max_no_improve = max_no_improve\n        self.post_opt_iters = post_opt_iters\n\n    def plan(self, map):\n        bounds = map.size\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        import math\n        import random\n\n        root = Node(start)\n        tree = [root]\n        nodes = [root]\n        edges = []\n\n        best_goal_node = None\n        best_cost = float('inf')\n        c_min = math.dist(start, goal)\n        found_solution = False\n\n        no_improve = 0\n        post_opt_count = 0\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def in_ellipsoid(point, c_best, c_min, start, goal):\n            # Check if point is within the prolate hyperspheroid\n            from math import sqrt\n            center = [(s + g) / 2 for s, g in zip(start, goal)]\n            diff = [p - c for p, c in zip(point, center)]\n            a1 = [g - s for s, g in zip(start, goal)]\n            norm_a1 = math.sqrt(sum(x*x for x in a1))\n            if norm_a1 < 1e-12:\n                return True\n            a1_unit = [x / norm_a1 for x in a1]\n\n            # Rotation matrix C (only rotation needed to align a1 with first axis)\n            # For low dimension (2 or 3), we create C via Gram-Schmidt and SVD is avoided\n            # We use a simplified test: x_M = C^T (point - center)\n            # To simplify, project difference vector onto a1_unit axis and orthogonal directions\n            proj = sum(d*u for d, u in zip(diff, a1_unit))\n            ortho_sq = sum((d - proj*u)**2 for d, u in zip(diff, a1_unit))\n            if c_best == float('inf'):\n                return True\n            val = (proj/(c_best/2))**2 + (ortho_sq/((math.sqrt(c_best**2 - c_min**2)/2)**2) if c_best > c_min else 1e10)\n            return val <= 1.0\n\n        def sample():\n            if not found_solution or best_cost == float('inf'):\n                while True:\n                    pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not self._is_in_obstacle(pt, obstacles, is_3d):\n                        return pt\n            else:\n                # informed sampling in ellipsoid\n                while True:\n                    # Sample in unit ball\n                    import random as rnd\n                    import math as m\n                    from math import sqrt\n                    from random import uniform\n                    # Generate random point in unit ball\n                    while True:\n                        pt_ball = [uniform(-1,1) for _ in range(dim)]\n                        norm_pt = math.sqrt(sum(x*x for x in pt_ball))\n                        if 0 < norm_pt <= 1: break\n                    # Scale to unit hypersphere\n                    pt_ball = [x / norm_pt for x in pt_ball]\n                    radius = rnd.random() ** (1/dim)\n                    pt_ball = [x * radius for x in pt_ball]\n\n                    # Apply ellipsoid scaling and rotation approx: aligned with axis a1\n                    # Use eigenvalues: c_best/2 along a1 and sqrt(c_best^2-c_min^2)/2 others\n                    a1 = [g - s for s, g in zip(start, goal)]\n                    norm_a1 = sqrt(sum(x*x for x in a1))\n                    if norm_a1 < 1e-9:\n                        return tuple(start)\n                    a1_unit = [x / norm_a1 for x in a1]\n\n                    L = [c / 2 for c in [best_cost] + [math.sqrt(best_cost*best_cost - c_min*c_min)]*(dim - 1)]\n                    center = [(s + g)/2 for s, g in zip(start, goal)]\n                    # Construct point in ellipsoid: x_center + C*L*x_ball\n                    # Using simplified approx. C aligns first dim with a1_unit\n                    # Compute dot product along a1_unit\n                    x_at_axis = pt_ball[0] * L[0]\n                    ortho_comp = [pt_ball[i] * L[i] for i in range(1, dim)]\n                    result = [center[i] + a1_unit[i]*x_at_axis for i in range(dim)]\n                    # to add orthogonal components, find basis orthogonal to a1_unit\n                    # we can just approximate by summing orthogonal components to axes\n                    # For 2D: orthogonal vector\n                    if dim == 2:\n                        # orth vector\n                        o = [-a1_unit[1], a1_unit[0]]\n                        for i in range(dim):\n                            result[i] += ortho_comp[0]*o[i]\n                    elif dim == 3:\n                        # Create arbitrary orthonormal basis {a1_unit, u, v}\n                        # u = normalized cross product with z axis if not parallel\n                        z_axis = [0,0,1]\n                        cross = [a1_unit[1]*z_axis[2]-a1_unit[2]*z_axis[1],\n                                 a1_unit[2]*z_axis[0]-a1_unit[0]*z_axis[2],\n                                 a1_unit[0]*z_axis[1]-a1_unit[1]*z_axis[0]]\n                        norm_cross = math.sqrt(sum(x*x for x in cross))\n                        if norm_cross < 1e-6:\n                            # a1_unit parallel to z-axis, use x axis for u\n                            u = [1,0,0]\n                        else:\n                            u = [x / norm_cross for x in cross]\n                        # v = a1_unit cross u\n                        v = [a1_unit[1]*u[2] - a1_unit[2]*u[1],\n                             a1_unit[2]*u[0] - a1_unit[0]*u[2],\n                             a1_unit[0]*u[1] - a1_unit[1]*u[0]]\n                        for i in range(dim):\n                            result[i] += ortho_comp[0]*u[i] + ortho_comp[1]*v[i]\n                    # else dim >3: just ignore orthogonal components (rare)\n                    if all(0 <= result[d] <= bounds[d] for d in range(dim)) and not self._is_in_obstacle(tuple(result), obstacles, is_3d):\n                        return tuple(result)\n\n        def nearest(pt):\n            return min(tree, key=lambda n:n.cost + dist(n.position, pt))\n\n        def near(pt, n):\n            # adaptive radius heuristic for RRT*\n            gamma_rrt = 2.0 * (1 + 1/dim)**(1/dim) * ( ( (math.factorial(dim) * (4/3) )) )**(1/dim)\n            r = min(self.step_size*5, gamma_rrt*(math.log(n)/n)**(1.0/dim))\n            return [node for node in tree if dist(node.position, pt) <= r]\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * self.step_size / d for i in range(dim))\n\n        def collision_free_edge(p1, p2):\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d)\n\n        def prune_outside_ellipsoid():\n            nonlocal tree, nodes, edges, best_cost\n            if best_cost == float('inf'):\n                return\n            new_tree = []\n            nodes_set = set(tree)\n            allowed_nodes = []\n            # mark reachable from root prune nodes outside ellipsoid\n            for n in tree:\n                if in_ellipsoid(n.position, best_cost, c_min, start, goal):\n                    allowed_nodes.append(n)\n            # rebuild tree with allowed nodes and parents therein\n            allowed_set = set(allowed_nodes)\n            # forcibly remove nodes whose parents not in allowed nodes\n            queue = []\n            new_tree = []\n            for n in allowed_nodes:\n                p = n.parent\n                while p is not None and p not in allowed_set:\n                    p = p.parent\n                if p in allowed_set or p is None:\n                    new_tree.append(n)\n            tree.clear()\n            tree.extend(new_tree)\n\n        def shortcut_path(path):\n            # attempt simple path shortcutting to remove unnecessary bends\n            if len(path) < 3:\n                return path\n            shortened = [path[0]]\n            i = 0\n            while i < len(path) - 1:\n                j = len(path) - 1\n                while j > i + 1:\n                    if collision_free_edge(shortened[-1], path[j]):\n                        shortened.append(path[j])\n                        i = j\n                        break\n                    j -= 1\n                else:\n                    shortened.append(path[i+1])\n                    i += 1\n            return shortened\n\n        n = 1\n        for _ in range(self.max_iter):\n            x_rand = sample()\n            x_nearest = min(tree, key=lambda n_: dist(n_.position, x_rand))\n            x_new_pos = steer(x_nearest.position, x_rand)\n            if self._is_in_obstacle(x_new_pos, obstacles, is_3d):\n                continue\n            if not collision_free_edge(x_nearest.position, x_new_pos):\n                continue\n            near_nodes = near(x_new_pos, len(tree))\n\n            # Find best parent among near nodes for min cost\n            min_cost = x_nearest.cost + dist(x_nearest.position, x_new_pos)\n            best_parent = x_nearest\n            for node in near_nodes:\n                edge_cost = dist(node.position, x_new_pos)\n                c = node.cost + edge_cost\n                if c + self.improve_tol < min_cost and collision_free_edge(node.position, x_new_pos):\n                    min_cost = c\n                    best_parent = node\n\n            x_new = Node(x_new_pos)\n            best_parent.add_child(x_new)\n            x_new.cost = min_cost\n            tree.append(x_new)\n            nodes.append(x_new)\n            edges.append((best_parent, x_new))\n\n            # Rewire neighbors\n            for node in near_nodes:\n                if node is x_new or node is best_parent:\n                    continue\n                potential_cost = x_new.cost + dist(x_new.position, node.position)\n                if potential_cost + self.improve_tol < node.cost and collision_free_edge(x_new.position, node.position):\n                    prev_parent = node.parent\n                    if prev_parent:\n                        if (prev_parent, node) in edges:\n                            edges.remove((prev_parent, node))\n                        if node in prev_parent.children:\n                            prev_parent.children.remove(node)\n                    x_new.add_child(node)\n                    node.cost = potential_cost\n                    edges.append((x_new, node))\n\n            # Check connection direct to goal\n            if dist(x_new.position, goal) <= self.step_size and collision_free_edge(x_new.position, goal):\n                potential_cost = x_new.cost + dist(x_new.position, goal)\n                if potential_cost + self.improve_tol < best_cost:\n                    goal_node = Node(goal)\n                    x_new.add_child(goal_node)\n                    goal_node.cost = potential_cost\n                    tree.append(goal_node)\n                    nodes.append(goal_node)\n                    edges.append((x_new, goal_node))\n                    best_cost = potential_cost\n                    best_goal_node = goal_node\n                    found_solution = True\n                    no_improve = 0\n                    post_opt_count = 0\n                else:\n                    no_improve += 1\n                    post_opt_count += 1\n            else:\n                if found_solution:\n                    no_improve += 1\n                    post_opt_count += 1\n\n            # Periodically prune tree outside ellipsoid for best_cost\n            if found_solution and (_ % 250) == 0:\n                prune_outside_ellipsoid()\n\n            n += 1\n            if found_solution and (post_opt_count >= self.post_opt_iters or no_improve >= self.max_no_improve):\n                break\n\n        if found_solution and best_goal_node:\n            extracted_path = best_goal_node.path_from_root()\n            # Smooth path shortcutting to improve length & smoothness:\n            extracted_path = shortcut_path(extracted_path)\n        else:\n            extracted_path = []\n\n        return PlannerResult(True if found_solution else False, extracted_path, nodes, edges)\n\n    def _distance(self, a, b):\n        import math\n        return math.dist(a, b)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * i / steps for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 18.79497,
          "time_improvement": -121.0,
          "length_improvement": 13.0,
          "smoothness_improvement": 1893.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.05898122787475586,
                    "num_nodes_avg": 510.2,
                    "path_length_avg": 172.7134244349467,
                    "smoothness_avg": 0.06581379164236674,
                    "success_improvement": 0.0,
                    "time_improvement": -124.66627252359639,
                    "length_improvement": 5.3330352478584375,
                    "smoothness_improvement": 930.1287561390558,
                    "objective_score": -29.549416827668576
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.2983426332473755,
                    "num_nodes_avg": 1301.1,
                    "path_length_avg": 243.83195303851275,
                    "smoothness_avg": 0.11834135251907138,
                    "success_improvement": 0.0,
                    "time_improvement": -80.6603936345688,
                    "length_improvement": 18.601875762117196,
                    "smoothness_improvement": 2945.008238146587,
                    "objective_score": 1.6880485576326105
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.1290714979171753,
                    "num_nodes_avg": 611.6,
                    "path_length_avg": 126.843073163169,
                    "smoothness_avg": 0.14976835208119793,
                    "success_improvement": 0.0,
                    "time_improvement": -156.6762408872638,
                    "length_improvement": 15.756870423099286,
                    "smoothness_improvement": 1805.0423837230148,
                    "objective_score": -28.523538093704484
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e2",
          "algorithm_description": "A hybrid bidirectional planner combining fast incremental exploration and post-path optimization with rewiring and informed sampling to improve efficiency, path length, success rate, and smoothness. It grows start and goal trees with RRT* style sampling, parent selection, and rewiring, attempting connection at each step. Once a valid path is found, informed sampling inside the ellipsoid between start and goal focuses search to optimize the path further. The final returned path is shortcut-smoothed to reduce unnecessary waypoints and sharp turns.",
          "planning_mechanism": "The planner alternates growing start and goal trees with RRT* expansions including best-parent selection and rewiring to improve path quality. Random samples are drawn uniformly initially, then inside an ellipsoid after first solution for focused optimization. Each extension tries to connect the two trees, and after the first connection the planner continues optimizing until iteration or improvement limits. Optionally, the output path is shortcut-smoothed to reduce length and increase smoothness.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True  # reserved for future collision checking updates\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        path.reverse()\n        return path\nclass Planner:\n    def __init__(self,\n                 max_iter=6000,\n                 step_size=4.0,\n                 neighbor_radius=None,\n                 post_opt_iters=600,\n                 max_no_improve=150,\n                 improve_tol=1e-5,\n                 time_limit_sec=25.0,\n                 shortcutting_trials=150):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.post_opt_iters = post_opt_iters\n        self.max_no_improve = max_no_improve\n        self.improve_tol = improve_tol\n        self.time_limit_sec = time_limit_sec\n        self.shortcutting_trials = shortcutting_trials\n        # neighbor radius factor for RRT*\n        self.gamma_rrt_star = 50.0\n        self.neighbor_radius = neighbor_radius  # if None will compute dynamically\n\n    def plan(self, map):\n        bounds = map.size\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        obstacles = map.obstacles\n\n        start_pos = map.start\n        goal_pos = map.goal\n\n        # Initialize data\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        best_cost = float('inf')\n        best_path = []\n        c_min = math.dist(start_pos, goal_pos)\n\n        found_solution = False\n        post_iter = 0\n        no_improve_count = 0\n\n        start_time = time.time()\n\n        def within_bounds(p):\n            return all(0.0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_p, to_p):\n            d = dist(from_p, to_p)\n            if d <= self.step_size:\n                return to_p\n            r = self.step_size / d\n            return tuple(from_p[i] + (to_p[i] - from_p[i]) * r for i in range(dim))\n\n        def neighbor_radius_fn(n_nodes):\n            if self.neighbor_radius is not None:\n                return self.neighbor_radius\n            if n_nodes < 2:\n                return self.step_size * 2.0\n            r_theory = self.gamma_rrt_star * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            maxr = max(bounds) * 0.25\n            return max(self.step_size * 2.0, min(r_theory, maxr))\n\n        def nearest(tree, pt):\n            mn = None\n            md = float(\"inf\")\n            for n in tree:\n                d = dist(n.position, pt)\n                if d < md:\n                    md = d\n                    mn = n\n            return mn\n\n        def near_nodes(tree, pos, radius):\n            result = []\n            r_sq = radius * radius\n            for n in tree:\n                d_sq = sum((n.position[i] - pos[i]) ** 2 for i in range(dim))\n                if d_sq <= r_sq:\n                    result.append(n)\n            return result\n\n        def edge_collision_free(p1, p2):\n            distance = dist(p1, p2)\n            steps = max(2, int(distance / 1.0))\n            for i in range(steps + 1):\n                ip = tuple(p1[d] + (p2[d] - p1[d]) * (i / steps) for d in range(dim))\n                if self._is_in_obstacle(ip, obstacles, is_3d):\n                    return False\n            return True\n\n        def collision_free(p):\n            return not self._is_in_obstacle(p, obstacles, is_3d)\n\n        def add_node_rrtstar(tree, pos):\n            r = neighbor_radius_fn(len(tree))\n            neigh = near_nodes(tree, pos, r)\n\n            candidate_parents = [n for n in neigh if edge_collision_free(n.position, pos)]\n            if not candidate_parents:\n                # fallback to nearest if no collision-free neighbors found\n                nnear = nearest(tree, pos)\n                if edge_collision_free(nnear.position, pos):\n                    parent = nnear\n                else:\n                    return None, []\n            else:\n                parent = min(candidate_parents, key=lambda n: n.cost + dist(n.position, pos))\n            new_cost = parent.cost + dist(parent.position, pos)\n            new_node = Node(pos, parent=None, cost=new_cost)\n            parent.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((parent, new_node))\n            return new_node, neigh\n\n        def rewire(node, neighbors):\n            for nb in neighbors:\n                if nb is node:\n                    continue\n                if not edge_collision_free(node.position, nb.position):\n                    continue\n                new_cost = node.cost + dist(node.position, nb.position)\n                if new_cost + 1e-12 < nb.cost:\n                    # reconnect neighbor via node\n                    if nb.parent:\n                        try:\n                            edges.remove((nb.parent, nb))\n                        except ValueError:\n                            pass\n                        if nb in nb.parent.children:\n                            nb.parent.children.remove(nb)\n                    node.add_child(nb)\n                    nb.cost = new_cost\n                    edges.append((node, nb))\n\n        def stitch_paths(node_start, node_goal):\n            path_start = node_start.path_from_root()\n            path_goal = node_goal.path_from_root()\n            # remove duplicated meeting node if any\n            if path_start and path_goal and path_start[-1] == path_goal[-1]:\n                merged = path_start + path_goal[-2::-1]\n            else:\n                merged = path_start + path_goal[::-1]\n            return merged\n\n        def path_cost(path):\n            c = 0.0\n            for i in range(len(path) - 1):\n                c += dist(path[i], path[i+1])\n            return c\n\n        def informed_sample(start, goal, c_best, c_min):\n            if c_best == float(\"inf\") or c_min < 1e-12:\n                return tuple(random.uniform(0.0, bounds[d]) for d in range(dim))\n            r1 = c_best / 2.0\n            r_other_sq = max(c_best * c_best - c_min * c_min, 0.0)\n            r_other = math.sqrt(r_other_sq) / 2.0\n            center = tuple((start[d] + goal[d]) / 2.0 for d in range(dim))\n            a1 = tuple((goal[d] - start[d]) / c_min for d in range(dim))\n\n            def sample_unit_ball(k):\n                while True:\n                    v = [random.gauss(0, 1) for _ in range(k)]\n                    norm_v = math.sqrt(sum(x * x for x in v))\n                    if norm_v > 1e-12:\n                        v = [x / norm_v for x in v]\n                        r = random.random() ** (1.0 / k)\n                        return tuple(v[i] * r for i in range(k))\n\n            u = sample_unit_ball(dim)\n\n            if dim == 2:\n                a2 = (-a1[1], a1[0])\n                basis = (a1, a2)\n                radii = (r1, r_other)\n            else:\n                ref = (1.0, 0.0, 0.0) if abs(a1[0]) < 0.9 else (0.0, 1.0, 0.0)\n                b2 = self._normalize(self._cross(a1, ref))\n                if self._norm(b2) < 1e-12:\n                    ref = (0.0, 0.0, 1.0)\n                    b2 = self._normalize(self._cross(a1, ref))\n                b3 = self._cross(a1, b2)\n                basis = (a1, b2, b3)\n                radii = (r1, r_other, r_other)\n\n            sample = []\n            for d in range(dim):\n                val = center[d]\n                for i in range(dim):\n                    val += basis[i][d] * radii[i] * u[i]\n                # Clamp inside bounds\n                val = max(0.0, min(bounds[d], val))\n                sample.append(val)\n            return tuple(sample)\n\n        def smooth_path(path, max_trials):\n            if len(path) < 3:\n                return path\n            new_path = path[:]\n            for _ in range(max_trials):\n                if len(new_path) < 3:\n                    break\n                i = random.randint(0, len(new_path) - 3)\n                j = random.randint(i+2, len(new_path) - 1)\n                if edge_collision_free(new_path[i], new_path[j]):\n                    # remove intermediate points between i and j\n                    new_path = new_path[:i+1] + new_path[j:]\n            return new_path\n\n        def try_connect_trees(new_node, other_tree, other_tree_nodes):\n            nearest_other = nearest(other_tree, new_node.position)\n            if dist(nearest_other.position, new_node.position) <= self.step_size:\n                if edge_collision_free(new_node.position, nearest_other.position):\n                    # Connect by creating new node optionally in other_tree for symmetry\n                    return new_node, nearest_other\n            # Otherwise try incremental steer connection on other tree side\n            curr = nearest_other\n            while True:\n                step_pos = steer(curr.position, new_node.position)\n                if not within_bounds(step_pos) or not collision_free(step_pos):\n                    break\n                if not edge_collision_free(curr.position, step_pos):\n                    break\n                new_other_node, _ = add_node_rrtstar(other_tree, step_pos)\n                if new_other_node is None:\n                    break\n                rewire(new_other_node, near_nodes(other_tree, step_pos, neighbor_radius_fn(len(other_tree))))\n                curr = new_other_node\n                if dist(curr.position, new_node.position) <= self.step_size:\n                    if edge_collision_free(curr.position, new_node.position):\n                        # Create virtual connection node aligned with new_node\n                        return new_node, curr\n            return None, None\n\n        iteration = 0\n        while iteration < self.max_iter:\n            if time.time() - start_time > self.time_limit_sec:\n                break\n            side_toggle = iteration % 2\n            if side_toggle == 0:\n                grow_tree, other_tree = start_tree, goal_tree\n                grow_is_start = True\n            else:\n                grow_tree, other_tree = goal_tree, start_tree\n                grow_is_start = False\n\n            # Sample either uniformly or informed if solution known\n            sample = informed_sample(start_pos, goal_pos, best_cost, c_min) if found_solution else \\\n                     tuple(random.uniform(0.0, bounds[d]) for d in range(dim))\n\n            if not within_bounds(sample) or not collision_free(sample):\n                if found_solution:\n                    post_iter += 1\n                    no_improve_count += 1\n                    if post_iter >= self.post_opt_iters or no_improve_count >= self.max_no_improve:\n                        break\n                iteration += 1\n                continue\n\n            nearest_node = nearest(grow_tree, sample)\n            new_pos = steer(nearest_node.position, sample)\n            if not within_bounds(new_pos) or not collision_free(new_pos):\n                if found_solution:\n                    post_iter += 1\n                    no_improve_count += 1\n                    if post_iter >= self.post_opt_iters or no_improve_count >= self.max_no_improve:\n                        break\n                iteration += 1\n                continue\n            if not edge_collision_free(nearest_node.position, new_pos):\n                if found_solution:\n                    post_iter += 1\n                    no_improve_count += 1\n                    if post_iter >= self.post_opt_iters or no_improve_count >= self.max_no_improve:\n                        break\n                iteration += 1\n                continue\n\n            new_node, neighbors = add_node_rrtstar(grow_tree, new_pos)\n            if new_node is None:\n                if found_solution:\n                    post_iter += 1\n                    no_improve_count += 1\n                    if post_iter >= self.post_opt_iters or no_improve_count >= self.max_no_improve:\n                        break\n                iteration += 1\n                continue\n\n            rewire(new_node, neighbors)\n\n            # Attempt to connect trees via new_node\n            n1, n2 = try_connect_trees(new_node, other_tree, nodes)\n            if n1 and n2:\n                candidate_path = stitch_paths(n1, n2)\n                candidate_cost = path_cost(candidate_path)\n\n                if candidate_cost + self.improve_tol < best_cost:\n                    best_cost = candidate_cost\n                    best_path = candidate_path\n                    found_solution = True\n                    no_improve_count = 0\n                    post_iter = 0\n                else:\n                    if found_solution:\n                        no_improve_count += 1\n                        post_iter += 1\n\n                if found_solution and (post_iter >= self.post_opt_iters or no_improve_count >= self.max_no_improve):\n                    break\n            else:\n                if found_solution:\n                    post_iter += 1\n                    no_improve_count += 1\n                    if post_iter >= self.post_opt_iters or no_improve_count >= self.max_no_improve:\n                        break\n\n            iteration += 1\n\n        if found_solution and best_path:\n            smooth = smooth_path(best_path, self.shortcutting_trials)\n        else:\n            smooth = []\n\n        return PlannerResult(\n            success=found_solution,\n            path=smooth if smooth else best_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    # ---------------- Collision Helpers ----------------\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    # ----------------------------------------------------------------\n    # Vector math utilities\n    # ----------------------------------------------------------------\n    def _cross(self, a, b):\n        ax, ay, az = a\n        bx, by, bz = b\n        return (ay * bz - az * by, az * bx - ax * bz, ax * by - ay * bx)\n\n    def _norm(self, v):\n        return math.sqrt(sum(x * x for x in v))\n\n    def _normalize(self, v):\n        n = self._norm(v)\n        if n < 1e-12:\n            return v\n        return tuple(x / n for x in v)",
          "objective": 30.8005,
          "time_improvement": -164.0,
          "length_improvement": 20.0,
          "smoothness_improvement": 1288.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.0989145278930664,
                    "num_nodes_avg": 208.6,
                    "path_length_avg": 152.44922059390572,
                    "smoothness_avg": 0.04405342963083721,
                    "success_improvement": 0.0,
                    "time_improvement": -276.7767996854121,
                    "length_improvement": 16.440166479991422,
                    "smoothness_improvement": 589.5318372761939,
                    "objective_score": -70.2212808312478
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.12343411445617676,
                    "num_nodes_avg": 460.7,
                    "path_length_avg": 228.4633553814897,
                    "smoothness_avg": 0.08673156530289851,
                    "success_improvement": 0.0,
                    "time_improvement": 25.25488072937533,
                    "length_improvement": 23.7323560205877,
                    "smoothness_improvement": 2131.665645465001,
                    "objective_score": 32.474206058490225
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.17110490798950195,
                    "num_nodes_avg": 411.5,
                    "path_length_avg": 121.1728155761859,
                    "smoothness_avg": 0.09766590253227968,
                    "success_improvement": 0.0,
                    "time_improvement": -240.2653977742545,
                    "length_improvement": 19.52278552372241,
                    "smoothness_improvement": 1142.3030712635552,
                    "objective_score": -54.65443266172513
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "initial",
          "algorithm_description": "This algorithm with post-optimization limits: a two-tree, asymptotically optimal planner that, after finding a first feasible path, continues improving within the start\u2013goal ellipsoid for only a user-defined number of extra iterations (or until no improvement is observed), then stops.",
          "planning_mechanism": "Mechanism: Alternate expanding start/goal trees with RRT* best-parent selection and local rewiring; greedily connect the opposite tree; upon first connection, switch to informed (ellipsoidal) sampling and keep optimizing for N additional iterations (or until M consecutive non-improvements), always enforcing node and edge collision checks, bounds, and a strict 30 s time limit that returns the best path so far.",
          "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        n = self\n        while n:\n            path.append(n.position)\n            n = n.parent\n        return path[::-1]\n\n\nclass Planner:\n    def __init__(\n        self,\n        max_iter: int = 5000,\n        step_size: float = 5.0,\n        neighbor_radius: float = 25.0,\n        post_opt_iters: int = 400,    # extra iterations after first solution\n        max_no_improve: int = 150,    # stop early if this many consecutive iterations show no improvement\n        improve_tol: float = 1e-6,    # minimal cost drop to count as improvement\n        time_limit_sec: float = 30.0  # hard wall time limit\n    ):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.neighbor_radius = neighbor_radius\n        self.post_opt_iters = post_opt_iters\n        self.max_no_improve = max_no_improve\n        self.improve_tol = improve_tol\n        self.time_limit_sec = time_limit_sec\n\n    def plan(self, map: Map) -> PlannerResult:\n        bounds = map.size                  # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_position = map.start         # Tuple[float, ...]\n        goal_position = map.goal           # Tuple[float, ...]\n        obstacles = map.obstacles          # Rectangular blocks / boxes\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        # Core data\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        # Initialize two trees\n        start_root = Node(start_position, cost=0.0)\n        goal_root  = Node(goal_position,  cost=0.0)\n        tree_a: List[Node] = [start_root]\n        tree_b: List[Node] = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        # RRT* neighborhood (practical clamp)\n        gamma_rrt_star = 60.0\n        max_radius = max(bounds) * 0.30\n        min_radius = max(10.0, self.step_size * 2.0)\n\n        # Best solution & informed sampling params\n        best_cost = float(\"inf\")\n        best_path: List[Tuple[float, ...]] = []\n        c_min = math.dist(start_position, goal_position)\n\n        # Post-optimization control\n        found_first_solution = False\n        post_iter_count = 0\n        no_improve_streak = 0\n\n        # Time guard\n        start_time = time.time()\n\n        # ---------- Helpers ----------\n        def within_bounds(p):\n            return all(0.0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def nearest(tree, pt):\n            return min(tree, key=lambda n: math.dist(n.position, pt))\n\n        def steer(from_pos, to_pos):\n            d = math.dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            r = self.step_size / d\n            return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * r for i in range(dim))\n\n        def neighbor_radius_fn(n_nodes: int) -> float:\n            if n_nodes < 2:\n                return min_radius\n            r_theory = gamma_rrt_star * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            return max(min_radius, min(max_radius, r_theory))\n\n        def near_nodes(tree, pos, radius):\n            return [nd for nd in tree if math.dist(nd.position, pos) <= radius]\n\n        def add_with_best_parent(tree, new_pos):\n            \"\"\"Insert new_pos using RRT* best-parent selection; return (new_node, neighbors) or (None, []).\"\"\"\n            r = neighbor_radius_fn(len(tree))\n            neigh = near_nodes(tree, new_pos, r)\n            parent_candidates = neigh if neigh else [nearest(tree, new_pos)]\n            parent_candidates = [nb for nb in parent_candidates\n                                 if not self._is_edge_in_obstacle(nb.position, new_pos, obstacles, is_3d)]\n            if not parent_candidates:\n                return None, []\n            parent = min(parent_candidates, key=lambda nb: nb.cost + math.dist(nb.position, new_pos))\n            new_node = Node(new_pos, parent=None, cost=parent.cost + math.dist(parent.position, new_pos))\n            parent.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((parent, new_node))\n            return new_node, neigh\n\n        def rewire_from(pivot: Node, neigh: List[Node]):\n            for nb in neigh:\n                if nb is pivot:\n                    continue\n                if self._is_edge_in_obstacle(pivot.position, nb.position, obstacles, is_3d):\n                    continue\n                new_c = pivot.cost + math.dist(pivot.position, nb.position)\n                if new_c + 1e-12 < nb.cost:\n                    if nb.parent is not None:\n                        try:\n                            edges.remove((nb.parent, nb))\n                        except ValueError:\n                            pass\n                        if nb in nb.parent.children:\n                            nb.parent.children.remove(nb)\n                    pivot.add_child(nb)\n                    nb.cost = new_c\n                    edges.append((pivot, nb))\n\n        def stitch_paths(meet_a: Node, meet_b: Node, a_is_start_side: bool) -> List[Tuple[float, ...]]:\n            \"\"\"Create full path from start to goal using meeting nodes from both trees.\"\"\"\n            path_a = meet_a.path_from_root()\n            path_b = meet_b.path_from_root()\n            if path_a and path_b and path_a[-1] == path_b[-1]:\n                merged = path_a + path_b[-2::-1]\n            else:\n                merged = path_a + path_b[::-1]\n            return merged if a_is_start_side else merged[::-1]\n\n        def path_cost(path):\n            return sum(math.dist(path[i], path[i+1]) for i in range(len(path)-1))\n\n        # ---------- Main loop ----------\n        for it in range(self.max_iter):\n            # Hard time limit\n            if time.time() - start_time > self.time_limit_sec:\n                return PlannerResult(\n                    success=(len(best_path) > 0),\n                    path=best_path if best_path else [],\n                    nodes=nodes,\n                    edges=edges\n                )\n\n            # Choose expansion/connection sides\n            if it % 2 == 0:\n                grow_tree, other_tree = tree_a, tree_b\n                a_is_start_side = True\n            else:\n                grow_tree, other_tree = tree_b, tree_a\n                a_is_start_side = False\n\n            # Informed sampling (uniform before first solution; ellipsoid after)\n            sample = self._sample_informed(start_position, goal_position, best_cost, c_min, bounds)\n\n            # Extend grow_tree toward sample\n            a_near = nearest(grow_tree, sample)\n            a_new_pos = steer(a_near.position, sample)\n\n            if (not within_bounds(a_new_pos)) or self._is_in_obstacle(a_new_pos, obstacles, is_3d):\n                # count post-optimization iterations if already in post phase\n                if found_first_solution:\n                    post_iter_count += 1\n                    no_improve_streak += 1\n                    if post_iter_count >= self.post_opt_iters or no_improve_streak >= self.max_no_improve:\n                        break\n                continue\n            if self._is_edge_in_obstacle(a_near.position, a_new_pos, obstacles, is_3d):\n                if found_first_solution:\n                    post_iter_count += 1\n                    no_improve_streak += 1\n                    if post_iter_count >= self.post_opt_iters or no_improve_streak >= self.max_no_improve:\n                        break\n                continue\n\n            a_new, a_neigh = add_with_best_parent(grow_tree, a_new_pos)\n            if a_new is None:\n                if found_first_solution:\n                    post_iter_count += 1\n                    no_improve_streak += 1\n                    if post_iter_count >= self.post_opt_iters or no_improve_streak >= self.max_no_improve:\n                        break\n                continue\n            rewire_from(a_new, a_neigh)\n\n            # Greedy connect other_tree toward a_new, with local rewiring each step\n            b_near = nearest(other_tree, a_new.position)\n            current = b_near\n            connected_b = None\n\n            while True:\n                step_pos = steer(current.position, a_new.position)\n                if (not within_bounds(step_pos)) or self._is_in_obstacle(step_pos, obstacles, is_3d):\n                    break\n                if self._is_edge_in_obstacle(current.position, step_pos, obstacles, is_3d):\n                    break\n\n                b_new, b_neigh = add_with_best_parent(other_tree, step_pos)\n                if b_new is None:\n                    break\n                rewire_from(b_new, b_neigh)\n                current = b_new\n\n                # Try a final short bridge\n                if math.dist(current.position, a_new.position) <= self.step_size:\n                    if not self._is_edge_in_obstacle(current.position, a_new.position, obstacles, is_3d) and a_new.valid:\n                        final_b = Node(\n                            a_new.position,\n                            parent=None,\n                            cost=current.cost + math.dist(current.position, a_new.position)\n                        )\n                        current.add_child(final_b)\n                        other_tree.append(final_b)\n                        nodes.append(final_b)\n                        edges.append((current, final_b))\n                        connected_b = final_b\n                    break\n\n            # If a connection was made, evaluate and manage post-optimization counters\n            if connected_b is not None:\n                candidate_path = stitch_paths(a_new, connected_b, a_is_start_side)\n                cand_cost = path_cost(candidate_path)\n\n                if cand_cost + self.improve_tol < best_cost:\n                    best_cost = cand_cost\n                    best_path = candidate_path\n                    success_state = True\n                    no_improve_streak = 0\n                else:\n                    no_improve_streak += 1\n\n                if not found_first_solution:\n                    found_first_solution = True\n                    post_iter_count = 0\n                else:\n                    post_iter_count += 1\n\n                if post_iter_count >= self.post_opt_iters or no_improve_streak >= self.max_no_improve:\n                    break\n            else:\n                # No successful connection this iteration\n                if found_first_solution:\n                    post_iter_count += 1\n                    no_improve_streak += 1\n                    if post_iter_count >= self.post_opt_iters or no_improve_streak >= self.max_no_improve:\n                        break\n\n        extracted_path = best_path if success_state else []\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    # ---------------- Informed Sampling ----------------\n    def _sample_informed(self, start, goal, c_best, c_min, bounds):\n        \"\"\"Uniform in bounds if no solution; otherwise sample within the start\u2013goal ellipsoid.\"\"\"\n        dim = len(bounds)\n        if c_best == float(\"inf\") or c_min <= 1e-12:\n            return tuple(random.uniform(0.0, bounds[d]) for d in range(dim))\n\n        # Ellipsoid radii\n        r1 = c_best / 2.0\n        r_other_sq = max(c_best * c_best - c_min * c_min, 0.0)\n        r_other = math.sqrt(r_other_sq) / 2.0\n\n        # Center and first axis (unit)\n        center = tuple((s + g) / 2.0 for s, g in zip(start, goal))\n        a1 = tuple((goal[d] - start[d]) / c_min for d in range(dim))\n\n        # Orthonormal basis aligned with a1\n        if dim == 2:\n            a2 = (-a1[1], a1[0])\n            basis = (a1, a2)\n            radii = (r1, r_other)\n        else:  # 3D\n            ref = (1.0, 0.0, 0.0) if abs(a1[0]) < 0.9 else (0.0, 1.0, 0.0)\n            b2 = self._normalize(self._cross(a1, ref))\n            if self._norm(b2) < 1e-12:\n                ref = (0.0, 0.0, 1.0)\n                b2 = self._normalize(self._cross(a1, ref))\n            b3 = self._cross(a1, b2)\n            basis = (a1, b2, b3)\n            radii = (r1, r_other, r_other)\n\n        u = self._sample_unit_ball(dim)\n\n        mapped = []\n        for d in range(dim):\n            val = center[d]\n            for i in range(dim):\n                val += basis[i][d] * radii[i] * u[i]\n            mapped.append(val)\n\n        mapped = tuple(min(max(mapped[d], 0.0), bounds[d]) for d in range(dim))\n        return mapped\n\n    def _sample_unit_ball(self, dim):\n        while True:\n            v = [random.gauss(0.0, 1.0) for _ in range(dim)]\n            n = math.sqrt(sum(x * x for x in v))\n            if n > 1e-12:\n                v = [x / n for x in v]\n                r = random.random() ** (1.0 / dim)\n                return tuple(v[i] * r for i in range(dim))\n\n    def _cross(self, a, b):\n        ax, ay, az = a\n        bx, by, bz = b\n        return (ay * bz - az * by, az * bx - ax * bz, ax * by - ay * bx)\n\n    def _norm(self, v):\n        return math.sqrt(sum(x * x for x in v))\n\n    def _normalize(self, v):\n        n = self._norm(v)\n        if n < 1e-12:\n            return v\n        return tuple(x / n for x in v)\n\n    # ---------------- Collision Utilities ----------------\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(\n                from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps)\n                for d in range(len(from_pos))\n            )\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n",
          "objective": 65.81518267889066,
          "time_improvement": -262.0,
          "length_improvement": 18.0,
          "smoothness_improvement": 428.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.16696455478668212,
                    "num_nodes_avg": 376.2,
                    "path_length_avg": 152.49852728791282,
                    "smoothness_avg": 0.035487538369853605,
                    "success_improvement": 0.0,
                    "time_improvement": -535.9871694624487,
                    "length_improvement": 16.413140699691567,
                    "smoothness_improvement": 455.45703791120593,
                    "objective_score": -148.67098122936363
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.09553766250610352,
                    "num_nodes_avg": 494.8,
                    "path_length_avg": 252.13389941176212,
                    "smoothness_avg": 0.017900451857510786,
                    "success_improvement": 0.0,
                    "time_improvement": 42.14748483175064,
                    "length_improvement": 15.830447104449604,
                    "smoothness_improvement": 360.5915194680795,
                    "objective_score": 23.945471309535353
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.19666085243225098,
                    "num_nodes_avg": 434.9,
                    "path_length_avg": 119.7891630713444,
                    "smoothness_avg": 0.04466973058732174,
                    "success_improvement": 0.0,
                    "time_improvement": -291.0868715910212,
                    "length_improvement": 20.441741634986126,
                    "smoothness_improvement": 468.1956758941966,
                    "objective_score": -72.7200381168437
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "initial",
          "algorithm_description": "This algorithm with post-optimization: a bidirectional RRT*-Connect that, after finding a first feasible \u201cbest shot\u201d path, keeps optimizing for only a user-defined number of extra iterations (or until no further improvements occur), then terminates\u2014while maintaining strict collision checks and a 30 s time cap.",
          "planning_mechanism": "Mechanism: Alternate tree growth with RRT* best-parent selection and local rewiring; greedily connect the opposite tree; upon the first connection, record the best path and continue only N additional iterations (or until M consecutive non-improving attempts), always staying within bounds and validating node and edge collisions; stop early on time limit and return the best path so far.",
          "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from its tree root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        n = self\n        while n:\n            path.append(n.position)\n            n = n.parent\n        return path[::-1]\n\n\nclass Planner:\n    def __init__(\n        self,\n        max_iter: int = 5000,\n        step_size: float = 5.0,\n        post_opt_iters: int = 400,   # extra iterations after first solution\n        max_no_improve: int = 150,   # early stop if no improvement for this many iterations\n        improve_tol: float = 1e-6,   # minimal cost drop to count as improvement\n        goal_sample_rate: float = 0.05,   # mild goal bias\n        bridge_bias_rate: float = 0.15,   # bias toward the opposite tree root\n        neighbor_gamma: float = 60.0,     # RRT* radius coefficient\n        time_limit_sec: float = 30.0      # hard wall time limit\n    ):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.post_opt_iters = post_opt_iters\n        self.max_no_improve = max_no_improve\n        self.improve_tol = improve_tol\n        self.goal_sample_rate = goal_sample_rate\n        self.bridge_bias_rate = bridge_bias_rate\n        self.neighbor_gamma = neighbor_gamma\n        self.time_limit_sec = time_limit_sec\n\n    def plan(self, map: Map) -> PlannerResult:\n        bounds = map.size                  # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_position = map.start         # Tuple[float, ...]\n        goal_position = map.goal           # Tuple[float, ...]\n        obstacles = map.obstacles          # Rectangular blocks: 2D=(x,y,w,h), 3D=(x,y,z,w,h,d)\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        # Core data\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        # Initialize bidirectional trees\n        start_root = Node(start_position, cost=0.0)\n        goal_root  = Node(goal_position,  cost=0.0)\n        tree_start: List[Node] = [start_root]\n        tree_goal:  List[Node] = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        # Practical RRT* neighborhood clamps\n        max_radius = max(bounds) * 0.30\n        min_radius = max(10.0, self.step_size * 2.0)\n\n        # Best solution tracking + post-optimization control\n        best_cost = float(\"inf\")\n        best_path: List[Tuple[float, ...]] = []\n        found_first_solution = False\n        post_iter_count = 0\n        no_improve_streak = 0\n\n        # Hard time limit\n        start_time = time.time()\n\n        # ----------------- Helper functions -----------------\n        def within_bounds(p):\n            return all(0.0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def clamp_bounds(p):\n            return tuple(min(max(p[d], 0.0), bounds[d]) for d in range(dim))\n\n        def steer(from_pos, to_pos):\n            d = math.dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return clamp_bounds(to_pos)\n            r = self.step_size / d\n            return clamp_bounds(tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * r for i in range(dim)))\n\n        def nearest(tree, pt):\n            return min(tree, key=lambda n: math.dist(n.position, pt))\n\n        def neighbor_radius(n_nodes: int) -> float:\n            if n_nodes < 2:\n                return min_radius\n            r_theory = self.neighbor_gamma * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            return max(min_radius, min(max_radius, r_theory))\n\n        def near_nodes(tree, pos, radius):\n            return [nd for nd in tree if math.dist(nd.position, pos) <= radius]\n\n        def uniform_sample():\n            return tuple(random.uniform(0.0, bounds[d]) for d in range(dim))\n\n        def sample_free(active_tree, other_tree):\n            # Goal bias toward the global goal or start depending on active tree\n            if random.random() < self.goal_sample_rate:\n                return goal_position if active_tree is tree_start else start_position\n            # Bridge bias: sample around the opposite root to encourage meeting\n            if random.random() < self.bridge_bias_rate:\n                anchor = other_tree[0].position\n                jitter = tuple(random.uniform(-2.0*self.step_size, 2.0*self.step_size) for _ in range(dim))\n                s = clamp_bounds(tuple(anchor[i] + jitter[i] for i in range(dim)))\n                return s if not self._is_in_obstacle(s, obstacles, is_3d) else uniform_sample()\n            # Uniform fallback\n            return uniform_sample()\n\n        def add_with_best_parent(tree, new_pos):\n            \"\"\"Insert new_pos with RRT* best-parent selection; returns (new_node, neighbors) or (None, []).\"\"\"\n            r = neighbor_radius(len(tree))\n            neigh = near_nodes(tree, new_pos, r)\n            if not neigh:\n                parent = nearest(tree, new_pos)\n                if self._is_edge_in_obstacle(parent.position, new_pos, obstacles, is_3d):\n                    return None, []\n            else:\n                candidates = [nb for nb in neigh if not self._is_edge_in_obstacle(nb.position, new_pos, obstacles, is_3d)]\n                if not candidates:\n                    return None, []\n                parent = min(candidates, key=lambda nb: nb.cost + math.dist(nb.position, new_pos))\n\n            new_node = Node(new_pos, parent=None, cost=parent.cost + math.dist(parent.position, new_pos))\n            parent.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((parent, new_node))\n            return new_node, neigh\n\n        def rewire_from(pivot: Node, neigh: List[Node]):\n            \"\"\"Local RRT* rewiring around pivot (edge and cost validated).\"\"\"\n            for nb in neigh:\n                if nb is pivot:\n                    continue\n                if self._is_edge_in_obstacle(pivot.position, nb.position, obstacles, is_3d):\n                    continue\n                new_c = pivot.cost + math.dist(pivot.position, nb.position)\n                if new_c + 1e-12 < nb.cost:\n                    if nb.parent is not None:\n                        try:\n                            edges.remove((nb.parent, nb))\n                        except ValueError:\n                            pass\n                        if nb in nb.parent.children:\n                            nb.parent.children.remove(nb)\n                    pivot.add_child(nb)\n                    nb.cost = new_c\n                    edges.append((pivot, nb))\n\n        def stitch_paths(a_node: Node, b_node: Node, a_is_start_side: bool) -> List[Tuple[float, ...]]:\n            \"\"\"Combine root\u2192a_node and root\u2192b_node into a single start\u2192goal path.\"\"\"\n            pa = a_node.path_from_root()\n            pb = b_node.path_from_root()\n            if pa and pb and pa[-1] == pb[-1]:\n                merged = pa + pb[-2::-1]\n            else:\n                merged = pa + pb[::-1]\n            return merged if a_is_start_side else merged[::-1]\n\n        def path_cost(path: List[Tuple[float, ...]]) -> float:\n            return sum(math.dist(path[i], path[i+1]) for i in range(len(path)-1))\n\n        # ----------------- Main loop -----------------\n        for it in range(self.max_iter):\n            # Enforce 30s time limit (return best so far)\n            if time.time() - start_time > self.time_limit_sec:\n                return PlannerResult(\n                    success=(len(best_path) > 0),\n                    path=best_path if best_path else [],\n                    nodes=nodes,\n                    edges=edges\n                )\n\n            # Alternate trees\n            if it % 2 == 0:\n                grow_tree, other_tree = tree_start, tree_goal\n                a_is_start_side = True\n            else:\n                grow_tree, other_tree = tree_goal, tree_start\n                a_is_start_side = False\n\n            # Sampling\n            s = sample_free(grow_tree, other_tree)\n\n            # Extend grow_tree toward sample\n            a_near = nearest(grow_tree, s)\n            a_new_pos = steer(a_near.position, s)\n\n            # Node & edge validity\n            if not within_bounds(a_new_pos) or self._is_in_obstacle(a_new_pos, obstacles, is_3d):\n                if found_first_solution:\n                    post_iter_count += 1\n                    no_improve_streak += 1\n                    if post_iter_count >= self.post_opt_iters or no_improve_streak >= self.max_no_improve:\n                        break\n                continue\n            if self._is_edge_in_obstacle(a_near.position, a_new_pos, obstacles, is_3d):\n                if found_first_solution:\n                    post_iter_count += 1\n                    no_improve_streak += 1\n                    if post_iter_count >= self.post_opt_iters or no_improve_streak >= self.max_no_improve:\n                        break\n                continue\n\n            a_new, a_neigh = add_with_best_parent(grow_tree, a_new_pos)\n            if a_new is None:\n                if found_first_solution:\n                    post_iter_count += 1\n                    no_improve_streak += 1\n                    if post_iter_count >= self.post_opt_iters or no_improve_streak >= self.max_no_improve:\n                        break\n                continue\n            rewire_from(a_new, a_neigh)\n\n            # Greedy connect the other tree toward a_new with stepwise rewiring\n            b_near = nearest(other_tree, a_new.position)\n            current = b_near\n            connected_b = None\n\n            while True:\n                step_pos = steer(current.position, a_new.position)\n                if not within_bounds(step_pos) or self._is_in_obstacle(step_pos, obstacles, is_3d):\n                    break\n                if self._is_edge_in_obstacle(current.position, step_pos, obstacles, is_3d):\n                    break\n\n                b_new, b_neigh = add_with_best_parent(other_tree, step_pos)\n                if b_new is None:\n                    break\n                rewire_from(b_new, b_neigh)\n                current = b_new\n\n                # Try to close the final short bridge exactly to a_new\n                if math.dist(current.position, a_new.position) <= self.step_size:\n                    if not self._is_edge_in_obstacle(current.position, a_new.position, obstacles, is_3d) and a_new.valid:\n                        final_b = Node(\n                            a_new.position,\n                            parent=None,\n                            cost=current.cost + math.dist(current.position, a_new.position)\n                        )\n                        current.add_child(final_b)\n                        other_tree.append(final_b)\n                        nodes.append(final_b)\n                        edges.append((current, final_b))\n                        connected_b = final_b\n                    break\n\n            # If a connection was made, evaluate candidate and manage post-optimization counters\n            if connected_b is not None:\n                candidate = stitch_paths(a_new, connected_b, a_is_start_side)\n                cand_cost = path_cost(candidate)\n\n                if cand_cost + self.improve_tol < best_cost:\n                    best_cost = cand_cost\n                    best_path = candidate\n                    success_state = True\n                    no_improve_streak = 0\n                else:\n                    no_improve_streak += 1\n\n                if not found_first_solution:\n                    found_first_solution = True\n                    post_iter_count = 0\n                else:\n                    post_iter_count += 1\n\n                if post_iter_count >= self.post_opt_iters or no_improve_streak >= self.max_no_improve:\n                    break\n            else:\n                # No successful connection this iteration\n                if found_first_solution:\n                    post_iter_count += 1\n                    no_improve_streak += 1\n                    if post_iter_count >= self.post_opt_iters or no_improve_streak >= self.max_no_improve:\n                        break\n\n        extracted_path = best_path if success_state else []\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    # ----------------- Collision utilities -----------------\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(\n                from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps)\n                for d in range(len(from_pos))\n            )\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n",
          "objective": 82.62479852047561,
          "time_improvement": -319.0,
          "length_improvement": 18.0,
          "smoothness_improvement": 387.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.1460770845413208,
                    "num_nodes_avg": 344.7,
                    "path_length_avg": 155.43548182876594,
                    "smoothness_avg": 0.03367728471153775,
                    "success_improvement": 0.0,
                    "time_improvement": -456.42439582135694,
                    "length_improvement": 14.803349376827102,
                    "smoothness_improvement": 427.12263712982536,
                    "objective_score": -125.90969593466171
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.15008063316345216,
                    "num_nodes_avg": 591.1,
                    "path_length_avg": 239.11131138332502,
                    "smoothness_avg": 0.01735302082153331,
                    "success_improvement": 0.0,
                    "time_improvement": 9.11916956316163,
                    "length_improvement": 20.17776182275505,
                    "smoothness_improvement": 346.5057246137415,
                    "objective_score": 16.574936585670226
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.3061445474624634,
                    "num_nodes_avg": 586.4,
                    "path_length_avg": 120.05507323742901,
                    "smoothness_avg": 0.03843279945019805,
                    "success_improvement": 0.0,
                    "time_improvement": -508.8101004392319,
                    "length_improvement": 20.26513676395415,
                    "smoothness_improvement": 388.8623721923524,
                    "objective_score": -138.5396362124353
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "initial",
          "algorithm_description": "This algorithm is an optimal variant of RRT that improves path quality over time by rewiring the tree to minimize path cost. It incrementally builds a space-filling tree from start toward the goal while performing local optimizations by choosing better parents and rewiring nearby nodes.",
          "planning_mechanism": "The planner samples a point, extends the nearest node toward it, finds nearby nodes within a radius, selects the node offering the lowest-cost path as the parent, and rewires suboptimal neighbors to the new node if a shorter path through it is possible and valid.",
          "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.children.remove(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 3.0, goal_sample_rate: float = 0.05, neighbor_radius: float = 10.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n\n    def plan(self, map) -> PlannerResult:\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        root = Node(start_position)\n        nodes.append(root)\n\n        for _ in range(self.max_iter):\n            # Goal biasing\n            if random.random() < self.goal_sample_rate:\n                sample = goal_position\n            else:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n\n            # Nearest node\n            nearest_node = min(nodes, key=lambda n: math.dist(n.position, sample))\n            direction = tuple(sample[d] - nearest_node.position[d] for d in range(len(bounds)))\n            dist_to_sample = math.dist(nearest_node.position, sample)\n            if dist_to_sample == 0:\n                continue\n            unit = tuple(d / dist_to_sample for d in direction)\n            new_position = tuple(nearest_node.position[d] + unit[d] * min(self.step_size, dist_to_sample) for d in range(len(bounds)))\n\n            if self._is_in_obstacle(new_position, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_position, obstacles, is_3d):\n                continue\n\n            # Nearby nodes for choosing best parent\n            new_node = Node(new_position)\n            near_nodes = [n for n in nodes if math.dist(n.position, new_position) <= self.neighbor_radius]\n\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_position)\n            best_parent = nearest_node\n\n            for near_node in near_nodes:\n                temp_cost = near_node.cost + math.dist(near_node.position, new_position)\n                if temp_cost < min_cost and not self._is_edge_in_obstacle(near_node.position, new_position, obstacles, is_3d):\n                    min_cost = temp_cost\n                    best_parent = near_node\n\n            new_node.update_parent(best_parent, min_cost)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewiring\n            for near_node in near_nodes:\n                if near_node == best_parent:\n                    continue\n                cost_through_new = new_node.cost + math.dist(near_node.position, new_position)\n                if cost_through_new < near_node.cost and not self._is_edge_in_obstacle(new_position, near_node.position, obstacles, is_3d):\n                    edges.remove((near_node.parent, near_node))\n                    near_node.update_parent(new_node, cost_through_new)\n                    edges.append((new_node, near_node))\n\n            # Check goal connection\n            if math.dist(new_position, goal_position) <= self.step_size:\n                if not self._is_edge_in_obstacle(new_position, goal_position, obstacles, is_3d) and not self._is_in_obstacle(goal_position, obstacles, is_3d):\n                    goal_node = Node(goal_position)\n                    goal_cost = new_node.cost + math.dist(new_position, goal_position)\n                    goal_node.update_parent(new_node, goal_cost)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    success_state = True\n                    break\n\n        if success_state:\n            path = []\n            node = nodes[-1]\n            while node:\n                path.append(node.position)\n                node = node.parent\n            extracted_path = path[::-1]\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n    ",
          "objective": 93.26951411575637,
          "time_improvement": -353.0,
          "length_improvement": 20.0,
          "smoothness_improvement": 166.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.05543720722198486,
                    "num_nodes_avg": 407.2,
                    "path_length_avg": 159.5448433070997,
                    "smoothness_avg": 0.014279977102373465,
                    "success_improvement": 0.0,
                    "time_improvement": -111.1666907330062,
                    "length_improvement": 12.550943233552712,
                    "smoothness_improvement": 123.51265111874623,
                    "objective_score": -25.201878024176505
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.657418155670166,
                    "num_nodes_avg": 1643.9,
                    "path_length_avg": 225.8188621683445,
                    "smoothness_avg": 0.011647718530032266,
                    "success_improvement": 0.0,
                    "time_improvement": -298.09738719911644,
                    "length_improvement": 24.615163972652255,
                    "smoothness_improvement": 199.70418729028074,
                    "objective_score": -73.66159683969218
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.37705459594726565,
                    "num_nodes_avg": 903.6,
                    "path_length_avg": 117.61140655432416,
                    "smoothness_avg": 0.021531337900664946,
                    "success_improvement": 0.0,
                    "time_improvement": -649.8243830649137,
                    "length_improvement": 21.888103819969416,
                    "smoothness_improvement": 173.8770288184128,
                    "objective_score": -180.9450674834004
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "initial",
          "algorithm_description": "This algorithm with post-optimization: a single-tree, asymptotically optimal sampler that, after the first feasible path, restricts sampling to a start\u2013goal prolate hyperspheroid to accelerate convergence while continuing local rewiring to reduce path cost.",
          "planning_mechanism": "Mechanism: (1) Grow one tree from the start using uniform sampling; (2) when a goal-connecting edge is found, record the best cost and switch to informed sampling inside the ellipsoid defined by start, goal, and current best path length; (3) for each sample, steer a step from the nearest node, then select the lowest-cost parent among nearby nodes and rewire neighbors if the new node offers cheaper paths; (4) whenever the new node lies within one step of the goal and the edge is collision-free, connect and update the best path; (5) after the first solution, continue only a limited number of additional iterations or until no further improvements occur; (6) every candidate node and edge is validated against obstacle occupancy and line-segment collisions, and results include the best path found within the iteration budget.",
          "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 post_opt_iters: int = 500, max_no_improve: int = 150,\n                 improve_tol: float = 1e-6):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.post_opt_iters = post_opt_iters\n        self.max_no_improve = max_no_improve\n        self.improve_tol = improve_tol\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        root = Node(start)\n        goal_node = Node(goal)\n        nodes.append(root)\n        tree = [root]\n\n        best_cost = float(\"inf\")\n        best_goal_node = None\n        c_min = math.dist(start, goal)\n\n        found_first_solution = False\n        post_iter_count = 0\n        no_improve_streak = 0\n\n        for _ in range(self.max_iter):\n            x_rand = self._sample(start, goal, best_cost, c_min, is_3d, bounds)\n\n            x_nearest = min(tree, key=lambda n: math.dist(n.position, x_rand))\n            x_new_pos = self._steer(x_nearest.position, x_rand)\n            if self._is_in_obstacle(x_new_pos, obstacles, is_3d) or                self._is_edge_in_obstacle(x_nearest.position, x_new_pos, obstacles, is_3d):\n                if found_first_solution:\n                    post_iter_count += 1\n                    no_improve_streak += 1\n                    if post_iter_count >= self.post_opt_iters or no_improve_streak >= self.max_no_improve:\n                        break\n                continue\n\n            x_new = Node(x_new_pos)\n            near_nodes = [n for n in tree if math.dist(n.position, x_new_pos) <= 20.0]\n\n            min_cost = x_nearest.cost + math.dist(x_nearest.position, x_new_pos)\n            best_parent = x_nearest\n            for n in near_nodes:\n                new_cost = n.cost + math.dist(n.position, x_new_pos)\n                if new_cost < min_cost and not self._is_edge_in_obstacle(n.position, x_new_pos, obstacles, is_3d):\n                    best_parent = n\n                    min_cost = new_cost\n\n            best_parent.add_child(x_new)\n            x_new.cost = min_cost\n            x_new.parent = best_parent\n            tree.append(x_new)\n            nodes.append(x_new)\n            edges.append((best_parent, x_new))\n\n            for n in near_nodes:\n                alt_cost = x_new.cost + math.dist(x_new.position, n.position)\n                if alt_cost + 1e-12 < n.cost and not self._is_edge_in_obstacle(x_new.position, n.position, obstacles, is_3d):\n                    if n.parent:\n                        try:\n                            edges.remove((n.parent, n))\n                        except ValueError:\n                            pass\n                        if n in n.parent.children:\n                            n.parent.children.remove(n)\n                    n.parent = x_new\n                    n.cost = alt_cost\n                    x_new.add_child(n)\n                    edges.append((x_new, n))\n\n            if math.dist(x_new.position, goal) < self.step_size and                not self._is_edge_in_obstacle(x_new.position, goal, obstacles, is_3d):\n                # \uc0c8 \ud574 \ud6c4\ubcf4\n                goal_node = Node(goal)  # \ubaa9\ud45c \ub178\ub4dc\ub294 \uc0c8\ub85c \ub9cc\ub4e4\uc5b4 \uba85\ud655\ud788 \uc5f0\uacb0\n                goal_node.parent = x_new\n                goal_node.cost = x_new.cost + math.dist(x_new.position, goal)\n                nodes.append(goal_node)\n                edges.append((x_new, goal_node))\n\n                if goal_node.cost + self.improve_tol < best_cost:\n                    best_cost = goal_node.cost\n                    best_goal_node = goal_node\n                    success_state = True\n                    extracted_path = goal_node.path_from_root()\n                    no_improve_streak = 0  \n                else:\n                    no_improve_streak += 1\n\n                if not found_first_solution:\n                    found_first_solution = True\n                    post_iter_count = 0  \n                else:\n                    post_iter_count += 1\n\n                if post_iter_count >= self.post_opt_iters or no_improve_streak >= self.max_no_improve:\n                    break\n            else:\n                if found_first_solution:\n                    post_iter_count += 1\n                    no_improve_streak += 1\n                    if post_iter_count >= self.post_opt_iters or no_improve_streak >= self.max_no_improve:\n                        break\n\n        if success_state and best_goal_node is not None:\n            extracted_path = best_goal_node.path_from_root()\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _sample(self, start, goal, c_best, c_min, is_3d, bounds):\n        import numpy as np\n        import math, random\n\n        if c_best == float(\"inf\"):\n            return tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n\n        dim = len(start)\n        L = np.diag([c_best / 2] + [math.sqrt(c_best**2 - c_min**2) / 2] * (dim - 1))\n        x_center = np.array([(s + g) / 2 for s, g in zip(start, goal)])\n        a1 = np.array(goal) - np.array(start)\n        a1 = a1 / np.linalg.norm(a1)\n        I = np.eye(dim)\n        M = np.outer(a1, I[:, 0])\n        U, _, Vt = np.linalg.svd(M)\n        C = np.dot(U, np.dot(np.diag([1] * (dim - 1) + [np.linalg.det(U) * np.linalg.det(Vt)]), Vt))\n\n        while True:\n            x_ball = np.random.normal(0, 1, dim)\n            norm = np.linalg.norm(x_ball)\n            if norm > 1e-6:\n                x_ball = x_ball / norm * random.random() ** (1.0 / dim)\n            x_rand = np.dot(C, np.dot(L, x_ball)) + x_center\n            if all(0 <= x_rand[d] <= bounds[d] for d in range(dim)):\n                return tuple(x_rand)\n\n    def _steer(self, from_pos, to_pos):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * self.step_size / dist for d in range(len(from_pos)))\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * i / steps for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n    \n",
          "objective": 176.22244165846607,
          "time_improvement": -640.0,
          "length_improvement": 23.0,
          "smoothness_improvement": 415.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.34255270957946776,
                    "num_nodes_avg": 746.9,
                    "path_length_avg": 149.78616134545342,
                    "smoothness_avg": 0.030209968016834215,
                    "success_improvement": 0.0,
                    "time_improvement": -1204.8226219959076,
                    "length_improvement": 17.89983145294235,
                    "smoothness_improvement": 372.8516014590004,
                    "objective_score": -348.84262971971185
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.6933090448379516,
                    "num_nodes_avg": 1213.6,
                    "path_length_avg": 221.23420201912344,
                    "smoothness_avg": 0.02132852376706613,
                    "success_improvement": 0.0,
                    "time_improvement": -319.8309962859896,
                    "length_improvement": 26.1456554925878,
                    "smoothness_improvement": 448.7982788413316,
                    "objective_score": -78.01791419603754
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.2486640214920044,
                    "num_nodes_avg": 688.0,
                    "path_length_avg": 114.36311094960925,
                    "smoothness_avg": 0.0411419688028192,
                    "success_improvement": 0.0,
                    "time_improvement": -394.50225115876833,
                    "length_improvement": 24.045467093406195,
                    "smoothness_improvement": 423.32280638761296,
                    "objective_score": -101.80678105964871
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e1",
          "algorithm_description": "A hybrid RRT*-based planner with adaptive sampling and dynamic neighborhood radius that grows a single tree from the start and performs rewiring with distance-based neighborhood scaling. It uses heuristic pruning and batch nearest neighbor caching to accelerate collision checks, applies path shortening as postprocessing, and attempts a direct connection to the goal at each iteration to improve success and efficiency.",
          "planning_mechanism": "The planner samples new states adaptively within the current search bounds, finds the best parent among dynamically chosen near neighbors whose radius shrinks as the tree grows, rewires neighbors to optimize cost, caches collision checks for efficiency, tries a direct connection to the goal for early success, and finally smoothes the extracted path to improve length and smoothness while maintaining collision-free guarantees.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\nclass Planner:\n    def __init__(self, max_iter=4000, step_size=4.0, initial_radius=15.0, min_radius=3.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.initial_radius = initial_radius\n        self.min_radius = min_radius\n\n    def plan(self, map) -> \"PlannerResult\":\n        bounds = map.size\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        tree = [Node(start)]\n        nodes = list(tree)\n        edges = []\n        success = False\n        best_goal_node = None\n        best_cost = float(\"inf\")\n\n        # For collision check cache: key = (p_from, p_to) rounded down to decimals, value=bool\n        collision_cache = {}\n\n        def cached_edge_collision(a, b):\n            key = tuple(sorted((self._round_tuple(a), self._round_tuple(b))))\n            if key in collision_cache:\n                return collision_cache[key]\n            val = self._is_edge_in_obstacle(a, b, obstacles, is_3d)\n            collision_cache[key] = val\n            return val\n\n        for it in range(self.max_iter):\n            x_rand = self._sample_free(bounds, obstacles, is_3d)\n\n            x_nearest = self._nearest(tree, x_rand)\n            x_new_pos = self._steer(x_nearest.position, x_rand, self.step_size)\n            if self._is_in_obstacle(x_new_pos, obstacles, is_3d):\n                continue\n            if cached_edge_collision(x_nearest.position, x_new_pos):\n                continue\n\n            # Dynamic radius decreasing with iteration count for near neighbor selection\n            neighbor_radius = max(\n                self.min_radius,\n                self.initial_radius * ( (math.log(it+2)/(it+2))**0.5 )\n            )\n\n            near_nodes = self._near(tree, x_new_pos, neighbor_radius)\n\n            min_cost = x_nearest.cost + self._distance(x_nearest.position, x_new_pos)\n            min_parent = x_nearest\n            for potential_parent in near_nodes:\n                if potential_parent == x_nearest:\n                    continue\n                c = potential_parent.cost + self._distance(potential_parent.position, x_new_pos)\n                if c < min_cost and not cached_edge_collision(potential_parent.position, x_new_pos):\n                    min_cost = c\n                    min_parent = potential_parent\n\n            x_new = Node(x_new_pos)\n            x_new.parent = min_parent\n            x_new.cost = min_cost\n            min_parent.add_child(x_new)\n            tree.append(x_new)\n            nodes.append(x_new)\n            edges.append((min_parent, x_new))\n\n            improved = False\n            for near_node in near_nodes:\n                if near_node == min_parent:\n                    continue\n                new_cost = x_new.cost + self._distance(x_new.position, near_node.position)\n                if new_cost + 1e-12 < near_node.cost and not cached_edge_collision(x_new.position, near_node.position):\n                    if near_node.parent:\n                        edges.remove((near_node.parent, near_node))\n                        near_node.parent.remove_child(near_node)\n                    near_node.parent = x_new\n                    near_node.cost = new_cost\n                    x_new.add_child(near_node)\n                    edges.append((x_new, near_node))\n                    improved = True\n\n            # Always try to directly connect x_new to goal if close enough\n            dist_to_goal = self._distance(x_new.position, goal)\n            if dist_to_goal <= self.step_size:\n                if not self._is_in_obstacle(goal, obstacles, is_3d) and not cached_edge_collision(x_new.position, goal):\n                    goal_node = Node(goal)\n                    goal_node.parent = x_new\n                    goal_node.cost = x_new.cost + dist_to_goal\n                    # Add goal node to data structures\n                    tree.append(goal_node)\n                    nodes.append(goal_node)\n                    edges.append((x_new, goal_node))\n\n                    if goal_node.cost < best_cost:\n                        best_cost = goal_node.cost\n                        best_goal_node = goal_node\n                        success = True\n\n            if success:\n                # Early stop bias for faster solution when found good solution\n                if it > 100 and it % 10 == 0:\n                    break\n\n        if not success:\n            return PlannerResult(False, [], nodes, edges)\n\n        path = self._extract_path(best_goal_node)\n        path = self._path_shortening(path, obstacles, is_3d)\n        return PlannerResult(True, path, nodes, edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        while True:\n            point = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n            if not self._is_in_obstacle(point, obstacles, is_3d):\n                return point\n\n    def _nearest(self, tree, point):\n        # Euclidean nearest node in tree\n        min_node = None\n        min_dist = float(\"inf\")\n        for node in tree:\n            dist = self._distance(node.position, point)\n            if dist < min_dist:\n                min_dist = dist\n                min_node = node\n        return min_node\n\n    def _near(self, tree, point, radius):\n        # Return list of nodes within radius of point\n        near_nodes = []\n        radius_sq = radius * radius\n        for node in tree:\n            d = self._distance_sq(node.position, point)\n            if d <= radius_sq:\n                near_nodes.append(node)\n        return near_nodes\n\n    def _steer(self, from_pos, to_pos, step_size):\n        dist = self._distance(from_pos, to_pos)\n        if dist <= step_size:\n            return to_pos\n        ratio = step_size / dist\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n    def _distance(self, a, b):\n        return math.dist(a, b)\n\n    def _distance_sq(self, a, b):\n        s = 0.0\n        for i in range(len(a)):\n            s += (a[i] - b[i]) ** 2\n        return s\n\n    def _extract_path(self, goal_node):\n        path = []\n        node = goal_node\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.6):\n        dist = self._distance(from_pos, to_pos)\n        steps = max(2, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * i / steps for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _path_shortening(self, path, obstacles, is_3d):\n        # Try shortcutting path segments greedily to reduce nodes while collision-free\n        if len(path) < 3:\n            return path\n        shortened = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            while j > i + 1:\n                if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                    break\n                j -= 1\n            shortened.append(path[j])\n            i = j\n        return shortened\n\n    def _round_tuple(self, pos, digits=3):\n        return tuple(round(x, digits) for x in pos)",
          "objective": 289.57187,
          "time_improvement": -864.0,
          "length_improvement": 16.0,
          "smoothness_improvement": 2038.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 0.9,
                    "time_avg": 0.25097036361694336,
                    "num_nodes_avg": 810.5,
                    "path_length_avg": 171.36049969211678,
                    "smoothness_avg": 0.0590128568363977,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": -855.9749455782868,
                    "length_improvement": 6.074594737867973,
                    "smoothness_improvement": 823.6793579593315,
                    "objective_score": -299.0293300409686
               },
               {
                    "map_id": 1,
                    "success_rate": 0.9,
                    "time_avg": 1.249403142929077,
                    "num_nodes_avg": 1481.8,
                    "path_length_avg": 238.22730941166657,
                    "smoothness_avg": 0.15328169630750338,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": -656.571935941442,
                    "length_improvement": 20.47286712548058,
                    "smoothness_improvement": 3844.0484503353355,
                    "objective_score": -215.46761825546758
               },
               {
                    "map_id": 2,
                    "success_rate": 0.9,
                    "time_avg": 0.593242859840393,
                    "num_nodes_avg": 958.2,
                    "path_length_avg": 119.25622485352412,
                    "smoothness_avg": 0.12149721800326971,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": -1079.7441701246387,
                    "length_improvement": 20.795693823471524,
                    "smoothness_improvement": 1445.4356450098185,
                    "objective_score": -354.2186565182596
               }
          ],
          "success_rate": 0.9
     },
     {
          "operator": "path_expert",
          "algorithm_description": "A Dual-Tree Anytime Informed RRT* with Adaptive Radius and Incremental Path Smoothing. This planner grows two asymptotically optimal trees from start and goal, using adaptive radius for rewiring, and informed sampling within ellipsoids after first solution. It prioritizes rewiring that propagates cost improvements recursively to downstream nodes for better path optimality. The connection threshold is dynamically tuned based on step size and adaptive neighborhood. Incremental shortcut smoothing is performed on newly discovered partial paths during planning to improve smoothness gradually, yielding shorter and smoother paths faster while balancing exploration and exploitation.",
          "planning_mechanism": "The planner maintains two trees initialized at start and goal positions, merging them upon a close and collision-free connection. Sampling switches between uniform and informed ellipsoidal bias based on the current best cost. Each new node selects the best parent within an adaptive radius based on cost and collision checks. Then, rewiring with recursion updates costs/parents downstream for enhanced optimality. When trees connect, the combined path is incrementally shortcut-smoothed before updating the best solution, accelerating convergence to shorter, smoother, feasible paths within the time budget.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=6000, step_size=6.0, gamma=100.0,\n                 max_no_improve=120, time_limit_sec=30.0, shortcut_attempts=75):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.gamma = gamma\n        self.max_no_improve = max_no_improve\n        self.time_limit_sec = time_limit_sec\n        self.shortcut_attempts = shortcut_attempts\n\n    def plan(self, map):\n        import time\n        import random\n        import math\n\n        bounds = map.size\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def within_bounds(p):\n            return all(0.0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    px, py = pos\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(a, b, resolution=0.5):\n            length = dist(a, b)\n            steps = max(1, int(length / resolution))\n            for i in range(steps + 1):\n                interp = tuple(a[d] + (b[d] - a[d]) * (i / steps) for d in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def steer(from_p, to_p):\n            d = dist(from_p, to_p)\n            if d <= self.step_size:\n                return to_p\n            ratio = self.step_size / d\n            return tuple(from_p[i] + (to_p[i] - from_p[i]) * ratio for i in range(dim))\n\n        def nearest(tree, point):\n            best = None\n            best_d = float(\"inf\")\n            for n in tree:\n                d = dist(n.position, point)\n                if d < best_d:\n                    best = n\n                    best_d = d\n            return best\n\n        def neighbor_radius(n_nodes):\n            if n_nodes < 2:\n                return self.step_size * 3.0\n            r = self.gamma * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            max_r = max(bounds) * 0.25\n            min_r = max(8.0, self.step_size * 1.5)\n            return max(min_r, min(max_r, r))\n\n        def near_nodes(tree, point, radius):\n            res = []\n            r_sq = radius * radius\n            for n in tree:\n                dx = 0.0\n                for d in range(dim):\n                    diff = n.position[d] - point[d]\n                    dx += diff * diff\n                    if dx > r_sq:\n                        break\n                if dx <= r_sq:\n                    res.append(n)\n            return res\n\n        def sample_uniform():\n            while True:\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle(p):\n                    return p\n\n        def sample_unit_ball():\n            while True:\n                v = [random.gauss(0, 1) for _ in range(dim)]\n                norm_v = math.sqrt(sum(x * x for x in v))\n                if norm_v > 1e-14:\n                    v = [x / norm_v for x in v]\n                    r = random.random() ** (1.0 / dim)\n                    return tuple(v[i] * r for i in range(dim))\n\n        def sample_informed(c_best):\n            if not found_solution or c_best == float(\"inf\") or c_min <= 1e-14:\n                return sample_uniform()\n            r1 = c_best / 2.0\n            rother_sq = max(c_best * c_best - c_min * c_min, 0.0)\n            r_other = math.sqrt(rother_sq) / 2.0\n            center = tuple((start_pos[d] + goal_pos[d]) * 0.5 for d in range(dim))\n            unit_vec = tuple((goal_pos[d] - start_pos[d]) / c_min for d in range(dim))\n\n            if dim == 2:\n                perp = (-unit_vec[1], unit_vec[0])\n                basis = [unit_vec, perp]\n                radii = [r1, r_other]\n            else:  # 3D\n                def cross(u, v):\n                    return (u[1]*v[2]-u[2]*v[1], u[2]*v[0]-u[0]*v[2], u[0]*v[1]-u[1]*v[0])\n                def norm(v):\n                    return math.sqrt(sum(x*x for x in v))\n                def normalize(v):\n                    nrm = norm(v)\n                    if nrm < 1e-14:\n                        return v\n                    return tuple(x / nrm for x in v)\n                ref = (1.0, 0.0, 0.0) if abs(unit_vec[0]) < 0.9 else (0.0, 1.0, 0.0)\n                b2 = normalize(cross(unit_vec, ref))\n                if norm(b2) < 1e-14:\n                    ref = (0.0, 0.0, 1.0)\n                    b2 = normalize(cross(unit_vec, ref))\n                b3 = cross(unit_vec, b2)\n                basis = [unit_vec, b2, b3]\n                radii = [r1, r_other, r_other]\n\n            u = sample_unit_ball()\n            sample = []\n            for d in range(dim):\n                val = center[d]\n                for i in range(dim):\n                    val += basis[i][d] * radii[i] * u[i]\n                val = max(0.0, min(val, bounds[d]))\n                sample.append(val)\n            return tuple(sample)\n\n        def add_node_best_parent(tree, pos):\n            r = neighbor_radius(len(tree))\n            neighbors = near_nodes(tree, pos, r)\n            if not neighbors:\n                neighbors = [nearest(tree, pos)]\n            candidates = []\n            for p in neighbors:\n                if not is_edge_in_obstacle(p.position, pos):\n                    candidates.append(p)\n            if not candidates or is_in_obstacle(pos):\n                return None, []\n            parent = min(candidates, key=lambda p: p.cost + dist(p.position, pos))\n            cost_new = parent.cost + dist(parent.position, pos)\n            new_node = Node(pos)\n            new_node.parent = parent\n            new_node.cost = cost_new\n            parent.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((parent, new_node))\n            return new_node, neighbors\n\n        def propagate_cost_improvements(node):\n            stack = [node]\n            while stack:\n                curr = stack.pop()\n                for child in curr.children[:]:\n                    new_cost = curr.cost + dist(curr.position, child.position)\n                    if new_cost + 1e-12 < child.cost:\n                        if child.parent:\n                            try:\n                                edges.remove((child.parent, child))\n                            except ValueError:\n                                pass\n                            child.parent.remove_child(child)\n                        curr.add_child(child)\n                        child.cost = new_cost\n                        edges.append((curr, child))\n                        stack.append(child)\n\n        def rewire(node, neighbors):\n            for n in neighbors:\n                if n is node:\n                    continue\n                if is_edge_in_obstacle(node.position, n.position):\n                    continue\n                new_cost = node.cost + dist(node.position, n.position)\n                if new_cost + 1e-12 < n.cost:\n                    if n.parent:\n                        try:\n                            edges.remove((n.parent, n))\n                        except ValueError:\n                            pass\n                        n.parent.remove_child(n)\n                    node.add_child(n)\n                    n.cost = new_cost\n                    edges.append((node, n))\n                    propagate_cost_improvements(n)\n\n        def connect_trees(new_node, other_tree):\n            # Dynamically allow upto adaptive radius connection\n            r = neighbor_radius(len(other_tree))\n            nearest_other = nearest(other_tree, new_node.position)\n            d = dist(new_node.position, nearest_other.position)\n            if d > r:\n                return None\n            if is_edge_in_obstacle(new_node.position, nearest_other.position):\n                return None\n            return nearest_other\n\n        def combine_paths(n_start, n_goal, start_side=True):\n            p_start = n_start.path_from_root()\n            p_goal = n_goal.path_from_root()\n            if p_start[-1] == p_goal[-1]:\n                combined = p_start + p_goal[-2::-1]\n            else:\n                combined = p_start + p_goal[::-1]\n            return combined if start_side else combined[::-1]\n\n        def path_cost(path):\n            if len(path) < 2:\n                return 0.0\n            total = 0.0\n            for i in range(len(path)-1):\n                total += dist(path[i], path[i+1])\n            return total\n\n        def shortcut_path(path, attempts):\n            if len(path) < 3:\n                return path[:]\n            path_smoothed = path[:]\n            for _ in range(attempts):\n                if len(path_smoothed) < 3:\n                    break\n                i = random.randint(0, len(path_smoothed)-3)\n                j = random.randint(i+2, len(path_smoothed)-1)\n                if j <= i+1:\n                    continue\n                if not is_edge_in_obstacle(path_smoothed[i], path_smoothed[j]):\n                    path_smoothed = path_smoothed[:i+1] + path_smoothed[j:]\n            return path_smoothed\n\n        # Initialization\n        start_time = time.time()\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        tree_a = [start_root]\n        tree_b = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        c_min = dist(start_pos, goal_pos)\n        best_cost = float(\"inf\")\n        best_path = []\n        found_solution = False\n        no_improve_count = 0\n\n        for it in range(self.max_iter):\n            if time.time() - start_time > self.time_limit_sec:\n                break\n\n            grow_tree = tree_a if it % 2 == 0 else tree_b\n            other_tree = tree_b if it % 2 == 0 else tree_a\n            start_side = (grow_tree is tree_a)\n\n            sample = sample_informed(best_cost)\n            nearest_node = nearest(grow_tree, sample)\n            new_pos = steer(nearest_node.position, sample)\n\n            if not within_bounds(new_pos) or is_in_obstacle(new_pos) or is_edge_in_obstacle(nearest_node.position, new_pos):\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n                continue\n\n            new_node, neighbors = add_node_best_parent(grow_tree, new_pos)\n            if new_node is None:\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n                continue\n\n            rewire(new_node, neighbors)\n\n            other_connect_node = connect_trees(new_node, other_tree)\n            if other_connect_node:\n                if new_node.parent is None or other_connect_node.parent is None:\n                    continue  # skip root-level connects\n                candidate_path = combine_paths(new_node, other_connect_node, start_side)\n                candidate_cost = path_cost(candidate_path)\n                if candidate_cost + 1e-8 < best_cost:\n                    best_cost = candidate_cost\n                    # Incremental shortcut smoothing on partial improved path\n                    best_path = shortcut_path(candidate_path, self.shortcut_attempts)\n                    found_solution = True\n                    no_improve_count = 0\n                else:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n            else:\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n\n        return PlannerResult(\n            success=found_solution,\n            path=best_path if found_solution else [],\n            nodes=nodes,\n            edges=edges\n        )",
          "objective": 324.51987,
          "time_improvement": -1029.0,
          "length_improvement": 19.0,
          "smoothness_improvement": 1271.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.6372508049011231,
                    "num_nodes_avg": 218.7,
                    "path_length_avg": 160.8863986140083,
                    "smoothness_avg": 0.04475053916474018,
                    "success_improvement": 0.0,
                    "time_improvement": -2327.361520920006,
                    "length_improvement": 11.815615511531895,
                    "smoothness_improvement": 600.4431152793574,
                    "objective_score": -688.1168713926859
               },
               {
                    "map_id": 1,
                    "success_rate": 0.9,
                    "time_avg": 0.47791233062744143,
                    "num_nodes_avg": 296.5,
                    "path_length_avg": 226.63752813777037,
                    "smoothness_avg": 0.07342140960589134,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": -189.3982292580281,
                    "length_improvement": 24.34186970806451,
                    "smoothness_improvement": 1789.185752463364,
                    "objective_score": -83.26841819025289
               },
               {
                    "map_id": 2,
                    "success_rate": 0.9,
                    "time_avg": 0.3372055530548096,
                    "num_nodes_avg": 221.1,
                    "path_length_avg": 120.76625865421815,
                    "smoothness_avg": 0.1198708929264735,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": -570.5791376184371,
                    "length_improvement": 19.79280127313315,
                    "smoothness_improvement": 1424.7489100758007,
                    "objective_score": -202.17431597127222
               }
          ],
          "success_rate": 0.9333333333333332
     }
]