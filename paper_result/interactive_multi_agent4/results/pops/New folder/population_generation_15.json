[
     {
          "operator": "e1",
          "algorithm_description": "A bidirectional incremental Rapid Random Tree with adaptive goal biasing and dynamic rewiring radius, integrating lazy collision checks and a priority queue driven expansion focused on nodes with lower estimated total cost (cost-to-come plus heuristic to goal). The Planner alternates tree expansions, uses informed sampling once a solution is found to prioritize promising regions, and performs dynamic rewiring within an adaptive radius decreasing over iterations to refine paths and reduce unnecessary rewiring overhead. The search employs lazy collision checks by postponing full edge validations until candidate connections are promising, improving efficiency. Path shortcutting post-processing is applied to enhance smoothness and reduce length, while maintaining collision-free guarantees.",
          "planning_mechanism": "A bidirectional, anytime planner that grows two trees from start and goal nodes by sampling either uniform or informed ellipsoidal regions based on current best path cost. The planner uses a priority-driven node expansion strategy prioritizing nodes with lowest estimated total cost, applies adaptive rewiring radius and lazy collision checking to efficiently rewire neighbor nodes only when beneficial, and incrementally attempts to connect the two trees. Upon connection, the algorithm extracts the combined path, applies shortcutting to smooth it, and returns it as the solution. The adaptive rewiring radius gradually decreases to focus optimization near the path, balancing computation and improvement for faster convergence and smoother paths.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost  # cost-to-come\n        self.children = []\n        self.id = id(self)  # unique identifier for potential bookkeeping\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=4000, step_size=5.0, goal_sample_rate=0.15, initial_neighbor_radius=25.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.initial_neighbor_radius = initial_neighbor_radius\n\n    def plan(self, map):\n        bounds = map.size\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        import random\n        import math\n        import heapq\n\n        # Heuristic function for A*-like priority: Euclidean distance to goal\n        def heuristic(p):\n            return sum((p[d] - goal[d]) ** 2 for d in range(dim)) ** 0.5\n\n        # Distance between two points\n        def dist(a, b):\n            return sum((a[d] - b[d]) ** 2 for d in range(dim)) ** 0.5\n\n        # Collision check for point in obstacles\n        def in_obstacle(pt):\n            if is_3d:\n                px, py, pz = pt\n                for obs in obstacles:\n                    ox, oy, oz, w, h, d = obs\n                    if ox <= px <= ox + w and oy <= py <= oy + h and oz <= pz <= oz + d:\n                        return True\n            else:\n                px, py = pt\n                for obs in obstacles:\n                    ox, oy, w, h = obs\n                    if ox <= px <= ox + w and oy <= py <= oy + h:\n                        return True\n            return False\n\n        # Edge collision check by discretizing line at resolution 1.0 units\n        def edge_in_obstacle(p1, p2):\n            distance = dist(p1, p2)\n            steps = max(1, int(distance / 1.0))\n            for i in range(steps + 1):\n                interp = tuple(p1[d] + (p2[d] - p1[d]) * (i / steps) for d in range(dim))\n                if in_obstacle(interp):\n                    return True\n            return False\n\n        # Steer from start towards goal at maximum step_size\n        def steer(start_pt, goal_pt):\n            d = dist(start_pt, goal_pt)\n            if d <= self.step_size:\n                return goal_pt\n            ratio = self.step_size / d\n            return tuple(start_pt[d_] + ratio * (goal_pt[d_] - start_pt[d_]) for d_ in range(dim))\n\n        # Random uniform sample in bounds avoiding obstacles\n        def sample_uniform():\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not in_obstacle(pt):\n                    return pt\n\n        # Informed sampling within prolate hyperspheroid about start and goal for bidirectional searching\n        def sample_informed(c_best):\n            if c_best == float('inf'):\n                return sample_uniform()\n            c_min = dist(start, goal)\n            if c_best < c_min:\n                return sample_uniform()\n            center = tuple((start[d] + goal[d]) * 0.5 for d in range(dim))\n            a1 = [(goal[d] - start[d]) / c_min for d in range(dim)]\n            # Sample unit ball\n            while True:\n                x_ball = [random.gauss(0, 1) for _ in range(dim)]\n                norm = math.sqrt(sum(x ** 2 for x in x_ball))\n                if norm <= 1 and norm > 0:\n                    unit = [x / norm for x in x_ball]\n                    r1 = c_best / 2.0\n                    r2_temp = c_best ** 2 - c_min ** 2\n                    r2 = math.sqrt(r2_temp) / 2.0 if r2_temp > 0 else 0.0\n                    # 2D rotation matrix to align ellipse axis\n                    if dim == 2:\n                        angle = math.atan2(a1[1], a1[0])\n                        cos_ang = math.cos(angle)\n                        sin_ang = math.sin(angle)\n                        x_ell = r1 * unit[0]\n                        y_ell = r2 * unit[1]\n                        px = center[0] + cos_ang * x_ell - sin_ang * y_ell\n                        py = center[1] + sin_ang * x_ell + cos_ang * y_ell\n                        pt = (px, py)\n                    else:\n                        # 3D approximation: scale x by r1, y,z by r2 and clamp\n                        pt_candidate = [center[d] + (r1 * unit[0] if d == 0 else r2 * unit[d]) for d in range(dim)]\n                        pt = tuple(max(0, min(pt_candidate[d], bounds[d])) for d in range(dim))\n                    if all(0 <= pt[d] <= bounds[d] for d in range(dim)) and not in_obstacle(pt):\n                        return pt\n\n        # Node priority queue helper by f = cost + heuristic\n        class PQ:\n            def __init__(self):\n                self.heap = []\n                self.entry_finder = {}\n                self.REMOVED = '<removed>'\n\n            def add_node(self, node, priority):\n                if node.id in self.entry_finder:\n                    self.remove_node(node)\n                entry = [priority, node.id, node]\n                self.entry_finder[node.id] = entry\n                heapq.heappush(self.heap, entry)\n\n            def remove_node(self, node):\n                entry = self.entry_finder.pop(node.id)\n                entry[-1] = self.REMOVED\n\n            def pop_node(self):\n                while self.heap:\n                    priority, node_id, node = heapq.heappop(self.heap)\n                    if node is not self.REMOVED:\n                        del self.entry_finder[node_id]\n                        return node\n                return None\n\n            def empty(self):\n                return not self.entry_finder\n\n        # Find nearest neighbor by Euclidean distance\n        def nearest(tree_nodes, point):\n            best_node = None\n            best_dist = float('inf')\n            for node in tree_nodes:\n                d = dist(node.position, point)\n                if d < best_dist:\n                    best_dist = d\n                    best_node = node\n            return best_node, best_dist\n\n        # Find neighbors within radius\n        def neighbors(tree_nodes, node, radius):\n            result = []\n            for n in tree_nodes:\n                if dist(n.position, node.position) <= radius:\n                    result.append(n)\n            return result\n\n        # Shortcut path by removing unnecessary nodes with collision check\n        def shortcut_path(path):\n            if len(path) <= 2:\n                return path\n            shortened = [path[0]]\n            idx = 0\n            while idx < len(path) - 1:\n                next_idx = len(path) - 1\n                for j in range(len(path) - 1, idx, -1):\n                    if not edge_in_obstacle(path[idx], path[j]):\n                        next_idx = j\n                        break\n                shortened.append(path[next_idx])\n                idx = next_idx\n            return shortened\n\n        # Lazy connection: check edge collision only on candidate edges after cost improvement\n        def lazy_edge_check(p1, p2):\n            return not edge_in_obstacle(p1, p2)\n\n        # Add new node to tree with rewiring in adaptive radius\n        def add_node_with_rewire(tree_nodes, tree_pq, new_pos, best_cost, neighbor_radius):\n            near_node, dist_to_near = nearest(tree_nodes, new_pos)\n            if in_obstacle(new_pos) or edge_in_obstacle(near_node.position, new_pos):\n                return None\n\n            new_cost = near_node.cost + dist(near_node.position, new_pos)\n            new_node = Node(new_pos, parent=near_node, cost=new_cost)\n            near_node.add_child(new_node)\n            tree_nodes.append(new_node)\n            tree_pq.add_node(new_node, new_node.cost + heuristic(new_node.position))\n\n            # Find neighbors within adaptive radius for rewiring\n            nbrs = neighbors(tree_nodes, new_node, neighbor_radius)\n            for nbr in nbrs:\n                if nbr is new_node.parent:\n                    continue\n                # Cost through new_node\n                cost_through_new = new_node.cost + dist(new_node.position, nbr.position)\n                if cost_through_new + 1e-6 < nbr.cost:\n                    # Lazy check edge collision\n                    if lazy_edge_check(new_node.position, nbr.position):\n                        # Rewire nbr to new_node\n                        if nbr.parent:\n                            nbr.parent.remove_child(nbr)\n                        nbr.parent = new_node\n                        new_node.children.append(nbr)\n                        old_cost = nbr.cost\n                        nbr.cost = cost_through_new\n\n                        # Update costs downstream\n                        def dfs_update_costs(n):\n                            for c in n.children:\n                                new_c_cost = n.cost + dist(n.position, c.position)\n                                if new_c_cost + 1e-8 < c.cost:\n                                    c.cost = new_c_cost\n                                    dfs_update_costs(c)\n                        dfs_update_costs(nbr)\n                        tree_pq.add_node(nbr, nbr.cost + heuristic(nbr.position))\n            return new_node\n\n        # Attempt connecting tree_b to new_node_a with lazy collision checking\n        def try_connect(tree_nodes_b, tree_pq_b, node_a, best_cost):\n            near_node_b, dist_nb = nearest(tree_nodes_b, node_a.position)\n            if in_obstacle(node_a.position) or edge_in_obstacle(near_node_b.position, node_a.position):\n                return None\n            cost_b = near_node_b.cost + dist(near_node_b.position, node_a.position)\n            new_node_b = Node(node_a.position, parent=near_node_b, cost=cost_b)\n            near_node_b.add_child(new_node_b)\n            tree_nodes_b.append(new_node_b)\n            tree_pq_b.add_node(new_node_b, new_node_b.cost + heuristic(new_node_b.position))\n            return new_node_b\n\n        start_node = Node(start, cost=0.0)\n        goal_node = Node(goal, cost=0.0)\n        start_tree = [start_node]\n        goal_tree = [goal_node]\n\n        start_pq = PQ()\n        start_pq.add_node(start_node, heuristic(start))\n        goal_pq = PQ()\n        goal_pq.add_node(goal_node, heuristic(goal))\n\n        best_cost = float('inf')\n        best_path = None\n\n        # Adaptive neighbor radius decreases over iterations (but never below minimum 5)\n        def adaptive_radius(iteration):\n            r = self.initial_neighbor_radius * (0.95 ** (iteration // 500))\n            return max(5.0, r)\n\n        for i in range(self.max_iter):\n            # Alternate expansion trees\n            if i % 2 == 0:\n                tree_nodes_a, pq_a = start_tree, start_pq\n                tree_nodes_b, pq_b = goal_tree, goal_pq\n                tree_dir = \"start\"\n            else:\n                tree_nodes_a, pq_a = goal_tree, goal_pq\n                tree_nodes_b, pq_b = start_tree, start_pq\n                tree_dir = \"goal\"\n\n            neighbor_r = adaptive_radius(i)\n\n            # Sampling guided by best cost found\n            curr_best_cost = best_cost if best_cost != float('inf') else float('inf')\n            if random.random() < self.goal_sample_rate and tree_dir == \"start\":\n                sample_pt = goal\n                if in_obstacle(sample_pt):\n                    sample_pt = sample_uniform()\n            elif random.random() < self.goal_sample_rate and tree_dir == \"goal\":\n                sample_pt = start\n                if in_obstacle(sample_pt):\n                    sample_pt = sample_uniform()\n            else:\n                sample_pt = sample_informed(curr_best_cost)\n\n            # Add node in tree A with rewiring\n            new_node_a = add_node_with_rewire(tree_nodes_a, pq_a, sample_pt, curr_best_cost, neighbor_r)\n            if new_node_a is None:\n                continue\n\n            # Attempt connection to other tree B\n            new_node_b = try_connect(tree_nodes_b, pq_b, new_node_a, curr_best_cost)\n            if new_node_b:\n                total_cost = new_node_a.cost + new_node_b.cost\n                if total_cost + 1e-8 < best_cost:\n                    best_cost = total_cost\n\n                    # Extract full path: path from start tree root to new_node_a + reversed path from new_node_b to root\n                    path_start = new_node_a.path_from_root() if tree_dir == \"start\" else new_node_b.path_from_root()\n                    path_goal = new_node_b.path_from_root() if tree_dir == \"start\" else new_node_a.path_from_root()\n\n                    # Remove duplicate connection point if equal\n                    if path_start[-1] == path_goal[-1]:\n                        full_path = path_start + path_goal[-2::-1]\n                    else:\n                        full_path = path_start + path_goal[::-1]\n\n                    # Shortcut path improves smoothness and shortness\n                    full_path = shortcut_path(full_path)\n                    best_path = full_path\n\n                    # Return early on first improvement (anytime)\n                    return PlannerResult(success=True, path=best_path, nodes=start_tree + goal_tree, edges=[])\n\n        # If no path found after max_iter\n        return PlannerResult(success=False, path=[], nodes=start_tree + goal_tree, edges=[])",
          "objective": -32.75208,
          "time_improvement": 72.0,
          "length_improvement": 1.0,
          "smoothness_improvement": 2162.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.017874813079833983,
                    "num_nodes_avg": 60.2,
                    "path_length_avg": 178.46134122599636,
                    "smoothness_avg": 0.10095412748742794,
                    "success_improvement": 0.0,
                    "time_improvement": 31.912783585485005,
                    "length_improvement": 2.1825109731139785,
                    "smoothness_improvement": 1480.1513205749102,
                    "objective_score": 18.28409826238844
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.00749971866607666,
                    "num_nodes_avg": 54.1,
                    "path_length_avg": 269.8000195347711,
                    "smoothness_avg": 0.1332598514245687,
                    "success_improvement": 0.0,
                    "time_improvement": 95.45857019623979,
                    "length_improvement": 9.932987716315523,
                    "smoothness_improvement": 3328.871960345464,
                    "objective_score": 51.24172349038857
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.006196403503417968,
                    "num_nodes_avg": 55.0,
                    "path_length_avg": 165.53671627025966,
                    "smoothness_avg": 0.1398135054188176,
                    "success_improvement": 0.0,
                    "time_improvement": 87.67760827182315,
                    "length_improvement": -9.941604935344571,
                    "smoothness_improvement": 1678.417468967884,
                    "objective_score": 28.730406865179617
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "A bidirectional prioritized sampling-based planner that incrementally grows start and goal trees by extending towards samples chosen adaptively from uniform or focused ellipsoid regions once a solution is found. The planner uses adaptive neighbor radius for local rewiring to improve paths dynamically, integrates both node and edge collision checks for validity, and attempts direct connections between trees. Upon success, it traces back and shortcuts the path for smoothness and length reduction. Early returns upon finding better paths improve efficiency.",
          "planning_mechanism": "The planner alternates expansions of two trees from start and goal, prioritizing node expansions based on cost plus heuristic, adaptively samples with goal bias and ellipsoidal informed sampling. It rewires within an adaptive radius, incrementally connects trees when close, and refines paths continuously by shortcutting to enhance smoothness and minimize length.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=3000, step_size=5.0, goal_sample_rate=0.1, neighbor_radius=20.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n\n    def plan(self, map):\n        bounds = map.size\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        import random\n        import math\n        import heapq\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def in_obstacle(pt):\n            if is_3d:\n                px, py, pz = pt\n                for ox, oy, oz, w, h, d in obstacles:\n                    if ox <= px <= ox + w and oy <= py <= oy + h and oz <= pz <= oz + d:\n                        return True\n            else:\n                px, py = pt\n                for ox, oy, w, h in obstacles:\n                    if ox <= px <= ox + w and oy <= py <= oy + h:\n                        return True\n            return False\n\n        def edge_in_obstacle(p1, p2):\n            d = dist(p1, p2)\n            steps = max(1, int(d))\n            for i in range(steps + 1):\n                interp = tuple(p1[j] + (p2[j] - p1[j]) * (i / steps) for j in range(dim))\n                if in_obstacle(interp):\n                    return True\n            return False\n\n        def steer(from_pt, to_pt):\n            d = dist(from_pt, to_pt)\n            if d <= self.step_size:\n                return to_pt\n            ratio = self.step_size / d\n            return tuple(from_pt[j] + ratio * (to_pt[j] - from_pt[j]) for j in range(dim))\n\n        def sample_uniform():\n            while True:\n                pt = tuple(random.uniform(0, bounds[j]) for j in range(dim))\n                if not in_obstacle(pt):\n                    return pt\n\n        def sample_informed(c_best):\n            if c_best == float('inf'):\n                return sample_uniform()\n            c_min = dist(start, goal)\n            if c_best < c_min:\n                return sample_uniform()\n            center = tuple((start[j] + goal[j]) * 0.5 for j in range(dim))\n            a1 = [(goal[j] - start[j]) / c_min for j in range(dim)]\n            while True:\n                x_ball = [random.gauss(0, 1) for _ in range(dim)]\n                norm = math.sqrt(sum(x ** 2 for x in x_ball))\n                if 0 < norm <= 1:\n                    unit = [x / norm for x in x_ball]\n                    r1 = c_best / 2\n                    r2_temp = c_best ** 2 - c_min ** 2\n                    r2 = math.sqrt(r2_temp) / 2 if r2_temp > 0 else 0.0\n                    if dim == 2:\n                        angle = math.atan2(a1[1], a1[0])\n                        cos_a = math.cos(angle)\n                        sin_a = math.sin(angle)\n                        x_ell = r1 * unit[0]\n                        y_ell = r2 * unit[1]\n                        px = center[0] + cos_a * x_ell - sin_a * y_ell\n                        py = center[1] + sin_a * x_ell + cos_a * y_ell\n                        pt = (px, py)\n                    else:\n                        pt_candidate = [center[j] + (r1 * unit[0] if j == 0 else r2 * unit[j]) for j in range(dim)]\n                        pt = tuple(max(0, min(pt_candidate[j], bounds[j])) for j in range(dim))\n                    if all(0 <= pt[j] <= bounds[j] for j in range(dim)) and not in_obstacle(pt):\n                        return pt\n\n        class PriorityQueue:\n            def __init__(self):\n                self.heap = []\n                self.entry_finder = {}\n                self.REMOVED = '<removed>'\n\n            def add(self, node, priority):\n                if node in self.entry_finder:\n                    self.remove(node)\n                entry = [priority, id(node), node]\n                self.entry_finder[node] = entry\n                heapq.heappush(self.heap, entry)\n\n            def remove(self, node):\n                entry = self.entry_finder.pop(node)\n                entry[-1] = self.REMOVED\n\n            def pop(self):\n                while self.heap:\n                    priority, _, node = heapq.heappop(self.heap)\n                    if node is not self.REMOVED:\n                        del self.entry_finder[node]\n                        return node\n                return None\n\n            def empty(self):\n                return not self.entry_finder\n\n        def heuristic(p):\n            return dist(p, goal)\n\n        def nearest(nodes, point):\n            best_node = None\n            best_d = float('inf')\n            for n in nodes:\n                d_ = dist(n.position, point)\n                if d_ < best_d:\n                    best_node = n\n                    best_d = d_\n            return best_node\n\n        def neighbors(nodes, node, radius):\n            return [n for n in nodes if dist(n.position, node.position) <= radius]\n\n        def shortcut_path(path):\n            if len(path) <= 2:\n                return path\n            shortened = [path[0]]\n            i = 0\n            while i < len(path) - 1:\n                j = len(path) - 1\n                while j > i:\n                    if not edge_in_obstacle(path[i], path[j]):\n                        shortened.append(path[j])\n                        i = j\n                        break\n                    j -= 1\n                else:\n                    shortened.append(path[i + 1])\n                    i += 1\n            return shortened\n\n        start_node = Node(start, cost=0.0)\n        goal_node = Node(goal, cost=0.0)\n        tree_start = [start_node]\n        tree_goal = [goal_node]\n        pq_start = PriorityQueue()\n        pq_goal = PriorityQueue()\n        pq_start.add(start_node, start_node.cost + heuristic(start_node.position))\n        pq_goal.add(goal_node, goal_node.cost + heuristic(goal_node.position))\n\n        best_cost = float('inf')\n        best_path = None\n\n        def add_node(tree_nodes, pq, pos, current_best_cost):\n            nearest_node = nearest(tree_nodes, pos)\n            if in_obstacle(pos) or edge_in_obstacle(nearest_node.position, pos):\n                return None\n            new_cost = nearest_node.cost + dist(nearest_node.position, pos)\n            if new_cost >= current_best_cost:\n                return None\n            new_node = Node(pos, parent=nearest_node, cost=new_cost)\n            nearest_node.add_child(new_node)\n            tree_nodes.append(new_node)\n            pq.add(new_node, new_node.cost + heuristic(new_node.position))\n\n            nbrs = neighbors(tree_nodes, new_node, self.neighbor_radius)\n            for nbr in nbrs:\n                if nbr is new_node.parent:\n                    continue\n                cost_through_new = new_node.cost + dist(new_node.position, nbr.position)\n                if cost_through_new + 1e-8 < nbr.cost and not edge_in_obstacle(new_node.position, nbr.position):\n                    # Rewire neighbor\n                    if nbr.parent:\n                        nbr.parent.remove_child(nbr)\n                    new_node.add_child(nbr)\n                    cost_diff = nbr.cost - cost_through_new\n                    nbr.cost = cost_through_new\n                    # Update downstream costs\n                    stack = [nbr]\n                    while stack:\n                        current = stack.pop()\n                        for c in current.children:\n                            new_c_cost = current.cost + dist(current.position, c.position)\n                            if new_c_cost + 1e-8 < c.cost:\n                                c.cost = new_c_cost\n                                stack.append(c)\n                    pq.add(nbr, nbr.cost + heuristic(nbr.position))\n            return new_node\n\n        for i in range(self.max_iter):\n            if i % 2 == 0:\n                tree_a, pq_a = tree_start, pq_start\n                tree_b, pq_b = tree_goal, pq_goal\n                current_best = best_cost\n                sample_goal = goal\n            else:\n                tree_a, pq_a = tree_goal, pq_goal\n                tree_b, pq_b = tree_start, pq_start\n                current_best = best_cost\n                sample_goal = start\n\n            if random.random() < self.goal_sample_rate:\n                sample = sample_goal if not in_obstacle(sample_goal) else sample_uniform()\n            else:\n                sample = sample_informed(current_best)\n\n            new_node_a = add_node(tree_a, pq_a, sample, current_best)\n            if not new_node_a:\n                continue\n\n            nearest_b = nearest(tree_b, new_node_a.position)\n            if not in_obstacle(new_node_a.position) and not edge_in_obstacle(nearest_b.position, new_node_a.position):\n                cost_b = nearest_b.cost + dist(nearest_b.position, new_node_a.position)\n                total_cost = new_node_a.cost + cost_b\n                if total_cost + 1e-8 < best_cost:\n                    best_cost = total_cost\n                    new_node_b = Node(new_node_a.position, parent=nearest_b, cost=cost_b)\n                    nearest_b.add_child(new_node_b)\n                    tree_b.append(new_node_b)\n                    pq_b.add(new_node_b, new_node_b.cost + heuristic(new_node_b.position))\n                    # Extract path from start to goal via new_node_a and new_node_b\n                    if i % 2 == 0:\n                        path_start = new_node_a.path_from_root()\n                        path_goal = new_node_b.path_from_root()\n                    else:\n                        path_start = new_node_b.path_from_root()\n                        path_goal = new_node_a.path_from_root()\n                    if path_start[-1] == path_goal[-1]:\n                        full_path = path_start + path_goal[-2::-1]\n                    else:\n                        full_path = path_start + path_goal[::-1]\n                    best_path = shortcut_path(full_path)\n                    return PlannerResult(success=True, path=best_path,\n                                         nodes=tree_start + tree_goal, edges=[])\n\n        return PlannerResult(success=False, path=[], nodes=tree_start + tree_goal, edges=[])",
          "objective": -31.50617,
          "time_improvement": 73.0,
          "length_improvement": -2.0,
          "smoothness_improvement": 2107.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.014693832397460938,
                    "num_nodes_avg": 76.7,
                    "path_length_avg": 189.2865918731709,
                    "smoothness_avg": 0.1024029442675328,
                    "success_improvement": 0.0,
                    "time_improvement": 44.02950442411974,
                    "length_improvement": -3.7509804436760463,
                    "smoothness_improvement": 1502.8284493395454,
                    "objective_score": 18.47240530772802
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.003192305564880371,
                    "num_nodes_avg": 53.5,
                    "path_length_avg": 272.4130893881122,
                    "smoothness_avg": 0.12310940990411035,
                    "success_improvement": 0.0,
                    "time_improvement": 98.06690993615078,
                    "length_improvement": 9.060669786224826,
                    "smoothness_improvement": 3067.693788956559,
                    "objective_score": 50.194943797362924
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.011048078536987305,
                    "num_nodes_avg": 115.9,
                    "path_length_avg": 166.41128938470322,
                    "smoothness_avg": 0.14553274592145063,
                    "success_improvement": 0.0,
                    "time_improvement": 78.02939213023721,
                    "length_improvement": -10.52245475526155,
                    "smoothness_improvement": 1751.1657860109547,
                    "objective_score": 25.851173715969004
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "An improved single-tree RRT with goal bias and incremental path smoothing. The planner grows a single tree from the start towards random samples or the goal with a fixed step size, uses efficient nearest node search, rigorous collision checking at nodes and edges, and performs incremental shortcut smoothing of newly connected paths to improve both path length and smoothness without costly rewiring. This balances efficiency, path quality, and computational cost.",
          "planning_mechanism": "The algorithm grows one tree from the start position toward randomly sampled points or with bias towards the goal, incrementally extending nodes while avoiding obstacles. It terminates early upon connecting directly to the goal within step size. Whenever a connection is made, a shortcutting smoothing step is applied on the resulting partial path immediately to reduce jagged segments, thus improving smoothness and path length without complex rewiring.",
          "code": "class Node:\n    def __init__(self, position, parent=None):\n        self.position = position\n        self.parent = parent\n        self.children = []\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n    def path_from_root(self):\n        path, node = [], self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=4000, step_size=6.0, goal_sample_rate=0.1, smooth_iters=30):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.smooth_iters = smooth_iters\n\n    def plan(self, map):\n        import random, math\n\n        bounds = map.size\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        tree = [Node(start)]\n        nodes = tree[:]\n        edges = []\n\n        def in_obstacle(p):\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d = obs\n                    if x <= p[0] <= x+w and y <= p[1] <= y+h and z <= p[2] <= z+d:\n                        return True\n                else:\n                    x,y,w,h = obs\n                    if x <= p[0] <= x+w and y <= p[1] <= y+h:\n                        return True\n            return False\n\n        def edge_collision(p1,p2,res=1.0):\n            dist = math.dist(p1,p2)\n            steps = max(1,int(dist/res))\n            for i in range(1,steps+1):\n                ip = tuple(p1[d] + (p2[d]-p1[d]) * i/steps for d in range(dim))\n                if in_obstacle(ip):\n                    return True\n            return False\n\n        def sample_free():\n            r = random.random()\n            if r < self.goal_sample_rate:\n                return goal\n            while True:\n                pt = tuple(random.uniform(0,bounds[d]) for d in range(dim))\n                if not in_obstacle(pt):\n                    return pt\n\n        def nearest(tree, point):\n            best = None\n            best_dist = float('inf')\n            for node in tree:\n                d = math.dist(node.position, point)\n                if d < best_dist:\n                    best = node\n                    best_dist = d\n            return best\n\n        def steer(from_p, to_p):\n            d = math.dist(from_p, to_p)\n            if d <= self.step_size:\n                return to_p\n            ratio = self.step_size / d\n            return tuple(from_p[d] + ratio * (to_p[d] - from_p[d]) for d in range(dim))\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path[:]\n            p = path[:]\n            for _ in range(self.smooth_iters):\n                if len(p) < 3:\n                    break\n                i = random.randint(0,len(p)-3)\n                j = random.randint(i+2,len(p)-1)\n                if not edge_collision(p[i], p[j]):\n                    p = p[:i+1] + p[j:]\n            return p\n\n        for _ in range(self.max_iter):\n            rand_pt = sample_free()\n            nearest_node = nearest(tree, rand_pt)\n            new_pos = steer(nearest_node.position, rand_pt)\n            if in_obstacle(new_pos) or edge_collision(nearest_node.position, new_pos):\n                continue\n            new_node = Node(new_pos, nearest_node)\n            nearest_node.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n\n            # Check if goal reached sufficiently closely and edge not in collision\n            if math.dist(new_pos, goal) <= self.step_size and not edge_collision(new_pos, goal):\n                goal_node = Node(goal, new_node)\n                new_node.add_child(goal_node)\n                tree.append(goal_node)\n                nodes.append(goal_node)\n                edges.append((new_node, goal_node))\n                path = goal_node.path_from_root()\n                smooth_path = shortcut_path(path)\n                return PlannerResult(True, smooth_path, nodes, edges)\n        return PlannerResult(False, [], nodes, edges)",
          "objective": -29.54917,
          "time_improvement": 65.0,
          "length_improvement": 11.0,
          "smoothness_improvement": 732.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.01264190673828125,
                    "num_nodes_avg": 251.0,
                    "path_length_avg": 177.46674489907502,
                    "smoothness_avg": 0.026830913377190374,
                    "success_improvement": 0.0,
                    "time_improvement": 51.845524977681876,
                    "length_improvement": 2.7276649802869177,
                    "smoothness_improvement": 319.96205861397976,
                    "objective_score": 18.79006677454661
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.039261603355407716,
                    "num_nodes_avg": 773.3,
                    "path_length_avg": 252.5749846219017,
                    "smoothness_avg": 0.03931518900385589,
                    "success_improvement": 0.0,
                    "time_improvement": 76.22526609855663,
                    "length_improvement": 15.683200165371181,
                    "smoothness_improvement": 911.6081306552461,
                    "objective_score": 36.835540582065924
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.016443514823913576,
                    "num_nodes_avg": 421.9,
                    "path_length_avg": 130.45390021590327,
                    "smoothness_avg": 0.0835968046133641,
                    "success_improvement": 0.0,
                    "time_improvement": 67.29983272771409,
                    "length_improvement": 13.358731023780487,
                    "smoothness_improvement": 963.3451842077347,
                    "objective_score": 33.02191435362119
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "initial",
          "algorithm_description": "This algorithm grows two trees simultaneously, one from the start position and one from the goal position, and attempts to connect them to find a feasible path. This bidirectional approach accelerates convergence and increases the success rate compared to a single tree RRT.",
          "planning_mechanism": "The planning mechanism involves randomly sampling points within the map bounds, extending each tree towards the sampled points, and attempting to connect the two trees whenever new nodes are added. Collision checks are performed for nodes and edges to ensure safety, and once the two trees connect, the final path is reconstructed by backtracking through the parent nodes of each tree.",
          "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map) -> PlannerResult:\n        import math, random\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position)\n        goal_root = Node(goal_position)\n        nodes.extend([start_root, goal_root])\n        tree_a, tree_b = [start_root], [goal_root]\n\n        for _ in range(self.max_iter):\n            rand_point = self._sample_free(bounds, obstacles, is_3d)\n            new_a = self._extend_tree(tree_a, rand_point, obstacles, is_3d, nodes, edges)\n            if new_a is None:\n                continue\n\n            new_b = self._connect_trees(tree_b, new_a, obstacles, is_3d, nodes, edges)\n            if new_b:\n                success_state = True\n                path_a = new_a.path_from_root()\n                path_b = new_b.path_from_root()\n                extracted_path = path_a + path_b[::-1]\n                break\n\n            tree_a, tree_b = tree_b, tree_a  # Swap trees\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        import random\n        while True:\n            if is_3d:\n                p = (random.uniform(0, bounds[0]),\n                     random.uniform(0, bounds[1]),\n                     random.uniform(0, bounds[2]))\n            else:\n                p = (random.uniform(0, bounds[0]),\n                     random.uniform(0, bounds[1]))\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    def _nearest(self, tree, point):\n        import math\n        return min(tree, key=lambda node: math.dist(node.position, point))\n\n    def _steer(self, from_pos, to_pos):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _extend_tree(self, tree, point, obstacles, is_3d, nodes, edges):\n        nearest_node = self._nearest(tree, point)\n        new_pos = self._steer(nearest_node.position, point)\n        if not self._is_in_obstacle(new_pos, obstacles, is_3d) and not self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n            new_node = Node(new_pos, parent=nearest_node)\n            nearest_node.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n            return new_node\n        return None\n\n    def _connect_trees(self, tree, new_node, obstacles, is_3d, nodes, edges):\n        import math\n        nearest_node = self._nearest(tree, new_node.position)\n        while True:\n            new_pos = self._steer(nearest_node.position, new_node.position)\n            if (not self._is_in_obstacle(new_pos, obstacles, is_3d) and\n                not self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d)):\n                next_node = Node(new_pos, parent=nearest_node)\n                nearest_node.add_child(next_node)\n                tree.append(next_node)\n                nodes.append(next_node)\n                edges.append((nearest_node, next_node))\n\n                if math.dist(next_node.position, new_node.position) <= self.step_size:\n                    if not self._is_edge_in_obstacle(next_node.position, new_node.position, obstacles, is_3d):\n                        final_node = Node(new_node.position, parent=next_node)\n                        next_node.add_child(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((next_node, final_node))\n                        return final_node\n                    else:\n                        return None\n                nearest_node = next_node\n            else:\n                return None\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n",
          "objective": -28.87615591314666,
          "time_improvement": 93.0,
          "length_improvement": 1.0,
          "smoothness_improvement": 69.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.0022002458572387695,
                    "num_nodes_avg": 57.5,
                    "path_length_avg": 171.4810676267031,
                    "smoothness_avg": 0.011144018674089623,
                    "success_improvement": 0.0,
                    "time_improvement": 91.61901077354663,
                    "length_improvement": 6.008509542400028,
                    "smoothness_improvement": 74.42809187338179,
                    "objective_score": 31.462949416870917
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.009090876579284668,
                    "num_nodes_avg": 226.2,
                    "path_length_avg": 305.50514541182173,
                    "smoothness_avg": 0.00636488258654892,
                    "success_improvement": 0.0,
                    "time_improvement": 94.49504979083876,
                    "length_improvement": -1.986411016509145,
                    "smoothness_improvement": 63.77301339152637,
                    "objective_score": 27.475533394303774
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.004314684867858886,
                    "num_nodes_avg": 127.6,
                    "path_length_avg": 150.78647946614691,
                    "smoothness_avg": 0.013383825302451875,
                    "success_improvement": 0.0,
                    "time_improvement": 91.41966188998718,
                    "length_improvement": -0.14519998085115468,
                    "smoothness_improvement": 70.24126995596559,
                    "objective_score": 27.68998492826529
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "An improved bidirectional sampling-based planner combining informed heuristic sampling with adaptive rewiring and lazy collision checking to enhance planning speed, path quality, and smoothness. The planner alternates forward and backward tree expansions, samples inside an informed ellipsoid for efficient search, applies rewiring with adaptive radius to optimize connectivity, and performs path shortcutting to smooth the final solution.",
          "planning_mechanism": "The planner grows two trees from start and goal, uses adaptive informed sampling focused on the current best solution corridor to accelerate convergence, rewires local connections based on adaptive neighborhoods to improve path cost, delays expensive collision checks (lazy evaluation) until necessary to reduce redundant computations, attempts direct tree connections to find feasible paths quickly, and post-processes the resulting path via shortcutting for smoothness and length reduction.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n    def add_child(self, child):\n        self.children.append(child)\nclass Planner:\n    def __init__(self, max_iter=4000, step_size=6.0, base_rewire_radius=12.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.base_rewire_radius = base_rewire_radius\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        edges = []\n        best_cost = float('inf')\n        best_path = []\n\n        def dist(a,b):\n            return math.dist(a,b)\n\n        def in_collision(p):\n            for o in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d = o\n                    px,py,pz = p\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                        return True\n                else:\n                    x,y,w,h = o\n                    px,py = p\n                    if x <= px <= x+w and y <= py <= y+h:\n                        return True\n            return False\n\n        def edge_collision(p1,p2,res=1.0):\n            distance = dist(p1,p2)\n            steps = max(1,int(distance/res))\n            for i in range(steps+1):\n                interp = tuple(p1[d]+(p2[d]-p1[d])*i/steps for d in range(dim))\n                if in_collision(interp):\n                    return True\n            return False\n\n        def steer(from_p,to_p,step):\n            distance = dist(from_p,to_p)\n            if distance <= step:\n                return to_p\n            ratio = step / distance\n            return tuple(from_p[i] + (to_p[i]-from_p[i])*ratio for i in range(dim))\n\n        def nearest(tree, p):\n            return min(tree, key=lambda n: dist(n.position, p))\n\n        def near(tree, p, radius):\n            r2 = radius**2\n            result = []\n            for n in tree:\n                d2 = sum((n.position[i]-p[i])**2 for i in range(dim))\n                if d2 <= r2:\n                    result.append(n)\n            return result\n\n        def extract_path(n_start, n_goal):\n            path_start, path_goal = [], []\n            while n_start:\n                path_start.append(n_start.position)\n                n_start = n_start.parent\n            while n_goal:\n                path_goal.append(n_goal.position)\n                n_goal = n_goal.parent\n            path_start.reverse()\n            return path_start + path_goal\n\n        def shortcut(path):\n            if len(path) <= 2:\n                return path\n            i = 0\n            while i < len(path)-2:\n                j = len(path)-1\n                while j > i+1:\n                    if not edge_collision(path[i], path[j]):\n                        path = path[:i+1] + path[j:]\n                        break\n                    j -= 1\n                i += 1\n            return path\n\n        def informed_sample(c_best):\n            if c_best == float('inf'):\n                while True:\n                    sample = tuple(random.uniform(0,bounds[i]) for i in range(dim))\n                    if not in_collision(sample):\n                        return sample\n            c_min = dist(start_pos, goal_pos)\n            if c_min == 0.0:\n                return goal_pos\n            center = tuple((start_pos[i]+goal_pos[i])*0.5 for i in range(dim))\n            a1 = [(goal_pos[i]-start_pos[i])/c_min for i in range(dim)]\n\n            # rotation matrix R that aligns x-axis with a1 (2D/3D only)\n            def mat_vec_mult(mat, vec):\n                return tuple(sum(mat[i][j]*vec[j] for j in range(dim)) for i in range(dim))\n\n            if dim == 2:\n                theta = math.acos(max(min(a1[0],1.0),-1.0))\n                if a1[1]<0:\n                    theta = -theta\n                R = [[math.cos(theta), -math.sin(theta)],\n                     [math.sin(theta), math.cos(theta)]]\n            elif dim == 3:\n                x = a1\n                I = [[1 if i==j else 0 for j in range(3)] for i in range(3)]\n                v = [x[0]-1, x[1], x[2]]\n                norm_v = math.sqrt(sum(vi*vi for vi in v))\n                if norm_v < 1e-10:\n                    R = I\n                else:\n                    v = [vi/norm_v for vi in v]\n                    R = [[I[i][j]-2*v[i]*v[j] for j in range(3)] for i in range(3)]\n            else:\n                R = [[1 if i==j else 0 for j in range(dim)] for i in range(dim)]\n\n            L1 = c_best/2.0\n            L2 = math.sqrt(max(c_best*c_best - c_min*c_min,0))/2.0\n\n            while True:\n                while True:\n                    sample = [random.uniform(-1,1) for _ in range(dim)]\n                    norm_s = math.sqrt(sum(x*x for x in sample))\n                    if norm_s > 0 and norm_s <= 1:\n                        break\n                unit_s = [x/norm_s for x in sample]\n                r = random.uniform(0,1)**(1/dim)\n                unit_ball = [r * us for us in unit_s]\n                ellip = [L1*unit_ball[0]] + [L2*unit_ball[i] for i in range(1,dim)]\n                rotated = mat_vec_mult(R, ellip)\n                point = tuple(center[i] + rotated[i] for i in range(dim))\n                if all(0 <= point[i] <= bounds[i] for i in range(dim)) and not in_collision(point):\n                    return point\n\n        # adaptive rewire radius decreases as tree grows (based on RRT* formula)\n        def rewire_radius(num_nodes):\n            gamma_rrt = 2 * (1 + 1/dim)**(1/dim) * (math.prod(bounds)**(1/dim))\n            radius = min(self.base_rewire_radius, gamma_rrt * (math.log(num_nodes+1)/(num_nodes+1))**(1/dim))\n            return radius\n\n        def rewire(tree, new_node):\n            r = rewire_radius(len(tree))\n            nbs = near(tree, new_node.position, r)\n            for nb in nbs:\n                if nb == new_node.parent:\n                    continue\n                if edge_collision(new_node.position, nb.position):\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, nb.position)\n                if new_cost + 1e-9 < nb.cost:\n                    if nb.parent:\n                        try:\n                            nb.parent.children.remove(nb)\n                        except Exception:\n                            pass\n                    nb.parent = new_node\n                    nb.cost = new_cost\n                    new_node.add_child(nb)\n\n        for it in range(self.max_iter):\n            sample = informed_sample(best_cost)\n            for tree_a, tree_b in [(start_tree, goal_tree),(goal_tree, start_tree)]:\n                nearest_node = nearest(tree_a, sample)\n                new_pos = steer(nearest_node.position, sample, self.step_size)\n                if in_collision(new_pos):\n                    continue\n                if edge_collision(nearest_node.position, new_pos):\n                    continue\n                new_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n                new_node = Node(new_pos, parent=nearest_node, cost=new_cost)\n                nearest_node.add_child(new_node)\n                tree_a.append(new_node)\n                edges.append((nearest_node,new_node))\n                rewire(tree_a, new_node)\n\n                connect_node = nearest(tree_b, new_pos)\n                gap = dist(new_pos, connect_node.position)\n                if gap <= self.step_size*1.8 and not edge_collision(new_pos, connect_node.position):\n                    connect_new = Node(connect_node.position, parent=new_node, cost=new_node.cost+gap)\n                    new_node.add_child(connect_new)\n                    tree_b.append(connect_new)\n                    edges.append((new_node, connect_new))\n                    path = extract_path(connect_new, connect_node)\n                    path = shortcut(path)\n                    cost_path = 0.0\n                    for i in range(len(path)-1):\n                        cost_path += dist(path[i], path[i+1])\n                    if cost_path < best_cost:\n                        best_cost = cost_path\n                        best_path = path\n            if best_path:\n                return PlannerResult(True,best_path,start_tree+goal_tree,edges)\n        return PlannerResult(False,[],start_tree+goal_tree,edges)",
          "objective": -28.64627,
          "time_improvement": 37.0,
          "length_improvement": 14.0,
          "smoothness_improvement": 1851.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.027629590034484862,
                    "num_nodes_avg": 116.4,
                    "path_length_avg": 170.26662958714778,
                    "smoothness_avg": 0.06141652618419348,
                    "success_improvement": 0.0,
                    "time_improvement": -5.244282428030285,
                    "length_improvement": 6.674162275882516,
                    "smoothness_improvement": 861.3020029038676,
                    "objective_score": 6.737722651639762
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.031986331939697264,
                    "num_nodes_avg": 221.9,
                    "path_length_avg": 238.03820887872735,
                    "smoothness_avg": 0.12286205335960987,
                    "success_improvement": 0.0,
                    "time_improvement": 80.63078261308962,
                    "length_improvement": 20.535994326332737,
                    "smoothness_improvement": 3061.329126902844,
                    "objective_score": 51.817477014240744
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.032309651374816895,
                    "num_nodes_avg": 180.3,
                    "path_length_avg": 129.22310027085973,
                    "smoothness_avg": 0.13606286458102096,
                    "success_improvement": 0.0,
                    "time_improvement": 35.74786073539117,
                    "length_improvement": 14.176169742883147,
                    "smoothness_improvement": 1630.7095943546199,
                    "objective_score": 27.383608038120336
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "An improved single-tree RRT with goal bias that incrementally extends the tree toward random samples or the goal, performs direct collision checks before adding nodes and edges, and applies path shortcutting to improve path smoothness and length as soon as a path to the goal is found. This approach balances planning speed, path quality, and computational simplicity.",
          "planning_mechanism": "The planner grows a single tree from the start by sampling points with goal bias, steering toward samples within a fixed step size, and ensuring collision-free nodes and edges. Upon connecting to the goal, it extracts the path and applies multiple shortcut attempts to smooth and shorten it.",
          "code": "class Node:\n    def __init__(self, position, parent=None):\n        self.position = position\n        self.parent = parent\n        self.children = []\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n    def path_from_root(self):\n        path, node = [], self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=4000, step_size=6.0, goal_sample_rate=0.1, smooth_iters=30):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.smooth_iters = smooth_iters\n\n    def plan(self, map):\n        import random, math\n\n        start = map.start\n        goal = map.goal\n        bounds = map.size\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = dim == 3\n\n        def in_obstacle(p):\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d = obs\n                    if x <= p[0] <= x+w and y <= p[1] <= y+h and z <= p[2] <= z+d:\n                        return True\n                else:\n                    x,y,w,h = obs\n                    if x <= p[0] <= x+w and y <= p[1] <= y+h:\n                        return True\n            return False\n\n        def edge_collision(p1,p2,res=1.0):\n            dist = math.dist(p1,p2)\n            steps = max(1, int(dist/res))\n            for i in range(1, steps+1):\n                ip = tuple(p1[d] + (p2[d]-p1[d]) * i/steps for d in range(dim))\n                if in_obstacle(ip):\n                    return True\n            return False\n\n        def sample_point():\n            if random.random() < self.goal_sample_rate:\n                return goal\n            while True:\n                pt = tuple(random.uniform(0,bounds[d]) for d in range(dim))\n                if not in_obstacle(pt):\n                    return pt\n\n        def nearest_node(tree, point):\n            best, best_dist = None, float('inf')\n            for node in tree:\n                dist = math.dist(node.position, point)\n                if dist < best_dist:\n                    best, best_dist = node, dist\n            return best\n\n        def steer(from_p, to_p):\n            dist = math.dist(from_p, to_p)\n            if dist <= self.step_size:\n                return to_p\n            ratio = self.step_size / dist\n            return tuple(from_p[d] + ratio*(to_p[d] - from_p[d]) for d in range(dim))\n\n        def shortcut_path(path):\n            p = path[:]\n            for _ in range(self.smooth_iters):\n                if len(p) < 3:\n                    break\n                i = random.randint(0, len(p)-3)\n                j = random.randint(i+2, len(p)-1)\n                if not edge_collision(p[i], p[j]):\n                    p = p[:i+1] + p[j:]\n            return p\n\n        tree = [Node(start)]\n\n        for _ in range(self.max_iter):\n            rand_pt = sample_point()\n            nearest = nearest_node(tree, rand_pt)\n            new_pos = steer(nearest.position, rand_pt)\n            if in_obstacle(new_pos) or edge_collision(nearest.position, new_pos):\n                continue\n            new_node = Node(new_pos, nearest)\n            nearest.add_child(new_node)\n            tree.append(new_node)\n\n            if math.dist(new_pos, goal) <= self.step_size and not edge_collision(new_pos, goal):\n                goal_node = Node(goal, new_node)\n                new_node.add_child(goal_node)\n                tree.append(goal_node)\n                path = goal_node.path_from_root()\n                smooth_path = shortcut_path(path)\n                return PlannerResult(True, smooth_path, tree, [(n.parent, n) for n in tree if n.parent])\n\n        return PlannerResult(False, [], tree, [(n.parent, n) for n in tree if n.parent])",
          "objective": -28.58352,
          "time_improvement": 65.0,
          "length_improvement": 9.0,
          "smoothness_improvement": 764.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.013500356674194336,
                    "num_nodes_avg": 234.0,
                    "path_length_avg": 181.91284921967247,
                    "smoothness_avg": 0.02454238749256365,
                    "success_improvement": 0.0,
                    "time_improvement": 48.57559055618673,
                    "length_improvement": 0.2906847491360036,
                    "smoothness_improvement": 284.1416589060716,
                    "objective_score": 16.167796310867978
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.043396592140197754,
                    "num_nodes_avg": 822.3,
                    "path_length_avg": 255.7830699481661,
                    "smoothness_avg": 0.04489486357795229,
                    "success_improvement": 0.0,
                    "time_improvement": 73.72133733248153,
                    "length_improvement": 14.612248943847922,
                    "smoothness_improvement": 1055.177176323898,
                    "objective_score": 36.159636447672696
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.013333845138549804,
                    "num_nodes_avg": 401.4,
                    "path_length_avg": 133.9702026300119,
                    "smoothness_avg": 0.08276683709463699,
                    "success_improvement": 0.0,
                    "time_improvement": 73.48383413871842,
                    "length_improvement": 11.023370388657252,
                    "smoothness_improvement": 952.7880586313554,
                    "objective_score": 33.42311276796666
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "An enhanced bidirectional Rapidly-exploring Random Tree planner with goal bias, adaptive sampling within bounds, and incremental local rewiring for path optimization. It grows two trees alternately, extends them towards sampled points with collision checking, rewires nearby nodes to improve path costs efficiently, and attempts connection between trees each iteration. Upon connection, it reconstructs and shortcuts the path to achieve better length and smoothness with efficient use of collision checks and node management.",
          "planning_mechanism": "The planner uses alternating expansions from start and goal trees guided by goal-biased random sampling, adaptive steering steps, localized rewiring within a computed neighborhood radius to optimize paths incrementally, and attempts fast tree connections. It maintains nodes and edges coherently and applies shortcutting at the end to improve smoothness and path quality while respecting obstacle and map bounds constraints.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.children = []\n        self.cost = cost\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        path, node = [], self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=3000, step_size=6.0, goal_sample_rate=0.1, rewire_factor=1.5):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.rewire_factor = rewire_factor\n\n    def plan(self, map):\n        bounds = map.size\n        start, goal = map.start, map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = dim == 3\n\n        start_tree = [Node(start)]\n        goal_tree = [Node(goal)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        def in_obstacle(p):\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d = obs\n                    if x <= p[0] <= x+w and y <= p[1] <= y+h and z <= p[2] <= z+d:\n                        return True\n                else:\n                    x,y,w,h = obs\n                    if x <= p[0] <= x+w and y <= p[1] <= y+h:\n                        return True\n            return False\n\n        def edge_in_obstacle(p1, p2, resolution=1.0):\n            dist = self._dist(p1,p2)\n            steps = max(1, int(dist / resolution))\n            for i in range(steps+1):\n                interp = tuple(p1[d] + (p2[d]-p1[d])*i/steps for d in range(dim))\n                if in_obstacle(interp):\n                    return True\n            return False\n\n        def sample_free():\n            import random\n            if random.random() < self.goal_sample_rate:\n                return goal\n            while True:\n                p = tuple(random.uniform(0,bounds[d]) for d in range(dim))\n                if not in_obstacle(p):\n                    return p\n\n        def nearest(tree, point):\n            min_dist, nearest_node = float('inf'), None\n            for node in tree:\n                dist = self._dist(node.position, point)\n                if dist < min_dist:\n                    min_dist = dist\n                    nearest_node = node\n            return nearest_node\n\n        def near(tree, point, radius):\n            radius_sq = radius*radius\n            return [n for n in tree if self._dist_sq(n.position, point) <= radius_sq]\n\n        def steer(from_pos, to_pos):\n            dist = self._dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d]-from_pos[d])*ratio for d in range(dim))\n\n        def valid_edge(p1, p2):\n            return (not in_obstacle(p2)) and (not edge_in_obstacle(p1, p2))\n\n        def rewire(new_node, tree, radius):\n            neighbors = near(tree, new_node.position, radius)\n            for neighbor in neighbors:\n                if neighbor is new_node.parent:\n                    continue\n                cost_through_new = new_node.cost + self._dist(new_node.position, neighbor.position)\n                if cost_through_new + 1e-7 < neighbor.cost and valid_edge(new_node.position, neighbor.position):\n                    # Update parent-child connections\n                    if neighbor.parent:\n                        try:\n                            neighbor.parent.children.remove(neighbor)\n                        except ValueError:\n                            pass\n                    neighbor.parent = new_node\n                    neighbor.cost = cost_through_new\n                    new_node.children.append(neighbor)\n                    update_children_costs(neighbor)\n\n        def update_children_costs(node):\n            stack = [node]\n            while stack:\n                current = stack.pop()\n                for child in current.children:\n                    new_cost = current.cost + self._dist(current.position, child.position)\n                    if new_cost + 1e-7 < child.cost:\n                        child.cost = new_cost\n                        child.parent = current\n                        stack.append(child)\n\n        def extend(tree, sample_point):\n            nearest_node = nearest(tree, sample_point)\n            new_pos = steer(nearest_node.position, sample_point)\n            if not valid_edge(nearest_node.position, new_pos):\n                return None\n            # Determine near nodes for possible better parent\n            rewire_radius = min(self.rewire_factor * (self.step_size * (len(nodes)+1)**(-1.0/(dim+1))), self.step_size*8)\n            near_nodes = near(tree, new_pos, rewire_radius)\n            cost_min = nearest_node.cost + self._dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for near_node in near_nodes:\n                cost_through_near = near_node.cost + self._dist(near_node.position, new_pos)\n                if cost_through_near + 1e-7 < cost_min and valid_edge(near_node.position, new_pos):\n                    best_parent = near_node\n                    cost_min = cost_through_near\n            new_node = Node(new_pos, best_parent, cost_min)\n            best_parent.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n            rewire(new_node, tree, rewire_radius)\n            return new_node\n\n        def connect(tree, target_node):\n            current = nearest(tree, target_node.position)\n            while True:\n                new_pos = steer(current.position, target_node.position)\n                if not valid_edge(current.position, new_pos):\n                    return None\n                new_cost = current.cost + self._dist(current.position, new_pos)\n                new_node = Node(new_pos, current, new_cost)\n                current.add_child(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((current, new_node))\n                # Local rewiring for new_node\n                rewire_radius = min(self.rewire_factor * (self.step_size * (len(nodes)+1)**(-1.0/(dim+1))), self.step_size*8)\n                rewire(new_node, tree, rewire_radius)\n                if self._dist(new_node.position, target_node.position) <= self.step_size:\n                    if valid_edge(new_node.position, target_node.position):\n                        final_cost = new_node.cost + self._dist(new_node.position, target_node.position)\n                        final_node = Node(target_node.position, new_node, final_cost)\n                        new_node.add_child(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n                current = new_node\n\n        def shortcut_path(path):\n            if len(path) <= 2:\n                return path\n            shortcut = [path[0]]\n            i = 0\n            while i < len(path)-1:\n                j = len(path)-1\n                while j > i+1:\n                    if not edge_in_obstacle(path[i], path[j]):\n                        break\n                    j -= 1\n                shortcut.append(path[j])\n                i = j\n            return shortcut\n\n        for iter_count in range(self.max_iter):\n            expanding_tree, other_tree = (start_tree, goal_tree) if iter_count % 2 == 0 else (goal_tree, start_tree)\n            sample = sample_free()\n            new_node = extend(expanding_tree, sample)\n            if new_node is None:\n                continue\n            connected_node = connect(other_tree, new_node)\n            if connected_node:\n                path_start = new_node.path_from_root()\n                path_goal = connected_node.path_from_root()\n                if path_start[-1] == path_goal[-1]:\n                    full_path = path_start + path_goal[-2::-1]\n                else:\n                    full_path = path_start + path_goal[::-1]\n                short_path = shortcut_path(full_path)\n                return PlannerResult(True, short_path, nodes, edges)\n\n        return PlannerResult(False, [], nodes, edges)\n\n    def _dist(self, a,b):\n        return sum((a[d]-b[d])**2 for d in range(len(a)))**0.5\n\n    def _dist_sq(self, a,b):\n        return sum((a[d]-b[d])**2 for d in range(len(a)))",
          "objective": -28.34614,
          "time_improvement": 33.0,
          "length_improvement": 16.0,
          "smoothness_improvement": 1738.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.015407323837280273,
                    "num_nodes_avg": 72.7,
                    "path_length_avg": 166.0049115375396,
                    "smoothness_avg": 0.051653195366249294,
                    "success_improvement": 0.0,
                    "time_improvement": 41.31173356654978,
                    "length_improvement": 9.010077470116768,
                    "smoothness_improvement": 708.4846741908297,
                    "objective_score": 21.341989922989143
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.04900016784667969,
                    "num_nodes_avg": 218.4,
                    "path_length_avg": 232.8627485806196,
                    "smoothness_avg": 0.10944763653939235,
                    "success_improvement": 0.0,
                    "time_improvement": 70.32811061903782,
                    "length_improvement": 22.26371194120606,
                    "smoothness_improvement": 2716.1665201047535,
                    "objective_score": 48.03749295095875
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.056807971000671385,
                    "num_nodes_avg": 184.6,
                    "path_length_avg": 123.96611989729759,
                    "smoothness_avg": 0.14857794458806553,
                    "success_improvement": 0.0,
                    "time_improvement": -12.97038218493259,
                    "length_improvement": 17.667605796498194,
                    "smoothness_improvement": 1789.900488277112,
                    "objective_score": 15.658951263804699
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m1",
          "algorithm_description": "A bidirectional RRT* inspired planner that grows two trees from start and goal by incrementally extending toward random free samples, rewiring to optimize path costs, and attempting to connect trees when new nodes are added. It uses adaptive sampling bias to improve convergence, incremental collision-checked edge extensions with variable step sizes, and post-processing path smoothing via shortcutting to improve smoothness and path quality.",
          "planning_mechanism": "A planner that iteratively samples free configurations, extends both trees towards samples using cost-aware rewiring to optimize the tree structure, tries to connect the two trees, and once connected, extracts an optimized path with path shortcutting to reduce detours and jagged motions, resulting in faster planning and higher quality, smoother paths.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position      # Tuple[float, ...]\n        self.parent = parent          # Node or None\n        self.children = []            # List of child nodes\n        self.cost = cost              # Cost to come from root\n    \n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=5.0, rewire_radius=15.0, shortcut_iters=50):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.rewire_radius = rewire_radius\n        self.shortcut_iters = shortcut_iters\n\n    def plan(self, map):\n        import math, random\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        tree_start = [Node(start_pos)]\n        tree_goal = [Node(goal_pos)]\n        nodes = tree_start + tree_goal\n        edges = []\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            ratio = self.step_size / d\n            return tuple(from_pos[i] + ratio * (to_pos[i] - from_pos[i]) for i in range(len(from_pos)))\n\n        def in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d = obs\n                    px,py,pz = pos\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                        return True\n                else:\n                    x,y,w,h = obs\n                    px,py = pos\n                    if x <= px <= x+w and y <= py <= y+h:\n                        return True\n            return False\n\n        def edge_in_obstacle(p1, p2, resolution=1.0):\n            d = dist(p1, p2)\n            steps = max(1, int(d / resolution))\n            for i in range(steps+1):\n                interp = tuple(p1[j] + (p2[j]-p1[j]) * (i/steps) for j in range(len(p1)))\n                if in_obstacle(interp):\n                    return True\n            return False\n\n        def sample_free():\n            # Adaptive biasing: With 10% chance sample goal or start to steer faster\n            r = random.random()\n            if r < 0.05:\n                return goal_pos\n            elif r < 0.1:\n                return start_pos\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                if not in_obstacle(pt):\n                    return pt\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: dist(node.position, point))\n\n        def neighbors(tree, point, radius):\n            return [node for node in tree if dist(node.position, point) <= radius]\n\n        def rewire(tree, new_node):\n            near_nodes = neighbors(tree, new_node.position, self.rewire_radius)\n            for near_node in near_nodes:\n                if near_node is new_node.parent:\n                    continue\n                if not edge_in_obstacle(new_node.position, near_node.position):\n                    new_cost = new_node.cost + dist(new_node.position, near_node.position)\n                    if new_cost < near_node.cost:\n                        # Rewire near_node under new_node\n                        if near_node.parent:\n                            near_node.parent.remove_child(near_node)\n                        near_node.parent = new_node\n                        new_node.add_child(near_node)\n                        near_node.cost = new_cost\n                        # Update subtree costs recursively\n                        self._update_costs(near_node)\n\n        def extend(tree, sample_pt):\n            nearest_node = nearest(tree, sample_pt)\n            new_pos = steer(nearest_node.position, sample_pt)\n            if in_obstacle(new_pos) or edge_in_obstacle(nearest_node.position, new_pos):\n                return None\n            new_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            new_node = Node(new_pos, parent=nearest_node, cost=new_cost)\n            nearest_node.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n            # Rewire to improve paths\n            rewire(tree, new_node)\n            return new_node\n\n        def update_costs(node):\n            for child in node.children:\n                child.cost = node.cost + dist(node.position, child.position)\n                update_costs(child)\n\n        self._update_costs = update_costs  # assign for recursive calls inside rewire\n\n        def connect_trees(tree_a, tree_b, new_node_b):\n            nearest_in_a = nearest(tree_a, new_node_b.position)\n            last_new = new_node_b\n            while True:\n                next_pos = steer(nearest_in_a.position, last_new.position)\n                if in_obstacle(next_pos) or edge_in_obstacle(nearest_in_a.position, next_pos):\n                    return None\n                new_cost = nearest_in_a.cost + dist(nearest_in_a.position, next_pos)\n                next_node = Node(next_pos, parent=nearest_in_a, cost=new_cost)\n                nearest_in_a.add_child(next_node)\n                tree_a.append(next_node)\n                nodes.append(next_node)\n                edges.append((nearest_in_a, next_node))\n                # Rewire tree_a to improve paths\n                rewire(tree_a, next_node)\n                if dist(next_node.position, last_new.position) <= self.step_size:\n                    # Try connecting final edge to last_new\n                    if in_obstacle(last_new.position) or edge_in_obstacle(next_node.position, last_new.position):\n                        return None\n                    final_cost = next_node.cost + dist(next_node.position, last_new.position)\n                    final_node = Node(last_new.position, parent=next_node, cost=final_cost)\n                    next_node.add_child(final_node)\n                    tree_a.append(final_node)\n                    nodes.append(final_node)\n                    edges.append((next_node, final_node))\n                    rewire(tree_a, final_node)\n                    return final_node\n                nearest_in_a = next_node\n\n        def extract_path(node_start, node_goal):\n            path_start = node_start.path_from_root()\n            path_goal = node_goal.path_from_root()\n            # Remove duplicate connection node if positions equal\n            if path_start[-1] == path_goal[-1]:\n                path = path_start + path_goal[-2::-1]\n            else:\n                path = path_start + path_goal[::-1]\n            return path\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path[:]\n            path = path[:]\n            for _ in range(self.shortcut_iters):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path)-3)\n                j = random.randint(i+2, len(path)-1)\n                if not edge_in_obstacle(path[i], path[j]):\n                    # Shortcut exists, remove intermediate points\n                    path = path[:i+1] + path[j:]\n            return path\n\n        # Main planning loop\n        for i in range(self.max_iter):\n            sample_pt = sample_free()\n            # Alternate tree extension for balance\n            trees = (tree_start, tree_goal) if (i % 2 == 0) else (tree_goal, tree_start)\n            new_node = extend(trees[0], sample_pt)\n            if new_node is None:\n                continue\n            connected_node = connect_trees(trees[1], trees[0], new_node)\n            if connected_node:\n                path = extract_path(new_node, connected_node)\n                smooth = shortcut_path(path)\n                return PlannerResult(True, smooth, nodes, edges)\n        return PlannerResult(False, [], nodes, edges)",
          "objective": -26.66239,
          "time_improvement": 37.0,
          "length_improvement": 17.0,
          "smoothness_improvement": 1121.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.013171768188476563,
                    "num_nodes_avg": 69.2,
                    "path_length_avg": 158.52217687945418,
                    "smoothness_avg": 0.027471418800683094,
                    "success_improvement": 0.0,
                    "time_improvement": 49.827221845334265,
                    "length_improvement": 13.111482907731792,
                    "smoothness_improvement": 329.98735937142976,
                    "objective_score": 24.464993095096503
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.05002806186676025,
                    "num_nodes_avg": 263.7,
                    "path_length_avg": 241.49667787737857,
                    "smoothness_avg": 0.0786364533363562,
                    "success_improvement": 0.0,
                    "time_improvement": 69.70567279893451,
                    "length_improvement": 19.38145782807234,
                    "smoothness_improvement": 1923.3725838923956,
                    "objective_score": 42.15743945598574
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.05518603324890137,
                    "num_nodes_avg": 242.7,
                    "path_length_avg": 123.63351542580783,
                    "smoothness_avg": 0.09520698603719767,
                    "success_improvement": 0.0,
                    "time_improvement": -9.744938211665817,
                    "length_improvement": 17.888505849538728,
                    "smoothness_improvement": 1111.0258349444482,
                    "objective_score": 13.364751220945731
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m2",
          "algorithm_description": "A bidirectional RRT* variant that uses informed sampling within an ellipsoidal region (informed RRT*) to bias samples towards the subset of the state space likely to improve the current solution, combined with rewiring for asymptotic optimality. It incorporates direct connection attempts between trees and post-processing shortcutting for smoother, shorter paths.",
          "planning_mechanism": "The planner grows two trees from start and goal alternately, sampling randomly inside an ellipsoid defined by start, goal, and the current best path cost to focus growth in promising areas. Each new node is connected and rewired locally to improve path cost. The trees attempt direct connection when close, and after finding a solution, the planner shortcut-postprocesses the path to enhance smoothness and reduce length.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\nclass Planner:\n    def __init__(self, max_iter=3000, step_size=7.5, rewire_radius=15.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.rewire_radius = rewire_radius\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        edges = []\n        best_cost = float('inf')\n        best_path = []\n\n        def distance(a,b):\n            return math.dist(a,b)\n\n        def is_in_collision(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d = obs\n                    px,py,pz = pos\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                        return True\n                else:\n                    x,y,w,h = obs\n                    px,py = pos\n                    if x <= px <= x+w and y <= py <= y+h:\n                        return True\n            return False\n\n        def is_edge_collision(from_pos, to_pos, resolution=1.0):\n            dist = distance(from_pos, to_pos)\n            steps = max(1,int(dist / resolution))\n            for i in range(steps+1):\n                interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * i/steps for d in range(len(from_pos)))\n                if is_in_collision(interp):\n                    return True\n            return False\n\n        def steer(from_pos, to_pos, max_step):\n            dist = distance(from_pos, to_pos)\n            if dist <= max_step:\n                return to_pos\n            ratio = max_step / dist\n            return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: distance(node.position, point))\n\n        def neighbors(tree, point, radius):\n            result = []\n            r_sq = radius*radius\n            for node in tree:\n                dx = node.position[0] - point[0]\n                dy = node.position[1] - point[1]\n                dz = node.position[2] - point[2] if is_3d else 0.0\n                dist_sq = dx*dx + dy*dy + dz*dz\n                if dist_sq <= r_sq:\n                    result.append(node)\n            return result\n\n        def extract_path(node_start, node_goal):\n            path_start = []\n            while node_start:\n                path_start.append(node_start.position)\n                node_start = node_start.parent\n            path_start.reverse()\n            path_goal = []\n            while node_goal:\n                path_goal.append(node_goal.position)\n                node_goal = node_goal.parent\n            return path_start + path_goal\n\n        def try_connect(node_from, tree_to):\n            near = nearest(tree_to, node_from.position)\n            if is_edge_collision(node_from.position, near.position):\n                return None\n            # direct connection possible, make new node\n            new_node = Node(near.position, parent=node_from, cost=node_from.cost + distance(node_from.position, near.position))\n            node_from.add_child(new_node)\n            tree_to.append(new_node)\n            edges.append((node_from,new_node))\n            return new_node\n\n        def rewire(tree, new_node):\n            nbs = neighbors(tree, new_node.position, self.rewire_radius)\n            for nb in nbs:\n                if nb == new_node.parent:\n                    continue\n                if is_edge_collision(new_node.position, nb.position):\n                    continue\n                new_cost = new_node.cost + distance(new_node.position, nb.position)\n                if new_cost + 1e-7 < nb.cost:\n                    # Rewire nb's parent link\n                    if nb.parent:\n                        try:\n                            nb.parent.children.remove(nb)\n                        except ValueError:\n                            pass\n                    nb.parent = new_node\n                    nb.cost = new_cost\n                    new_node.add_child(nb)\n\n        def informed_sample(c_best):\n            # Sample uniformly inside ellipsoid defined by start, goal, c_best\n            if c_best == float('inf'):\n                # No solution found yet, uniform sample in bounds\n                while True:\n                    sample = tuple(random.uniform(0, bounds[i]) for i in range(len(bounds)))\n                    if not is_in_collision(sample):\n                        return sample\n            else:\n                c_min = distance(start_pos, goal_pos)\n                if c_min == 0.0:\n                    return goal_pos\n                # Ellipsoid parameters\n                center = tuple((start_pos[i]+goal_pos[i])/2 for i in range(len(bounds)))\n                a1 = [(goal_pos[i]-start_pos[i])/c_min for i in range(len(bounds))]\n                # Build rotation matrix to transform unit ball samples\n                # For 2D or 3D the rotation matrix is based on a1 vector\n                # Using Householder transform for rotation to align x-axis with a1\n                dim = len(bounds)\n                def mat_vec_mult(mat, vec):\n                    return tuple(sum(mat[i][j]*vec[j] for j in range(dim)) for i in range(dim))\n                # Construct orthonormal basis with a1 as first basis vector\n                # For 2D and 3D:\n                if dim == 2:\n                    # rotation angle\n                    theta = math.acos(a1[0])\n                    if a1[1]<0:\n                        theta = -theta\n                    # rotation matrix\n                    R = [[math.cos(theta), -math.sin(theta)],\n                         [math.sin(theta), math.cos(theta)]]\n                elif dim ==3:\n                    # Construct a rotation matrix using Householder reflection\n                    # vector to rotate to x = a1\n                    x = a1\n                    I = [[1 if i==j else 0 for j in range(3)] for i in range(3)]\n                    v = [x[0]-1, x[1], x[2]]\n                    norm_v = math.sqrt(sum(vi*vi for vi in v))\n                    if norm_v < 1e-10:\n                        R = I\n                    else:\n                        v = [vi/norm_v for vi in v]\n                        R = [[I[i][j] - 2*v[i]*v[j] for j in range(3)] for i in range(3)]\n                else:\n                    R = [[1 if i==j else 0 for j in range(dim)] for i in range(dim)]\n\n                # lengths of ellipsoid axes\n                L1 = c_best/2.0\n                L_other = math.sqrt(c_best*c_best - c_min*c_min)/2.0\n\n                while True:\n                    # sample random unit vector in unit ball\n                    while True:\n                        sample = [random.uniform(-1,1) for _ in range(dim)]\n                        norm_sample = math.sqrt(sum(x*x for x in sample))\n                        if 0 < norm_sample <= 1:\n                            break\n                    unit_s = [x/norm_sample for x in sample]\n                    r = random.uniform(0,1)**(1/dim)  # radius for uniform ball sampling\n                    unit_ball_sample = [r*us for us in unit_s]\n\n                    # scale by axes\n                    ellipsoid_sample = [L1*unit_ball_sample[0]] + [L_other*unit_ball_sample[i] for i in range(1,dim)]\n\n                    # rotate and translate\n                    if dim == 2 or dim == 3:\n                        rotated = mat_vec_mult(R, ellipsoid_sample)\n                    else:\n                        rotated = ellipsoid_sample\n                    point = tuple(center[i] + rotated[i] for i in range(dim))\n                    if all(0 <= point[i] <= bounds[i] for i in range(dim)):\n                        if not is_in_collision(point):\n                            return point\n\n        def shortcut_path(path):\n            if len(path)<=2:\n                return path\n            i = 0\n            while i < len(path)-2:\n                j = len(path)-1\n                while j > i+1:\n                    if not is_edge_collision(path[i], path[j]):\n                        # shortcut between i and j\n                        path = path[:i+1] + path[j:]\n                        break\n                    j -=1\n                i +=1\n            return path\n\n        for it in range(self.max_iter):\n            sample = informed_sample(best_cost)\n            for tree_a, tree_b in [(start_tree, goal_tree),(goal_tree, start_tree)]:\n                near = nearest(tree_a, sample)\n                new_pos = steer(near.position, sample, self.step_size)\n                if is_in_collision(new_pos):\n                    continue\n                if is_edge_collision(near.position, new_pos):\n                    continue\n                new_cost = near.cost + distance(near.position, new_pos)\n                new_node = Node(new_pos, parent=near, cost=new_cost)\n                near.add_child(new_node)\n                tree_a.append(new_node)\n                edges.append((near,new_node))\n\n                rewire(tree_a, new_node)\n\n                near_to_new = nearest(tree_b, new_pos)\n                dist_trees = distance(new_pos, near_to_new.position)\n                if dist_trees <= self.step_size*2 and not is_edge_collision(new_pos, near_to_new.position):\n                    connect_node = Node(near_to_new.position, parent=new_node, cost=new_node.cost + dist_trees)\n                    new_node.add_child(connect_node)\n                    tree_b.append(connect_node)\n                    edges.append((new_node, connect_node))\n                    path = extract_path(connect_node, connect_node)\n                    # extract_path from new_node to nearest node in other tree\n                    path = extract_path(new_node, near_to_new)\n                    path = shortcut_path(path)\n                    cost_path = 0.0\n                    for k in range(len(path)-1):\n                        cost_path += distance(path[k], path[k+1])\n                    if cost_path < best_cost:\n                        best_cost = cost_path\n                        best_path = path\n            if best_path:\n                return PlannerResult(True, best_path, start_tree+goal_tree, edges)\n        return PlannerResult(False, [], start_tree+goal_tree, edges)",
          "objective": -24.54042,
          "time_improvement": 22.0,
          "length_improvement": 15.0,
          "smoothness_improvement": 1806.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.019874000549316408,
                    "num_nodes_avg": 86.7,
                    "path_length_avg": 165.53372291805212,
                    "smoothness_avg": 0.05590834490258338,
                    "success_improvement": 0.0,
                    "time_improvement": 24.29764885485091,
                    "length_improvement": 9.26834341891934,
                    "smoothness_improvement": 775.0870046395709,
                    "objective_score": 16.725735731004733
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.017957305908203124,
                    "num_nodes_avg": 144.4,
                    "path_length_avg": 240.5533294992943,
                    "smoothness_avg": 0.12055312154964279,
                    "success_improvement": 0.0,
                    "time_improvement": 89.12601287090475,
                    "length_improvement": 19.696374669454404,
                    "smoothness_improvement": 3001.9186483760295,
                    "objective_score": 53.56522190482421
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.07342400550842285,
                    "num_nodes_avg": 284.9,
                    "path_length_avg": 128.16200978596154,
                    "smoothness_avg": 0.13688525836651863,
                    "success_improvement": 0.0,
                    "time_improvement": -46.01362832932536,
                    "length_improvement": 14.88089551925333,
                    "smoothness_improvement": 1641.1703826033552,
                    "objective_score": 3.3303007257711688
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "A simplified bidirectional RRT* inspired planner that alternates growing trees from start and goal by sampling collision-free points, extends toward samples with fixed step size, and rewires local neighbors to improve path cost dynamically. It attempts connecting the trees at each iteration, returning the combined path upon success. This approach balances planning efficiency, path quality, and smoothness through incremental rewiring and early collision checks.",
          "planning_mechanism": "The planner operates by sampling points within bounds avoiding obstacles, nearest neighbor extension with fixed step, rewiring neighbors within a computed radius to optimize cost, and alternating tree expansion. Once the two trees connect, their paths are concatenated to form the final solution.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=4000, step_size=5.0, gamma_rrt_star=30.0, max_radius=40.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.gamma_rrt_star = gamma_rrt_star\n        self.max_radius = max_radius\n\n    def plan(self, map):\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        for i in range(self.max_iter):\n            tree_a, tree_b = (tree_start, tree_goal) if i % 2 == 0 else (tree_goal, tree_start)\n            sample = self._sample_free(bounds, obstacles, is_3d)\n\n            new_node = self._extend_and_rewire(tree_a, sample, obstacles, is_3d, nodes, edges, bounds)\n            if new_node is None:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            connect_node = self._connect_and_rewire(tree_b, new_node, obstacles, is_3d, nodes, edges, bounds)\n            if connect_node:\n                path_a = new_node.path_from_root()\n                path_b = connect_node.path_from_root()\n                if path_a[-1] == path_b[-1]:\n                    path_b = path_b[:-1]\n                full_path = path_a + path_b[::-1]\n                return PlannerResult(True, full_path, nodes, edges)\n\n            tree_a, tree_b = tree_b, tree_a\n\n        return PlannerResult(False, [], nodes, edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        import random\n        dim = len(bounds)\n        while True:\n            pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            if not self._in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def _nearest(self, tree, point):\n        best = None\n        best_dist = float('inf')\n        for node in tree:\n            dist = self._dist(node.position, point)\n            if dist < best_dist:\n                best_dist = dist\n                best = node\n        return best\n\n    def _steer(self, from_pos, to_pos):\n        dist = self._dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(len(from_pos)))\n\n    def _near_nodes(self, tree, position, bounds):\n        n = max(1, len(tree))\n        d = len(position)\n        scale = max(1.0, sum(bounds) / d)\n        r_theory = self.gamma_rrt_star * ((math.log(n + 1) / (n + 1)) ** (1.0 / d))\n        radius = max(self.step_size * 2, min(self.max_radius, r_theory * 0.5 + scale * 0.02))\n        return [node for node in tree if self._dist(node.position, position) <= radius]\n\n    def _extend_and_rewire(self, tree, sample, obstacles, is_3d, nodes, edges, bounds):\n        nearest = self._nearest(tree, sample)\n        new_pos = self._steer(nearest.position, sample)\n        if self._in_obstacle(new_pos, obstacles, is_3d):\n            return None\n        if self._edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n            return None\n\n        neighbors = self._near_nodes(tree, new_pos, bounds)\n        min_cost = nearest.cost + self._dist(nearest.position, new_pos)\n        best_parent = nearest\n        for nb in neighbors:\n            if not self._edge_in_obstacle(nb.position, new_pos, obstacles, is_3d):\n                cost = nb.cost + self._dist(nb.position, new_pos)\n                if cost < min_cost:\n                    min_cost = cost\n                    best_parent = nb\n\n        new_node = Node(new_pos, cost=min_cost)\n        best_parent.add_child(new_node)\n        new_node.cost = min_cost\n        tree.append(new_node)\n        nodes.append(new_node)\n        edges.append((best_parent, new_node))\n\n        for nb in neighbors:\n            if nb == best_parent:\n                continue\n            if not self._edge_in_obstacle(new_node.position, nb.position, obstacles, is_3d):\n                updated_cost = new_node.cost + self._dist(new_node.position, nb.position)\n                if updated_cost < nb.cost:\n                    if nb.parent:\n                        try:\n                            edges.remove((nb.parent, nb))\n                        except ValueError:\n                            pass\n                        if nb in nb.parent.children:\n                            nb.parent.children.remove(nb)\n                    new_node.add_child(nb)\n                    nb.cost = updated_cost\n                    edges.append((new_node, nb))\n        return new_node\n\n    def _connect_and_rewire(self, tree, target_node, obstacles, is_3d, nodes, edges, bounds):\n        nearest = self._nearest(tree, target_node.position)\n        while True:\n            new_pos = self._steer(nearest.position, target_node.position)\n            if self._in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                return None\n\n            neighbors = self._near_nodes(tree, new_pos, bounds)\n            min_cost = nearest.cost + self._dist(nearest.position, new_pos)\n            best_parent = nearest\n            for nb in neighbors:\n                if not self._edge_in_obstacle(nb.position, new_pos, obstacles, is_3d):\n                    cost = nb.cost + self._dist(nb.position, new_pos)\n                    if cost < min_cost:\n                        min_cost = cost\n                        best_parent = nb\n\n            new_node = Node(new_pos, cost=min_cost)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            for nb in neighbors:\n                if nb == best_parent:\n                    continue\n                if not self._edge_in_obstacle(new_node.position, nb.position, obstacles, is_3d):\n                    updated_cost = new_node.cost + self._dist(new_node.position, nb.position)\n                    if updated_cost < nb.cost:\n                        if nb.parent:\n                            try:\n                                edges.remove((nb.parent, nb))\n                            except ValueError:\n                                pass\n                            if nb in nb.parent.children:\n                                nb.parent.children.remove(nb)\n                        new_node.add_child(nb)\n                        nb.cost = updated_cost\n                        edges.append((new_node, nb))\n\n            if self._dist(new_node.position, target_node.position) <= self.step_size:\n                if (not self._edge_in_obstacle(new_node.position, target_node.position, obstacles, is_3d)\n                   and not self._in_obstacle(target_node.position, obstacles, is_3d)):\n                    final_node = Node(target_node.position, cost=new_node.cost + self._dist(new_node.position, target_node.position))\n                    new_node.add_child(final_node)\n                    tree.append(final_node)\n                    nodes.append(final_node)\n                    edges.append((new_node, final_node))\n                    return final_node\n                else:\n                    return None\n            nearest = new_node\n\n    def _in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _edge_in_obstacle(self, p1, p2, obstacles, is_3d, resolution=1.0):\n        dist = self._dist(p1, p2)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(p1[d] + (p2[d] - p1[d]) * i / steps for d in range(len(p1)))\n            if self._in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _dist(self, a, b):\n        s = 0\n        for i in range(len(a)):\n            s += (a[i] - b[i]) ** 2\n        return s ** 0.5",
          "objective": -23.86958,
          "time_improvement": 56.0,
          "length_improvement": 11.0,
          "smoothness_improvement": 157.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.010033559799194337,
                    "num_nodes_avg": 60.9,
                    "path_length_avg": 164.20093510394682,
                    "smoothness_avg": 0.01583828018408221,
                    "success_improvement": 0.0,
                    "time_improvement": 61.78101810606081,
                    "length_improvement": 9.99886553920486,
                    "smoothness_improvement": 147.90347825679143,
                    "objective_score": 25.273142146625116
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.050237512588500975,
                    "num_nodes_avg": 241.6,
                    "path_length_avg": 264.8016597340139,
                    "smoothness_avg": 0.010300759767330584,
                    "success_improvement": 0.0,
                    "time_improvement": 69.57884060795715,
                    "length_improvement": 11.601584087618049,
                    "smoothness_improvement": 165.04596815078446,
                    "objective_score": 28.659832475711898
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.0325772762298584,
                    "num_nodes_avg": 182.9,
                    "path_length_avg": 134.71639352764254,
                    "smoothness_avg": 0.020352271921149336,
                    "success_improvement": 0.0,
                    "time_improvement": 35.21565228605458,
                    "length_improvement": 10.527785924243197,
                    "smoothness_improvement": 158.87939658857192,
                    "objective_score": 17.67576422330515
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "A streamlined bidirectional RRT planner that alternately grows trees toward random samples with efficient collision checking and directly attempts to connect them, avoiding extra intermediate nodes and complex mechanisms to quickly find a feasible path.",
          "planning_mechanism": "The planner alternates extending trees from start and goal toward random free points, verifying collisions for nodes and edges, then tries connecting the opposite tree\u2019s nearest node directly to the newly added node to form a path, returning immediately upon success.",
          "code": "class Node:\n    def __init__(self, position, parent=None):\n        self.position = position\n        self.parent = parent\n\n    def path_from_root(self):\n        path, node = [], self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map):\n        import random, math\n        bounds = map.size\n        start, goal = map.start, map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n\n        def in_obstacle(p):\n            for obs in obstacles:\n                if dim == 3:\n                    x,y,z,w,h,d = obs\n                    if x <= p[0] <= x+w and y <= p[1] <= y+h and z <= p[2] <= z+d:\n                        return True\n                else:\n                    x,y,w,h = obs\n                    if x <= p[0] <= x+w and y <= p[1] <= y+h:\n                        return True\n            return False\n\n        def edge_collision(p1, p2, res=1.0):\n            dist = math.dist(p1, p2)\n            steps = max(1, int(dist / res))\n            for i in range(steps+1):\n                interp = tuple(p1[d] + (p2[d]-p1[d]) * i/steps for d in range(dim))\n                if in_obstacle(interp):\n                    return True\n            return False\n\n        def sample_free():\n            while True:\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not in_obstacle(p):\n                    return p\n\n        def nearest(tree, p):\n            return min(tree, key=lambda n: math.dist(n.position, p))\n\n        def steer(from_p, to_p):\n            dist = math.dist(from_p, to_p)\n            if dist <= self.step_size:\n                return to_p\n            ratio = self.step_size/dist\n            return tuple(from_p[d] + ratio*(to_p[d]-from_p[d]) for d in range(dim))\n\n        start_tree = [Node(start)]\n        goal_tree = [Node(goal)]\n        nodes, edges = start_tree + goal_tree, []\n\n        for i in range(self.max_iter):\n            rand_pt = sample_free()\n            tree_a, tree_b = (start_tree, goal_tree) if i % 2 == 0 else (goal_tree, start_tree)\n            near = nearest(tree_a, rand_pt)\n            new_pos = steer(near.position, rand_pt)\n            if in_obstacle(new_pos) or edge_collision(near.position, new_pos):\n                continue\n            new_node = Node(new_pos, near)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((near, new_node))\n\n            near_b = nearest(tree_b, new_pos)\n            if not edge_collision(near_b.position, new_pos):\n                new_node_b = Node(new_pos, near_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((near_b, new_node_b))\n\n                path_a = new_node.path_from_root()\n                path_b = new_node_b.path_from_root()\n                return PlannerResult(True, path_a + path_b[::-1], nodes, edges)\n\n        return PlannerResult(False, [], nodes, edges)",
          "objective": -23.58846,
          "time_improvement": 80.0,
          "length_improvement": -2.0,
          "smoothness_improvement": 90.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.007964897155761718,
                    "num_nodes_avg": 97.1,
                    "path_length_avg": 188.79254971727624,
                    "smoothness_avg": 0.01216603718031909,
                    "success_improvement": 0.0,
                    "time_improvement": 69.66079175532616,
                    "length_improvement": -3.4801881094312552,
                    "smoothness_improvement": 90.42490084458115,
                    "objective_score": 19.262249165161997
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.008180975914001465,
                    "num_nodes_avg": 219.4,
                    "path_length_avg": 299.83809370433016,
                    "smoothness_avg": 0.007442551666893669,
                    "success_improvement": 0.0,
                    "time_improvement": 95.04603712566637,
                    "length_improvement": -0.09458603950933,
                    "smoothness_improvement": 91.50221504246055,
                    "objective_score": 28.914570589206615
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.01209850311279297,
                    "num_nodes_avg": 264.7,
                    "path_length_avg": 152.1665942775345,
                    "smoothness_avg": 0.014835120894542881,
                    "success_improvement": 0.0,
                    "time_improvement": 75.94047989318848,
                    "length_improvement": -1.0618065245696475,
                    "smoothness_improvement": 88.70164276386569,
                    "objective_score": 22.588568267034084
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "A single-tree RRT planner with goal bias that incrementally extends towards random samples or the goal within map bounds, ensuring collision-free nodes and edges. It directly connects to the goal when possible and applies iterative shortcutting to shorten and smooth the resulting path. This balances simplicity, efficiency, and path quality without complex rewiring or dual-tree management.",
          "planning_mechanism": "The planner grows one tree from the start, sampling points biased toward the goal, extends toward these points with a fixed step size if collision-free, and attempts direct connection to the goal. Upon success, it refines the path by shortcutting to improve length and smoothness before returning the result.",
          "code": "class Node:\n    def __init__(self, position, parent=None):\n        self.position = position\n        self.parent = parent\n        self.children = []\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n    def path_from_root(self):\n        node, path = self, []\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=3000, step_size=5.0, goal_sample_rate=0.1, smooth_iters=20):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.smooth_iters = smooth_iters\n\n    def plan(self, map):\n        import random\n        start, goal = map.start, map.goal\n        bounds = map.size\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = dim == 3\n\n        def in_obstacle(p):\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d = obs\n                    if x <= p[0] <= x+w and y <= p[1] <= y+h and z <= p[2] <= z+d:\n                        return True\n                else:\n                    x,y,w,h = obs\n                    if x <= p[0] <= x+w and y <= p[1] <= y+h:\n                        return True\n            return False\n\n        def edge_collision(p1, p2):\n            import math\n            dist = math.dist(p1, p2)\n            steps = max(1, int(dist / 1.0))\n            for i in range(1, steps+1):\n                ip = tuple(p1[d] + (p2[d]-p1[d]) * i/steps for d in range(dim))\n                if in_obstacle(ip):\n                    return True\n            return False\n\n        def sample_point():\n            if random.random() < self.goal_sample_rate:\n                return goal\n            while True:\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not in_obstacle(p):\n                    return p\n\n        def nearest_node(tree, pt):\n            import math\n            best = None\n            best_dist = float(\"inf\")\n            for n in tree:\n                d = math.dist(n.position, pt)\n                if d < best_dist:\n                    best, best_dist = n, d\n            return best\n\n        def steer(from_p, to_p):\n            import math\n            dist = math.dist(from_p, to_p)\n            if dist <= self.step_size:\n                return to_p\n            ratio = self.step_size / dist\n            return tuple(from_p[d] + ratio * (to_p[d]-from_p[d]) for d in range(dim))\n\n        def shortcut_path(path):\n            import random\n            import math\n            p = path\n            for _ in range(self.smooth_iters):\n                if len(p) < 3:\n                    break\n                i = random.randint(0, len(p)-3)\n                j = random.randint(i+2, len(p)-1)\n                if not edge_collision(p[i], p[j]):\n                    p = p[:i+1] + p[j:]\n            return p\n\n        tree = [Node(start)]\n        for _ in range(self.max_iter):\n            rnd = sample_point()\n            nearest = nearest_node(tree, rnd)\n            new_pos = steer(nearest.position, rnd)\n            if in_obstacle(new_pos) or edge_collision(nearest.position, new_pos):\n                continue\n            new_node = Node(new_pos, nearest)\n            nearest.add_child(new_node)\n            tree.append(new_node)\n\n            import math\n            if math.dist(new_pos, goal) <= self.step_size and not edge_collision(new_pos, goal):\n                goal_node = Node(goal, new_node)\n                new_node.add_child(goal_node)\n                tree.append(goal_node)\n                path = goal_node.path_from_root()\n                smooth_path = shortcut_path(path)\n                edges = [(n.parent, n) for n in tree if n.parent]\n                return PlannerResult(True, smooth_path, tree, edges)\n\n        edges = [(n.parent, n) for n in tree if n.parent]\n        return PlannerResult(False, [], tree, edges)",
          "objective": -23.57065,
          "time_improvement": 58.0,
          "length_improvement": 7.0,
          "smoothness_improvement": 381.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.014452171325683594,
                    "num_nodes_avg": 311.0,
                    "path_length_avg": 184.945116032427,
                    "smoothness_avg": 0.015777086499437463,
                    "success_improvement": 0.0,
                    "time_improvement": 44.95001920766345,
                    "length_improvement": -1.3713487402772202,
                    "smoothness_improvement": 146.94566420788803,
                    "objective_score": 13.396924839172144
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.059044384956359865,
                    "num_nodes_avg": 980.3,
                    "path_length_avg": 266.330502537888,
                    "smoothness_avg": 0.021634063382426717,
                    "success_improvement": 0.0,
                    "time_improvement": 64.24586820857652,
                    "length_improvement": 11.09121235438472,
                    "smoothness_improvement": 456.660033215849,
                    "objective_score": 28.21178804128303
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.017370772361755372,
                    "num_nodes_avg": 421.8,
                    "path_length_avg": 133.58884605976408,
                    "smoothness_avg": 0.05032267619592935,
                    "success_improvement": 0.0,
                    "time_improvement": 65.45585490930883,
                    "length_improvement": 11.276649264367416,
                    "smoothness_improvement": 540.1007267786442,
                    "objective_score": 29.10324966530632
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "A simplified single-tree RRT planner that incrementally grows from start towards random samples with goal bias, checking collision at nodes and edges. Upon connecting to the goal, it performs shortcut smoothing to improve path quality. This streamlined approach balances clarity and efficiency for general path planning tasks.",
          "planning_mechanism": "A single tree grows by sampling points biased towards the goal, extending towards these samples stepwise if collision-free. When the goal is reachable within step size, the path is connected, and shortcut smoothing is applied before returning the final path.",
          "code": "class Node:\n    def __init__(self, position, parent=None):\n        self.position = position\n        self.parent = parent\n        self.children = []\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n    def path_from_root(self):\n        node, path = self, []\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=3000, step_size=5.0, goal_sample_rate=0.1, smooth_iters=20):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.smooth_iters = smooth_iters\n\n    def plan(self, map):\n        import random\n        start, goal = map.start, map.goal\n        bounds = map.size\n        obstacles = map.obstacles\n        dim = len(bounds)\n\n        def in_obstacle(p):\n            for obs in obstacles:\n                if dim == 3:\n                    x,y,z,w,h,d = obs\n                    if x <= p[0] <= x+w and y <= p[1] <= y+h and z <= p[2] <= z+d:\n                        return True\n                else:\n                    x,y,w,h = obs\n                    if x <= p[0] <= x+w and y <= p[1] <= y+h:\n                        return True\n            return False\n\n        def edge_collision(p1, p2):\n            import math\n            dist = math.dist(p1, p2)\n            steps = max(1, int(dist))\n            for i in range(1, steps+1):\n                ip = tuple(p1[d] + (p2[d]-p1[d]) * i/steps for d in range(dim))\n                if in_obstacle(ip):\n                    return True\n            return False\n\n        def sample_point():\n            if random.random() < self.goal_sample_rate:\n                return goal\n            while True:\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not in_obstacle(p):\n                    return p\n\n        def nearest_node(tree, pt):\n            import math\n            best, best_dist = None, float('inf')\n            for n in tree:\n                d = math.dist(n.position, pt)\n                if d < best_dist:\n                    best, best_dist = n, d\n            return best\n\n        def steer(from_p, to_p):\n            import math\n            dist = math.dist(from_p, to_p)\n            if dist <= self.step_size:\n                return to_p\n            ratio = self.step_size / dist\n            return tuple(from_p[d] + ratio * (to_p[d]-from_p[d]) for d in range(dim))\n\n        def shortcut_path(path):\n            import random\n            for _ in range(self.smooth_iters):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i+2, len(path)-1)\n                if not edge_collision(path[i], path[j]):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        tree = [Node(start)]\n        for _ in range(self.max_iter):\n            rnd = sample_point()\n            nearest = nearest_node(tree, rnd)\n            new_pos = steer(nearest.position, rnd)\n            if in_obstacle(new_pos) or edge_collision(nearest.position, new_pos):\n                continue\n            new_node = Node(new_pos, nearest)\n            nearest.add_child(new_node)\n            tree.append(new_node)\n\n            import math\n            if math.dist(new_pos, goal) <= self.step_size and not edge_collision(new_pos, goal):\n                goal_node = Node(goal, new_node)\n                new_node.add_child(goal_node)\n                tree.append(goal_node)\n                path = goal_node.path_from_root()\n                path = shortcut_path(path)\n                edges = [(n.parent, n) for n in tree if n.parent]\n                return PlannerResult(True, path, tree, edges)\n\n        edges = [(n.parent, n) for n in tree if n.parent]\n        return PlannerResult(False, [], tree, edges)",
          "objective": -23.33287,
          "time_improvement": 59.0,
          "length_improvement": 7.0,
          "smoothness_improvement": 340.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.015235590934753417,
                    "num_nodes_avg": 284.5,
                    "path_length_avg": 184.94121792369054,
                    "smoothness_avg": 0.016946523794565408,
                    "success_improvement": 0.0,
                    "time_improvement": 41.965883920324984,
                    "length_improvement": -1.369212125109286,
                    "smoothness_improvement": 165.2498973503724,
                    "objective_score": 12.594487387783786
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.06221249103546143,
                    "num_nodes_avg": 958.2,
                    "path_length_avg": 266.4083752295869,
                    "smoothness_avg": 0.020613223343708017,
                    "success_improvement": 0.0,
                    "time_improvement": 62.32743206320676,
                    "length_improvement": 11.065216208454466,
                    "smoothness_improvement": 430.39308373825736,
                    "objective_score": 27.489324762725992
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.013982272148132325,
                    "num_nodes_avg": 408.3,
                    "path_length_avg": 135.17266394842352,
                    "smoothness_avg": 0.041220965056521584,
                    "success_improvement": 0.0,
                    "time_improvement": 72.19434877599168,
                    "length_improvement": 10.224752836023129,
                    "smoothness_improvement": 424.3276329038104,
                    "objective_score": 29.914794498930434
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m1",
          "algorithm_description": "An improved bidirectional RRT algorithm that grows start and goal trees by incrementally extending towards random samples, but integrates an adaptive best-near extension strategy and direct tree connection attempts to reduce unnecessary intermediate nodes, enhancing planning speed and path quality. The algorithm prunes redundant branches during connection and returns a smooth shortest path by tracing parent links without excessive intermediate nodes, while ensuring collision checks for nodes and edges.",
          "planning_mechanism": "The planner alternates expanding the start and goal trees by selecting the best node near a random sample to attempt efficient extensions. It tries to directly connect the two trees whenever possible, avoiding incremental stepwise connections that add many nodes. Upon successful connection, it constructs the path by merging the backward path of the start tree and the forward path of the goal tree, ensuring smoothness and shortness without intermediate expansions between trees.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map):\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        edges = []\n\n        for _ in range(self.max_iter):\n            rand = self._sample_free(bounds, obstacles, is_3d)\n            # Alternate growing trees: start_tree then goal_tree\n            for source_tree, target_tree in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest = self._best_near(source_tree, rand)\n                new_pos = self._steer(nearest.position, rand, self.step_size)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                    continue\n                new_node = Node(new_pos, parent=nearest, cost=nearest.cost + self._distance(nearest.position, new_pos))\n                nearest.add_child(new_node)\n                source_tree.append(new_node)\n                edges.append((nearest, new_node))\n\n                # Try direct connection to closest node in target_tree\n                connect_node = self._nearest(target_tree, new_pos)\n                if self._direct_connect(new_node, connect_node, obstacles, is_3d):\n                    # Link both trees at connection without intermediate nodes\n                    new_node_connect = Node(connect_node.position, parent=new_node, cost=new_node.cost + self._distance(new_node.position, connect_node.position))\n                    new_node.add_child(new_node_connect)\n                    source_tree.append(new_node_connect)\n                    edges.append((new_node, new_node_connect))\n\n                    path = self._build_path(new_node_connect, connect_node)\n                    return PlannerResult(True, path, start_tree + goal_tree, edges)\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        while True:\n            point = tuple((random.uniform(0, bounds[i]) for i in range(len(bounds))))\n            if not self._is_in_obstacle(point, obstacles, is_3d):\n                return point\n\n    def _best_near(self, tree, sample):\n        # Select node near sample that yields minimal cost-to-come plus distance to sample\n        candidates = [node for node in tree\n                      if self._distance(node.position, sample) <= self.step_size * 3]\n        if not candidates:\n            return self._nearest(tree, sample)\n        best_node = min(candidates, key=lambda n: n.cost + self._distance(n.position, sample))\n        return best_node\n\n    def _nearest(self, tree, point):\n        return min(tree, key=lambda node: self._distance(node.position, point))\n\n    def _steer(self, from_pos, to_pos, max_step):\n        dist = self._distance(from_pos, to_pos)\n        if dist <= max_step:\n            return to_pos\n        ratio = max_step / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _direct_connect(self, node_a, node_b, obstacles, is_3d):\n        # Try direct edge-connect (no incremental steps)\n        if node_a.position == node_b.position:\n            return True\n        if self._is_edge_in_obstacle(node_a.position, node_b.position, obstacles, is_3d):\n            return False\n        return True\n\n    def _build_path(self, connect_node_starttree, connect_node_goaltree):\n        # Extract path: from start root to connect_node_starttree\n        path_start = []\n        node = connect_node_starttree\n        while node:\n            path_start.append(node.position)\n            node = node.parent\n        path_start.reverse()\n        # From connect_node_goaltree to root of goal tree (goal)\n        path_goal = []\n        node = connect_node_goaltree\n        while node:\n            path_goal.append(node.position)\n            node = node.parent\n        # Concatenate without duplicating connection point\n        if path_goal and path_start and path_goal[0] == path_start[-1]:\n            path_goal = path_goal[1:]\n        return path_start + path_goal\n\n    def _distance(self, a, b):\n        return math.dist(a, b)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        dist = self._distance(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -23.20822,
          "time_improvement": 70.0,
          "length_improvement": 3.0,
          "smoothness_improvement": 94.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.01148538589477539,
                    "num_nodes_avg": 114.7,
                    "path_length_avg": 178.88287649808652,
                    "smoothness_avg": 0.011710944030027473,
                    "success_improvement": 0.0,
                    "time_improvement": 56.2508457274982,
                    "length_improvement": 1.951460810827528,
                    "smoothness_improvement": 83.30170479192397,
                    "objective_score": 18.4626387287056
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.024952244758605958,
                    "num_nodes_avg": 287.1,
                    "path_length_avg": 284.2732101707537,
                    "smoothness_avg": 0.007407994819409248,
                    "success_improvement": 0.0,
                    "time_improvement": 84.89025081300372,
                    "length_improvement": 5.101420094330395,
                    "smoothness_improvement": 90.61304246639523,
                    "objective_score": 28.980992512831325
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.016226673126220705,
                    "num_nodes_avg": 197.2,
                    "path_length_avg": 147.25047497131663,
                    "smoothness_avg": 0.01634842816831971,
                    "success_improvement": 0.0,
                    "time_improvement": 67.73105195682024,
                    "length_improvement": 2.20324583817514,
                    "smoothness_improvement": 107.95079958558324,
                    "objective_score": 22.18101708787907
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "A simplified bidirectional RRT planner that efficiently grows two trees from start and goal positions. It alternates tree expansions towards random free samples and attempts to connect the trees for path finding. Rigorous collision checks on nodes and edges ensure safety. The planner avoids complex rewiring or smoothing, emphasizing understandable and reliable path discovery.",
          "planning_mechanism": "The planner grows two trees from start and goal, sampling random points inside bounds and extending each tree toward these points stepwise while checking collisions. After each extension, it tries to connect the opposite tree to the new node. Upon connection, it reconstructs the path by joining the two trees\u2019 paths, returning success; otherwise, it repeats up to a maximum iteration count.",
          "code": "class Node:\n    def __init__(self, position, parent=None):\n        self.position = position\n        self.parent = parent\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        path, node = [], self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map):\n        import random, math\n        bounds = map.size\n        start, goal = map.start, map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start)]\n        goal_tree = [Node(goal)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        def sample_free():\n            while True:\n                p = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                if not is_in_obstacle(p):\n                    return p\n\n        def is_in_obstacle(p):\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d = obs\n                    if x <= p[0] <= x+w and y <= p[1] <= y+h and z <= p[2] <= z+d:\n                        return True\n                else:\n                    x,y,w,h = obs\n                    if x <= p[0] <= x+w and y <= p[1] <= y+h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(p1, p2, resolution=1.0):\n            dist = math.dist(p1, p2)\n            steps = max(1, int(dist / resolution))\n            for i in range(steps+1):\n                interp = tuple(p1[d] + (p2[d]-p1[d]) * i/steps for d in range(len(p1)))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: math.dist(n.position, point))\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + ratio * (to_pos[d]-from_pos[d]) for d in range(len(from_pos)))\n\n        def extend(tree, target):\n            nearest_node = nearest(tree, target)\n            new_pos = steer(nearest_node.position, target)\n            if (not is_in_obstacle(new_pos) and not is_edge_in_obstacle(nearest_node.position, new_pos)):\n                new_node = Node(new_pos)\n                nearest_node.add_child(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((nearest_node, new_node))\n                return new_node\n            return None\n\n        def connect(tree, target_node):\n            current = nearest(tree, target_node.position)\n            while True:\n                new_pos = steer(current.position, target_node.position)\n                if is_in_obstacle(new_pos) or is_edge_in_obstacle(current.position, new_pos):\n                    return None\n                new_node = Node(new_pos)\n                current.add_child(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((current, new_node))\n                if math.dist(new_pos, target_node.position) <= self.step_size:\n                    if not is_edge_in_obstacle(new_pos, target_node.position):\n                        final_node = Node(target_node.position)\n                        new_node.add_child(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    return None\n                current = new_node\n\n        for i in range(self.max_iter):\n            rand_point = sample_free()\n            tree_a, tree_b = (start_tree, goal_tree) if i % 2 == 0 else (goal_tree, start_tree)\n            new_node = extend(tree_a, rand_point)\n            if new_node is None:\n                continue\n            connected_node = connect(tree_b, new_node)\n            if connected_node:\n                path_a = new_node.path_from_root()\n                path_b = connected_node.path_from_root()\n                full_path = path_a + path_b[::-1]\n                return PlannerResult(True, full_path, nodes, edges)\n\n        return PlannerResult(False, [], nodes, edges)",
          "objective": -22.17466,
          "time_improvement": 79.0,
          "length_improvement": -3.0,
          "smoothness_improvement": 65.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.003809499740600586,
                    "num_nodes_avg": 73.7,
                    "path_length_avg": 178.46637665923026,
                    "smoothness_avg": 0.010942951354709452,
                    "success_improvement": 0.0,
                    "time_improvement": 85.4891778665962,
                    "length_improvement": 2.179750972366932,
                    "smoothness_improvement": 71.28095170040967,
                    "objective_score": 27.311008701901063
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.009117722511291504,
                    "num_nodes_avg": 227.8,
                    "path_length_avg": 308.81910883768927,
                    "smoothness_avg": 0.0062857777942338725,
                    "success_improvement": 0.0,
                    "time_improvement": 94.47879332560935,
                    "length_improvement": -3.09270739521206,
                    "smoothness_improvement": 61.73759010838131,
                    "objective_score": 26.79670151109747
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.021011710166931152,
                    "num_nodes_avg": 348.1,
                    "path_length_avg": 164.0108412010742,
                    "smoothness_avg": 0.012713382189075556,
                    "success_improvement": 0.0,
                    "time_improvement": 58.215354533799626,
                    "length_improvement": -8.928191368754328,
                    "smoothness_improvement": 61.713283040781754,
                    "objective_score": 12.416257954091197
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e2",
          "algorithm_description": "A hybrid bidirectional RRT* planner integrating goal bias sampling, adaptive step sizes, efficient nearest neighbor search via incremental radius, and localized rewiring for path improvement and smoothing. The planner grows two trees from start and goal, extends them towards randomly sampled points (biased towards goal regions), and attempts connection. It dynamically updates node costs and performs local rewiring to optimize paths progressively, improving success rate, path length, and smoothness while maintaining computational efficiency.",
          "planning_mechanism": "A bidirectional RRT*-inspired planner alternates tree expansion using goal-biased sampling and adaptive step sizes; extends nodes using steering methods with collision checking; after adding nodes performs local rewiring within a radius to optimize paths; attempts connection between two trees each iteration; once connected, reconstructs the final minimized-cost path, returning it with consistent nodes and edges.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.children = []\n        self.cost = cost\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=4000, step_size=5.0, goal_sample_rate=0.15, rewire_radius=15.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.rewire_radius = rewire_radius\n\n    def plan(self, map):\n        bounds = map.size\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start)]\n        goal_tree = [Node(goal)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        for i in range(self.max_iter):\n            expanding_tree, other_tree = (start_tree, goal_tree) if i % 2 == 0 else (goal_tree, start_tree)\n            sample = self._sample_free(bounds, obstacles, is_3d, goal, self.goal_sample_rate)\n            new_node = self._extend(expanding_tree, sample, obstacles, is_3d, nodes, edges)\n            if new_node is not None:\n                self._rewire(new_node, expanding_tree, obstacles, is_3d, nodes, edges)\n                connected_node = self._connect(other_tree, new_node, obstacles, is_3d, nodes, edges)\n                if connected_node is not None:\n                    path_start = new_node.path_from_root()\n                    path_goal = connected_node.path_from_root()\n                    # Connect and optimize final path\n                    if path_start[-1] == path_goal[-1]:\n                        full_path = path_start + path_goal[-2::-1]\n                    else:\n                        full_path = path_start + path_goal[::-1]\n                    optimized_path = self._shortcut_path(full_path, obstacles, is_3d)\n                    return PlannerResult(True, optimized_path, nodes, edges)\n\n        return PlannerResult(False, [], nodes, edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d, goal, goal_sample_rate):\n        import random\n        from math import sqrt\n        if random.random() < goal_sample_rate:\n            return goal\n        while True:\n            pt = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n            if not self._in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def _nearest(self, tree, point):\n        min_dist = float('inf')\n        nearest_node = None\n        for node in tree:\n            dist = self._dist(node.position, point)\n            if dist < min_dist:\n                min_dist = dist\n                nearest_node = node\n        return nearest_node\n\n    def _near(self, tree, point, radius):\n        near_nodes = []\n        r2 = radius * radius\n        for node in tree:\n            if self._dist_sq(node.position, point) <= r2:\n                near_nodes.append(node)\n        return near_nodes\n\n    def _extend(self, tree, point, obstacles, is_3d, nodes, edges):\n        nearest = self._nearest(tree, point)\n        new_pos = self._steer(nearest.position, point)\n        if not self._valid(nearest.position, new_pos, obstacles, is_3d):\n            return None\n        new_cost = nearest.cost + self._dist(nearest.position, new_pos)\n        # Choose best parent among near vertices to minimize cost\n        near_nodes = self._near(tree, new_pos, self.rewire_radius)\n        best_parent = nearest\n        best_cost = new_cost\n        for near_node in near_nodes:\n            cost_through_near = near_node.cost + self._dist(near_node.position, new_pos)\n            if cost_through_near < best_cost and self._valid(near_node.position, new_pos, obstacles, is_3d):\n                best_parent = near_node\n                best_cost = cost_through_near\n        new_node = Node(new_pos, best_parent, best_cost)\n        best_parent.add_child(new_node)\n        tree.append(new_node)\n        nodes.append(new_node)\n        edges.append((best_parent, new_node))\n        return new_node\n\n    def _connect(self, tree, target_node, obstacles, is_3d, nodes, edges):\n        current = self._nearest(tree, target_node.position)\n        while True:\n            new_pos = self._steer(current.position, target_node.position)\n            if not self._valid(current.position, new_pos, obstacles, is_3d):\n                return None\n            new_cost = current.cost + self._dist(current.position, new_pos)\n            new_node = Node(new_pos, current, new_cost)\n            current.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((current, new_node))\n\n            # Rewire near nodes around new_node for better costs\n            self._rewire(new_node, tree, obstacles, is_3d, nodes, edges)\n\n            if self._dist(new_node.position, target_node.position) <= self.step_size:\n                if not self._valid(new_node.position, target_node.position, obstacles, is_3d):\n                    return None\n                final_cost = new_node.cost + self._dist(new_node.position, target_node.position)\n                final_node = Node(target_node.position, new_node, final_cost)\n                new_node.add_child(final_node)\n                tree.append(final_node)\n                nodes.append(final_node)\n                edges.append((new_node, final_node))\n                return final_node\n            current = new_node\n\n    def _rewire(self, new_node, tree, obstacles, is_3d, nodes, edges):\n        near_nodes = self._near(tree, new_node.position, self.rewire_radius)\n        for near in near_nodes:\n            if near == new_node.parent:\n                continue\n            cost_through_new = new_node.cost + self._dist(new_node.position, near.position)\n            if cost_through_new < near.cost and self._valid(new_node.position, near.position, obstacles, is_3d):\n                # Update parent and cost\n                if near.parent:\n                    try:\n                        near.parent.children.remove(near)\n                    except ValueError:\n                        pass\n                near.parent = new_node\n                near.cost = cost_through_new\n                new_node.children.append(near)\n                # Update children costs recursively\n                self._update_children_costs(near)\n\n    def _update_children_costs(self, node):\n        for child in node.children:\n            new_cost = node.cost + self._dist(node.position, child.position)\n            if new_cost < child.cost:\n                child.cost = new_cost\n                child.parent = node\n                self._update_children_costs(child)\n\n    def _steer(self, start, goal):\n        dist = self._dist(start, goal)\n        if dist <= self.step_size:\n            return goal\n        ratio = self.step_size / dist\n        return tuple(start[d] + (goal[d] - start[d]) * ratio for d in range(len(start)))\n\n    def _valid(self, p1, p2, obstacles, is_3d):\n        return (not self._in_obstacle(p2, obstacles, is_3d)) and (not self._edge_in_obstacle(p1, p2, obstacles, is_3d))\n\n    def _in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x,y,z,w,h,d = obs\n                px,py,pz = pos\n                if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                    return True\n            else:\n                x,y,w,h = obs\n                px,py = pos\n                if x <= px <= x+w and y <= py <= y+h:\n                    return True\n        return False\n\n    def _edge_in_obstacle(self, p1, p2, obstacles, is_3d, res=1.0):\n        dist = self._dist(p1, p2)\n        steps = max(1, int(dist / res))\n        for i in range(steps + 1):\n            interp = tuple(p1[d] + (p2[d] - p1[d]) * i / steps for d in range(len(p1)))\n            if self._in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _dist(self, a, b):\n        return sum((a[d]-b[d])**2 for d in range(len(a)))**0.5\n\n    def _dist_sq(self, a, b):\n        return sum((a[d]-b[d])**2 for d in range(len(a)))\n\n    def _shortcut_path(self, path, obstacles, is_3d):\n        if len(path) <= 2:\n            return path\n        i = 0\n        new_path = [path[0]]\n        while i < len(path) - 1:\n            j = len(path) - 1\n            while j > i + 1:\n                if not self._edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                    break\n                j -= 1\n            new_path.append(path[j])\n            i = j\n        return new_path",
          "objective": -21.69817,
          "time_improvement": 13.0,
          "length_improvement": 17.0,
          "smoothness_improvement": 1574.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.026177811622619628,
                    "num_nodes_avg": 114.0,
                    "path_length_avg": 165.39322114121052,
                    "smoothness_avg": 0.05422599018415906,
                    "success_improvement": 0.0,
                    "time_improvement": 0.2857083177810343,
                    "length_improvement": 9.345354669199349,
                    "smoothness_improvement": 748.7545000044862,
                    "objective_score": 9.43669779687635
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.08344228267669677,
                    "num_nodes_avg": 275.8,
                    "path_length_avg": 235.51330564478062,
                    "smoothness_avg": 0.10403228200976807,
                    "success_improvement": 0.0,
                    "time_improvement": 49.471802034945625,
                    "length_improvement": 21.378879701134153,
                    "smoothness_improvement": 2576.825547535313,
                    "objective_score": 40.55299616884074
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.056298470497131346,
                    "num_nodes_avg": 219.1,
                    "path_length_avg": 121.18470212144905,
                    "smoothness_avg": 0.11765862390427125,
                    "success_improvement": 0.0,
                    "time_improvement": -11.957171088066387,
                    "length_improvement": 19.514891046335084,
                    "smoothness_improvement": 1396.6090114061014,
                    "objective_score": 15.104828358411641
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e2",
          "algorithm_description": "A hybrid bidirectional anytime RRT* variant integrating adaptive informed sampling, dynamic rewiring, and heuristic-guided priority expansions for efficient and high-quality path planning. It maintains two trees grown from start and goal, using informed ellipse sampling after finding initial solutions, rewires nodes within an adaptive radius to improve path quality, and employs a min-priority queue with cost + heuristic to guide expansions. The algorithm incrementally attempts to connect both trees using collision-checked edges and performs path shortcutting for smoothness and shorter paths. This combination balances efficiency, robustness, path length, and smoothness, yielding faster convergence and better final solutions.",
          "planning_mechanism": "A bidirectional RRT*-inspired planner that alternates expansions of two trees grown from start and goal, uses heuristic priority queues for node selection, employs adaptive ellipsoidal informed sampling to bias growth towards promising regions when a solution is found, dynamically rewires nodes within a decreasing radius to reduce path cost, and performs collision checking both lazily and eagerly to optimize planning time. The planner incrementally attempts connections between trees and upon success extracts and shortcuts the path to return the best collision-free solution found within the iteration limit.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost  # cost-to-come\n        self.children = []\n        self.id = id(self)\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=4500, step_size=4.0, goal_sample_rate=0.12, init_radius=20.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.init_radius = init_radius\n\n    def plan(self, map):\n        bounds = map.size\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        import math\n        import random\n        import heapq\n\n        def heuristic(p):\n            return math.sqrt(sum((p[d] - goal[d]) ** 2 for d in range(dim)))\n\n        def dist(a, b):\n            return math.sqrt(sum((a[d] - b[d]) ** 2 for d in range(dim)))\n\n        def in_obstacle(pt):\n            if is_3d:\n                px, py, pz = pt\n                for obs in obstacles:\n                    ox, oy, oz, w, h, d = obs\n                    if ox <= px <= ox + w and oy <= py <= oy + h and oz <= pz <= oz + d:\n                        return True\n            else:\n                px, py = pt\n                for obs in obstacles:\n                    ox, oy, w, h = obs\n                    if ox <= px <= ox + w and oy <= py <= oy + h:\n                        return True\n            return False\n\n        def edge_in_obstacle(p1, p2):\n            distance = dist(p1, p2)\n            steps = max(2, int(distance / 0.5))\n            for i in range(steps+1):\n                interp = tuple(p1[d] + (p2[d] - p1[d]) * (i / steps) for d in range(dim))\n                if in_obstacle(interp):\n                    return True\n            return False\n\n        def steer(from_p, to_p):\n            d = dist(from_p, to_p)\n            if d <= self.step_size:\n                return to_p\n            ratio = self.step_size / d\n            return tuple(from_p[d_] + ratio * (to_p[d_] - from_p[d_]) for d_ in range(dim))\n\n        def sample_uniform():\n            trials = 0\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not in_obstacle(pt):\n                    return pt\n                trials += 1\n                if trials > 1000:  # fallback to goal sample if stuck\n                    return goal\n\n        # Informed sampling inside prolate hyperspheroid\n        def sample_informed(c_best):\n            if c_best == float('inf'):\n                return sample_uniform()\n            c_min = dist(start, goal)\n            if c_best < c_min:\n                return sample_uniform()\n            center = tuple((start[d] + goal[d]) * 0.5 for d in range(dim))\n            a1 = [(goal[d] - start[d]) / c_min for d in range(dim)]\n\n            while True:\n                x_ball = [random.gauss(0,1) for _ in range(dim)]\n                norm = math.sqrt(sum(x*x for x in x_ball))\n                if norm == 0:\n                    continue\n                unit = [x / norm for x in x_ball]\n                r1 = c_best/2.0\n                r2_temp = c_best**2 - c_min**2\n                r2 = math.sqrt(r2_temp)/2.0 if r2_temp > 0 else 0.0\n                \n                if dim == 2:\n                    angle = math.atan2(a1[1], a1[0])\n                    cos_a = math.cos(angle)\n                    sin_a = math.sin(angle)\n                    x_ell = r1 * unit[0]\n                    y_ell = r2 * unit[1]\n                    px = center[0] + cos_a * x_ell - sin_a * y_ell\n                    py = center[1] + sin_a * x_ell + cos_a * y_ell\n                    pt = (px, py)\n                else:\n                    # 3D: scale along axis, clamp inside bounds\n                    pt_candidate = []\n                    for d in range(dim):\n                        scale = r1 if d == 0 else r2\n                        coord = center[d] + scale * unit[d]\n                        coord = max(0, min(coord, bounds[d]))\n                        pt_candidate.append(coord)\n                    pt = tuple(pt_candidate)\n\n                if all(0 <= pt[d] <= bounds[d] for d in range(dim)) and not in_obstacle(pt):\n                    return pt\n\n        class PriorityQueue:\n            def __init__(self):\n                self.heap = []\n                self.entry_finder = {}\n                self.REMOVED = '<removed>'\n\n            def add(self, node, priority):\n                if node.id in self.entry_finder:\n                    self.remove(node)\n                entry = [priority, node.id, node]\n                self.entry_finder[node.id] = entry\n                heapq.heappush(self.heap, entry)\n\n            def remove(self, node):\n                entry = self.entry_finder.pop(node.id)\n                entry[-1] = self.REMOVED\n\n            def pop(self):\n                while self.heap:\n                    priority, nid, node = heapq.heappop(self.heap)\n                    if node is not self.REMOVED:\n                        del self.entry_finder[nid]\n                        return node\n                return None\n\n            def empty(self):\n                return not bool(self.entry_finder)\n\n        def nearest(tree_nodes, point):\n            best_node = None\n            best_dist = float('inf')\n            for node in tree_nodes:\n                d = dist(node.position, point)\n                if d < best_dist:\n                    best_dist = d\n                    best_node = node\n            return best_node, best_dist\n\n        def neighbors(tree_nodes, node, radius):\n            nbrs = []\n            for n in tree_nodes:\n                if dist(n.position, node.position) <= radius:\n                    nbrs.append(n)\n            return nbrs\n\n        def shortcut_path(path):\n            if len(path) <= 2:\n                return path\n            shortened = [path[0]]\n            idx = 0\n            while idx < len(path)-1:\n                next_idx = len(path)-1\n                for j in range(len(path)-1, idx, -1):\n                    if not edge_in_obstacle(path[idx], path[j]):\n                        next_idx = j\n                        break\n                shortened.append(path[next_idx])\n                idx = next_idx\n            return shortened\n\n        def add_node_rewire(t_nodes, t_pq, new_pos, heuristic_best, radius):\n            near, _ = nearest(t_nodes, new_pos)\n            if in_obstacle(new_pos) or edge_in_obstacle(near.position, new_pos):\n                return None\n\n            new_cost = near.cost + dist(near.position, new_pos)\n            new_node = Node(new_pos, parent=near, cost=new_cost)\n            near.add_child(new_node)\n            t_nodes.append(new_node)\n            t_pq.add(new_node, new_node.cost + heuristic(new_pos))\n\n            nbrs = neighbors(t_nodes, new_node, radius)\n            for nbr in nbrs:\n                if nbr is new_node.parent:\n                    continue\n                cost_through_new = new_node.cost + dist(new_node.position, nbr.position)\n                if cost_through_new + 1e-8 < nbr.cost:\n                    if not edge_in_obstacle(new_node.position, nbr.position):\n                        # Rewire nbr\n                        if nbr.parent:\n                            nbr.parent.remove_child(nbr)\n                        nbr.parent = new_node\n                        new_node.children.append(nbr)\n                        old_cost = nbr.cost\n                        nbr.cost = cost_through_new\n\n                        def dfs_update_cost(node):\n                            for c in node.children:\n                                new_c_cost = node.cost + dist(node.position, c.position)\n                                if new_c_cost + 1e-8 < c.cost:\n                                    c.cost = new_c_cost\n                                    dfs_update_cost(c)\n                        dfs_update_cost(nbr)\n                        t_pq.add(nbr, nbr.cost + heuristic(nbr.position))\n            return new_node\n\n        def attempt_connect(tree_other_nodes, tree_other_pq, node_new):\n            near_other, _ = nearest(tree_other_nodes, node_new.position)\n            if in_obstacle(node_new.position) or edge_in_obstacle(near_other.position, node_new.position):\n                return None\n            cost_new = near_other.cost + dist(near_other.position, node_new.position)\n            new_node_other = Node(node_new.position, parent=near_other, cost=cost_new)\n            near_other.add_child(new_node_other)\n            tree_other_nodes.append(new_node_other)\n            tree_other_pq.add(new_node_other, new_node_other.cost + heuristic(new_node_other.position))\n            return new_node_other\n\n        start_node = Node(start, cost=0.0)\n        goal_node = Node(goal, cost=0.0)\n        tree_start = [start_node]\n        tree_goal = [goal_node]\n        pq_start = PriorityQueue()\n        pq_goal = PriorityQueue()\n        pq_start.add(start_node, heuristic(start))\n        pq_goal.add(goal_node, heuristic(goal))\n\n        best_cost = float('inf')\n        best_path = None\n\n        def adaptive_radius(iter_idx):\n            r = self.init_radius * (0.96 ** (iter_idx // 350))\n            return max(4.0, r)\n\n        for i in range(self.max_iter):\n            expand_start = (i % 2 == 0)\n            t_nodes_a, t_pq_a = (tree_start, pq_start) if expand_start else (tree_goal, pq_goal)\n            t_nodes_b, t_pq_b = (tree_goal, pq_goal) if expand_start else (tree_start, pq_start)\n\n            nbr_radius = adaptive_radius(i)\n            curr_best = best_cost if best_cost != float('inf') else float('inf')\n\n            sample_point = None\n            p = random.random()\n            if p < self.goal_sample_rate:\n                sample_point = goal if expand_start else start\n                # Ensure not in obstacle\n                if in_obstacle(sample_point):\n                    sample_point = sample_uniform()\n            elif curr_best < float('inf'):\n                sample_point = sample_informed(curr_best)\n            else:\n                sample_point = sample_uniform()\n\n            new_node_a = add_node_rewire(t_nodes_a, t_pq_a, sample_point, curr_best, nbr_radius)\n            if new_node_a is None:\n                continue\n\n            new_node_b = attempt_connect(t_nodes_b, t_pq_b, new_node_a)\n            if new_node_b:\n                total_c = new_node_a.cost + new_node_b.cost\n                if total_c + 1e-8 < best_cost:\n                    best_cost = total_c\n                    path_start = new_node_a.path_from_root() if expand_start else new_node_b.path_from_root()\n                    path_goal = new_node_b.path_from_root() if expand_start else new_node_a.path_from_root()\n                    if path_start[-1] == path_goal[-1]:\n                        combined = path_start + path_goal[-2::-1]\n                    else:\n                        combined = path_start + path_goal[::-1]\n\n                    smoothed = shortcut_path(combined)\n                    best_path = smoothed\n                    # Anytime return on improvement\n                    return PlannerResult(success=True, path=best_path, nodes=tree_start + tree_goal, edges=[])\n\n        # Return failure if no connection found\n        return PlannerResult(success=False, path=[], nodes=tree_start + tree_goal, edges=[])",
          "objective": -21.32282,
          "time_improvement": 41.0,
          "length_improvement": -3.0,
          "smoothness_improvement": 2088.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.03065047264099121,
                    "num_nodes_avg": 69.3,
                    "path_length_avg": 201.54333295789633,
                    "smoothness_avg": 0.09071995397809844,
                    "success_improvement": 0.0,
                    "time_improvement": -16.75117130420488,
                    "length_improvement": -10.469094452705283,
                    "smoothness_improvement": 1319.964281290423,
                    "objective_score": -4.70698665643252
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.011514782905578613,
                    "num_nodes_avg": 68.4,
                    "path_length_avg": 272.8228556658298,
                    "smoothness_avg": 0.12690712863337233,
                    "success_improvement": 0.0,
                    "time_improvement": 93.02726134144713,
                    "length_improvement": 8.923878008254347,
                    "smoothness_improvement": 3165.4118272467053,
                    "objective_score": 49.089564343620275
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.026196837425231934,
                    "num_nodes_avg": 82.4,
                    "path_length_avg": 159.78036568867304,
                    "smoothness_avg": 0.14757624600187821,
                    "success_improvement": 0.0,
                    "time_improvement": 47.90402325881309,
                    "length_improvement": -6.118510967013652,
                    "smoothness_improvement": 1777.1589561985077,
                    "objective_score": 19.585895178428274
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "A streamlined bidirectional RRT planner that grows two trees from start and goal by extending towards random collision-free samples with a fixed step size, connecting trees incrementally, and returning a feasible path once connected. It performs collision checking on nodes and edges and maintains coherent parent-child relationships to build efficient paths.",
          "planning_mechanism": "A planner that alternates expanding two trees via fixed-step steering towards uniform random free samples, validates each extension for collisions, attempts to connect trees after each new node, and reconstructs the final path by joining connected tree paths.",
          "code": "class Node:\n    def __init__(self, position, parent=None):\n        self.position = position\n        self.parent = parent\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        node, path = self, []\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=3000, step_size=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map):\n        bounds, start, goal = map.size, map.start, map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        tree_start = [Node(start)]\n        tree_goal = [Node(goal)]\n        nodes = tree_start + tree_goal\n        edges = []\n\n        for i in range(self.max_iter):\n            tree_a, tree_b = (tree_start, tree_goal) if i % 2 == 0 else (tree_goal, tree_start)\n            sample = self._sample_free(bounds, obstacles, is_3d)\n            new_node = self._extend(tree_a, sample, obstacles, is_3d, nodes, edges)\n            if new_node:\n                connected_node = self._connect(tree_b, new_node, obstacles, is_3d, nodes, edges)\n                if connected_node:\n                    path_a = new_node.path_from_root()\n                    path_b = connected_node.path_from_root()\n                    if path_a[-1] == path_b[-1]:\n                        path = path_a + path_b[-2::-1]\n                    else:\n                        path = path_a + path_b[::-1]\n                    return PlannerResult(True, path, nodes, edges)\n        return PlannerResult(False, [], nodes, edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        import random\n        while True:\n            pt = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n            if not self._in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def _extend(self, tree, target, obstacles, is_3d, nodes, edges):\n        nearest = min(tree, key=lambda n: self._dist(n.position, target))\n        new_pos = self._steer(nearest.position, target)\n        if self._valid(nearest.position, new_pos, obstacles, is_3d):\n            new_node = Node(new_pos, nearest)\n            nearest.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest, new_node))\n            return new_node\n        return None\n\n    def _connect(self, tree, target_node, obstacles, is_3d, nodes, edges):\n        nearest = min(tree, key=lambda n: self._dist(n.position, target_node.position))\n        while True:\n            new_pos = self._steer(nearest.position, target_node.position)\n            if not self._valid(nearest.position, new_pos, obstacles, is_3d):\n                return None\n            new_node = Node(new_pos, nearest)\n            nearest.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest, new_node))\n            if self._dist(new_node.position, target_node.position) <= self.step_size:\n                if not self._valid(new_node.position, target_node.position, obstacles, is_3d):\n                    return None\n                final_node = Node(target_node.position, new_node)\n                new_node.add_child(final_node)\n                tree.append(final_node)\n                nodes.append(final_node)\n                edges.append((new_node, final_node))\n                return final_node\n            nearest = new_node\n\n    def _steer(self, start, goal):\n        dist = self._dist(start, goal)\n        if dist <= self.step_size:\n            return goal\n        ratio = self.step_size / dist\n        return tuple(start[d] + (goal[d] - start[d]) * ratio for d in range(len(start)))\n\n    def _valid(self, p1, p2, obstacles, is_3d):\n        return (not self._in_obstacle(p2, obstacles, is_3d)) and (not self._edge_in_obstacle(p1, p2, obstacles, is_3d))\n\n    def _in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x,y,z,w,h,d = obs\n                px,py,pz = pos\n                if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                    return True\n            else:\n                x,y,w,h = obs\n                px,py = pos\n                if x <= px <= x+w and y <= py <= y+h:\n                    return True\n        return False\n\n    def _edge_in_obstacle(self, p1, p2, obstacles, is_3d, res=1.0):\n        dist = self._dist(p1, p2)\n        steps = max(1, int(dist / res))\n        for i in range(steps+1):\n            interp = tuple(p1[d] + (p2[d] - p1[d]) * i / steps for d in range(len(p1)))\n            if self._in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _dist(self, a, b):\n        return sum((a[d] - b[d])**2 for d in range(len(a)))**0.5",
          "objective": -19.65905,
          "time_improvement": 71.0,
          "length_improvement": -3.0,
          "smoothness_improvement": 62.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.007035160064697265,
                    "num_nodes_avg": 86.2,
                    "path_length_avg": 189.39879686980154,
                    "smoothness_avg": 0.0102591145052943,
                    "success_improvement": 0.0,
                    "time_improvement": 73.20226714000162,
                    "length_improvement": -3.8124817803312583,
                    "smoothness_improvement": 60.57742003157615,
                    "objective_score": 19.976078173959614
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.03991465568542481,
                    "num_nodes_avg": 246.5,
                    "path_length_avg": 309.916942499886,
                    "smoothness_avg": 0.006220174309434665,
                    "success_improvement": 0.0,
                    "time_improvement": 75.82981242262478,
                    "length_improvement": -3.4591958710432116,
                    "smoothness_improvement": 60.04956519221755,
                    "objective_score": 20.973674030122595
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.0178729772567749,
                    "num_nodes_avg": 178.1,
                    "path_length_avg": 154.6893175478031,
                    "smoothness_avg": 0.013091758856632583,
                    "success_improvement": 0.0,
                    "time_improvement": 64.45715212295462,
                    "length_improvement": -2.737279201508942,
                    "smoothness_improvement": 66.52620632324673,
                    "objective_score": 18.027409147597258
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "A streamlined single-tree Rapidly-exploring Random Tree (RRT) planner that incrementally grows from start towards random samples with goal bias. It ensures node and edge collision-free conditions, and upon reaching the goal, generates the path without further smoothing for simplicity and faster general performance.",
          "planning_mechanism": "A single RRT tree grows by sampling points with goal bias, extending stepwise towards them if collision-free, and connects to the goal directly when reachable within step size, returning the raw path from start to goal.",
          "code": "class Node:\n    def __init__(self, position, parent=None):\n        self.position = position\n        self.parent = parent\n        self.children = []\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n    def path_from_root(self):\n        node, path = self, []\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=3000, step_size=5.0, goal_sample_rate=0.1):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map):\n        import random, math\n        start, goal = map.start, map.goal\n        bounds = map.size\n        obstacles = map.obstacles\n        dim = len(bounds)\n\n        def in_obstacle(p):\n            for obs in obstacles:\n                if dim == 3:\n                    x,y,z,w,h,d = obs\n                    if x <= p[0] <= x+w and y <= p[1] <= y+h and z <= p[2] <= z+d:\n                        return True\n                else:\n                    x,y,w,h = obs\n                    if x <= p[0] <= x+w and y <= p[1] <= y+h:\n                        return True\n            return False\n\n        def edge_collision(p1, p2):\n            dist = math.dist(p1, p2)\n            steps = max(1, int(dist))\n            for i in range(1, steps+1):\n                ip = tuple(p1[d] + (p2[d]-p1[d]) * i/steps for d in range(dim))\n                if in_obstacle(ip):\n                    return True\n            return False\n\n        def sample_point():\n            if random.random() < self.goal_sample_rate:\n                return goal\n            while True:\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not in_obstacle(p):\n                    return p\n\n        def nearest_node(tree, pt):\n            best, best_dist = None, float('inf')\n            for n in tree:\n                d = math.dist(n.position, pt)\n                if d < best_dist:\n                    best, best_dist = n, d\n            return best\n\n        def steer(from_p, to_p):\n            dist = math.dist(from_p, to_p)\n            if dist <= self.step_size:\n                return to_p\n            ratio = self.step_size / dist\n            return tuple(from_p[d] + ratio * (to_p[d]-from_p[d]) for d in range(dim))\n\n        tree = [Node(start)]\n        for _ in range(self.max_iter):\n            rnd = sample_point()\n            nearest = nearest_node(tree, rnd)\n            new_pos = steer(nearest.position, rnd)\n            if in_obstacle(new_pos) or edge_collision(nearest.position, new_pos):\n                continue\n            new_node = Node(new_pos, nearest)\n            nearest.add_child(new_node)\n            tree.append(new_node)\n\n            if math.dist(new_pos, goal) <= self.step_size and not edge_collision(new_pos, goal):\n                goal_node = Node(goal, new_node)\n                new_node.add_child(goal_node)\n                tree.append(goal_node)\n                path = goal_node.path_from_root()\n                edges = [(n.parent, n) for n in tree if n.parent]\n                return PlannerResult(True, path, tree, edges)\n\n        edges = [(n.parent, n) for n in tree if n.parent]\n        return PlannerResult(False, [], tree, edges)",
          "objective": -15.53064,
          "time_improvement": 55.0,
          "length_improvement": -2.0,
          "smoothness_improvement": 64.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.01205458641052246,
                    "num_nodes_avg": 258.6,
                    "path_length_avg": 189.8774316175603,
                    "smoothness_avg": 0.010339503801463782,
                    "success_improvement": 0.0,
                    "time_improvement": 54.08269557533536,
                    "length_improvement": -4.074829070030757,
                    "smoothness_improvement": 61.83568708477926,
                    "objective_score": 14.089089666006048
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.056881046295166014,
                    "num_nodes_avg": 942.9,
                    "path_length_avg": 307.6614641896531,
                    "smoothness_avg": 0.006310430817754817,
                    "success_improvement": 0.0,
                    "time_improvement": 65.55587077120757,
                    "length_improvement": -2.7062522907439193,
                    "smoothness_improvement": 62.37193016043031,
                    "objective_score": 18.35486950771807
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.027751445770263672,
                    "num_nodes_avg": 553.6,
                    "path_length_avg": 149.65863767791262,
                    "smoothness_avg": 0.013237491002032609,
                    "success_improvement": 0.0,
                    "time_improvement": 44.81247297471572,
                    "length_improvement": 0.6038588328393786,
                    "smoothness_improvement": 68.37990845590703,
                    "objective_score": 14.147956734397878
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e2",
          "algorithm_description": "A hybrid bidirectional informed RRT* variant employing adaptive rewiring, heuristic ellipsoidal sampling, and incremental connection attempts between trees. The algorithm balances exploration and exploitation by alternating tree expansions with focused sampling, adaptive neighborhood rewiring to improve path quality, strict obstacle collision checks on nodes and edges, and shortcutting path refinement to ensure smoothness and shortened path length. This mechanism effectively improves planning efficiency, robustness, and path optimality in cluttered environments.",
          "planning_mechanism": "The planner grows two trees from start and goal, samples informed points inside an ellipsoidal heuristic region for efficiency, extends trees toward sampled points with collision checks, rewires locally to improve path costs adaptively, attempts direct connections between trees, and performs path shortcutting as post-processing before returning the final solution.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n    def add_child(self, child):\n        self.children.append(child)\nclass Planner:\n    def __init__(self, max_iter=4000, step_size=5.0, base_rewire_radius=15.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.base_rewire_radius = base_rewire_radius\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        start_tree = [Node(start_pos, None, 0.0)]\n        goal_tree = [Node(goal_pos, None, 0.0)]\n        edges = []\n        best_cost = float('inf')\n        best_path = []\n\n        def dist(a,b):\n            import math\n            return math.dist(a,b)\n\n        def in_collision(p):\n            if any(p[d]<0 or p[d]>bounds[d] for d in range(dim)):\n                return True\n            for o in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d = o\n                    px,py,pz = p\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                        return True\n                else:\n                    x,y,w,h = o\n                    px,py = p\n                    if x <= px <= x+w and y <= py <= y+h:\n                        return True\n            return False\n\n        def edge_collision(p1,p2,res=1.0):\n            distance = dist(p1,p2)\n            steps = max(1,int(distance/res))\n            for i in range(steps+1):\n                interp = tuple(p1[d] + (p2[d]-p1[d])*i/steps for d in range(dim))\n                if in_collision(interp):\n                    return True\n            return False\n\n        def steer(from_p,to_p,step):\n            distance = dist(from_p,to_p)\n            if distance <= step:\n                return to_p\n            ratio = step / distance\n            return tuple(from_p[i] + (to_p[i]-from_p[i])*ratio for i in range(dim))\n\n        def nearest(tree, p):\n            # Returns node minimizing Euclidean distance to p\n            return min(tree, key=lambda n: dist(n.position, p))\n\n        def near(tree, p, radius):\n            r2 = radius*radius\n            result = []\n            for n in tree:\n                d2 = sum((n.position[i]-p[i])**2 for i in range(dim))\n                if d2 <= r2:\n                    result.append(n)\n            return result\n\n        def extract_path(node_start, node_goal):\n            path_start, path_goal = [], []\n            n = node_start\n            while n:\n                path_start.append(n.position)\n                n = n.parent\n            n = node_goal\n            while n:\n                path_goal.append(n.position)\n                n = n.parent\n            path_start.reverse()\n            return path_start + path_goal\n\n        def shortcut(path):\n            if len(path) <= 2:\n                return path\n            i = 0\n            while i < len(path)-2:\n                j = len(path)-1\n                while j > i+1:\n                    if not edge_collision(path[i], path[j]):\n                        path = path[:i+1] + path[j:]\n                        break\n                    j -= 1\n                i += 1\n            return path\n\n        def informed_sample(c_best):\n            import random, math\n            if c_best == float('inf'):\n                while True:\n                    pt = tuple(random.uniform(0,bounds[i]) for i in range(dim))\n                    if not in_collision(pt):\n                        return pt\n\n            c_min = dist(start_pos, goal_pos)\n            if c_min < 1e-10:\n                return goal_pos\n            center = tuple((start_pos[i]+goal_pos[i])*0.5 for i in range(dim))\n            a1 = [(goal_pos[i]-start_pos[i])/c_min for i in range(dim)]\n\n            # rotation matrix R aligning x-axis to a1\n            def mat_vec_mult(mat, vec):\n                return tuple(sum(mat[i][j]*vec[j] for j in range(dim)) for i in range(dim))\n\n            if dim == 2:\n                import math\n                theta = math.acos(max(min(a1[0],1.0),-1.0))\n                if a1[1] < 0:\n                    theta = -theta\n                R = [[math.cos(theta), -math.sin(theta)],\n                     [math.sin(theta),  math.cos(theta)]]\n            elif dim == 3:\n                x = a1\n                I = [[1 if i==j else 0 for j in range(3)] for i in range(3)]\n                v = [x[0]-1, x[1], x[2]]\n                norm_v = math.sqrt(sum(vi*vi for vi in v))\n                if norm_v < 1e-10:\n                    R = I\n                else:\n                    v = [vi/norm_v for vi in v]\n                    R = [[I[i][j]-2*v[i]*v[j] for j in range(3)] for i in range(3)]\n            else:\n                R = [[1 if i==j else 0 for j in range(dim)] for i in range(dim)]\n\n            L1 = c_best/2.0\n            L2 = math.sqrt(max(c_best*c_best - c_min*c_min, 0))/2.0\n\n            while True:\n                while True:\n                    sample = [random.uniform(-1,1) for _ in range(dim)]\n                    norm_s = math.sqrt(sum(x*x for x in sample))\n                    if 0 < norm_s <= 1:\n                        break\n                unit_s = [x/norm_s for x in sample]\n                r = random.uniform(0,1)**(1/dim)\n                unit_ball = [r*u for u in unit_s]\n                ellip = [L1*unit_ball[0]] + [L2*unit_ball[i] for i in range(1,dim)]\n                rotated = mat_vec_mult(R, ellip)\n                point = tuple(center[i]+rotated[i] for i in range(dim))\n                if all(0 <= point[i] <= bounds[i] for i in range(dim)) and (not in_collision(point)):\n                    return point\n\n        def rewire_radius(num_nodes):\n            import math\n            gamma_rrt = 2 * (1 + 1/dim)**(1/dim) * (pow(math.prod(bounds), 1/dim))\n            radius = min(self.base_rewire_radius, gamma_rrt * (math.log(num_nodes+1)/(num_nodes+1))**(1/dim))\n            return radius\n\n        def rewire(tree, new_node):\n            r = rewire_radius(len(tree))\n            neighbors = near(tree, new_node.position, r)\n            for nb in neighbors:\n                if nb == new_node.parent:\n                    continue\n                if edge_collision(new_node.position, nb.position):\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, nb.position)\n                if new_cost + 1e-9 < nb.cost:\n                    if nb.parent:\n                        try:\n                            nb.parent.children.remove(nb)\n                        except Exception:\n                            pass\n                    nb.parent = new_node\n                    nb.cost = new_cost\n                    new_node.add_child(nb)\n                # Try to improve new_node cost via neighbors as well\n                cost_to_new_via_nb = nb.cost + dist(nb.position, new_node.position)\n                if cost_to_new_via_nb + 1e-9 < new_node.cost and not edge_collision(nb.position, new_node.position):\n                    if new_node.parent:\n                        try:\n                            new_node.parent.children.remove(new_node)\n                        except Exception:\n                            pass\n                    new_node.parent = nb\n                    new_node.cost = cost_to_new_via_nb\n                    nb.add_child(new_node)\n\n        import random\n        for iteration in range(self.max_iter):\n            sample = informed_sample(best_cost)\n\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest_node = nearest(tree_a, sample)\n                new_pos = steer(nearest_node.position, sample, self.step_size)\n                if in_collision(new_pos):\n                    continue\n                if edge_collision(nearest_node.position, new_pos):\n                    continue\n                new_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n                new_node = Node(new_pos, parent=nearest_node, cost=new_cost)\n                nearest_node.add_child(new_node)\n                tree_a.append(new_node)\n                edges.append((nearest_node, new_node))\n\n                rewire(tree_a, new_node)\n\n                connect_node = nearest(tree_b, new_pos)\n                gap = dist(new_pos, connect_node.position)\n                if gap <= self.step_size * 1.8 and not edge_collision(new_pos, connect_node.position):\n                    connect_new = Node(connect_node.position, parent=new_node, cost=new_node.cost + gap)\n                    new_node.add_child(connect_new)\n                    tree_b.append(connect_new)\n                    edges.append((new_node, connect_new))\n\n                    # Extract combined path and shortcut it for smoothness\n                    path = extract_path(connect_new, connect_node)\n                    path = shortcut(path)\n\n                    # Compute cost\n                    cost_path = 0.0\n                    for i in range(len(path) - 1):\n                        cost_path += dist(path[i], path[i+1])\n                    if cost_path < best_cost:\n                        best_cost = cost_path\n                        best_path = path\n\n            if best_path:\n                return PlannerResult(True, best_path, start_tree + goal_tree, edges)\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)",
          "objective": -6.42831,
          "time_improvement": 4.0,
          "length_improvement": 18.0,
          "smoothness_improvement": 2195.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.03503596782684326,
                    "num_nodes_avg": 98.3,
                    "path_length_avg": 162.4431334838995,
                    "smoothness_avg": 0.04818856755938396,
                    "success_improvement": 0.0,
                    "time_improvement": -33.456026256830526,
                    "length_improvement": 10.96234446130194,
                    "smoothness_improvement": 654.2557254536857,
                    "objective_score": -0.18812257299956503
               },
               {
                    "map_id": 1,
                    "success_rate": 0.9,
                    "time_avg": 0.07711725234985352,
                    "num_nodes_avg": 259.7,
                    "path_length_avg": 227.74123825627717,
                    "smoothness_avg": 0.17653460763730278,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": 53.30190320473256,
                    "length_improvement": 23.973419501972636,
                    "smoothness_improvement": 4442.362607246129,
                    "objective_score": 2.5864356988340056
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.05447630882263184,
                    "num_nodes_avg": 199.7,
                    "path_length_avg": 120.57501083590122,
                    "smoothness_avg": 0.12476181654903722,
                    "success_improvement": 0.0,
                    "time_improvement": -8.333554592970774,
                    "length_improvement": 19.919818967816777,
                    "smoothness_improvement": 1486.9610975443823,
                    "objective_score": 16.886630490520744
               }
          ],
          "success_rate": 0.9666666666666667
     }
]