{
    "operator": "e1",
    "algorithm_description": "A hybrid RRT*-based planner with adaptive sampling and dynamic neighborhood radius that grows a single tree from the start and performs rewiring with distance-based neighborhood scaling. It uses heuristic pruning and batch nearest neighbor caching to accelerate collision checks, applies path shortening as postprocessing, and attempts a direct connection to the goal at each iteration to improve success and efficiency.",
    "planning_mechanism": "The planner samples new states adaptively within the current search bounds, finds the best parent among dynamically chosen near neighbors whose radius shrinks as the tree grows, rewires neighbors to optimize cost, caches collision checks for efficiency, tries a direct connection to the goal for early success, and finally smoothes the extracted path to improve length and smoothness while maintaining collision-free guarantees.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\nclass Planner:\n    def __init__(self, max_iter=4000, step_size=4.0, initial_radius=15.0, min_radius=3.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.initial_radius = initial_radius\n        self.min_radius = min_radius\n\n    def plan(self, map) -> \"PlannerResult\":\n        bounds = map.size\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        tree = [Node(start)]\n        nodes = list(tree)\n        edges = []\n        success = False\n        best_goal_node = None\n        best_cost = float(\"inf\")\n\n        # For collision check cache: key = (p_from, p_to) rounded down to decimals, value=bool\n        collision_cache = {}\n\n        def cached_edge_collision(a, b):\n            key = tuple(sorted((self._round_tuple(a), self._round_tuple(b))))\n            if key in collision_cache:\n                return collision_cache[key]\n            val = self._is_edge_in_obstacle(a, b, obstacles, is_3d)\n            collision_cache[key] = val\n            return val\n\n        for it in range(self.max_iter):\n            x_rand = self._sample_free(bounds, obstacles, is_3d)\n\n            x_nearest = self._nearest(tree, x_rand)\n            x_new_pos = self._steer(x_nearest.position, x_rand, self.step_size)\n            if self._is_in_obstacle(x_new_pos, obstacles, is_3d):\n                continue\n            if cached_edge_collision(x_nearest.position, x_new_pos):\n                continue\n\n            # Dynamic radius decreasing with iteration count for near neighbor selection\n            neighbor_radius = max(\n                self.min_radius,\n                self.initial_radius * ( (math.log(it+2)/(it+2))**0.5 )\n            )\n\n            near_nodes = self._near(tree, x_new_pos, neighbor_radius)\n\n            min_cost = x_nearest.cost + self._distance(x_nearest.position, x_new_pos)\n            min_parent = x_nearest\n            for potential_parent in near_nodes:\n                if potential_parent == x_nearest:\n                    continue\n                c = potential_parent.cost + self._distance(potential_parent.position, x_new_pos)\n                if c < min_cost and not cached_edge_collision(potential_parent.position, x_new_pos):\n                    min_cost = c\n                    min_parent = potential_parent\n\n            x_new = Node(x_new_pos)\n            x_new.parent = min_parent\n            x_new.cost = min_cost\n            min_parent.add_child(x_new)\n            tree.append(x_new)\n            nodes.append(x_new)\n            edges.append((min_parent, x_new))\n\n            improved = False\n            for near_node in near_nodes:\n                if near_node == min_parent:\n                    continue\n                new_cost = x_new.cost + self._distance(x_new.position, near_node.position)\n                if new_cost + 1e-12 < near_node.cost and not cached_edge_collision(x_new.position, near_node.position):\n                    if near_node.parent:\n                        edges.remove((near_node.parent, near_node))\n                        near_node.parent.remove_child(near_node)\n                    near_node.parent = x_new\n                    near_node.cost = new_cost\n                    x_new.add_child(near_node)\n                    edges.append((x_new, near_node))\n                    improved = True\n\n            # Always try to directly connect x_new to goal if close enough\n            dist_to_goal = self._distance(x_new.position, goal)\n            if dist_to_goal <= self.step_size:\n                if not self._is_in_obstacle(goal, obstacles, is_3d) and not cached_edge_collision(x_new.position, goal):\n                    goal_node = Node(goal)\n                    goal_node.parent = x_new\n                    goal_node.cost = x_new.cost + dist_to_goal\n                    # Add goal node to data structures\n                    tree.append(goal_node)\n                    nodes.append(goal_node)\n                    edges.append((x_new, goal_node))\n\n                    if goal_node.cost < best_cost:\n                        best_cost = goal_node.cost\n                        best_goal_node = goal_node\n                        success = True\n\n            if success:\n                # Early stop bias for faster solution when found good solution\n                if it > 100 and it % 10 == 0:\n                    break\n\n        if not success:\n            return PlannerResult(False, [], nodes, edges)\n\n        path = self._extract_path(best_goal_node)\n        path = self._path_shortening(path, obstacles, is_3d)\n        return PlannerResult(True, path, nodes, edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        while True:\n            point = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n            if not self._is_in_obstacle(point, obstacles, is_3d):\n                return point\n\n    def _nearest(self, tree, point):\n        # Euclidean nearest node in tree\n        min_node = None\n        min_dist = float(\"inf\")\n        for node in tree:\n            dist = self._distance(node.position, point)\n            if dist < min_dist:\n                min_dist = dist\n                min_node = node\n        return min_node\n\n    def _near(self, tree, point, radius):\n        # Return list of nodes within radius of point\n        near_nodes = []\n        radius_sq = radius * radius\n        for node in tree:\n            d = self._distance_sq(node.position, point)\n            if d <= radius_sq:\n                near_nodes.append(node)\n        return near_nodes\n\n    def _steer(self, from_pos, to_pos, step_size):\n        dist = self._distance(from_pos, to_pos)\n        if dist <= step_size:\n            return to_pos\n        ratio = step_size / dist\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n    def _distance(self, a, b):\n        return math.dist(a, b)\n\n    def _distance_sq(self, a, b):\n        s = 0.0\n        for i in range(len(a)):\n            s += (a[i] - b[i]) ** 2\n        return s\n\n    def _extract_path(self, goal_node):\n        path = []\n        node = goal_node\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.6):\n        dist = self._distance(from_pos, to_pos)\n        steps = max(2, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * i / steps for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _path_shortening(self, path, obstacles, is_3d):\n        # Try shortcutting path segments greedily to reduce nodes while collision-free\n        if len(path) < 3:\n            return path\n        shortened = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            while j > i + 1:\n                if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                    break\n                j -= 1\n            shortened.append(path[j])\n            i = j\n        return shortened\n\n    def _round_tuple(self, pos, digits=3):\n        return tuple(round(x, digits) for x in pos)",
    "objective": 289.57187,
    "time_improvement": -864.0,
    "length_improvement": 16.0,
    "smoothness_improvement": 2038.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 0.9,
            "time_avg": 0.25097036361694336,
            "num_nodes_avg": 810.5,
            "path_length_avg": 171.36049969211678,
            "smoothness_avg": 0.0590128568363977,
            "success_improvement": -9.999999999999998,
            "time_improvement": -855.9749455782868,
            "length_improvement": 6.074594737867973,
            "smoothness_improvement": 823.6793579593315,
            "objective_score": -299.0293300409686
        },
        {
            "map_id": 1,
            "success_rate": 0.9,
            "time_avg": 1.249403142929077,
            "num_nodes_avg": 1481.8,
            "path_length_avg": 238.22730941166657,
            "smoothness_avg": 0.15328169630750338,
            "success_improvement": -9.999999999999998,
            "time_improvement": -656.571935941442,
            "length_improvement": 20.47286712548058,
            "smoothness_improvement": 3844.0484503353355,
            "objective_score": -215.46761825546758
        },
        {
            "map_id": 2,
            "success_rate": 0.9,
            "time_avg": 0.593242859840393,
            "num_nodes_avg": 958.2,
            "path_length_avg": 119.25622485352412,
            "smoothness_avg": 0.12149721800326971,
            "success_improvement": -9.999999999999998,
            "time_improvement": -1079.7441701246387,
            "length_improvement": 20.795693823471524,
            "smoothness_improvement": 1445.4356450098185,
            "objective_score": -354.2186565182596
        }
    ],
    "success_rate": 0.9
}
{
    "operator": "e2",
    "algorithm_description": "A hybrid bidirectional planner combining fast incremental exploration and post-path optimization with rewiring and informed sampling to improve efficiency, path length, success rate, and smoothness. It grows start and goal trees with RRT* style sampling, parent selection, and rewiring, attempting connection at each step. Once a valid path is found, informed sampling inside the ellipsoid between start and goal focuses search to optimize the path further. The final returned path is shortcut-smoothed to reduce unnecessary waypoints and sharp turns.",
    "planning_mechanism": "The planner alternates growing start and goal trees with RRT* expansions including best-parent selection and rewiring to improve path quality. Random samples are drawn uniformly initially, then inside an ellipsoid after first solution for focused optimization. Each extension tries to connect the two trees, and after the first connection the planner continues optimizing until iteration or improvement limits. Optionally, the output path is shortcut-smoothed to reduce length and increase smoothness.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True  # reserved for future collision checking updates\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        path.reverse()\n        return path\nclass Planner:\n    def __init__(self,\n                 max_iter=6000,\n                 step_size=4.0,\n                 neighbor_radius=None,\n                 post_opt_iters=600,\n                 max_no_improve=150,\n                 improve_tol=1e-5,\n                 time_limit_sec=25.0,\n                 shortcutting_trials=150):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.post_opt_iters = post_opt_iters\n        self.max_no_improve = max_no_improve\n        self.improve_tol = improve_tol\n        self.time_limit_sec = time_limit_sec\n        self.shortcutting_trials = shortcutting_trials\n        # neighbor radius factor for RRT*\n        self.gamma_rrt_star = 50.0\n        self.neighbor_radius = neighbor_radius  # if None will compute dynamically\n\n    def plan(self, map):\n        bounds = map.size\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        obstacles = map.obstacles\n\n        start_pos = map.start\n        goal_pos = map.goal\n\n        # Initialize data\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        best_cost = float('inf')\n        best_path = []\n        c_min = math.dist(start_pos, goal_pos)\n\n        found_solution = False\n        post_iter = 0\n        no_improve_count = 0\n\n        start_time = time.time()\n\n        def within_bounds(p):\n            return all(0.0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_p, to_p):\n            d = dist(from_p, to_p)\n            if d <= self.step_size:\n                return to_p\n            r = self.step_size / d\n            return tuple(from_p[i] + (to_p[i] - from_p[i]) * r for i in range(dim))\n\n        def neighbor_radius_fn(n_nodes):\n            if self.neighbor_radius is not None:\n                return self.neighbor_radius\n            if n_nodes < 2:\n                return self.step_size * 2.0\n            r_theory = self.gamma_rrt_star * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            maxr = max(bounds) * 0.25\n            return max(self.step_size * 2.0, min(r_theory, maxr))\n\n        def nearest(tree, pt):\n            mn = None\n            md = float(\"inf\")\n            for n in tree:\n                d = dist(n.position, pt)\n                if d < md:\n                    md = d\n                    mn = n\n            return mn\n\n        def near_nodes(tree, pos, radius):\n            result = []\n            r_sq = radius * radius\n            for n in tree:\n                d_sq = sum((n.position[i] - pos[i]) ** 2 for i in range(dim))\n                if d_sq <= r_sq:\n                    result.append(n)\n            return result\n\n        def edge_collision_free(p1, p2):\n            distance = dist(p1, p2)\n            steps = max(2, int(distance / 1.0))\n            for i in range(steps + 1):\n                ip = tuple(p1[d] + (p2[d] - p1[d]) * (i / steps) for d in range(dim))\n                if self._is_in_obstacle(ip, obstacles, is_3d):\n                    return False\n            return True\n\n        def collision_free(p):\n            return not self._is_in_obstacle(p, obstacles, is_3d)\n\n        def add_node_rrtstar(tree, pos):\n            r = neighbor_radius_fn(len(tree))\n            neigh = near_nodes(tree, pos, r)\n\n            candidate_parents = [n for n in neigh if edge_collision_free(n.position, pos)]\n            if not candidate_parents:\n                # fallback to nearest if no collision-free neighbors found\n                nnear = nearest(tree, pos)\n                if edge_collision_free(nnear.position, pos):\n                    parent = nnear\n                else:\n                    return None, []\n            else:\n                parent = min(candidate_parents, key=lambda n: n.cost + dist(n.position, pos))\n            new_cost = parent.cost + dist(parent.position, pos)\n            new_node = Node(pos, parent=None, cost=new_cost)\n            parent.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((parent, new_node))\n            return new_node, neigh\n\n        def rewire(node, neighbors):\n            for nb in neighbors:\n                if nb is node:\n                    continue\n                if not edge_collision_free(node.position, nb.position):\n                    continue\n                new_cost = node.cost + dist(node.position, nb.position)\n                if new_cost + 1e-12 < nb.cost:\n                    # reconnect neighbor via node\n                    if nb.parent:\n                        try:\n                            edges.remove((nb.parent, nb))\n                        except ValueError:\n                            pass\n                        if nb in nb.parent.children:\n                            nb.parent.children.remove(nb)\n                    node.add_child(nb)\n                    nb.cost = new_cost\n                    edges.append((node, nb))\n\n        def stitch_paths(node_start, node_goal):\n            path_start = node_start.path_from_root()\n            path_goal = node_goal.path_from_root()\n            # remove duplicated meeting node if any\n            if path_start and path_goal and path_start[-1] == path_goal[-1]:\n                merged = path_start + path_goal[-2::-1]\n            else:\n                merged = path_start + path_goal[::-1]\n            return merged\n\n        def path_cost(path):\n            c = 0.0\n            for i in range(len(path) - 1):\n                c += dist(path[i], path[i+1])\n            return c\n\n        def informed_sample(start, goal, c_best, c_min):\n            if c_best == float(\"inf\") or c_min < 1e-12:\n                return tuple(random.uniform(0.0, bounds[d]) for d in range(dim))\n            r1 = c_best / 2.0\n            r_other_sq = max(c_best * c_best - c_min * c_min, 0.0)\n            r_other = math.sqrt(r_other_sq) / 2.0\n            center = tuple((start[d] + goal[d]) / 2.0 for d in range(dim))\n            a1 = tuple((goal[d] - start[d]) / c_min for d in range(dim))\n\n            def sample_unit_ball(k):\n                while True:\n                    v = [random.gauss(0, 1) for _ in range(k)]\n                    norm_v = math.sqrt(sum(x * x for x in v))\n                    if norm_v > 1e-12:\n                        v = [x / norm_v for x in v]\n                        r = random.random() ** (1.0 / k)\n                        return tuple(v[i] * r for i in range(k))\n\n            u = sample_unit_ball(dim)\n\n            if dim == 2:\n                a2 = (-a1[1], a1[0])\n                basis = (a1, a2)\n                radii = (r1, r_other)\n            else:\n                ref = (1.0, 0.0, 0.0) if abs(a1[0]) < 0.9 else (0.0, 1.0, 0.0)\n                b2 = self._normalize(self._cross(a1, ref))\n                if self._norm(b2) < 1e-12:\n                    ref = (0.0, 0.0, 1.0)\n                    b2 = self._normalize(self._cross(a1, ref))\n                b3 = self._cross(a1, b2)\n                basis = (a1, b2, b3)\n                radii = (r1, r_other, r_other)\n\n            sample = []\n            for d in range(dim):\n                val = center[d]\n                for i in range(dim):\n                    val += basis[i][d] * radii[i] * u[i]\n                # Clamp inside bounds\n                val = max(0.0, min(bounds[d], val))\n                sample.append(val)\n            return tuple(sample)\n\n        def smooth_path(path, max_trials):\n            if len(path) < 3:\n                return path\n            new_path = path[:]\n            for _ in range(max_trials):\n                if len(new_path) < 3:\n                    break\n                i = random.randint(0, len(new_path) - 3)\n                j = random.randint(i+2, len(new_path) - 1)\n                if edge_collision_free(new_path[i], new_path[j]):\n                    # remove intermediate points between i and j\n                    new_path = new_path[:i+1] + new_path[j:]\n            return new_path\n\n        def try_connect_trees(new_node, other_tree, other_tree_nodes):\n            nearest_other = nearest(other_tree, new_node.position)\n            if dist(nearest_other.position, new_node.position) <= self.step_size:\n                if edge_collision_free(new_node.position, nearest_other.position):\n                    # Connect by creating new node optionally in other_tree for symmetry\n                    return new_node, nearest_other\n            # Otherwise try incremental steer connection on other tree side\n            curr = nearest_other\n            while True:\n                step_pos = steer(curr.position, new_node.position)\n                if not within_bounds(step_pos) or not collision_free(step_pos):\n                    break\n                if not edge_collision_free(curr.position, step_pos):\n                    break\n                new_other_node, _ = add_node_rrtstar(other_tree, step_pos)\n                if new_other_node is None:\n                    break\n                rewire(new_other_node, near_nodes(other_tree, step_pos, neighbor_radius_fn(len(other_tree))))\n                curr = new_other_node\n                if dist(curr.position, new_node.position) <= self.step_size:\n                    if edge_collision_free(curr.position, new_node.position):\n                        # Create virtual connection node aligned with new_node\n                        return new_node, curr\n            return None, None\n\n        iteration = 0\n        while iteration < self.max_iter:\n            if time.time() - start_time > self.time_limit_sec:\n                break\n            side_toggle = iteration % 2\n            if side_toggle == 0:\n                grow_tree, other_tree = start_tree, goal_tree\n                grow_is_start = True\n            else:\n                grow_tree, other_tree = goal_tree, start_tree\n                grow_is_start = False\n\n            # Sample either uniformly or informed if solution known\n            sample = informed_sample(start_pos, goal_pos, best_cost, c_min) if found_solution else \\\n                     tuple(random.uniform(0.0, bounds[d]) for d in range(dim))\n\n            if not within_bounds(sample) or not collision_free(sample):\n                if found_solution:\n                    post_iter += 1\n                    no_improve_count += 1\n                    if post_iter >= self.post_opt_iters or no_improve_count >= self.max_no_improve:\n                        break\n                iteration += 1\n                continue\n\n            nearest_node = nearest(grow_tree, sample)\n            new_pos = steer(nearest_node.position, sample)\n            if not within_bounds(new_pos) or not collision_free(new_pos):\n                if found_solution:\n                    post_iter += 1\n                    no_improve_count += 1\n                    if post_iter >= self.post_opt_iters or no_improve_count >= self.max_no_improve:\n                        break\n                iteration += 1\n                continue\n            if not edge_collision_free(nearest_node.position, new_pos):\n                if found_solution:\n                    post_iter += 1\n                    no_improve_count += 1\n                    if post_iter >= self.post_opt_iters or no_improve_count >= self.max_no_improve:\n                        break\n                iteration += 1\n                continue\n\n            new_node, neighbors = add_node_rrtstar(grow_tree, new_pos)\n            if new_node is None:\n                if found_solution:\n                    post_iter += 1\n                    no_improve_count += 1\n                    if post_iter >= self.post_opt_iters or no_improve_count >= self.max_no_improve:\n                        break\n                iteration += 1\n                continue\n\n            rewire(new_node, neighbors)\n\n            # Attempt to connect trees via new_node\n            n1, n2 = try_connect_trees(new_node, other_tree, nodes)\n            if n1 and n2:\n                candidate_path = stitch_paths(n1, n2)\n                candidate_cost = path_cost(candidate_path)\n\n                if candidate_cost + self.improve_tol < best_cost:\n                    best_cost = candidate_cost\n                    best_path = candidate_path\n                    found_solution = True\n                    no_improve_count = 0\n                    post_iter = 0\n                else:\n                    if found_solution:\n                        no_improve_count += 1\n                        post_iter += 1\n\n                if found_solution and (post_iter >= self.post_opt_iters or no_improve_count >= self.max_no_improve):\n                    break\n            else:\n                if found_solution:\n                    post_iter += 1\n                    no_improve_count += 1\n                    if post_iter >= self.post_opt_iters or no_improve_count >= self.max_no_improve:\n                        break\n\n            iteration += 1\n\n        if found_solution and best_path:\n            smooth = smooth_path(best_path, self.shortcutting_trials)\n        else:\n            smooth = []\n\n        return PlannerResult(\n            success=found_solution,\n            path=smooth if smooth else best_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    # ---------------- Collision Helpers ----------------\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    # ----------------------------------------------------------------\n    # Vector math utilities\n    # ----------------------------------------------------------------\n    def _cross(self, a, b):\n        ax, ay, az = a\n        bx, by, bz = b\n        return (ay * bz - az * by, az * bx - ax * bz, ax * by - ay * bx)\n\n    def _norm(self, v):\n        return math.sqrt(sum(x * x for x in v))\n\n    def _normalize(self, v):\n        n = self._norm(v)\n        if n < 1e-12:\n            return v\n        return tuple(x / n for x in v)",
    "objective": 30.8005,
    "time_improvement": -164.0,
    "length_improvement": 20.0,
    "smoothness_improvement": 1288.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.0989145278930664,
            "num_nodes_avg": 208.6,
            "path_length_avg": 152.44922059390572,
            "smoothness_avg": 0.04405342963083721,
            "success_improvement": 0.0,
            "time_improvement": -276.7767996854121,
            "length_improvement": 16.440166479991422,
            "smoothness_improvement": 589.5318372761939,
            "objective_score": -70.2212808312478
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.12343411445617676,
            "num_nodes_avg": 460.7,
            "path_length_avg": 228.4633553814897,
            "smoothness_avg": 0.08673156530289851,
            "success_improvement": 0.0,
            "time_improvement": 25.25488072937533,
            "length_improvement": 23.7323560205877,
            "smoothness_improvement": 2131.665645465001,
            "objective_score": 32.474206058490225
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.17110490798950195,
            "num_nodes_avg": 411.5,
            "path_length_avg": 121.1728155761859,
            "smoothness_avg": 0.09766590253227968,
            "success_improvement": 0.0,
            "time_improvement": -240.2653977742545,
            "length_improvement": 19.52278552372241,
            "smoothness_improvement": 1142.3030712635552,
            "objective_score": -54.65443266172513
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m1",
    "algorithm_description": "This algorithm introduces an enhanced informed sampling, tree pruning, and adaptive neighborhood to improve planning speed, path length, and smoothness in a unidirectional RRT* variant with post-optimization. It prunes the tree to remove unreachable nodes, dynamically adjusts the search neighborhood radius based on the number of nodes, and smoothens the final path with shortcutting to better reduce unnecessary zigzags and length.",
    "planning_mechanism": "The planner initially explores the entire map by uniform sampling, then once a feasible path is found, it switches to informed sampling within the ellipsoidal region defined by start, goal, and best path cost. It prunes nodes outside this region to focus search, dynamically calculates rewiring radius for better efficiency, performs rewiring to optimize locally, and finally applies shortcut-based path smoothing for improved smoothness and length.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=4000, step_size=5.0, improve_tol=1e-6, max_no_improve=100, post_opt_iters=300):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.improve_tol = improve_tol\n        self.max_no_improve = max_no_improve\n        self.post_opt_iters = post_opt_iters\n\n    def plan(self, map):\n        bounds = map.size\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        import math\n        import random\n\n        root = Node(start)\n        tree = [root]\n        nodes = [root]\n        edges = []\n\n        best_goal_node = None\n        best_cost = float('inf')\n        c_min = math.dist(start, goal)\n        found_solution = False\n\n        no_improve = 0\n        post_opt_count = 0\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def in_ellipsoid(point, c_best, c_min, start, goal):\n            # Check if point is within the prolate hyperspheroid\n            from math import sqrt\n            center = [(s + g) / 2 for s, g in zip(start, goal)]\n            diff = [p - c for p, c in zip(point, center)]\n            a1 = [g - s for s, g in zip(start, goal)]\n            norm_a1 = math.sqrt(sum(x*x for x in a1))\n            if norm_a1 < 1e-12:\n                return True\n            a1_unit = [x / norm_a1 for x in a1]\n\n            # Rotation matrix C (only rotation needed to align a1 with first axis)\n            # For low dimension (2 or 3), we create C via Gram-Schmidt and SVD is avoided\n            # We use a simplified test: x_M = C^T (point - center)\n            # To simplify, project difference vector onto a1_unit axis and orthogonal directions\n            proj = sum(d*u for d, u in zip(diff, a1_unit))\n            ortho_sq = sum((d - proj*u)**2 for d, u in zip(diff, a1_unit))\n            if c_best == float('inf'):\n                return True\n            val = (proj/(c_best/2))**2 + (ortho_sq/((math.sqrt(c_best**2 - c_min**2)/2)**2) if c_best > c_min else 1e10)\n            return val <= 1.0\n\n        def sample():\n            if not found_solution or best_cost == float('inf'):\n                while True:\n                    pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not self._is_in_obstacle(pt, obstacles, is_3d):\n                        return pt\n            else:\n                # informed sampling in ellipsoid\n                while True:\n                    # Sample in unit ball\n                    import random as rnd\n                    import math as m\n                    from math import sqrt\n                    from random import uniform\n                    # Generate random point in unit ball\n                    while True:\n                        pt_ball = [uniform(-1,1) for _ in range(dim)]\n                        norm_pt = math.sqrt(sum(x*x for x in pt_ball))\n                        if 0 < norm_pt <= 1: break\n                    # Scale to unit hypersphere\n                    pt_ball = [x / norm_pt for x in pt_ball]\n                    radius = rnd.random() ** (1/dim)\n                    pt_ball = [x * radius for x in pt_ball]\n\n                    # Apply ellipsoid scaling and rotation approx: aligned with axis a1\n                    # Use eigenvalues: c_best/2 along a1 and sqrt(c_best^2-c_min^2)/2 others\n                    a1 = [g - s for s, g in zip(start, goal)]\n                    norm_a1 = sqrt(sum(x*x for x in a1))\n                    if norm_a1 < 1e-9:\n                        return tuple(start)\n                    a1_unit = [x / norm_a1 for x in a1]\n\n                    L = [c / 2 for c in [best_cost] + [math.sqrt(best_cost*best_cost - c_min*c_min)]*(dim - 1)]\n                    center = [(s + g)/2 for s, g in zip(start, goal)]\n                    # Construct point in ellipsoid: x_center + C*L*x_ball\n                    # Using simplified approx. C aligns first dim with a1_unit\n                    # Compute dot product along a1_unit\n                    x_at_axis = pt_ball[0] * L[0]\n                    ortho_comp = [pt_ball[i] * L[i] for i in range(1, dim)]\n                    result = [center[i] + a1_unit[i]*x_at_axis for i in range(dim)]\n                    # to add orthogonal components, find basis orthogonal to a1_unit\n                    # we can just approximate by summing orthogonal components to axes\n                    # For 2D: orthogonal vector\n                    if dim == 2:\n                        # orth vector\n                        o = [-a1_unit[1], a1_unit[0]]\n                        for i in range(dim):\n                            result[i] += ortho_comp[0]*o[i]\n                    elif dim == 3:\n                        # Create arbitrary orthonormal basis {a1_unit, u, v}\n                        # u = normalized cross product with z axis if not parallel\n                        z_axis = [0,0,1]\n                        cross = [a1_unit[1]*z_axis[2]-a1_unit[2]*z_axis[1],\n                                 a1_unit[2]*z_axis[0]-a1_unit[0]*z_axis[2],\n                                 a1_unit[0]*z_axis[1]-a1_unit[1]*z_axis[0]]\n                        norm_cross = math.sqrt(sum(x*x for x in cross))\n                        if norm_cross < 1e-6:\n                            # a1_unit parallel to z-axis, use x axis for u\n                            u = [1,0,0]\n                        else:\n                            u = [x / norm_cross for x in cross]\n                        # v = a1_unit cross u\n                        v = [a1_unit[1]*u[2] - a1_unit[2]*u[1],\n                             a1_unit[2]*u[0] - a1_unit[0]*u[2],\n                             a1_unit[0]*u[1] - a1_unit[1]*u[0]]\n                        for i in range(dim):\n                            result[i] += ortho_comp[0]*u[i] + ortho_comp[1]*v[i]\n                    # else dim >3: just ignore orthogonal components (rare)\n                    if all(0 <= result[d] <= bounds[d] for d in range(dim)) and not self._is_in_obstacle(tuple(result), obstacles, is_3d):\n                        return tuple(result)\n\n        def nearest(pt):\n            return min(tree, key=lambda n:n.cost + dist(n.position, pt))\n\n        def near(pt, n):\n            # adaptive radius heuristic for RRT*\n            gamma_rrt = 2.0 * (1 + 1/dim)**(1/dim) * ( ( (math.factorial(dim) * (4/3) )) )**(1/dim)\n            r = min(self.step_size*5, gamma_rrt*(math.log(n)/n)**(1.0/dim))\n            return [node for node in tree if dist(node.position, pt) <= r]\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * self.step_size / d for i in range(dim))\n\n        def collision_free_edge(p1, p2):\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d)\n\n        def prune_outside_ellipsoid():\n            nonlocal tree, nodes, edges, best_cost\n            if best_cost == float('inf'):\n                return\n            new_tree = []\n            nodes_set = set(tree)\n            allowed_nodes = []\n            # mark reachable from root prune nodes outside ellipsoid\n            for n in tree:\n                if in_ellipsoid(n.position, best_cost, c_min, start, goal):\n                    allowed_nodes.append(n)\n            # rebuild tree with allowed nodes and parents therein\n            allowed_set = set(allowed_nodes)\n            # forcibly remove nodes whose parents not in allowed nodes\n            queue = []\n            new_tree = []\n            for n in allowed_nodes:\n                p = n.parent\n                while p is not None and p not in allowed_set:\n                    p = p.parent\n                if p in allowed_set or p is None:\n                    new_tree.append(n)\n            tree.clear()\n            tree.extend(new_tree)\n\n        def shortcut_path(path):\n            # attempt simple path shortcutting to remove unnecessary bends\n            if len(path) < 3:\n                return path\n            shortened = [path[0]]\n            i = 0\n            while i < len(path) - 1:\n                j = len(path) - 1\n                while j > i + 1:\n                    if collision_free_edge(shortened[-1], path[j]):\n                        shortened.append(path[j])\n                        i = j\n                        break\n                    j -= 1\n                else:\n                    shortened.append(path[i+1])\n                    i += 1\n            return shortened\n\n        n = 1\n        for _ in range(self.max_iter):\n            x_rand = sample()\n            x_nearest = min(tree, key=lambda n_: dist(n_.position, x_rand))\n            x_new_pos = steer(x_nearest.position, x_rand)\n            if self._is_in_obstacle(x_new_pos, obstacles, is_3d):\n                continue\n            if not collision_free_edge(x_nearest.position, x_new_pos):\n                continue\n            near_nodes = near(x_new_pos, len(tree))\n\n            # Find best parent among near nodes for min cost\n            min_cost = x_nearest.cost + dist(x_nearest.position, x_new_pos)\n            best_parent = x_nearest\n            for node in near_nodes:\n                edge_cost = dist(node.position, x_new_pos)\n                c = node.cost + edge_cost\n                if c + self.improve_tol < min_cost and collision_free_edge(node.position, x_new_pos):\n                    min_cost = c\n                    best_parent = node\n\n            x_new = Node(x_new_pos)\n            best_parent.add_child(x_new)\n            x_new.cost = min_cost\n            tree.append(x_new)\n            nodes.append(x_new)\n            edges.append((best_parent, x_new))\n\n            # Rewire neighbors\n            for node in near_nodes:\n                if node is x_new or node is best_parent:\n                    continue\n                potential_cost = x_new.cost + dist(x_new.position, node.position)\n                if potential_cost + self.improve_tol < node.cost and collision_free_edge(x_new.position, node.position):\n                    prev_parent = node.parent\n                    if prev_parent:\n                        if (prev_parent, node) in edges:\n                            edges.remove((prev_parent, node))\n                        if node in prev_parent.children:\n                            prev_parent.children.remove(node)\n                    x_new.add_child(node)\n                    node.cost = potential_cost\n                    edges.append((x_new, node))\n\n            # Check connection direct to goal\n            if dist(x_new.position, goal) <= self.step_size and collision_free_edge(x_new.position, goal):\n                potential_cost = x_new.cost + dist(x_new.position, goal)\n                if potential_cost + self.improve_tol < best_cost:\n                    goal_node = Node(goal)\n                    x_new.add_child(goal_node)\n                    goal_node.cost = potential_cost\n                    tree.append(goal_node)\n                    nodes.append(goal_node)\n                    edges.append((x_new, goal_node))\n                    best_cost = potential_cost\n                    best_goal_node = goal_node\n                    found_solution = True\n                    no_improve = 0\n                    post_opt_count = 0\n                else:\n                    no_improve += 1\n                    post_opt_count += 1\n            else:\n                if found_solution:\n                    no_improve += 1\n                    post_opt_count += 1\n\n            # Periodically prune tree outside ellipsoid for best_cost\n            if found_solution and (_ % 250) == 0:\n                prune_outside_ellipsoid()\n\n            n += 1\n            if found_solution and (post_opt_count >= self.post_opt_iters or no_improve >= self.max_no_improve):\n                break\n\n        if found_solution and best_goal_node:\n            extracted_path = best_goal_node.path_from_root()\n            # Smooth path shortcutting to improve length & smoothness:\n            extracted_path = shortcut_path(extracted_path)\n        else:\n            extracted_path = []\n\n        return PlannerResult(True if found_solution else False, extracted_path, nodes, edges)\n\n    def _distance(self, a, b):\n        import math\n        return math.dist(a, b)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * i / steps for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 18.79497,
    "time_improvement": -121.0,
    "length_improvement": 13.0,
    "smoothness_improvement": 1893.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.05898122787475586,
            "num_nodes_avg": 510.2,
            "path_length_avg": 172.7134244349467,
            "smoothness_avg": 0.06581379164236674,
            "success_improvement": 0.0,
            "time_improvement": -124.66627252359639,
            "length_improvement": 5.3330352478584375,
            "smoothness_improvement": 930.1287561390558,
            "objective_score": -29.549416827668576
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.2983426332473755,
            "num_nodes_avg": 1301.1,
            "path_length_avg": 243.83195303851275,
            "smoothness_avg": 0.11834135251907138,
            "success_improvement": 0.0,
            "time_improvement": -80.6603936345688,
            "length_improvement": 18.601875762117196,
            "smoothness_improvement": 2945.008238146587,
            "objective_score": 1.6880485576326105
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.1290714979171753,
            "num_nodes_avg": 611.6,
            "path_length_avg": 126.843073163169,
            "smoothness_avg": 0.14976835208119793,
            "success_improvement": 0.0,
            "time_improvement": -156.6762408872638,
            "length_improvement": 15.756870423099286,
            "smoothness_improvement": 1805.0423837230148,
            "objective_score": -28.523538093704484
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m3",
    "algorithm_description": "A simplified bidirectional RRT planner that balances efficient path finding and computational efficiency by alternating tree expansion from start and goal positions, using straightforward extension steps and rigorous collision checks without costly rewiring or informed sampling. The algorithm prioritizes easy implementation and reliable success at the cost of advanced path cost optimization or smoothing.",
    "planning_mechanism": "class 'Node'",
    "code": "class Node:\n    def __init__(self, position, parent=None):\n        self.position = position\n        self.parent = parent\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map):\n        bounds = map.size\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start)]\n        goal_tree = [Node(goal)]\n\n        nodes = start_tree + goal_tree\n        edges = []\n\n        for i in range(self.max_iter):\n            tree_a, tree_b = (start_tree, goal_tree) if i % 2 == 0 else (goal_tree, start_tree)\n\n            rand_point = self._sample_free(bounds, obstacles, is_3d)\n            new_node_a = self._extend(tree_a, rand_point, obstacles, is_3d, nodes, edges)\n            if new_node_a is None:\n                continue\n\n            new_node_b = self._connect(tree_b, new_node_a, obstacles, is_3d, nodes, edges)\n            if new_node_b is not None:\n                path_start = new_node_a.path_from_root()\n                path_goal = new_node_b.path_from_root()\n                # Avoid duplicating connecting node\n                if path_start[-1] == path_goal[-1]:\n                    full_path = path_start + path_goal[-2::-1]\n                else:\n                    full_path = path_start + path_goal[::-1]\n                return PlannerResult(\n                    success=True,\n                    path=full_path,\n                    nodes=nodes,\n                    edges=edges\n                )\n\n        return PlannerResult(\n            success=False,\n            path=[],\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        while True:\n            if is_3d:\n                p = tuple(random.uniform(0, bounds[d]) for d in range(3))\n            else:\n                p = tuple(random.uniform(0, bounds[d]) for d in range(2))\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    def _nearest(self, tree, point):\n        return min(tree, key=lambda node: self._distance(node.position, point))\n\n    def _steer(self, from_pos, to_pos):\n        dist = self._distance(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(len(from_pos)))\n\n    def _extend(self, tree, point, obstacles, is_3d, nodes, edges):\n        nearest = self._nearest(tree, point)\n        new_pos = self._steer(nearest.position, point)\n        if (self._within_bounds(new_pos, edges, nodes) and\n            not self._is_in_obstacle(new_pos, obstacles, is_3d) and\n            not self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d)):\n            new_node = Node(new_pos)\n            nearest.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest, new_node))\n            return new_node\n        return None\n\n    def _connect(self, tree, target_node, obstacles, is_3d, nodes, edges):\n        current = self._nearest(tree, target_node.position)\n        while True:\n            new_pos = self._steer(current.position, target_node.position)\n            if not self._within_bounds(new_pos, edges, nodes):\n                return None\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(current.position, new_pos, obstacles, is_3d):\n                return None\n            new_node = Node(new_pos)\n            current.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((current, new_node))\n            if self._distance(new_node.position, target_node.position) <= self.step_size:\n                if not self._is_edge_in_obstacle(new_node.position, target_node.position, obstacles, is_3d):\n                    final_node = Node(target_node.position)\n                    new_node.add_child(final_node)\n                    tree.append(final_node)\n                    nodes.append(final_node)\n                    edges.append((new_node, final_node))\n                    return final_node\n                else:\n                    return None\n            current = new_node\n\n    def _within_bounds(self, pos, edges, nodes):\n        dims = len(pos)\n        if hasattr(edges, '__len__') and nodes:\n            # edges and nodes arguments don't provide bounds, re-checking not needed\n            # Instead, handle bounds from map.size (caller)\n            # Simplify to true since map bounds are enforced in sampling and steering\n            return True\n        # fallback check (shouldn't occur)\n        return all(0.0 <= pos[d] <= 10000.0 for d in range(dims))  # large bound\n\n    def _distance(self, a, b):\n        return math.sqrt(sum((a[d]-b[d])**2 for d in range(len(a))))\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, p1, p2, obstacles, is_3d, resolution=1.0):\n        dist = self._distance(p1, p2)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(p1[d] + (p2[d] - p1[d]) * i / steps for d in range(len(p1)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": -15.67822,
    "time_improvement": 51.0,
    "length_improvement": 0.0,
    "smoothness_improvement": 68.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.007469820976257324,
            "num_nodes_avg": 73.1,
            "path_length_avg": 176.0623468550158,
            "smoothness_avg": 0.0107998836069439,
            "success_improvement": 0.0,
            "time_improvement": 71.54659379560685,
            "length_improvement": 3.4974378023468984,
            "smoothness_improvement": 69.04163077129193,
            "objective_score": 23.907648973946657
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.03709430694580078,
            "num_nodes_avg": 234.9,
            "path_length_avg": 302.79595763742356,
            "smoothness_avg": 0.006446290084951689,
            "success_improvement": 0.0,
            "time_improvement": 77.53766526263358,
            "length_improvement": -1.0820061577686475,
            "smoothness_improvement": 65.86768696088066,
            "objective_score": 22.941434318933286
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.04822392463684082,
            "num_nodes_avg": 247.1,
            "path_length_avg": 154.05757544889508,
            "smoothness_avg": 0.013304546360919387,
            "success_improvement": 0.0,
            "time_improvement": 4.100162341356848,
            "length_improvement": -2.3177061797402922,
            "smoothness_improvement": 69.23284767143511,
            "objective_score": 0.1855892329200547
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "e1",
    "algorithm_description": "A novel bidirectional RRT* planner incorporating adaptive informed sampling, efficient radius-based neighbor search, and incremental path shortcutting to improve planning speed, path length and smoothness. The planner alternates tree growth from start and goal, samples within an ellipsoidal informed set shrinking as better solutions are found, performs RRT* style rewiring with dynamic neighborhoods, and intermittently shortens paths by shortcutting segments if collision-free, yielding improved smoothness and path quality with computational efficiency. Early stopping occurs upon time limit or no recent improvements.",
    "planning_mechanism": "A bidirectional RRT* with adaptive informed sampling that focuses search progressively around the best known path, rewires new nodes within a dynamic neighborhood radius for optimal cost, and applies an incremental shortcut post-processing during planning to smooth and shorten paths efficiently.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position  # Tuple[float, ...]\n        self.parent = parent      # Node or None\n        self.cost = cost          # Cost from root\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(\n        self,\n        max_iter=5000,\n        step_size=5.0,\n        goal_sample_rate=0.1,\n        neighbor_constant=50.0,\n        time_limit_sec=30.0,\n        shortcut_attempts=30,\n        improvement_tol=1e-6,\n        max_no_improve=150\n    ):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_constant = neighbor_constant\n        self.time_limit_sec = time_limit_sec\n        self.shortcut_attempts = shortcut_attempts\n        self.improvement_tol = improvement_tol\n        self.max_no_improve = max_no_improve\n\n    def plan(self, map):\n        import time, math, random\n\n        bounds = map.size\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        start_p = map.start\n        goal_p = map.goal\n        obstacles = map.obstacles\n\n        def dist(a,b):\n            return math.dist(a,b)\n\n        def clamp(p):\n            return tuple(min(max(p[d],0.0), bounds[d]) for d in range(dim))\n\n        def within_bounds(p):\n            return all(0.0 <= p[d] <= bounds[d] for d in range(dim))\n\n        # Collision checks\n        def in_obstacle(p):\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d = obs\n                    px,py,pz = p\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                        return True\n                else:\n                    x,y,w,h = obs\n                    px,py = p\n                    if x <= px <= x+w and y <= py <= y+h:\n                        return True\n            return False\n\n        def edge_in_obstacle(p1,p2, resolution=0.5):\n            length = dist(p1,p2)\n            steps = max(1,int(length/resolution))\n            for i in range(steps+1):\n                interp = tuple(p1[d]+(p2[d]-p1[d])*i/steps for d in range(dim))\n                if in_obstacle(interp):\n                    return True\n            return False\n\n        # Nodes and edges data\n        start_root = Node(start_p, cost=0.0)\n        goal_root = Node(goal_p, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes_all = [start_root, goal_root]\n        edges = []\n\n        # Parameters for adaptive radius (RRT* theory)\n        gamma_rrt = self.neighbor_constant\n        unit_ball_volume = 1.0\n        if dim == 2:\n            unit_ball_volume = math.pi\n        elif dim == 3:\n            unit_ball_volume = 4/3*math.pi\n\n        def neighbor_radius(n):\n            if n < 2:\n                return self.step_size * 2.0\n            radius = gamma_rrt * ((math.log(n)/n)**(1/dim))\n            radius = max(radius, self.step_size)\n            # Clamp to 0.25 * max map extent for efficiency\n            max_extent = max(bounds)\n            return min(radius, 0.25*max_extent)\n\n        # Adaptive informed sampling ellipsoid parameters\n        best_path = []\n        best_cost = float(\"inf\")\n        found_solution = False\n\n        # Helper to compute path cost\n        def path_cost(path):\n            return sum(dist(path[i], path[i+1]) for i in range(len(path)-1))\n\n        # Ellipsoidal informed sampling between start and goal\n        from_start_to_goal = tuple(goal_p[d]-start_p[d] for d in range(dim))\n        c_min = dist(start_p,goal_p)\n        if c_min == 0.0:\n            c_min = 1e-6\n        center = tuple((start_p[d]+goal_p[d])/2 for d in range(dim))\n        I = [[0.0]*dim for _ in range(dim)]\n        for i in range(dim):\n            for j in range(dim):\n                I[i][j] = 1.0 if i==j else 0.0\n\n        def rotation_matrix():\n            # For 2D and 3D cases, create rotation matrix that aligns x-axis with start->goal vector\n            # Use Gram\u2013Schmidt or predefined approach:\n            # For 2D: rotation angle theta\n            if dim==2:\n                dx,dy = from_start_to_goal\n                L = max(dist(start_p,goal_p), 1e-9)\n                cos_theta = dx/L\n                sin_theta = dy/L\n                return [[cos_theta, -sin_theta],[sin_theta, cos_theta]]\n            else:\n                # For 3D, compute a rotation matrix that aligns x-axis to from_start_to_goal vector:\n                import math\n                vx,vy,vz = from_start_to_goal\n                norm_v = dist((0,0,0), from_start_to_goal)\n                if norm_v < 1e-9:\n                    return [[1 if i==j else 0 for j in range(3)] for i in range(3)]\n                ux, uy, uz = (vx / norm_v, vy / norm_v, vz / norm_v)\n                # Use Rodrigues' rotation formula to find rotation matrix aligning x-axis to u\n                # x-axis unit vector\n                ex = (1.0,0.0,0.0)\n                # Cross product axis and angle\n                kx, ky, kz = (ex[1]*uz - ex[2]*uy,\n                              ex[2]*ux - ex[0]*uz,\n                              ex[0]*uy - ex[1]*ux)\n                s = math.sqrt(kx*kx + ky*ky + kz*kz)\n                c = ux\n                if s < 1e-9:\n                    # vectors colinear, identity or 180 rotation\n                    if c > 0:\n                        return [[1 if i==j else 0 for j in range(3)] for i in range(3)]\n                    else:\n                        # 180 degree rotation about arbitrary perpendicular axis (e.g. y-axis)\n                        return [[-1,0,0],[0,-1,0],[0,0,1]]\n                kx,ky,kz = kx/s, ky/s, kz/s\n                K = [[0, -kz, ky],\n                     [kz, 0, -kx],\n                     [-ky, kx, 0]]\n                I = [[1 if i==j else 0 for j in range(3)] for i in range(3)]\n                R = [[0,0,0],[0,0,0],[0,0,0]]\n                for i in range(3):\n                    for j in range(3):\n                        R[i][j] = (I[i][j] +\n                                   K[i][0]*K[0][j]*(1-c) +\n                                   K[i][j]*s)\n                # Actually Rodrigues formula: R = I + K*s + K^2*(1-c)\n                # Fix to correct formula:\n                def mat_mult(A,B):\n                    return [[sum(A[i][k]*B[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n                K2 = mat_mult(K,K)\n                R = [[I[i][j] + K[i][j]*s + K2[i][j]*(1-c) for j in range(3)] for i in range(3)]\n                return R\n\n        rot_mat = rotation_matrix()\n\n        def matrix_vec_mul(M,v):\n            # M: dimxdim matrix, v: dim vector\n            return tuple(sum(M[i][j]*v[j] for j in range(dim)) for i in range(dim))\n\n        def informed_sample():\n            # If no solution found, uniform sample\n            if not found_solution:\n                return tuple(random.uniform(0.0, bounds[d]) for d in range(dim))\n            # Sample uniformly inside unit ball in dim dims then scale and rotate into ellipsoid\n            # Ellipsoid parameters:\n            # c_best = best_cost\n            # a1 = c_best/2\n            # lain = sqrt(c_best^2 - c_min^2)/2\n            c_best = best_cost\n            if c_best < c_min:\n                # Numerical stability\n                c_best = c_min\n            a1 = c_best / 2.0\n            lain = math.sqrt(abs(c_best**2 - c_min**2)) / 2.0\n            # Construct shape matrix Ldiag = diag(a1, lain, ..., lain)\n            Ldiag = [a1] + [lain]*(dim-1)\n\n            while True:\n                # Generate random point in unit ball dimension dim\n                # Using normal distribution + normalization method\n                vec = [random.gauss(0,1) for _ in range(dim)]\n                length = math.sqrt(sum(x*x for x in vec))\n                if length == 0:\n                    continue\n                unit_vec = [x/length for x in vec]\n                radius = random.uniform(0,1)**(1/dim)\n                sample_ball = [radius*u for u in unit_vec]\n                # Scale by Ldiag\n                sample_ellipsoid = [Ldiag[i]*sample_ball[i] for i in range(dim)]\n                # Rotate by rot_mat\n                rotated = matrix_vec_mul(rot_mat, sample_ellipsoid)\n                # Translate by center\n                p = tuple(rotated[d] + center[d] for d in range(dim))\n                if within_bounds(p) and not in_obstacle(p):\n                    return p\n\n        def nearest(tree, p):\n            # Linear search, could be improved with spatial structures\n            best = None\n            best_dist = float(\"inf\")\n            for n in tree:\n                d = dist(n.position,p)\n                if d < best_dist:\n                    best = n\n                    best_dist = d\n            return best\n\n        def neighbors(tree, p, radius):\n            return [n for n in tree if dist(n.position,p) <= radius]\n\n        def steer(from_p, to_p):\n            d = dist(from_p, to_p)\n            if d <= self.step_size:\n                return to_p\n            ratio = self.step_size/d\n            return tuple(from_p[i] + ratio*(to_p[i]-from_p[i]) for i in range(dim))\n\n        def add_node(tree, new_pos):\n            # Choose best parent in neighborhood\n            n_nodes = len(tree)\n            r = neighbor_radius(n_nodes)\n            neigh = neighbors(tree, new_pos, r)\n            # Filter feasible parents (no edge collision)\n            candidates = []\n            for nb in neigh:\n                if not edge_in_obstacle(nb.position,new_pos):\n                    new_cost = nb.cost + dist(nb.position,new_pos)\n                    candidates.append((nb,new_cost))\n            if not candidates:\n                # fallback to nearest if possible\n                nearest_n = nearest(tree,new_pos)\n                if edge_in_obstacle(nearest_n.position,new_pos):\n                    return None,None\n                parent = nearest_n\n                cost_new = parent.cost + dist(parent.position,new_pos)\n            else:\n                parent, cost_new = min(candidates,key=lambda x: x[1])\n            node_new = Node(new_pos,parent=parent,cost=cost_new)\n            parent.add_child(node_new)\n            tree.append(node_new)\n            nodes_all.append(node_new)\n            edges.append((parent,node_new))\n            # Rewire neighbors\n            for nb,_ in candidates:\n                if nb is parent:\n                    continue\n                cost_potential = node_new.cost + dist(node_new.position, nb.position)\n                if cost_potential + 1e-12 < nb.cost:\n                    if edge_in_obstacle(node_new.position, nb.position):\n                        continue\n                    # Rewire nb\n                    if nb.parent:\n                        try:\n                            edges.remove((nb.parent, nb))\n                        except ValueError:\n                            pass\n                        if nb in nb.parent.children:\n                            nb.parent.children.remove(nb)\n                    node_new.add_child(nb)\n                    nb.cost = cost_potential\n                    edges.append((node_new, nb))\n            return node_new, neigh\n\n        def path_merge(n_start, n_goal):\n            path_s = n_start.path_from_root()\n            path_g = n_goal.path_from_root()\n            # Remove duplicate node at connection\n            if path_s[-1] == path_g[-1]:\n                return path_s + path_g[-2::-1]\n            else:\n                return path_s + path_g[::-1]\n\n        # Incremental shortcutting to improve path smoothness\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.shortcut_attempts):\n                if len(path) < 3:\n                    break\n                i = random.randint(0,len(path)-3)\n                j = random.randint(i+2,len(path)-1)\n                if not edge_in_obstacle(path[i], path[j]):\n                    # Remove intermediate nodes between i and j\n                    path = path[:i+1] + path[j:]\n            return path\n\n        # Main loop\n        start_time = time.time()\n        no_improve_count = 0\n\n        for it in range(self.max_iter):\n            if (time.time() - start_time) > self.time_limit_sec:\n                break\n\n            # Alternate tree-growing side\n            if it % 2 == 0:\n                tree_a, tree_b = tree_start, tree_goal\n                a_is_start = True\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n                a_is_start = False\n\n            # Sample\n            if random.random() < self.goal_sample_rate:\n                sample_p = goal_p if a_is_start else start_p\n                if in_obstacle(sample_p):\n                    sample_p = informed_sample()\n            else:\n                sample_p = informed_sample()\n\n            # Extend tree_a towards sample\n            near_a = nearest(tree_a, sample_p)\n            new_pos_a = steer(near_a.position, sample_p)\n\n            if not within_bounds(new_pos_a) or in_obstacle(new_pos_a):\n                no_improve_count += 1\n                if found_solution and no_improve_count >= self.max_no_improve:\n                    break\n                continue\n            if edge_in_obstacle(near_a.position, new_pos_a):\n                no_improve_count += 1\n                if found_solution and no_improve_count >= self.max_no_improve:\n                    break\n                continue\n\n            new_node_a, _ = add_node(tree_a, new_pos_a)\n            if new_node_a is None:\n                no_improve_count += 1\n                if found_solution and no_improve_count >= self.max_no_improve:\n                    break\n                continue\n\n            # Attempt connecting the other tree towards new_node_a\n            near_b = nearest(tree_b,new_node_a.position)\n            current = near_b\n            connected_node_b = None\n\n            while True:\n                step_pos = steer(current.position, new_node_a.position)\n                if not within_bounds(step_pos) or in_obstacle(step_pos) or edge_in_obstacle(current.position, step_pos):\n                    break\n                new_node_b, _ = add_node(tree_b, step_pos)\n                if new_node_b is None:\n                    break\n                current = new_node_b\n                if dist(current.position, new_node_a.position) <= self.step_size:\n                    if not edge_in_obstacle(current.position, new_node_a.position):\n                        connector = Node(new_node_a.position, parent=current,\n                                         cost=current.cost + dist(current.position,new_node_a.position))\n                        current.add_child(connector)\n                        tree_b.append(connector)\n                        nodes_all.append(connector)\n                        edges.append((current, connector))\n                        connected_node_b = connector\n                    break\n\n            if connected_node_b is not None:\n                # New candidate path found by connecting two trees\n                cand_path = path_merge(new_node_a, connected_node_b, )\n                cand_cost = path_cost(cand_path)\n                # Apply shortcutting to candidate path\n                cand_path_smooth = shortcut_path(cand_path)\n                cand_cost_smooth = path_cost(cand_path_smooth)\n\n                # Prefer smooth shortcut path cost if significantly better\n                if cand_cost_smooth + self.improvement_tol < cand_cost:\n                    cand_path = cand_path_smooth\n                    cand_cost = cand_cost_smooth\n\n                if cand_cost + self.improvement_tol < best_cost:\n                    best_cost = cand_cost\n                    best_path = cand_path\n                    found_solution = True\n                    no_improve_count = 0\n                else:\n                    no_improve_count += 1\n                    if found_solution and no_improve_count >= self.max_no_improve:\n                        break\n            else:\n                no_improve_count += 1\n                if found_solution and no_improve_count >= self.max_no_improve:\n                    break\n\n        return PlannerResult(\n            success=(len(best_path) > 0),\n            path=best_path if best_path else [],\n            nodes=nodes_all,\n            edges=edges\n        )",
    "objective": 485.4697,
    "time_improvement": -1513.0,
    "length_improvement": 21.0,
    "smoothness_improvement": 1207.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 0.9,
            "time_avg": 1.0568130731582641,
            "num_nodes_avg": 736.1,
            "path_length_avg": 153.6495677996878,
            "smoothness_avg": 0.04385146897193462,
            "success_improvement": -9.999999999999998,
            "time_improvement": -3925.5223984968075,
            "length_improvement": 15.782237155783607,
            "smoothness_improvement": 586.3707143997782,
            "objective_score": -1215.255523683573
        },
        {
            "map_id": 1,
            "success_rate": 0.9,
            "time_avg": 0.5049476861953736,
            "num_nodes_avg": 665.0,
            "path_length_avg": 229.35320652897818,
            "smoothness_avg": 0.08379630799163253,
            "success_improvement": -9.999999999999998,
            "time_improvement": -205.76939929762253,
            "length_improvement": 23.435298094610914,
            "smoothness_improvement": 2056.139360665742,
            "objective_score": -87.3889441291915
        },
        {
            "map_id": 2,
            "success_rate": 0.9,
            "time_avg": 0.2551203489303589,
            "num_nodes_avg": 460.7,
            "path_length_avg": 116.56988216261001,
            "smoothness_avg": 0.08474802191414177,
            "success_improvement": -9.999999999999998,
            "time_improvement": -407.34153700851914,
            "length_improvement": 22.579834728883995,
            "smoothness_improvement": 977.9885832996046,
            "objective_score": -153.7646173487273
        }
    ],
    "success_rate": 0.9
}
{
    "operator": "e2",
    "algorithm_description": "A Hybrid Bidirectional Informed RRT* with Adaptive Neighborhood and Smooth Path Post-processing. The planner alternates growing two asymptotically optimal trees from start and goal using informed sampling within ellipsoidal bounds after first solution. It uses an adaptive neighborhood radius for rewiring and best parent selection to improve path quality while ensuring collision-free incremental expansion. Upon connecting trees, the algorithm performs shortcut smoothing on the path to enhance smoothness and reduce length before returning the result. This combination accelerates convergence, improves path optimality, and produces smoother feasible paths efficiently.",
    "planning_mechanism": "The planner initializes two trees at start and goal, grows them iteratively by sampling points either uniformly or informed within an ellipsoid after first solution, selecting parents for new nodes based on minimal path cost, and rewires neighbors within a dynamically computed radius to optimize local subtrees. Trees attempt connection after new node insertion; a feasible connection yields a combined path which is then shortcut-smoothed to reduce unnecessary turns and path length. This hybrid approach balances exploration and exploitation, improves computation efficiency, and delivers practical high-quality solutions.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        path = []\n        n = self\n        while n:\n            path.append(n.position)\n            n = n.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=5.0, gamma=60.0, \n                 post_opt_iters=300, max_no_improve=100, time_limit_sec=30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.gamma = gamma\n        self.post_opt_iters = post_opt_iters\n        self.max_no_improve = max_no_improve\n        self.time_limit_sec = time_limit_sec\n\n    def plan(self, map):\n        import math\n        import random\n        import time\n\n        bounds = map.size\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        def within_bounds(p):\n            return all(0.0 <= p[d] <= bounds[d] for d in range(dim))\n\n        # Initialize trees and data containers\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        tree_a = [start_root]\n        tree_b = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        c_min = math.dist(start_pos, goal_pos)\n        best_cost = float(\"inf\")\n        best_path = []\n        found_solution = False\n        no_improve_count = 0\n        post_opt_count = 0\n        start_time = time.time()\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_p, to_p):\n            d = dist(from_p, to_p)\n            if d <= self.step_size:\n                return to_p\n            r = self.step_size / d\n            return tuple(from_p[i] + (to_p[i] - from_p[i]) * r for i in range(dim))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: dist(n.position, point))\n\n        def neighbor_radius(n_nodes):\n            if n_nodes < 2:\n                return self.step_size * 2.0\n            r = self.gamma * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            max_r = max(bounds) * 0.30\n            min_r = max(10.0, self.step_size * 2.0)\n            return max(min_r, min(max_r, r))\n\n        def near_nodes(tree, point, radius):\n            return [n for n in tree if dist(n.position, point) <= radius]\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    px, py = pos\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(a, b, resolution=1.0):\n            length = dist(a, b)\n            steps = max(1, int(length / resolution))\n            for i in range(steps + 1):\n                interp = tuple(a[d] + (b[d] - a[d]) * (i / steps) for d in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def sample_uniform():\n            while True:\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle(p):\n                    return p\n\n        def sample_unit_ball():\n            while True:\n                v = [random.gauss(0, 1) for _ in range(dim)]\n                nrm = math.sqrt(sum(x*x for x in v))\n                if nrm > 1e-12:\n                    v = [x / nrm for x in v]\n                    r = random.random() ** (1.0 / dim)\n                    return tuple(v[i]*r for i in range(dim))\n\n        # Informed sampling inside the ellipsoid (or uniform if no solution)\n        def sample_informed(c_best):\n            if not found_solution or c_best == float(\"inf\") or c_min <= 1e-12:\n                return sample_uniform()\n            r1 = c_best / 2.0\n            r_other_sq = max(c_best * c_best - c_min * c_min, 0.0)\n            r_other = math.sqrt(r_other_sq) / 2.0\n            center = tuple((start_pos[d] + goal_pos[d]) / 2.0 for d in range(dim))\n            unit_vec = tuple((goal_pos[d] - start_pos[d]) / c_min for d in range(dim))\n\n            # Construct orthonormal basis for the ellipsoid axes\n            if dim == 2:\n                # Perp vector in 2D\n                perp_vec = (-unit_vec[1], unit_vec[0])\n                basis = [unit_vec, perp_vec]\n                radii = [r1, r_other]\n            else:  # 3D\n                # Create two perpendicular vectors using cross products\n                def cross(u,v):\n                    return (u[1]*v[2]-u[2]*v[1], u[2]*v[0]-u[0]*v[2], u[0]*v[1]-u[1]*v[0])\n                def norm(v):\n                    return math.sqrt(sum(x*x for x in v))\n                def normalize(v):\n                    n = norm(v)\n                    if n < 1e-12:\n                        return v\n                    return tuple(x/n for x in v)\n                ref = (1.0, 0.0, 0.0) if abs(unit_vec[0]) < 0.9 else (0.0, 1.0, 0.0)\n                b2 = normalize(cross(unit_vec, ref))\n                if norm(b2) < 1e-12:\n                    ref = (0.0, 0.0, 1.0)\n                    b2 = normalize(cross(unit_vec, ref))\n                b3 = cross(unit_vec, b2)\n                basis = [unit_vec, b2, b3]\n                radii = [r1, r_other, r_other]\n\n            u = sample_unit_ball()\n            mapped = []\n            for d in range(dim):\n                val = center[d]\n                for i in range(dim):\n                    val += basis[i][d] * radii[i] * u[i]\n                # Clamp to bounds\n                val = max(0.0, min(bounds[d], val))\n                mapped.append(val)\n            return tuple(mapped)\n\n        def add_node_with_best_parent(tree, pos):\n            r = neighbor_radius(len(tree))\n            neighbors = near_nodes(tree, pos, r)\n            if not neighbors:\n                # Use nearest if no neighbor within radius\n                neighbors = [nearest(tree, pos)]\n            candidates = [p for p in neighbors if not is_edge_in_obstacle(p.position, pos)]\n            if not candidates:\n                return None, []\n            parent = min(candidates, key=lambda p: p.cost + dist(p.position, pos))\n            cost_new = parent.cost + dist(parent.position, pos)\n            if is_in_obstacle(pos):\n                return None, []\n            new_node = Node(pos)\n            new_node.parent = parent\n            new_node.cost = cost_new\n            parent.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((parent, new_node))\n            return new_node, neighbors\n\n        def rewire(node, neighbors):\n            for n in neighbors:\n                if n is node:\n                    continue\n                if is_edge_in_obstacle(node.position, n.position):\n                    continue\n                new_cost = node.cost + dist(node.position, n.position)\n                if new_cost + 1e-12 < n.cost:\n                    if n.parent:\n                        try:\n                            edges.remove((n.parent, n))\n                        except ValueError:\n                            pass\n                        if n in n.parent.children:\n                            n.parent.children.remove(n)\n                    node.add_child(n)\n                    n.cost = new_cost\n                    edges.append((node, n))\n\n        def connect_trees(new_node, other_tree):\n            nearest_to_new = nearest(other_tree, new_node.position)\n            d = dist(new_node.position, nearest_to_new.position)\n            if d > self.step_size * 2.5:\n                return None\n            if is_edge_in_obstacle(new_node.position, nearest_to_new.position):\n                return None\n            return nearest_to_new\n\n        def extract_combined_path(n_start, n_goal, start_side=True):\n            path_from_start = n_start.path_from_root()\n            path_from_goal = n_goal.path_from_root()\n            if path_from_start[-1] == path_from_goal[-1]:\n                combined = path_from_start + path_from_goal[-2::-1]\n            else:\n                combined = path_from_start + path_from_goal[::-1]\n            if start_side:\n                return combined\n            else:\n                return combined[::-1]\n\n        def path_cost(path):\n            if not path or len(path) < 2:\n                return 0.0\n            c = 0.0\n            for i in range(len(path)-1):\n                c += dist(path[i], path[i+1])\n            return c\n\n        # Shortcut smoothing: tries to shortcut path pairs if collision free\n        def shortcut_path(path, attempts=40):\n            if len(path) < 3:\n                return path[:]\n            import random as rand\n            path_smoothed = path[:]\n            for _ in range(attempts):\n                if len(path_smoothed) < 3:\n                    break\n                i = rand.randint(0, len(path_smoothed)-3)\n                j = rand.randint(i+2, len(path_smoothed)-1)\n                if j <= i+1:\n                    continue\n                if not is_edge_in_obstacle(path_smoothed[i], path_smoothed[j]):\n                    # Shortcut possible, remove intermediate nodes\n                    path_smoothed = path_smoothed[:i+1] + path_smoothed[j:]\n            return path_smoothed\n\n        # Main planning loop\n        for it in range(self.max_iter):\n            # Time limit check\n            if time.time() - start_time > self.time_limit_sec:\n                break\n\n            # Alternate growth\n            grow_tree = tree_a if it % 2 == 0 else tree_b\n            other_tree = tree_b if it % 2 == 0 else tree_a\n            start_side = (grow_tree == tree_a)\n\n            sample = sample_informed(best_cost)\n            nearest_node = nearest(grow_tree, sample)\n            new_pos = steer(nearest_node.position, sample)\n\n            if not within_bounds(new_pos):\n                # Count post optimization if solution found\n                if found_solution:\n                    post_opt_count += 1\n                    no_improve_count += 1\n                    if post_opt_count >= self.post_opt_iters or no_improve_count >= self.max_no_improve:\n                        break\n                continue\n\n            if is_in_obstacle(new_pos) or is_edge_in_obstacle(nearest_node.position, new_pos):\n                if found_solution:\n                    post_opt_count += 1\n                    no_improve_count += 1\n                    if post_opt_count >= self.post_opt_iters or no_improve_count >= self.max_no_improve:\n                        break\n                continue\n\n            new_node, neighbors = add_node_with_best_parent(grow_tree, new_pos)\n            if new_node is None:\n                if found_solution:\n                    post_opt_count += 1\n                    no_improve_count += 1\n                    if post_opt_count >= self.post_opt_iters or no_improve_count >= self.max_no_improve:\n                        break\n                continue\n\n            rewire(new_node, neighbors)\n\n            # Attempt connection to other tree\n            connect_node = connect_trees(new_node, other_tree)\n            if connect_node:\n                # Join trees\n                if connect_node.parent is None or new_node.parent is None:\n                    # Should not happen, skip if roots\n                    continue\n                # Combine paths\n                candidate_path = extract_combined_path(new_node, connect_node, start_side)\n                candidate_cost = path_cost(candidate_path)\n                # If improved path found\n                if candidate_cost + 1e-7 < best_cost:\n                    best_cost = candidate_cost\n                    # Smooth path before recording\n                    best_path = shortcut_path(candidate_path, attempts=50)\n                    found_solution = True\n                    no_improve_count = 0\n                    post_opt_count = 0\n                else:\n                    if found_solution:\n                        no_improve_count += 1\n                        post_opt_count += 1\n                        if post_opt_count >= self.post_opt_iters or no_improve_count >= self.max_no_improve:\n                            break\n            else:\n                if found_solution:\n                    no_improve_count += 1\n                    post_opt_count += 1\n                    if post_opt_count >= self.post_opt_iters or no_improve_count >= self.max_no_improve:\n                        break\n\n        return PlannerResult(\n            success=found_solution,\n            path=best_path if found_solution else [],\n            nodes=nodes,\n            edges=edges\n        )",
    "objective": 14.32975,
    "time_improvement": -103.0,
    "length_improvement": 19.0,
    "smoothness_improvement": 1026.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.11174523830413818,
            "num_nodes_avg": 170.3,
            "path_length_avg": 155.95946117163558,
            "smoothness_avg": 0.04431890634175788,
            "success_improvement": 0.0,
            "time_improvement": -325.65044958646763,
            "length_improvement": 14.516147996016231,
            "smoothness_improvement": 593.6871242940072,
            "objective_score": -86.0170104568605
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.08233952522277832,
            "num_nodes_avg": 319.1,
            "path_length_avg": 230.98919001369396,
            "smoothness_avg": 0.06524519533690301,
            "success_improvement": 0.0,
            "time_improvement": 50.13957315950754,
            "length_improvement": 22.889159718239107,
            "smoothness_improvement": 1578.8058702331955,
            "objective_score": 36.6693971299617
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.06728522777557373,
            "num_nodes_avg": 254.4,
            "path_length_avg": 120.52492557718756,
            "smoothness_avg": 0.0790609987636083,
            "success_improvement": 0.0,
            "time_improvement": -33.805833289081406,
            "length_improvement": 19.953083211850664,
            "smoothness_improvement": 905.6500685972023,
            "objective_score": 6.358350283371988
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m1",
    "algorithm_description": "An improved informed bidirectional RRT* algorithm that integrates informed sampling within an ellipsoidal domain after the first solution is found, enabling efficient focused exploration. It alternates growth between start and goal trees, performs RRT* style best-parent selection and rewiring, and merges paths optimally. The algorithm stops after a fixed number of post-optimization iterations or no improvement streak, with strict collision checks, adaptive neighbor radius, and path quality enhancement via rewiring.",
    "planning_mechanism": "This planner grows two trees from start and goal positions alternately, uses an ellipsoidal informed sampling region once a first solution is found to accelerate convergence towards better paths, employs RRT* style parent selection and rewiring for asymptotic optimization, and merges paths when trees connect, continuing refinement until no further improvements are found or iteration limits are reached.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(\n        self,\n        max_iter: int = 6000,\n        step_size: float = 5.0,\n        post_opt_iters: int = 600,\n        max_no_improve: int = 150,\n        improve_tol: float = 1e-6,\n        neighbor_gamma: float = 60.0,\n    ):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.post_opt_iters = post_opt_iters\n        self.max_no_improve = max_no_improve\n        self.improve_tol = improve_tol\n        self.neighbor_gamma = neighbor_gamma\n\n    def plan(self, map):\n        import random\n        import math\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = dim == 3\n\n        def within_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def clamp_bounds(p):\n            return tuple(min(max(p[d], 0.0), bounds[d]) for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_p, to_p):\n            d = dist(from_p, to_p)\n            if d <= self.step_size:\n                return clamp_bounds(to_p)\n            ratio = self.step_size / d\n            return tuple(from_p[i] + (to_p[i] - from_p[i]) * ratio for i in range(dim))\n\n        def is_in_obstacle(p):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d_ = obs\n                    px, py, pz = p\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d_:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    px, py = p\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(p1, p2, resolution=1.0):\n            distance = dist(p1, p2)\n            steps = max(1, int(distance / resolution))\n            for i in range(steps + 1):\n                interp = tuple(p1[d] + (p2[d] - p1[d]) * i / steps for d in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def neighbor_radius(n_nodes):\n            if n_nodes < 2:\n                return max(self.step_size * 2.0, 10.0)\n            r = self.neighbor_gamma * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            max_r = max(bounds) * 0.30\n            return max(self.step_size * 2.0, min(r, max_r))\n\n        def nearest_node(tree, point):\n            return min(tree, key=lambda n: dist(n.position, point))\n\n        def near_nodes(tree, point, radius):\n            return [n for n in tree if dist(n.position, point) <= radius]\n\n        def best_parent_and_cost(candidates, new_pos):\n            best_n = None\n            best_cost = float(\"inf\")\n            for n in candidates:\n                if is_edge_in_obstacle(n.position, new_pos):\n                    continue\n                c = n.cost + dist(n.position, new_pos)\n                if c < best_cost:\n                    best_cost = c\n                    best_n = n\n            return best_n, best_cost\n\n        def rewire(node, neighbors):\n            for nb in neighbors:\n                if nb is node:\n                    continue\n                if is_edge_in_obstacle(node.position, nb.position):\n                    continue\n                c = node.cost + dist(node.position, nb.position)\n                if c + 1e-12 < nb.cost:\n                    if nb.parent:\n                        try:\n                            edges.remove((nb.parent, nb))\n                        except Exception:\n                            pass\n                        if nb in nb.parent.children:\n                            nb.parent.children.remove(nb)\n                    node.add_child(nb)\n                    nb.cost = c\n                    edges.append((node, nb))\n\n        def path_cost(path_points):\n            total = 0.0\n            for i in range(len(path_points) - 1):\n                total += dist(path_points[i], path_points[i + 1])\n            return total\n\n        def sample_uniform():\n            return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        # Informed sampling inside ellipsoid defined by start, goal, and best_cost c_best\n        def sample_informed(c_best):\n            if c_best == float(\"inf\"):\n                return sample_uniform()\n            import numpy as np\n            c_min = dist(start_pos, goal_pos)\n            if c_best < c_min:\n                return sample_uniform()\n            L_diag = [c_best / 2.0] + [math.sqrt(c_best ** 2 - c_min ** 2) / 2.0] * (dim - 1)\n            L = np.diag(L_diag)\n            center = np.array([(s + g) / 2 for s, g in zip(start_pos, goal_pos)])\n            a1 = np.array(goal_pos) - np.array(start_pos)\n            norm_a1 = np.linalg.norm(a1)\n            if norm_a1 < 1e-10:\n                return sample_uniform()\n            e1 = a1 / norm_a1\n            I = np.eye(dim)\n            M = np.outer(e1, I[:, 0])\n            U, _, Vt = np.linalg.svd(M)\n            C = U @ np.diag([1] * (dim - 1) + [np.linalg.det(U) * np.linalg.det(Vt)]) @ Vt\n\n            while True:\n                x_ball = np.random.normal(0, 1, dim)\n                norm = np.linalg.norm(x_ball)\n                if norm < 1e-10:\n                    continue\n                x_ball /= norm\n                r = random.random() ** (1.0 / dim)\n                x_ball *= r\n                x_rand = C @ (L @ x_ball) + center\n                x_rand_t = tuple(float(x_rand[d]) for d in range(dim))\n                if all(0 <= x_rand_t[d] <= bounds[d] for d in range(dim)):\n                    return x_rand_t\n\n        def stitch_paths(node_start, node_goal, start_side):\n            path_start = node_start.path_from_root()\n            path_goal = node_goal.path_from_root()\n            if path_start[-1] == path_goal[-1]:\n                combined = path_start + path_goal[-2::-1]\n            else:\n                combined = path_start + path_goal[::-1]\n            return combined if start_side else combined[::-1]\n\n        # Initialize trees\n        tree_start = [Node(start_pos, cost=0.0)]\n        tree_goal = [Node(goal_pos, cost=0.0)]\n        nodes = [tree_start[0], tree_goal[0]]\n        edges = []\n\n        best_cost = float(\"inf\")\n        best_path = []\n        found_first_solution = False\n        post_iter_count = 0\n        no_improve_streak = 0\n\n        for iteration in range(self.max_iter):\n            # Alternate tree to grow\n            if iteration % 2 == 0:\n                active_tree, other_tree = tree_start, tree_goal\n                active_side_is_start = True\n            else:\n                active_tree, other_tree = tree_goal, tree_start\n                active_side_is_start = False\n\n            # Sample\n            if found_first_solution:\n                x_rand = sample_informed(best_cost)\n            else:\n                x_rand = sample_uniform()\n\n            # Nearest node in active tree\n            x_nearest = nearest_node(active_tree, x_rand)\n            x_new_pos = steer(x_nearest.position, x_rand)\n\n            if (not within_bounds(x_new_pos)) or is_in_obstacle(x_new_pos) or is_edge_in_obstacle(x_nearest.position, x_new_pos):\n                if found_first_solution:\n                    post_iter_count += 1\n                    no_improve_streak += 1\n                    if post_iter_count >= self.post_opt_iters or no_improve_streak >= self.max_no_improve:\n                        break\n                continue\n\n            nbr_radius = neighbor_radius(len(active_tree))\n            near_nbs = near_nodes(active_tree, x_new_pos, nbr_radius)\n\n            # Select best parent from neighbors\n            best_p, min_cost = best_parent_and_cost(near_nbs if near_nbs else [x_nearest], x_new_pos)\n            if best_p is None:\n                if found_first_solution:\n                    post_iter_count += 1\n                    no_improve_streak += 1\n                    if post_iter_count >= self.post_opt_iters or no_improve_streak >= self.max_no_improve:\n                        break\n                continue\n\n            x_new = Node(x_new_pos)\n            best_p.add_child(x_new)\n            x_new.parent = best_p\n            x_new.cost = min_cost\n            active_tree.append(x_new)\n            nodes.append(x_new)\n            edges.append((best_p, x_new))\n\n            rewire(x_new, near_nbs)\n\n            # Try to connect other tree greedily to x_new with incremental stepping and rewiring\n            x_other_near = nearest_node(other_tree, x_new.position)\n            current = x_other_near\n            connected_node = None\n            while True:\n                step_pos = steer(current.position, x_new.position)\n                if (not within_bounds(step_pos)) or is_in_obstacle(step_pos) or is_edge_in_obstacle(current.position, step_pos):\n                    break\n                # neighbor radius for other tree\n                nbr_radius_other = neighbor_radius(len(other_tree))\n                near_nbs_other = near_nodes(other_tree, step_pos, nbr_radius_other)\n\n                # Best parent insertion for new node in other tree\n                bp, cst = best_parent_and_cost(near_nbs_other if near_nbs_other else [current], step_pos)\n                if bp is None:\n                    break\n                new_node = Node(step_pos)\n                bp.add_child(new_node)\n                new_node.parent = bp\n                new_node.cost = cst\n                other_tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((bp, new_node))\n\n                rewire(new_node, near_nbs_other)\n\n                current = new_node\n                # Check if close enough to x_new to connect directly\n                if dist(current.position, x_new.position) <= self.step_size and not is_edge_in_obstacle(current.position, x_new.position):\n                    connect_node = Node(x_new.position)\n                    connect_node.cost = current.cost + dist(current.position, x_new.position)\n                    # Attach connect_node in other tree\n                    current.add_child(connect_node)\n                    connect_node.parent = current\n                    other_tree.append(connect_node)\n                    nodes.append(connect_node)\n                    edges.append((current, connect_node))\n                    connected_node = connect_node\n                    break\n\n            if connected_node is not None:\n                candidate_path = stitch_paths(x_new, connected_node, active_side_is_start)\n                candidate_cost = path_cost(candidate_path)\n                if candidate_cost + self.improve_tol < best_cost:\n                    best_cost = candidate_cost\n                    best_path = candidate_path\n                    found_first_solution = True\n                    no_improve_streak = 0\n                    post_iter_count = 0\n                else:\n                    no_improve_streak += 1\n                    post_iter_count += 1\n                if post_iter_count >= self.post_opt_iters or no_improve_streak >= self.max_no_improve:\n                    break\n            else:\n                if found_first_solution:\n                    post_iter_count += 1\n                    no_improve_streak += 1\n                    if post_iter_count >= self.post_opt_iters or no_improve_streak >= self.max_no_improve:\n                        break\n\n        success = len(best_path) > 0\n        return PlannerResult(\n            success=success,\n            path=best_path if success else [],\n            nodes=nodes,\n            edges=edges,\n        )",
    "objective": 347.42085,
    "time_improvement": -1206.0,
    "length_improvement": 21.0,
    "smoothness_improvement": 375.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.6662193059921264,
            "num_nodes_avg": 715.0,
            "path_length_avg": 152.2266496905497,
            "smoothness_avg": 0.028874974448721235,
            "success_improvement": 0.0,
            "time_improvement": -2437.7058693715417,
            "length_improvement": 16.562161118982523,
            "smoothness_improvement": 351.9560531330992,
            "objective_score": -719.6146838744074
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.9742064476013184,
            "num_nodes_avg": 1443.9,
            "path_length_avg": 229.80139564843256,
            "smoothness_avg": 0.015276574157537895,
            "success_improvement": 0.0,
            "time_improvement": -489.9274883689034,
            "length_improvement": 23.28567966612852,
            "smoothness_improvement": 293.07725634506016,
            "objective_score": -131.54145242926862
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.3980384111404419,
            "num_nodes_avg": 706.5,
            "path_length_avg": 115.5328292299278,
            "smoothness_avg": 0.045574030615126014,
            "success_improvement": 0.0,
            "time_improvement": -691.5535555791566,
            "length_improvement": 23.268595907617566,
            "smoothness_improvement": 479.6983054993822,
            "objective_score": -191.10641760167954
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m3",
    "algorithm_description": "A simplified bidirectional RRT* planner that balances exploration and optimization with clear structure. It grows two trees from start and goal, alternates extension towards random samples with mild goal bias, uses radius-based neighbor rewiring to improve paths, and attempts greedy connection of the two trees for fast solution discovery. Strict collision checking ensures robustness.",
    "planning_mechanism": "The planner samples in free space, extends one tree towards the sample with step-wise steering, chooses the best parent among neighbors within a neighborhood radius, rewires neighbors to reduce path costs, then attempts to connect the other tree greedily. Upon connecting, it extracts and returns the combined path, iterating until a solution is found or iteration limit is reached.",
    "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent: Optional[\"Node\"]=None, cost: float=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children: List[\"Node\"] = []\n\n    def add_child(self, child: \"Node\"):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        node, path = self, []\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 3000, step_size: float = 4.0, gamma_rrt_star: float = 50.0, max_radius: float = 40.0, goal_sample_rate: float = 0.05):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.gamma_rrt_star = gamma_rrt_star\n        self.max_radius = max_radius\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map) -> \"PlannerResult\":\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        tree_start = [Node(start_pos)]\n        tree_goal = [Node(goal_pos)]\n        nodes = tree_start + tree_goal\n        edges: List[Tuple[Node,Node]] = []\n\n        def sample_free():\n            if random.random() < self.goal_sample_rate:\n                return goal_pos\n            while True:\n                s = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(s, obstacles, is_3d):\n                    return s\n\n        def nearest(tree: List[Node], point: Tuple[float, ...]) -> Node:\n            return min(tree, key=lambda n: math.dist(n.position, point))\n\n        def steer(from_pos, to_pos) -> Tuple[float, ...]:\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dim))\n\n        def neighbor_radius(n_nodes: int) -> float:\n            if n_nodes < 2:\n                return self.step_size * 2.0\n            r = self.gamma_rrt_star * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            return min(max(self.step_size*2.0, r), self.max_radius)\n\n        def near_nodes(tree: List[Node], pos: Tuple[float,...]) -> List[Node]:\n            r = neighbor_radius(len(tree))\n            return [n for n in tree if math.dist(n.position, pos) <= r]\n\n        def can_connect(from_p, to_p) -> bool:\n            return (not self._is_in_obstacle(to_p, obstacles, is_3d)\n                    and not self._is_edge_in_obstacle(from_p, to_p, obstacles, is_3d))\n\n        def add_node_with_parent(tree: List[Node], new_pos: Tuple[float, ...]) -> Optional[Node]:\n            near = near_nodes(tree, new_pos)\n            candidates = [n for n in near if can_connect(n.position, new_pos)]\n            if not candidates:\n                parent = nearest(tree, new_pos)\n                if not can_connect(parent.position, new_pos):\n                    return None\n                best_parent = parent\n                best_cost = parent.cost + math.dist(parent.position, new_pos)\n            else:\n                best_parent, best_cost = min(\n                    ((n, n.cost + math.dist(n.position, new_pos)) for n in candidates),\n                    key=lambda x: x[1]\n                )\n            new_node = Node(new_pos, parent=None, cost=best_cost)\n            best_parent.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n            return new_node\n\n        def rewire(node: Node, neighbors: List[Node]):\n            for nb in neighbors:\n                if nb is node:\n                    continue\n                if can_connect(node.position, nb.position):\n                    new_cost = node.cost + math.dist(node.position, nb.position)\n                    if new_cost + 1e-12 < nb.cost:\n                        if nb.parent is not None:\n                            try:\n                                edges.remove((nb.parent, nb))\n                            except ValueError:\n                                pass\n                            if nb in nb.parent.children:\n                                nb.parent.children.remove(nb)\n                        node.add_child(nb)\n                        nb.cost = new_cost\n                        edges.append((node, nb))\n\n        def extend(tree: List[Node], target_point: Tuple[float, ...], other_tree: List[Node]) -> Optional[Node]:\n            nearest_node = nearest(tree, target_point)\n            new_pos = steer(nearest_node.position, target_point)\n            if not can_connect(nearest_node.position, new_pos):\n                return None\n            new_node = add_node_with_parent(tree, new_pos)\n            if not new_node:\n                return None\n            near = near_nodes(tree, new_pos)\n            rewire(new_node, near)\n            # Attempt connect with other_tree greedily\n            connect_node = attempt_connect(other_tree, new_node)\n            if connect_node:\n                return (new_node, connect_node)\n            return (new_node, None)\n\n        def attempt_connect(tree: List[Node], target_node: Node) -> Optional[Node]:\n            nearest_node = nearest(tree, target_node.position)\n            current = nearest_node\n            while True:\n                new_pos = steer(current.position, target_node.position)\n                if not can_connect(current.position, new_pos):\n                    return None\n                new_node = add_node_with_parent(tree, new_pos)\n                if new_node is None:\n                    return None\n                near = near_nodes(tree, new_pos)\n                rewire(new_node, near)\n                current = new_node\n                if math.dist(current.position, target_node.position) <= self.step_size:\n                    if can_connect(current.position, target_node.position):\n                        final_node = Node(target_node.position, parent=None, cost=current.cost + math.dist(current.position, target_node.position))\n                        current.add_child(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((current, final_node))\n                        return final_node\n                    else:\n                        return None\n\n        best_path: List[Tuple[float,...]] = []\n        solution_found = False\n\n        for _ in range(self.max_iter):\n            sample = sample_free()\n            result = extend(tree_start, sample, tree_goal)\n            if result is None:\n                tree_start, tree_goal = tree_goal, tree_start\n                continue\n            new_node, connect_node = result\n            if connect_node:\n                path_start = new_node.path_from_root()\n                path_goal = connect_node.path_from_root()\n                if path_start[-1] == path_goal[-1]:\n                    path_goal = path_goal[:-1]\n                best_path = path_start + path_goal[::-1]\n                solution_found = True\n                break\n            tree_start, tree_goal = tree_goal, tree_start\n\n        return PlannerResult(success=solution_found, path=best_path, nodes=nodes, edges=edges)\n\n    def _is_in_obstacle(self, pos: Tuple[float,...], obstacles, is_3d: bool) -> bool:\n        for obs in obstacles:\n            if is_3d:\n                x,y,z,w,h,d = obs\n                px,py,pz = pos\n                if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                    return True\n            else:\n                x,y,w,h = obs\n                px,py = pos\n                if x <= px <= x+w and y <= py <= y+h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_p: Tuple[float,...], to_p: Tuple[float,...], obstacles, is_3d: bool, resolution: float=1.0) -> bool:\n        dist = math.dist(from_p, to_p)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps+1):\n            interm = tuple(from_p[d] + (to_p[d] - from_p[d]) * i/steps for d in range(len(from_p)))\n            if self._is_in_obstacle(interm, obstacles, is_3d):\n                return True\n        return False",
    "objective": 2.60201,
    "time_improvement": -40.0,
    "length_improvement": 14.0,
    "smoothness_improvement": 242.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.049528646469116214,
            "num_nodes_avg": 102.8,
            "path_length_avg": 163.73573386408458,
            "smoothness_avg": 0.024721319861977082,
            "success_improvement": 0.0,
            "time_improvement": -88.66030407138894,
            "length_improvement": 10.253849710358729,
            "smoothness_improvement": 286.9423390452511,
            "objective_score": -19.011069699975188
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.07662971019744873,
            "num_nodes_avg": 315.6,
            "path_length_avg": 257.08848163237656,
            "smoothness_avg": 0.011895872353594215,
            "success_improvement": 0.0,
            "time_improvement": 53.59713274067979,
            "length_improvement": 14.176464949466494,
            "smoothness_improvement": 206.0893639085042,
            "objective_score": 25.615465611426355
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.09266290664672852,
            "num_nodes_avg": 359.9,
            "path_length_avg": 126.19502968546935,
            "smoothness_avg": 0.02608580925521416,
            "success_improvement": 0.0,
            "time_improvement": -84.27280175389355,
            "length_improvement": 16.18727004447308,
            "smoothness_improvement": 231.80956827217284,
            "objective_score": -14.410430658123351
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "path_expert",
    "algorithm_description": "A Dual-Tree Anytime Informed RRT* with Adaptive Radius and Incremental Path Smoothing. This planner grows two asymptotically optimal trees from start and goal, using adaptive radius for rewiring, and informed sampling within ellipsoids after first solution. It prioritizes rewiring that propagates cost improvements recursively to downstream nodes for better path optimality. The connection threshold is dynamically tuned based on step size and adaptive neighborhood. Incremental shortcut smoothing is performed on newly discovered partial paths during planning to improve smoothness gradually, yielding shorter and smoother paths faster while balancing exploration and exploitation.",
    "planning_mechanism": "The planner maintains two trees initialized at start and goal positions, merging them upon a close and collision-free connection. Sampling switches between uniform and informed ellipsoidal bias based on the current best cost. Each new node selects the best parent within an adaptive radius based on cost and collision checks. Then, rewiring with recursion updates costs/parents downstream for enhanced optimality. When trees connect, the combined path is incrementally shortcut-smoothed before updating the best solution, accelerating convergence to shorter, smoother, feasible paths within the time budget.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=6000, step_size=6.0, gamma=100.0,\n                 max_no_improve=120, time_limit_sec=30.0, shortcut_attempts=75):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.gamma = gamma\n        self.max_no_improve = max_no_improve\n        self.time_limit_sec = time_limit_sec\n        self.shortcut_attempts = shortcut_attempts\n\n    def plan(self, map):\n        import time\n        import random\n        import math\n\n        bounds = map.size\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def within_bounds(p):\n            return all(0.0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    px, py = pos\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(a, b, resolution=0.5):\n            length = dist(a, b)\n            steps = max(1, int(length / resolution))\n            for i in range(steps + 1):\n                interp = tuple(a[d] + (b[d] - a[d]) * (i / steps) for d in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def steer(from_p, to_p):\n            d = dist(from_p, to_p)\n            if d <= self.step_size:\n                return to_p\n            ratio = self.step_size / d\n            return tuple(from_p[i] + (to_p[i] - from_p[i]) * ratio for i in range(dim))\n\n        def nearest(tree, point):\n            best = None\n            best_d = float(\"inf\")\n            for n in tree:\n                d = dist(n.position, point)\n                if d < best_d:\n                    best = n\n                    best_d = d\n            return best\n\n        def neighbor_radius(n_nodes):\n            if n_nodes < 2:\n                return self.step_size * 3.0\n            r = self.gamma * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            max_r = max(bounds) * 0.25\n            min_r = max(8.0, self.step_size * 1.5)\n            return max(min_r, min(max_r, r))\n\n        def near_nodes(tree, point, radius):\n            res = []\n            r_sq = radius * radius\n            for n in tree:\n                dx = 0.0\n                for d in range(dim):\n                    diff = n.position[d] - point[d]\n                    dx += diff * diff\n                    if dx > r_sq:\n                        break\n                if dx <= r_sq:\n                    res.append(n)\n            return res\n\n        def sample_uniform():\n            while True:\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle(p):\n                    return p\n\n        def sample_unit_ball():\n            while True:\n                v = [random.gauss(0, 1) for _ in range(dim)]\n                norm_v = math.sqrt(sum(x * x for x in v))\n                if norm_v > 1e-14:\n                    v = [x / norm_v for x in v]\n                    r = random.random() ** (1.0 / dim)\n                    return tuple(v[i] * r for i in range(dim))\n\n        def sample_informed(c_best):\n            if not found_solution or c_best == float(\"inf\") or c_min <= 1e-14:\n                return sample_uniform()\n            r1 = c_best / 2.0\n            rother_sq = max(c_best * c_best - c_min * c_min, 0.0)\n            r_other = math.sqrt(rother_sq) / 2.0\n            center = tuple((start_pos[d] + goal_pos[d]) * 0.5 for d in range(dim))\n            unit_vec = tuple((goal_pos[d] - start_pos[d]) / c_min for d in range(dim))\n\n            if dim == 2:\n                perp = (-unit_vec[1], unit_vec[0])\n                basis = [unit_vec, perp]\n                radii = [r1, r_other]\n            else:  # 3D\n                def cross(u, v):\n                    return (u[1]*v[2]-u[2]*v[1], u[2]*v[0]-u[0]*v[2], u[0]*v[1]-u[1]*v[0])\n                def norm(v):\n                    return math.sqrt(sum(x*x for x in v))\n                def normalize(v):\n                    nrm = norm(v)\n                    if nrm < 1e-14:\n                        return v\n                    return tuple(x / nrm for x in v)\n                ref = (1.0, 0.0, 0.0) if abs(unit_vec[0]) < 0.9 else (0.0, 1.0, 0.0)\n                b2 = normalize(cross(unit_vec, ref))\n                if norm(b2) < 1e-14:\n                    ref = (0.0, 0.0, 1.0)\n                    b2 = normalize(cross(unit_vec, ref))\n                b3 = cross(unit_vec, b2)\n                basis = [unit_vec, b2, b3]\n                radii = [r1, r_other, r_other]\n\n            u = sample_unit_ball()\n            sample = []\n            for d in range(dim):\n                val = center[d]\n                for i in range(dim):\n                    val += basis[i][d] * radii[i] * u[i]\n                val = max(0.0, min(val, bounds[d]))\n                sample.append(val)\n            return tuple(sample)\n\n        def add_node_best_parent(tree, pos):\n            r = neighbor_radius(len(tree))\n            neighbors = near_nodes(tree, pos, r)\n            if not neighbors:\n                neighbors = [nearest(tree, pos)]\n            candidates = []\n            for p in neighbors:\n                if not is_edge_in_obstacle(p.position, pos):\n                    candidates.append(p)\n            if not candidates or is_in_obstacle(pos):\n                return None, []\n            parent = min(candidates, key=lambda p: p.cost + dist(p.position, pos))\n            cost_new = parent.cost + dist(parent.position, pos)\n            new_node = Node(pos)\n            new_node.parent = parent\n            new_node.cost = cost_new\n            parent.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((parent, new_node))\n            return new_node, neighbors\n\n        def propagate_cost_improvements(node):\n            stack = [node]\n            while stack:\n                curr = stack.pop()\n                for child in curr.children[:]:\n                    new_cost = curr.cost + dist(curr.position, child.position)\n                    if new_cost + 1e-12 < child.cost:\n                        if child.parent:\n                            try:\n                                edges.remove((child.parent, child))\n                            except ValueError:\n                                pass\n                            child.parent.remove_child(child)\n                        curr.add_child(child)\n                        child.cost = new_cost\n                        edges.append((curr, child))\n                        stack.append(child)\n\n        def rewire(node, neighbors):\n            for n in neighbors:\n                if n is node:\n                    continue\n                if is_edge_in_obstacle(node.position, n.position):\n                    continue\n                new_cost = node.cost + dist(node.position, n.position)\n                if new_cost + 1e-12 < n.cost:\n                    if n.parent:\n                        try:\n                            edges.remove((n.parent, n))\n                        except ValueError:\n                            pass\n                        n.parent.remove_child(n)\n                    node.add_child(n)\n                    n.cost = new_cost\n                    edges.append((node, n))\n                    propagate_cost_improvements(n)\n\n        def connect_trees(new_node, other_tree):\n            # Dynamically allow upto adaptive radius connection\n            r = neighbor_radius(len(other_tree))\n            nearest_other = nearest(other_tree, new_node.position)\n            d = dist(new_node.position, nearest_other.position)\n            if d > r:\n                return None\n            if is_edge_in_obstacle(new_node.position, nearest_other.position):\n                return None\n            return nearest_other\n\n        def combine_paths(n_start, n_goal, start_side=True):\n            p_start = n_start.path_from_root()\n            p_goal = n_goal.path_from_root()\n            if p_start[-1] == p_goal[-1]:\n                combined = p_start + p_goal[-2::-1]\n            else:\n                combined = p_start + p_goal[::-1]\n            return combined if start_side else combined[::-1]\n\n        def path_cost(path):\n            if len(path) < 2:\n                return 0.0\n            total = 0.0\n            for i in range(len(path)-1):\n                total += dist(path[i], path[i+1])\n            return total\n\n        def shortcut_path(path, attempts):\n            if len(path) < 3:\n                return path[:]\n            path_smoothed = path[:]\n            for _ in range(attempts):\n                if len(path_smoothed) < 3:\n                    break\n                i = random.randint(0, len(path_smoothed)-3)\n                j = random.randint(i+2, len(path_smoothed)-1)\n                if j <= i+1:\n                    continue\n                if not is_edge_in_obstacle(path_smoothed[i], path_smoothed[j]):\n                    path_smoothed = path_smoothed[:i+1] + path_smoothed[j:]\n            return path_smoothed\n\n        # Initialization\n        start_time = time.time()\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        tree_a = [start_root]\n        tree_b = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        c_min = dist(start_pos, goal_pos)\n        best_cost = float(\"inf\")\n        best_path = []\n        found_solution = False\n        no_improve_count = 0\n\n        for it in range(self.max_iter):\n            if time.time() - start_time > self.time_limit_sec:\n                break\n\n            grow_tree = tree_a if it % 2 == 0 else tree_b\n            other_tree = tree_b if it % 2 == 0 else tree_a\n            start_side = (grow_tree is tree_a)\n\n            sample = sample_informed(best_cost)\n            nearest_node = nearest(grow_tree, sample)\n            new_pos = steer(nearest_node.position, sample)\n\n            if not within_bounds(new_pos) or is_in_obstacle(new_pos) or is_edge_in_obstacle(nearest_node.position, new_pos):\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n                continue\n\n            new_node, neighbors = add_node_best_parent(grow_tree, new_pos)\n            if new_node is None:\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n                continue\n\n            rewire(new_node, neighbors)\n\n            other_connect_node = connect_trees(new_node, other_tree)\n            if other_connect_node:\n                if new_node.parent is None or other_connect_node.parent is None:\n                    continue  # skip root-level connects\n                candidate_path = combine_paths(new_node, other_connect_node, start_side)\n                candidate_cost = path_cost(candidate_path)\n                if candidate_cost + 1e-8 < best_cost:\n                    best_cost = candidate_cost\n                    # Incremental shortcut smoothing on partial improved path\n                    best_path = shortcut_path(candidate_path, self.shortcut_attempts)\n                    found_solution = True\n                    no_improve_count = 0\n                else:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n            else:\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n\n        return PlannerResult(\n            success=found_solution,\n            path=best_path if found_solution else [],\n            nodes=nodes,\n            edges=edges\n        )",
    "objective": 324.51987,
    "time_improvement": -1029.0,
    "length_improvement": 19.0,
    "smoothness_improvement": 1271.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.6372508049011231,
            "num_nodes_avg": 218.7,
            "path_length_avg": 160.8863986140083,
            "smoothness_avg": 0.04475053916474018,
            "success_improvement": 0.0,
            "time_improvement": -2327.361520920006,
            "length_improvement": 11.815615511531895,
            "smoothness_improvement": 600.4431152793574,
            "objective_score": -688.1168713926859
        },
        {
            "map_id": 1,
            "success_rate": 0.9,
            "time_avg": 0.47791233062744143,
            "num_nodes_avg": 296.5,
            "path_length_avg": 226.63752813777037,
            "smoothness_avg": 0.07342140960589134,
            "success_improvement": -9.999999999999998,
            "time_improvement": -189.3982292580281,
            "length_improvement": 24.34186970806451,
            "smoothness_improvement": 1789.185752463364,
            "objective_score": -83.26841819025289
        },
        {
            "map_id": 2,
            "success_rate": 0.9,
            "time_avg": 0.3372055530548096,
            "num_nodes_avg": 221.1,
            "path_length_avg": 120.76625865421815,
            "smoothness_avg": 0.1198708929264735,
            "success_improvement": -9.999999999999998,
            "time_improvement": -570.5791376184371,
            "length_improvement": 19.79280127313315,
            "smoothness_improvement": 1424.7489100758007,
            "objective_score": -202.17431597127222
        }
    ],
    "success_rate": 0.9333333333333332
}
{
    "operator": "m2",
    "algorithm_description": "A hybrid bidirectional RRT* planner with adaptive neighbor radius and incremental rewiring that dynamically balances exploration and exploitation. It samples with goal and bridge bias and adapts rewiring radius by node count to improve path quality and search speed. After first solution, it performs focused post-optimization with early stopping, using efficient collision checking to maintain path validity and smoothness.",
    "planning_mechanism": "The planner grows two trees simultaneously, alternately extending them toward biased random samples near goals or opposite tree roots. For each new node, it selects the best parent in a dynamically scaled neighbor radius and rewires neighbors to locally optimize costs. Upon connecting the two trees, it refines the path with limited post-optimization iterations or until convergence or time run out, thereby significantly improving efficiency, path length, and smoothness.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(\n        self,\n        max_iter=6000,\n        step_size=5.0,\n        post_opt_iters=500,\n        max_no_improve=100,\n        improve_tol=1e-5,\n        goal_sample_rate=0.08,\n        bridge_bias_rate=0.12,\n        neighbor_gamma=60.0,\n        time_limit_sec=28.0\n    ):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.post_opt_iters = post_opt_iters\n        self.max_no_improve = max_no_improve\n        self.improve_tol = improve_tol\n        self.goal_sample_rate = goal_sample_rate\n        self.bridge_bias_rate = bridge_bias_rate\n        self.neighbor_gamma = neighbor_gamma\n        self.time_limit_sec = time_limit_sec\n\n    def plan(self, map):\n        import time\n        import math\n        import random\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def in_bounds(p):\n            return all(0.0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def clamp(p):\n            return tuple(min(max(p[d], 0.0), bounds[d]) for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_p, to_p):\n            d = dist(from_p, to_p)\n            if d <= self.step_size:\n                return clamp(to_p)\n            r = self.step_size / d\n            return clamp(tuple(from_p[i] + (to_p[i] - from_p[i]) * r for i in range(dim)))\n\n        def is_in_obstacle(pos):\n            px = pos[0]\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d=obs\n                    if x <= pos[0] <= x + w and y <= pos[1] <= y + h and z <= pos[2] <= z + d:\n                        return True\n                else:\n                    x,y,w,h=obs\n                    if x <= pos[0] <= x + w and y <= pos[1] <= y + h:\n                        return True\n            return False\n\n        def edge_collision(f_pos, t_pos, resolution=1.0):\n            d = dist(f_pos, t_pos)\n            steps = max(1, int(d / resolution))\n            for i in range(steps + 1):\n                interp = tuple(f_pos[j] + (t_pos[j] - f_pos[j]) * (i / steps) for j in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def sample_uniform():\n            return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        def sample_free(active_tree, other_tree):\n            r = random.random()\n            if r < self.goal_sample_rate:\n                return goal_pos if active_tree is tree_start else start_pos\n            if r < self.goal_sample_rate + self.bridge_bias_rate:\n                root_o = other_tree[0].position\n                jitter = tuple(random.uniform(-2*self.step_size, 2*self.step_size) for _ in range(dim))\n                s = clamp(tuple(root_o[i] + jitter[i] for i in range(dim)))\n                return s if not is_in_obstacle(s) else sample_uniform()\n            return sample_uniform()\n\n        def nearest(tree, p):\n            nearest_node = None\n            min_dist = float('inf')\n            for n in tree:\n                d = dist(n.position, p)\n                if d < min_dist:\n                    min_dist = d\n                    nearest_node = n\n            return nearest_node\n\n        def neighbor_radius(n_nodes):\n            if n_nodes < 2:\n                return max(10.0, self.step_size*2)\n            r = self.neighbor_gamma * ((math.log(n_nodes)/n_nodes) ** (1.0 / dim))\n            return max(10.0, min(max(bounds), r))\n\n        def near(tree, pos, radius):\n            return [nd for nd in tree if dist(nd.position, pos) <= radius]\n\n        def add_node_with_best_parent(tree, pos):\n            radius = neighbor_radius(len(tree))\n            near_nodes = near(tree, pos, radius)\n            candidates = [n for n in near_nodes if not edge_collision(n.position, pos)]\n            if not candidates:\n                parent = nearest(tree, pos)\n                if edge_collision(parent.position, pos):\n                    return None, []\n            else:\n                parent = min(candidates, key=lambda c: c.cost + dist(c.position, pos))\n            cost_c = parent.cost + dist(parent.position, pos)\n            new_node = Node(pos, parent=None, cost=cost_c)\n            parent.add_child(new_node)\n            tree.append(new_node)\n            return new_node, near_nodes\n\n        def rewire(node, neighbors, tree, edges):\n            for nb in neighbors:\n                if nb is node:\n                    continue\n                if edge_collision(node.position, nb.position):\n                    continue\n                new_cost = node.cost + dist(node.position, nb.position)\n                if new_cost + 1e-12 < nb.cost:\n                    if nb.parent:\n                        try:\n                            edges.remove((nb.parent, nb))\n                        except ValueError:\n                            pass\n                        if nb in nb.parent.children:\n                            nb.parent.children.remove(nb)\n                    node.add_child(nb)\n                    nb.cost = new_cost\n                    edges.append((node, nb))\n\n        def stitch_path(a_node, b_node, a_start=True):\n            path_a = a_node.path_from_root()\n            path_b = b_node.path_from_root()\n            if path_a[-1] == path_b[-1]:\n                full_path = path_a + path_b[-2::-1]\n            else:\n                full_path = path_a + path_b[::-1]\n            if a_start:\n                return full_path\n            return full_path[::-1]\n\n        def path_cost(path):\n            return sum(dist(path[i], path[i+1]) for i in range(len(path)-1))\n\n        start_time = time.time()\n\n        tree_start = [Node(start_pos, cost=0.0)]\n        tree_goal = [Node(goal_pos, cost=0.0)]\n        nodes = tree_start + tree_goal[:]\n        edges = []\n        best_path = []\n        best_cost = float('inf')\n        found_solution = False\n        post_opt_counter = 0\n        no_improve = 0\n\n        for i in range(self.max_iter):\n            if time.time() - start_time > self.time_limit_sec:\n                break\n\n            grow_tree, other_tree = (tree_start, tree_goal) if i % 2 == 0 else (tree_goal, tree_start)\n            a_is_start_tree = (grow_tree is tree_start)\n\n            sample_pos = sample_free(grow_tree, other_tree)\n            nearest_node = nearest(grow_tree, sample_pos)\n            new_pos = steer(nearest_node.position, sample_pos)\n\n            if not in_bounds(new_pos) or is_in_obstacle(new_pos):\n                if found_solution:\n                    post_opt_counter += 1\n                    no_improve += 1\n                    if post_opt_counter >= self.post_opt_iters or no_improve >= self.max_no_improve:\n                        break\n                continue\n            if edge_collision(nearest_node.position, new_pos):\n                if found_solution:\n                    post_opt_counter += 1\n                    no_improve += 1\n                    if post_opt_counter >= self.post_opt_iters or no_improve >= self.max_no_improve:\n                        break\n                continue\n\n            new_node, neighbors = add_node_with_best_parent(grow_tree, new_pos)\n            if new_node is None:\n                if found_solution:\n                    post_opt_counter += 1\n                    no_improve += 1\n                    if post_opt_counter >= self.post_opt_iters or no_improve >= self.max_no_improve:\n                        break\n                continue\n\n            edges.append((new_node.parent, new_node))\n            nodes.append(new_node)\n            rewire(new_node, neighbors, grow_tree, edges)\n\n            # Try to connect other tree greedily one step toward new_node with rewiring\n            other_near = nearest(other_tree, new_node.position)\n            curr = other_near\n            connected_node = None\n\n            while True:\n                step_pos = steer(curr.position, new_node.position)\n                if not in_bounds(step_pos) or is_in_obstacle(step_pos):\n                    break\n                if edge_collision(curr.position, step_pos):\n                    break\n\n                w_new_node, w_neighbors = add_node_with_best_parent(other_tree, step_pos)\n                if w_new_node is None:\n                    break\n                edges.append((w_new_node.parent, w_new_node))\n                nodes.append(w_new_node)\n                rewire(w_new_node, w_neighbors, other_tree, edges)\n                curr = w_new_node\n\n                if dist(curr.position, new_node.position) <= self.step_size:\n                    if not edge_collision(curr.position, new_node.position) and new_node.valid:\n                        bridge_node = Node(new_node.position, parent=None,\n                                           cost=curr.cost + dist(curr.position, new_node.position))\n                        curr.add_child(bridge_node)\n                        other_tree.append(bridge_node)\n                        nodes.append(bridge_node)\n                        edges.append((curr, bridge_node))\n                        connected_node = bridge_node\n                    break\n\n            if connected_node is not None:\n                candidate_path = stitch_path(new_node, connected_node, a_start=a_is_start_tree)\n                candidate_cost = path_cost(candidate_path)\n                if candidate_cost + self.improve_tol < best_cost:\n                    best_cost = candidate_cost\n                    best_path = candidate_path\n                    found_solution = True\n                    no_improve = 0\n                    post_opt_counter = 0\n                else:\n                    no_improve += 1\n                    post_opt_counter += 1\n\n                if post_opt_counter >= self.post_opt_iters or no_improve >= self.max_no_improve:\n                    break\n            else:\n                if found_solution:\n                    no_improve += 1\n                    post_opt_counter += 1\n                    if post_opt_counter >= self.post_opt_iters or no_improve >= self.max_no_improve:\n                        break\n\n        return PlannerResult(\n            success=found_solution,\n            path=best_path if found_solution else [],\n            nodes=nodes,\n            edges=edges\n        )",
    "objective": 64.09836,
    "time_improvement": -256.0,
    "length_improvement": 18.0,
    "smoothness_improvement": 371.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.12574965953826905,
            "num_nodes_avg": 297.2,
            "path_length_avg": 157.25260125169626,
            "smoothness_avg": 0.031982096882791765,
            "success_improvement": 0.0,
            "time_improvement": -378.99489884418006,
            "length_improvement": 13.807357427019118,
            "smoothness_improvement": 400.5892664506616,
            "objective_score": -103.41110886478924
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.3570851802825928,
            "num_nodes_avg": 801.0,
            "path_length_avg": 235.28089610184898,
            "smoothness_avg": 0.01636074260770513,
            "success_improvement": 0.0,
            "time_improvement": -116.23174847234705,
            "length_improvement": 21.456464696102515,
            "smoothness_improvement": 320.9736914628338,
            "objective_score": -20.390777266728442
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.18697638511657716,
            "num_nodes_avg": 356.5,
            "path_length_avg": 122.72864267507502,
            "smoothness_avg": 0.03870353042699551,
            "success_improvement": 0.0,
            "time_improvement": -271.8279902291744,
            "length_improvement": 18.489479245165384,
            "smoothness_improvement": 392.30605023393406,
            "objective_score": -68.49317927048341
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m3",
    "algorithm_description": "A bidirectional RRT planner integrating incremental tree growth with dynamic bidirectional connection attempts, enhanced by adaptive stepping and early collision pruning to improve planning efficiency, path length, and smoothness. The planner grows two trees from start and goal positions alternately, samples collision-free points within bounds, and attempts to connect the trees efficiently by extending towards the nearest nodes with collision checks and dynamic step sizes proportional to target distance. It extracts a collision-free path once the trees connect, producing streamlined, robust, and smooth paths efficiently.",
    "planning_mechanism": "The planner alternates growing two trees from start and goal, sampling free points and extending each tree towards them with adaptive step sizes. After each extension, it tries to connect the newly added node to the other tree by incremental, collision-checked steps. Upon connecting nodes from both trees within a step, it extracts the path by concatenating the two tree paths, ensuring collision-free, smooth, and relatively short paths with efficient exploration.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=4000, max_step=7.0, min_step=1.0):\n        self.max_iter = max_iter\n        self.max_step = max_step\n        self.min_step = min_step\n\n    def plan(self, map):\n        bounds = map.size\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start, None, 0.0)]\n        goal_tree = [Node(goal, None, 0.0)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        for i in range(self.max_iter):\n            tree_a, tree_b = (start_tree, goal_tree) if (i % 2 == 0) else (goal_tree, start_tree)\n            rand = self._sample_free(bounds, obstacles, is_3d)\n            new_node_a = self._extend(tree_a, rand, obstacles, is_3d, nodes, edges)\n            if new_node_a is None:\n                continue\n            new_node_b = self._connect(tree_b, new_node_a, obstacles, is_3d, nodes, edges)\n            if new_node_b:\n                path_start = new_node_a.path_from_root()\n                path_goal = new_node_b.path_from_root()\n                if path_start[-1] == path_goal[-1]:\n                    full_path = path_start + path_goal[-2::-1]\n                else:\n                    full_path = path_start + path_goal[::-1]\n                return PlannerResult(True, full_path, nodes, edges)\n\n        return PlannerResult(False, [], nodes, edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        while True:\n            if is_3d:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(3))\n            else:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(2))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def _nearest(self, tree, point):\n        return min(tree, key=lambda node: self._distance(node.position, point))\n\n    def _steer(self, from_pos, to_pos, step_size):\n        dist = self._distance(from_pos, to_pos)\n        if dist <= step_size:\n            return to_pos\n        ratio = step_size / dist\n        return tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(len(from_pos)))\n\n    def _extend(self, tree, point, obstacles, is_3d, nodes, edges):\n        nearest = self._nearest(tree, point)\n        dist = self._distance(nearest.position, point)\n        step = max(self.min_step, min(self.max_step, dist))\n        new_pos = self._steer(nearest.position, point, step)\n        if not self._valid_node_and_edge(nearest.position, new_pos, obstacles, is_3d):\n            return None\n        cost = nearest.cost + self._distance(nearest.position, new_pos)\n        new_node = Node(new_pos, nearest, cost)\n        nearest.add_child(new_node)\n        tree.append(new_node)\n        nodes.append(new_node)\n        edges.append((nearest, new_node))\n        return new_node\n\n    def _connect(self, tree, target_node, obstacles, is_3d, nodes, edges):\n        current = self._nearest(tree, target_node.position)\n        while True:\n            dist = self._distance(current.position, target_node.position)\n            if dist <= self.min_step:\n                if self._valid_node_and_edge(current.position, target_node.position, obstacles, is_3d):\n                    final_node = Node(target_node.position, current, current.cost + dist)\n                    current.add_child(final_node)\n                    tree.append(final_node)\n                    nodes.append(final_node)\n                    edges.append((current, final_node))\n                    return final_node\n                else:\n                    return None\n            step = max(self.min_step, min(self.max_step, dist))\n            new_pos = self._steer(current.position, target_node.position, step)\n            if not self._valid_node_and_edge(current.position, new_pos, obstacles, is_3d):\n                return None\n            cost = current.cost + self._distance(current.position, new_pos)\n            new_node = Node(new_pos, current, cost)\n            current.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((current, new_node))\n            current = new_node\n\n    def _valid_node_and_edge(self, from_pos, to_pos, obstacles, is_3d):\n        return (not self._is_in_obstacle(to_pos, obstacles, is_3d)) and (not self._is_edge_in_obstacle(from_pos, to_pos, obstacles, is_3d))\n\n    def _distance(self, a, b):\n        return sum((a[d] - b[d]) ** 2 for d in range(len(a))) ** 0.5\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, p1, p2, obstacles, is_3d, resolution=0.75):\n        dist = self._distance(p1, p2)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(p1[d] + (p2[d] - p1[d]) * i / steps for d in range(len(p1)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": -2.9445,
    "time_improvement": 71.0,
    "length_improvement": -4.0,
    "smoothness_improvement": 135.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 0.9,
            "time_avg": 0.0052031993865966795,
            "num_nodes_avg": 66.1,
            "path_length_avg": 179.52586487195038,
            "smoothness_avg": 0.015996258195269022,
            "success_improvement": -9.999999999999998,
            "time_improvement": 80.18041581185753,
            "length_improvement": 1.599028694309952,
            "smoothness_improvement": 150.37617718660707,
            "objective_score": -24.234577153923727
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.025962257385253908,
            "num_nodes_avg": 183.2,
            "path_length_avg": 311.53884259076005,
            "smoothness_avg": 0.008952320893406817,
            "success_improvement": 0.0,
            "time_improvement": 84.27864101148131,
            "length_improvement": -4.00063280518264,
            "smoothness_improvement": 130.34966468346292,
            "objective_score": 23.534960943752125
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.02556898593902588,
            "num_nodes_avg": 173.0,
            "path_length_avg": 165.20684003090693,
            "smoothness_avg": 0.017623676399170646,
            "success_improvement": 0.0,
            "time_improvement": 49.15259139287367,
            "length_improvement": -9.722516844185002,
            "smoothness_improvement": 124.17186295297415,
            "objective_score": 9.533126626115969
        }
    ],
    "success_rate": 0.9666666666666667
}
{
    "operator": "m3",
    "algorithm_description": "A simplified bidirectional RRT planner alternating tree expansions, sampling collision-free points, extending towards sampled points with fixed step size, and attempting quick connection between trees. It efficiently grows two trees in 2D or 3D spaces while validating nodes and edges against obstacles, stopping upon connection to return a feasible path.",
    "planning_mechanism": "The planner grows a start and goal tree alternately by sampling random free points in the space, extending toward them with a fixed step size while checking for collisions. After each extension, it attempts to connect the other tree to the new node directly in a single step. Once connected, the full path is reconstructed and returned.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        path, node = [], self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=3000, step_size=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map):\n        bounds = map.size\n        start, goal = map.start, map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n\n        start_tree = [Node(start)]\n        goal_tree = [Node(goal)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        for i in range(self.max_iter):\n            tree_a, tree_b = (start_tree, goal_tree) if i % 2 == 0 else (goal_tree, start_tree)\n            rand = self._sample_free(bounds, obstacles, dim)\n            new_node = self._extend(tree_a, rand, obstacles, dim)\n            if not new_node:\n                continue\n            connected = self._try_connect(tree_b, new_node, obstacles, dim)\n            if connected:\n                path_start = new_node.path_from_root()\n                path_goal = connected.path_from_root()\n                if path_start[-1] == path_goal[-1]:\n                    path = path_start + path_goal[-2::-1]\n                else:\n                    path = path_start + path_goal[::-1]\n                return PlannerResult(True, path, nodes, edges)\n\n        return PlannerResult(False, [], nodes, edges)\n\n    def _sample_free(self, bounds, obstacles, dim):\n        import random\n        while True:\n            pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            if not self._is_in_obstacle(pt, obstacles, dim):\n                return pt\n\n    def _nearest(self, tree, point):\n        return min(tree, key=lambda n: self._distance(n.position, point))\n\n    def _steer(self, from_pos, to_pos):\n        dist = self._distance(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(len(from_pos)))\n\n    def _extend(self, tree, point, obstacles, dim):\n        nearest = self._nearest(tree, point)\n        new_pos = self._steer(nearest.position, point)\n        if not self._valid_move(nearest.position, new_pos, obstacles, dim):\n            return None\n        cost = nearest.cost + self._distance(nearest.position, new_pos)\n        new_node = Node(new_pos, nearest, cost)\n        nearest.add_child(new_node)\n        tree.append(new_node)\n        return new_node\n\n    def _try_connect(self, tree, target_node, obstacles, dim):\n        nearest = self._nearest(tree, target_node.position)\n        if not self._valid_move(nearest.position, target_node.position, obstacles, dim):\n            return None\n        cost = nearest.cost + self._distance(nearest.position, target_node.position)\n        new_node = Node(target_node.position, nearest, cost)\n        nearest.add_child(new_node)\n        tree.append(new_node)\n        return new_node\n\n    def _valid_move(self, from_pos, to_pos, obstacles, dim):\n        return (not self._is_in_obstacle(to_pos, obstacles, dim)) and (not self._edge_in_obstacle(from_pos, to_pos, obstacles, dim))\n\n    def _distance(self, a, b):\n        return sum((a[d]-b[d])**2 for d in range(len(a)))**0.5\n\n    def _is_in_obstacle(self, pos, obstacles, dim):\n        if dim == 3:\n            x, y, z = pos\n            for ox, oy, oz, w, h, d in obstacles:\n                if ox <= x <= ox+w and oy <= y <= oy+h and oz <= z <= oz+d:\n                    return True\n        else:\n            x, y = pos\n            for ox, oy, w, h in obstacles:\n                if ox <= x <= ox+w and oy <= y <= oy+h:\n                    return True\n        return False\n\n    def _edge_in_obstacle(self, p1, p2, obstacles, dim, res=1.0):\n        dist = self._distance(p1, p2)\n        steps = max(1, int(dist / res))\n        for i in range(steps+1):\n            interp = tuple(p1[d] + (p2[d] - p1[d]) * i / steps for d in range(dim))\n            if self._is_in_obstacle(interp, obstacles, dim):\n                return True\n        return False",
    "objective": 0.15112,
    "time_improvement": 64.0,
    "length_improvement": -5.0,
    "smoothness_improvement": 80.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 0.9,
            "time_avg": 0.011497068405151366,
            "num_nodes_avg": 2.0,
            "path_length_avg": 198.14674835764038,
            "smoothness_avg": 0.011015579939297184,
            "success_improvement": -9.999999999999998,
            "time_improvement": 56.20634570343186,
            "length_improvement": -8.607372610977757,
            "smoothness_improvement": 72.41774676470342,
            "objective_score": -37.940431121733575
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.035675334930419925,
            "num_nodes_avg": 2.0,
            "path_length_avg": 303.7268747444005,
            "smoothness_avg": 0.006990144131000228,
            "success_improvement": 0.0,
            "time_improvement": 78.39691906777979,
            "length_improvement": -1.3927730830407905,
            "smoothness_improvement": 79.8614432879454,
            "objective_score": 23.08271908694919
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.021834397315979005,
            "num_nodes_avg": 2.0,
            "path_length_avg": 158.12349228379125,
            "smoothness_avg": 0.01480234075208045,
            "success_improvement": 0.0,
            "time_improvement": 56.5793291660661,
            "length_improvement": -5.018094543324328,
            "smoothness_improvement": 88.284681771322,
            "objective_score": 14.404365432681844
        }
    ],
    "success_rate": 0.9666666666666667
}
{
    "operator": "m3",
    "algorithm_description": "A streamlined bidirectional RRT planner using uniform random sampling, fixed incremental extensions, and direct tree connections, ensuring collision-free node and edge additions. It alternates expanding from start and goal trees and returns a feasible path upon connecting both trees.",
    "planning_mechanism": "The planner iteratively samples random configurations within bounds avoiding obstacles, extends the active tree incrementally toward samples verifying collision-free paths, then tries to directly connect the other tree with a collision-free edge. Once the trees connect, the combined path from start to goal is returned.",
    "code": "class Node:\n    def __init__(self, pos, parent=None, cost=0.0):\n        self.pos = pos\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n    def path(self):\n        node, path = self, []\n        while node:\n            path.append(node.pos)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=3000, step=5.0):\n        self.max_iter = max_iter\n        self.step = step\n\n    def plan(self, map):\n        bounds = map.size\n        start, goal = map.start, map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n\n        tree_start = [Node(start)]\n        tree_goal = [Node(goal)]\n        nodes = tree_start + tree_goal\n        edges = []\n\n        for i in range(self.max_iter):\n            active_tree, other_tree = (tree_start, tree_goal) if i % 2 == 0 else (tree_goal, tree_start)\n            sample = self._random_free(bounds, obstacles, dim)\n            new_node = self._extend_tree(active_tree, sample, obstacles, dim)\n            if not new_node:\n                continue\n            connected_node = self._connect_tree(other_tree, new_node, obstacles, dim)\n            if connected_node:\n                path_start = new_node.path()\n                path_goal = connected_node.path()\n                if path_start[-1] == path_goal[-1]:\n                    path = path_start + path_goal[-2::-1]\n                else:\n                    path = path_start + path_goal[::-1]\n                return PlannerResult(True, path, nodes, edges)\n        return PlannerResult(False, [], nodes, edges)\n\n    def _random_free(self, bounds, obstacles, dim):\n        import random\n        while True:\n            pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            if not self._in_obstacle(pt, obstacles, dim):\n                return pt\n\n    def _nearest(self, tree, pt):\n        return min(tree, key=lambda n: self._dist(n.pos, pt))\n\n    def _steer(self, from_p, to_p):\n        dist = self._dist(from_p, to_p)\n        if dist <= self.step:\n            return to_p\n        ratio = self.step / dist\n        return tuple(from_p[d] + ratio * (to_p[d] - from_p[d]) for d in range(len(from_p)))\n\n    def _extend_tree(self, tree, target, obstacles, dim):\n        nearest = self._nearest(tree, target)\n        new_pos = self._steer(nearest.pos, target)\n        if self._valid_move(nearest.pos, new_pos, obstacles, dim):\n            cost = nearest.cost + self._dist(nearest.pos, new_pos)\n            new_node = Node(new_pos, nearest, cost)\n            nearest.add_child(new_node)\n            tree.append(new_node)\n            return new_node\n        return None\n\n    def _connect_tree(self, tree, node, obstacles, dim):\n        nearest = self._nearest(tree, node.pos)\n        if self._valid_move(nearest.pos, node.pos, obstacles, dim):\n            cost = nearest.cost + self._dist(nearest.pos, node.pos)\n            new_node = Node(node.pos, nearest, cost)\n            nearest.add_child(new_node)\n            tree.append(new_node)\n            return new_node\n        return None\n\n    def _valid_move(self, p1, p2, obstacles, dim):\n        return not self._in_obstacle(p2, obstacles, dim) and not self._edge_in_obstacle(p1, p2, obstacles, dim)\n\n    def _dist(self, a, b):\n        return sum((a[d] - b[d]) ** 2 for d in range(len(a))) ** 0.5\n\n    def _in_obstacle(self, pos, obstacles, dim):\n        if dim == 3:\n            x, y, z = pos\n            for ox, oy, oz, w, h, d in obstacles:\n                if ox <= x <= ox + w and oy <= y <= oy + h and oz <= z <= oz + d:\n                    return True\n        else:\n            x, y = pos\n            for ox, oy, w, h in obstacles:\n                if ox <= x <= ox + w and oy <= y <= oy + h:\n                    return True\n        return False\n\n    def _edge_in_obstacle(self, p1, p2, obstacles, dim, res=1.0):\n        dist = self._dist(p1, p2)\n        steps = max(1, int(dist / res))\n        for i in range(steps + 1):\n            interp = tuple(p1[d] + (p2[d] - p1[d]) * i / steps for d in range(dim))\n            if self._in_obstacle(interp, obstacles, dim):\n                return True\n        return False",
    "objective": 3.31752,
    "time_improvement": 56.0,
    "length_improvement": -6.0,
    "smoothness_improvement": 78.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 0.9,
            "time_avg": 0.011667585372924805,
            "num_nodes_avg": 2.0,
            "path_length_avg": 199.7506003496484,
            "smoothness_avg": 0.010986406240193407,
            "success_improvement": -9.999999999999998,
            "time_improvement": 55.55682698481459,
            "length_improvement": -9.486469302458534,
            "smoothness_improvement": 71.96111502202773,
            "objective_score": -38.6650279109206
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.042991256713867186,
            "num_nodes_avg": 2.0,
            "path_length_avg": 314.05205420211536,
            "smoothness_avg": 0.006785880616944327,
            "success_improvement": 0.0,
            "time_improvement": 73.9667868576729,
            "length_improvement": -4.839615179838341,
            "smoothness_improvement": 74.60559594622474,
            "objective_score": 19.659294929129988
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.03116497993469238,
            "num_nodes_avg": 2.0,
            "path_length_avg": 157.5621983172945,
            "smoothness_avg": 0.014671261501278421,
            "success_improvement": 0.0,
            "time_improvement": 38.0241956896094,
            "length_improvement": -4.645309816723679,
            "smoothness_improvement": 86.61736337638406,
            "objective_score": 9.053159633730532
        }
    ],
    "success_rate": 0.9666666666666667
}
{
    "operator": "e1",
    "algorithm_description": "A hybrid bidirectional RRT* with informed sampling and dynamic neighborhood rewiring. The planner grows two trees simultaneously from start and goal while using informed sampling ellipses to focus the search within an approximate solution space, reducing unnecessary expansions. It dynamically adapts the neighborhood radius for rewiring based on node density and applies incremental rewiring for improved path quality. After connection, a path shortcutting postprocess reduces path length and smoothens the trajectory. This method improves convergence speed, path optimality, and smoothness while maintaining collision safety.",
    "planning_mechanism": "The planner alternately grows two trees using informed uniform sampling constrained by an ellipse defined by current best solution cost to bias sampling towards promising regions. Each extension attempts rewiring with dynamically computed radius and performs incremental path cost improvement both locally and across the trees. When a connection between trees is found, the combined path undergoes shortcutting to reduce unnecessary waypoints and smooth angular transitions. The search halts when maximum iterations or time limit is reached or when no better solution is found over a period.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost  # cost from root\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=3.0, search_radius_factor=50.0, time_limit=10.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.search_radius_factor = search_radius_factor  # parameter to compute rewiring radius dynamically\n        self.time_limit = time_limit\n\n    def plan(self, map):\n        import math\n        import random\n        import time\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = dim == 3\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_p, to_p, max_step):\n            d = dist(from_p, to_p)\n            if d <= max_step:\n                return to_p\n            ratio = max_step / d\n            return tuple(from_p[i] + ratio * (to_p[i] - from_p[i]) for i in range(dim))\n\n        def in_obstacle(p):\n            px, py = p[0], p[1]\n            if is_3d:\n                pz = p[2]\n                for ox, oy, oz, ow, oh, od in obstacles:\n                    if ox <= px <= ox + ow and oy <= py <= oy + oh and oz <= pz <= oz + od:\n                        return True\n            else:\n                for ox, oy, ow, oh in obstacles:\n                    if ox <= px <= ox + ow and oy <= py <= oy + oh:\n                        return True\n            return False\n\n        def edge_collision(f, t, resolution=0.2):\n            length = dist(f, t)\n            steps = max(1, int(length / resolution))\n            for i in range(steps + 1):\n                interp = tuple(f[d] + (t[d] - f[d]) * (i/steps) for d in range(dim))\n                if in_obstacle(interp):\n                    return True\n            return False\n\n        # Nodes and edges\n        start_node = Node(start_pos, parent=None, cost=0.0)\n        goal_node = Node(goal_pos, parent=None, cost=0.0)\n        tree_start = [start_node]\n        tree_goal = [goal_node]\n\n        all_nodes = [start_node, goal_node]\n        all_edges = []\n\n        # For informed sampling ellipse params\n        c_best = float('inf')\n        c_min = dist(start_pos, goal_pos)\n        center = tuple((start_pos[i] + goal_pos[i]) / 2.0 for i in range(dim))\n        # Unit vector from start to goal\n        unit_vector = tuple((goal_pos[i] - start_pos[i]) / c_min if c_min > 0 else 1.0 for i in range(dim))\n\n        def sample_in_ellipse():\n            # If no solution found, sample uniformly in bounds\n            if c_best == float('inf'):\n                while True:\n                    sample = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                    if not in_obstacle(sample):\n                        return sample\n            else:\n                # Sample point inside ellipse defined by start and goal and cost c_best\n                while True:\n                    # Sample uniformly in unit ball\n                    import math\n                    while True:\n                        pt = [random.uniform(-1, 1) for _ in range(dim)]\n                        norm = math.sqrt(sum(x * x for x in pt))\n                        if norm <= 1 and norm > 0:\n                            break\n                    # Scale unit ball by ellipse radii\n                    r1 = c_best / 2.0\n                    rest = math.sqrt(max(c_best * c_best - c_min * c_min, 0)) / 2.0\n                    # Compute orthonormal basis with unit_vector as first basis vector\n                    # Use Householder reflection or Gram-Schmidt; simplified for 2D and 3D\n                    # We'll build rotation matrix from unit_vector\n                    # For numerical stability and general dim, just approximate by aligning first axis to unit_vector\n\n                    # Construct rotation matrix R: map e1=[1,0..] to unit_vector\n                    # Here approximate: rotation for 2D or 3D only\n\n                    if dim == 2:\n                        ux, uy = unit_vector\n                        cos_theta = ux\n                        sin_theta = uy\n                        # scale coords: first axis r1, second rest\n                        x = pt[0] * r1\n                        y = pt[1] * rest\n                        # Rotate\n                        rx = cos_theta * x - sin_theta * y\n                        ry = sin_theta * x + cos_theta * y\n                        sample = (rx + center[0], ry + center[1])\n                    elif dim == 3:\n                        # Construct an orthonormal basis (u, v, w)\n                        # u = unit_vector\n                        # v = arbitrary vector orthogonal to u\n                        # w = u cross v\n                        u = unit_vector\n                        # Choose v:\n                        if abs(u[0]) < 0.9:\n                            v = (-u[1], u[0], 0.0)\n                        else:\n                            v = (0.0, -u[2], u[1])\n                        norm_v = math.sqrt(sum(x*x for x in v))\n                        v = tuple(x / norm_v for x in v)\n                        # w = u cross v\n                        w = (u[1]*v[2] - u[2]*v[1],\n                             u[2]*v[0] - u[0]*v[2],\n                             u[0]*v[1] - u[1]*v[0])\n                        # scale coords\n                        x = pt[0] * r1\n                        y = pt[1] * rest\n                        z = pt[2] * rest\n                        rx = u[0]*x + v[0]*y + w[0]*z + center[0]\n                        ry = u[1]*x + v[1]*y + w[1]*z + center[1]\n                        rz = u[2]*x + v[2]*y + w[2]*z + center[2]\n                        sample = (rx, ry, rz)\n                    else:\n                        # fallback to uniform sample in bounds\n                        return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n\n                    # Check bounds\n                    in_bounds = True\n                    for i in range(dim):\n                        if sample[i] < 0 or sample[i] > bounds[i]:\n                            in_bounds = False\n                            break\n                    if not in_bounds:\n                        continue\n                    if not in_obstacle(sample):\n                        return sample\n\n        # Dynamic radius for rewiring based on formula for RRT*\n        def compute_radius(n_nodes):\n            gamma_rrt_star = self.search_radius_factor\n            radius = min(self.step_size * 20.0, gamma_rrt_star * (math.log(n_nodes + 1) / (n_nodes + 1)) ** (1 / dim))\n            return radius\n\n        def near_nodes(tree, point, radius):\n            return [node for node in tree if dist(node.position, point) <= radius]\n\n        def rewire(tree, new_node, radius):\n            neighbors = near_nodes(tree, new_node.position, radius)\n            for near_node in neighbors:\n                if near_node is new_node.parent:\n                    continue\n                # If connecting near_node from new_node reduces cost and edge valid\n                proposed_cost = new_node.cost + dist(new_node.position, near_node.position)\n                if proposed_cost < near_node.cost:\n                    if not edge_collision(new_node.position, near_node.position):\n                        # rewire near_node to new_node\n                        old_parent = near_node.parent\n                        if old_parent:\n                            try:\n                                old_parent.children.remove(near_node)\n                            except ValueError:\n                                pass\n                        near_node.parent = new_node\n                        near_node.cost = proposed_cost\n                        new_node.children.append(near_node)\n                        # propagate cost updates to descendants\n                        self._update_costs(near_node)\n\n        def insert_node(tree, new_pos, parent_node):\n            cost = parent_node.cost + dist(parent_node.position, new_pos)\n            new_node = Node(new_pos, parent=parent_node, cost=cost)\n            parent_node.children.append(new_node)\n            tree.append(new_node)\n            all_nodes.append(new_node)\n            all_edges.append((parent_node, new_node))\n            return new_node\n\n        def try_extend(tree, sample):\n            nearest = min(tree, key=lambda node: dist(node.position, sample))\n            new_pos = steer(nearest.position, sample, self.step_size)\n            if in_obstacle(new_pos):\n                return None\n            if edge_collision(nearest.position, new_pos):\n                return None\n            return insert_node(tree, new_pos, nearest)\n\n        def try_connect_trees(node_start, tree_goal):\n            import collections\n            # Attempt to connect node_start to nearest node(s) in tree_goal by extending edges (like RRT*)\n            radius = compute_radius(len(tree_goal))\n            neighbors = near_nodes(tree_goal, node_start.position, radius)\n            best_connection = None\n            best_cost = float('inf')\n            for goal_node in neighbors:\n                if not edge_collision(node_start.position, goal_node.position):\n                    cost = node_start.cost + dist(node_start.position, goal_node.position) + goal_node.cost\n                    if cost < best_cost:\n                        best_cost = cost\n                        best_connection = goal_node\n            return best_connection, best_cost if best_connection is not None else (None, None)\n\n        def extract_path(node_from_start, node_from_goal):\n            path_start = []\n            n = node_from_start\n            while n is not None:\n                path_start.append(n.position)\n                n = n.parent\n            path_start.reverse()\n            path_goal = []\n            n = node_from_goal\n            while n is not None:\n                path_goal.append(n.position)\n                n = n.parent\n            return path_start + path_goal\n\n        def shortcut_path(path, max_trials=100):\n            # Attempts to shortcut path by replacing subpaths with direct segments if valid\n            if len(path) < 3:\n                return path\n            shortened = path[:]\n            for _ in range(max_trials):\n                if len(shortened) < 3:\n                    break\n                import random\n                i = random.randint(0, len(shortened) - 3)\n                j = random.randint(i + 2, len(shortened) - 1)\n                if not edge_collision(shortened[i], shortened[j]):\n                    # remove points i+1 to j-1\n                    shortened = shortened[:i+1] + shortened[j:]\n            return shortened\n\n        def cost_via_nodes(n1, n2):\n            return n1.cost + dist(n1.position, n2.position) + n2.cost\n\n        self._update_costs = lambda node: self._propagate_costs(node, dist)\n\n        start_time = time.time()\n        best_path = None\n        best_cost = float('inf')\n        last_improve_iter = 0\n\n        for it in range(self.max_iter):\n            if time.time() - start_time > self.time_limit:\n                break\n\n            sample = sample_in_ellipse()\n            # Alternate growth\n            grow_start = (it % 2 == 0)\n            if grow_start:\n                new_node = try_extend(tree_start, sample)\n                tree_grow = tree_start\n                tree_connect = tree_goal\n            else:\n                new_node = try_extend(tree_goal, sample)\n                tree_grow = tree_goal\n                tree_connect = tree_start\n\n            if new_node is None:\n                continue\n\n            radius = compute_radius(len(tree_grow))\n            rewire(tree_grow, new_node, radius)\n\n            conn_node, conn_cost = try_connect_trees(new_node, tree_connect)\n            if conn_node is not None and conn_cost < best_cost:\n                best_cost = conn_cost\n                if grow_start:\n                    path = extract_path(new_node, conn_node)\n                else:\n                    path = extract_path(conn_node, new_node)\n                best_path = shortcut_path(path)\n                last_improve_iter = it\n\n            # Early stop if no improvement for many iterations\n            if it - last_improve_iter > 150 and best_path is not None:\n                break\n\n        success = best_path is not None\n\n        return PlannerResult(success, best_path if success else [],\n                             all_nodes, all_edges)\n\n\n    def _propagate_costs(self, node, dist_func):\n        # Recursive update of costs for subtree rooted at node\n        for child in node.children:\n            new_cost = node.cost + dist_func(node.position, child.position)\n            if child.cost > new_cost:\n                child.cost = new_cost\n                self._propagate_costs(child, dist_func)",
    "objective": 67.34584,
    "time_improvement": -280.0,
    "length_improvement": 18.0,
    "smoothness_improvement": 1165.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.13730175495147706,
            "num_nodes_avg": 326.4,
            "path_length_avg": 163.7196844298599,
            "smoothness_avg": 0.0323232060861102,
            "success_improvement": 0.0,
            "time_improvement": -422.99815733573814,
            "length_improvement": 10.262646659576829,
            "smoothness_improvement": 405.928366213086,
            "objective_score": -118.71221737390991
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.10871767997741699,
            "num_nodes_avg": 544.6,
            "path_length_avg": 225.24784467050148,
            "smoothness_avg": 0.0736347701135599,
            "success_improvement": 0.0,
            "time_improvement": 34.16636889615569,
            "length_improvement": 24.805786049259623,
            "smoothness_improvement": 1794.675672003038,
            "objective_score": 34.10676065841767
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.27789170742034913,
            "num_nodes_avg": 756.1,
            "path_length_avg": 120.74631266459755,
            "smoothness_avg": 0.10962272805060783,
            "success_improvement": 0.0,
            "time_improvement": -452.62548266209484,
            "length_improvement": 19.80604844971319,
            "smoothness_improvement": 1294.3930092956348,
            "objective_score": -117.43205068232234
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m3",
    "algorithm_description": "A simplified RRT* planner that balances efficient sampling, dynamic neighborhood rewiring, and path shortening to improve planning success, path quality, and smoothness while maintaining general applicability across 2D/3D maps. The planner grows a single tree with adaptive neighbor radius for rewiring, attempts direct connection to goal when close, and performs a single-pass path shortcutting at the end.",
    "planning_mechanism": "The planner samples uniformly, finds nearest nodes, steers by fixed steps, rewires within a radius that shrinks as iterations progress, tries connecting the goal if near, and postprocesses the found path by shortcutting to improve length and smoothness while ensuring collision-free paths.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\nclass Planner:\n    def __init__(self, max_iter=3000, step_size=4.0, radius_max=20.0, radius_min=3.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.radius_max = radius_max\n        self.radius_min = radius_min\n\n    def plan(self, map) -> \"PlannerResult\":\n        import math\n        import random\n\n        bounds = map.size\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        tree = [Node(start)]\n        edges = []\n        success = False\n        best_goal_node = None\n        best_cost = float(\"inf\")\n\n        def collision_free_point(pt):\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d = obs\n                    px,py,pz = pt\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return False\n                else:\n                    x,y,w,h = obs\n                    px,py = pt\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return False\n            return True\n\n        def collision_free_edge(a, b, res=0.5):\n            dist = self._distance(a,b)\n            steps = max(2, int(dist / res))\n            for i in range(steps+1):\n                interp = tuple(a[d] + (b[d]-a[d]) * i/steps for d in range(len(a)))\n                if not collision_free_point(interp):\n                    return False\n            return True\n\n        def nearest_node(sample):\n            min_node = None\n            min_dist = float(\"inf\")\n            for n in tree:\n                d = self._distance(n.position, sample)\n                if d < min_dist:\n                    min_dist = d\n                    min_node = n\n            return min_node\n\n        def near_nodes(point, radius):\n            r2 = radius*radius\n            return [n for n in tree if self._distance_sq(n.position, point) <= r2]\n\n        def steer(from_pt, to_pt):\n            dist = self._distance(from_pt, to_pt)\n            if dist <= self.step_size:\n                return to_pt\n            ratio = self.step_size / dist\n            return tuple(from_pt[i] + (to_pt[i] - from_pt[i]) * ratio for i in range(len(from_pt)))\n\n        for i in range(1, self.max_iter+1):\n            while True:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                if collision_free_point(sample):\n                    break\n\n            nearest = nearest_node(sample)\n            new_pos = steer(nearest.position, sample)\n            if not collision_free_point(new_pos) or not collision_free_edge(nearest.position, new_pos):\n                continue\n\n            # radius adapts with iteration (shrinks slowly)\n            radius = max(self.radius_min, self.radius_max * (math.log(i+1)/(i+1))**0.5)\n\n            near_set = near_nodes(new_pos, radius)\n\n            # Choose best parent\n            min_cost = nearest.cost + self._distance(nearest.position, new_pos)\n            min_parent = nearest\n            for node in near_set:\n                cost_to_new = node.cost + self._distance(node.position, new_pos)\n                if cost_to_new < min_cost and collision_free_edge(node.position, new_pos):\n                    min_cost = cost_to_new\n                    min_parent = node\n\n            new_node = Node(new_pos, parent=min_parent, cost=min_cost)\n            min_parent.add_child(new_node)\n            tree.append(new_node)\n            edges.append((min_parent,new_node))\n\n            # Rewire neighbors\n            for node in near_set:\n                if node == min_parent:\n                    continue\n                new_cost = new_node.cost + self._distance(new_node.position, node.position)\n                if new_cost < node.cost and collision_free_edge(new_node.position, node.position):\n                    if node.parent:\n                        edges.remove((node.parent, node))\n                        node.parent.remove_child(node)\n                    node.parent = new_node\n                    node.cost = new_cost\n                    new_node.add_child(node)\n                    edges.append((new_node, node))\n\n            # Try connect goal if near\n            dist_goal = self._distance(new_node.position, goal)\n            if dist_goal <= self.step_size:\n                if collision_free_point(goal) and collision_free_edge(new_node.position, goal):\n                    goal_node = Node(goal, parent=new_node, cost=new_node.cost + dist_goal)\n                    new_node.add_child(goal_node)\n                    tree.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    if goal_node.cost < best_cost:\n                        best_cost = goal_node.cost\n                        best_goal_node = goal_node\n                        success = True\n\n            if success and i > 50 and i % 10 == 0:\n                break\n\n        if not success:\n            return PlannerResult(False, [], tree, edges)\n\n        path = self._extract_path(best_goal_node)\n        path = self._shortcut_path(path, collision_free_edge)\n        return PlannerResult(True, path, tree, edges)\n\n    def _distance(self, a, b):\n        s=0.0\n        for i in range(len(a)):\n            s += (a[i]-b[i])**2\n        return s**0.5\n\n    def _distance_sq(self, a, b):\n        s=0.0\n        for i in range(len(a)):\n            s += (a[i]-b[i])**2\n        return s\n\n    def _extract_path(self, goal_node):\n        path = []\n        current = goal_node\n        while current:\n            path.append(current.position)\n            current = current.parent\n        return path[::-1]\n\n    def _shortcut_path(self, path, collision_check_edge):\n        if len(path) < 3:\n            return path\n        shortened = [path[0]]\n        i = 0\n        while i < len(path)-1:\n            j = len(path)-1\n            while j > i+1:\n                if collision_check_edge(path[i], path[j]):\n                    break\n                j -= 1\n            shortened.append(path[j])\n            i = j\n        return shortened",
    "objective": 446.92394,
    "time_improvement": -1550.0,
    "length_improvement": 15.0,
    "smoothness_improvement": 1813.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.7938541173934937,
            "num_nodes_avg": 1038.2,
            "path_length_avg": 173.96059449334226,
            "smoothness_avg": 0.061321596654763055,
            "success_improvement": 0.0,
            "time_improvement": -2923.881528221643,
            "length_improvement": 4.649441576177579,
            "smoothness_improvement": 859.816149625509,
            "objective_score": -870.0757127726588
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 1.7996135234832764,
            "num_nodes_avg": 1431.4,
            "path_length_avg": 234.62936662064917,
            "smoothness_avg": 0.11445210890377959,
            "success_improvement": 0.0,
            "time_improvement": -989.7500099256837,
            "length_improvement": 21.67396399016333,
            "smoothness_improvement": 2844.935198616183,
            "objective_score": -269.6959485905262
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.4200397491455078,
            "num_nodes_avg": 653.0,
            "path_length_avg": 123.15732201925016,
            "smoothness_avg": 0.14416491148312877,
            "success_improvement": 0.0,
            "time_improvement": -735.3062106948057,
            "length_improvement": 18.204770836281035,
            "smoothness_improvement": 1733.7670329185364,
            "objective_score": -201.0001655420804
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "e2",
    "algorithm_description": "A hybrid bidirectional RRT* variant integrating goal bias sampling, informed rewiring, and adaptive step size to efficiently find shorter, smoother, and feasible paths in 2D/3D spaces. It uses informed sampling to speed convergence, rigorous collision checking ensuring safe expansions, incremental rewiring to optimize path cost, and path shortcutting to smooth the final output.",
    "planning_mechanism": "A bidirectional tree grows from start and goal, alternately sampling with goal bias and within an ellipsoidal informed set once a solution is found. New nodes are extended from nearest tree nodes with adaptive step size considering proximity. After adding a new node, rewiring is performed to update neighbor connections minimizing cost to come. The two trees attempt connection after each extension. Upon successful connection, the combined path is shortcut and returned.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def path_from_root(self):\n        path, node = [], self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=4.0, goal_sample_rate=0.1, neighbor_radius=10.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate  # Probability of sampling goal\n        self.neighbor_radius = neighbor_radius    # Radius to search for rewiring neighbors\n\n    def plan(self, map):\n        bounds = map.size\n        start, goal = map.start, map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        start_tree = [Node(start, cost=0.0)]\n        goal_tree = [Node(goal, cost=0.0)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        best_cost = float('inf')\n        best_connection = None\n\n        def dist(a, b):\n            return sum((a[d]-b[d])**2 for d in range(dim))**0.5\n\n        def line_cost(a, b):\n            return dist(a, b)\n\n        # Utility for collision checking a single point\n        def in_obstacle(p):\n            if is_3d:\n                x, y, z = p\n                for ox, oy, oz, w, h, d in obstacles:\n                    if ox <= x <= ox + w and oy <= y <= oy + h and oz <= z <= oz + d:\n                        return True\n            else:\n                x, y = p\n                for ox, oy, w, h in obstacles:\n                    if ox <= x <= ox + w and oy <= y <= oy + h:\n                        return True\n            return False\n\n        # Checks collision for edge p1->p2 by interpolation with resolution = 1.0 units\n        def edge_in_obstacle(p1, p2):\n            dist_p = dist(p1, p2)\n            steps = max(1, int(dist_p / 1.0))\n            for i in range(steps + 1):\n                interp = tuple(p1[d] + (p2[d]-p1[d])*i/steps for d in range(dim))\n                if in_obstacle(interp):\n                    return True\n            return False\n\n        # Sample free point with goal bias and informed ellipsoid sampling if solution found\n        def sample_free():\n            if best_connection and random.random() > self.goal_sample_rate:\n                # Informed ellipsoid sampling within informed subset (prolate hyperspheroid)\n                c_min = dist(start, goal)\n                c_best = best_cost\n                if c_best < float('inf') and c_best > c_min:\n                    center = [(s+g)*0.5 for s,g in zip(start, goal)]\n                    a1 = [(g - s)/c_min for s,g in zip(start, goal)]\n                    # Sample unit ball in dim-dim space and transform\n                    while True:\n                        x_ball = [random.gauss(0,1) for _ in range(dim)]\n                        norm = (sum(x**2 for x in x_ball))**0.5\n                        if norm <= 1:\n                            unit = [x / norm for x in x_ball]\n                            r1 = c_best / 2.0\n                            r2 = (c_best**2 - c_min**2)**0.5 / 2.0 if c_best**2 - c_min**2 > 0 else 0.0\n                            # Construct scaled unit vector in bounding box of ellipsoid\n                            if dim == 2:\n                                # Rotation matrix from a1 to x axis\n                                angle = math.atan2(a1[1], a1[0])\n                                cos_ang = math.cos(angle)\n                                sin_ang = math.sin(angle)\n                                # Scale unit ball coordinates\n                                x_ell = r1 * unit[0]\n                                y_ell = r2 * unit[1]\n                                # Rotate back to world frame and translate\n                                px = center[0] + cos_ang * x_ell - sin_ang * y_ell\n                                py = center[1] + sin_ang * x_ell + cos_ang * y_ell\n                                pt = (px, py)\n                            else:\n                                # 3D case: align a1 with x axis by rotation matrix (approximate)\n                                # To simplify, sample box around center limited by bounds\n                                pt_candidate = [center[d] + r1*unit[0] if d == 0 else center[d] + r2*unit[d] for d in range(dim)]\n                                pt = tuple(max(0,min(pt_candidate[d], bounds[d])) for d in range(dim))\n                            if (all(0 <= pt[d] <= bounds[d] for d in range(dim)) and not in_obstacle(pt)):\n                                return pt\n                else:\n                    # If no valid c_best, fall back to uniform\n                    return uniform_sample()\n            # else regular or goal biased sample\n            if random.random() < self.goal_sample_rate:\n                return goal\n            else:\n                return uniform_sample()\n\n        def uniform_sample():\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not in_obstacle(pt):\n                    return pt\n\n        # Find the nearest node in a tree by Euclidean distance\n        def nearest(tree, point):\n            best = None\n            best_dist = float('inf')\n            for node in tree:\n                d = dist(node.position, point)\n                if d < best_dist:\n                    best = node\n                    best_dist = d\n            return best\n\n        # Steer from from_pos towards to_pos by step size or closer\n        def steer(from_pos, to_pos, max_step):\n            d = dist(from_pos, to_pos)\n            if d <= max_step:\n                return to_pos\n            ratio = max_step / d\n            return tuple(from_pos[d_] + ratio * (to_pos[d_] - from_pos[d_]) for d_ in range(dim))\n\n        # Find neighbors within radius for rewiring\n        def near(tree, node, radius):\n            ret = []\n            for n in tree:\n                if dist(n.position, node.position) <= radius:\n                    ret.append(n)\n            return ret\n\n        # Attempt to add new node to tree with rewiring for cost improvement\n        def extend_with_rewire(tree, point):\n            nearest_node = nearest(tree, point)\n            new_pos = steer(nearest_node.position, point, self.step_size)\n            if in_obstacle(new_pos) or edge_in_obstacle(nearest_node.position, new_pos):\n                return None\n            new_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            new_node = Node(new_pos, parent=nearest_node, cost=new_cost)\n            nearest_node.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n\n            # Rewire neighbors if cheaper to reach via new_node\n            neighbors = near(tree, new_node, self.neighbor_radius)\n            for neighbor in neighbors:\n                if neighbor == new_node.parent:\n                    continue\n                cost_to_neighbor = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_to_neighbor < neighbor.cost:\n                    # Check if edge is collision free before rewiring\n                    if not edge_in_obstacle(new_node.position, neighbor.position):\n                        # Rewire\n                        if neighbor.parent:\n                            neighbor.parent.remove_child(neighbor)\n                        neighbor.parent = new_node\n                        new_node.children.append(neighbor)\n                        # Update costs downstream by DFS\n                        def update_costs(n):\n                            for c in n.children:\n                                old_cost = c.cost\n                                c.cost = n.cost + dist(n.position, c.position)\n                                if c.cost < old_cost:\n                                    update_costs(c)\n                        neighbor.cost = cost_to_neighbor\n                        update_costs(neighbor)\n\n            return new_node\n\n        # Try to connect tree_b to node from tree_a by single edge\n        def try_connect(tree_b, node_a):\n            nearest_node = nearest(tree_b, node_a.position)\n            if edge_in_obstacle(nearest_node.position, node_a.position) or in_obstacle(node_a.position):\n                return None\n            c_cost = nearest_node.cost + dist(nearest_node.position, node_a.position)\n            new_node = Node(node_a.position, parent=nearest_node, cost=c_cost)\n            nearest_node.add_child(new_node)\n            tree_b.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n            return new_node\n\n        # Shortcut the final path by removing unnecessary waypoints with collision checking\n        def shortcut_path(path):\n            if len(path) <= 2:\n                return path\n            shortened = [path[0]]\n            idx = 0\n            while idx < len(path) - 1:\n                next_idx = len(path) -1\n                for j in range(len(path)-1, idx, -1):\n                    if not edge_in_obstacle(path[idx], path[j]):\n                        next_idx = j\n                        break\n                shortened.append(path[next_idx])\n                idx = next_idx\n            return shortened\n\n        import random\n        import math\n\n        for itr in range(self.max_iter):\n            tree_a, tree_b = (start_tree, goal_tree) if itr % 2 == 0 else (goal_tree, start_tree)\n\n            sample = sample_free()\n            new_node_a = extend_with_rewire(tree_a, sample)\n            if new_node_a is None:\n                continue\n\n            new_node_b = try_connect(tree_b, new_node_a)\n            if new_node_b:\n                total_cost = new_node_a.cost + new_node_b.cost\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_connection = (new_node_a, new_node_b)\n\n                # Build full path from start to goal via connecting nodes\n                path_start = new_node_a.path_from_root()\n                path_goal = new_node_b.path_from_root()\n                # Remove duplication of connecting node\n                if path_start[-1] == path_goal[-1]:\n                    full_path = path_start + path_goal[-2::-1]\n                else:\n                    full_path = path_start + path_goal[::-1]\n                # Shortcut path to improve smoothness and length\n                full_path = shortcut_path(full_path)\n                return PlannerResult(\n                    success=True,\n                    path=full_path,\n                    nodes=nodes,\n                    edges=edges\n                )\n\n        # If no connection found after max_iter\n        return PlannerResult(\n            success=False,\n            path=[],\n            nodes=nodes,\n            edges=edges\n        )",
    "objective": -13.10341,
    "time_improvement": -17.0,
    "length_improvement": 15.0,
    "smoothness_improvement": 1770.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.03586246967315674,
            "num_nodes_avg": 158.2,
            "path_length_avg": 169.64979962636318,
            "smoothness_avg": 0.04954703801688554,
            "success_improvement": 0.0,
            "time_improvement": -36.60426673496058,
            "length_improvement": 7.012256551684769,
            "smoothness_improvement": 675.5187380793998,
            "objective_score": -3.3963323990803147
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.07881088256835937,
            "num_nodes_avg": 308.2,
            "path_length_avg": 237.82271271086537,
            "smoothness_avg": 0.12127577225727508,
            "success_improvement": 0.0,
            "time_improvement": 52.276331034184054,
            "length_improvement": 20.60793314987834,
            "smoothness_improvement": 3020.512971587674,
            "objective_score": 43.150224058120585
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.08306193351745605,
            "num_nodes_avg": 277.3,
            "path_length_avg": 122.87997069169981,
            "smoothness_avg": 0.13485837299586953,
            "success_improvement": 0.0,
            "time_improvement": -65.17995994568392,
            "length_improvement": 18.388974381988994,
            "smoothness_improvement": 1615.3885502978142,
            "objective_score": -0.4436606030227068
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m2",
    "algorithm_description": "A bidirectional RRT* variant that uses informed sampling within an ellipsoidal region (informed RRT*) to bias samples towards the subset of the state space likely to improve the current solution, combined with rewiring for asymptotic optimality. It incorporates direct connection attempts between trees and post-processing shortcutting for smoother, shorter paths.",
    "planning_mechanism": "The planner grows two trees from start and goal alternately, sampling randomly inside an ellipsoid defined by start, goal, and the current best path cost to focus growth in promising areas. Each new node is connected and rewired locally to improve path cost. The trees attempt direct connection when close, and after finding a solution, the planner shortcut-postprocesses the path to enhance smoothness and reduce length.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\nclass Planner:\n    def __init__(self, max_iter=3000, step_size=7.5, rewire_radius=15.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.rewire_radius = rewire_radius\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        edges = []\n        best_cost = float('inf')\n        best_path = []\n\n        def distance(a,b):\n            return math.dist(a,b)\n\n        def is_in_collision(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d = obs\n                    px,py,pz = pos\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                        return True\n                else:\n                    x,y,w,h = obs\n                    px,py = pos\n                    if x <= px <= x+w and y <= py <= y+h:\n                        return True\n            return False\n\n        def is_edge_collision(from_pos, to_pos, resolution=1.0):\n            dist = distance(from_pos, to_pos)\n            steps = max(1,int(dist / resolution))\n            for i in range(steps+1):\n                interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * i/steps for d in range(len(from_pos)))\n                if is_in_collision(interp):\n                    return True\n            return False\n\n        def steer(from_pos, to_pos, max_step):\n            dist = distance(from_pos, to_pos)\n            if dist <= max_step:\n                return to_pos\n            ratio = max_step / dist\n            return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: distance(node.position, point))\n\n        def neighbors(tree, point, radius):\n            result = []\n            r_sq = radius*radius\n            for node in tree:\n                dx = node.position[0] - point[0]\n                dy = node.position[1] - point[1]\n                dz = node.position[2] - point[2] if is_3d else 0.0\n                dist_sq = dx*dx + dy*dy + dz*dz\n                if dist_sq <= r_sq:\n                    result.append(node)\n            return result\n\n        def extract_path(node_start, node_goal):\n            path_start = []\n            while node_start:\n                path_start.append(node_start.position)\n                node_start = node_start.parent\n            path_start.reverse()\n            path_goal = []\n            while node_goal:\n                path_goal.append(node_goal.position)\n                node_goal = node_goal.parent\n            return path_start + path_goal\n\n        def try_connect(node_from, tree_to):\n            near = nearest(tree_to, node_from.position)\n            if is_edge_collision(node_from.position, near.position):\n                return None\n            # direct connection possible, make new node\n            new_node = Node(near.position, parent=node_from, cost=node_from.cost + distance(node_from.position, near.position))\n            node_from.add_child(new_node)\n            tree_to.append(new_node)\n            edges.append((node_from,new_node))\n            return new_node\n\n        def rewire(tree, new_node):\n            nbs = neighbors(tree, new_node.position, self.rewire_radius)\n            for nb in nbs:\n                if nb == new_node.parent:\n                    continue\n                if is_edge_collision(new_node.position, nb.position):\n                    continue\n                new_cost = new_node.cost + distance(new_node.position, nb.position)\n                if new_cost + 1e-7 < nb.cost:\n                    # Rewire nb's parent link\n                    if nb.parent:\n                        try:\n                            nb.parent.children.remove(nb)\n                        except ValueError:\n                            pass\n                    nb.parent = new_node\n                    nb.cost = new_cost\n                    new_node.add_child(nb)\n\n        def informed_sample(c_best):\n            # Sample uniformly inside ellipsoid defined by start, goal, c_best\n            if c_best == float('inf'):\n                # No solution found yet, uniform sample in bounds\n                while True:\n                    sample = tuple(random.uniform(0, bounds[i]) for i in range(len(bounds)))\n                    if not is_in_collision(sample):\n                        return sample\n            else:\n                c_min = distance(start_pos, goal_pos)\n                if c_min == 0.0:\n                    return goal_pos\n                # Ellipsoid parameters\n                center = tuple((start_pos[i]+goal_pos[i])/2 for i in range(len(bounds)))\n                a1 = [(goal_pos[i]-start_pos[i])/c_min for i in range(len(bounds))]\n                # Build rotation matrix to transform unit ball samples\n                # For 2D or 3D the rotation matrix is based on a1 vector\n                # Using Householder transform for rotation to align x-axis with a1\n                dim = len(bounds)\n                def mat_vec_mult(mat, vec):\n                    return tuple(sum(mat[i][j]*vec[j] for j in range(dim)) for i in range(dim))\n                # Construct orthonormal basis with a1 as first basis vector\n                # For 2D and 3D:\n                if dim == 2:\n                    # rotation angle\n                    theta = math.acos(a1[0])\n                    if a1[1]<0:\n                        theta = -theta\n                    # rotation matrix\n                    R = [[math.cos(theta), -math.sin(theta)],\n                         [math.sin(theta), math.cos(theta)]]\n                elif dim ==3:\n                    # Construct a rotation matrix using Householder reflection\n                    # vector to rotate to x = a1\n                    x = a1\n                    I = [[1 if i==j else 0 for j in range(3)] for i in range(3)]\n                    v = [x[0]-1, x[1], x[2]]\n                    norm_v = math.sqrt(sum(vi*vi for vi in v))\n                    if norm_v < 1e-10:\n                        R = I\n                    else:\n                        v = [vi/norm_v for vi in v]\n                        R = [[I[i][j] - 2*v[i]*v[j] for j in range(3)] for i in range(3)]\n                else:\n                    R = [[1 if i==j else 0 for j in range(dim)] for i in range(dim)]\n\n                # lengths of ellipsoid axes\n                L1 = c_best/2.0\n                L_other = math.sqrt(c_best*c_best - c_min*c_min)/2.0\n\n                while True:\n                    # sample random unit vector in unit ball\n                    while True:\n                        sample = [random.uniform(-1,1) for _ in range(dim)]\n                        norm_sample = math.sqrt(sum(x*x for x in sample))\n                        if 0 < norm_sample <= 1:\n                            break\n                    unit_s = [x/norm_sample for x in sample]\n                    r = random.uniform(0,1)**(1/dim)  # radius for uniform ball sampling\n                    unit_ball_sample = [r*us for us in unit_s]\n\n                    # scale by axes\n                    ellipsoid_sample = [L1*unit_ball_sample[0]] + [L_other*unit_ball_sample[i] for i in range(1,dim)]\n\n                    # rotate and translate\n                    if dim == 2 or dim == 3:\n                        rotated = mat_vec_mult(R, ellipsoid_sample)\n                    else:\n                        rotated = ellipsoid_sample\n                    point = tuple(center[i] + rotated[i] for i in range(dim))\n                    if all(0 <= point[i] <= bounds[i] for i in range(dim)):\n                        if not is_in_collision(point):\n                            return point\n\n        def shortcut_path(path):\n            if len(path)<=2:\n                return path\n            i = 0\n            while i < len(path)-2:\n                j = len(path)-1\n                while j > i+1:\n                    if not is_edge_collision(path[i], path[j]):\n                        # shortcut between i and j\n                        path = path[:i+1] + path[j:]\n                        break\n                    j -=1\n                i +=1\n            return path\n\n        for it in range(self.max_iter):\n            sample = informed_sample(best_cost)\n            for tree_a, tree_b in [(start_tree, goal_tree),(goal_tree, start_tree)]:\n                near = nearest(tree_a, sample)\n                new_pos = steer(near.position, sample, self.step_size)\n                if is_in_collision(new_pos):\n                    continue\n                if is_edge_collision(near.position, new_pos):\n                    continue\n                new_cost = near.cost + distance(near.position, new_pos)\n                new_node = Node(new_pos, parent=near, cost=new_cost)\n                near.add_child(new_node)\n                tree_a.append(new_node)\n                edges.append((near,new_node))\n\n                rewire(tree_a, new_node)\n\n                near_to_new = nearest(tree_b, new_pos)\n                dist_trees = distance(new_pos, near_to_new.position)\n                if dist_trees <= self.step_size*2 and not is_edge_collision(new_pos, near_to_new.position):\n                    connect_node = Node(near_to_new.position, parent=new_node, cost=new_node.cost + dist_trees)\n                    new_node.add_child(connect_node)\n                    tree_b.append(connect_node)\n                    edges.append((new_node, connect_node))\n                    path = extract_path(connect_node, connect_node)\n                    # extract_path from new_node to nearest node in other tree\n                    path = extract_path(new_node, near_to_new)\n                    path = shortcut_path(path)\n                    cost_path = 0.0\n                    for k in range(len(path)-1):\n                        cost_path += distance(path[k], path[k+1])\n                    if cost_path < best_cost:\n                        best_cost = cost_path\n                        best_path = path\n            if best_path:\n                return PlannerResult(True, best_path, start_tree+goal_tree, edges)\n        return PlannerResult(False, [], start_tree+goal_tree, edges)",
    "objective": -24.54042,
    "time_improvement": 22.0,
    "length_improvement": 15.0,
    "smoothness_improvement": 1806.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.019874000549316408,
            "num_nodes_avg": 86.7,
            "path_length_avg": 165.53372291805212,
            "smoothness_avg": 0.05590834490258338,
            "success_improvement": 0.0,
            "time_improvement": 24.29764885485091,
            "length_improvement": 9.26834341891934,
            "smoothness_improvement": 775.0870046395709,
            "objective_score": 16.725735731004733
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.017957305908203124,
            "num_nodes_avg": 144.4,
            "path_length_avg": 240.5533294992943,
            "smoothness_avg": 0.12055312154964279,
            "success_improvement": 0.0,
            "time_improvement": 89.12601287090475,
            "length_improvement": 19.696374669454404,
            "smoothness_improvement": 3001.9186483760295,
            "objective_score": 53.56522190482421
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.07342400550842285,
            "num_nodes_avg": 284.9,
            "path_length_avg": 128.16200978596154,
            "smoothness_avg": 0.13688525836651863,
            "success_improvement": 0.0,
            "time_improvement": -46.01362832932536,
            "length_improvement": 14.88089551925333,
            "smoothness_improvement": 1641.1703826033552,
            "objective_score": 3.3303007257711688
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m3",
    "algorithm_description": "A hybrid bidirectional RRT* variant with adaptive informed sampling and efficient rewiring, integrating a streamlined extension and connection strategy. It alternates growth between two trees using dynamically computed neighbor radius based on node density, applies local rewiring to improve paths incrementally, and finishes with a simple path shortcutting to reduce length and enhance smoothness while respecting collision and boundary constraints. Early stopping is triggered by time and improvement stagnation, balancing solution quality and efficiency.",
    "planning_mechanism": "The planner grows two trees from start and goal alternately, sampling informed points within the current best path ellipse or the whole space initially. Each iteration attempts to extend and rewire the growing tree nodes with dynamically adjusted neighborhood radius. Then it tries to connect to the opposite tree by the shortest connection within radius. When a better path is found, it triggers post-processing via shortcutting. The search ends if time expires or no improvements occur over a threshold, returning the best collision-free, smoothed path found.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=3.0, search_factor=50.0, time_limit=10.0, max_no_improve=150):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.search_factor = search_factor\n        self.time_limit = time_limit\n        self.max_no_improve = max_no_improve\n\n    def plan(self, map):\n        import math\n        import random\n        import time\n\n        bounds = map.size\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(frm, to):\n            d = dist(frm, to)\n            if d <= self.step_size:\n                return to\n            r = self.step_size / d\n            return tuple(frm[i] + r * (to[i] - frm[i]) for i in range(dim))\n\n        def in_obstacle(p):\n            if is_3d:\n                px, py, pz = p\n                for ox, oy, oz, ow, oh, od in obstacles:\n                    if ox <= px <= ox + ow and oy <= py <= oy + oh and oz <= pz <= oz + od:\n                        return True\n            else:\n                px, py = p\n                for ox, oy, ow, oh in obstacles:\n                    if ox <= px <= ox + ow and oy <= py <= oy + oh:\n                        return True\n            return False\n\n        def edge_collision(f, t, res=0.2):\n            length = dist(f, t)\n            steps = max(1, int(length / res))\n            for i in range(steps + 1):\n                pt = tuple(f[d] + (t[d] - f[d]) * (i / steps) for d in range(dim))\n                if in_obstacle(pt):\n                    return True\n            return False\n\n        start_node = Node(start, cost=0.0)\n        goal_node = Node(goal, cost=0.0)\n        tree_start = [start_node]\n        tree_goal = [goal_node]\n        all_nodes = [start_node, goal_node]\n        all_edges = []\n\n        c_min = dist(start, goal)\n        c_best = float('inf')\n        center = tuple((start[i] + goal[i]) * 0.5 for i in range(dim))\n        unit_vec = tuple((goal[i] - start[i]) / c_min if c_min > 0 else 1.0 for i in range(dim))\n\n        def sample_informed():\n            if c_best == float('inf'):\n                while True:\n                    pt = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                    if not in_obstacle(pt):\n                        return pt\n            while True:\n                # Sample in unit ball\n                while True:\n                    u = [random.uniform(-1,1) for _ in range(dim)]\n                    norm = math.sqrt(sum(x*x for x in u))\n                    if 0 < norm <= 1:\n                        break\n                r1 = c_best * 0.5\n                r_rest = math.sqrt(max(c_best*c_best - c_min*c_min, 0)) * 0.5\n                if dim == 2:\n                    ux, uy = unit_vec\n                    x, y = u[0]*r1, u[1]*r_rest\n                    rx = ux * x - uy * y + center[0]\n                    ry = uy * x + ux * y + center[1]\n                    candidate = (rx, ry)\n                elif dim == 3:\n                    uvec = unit_vec\n                    if abs(uvec[0]) < 0.9:\n                        v = (-uvec[1], uvec[0], 0.0)\n                    else:\n                        v = (0.0, -uvec[2], uvec[1])\n                    norm_v = math.sqrt(sum(x*x for x in v))\n                    v = tuple(x / norm_v for x in v)\n                    w = (uvec[1]*v[2]-uvec[2]*v[1], uvec[2]*v[0]-uvec[0]*v[2], uvec[0]*v[1]-uvec[1]*v[0])\n                    x = u[0] * r1\n                    y = u[1] * r_rest\n                    z = u[2] * r_rest\n                    rx = uvec[0]*x + v[0]*y + w[0]*z + center[0]\n                    ry = uvec[1]*x + v[1]*y + w[1]*z + center[1]\n                    rz = uvec[2]*x + v[2]*y + w[2]*z + center[2]\n                    candidate = (rx, ry, rz)\n                else:\n                    candidate = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if all(0 <= candidate[i] <= bounds[i] for i in range(dim)) and not in_obstacle(candidate):\n                    return candidate\n\n        def neighbor_radius(n_nodes):\n            val = self.search_factor * (math.log(n_nodes+1)/(n_nodes+1))**(1/dim)\n            return min(val, self.step_size*20.0)\n\n        def near_nodes(tree, pos, radius):\n            return [nd for nd in tree if dist(nd.position, pos) <= radius]\n\n        def update_costs(node):\n            for c in node.children:\n                new_cost = node.cost + dist(node.position, c.position)\n                if c.cost > new_cost:\n                    c.cost = new_cost\n                    update_costs(c)\n\n        def add_node(tree, new_pos, parent):\n            cost = parent.cost + dist(parent.position, new_pos)\n            new_node = Node(new_pos, parent, cost)\n            parent.children.append(new_node)\n            tree.append(new_node)\n            all_nodes.append(new_node)\n            all_edges.append((parent, new_node))\n            return new_node\n\n        def extend(tree, sample):\n            nearest_node = min(tree, key=lambda n: dist(n.position, sample))\n            new_pos = steer(nearest_node.position, sample)\n            if in_obstacle(new_pos) or edge_collision(nearest_node.position, new_pos):\n                return None\n            return add_node(tree, new_pos, nearest_node)\n\n        def rewire(tree, new_node):\n            r = neighbor_radius(len(tree))\n            neighbors = near_nodes(tree, new_node.position, r)\n            for nb in neighbors:\n                if nb is new_node.parent:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, nb.position)\n                if new_cost + 1e-12 < nb.cost and not edge_collision(new_node.position, nb.position):\n                    old_parent = nb.parent\n                    if old_parent:\n                        try:\n                            old_parent.children.remove(nb)\n                        except ValueError:\n                            pass\n                    nb.parent = new_node\n                    nb.cost = new_cost\n                    new_node.children.append(nb)\n                    update_costs(nb)\n\n        def connect_trees(node, other_tree):\n            r = neighbor_radius(len(other_tree))\n            candidates = near_nodes(other_tree, node.position, r)\n            best_node = None\n            best_cost = float('inf')\n            for cand in candidates:\n                if not edge_collision(node.position, cand.position):\n                    total_cost = node.cost + dist(node.position, cand.position) + cand.cost\n                    if total_cost < best_cost:\n                        best_cost = total_cost\n                        best_node = cand\n            return best_node, best_cost if best_node is not None else (None, None)\n\n        def extract_path(n1, n2):\n            path_start = []\n            cur = n1\n            while cur:\n                path_start.append(cur.position)\n                cur = cur.parent\n            path_start.reverse()\n            path_goal = []\n            cur = n2\n            while cur:\n                path_goal.append(cur.position)\n                cur = cur.parent\n            return path_start + path_goal\n\n        def shortcut(path, max_trials=100):\n            if len(path) < 3:\n                return path\n            shortened = path[:]\n            for _ in range(max_trials):\n                if len(shortened) < 3:\n                    break\n                i = random.randint(0, len(shortened)-3)\n                j = random.randint(i+2, len(shortened)-1)\n                if not edge_collision(shortened[i], shortened[j]):\n                    shortened = shortened[:i+1] + shortened[j:]\n            return shortened\n\n        start_time = time.time()\n        best_path = None\n        best_cost = float('inf')\n        last_improve = 0\n\n        for it in range(self.max_iter):\n            if time.time() - start_time > self.time_limit:\n                break\n\n            sample = sample_informed()\n            grow_start = (it % 2 == 0)\n            if grow_start:\n                new_node = extend(tree_start, sample)\n                tree_grow, tree_other = tree_start, tree_goal\n            else:\n                new_node = extend(tree_goal, sample)\n                tree_grow, tree_other = tree_goal, tree_start\n            if new_node is None:\n                continue\n            rewire(tree_grow, new_node)\n            connection_node, connection_cost = connect_trees(new_node, tree_other)\n            if connection_node is not None and connection_cost < best_cost:\n                best_cost = connection_cost\n                if grow_start:\n                    path = extract_path(new_node, connection_node)\n                else:\n                    path = extract_path(connection_node, new_node)\n                best_path = shortcut(path)\n                c_best = best_cost\n                last_improve = it\n            if best_path is not None and (it - last_improve) > self.max_no_improve:\n                break\n\n        success = best_path is not None\n        return PlannerResult(success, best_path if success else [], all_nodes, all_edges)",
    "objective": 83.44772,
    "time_improvement": -339.0,
    "length_improvement": 19.0,
    "smoothness_improvement": 1381.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.2206017255783081,
            "num_nodes_avg": 375.3,
            "path_length_avg": 156.75230320140025,
            "smoothness_avg": 0.03674676591450731,
            "success_improvement": 0.0,
            "time_improvement": -740.2973146505884,
            "length_improvement": 14.081578716116288,
            "smoothness_improvement": 475.1666834414161,
            "objective_score": -211.26441374829966
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.2013427734375,
            "num_nodes_avg": 595.9,
            "path_length_avg": 232.2207569467298,
            "smoothness_avg": 0.1001150942298877,
            "success_improvement": 0.0,
            "time_improvement": -21.922449730923745,
            "length_improvement": 22.47802722730308,
            "smoothness_improvement": 2476.0334845226766,
            "objective_score": 19.290248839718107
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.1783754587173462,
            "num_nodes_avg": 563.8,
            "path_length_avg": 120.22787357119338,
            "smoothness_avg": 0.10154046803092032,
            "success_improvement": 0.0,
            "time_improvement": -254.72387745503374,
            "length_improvement": 20.150371010135512,
            "smoothness_improvement": 1191.5872584155884,
            "objective_score": -58.36900433835086
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m3",
    "algorithm_description": "A simplified bidirectional RRT* inspired planner that alternates growing trees from start and goal by sampling collision-free points, extends toward samples with fixed step size, and rewires local neighbors to improve path cost dynamically. It attempts connecting the trees at each iteration, returning the combined path upon success. This approach balances planning efficiency, path quality, and smoothness through incremental rewiring and early collision checks.",
    "planning_mechanism": "The planner operates by sampling points within bounds avoiding obstacles, nearest neighbor extension with fixed step, rewiring neighbors within a computed radius to optimize cost, and alternating tree expansion. Once the two trees connect, their paths are concatenated to form the final solution.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=4000, step_size=5.0, gamma_rrt_star=30.0, max_radius=40.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.gamma_rrt_star = gamma_rrt_star\n        self.max_radius = max_radius\n\n    def plan(self, map):\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        for i in range(self.max_iter):\n            tree_a, tree_b = (tree_start, tree_goal) if i % 2 == 0 else (tree_goal, tree_start)\n            sample = self._sample_free(bounds, obstacles, is_3d)\n\n            new_node = self._extend_and_rewire(tree_a, sample, obstacles, is_3d, nodes, edges, bounds)\n            if new_node is None:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            connect_node = self._connect_and_rewire(tree_b, new_node, obstacles, is_3d, nodes, edges, bounds)\n            if connect_node:\n                path_a = new_node.path_from_root()\n                path_b = connect_node.path_from_root()\n                if path_a[-1] == path_b[-1]:\n                    path_b = path_b[:-1]\n                full_path = path_a + path_b[::-1]\n                return PlannerResult(True, full_path, nodes, edges)\n\n            tree_a, tree_b = tree_b, tree_a\n\n        return PlannerResult(False, [], nodes, edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        import random\n        dim = len(bounds)\n        while True:\n            pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            if not self._in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def _nearest(self, tree, point):\n        best = None\n        best_dist = float('inf')\n        for node in tree:\n            dist = self._dist(node.position, point)\n            if dist < best_dist:\n                best_dist = dist\n                best = node\n        return best\n\n    def _steer(self, from_pos, to_pos):\n        dist = self._dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(len(from_pos)))\n\n    def _near_nodes(self, tree, position, bounds):\n        n = max(1, len(tree))\n        d = len(position)\n        scale = max(1.0, sum(bounds) / d)\n        r_theory = self.gamma_rrt_star * ((math.log(n + 1) / (n + 1)) ** (1.0 / d))\n        radius = max(self.step_size * 2, min(self.max_radius, r_theory * 0.5 + scale * 0.02))\n        return [node for node in tree if self._dist(node.position, position) <= radius]\n\n    def _extend_and_rewire(self, tree, sample, obstacles, is_3d, nodes, edges, bounds):\n        nearest = self._nearest(tree, sample)\n        new_pos = self._steer(nearest.position, sample)\n        if self._in_obstacle(new_pos, obstacles, is_3d):\n            return None\n        if self._edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n            return None\n\n        neighbors = self._near_nodes(tree, new_pos, bounds)\n        min_cost = nearest.cost + self._dist(nearest.position, new_pos)\n        best_parent = nearest\n        for nb in neighbors:\n            if not self._edge_in_obstacle(nb.position, new_pos, obstacles, is_3d):\n                cost = nb.cost + self._dist(nb.position, new_pos)\n                if cost < min_cost:\n                    min_cost = cost\n                    best_parent = nb\n\n        new_node = Node(new_pos, cost=min_cost)\n        best_parent.add_child(new_node)\n        new_node.cost = min_cost\n        tree.append(new_node)\n        nodes.append(new_node)\n        edges.append((best_parent, new_node))\n\n        for nb in neighbors:\n            if nb == best_parent:\n                continue\n            if not self._edge_in_obstacle(new_node.position, nb.position, obstacles, is_3d):\n                updated_cost = new_node.cost + self._dist(new_node.position, nb.position)\n                if updated_cost < nb.cost:\n                    if nb.parent:\n                        try:\n                            edges.remove((nb.parent, nb))\n                        except ValueError:\n                            pass\n                        if nb in nb.parent.children:\n                            nb.parent.children.remove(nb)\n                    new_node.add_child(nb)\n                    nb.cost = updated_cost\n                    edges.append((new_node, nb))\n        return new_node\n\n    def _connect_and_rewire(self, tree, target_node, obstacles, is_3d, nodes, edges, bounds):\n        nearest = self._nearest(tree, target_node.position)\n        while True:\n            new_pos = self._steer(nearest.position, target_node.position)\n            if self._in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                return None\n\n            neighbors = self._near_nodes(tree, new_pos, bounds)\n            min_cost = nearest.cost + self._dist(nearest.position, new_pos)\n            best_parent = nearest\n            for nb in neighbors:\n                if not self._edge_in_obstacle(nb.position, new_pos, obstacles, is_3d):\n                    cost = nb.cost + self._dist(nb.position, new_pos)\n                    if cost < min_cost:\n                        min_cost = cost\n                        best_parent = nb\n\n            new_node = Node(new_pos, cost=min_cost)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            for nb in neighbors:\n                if nb == best_parent:\n                    continue\n                if not self._edge_in_obstacle(new_node.position, nb.position, obstacles, is_3d):\n                    updated_cost = new_node.cost + self._dist(new_node.position, nb.position)\n                    if updated_cost < nb.cost:\n                        if nb.parent:\n                            try:\n                                edges.remove((nb.parent, nb))\n                            except ValueError:\n                                pass\n                            if nb in nb.parent.children:\n                                nb.parent.children.remove(nb)\n                        new_node.add_child(nb)\n                        nb.cost = updated_cost\n                        edges.append((new_node, nb))\n\n            if self._dist(new_node.position, target_node.position) <= self.step_size:\n                if (not self._edge_in_obstacle(new_node.position, target_node.position, obstacles, is_3d)\n                   and not self._in_obstacle(target_node.position, obstacles, is_3d)):\n                    final_node = Node(target_node.position, cost=new_node.cost + self._dist(new_node.position, target_node.position))\n                    new_node.add_child(final_node)\n                    tree.append(final_node)\n                    nodes.append(final_node)\n                    edges.append((new_node, final_node))\n                    return final_node\n                else:\n                    return None\n            nearest = new_node\n\n    def _in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _edge_in_obstacle(self, p1, p2, obstacles, is_3d, resolution=1.0):\n        dist = self._dist(p1, p2)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(p1[d] + (p2[d] - p1[d]) * i / steps for d in range(len(p1)))\n            if self._in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _dist(self, a, b):\n        s = 0\n        for i in range(len(a)):\n            s += (a[i] - b[i]) ** 2\n        return s ** 0.5",
    "objective": -23.86958,
    "time_improvement": 56.0,
    "length_improvement": 11.0,
    "smoothness_improvement": 157.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.010033559799194337,
            "num_nodes_avg": 60.9,
            "path_length_avg": 164.20093510394682,
            "smoothness_avg": 0.01583828018408221,
            "success_improvement": 0.0,
            "time_improvement": 61.78101810606081,
            "length_improvement": 9.99886553920486,
            "smoothness_improvement": 147.90347825679143,
            "objective_score": 25.273142146625116
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.050237512588500975,
            "num_nodes_avg": 241.6,
            "path_length_avg": 264.8016597340139,
            "smoothness_avg": 0.010300759767330584,
            "success_improvement": 0.0,
            "time_improvement": 69.57884060795715,
            "length_improvement": 11.601584087618049,
            "smoothness_improvement": 165.04596815078446,
            "objective_score": 28.659832475711898
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.0325772762298584,
            "num_nodes_avg": 182.9,
            "path_length_avg": 134.71639352764254,
            "smoothness_avg": 0.020352271921149336,
            "success_improvement": 0.0,
            "time_improvement": 35.21565228605458,
            "length_improvement": 10.527785924243197,
            "smoothness_improvement": 158.87939658857192,
            "objective_score": 17.67576422330515
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "e2",
    "algorithm_description": "A hybrid bidirectional RRT* planner with adaptive informed sampling, dynamic rewiring with efficient cost propagation, KD-tree motivated nearest neighbor pruning, and incremental incremental shortcut smoothing during planning to improve efficiency, path quality, robustness, success rate, smoothness, and reduce search time. The algorithm dynamically focuses sampling inside the current best ellipsoidal informed subset, rewires with cost propagation to descendants to improve path optimality, prunes neighbors based on an adaptive radius with naive acceleration for efficiency, and performs incremental smoothing after each new best path update to improve overall smoothness and reduce path length progressively.",
    "planning_mechanism": "The planner grows two RRT* trees simultaneously from start and goal positions. It samples points initially uniformly and switches to ellipsoidal informed sampling after finding a feasible solution. Each new node addition chooses the best parent from neighbors within an adaptive radius and rewires neighbors with a full descendants cost update to maintain path optimality. The trees attempt to connect at every iteration for early termination. Upon improvement in path cost, incremental shortcut smoothing runs to reduce path length and smooth path angles, improving path quality progressively during planning rather than only post-processing. This approach balances exploration and exploitation, accelerates convergence, and returns higher-quality, smoother paths with reduced runtime.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self,\n                 max_iter=5000,\n                 step_size=4.0,\n                 neighbor_factor=40.0,\n                 max_neighbor_radius=None,\n                 time_limit_sec=20.0,\n                 smooth_trials_increment=60,\n                 max_no_improve=200,\n                 improve_tol=1e-6):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.neighbor_factor = neighbor_factor\n        self.max_neighbor_radius = max_neighbor_radius\n        self.time_limit_sec = time_limit_sec\n        self.smooth_trials_increment = smooth_trials_increment\n        self.max_no_improve = max_no_improve\n        self.improve_tol = improve_tol\n\n    def plan(self, map):\n        import time\n        import math\n        import random\n\n        bounds = map.size\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        obstacles = map.obstacles\n        start_pos = map.start\n        goal_pos = map.goal\n\n        def within_bounds(p):\n            for d in range(dim):\n                if p[d] < 0.0 or p[d] > bounds[d]:\n                    return False\n            return True\n\n        def dist(a, b):\n            s = 0.0\n            for i in range(dim):\n                diff = a[i] - b[i]\n                s += diff * diff\n            return math.sqrt(s)\n\n        def steer(from_p, to_p):\n            d = dist(from_p, to_p)\n            if d <= self.step_size:\n                return to_p\n            r = self.step_size / d\n            return tuple(from_p[i] + r * (to_p[i] - from_p[i]) for i in range(dim))\n\n        def in_obstacle(pos):\n            if is_3d:\n                px, py, pz = pos\n                for obs in obstacles:\n                    x, y, z, w, h, d = obs\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n            else:\n                px, py = pos\n                for obs in obstacles:\n                    x, y, w, h = obs\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def edge_collision_free(p1, p2):\n            seg_dist = dist(p1, p2)\n            steps = max(2, int(seg_dist / 1.0))\n            for i in range(steps + 1):\n                interm = tuple(p1[d] + (p2[d] - p1[d]) * i / steps for d in range(dim))\n                if in_obstacle(interm):\n                    return False\n            return True\n\n        def neighbor_radius(num_nodes):\n            if self.max_neighbor_radius is not None:\n                maxr = self.max_neighbor_radius\n            else:\n                maxr = max(bounds) * 0.25\n            if num_nodes < 2:\n                return self.step_size * 2.0\n            return max(self.step_size * 2.0,\n                       min(maxr,\n                           self.neighbor_factor * ((math.log(num_nodes) / num_nodes) ** (1.0 / dim))))\n\n        def nearest(tree, point):\n            best_node = None\n            best_dist = float('inf')\n            for n in tree:\n                d = dist(n.position, point)\n                if d < best_dist:\n                    best_dist = d\n                    best_node = n\n            return best_node\n\n        def near_nodes(tree, pos, radius):\n            radius_sq = radius * radius\n            result = []\n            for n in tree:\n                d_sq = 0.0\n                for i in range(dim):\n                    diff = n.position[i] - pos[i]\n                    d_sq += diff * diff\n                    if d_sq > radius_sq:\n                        break\n                if d_sq <= radius_sq:\n                    result.append(n)\n            return result\n\n        def informed_sample(start, goal, c_best, c_min):\n            if c_best == float('inf') or c_min < 1e-12:\n                # Uniform sample\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            r1 = c_best / 2.0\n            r_orth_sq = max(c_best * c_best - c_min * c_min, 0.0)\n            r_orth = math.sqrt(r_orth_sq) / 2.0\n            center = tuple((start[d] + goal[d]) / 2.0 for d in range(dim))\n            a1 = tuple((goal[d] - start[d]) / c_min for d in range(dim))\n\n            def sample_unit_ball(k):\n                while True:\n                    v = [random.gauss(0, 1) for _ in range(k)]\n                    norm_v = math.sqrt(sum(x * x for x in v))\n                    if norm_v > 1e-12:\n                        v = [x / norm_v for x in v]\n                        r = random.random() ** (1.0 / k)\n                        return tuple(v[i] * r for i in range(k))\n\n            u = sample_unit_ball(dim)\n\n            if dim == 2:\n                a2 = (-a1[1], a1[0])\n                basis = (a1, a2)\n                radii = (r1, r_orth)\n            else:\n                ref = (1.0, 0.0, 0.0) if abs(a1[0]) < 0.9 else (0.0, 1.0, 0.0)\n                b2 = self._normalize(self._cross(a1, ref))\n                if self._norm(b2) < 1e-12:\n                    ref = (0.0, 0.0, 1.0)\n                    b2 = self._normalize(self._cross(a1, ref))\n                b3 = self._cross(a1, b2)\n                basis = (a1, b2, b3)\n                radii = (r1, r_orth, r_orth)\n\n            sample = [0]*dim\n            for d in range(dim):\n                val = center[d]\n                for i in range(dim):\n                    val += basis[i][d] * radii[i] * u[i]\n                val = max(0.0, min(bounds[d], val))\n                sample[d] = val\n            return tuple(sample)\n\n        def cost_descendants_update(node):\n            # Recursively update costs of children since rewiring changes cost\n            stack = [(node, node.cost)]\n            while stack:\n                curr, base_cost = stack.pop()\n                for child in curr.children:\n                    new_cost = base_cost + dist(curr.position, child.position)\n                    if abs(child.cost - new_cost) > 1e-12:\n                        child.cost = new_cost\n                        stack.append((child, new_cost))\n\n        def add_node(tree, pos, nodes_all, edges_all):\n            r = neighbor_radius(len(tree))\n            neighbors = near_nodes(tree, pos, r)\n            candidate_parents = []\n            for nb in neighbors:\n                if edge_collision_free(nb.position, pos):\n                    candidate_parents.append(nb)\n            if not candidate_parents:\n                n_near = nearest(tree, pos)\n                if edge_collision_free(n_near.position, pos):\n                    parent = n_near\n                else:\n                    return None, []\n            else:\n                parent = min(candidate_parents, key=lambda n: n.cost + dist(n.position, pos))\n            new_cost = parent.cost + dist(parent.position, pos)\n            new_node = Node(pos, parent=None, cost=new_cost)\n            parent.add_child(new_node)\n            tree.append(new_node)\n            nodes_all.append(new_node)\n            edges_all.append((parent, new_node))\n\n            # Rewire neighbors with cost propagation\n            for nb in neighbors:\n                if nb is new_node or nb is parent:\n                    continue\n                if edge_collision_free(new_node.position, nb.position):\n                    new_cost_nb = new_node.cost + dist(new_node.position, nb.position)\n                    if new_cost_nb + 1e-12 < nb.cost:\n                        # Reconnect nb to new_node\n                        if nb.parent:\n                            try:\n                                edges_all.remove((nb.parent, nb))\n                            except ValueError:\n                                pass\n                            nb.parent.remove_child(nb)\n                        new_node.add_child(nb)\n                        nb.cost = new_cost_nb\n                        edges_all.append((new_node, nb))\n                        cost_descendants_update(nb)\n            return new_node, neighbors\n\n        def try_connect_trees(new_node, other_tree):\n            near_other = nearest(other_tree, new_node.position)\n            if dist(new_node.position, near_other.position) <= self.step_size and edge_collision_free(new_node.position, near_other.position):\n                return new_node, near_other\n            # Attempt incremental steering from other_tree to new_node.position\n            curr = near_other\n            while True:\n                next_pos = steer(curr.position, new_node.position)\n                if not within_bounds(next_pos) or in_obstacle(next_pos):\n                    break\n                if not edge_collision_free(curr.position, next_pos):\n                    break\n                next_node, _ = add_node(other_tree, next_pos, nodes, edges)\n                if next_node is None:\n                    break\n                curr = next_node\n                if dist(curr.position, new_node.position) <= self.step_size and edge_collision_free(curr.position, new_node.position):\n                    return new_node, curr\n            return None, None\n\n        def stitch_paths(n1, n2):\n            path1 = n1.path_from_root()\n            path2 = n2.path_from_root()\n            # Remove duplicated meeting node if any\n            if path1 and path2 and path1[-1] == path2[-1]:\n                full_path = path1 + path2[-2::-1]\n            else:\n                full_path = path1 + path2[::-1]\n            return full_path\n\n        def path_cost(path):\n            total = 0.0\n            for i in range(len(path)-1):\n                total += dist(path[i], path[i+1])\n            return total\n\n        def incremental_smooth(path, trials):\n            if len(path) < 3:\n                return path\n            smooth_path = path[:]\n            for _ in range(trials):\n                if len(smooth_path) < 3:\n                    break\n                i = random.randint(0, len(smooth_path) - 3)\n                j = random.randint(i + 2, len(smooth_path) - 1)\n                if edge_collision_free(smooth_path[i], smooth_path[j]):\n                    smooth_path = smooth_path[:i + 1] + smooth_path[j:]\n            return smooth_path\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        c_min = dist(start_pos, goal_pos)\n        best_cost = float('inf')\n        best_path = []\n        found_solution = False\n        no_improve = 0\n        smooth_trials = self.smooth_trials_increment\n\n        start_time = time.time()\n\n        iteration = 0\n        while iteration < self.max_iter:\n            if time.time() - start_time > self.time_limit_sec:\n                break\n\n            # Alternate tree expansion\n            if iteration % 2 == 0:\n                tree_grow, tree_other = tree_start, tree_goal\n            else:\n                tree_grow, tree_other = tree_goal, tree_start\n\n            sample = (informed_sample(start_pos, goal_pos, best_cost, c_min)\n                      if found_solution else\n                      tuple(random.uniform(0.0, bounds[d]) for d in range(dim)))\n\n            if not within_bounds(sample) or in_obstacle(sample):\n                iteration += 1\n                if found_solution:\n                    no_improve += 1\n                    if no_improve > self.max_no_improve:\n                        break\n                continue\n\n            nearest_node = nearest(tree_grow, sample)\n            new_pos = steer(nearest_node.position, sample)\n            if not within_bounds(new_pos) or in_obstacle(new_pos):\n                iteration += 1\n                if found_solution:\n                    no_improve += 1\n                    if no_improve > self.max_no_improve:\n                        break\n                continue\n            if not edge_collision_free(nearest_node.position, new_pos):\n                iteration += 1\n                if found_solution:\n                    no_improve += 1\n                    if no_improve > self.max_no_improve:\n                        break\n                continue\n\n            new_node, neighbors = add_node(tree_grow, new_pos, nodes, edges)\n            if new_node is None:\n                iteration += 1\n                if found_solution:\n                    no_improve += 1\n                    if no_improve > self.max_no_improve:\n                        break\n                continue\n\n            # Attempt connection between trees\n            connect_nodes = try_connect_trees(new_node, tree_other)\n            if connect_nodes[0] is not None and connect_nodes[1] is not None:\n                n1, n2 = connect_nodes\n                candidate_path = stitch_paths(n1, n2)\n                candidate_cost = path_cost(candidate_path)\n                if candidate_cost + self.improve_tol < best_cost:\n                    best_cost = candidate_cost\n                    best_path = candidate_path\n                    found_solution = True\n                    no_improve = 0\n                    # Incremental smoothing of current best path\n                    best_path = incremental_smooth(best_path, smooth_trials)\n                    smooth_trials += self.smooth_trials_increment\n                else:\n                    if found_solution:\n                        no_improve += 1\n                        if no_improve > self.max_no_improve:\n                            break\n            else:\n                if found_solution:\n                    no_improve += 1\n                    if no_improve > self.max_no_improve:\n                        break\n\n            iteration += 1\n\n        if found_solution:\n            return PlannerResult(\n                success=True,\n                path=best_path,\n                nodes=nodes,\n                edges=edges\n            )\n        else:\n            return PlannerResult(\n                success=False,\n                path=[],\n                nodes=nodes,\n                edges=edges\n            )\n\n    # Vector math helpers for informed sampling\n    def _cross(self, a, b):\n        ax, ay, az = a if len(a) == 3 else (a[0], a[1], 0.0)\n        bx, by, bz = b if len(b) == 3 else (b[0], b[1], 0.0)\n        return (ay * bz - az * by, az * bx - ax * bz, ax * by - ay * bx)\n\n    def _norm(self, v):\n        s = 0.0\n        for x in v:\n            s += x * x\n        return s ** 0.5\n\n    def _normalize(self, v):\n        n = self._norm(v)\n        if n < 1e-12:\n            return v\n        return tuple(x / n for x in v)",
    "objective": 96.54181,
    "time_improvement": -384.0,
    "length_improvement": 21.0,
    "smoothness_improvement": 1246.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.10597767829895019,
            "num_nodes_avg": 269.3,
            "path_length_avg": 151.79808026004864,
            "smoothness_avg": 0.0406356862965908,
            "success_improvement": 0.0,
            "time_improvement": -303.68115097041834,
            "length_improvement": 16.797066814957358,
            "smoothness_improvement": 536.0367323467981,
            "objective_score": -78.3459215404171
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.12645435333251953,
            "num_nodes_avg": 508.4,
            "path_length_avg": 231.86640810933136,
            "smoothness_avg": 0.08810328541488317,
            "success_improvement": 0.0,
            "time_improvement": 23.425985078990397,
            "length_improvement": 22.596319068592447,
            "smoothness_improvement": 2166.9609919564273,
            "objective_score": 31.420391924634725
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.48881847858428956,
            "num_nodes_avg": 748.5,
            "path_length_avg": 116.07428278021807,
            "smoothness_avg": 0.08929813830540603,
            "success_improvement": 0.0,
            "time_improvement": -872.0820753142518,
            "length_improvement": 22.908988240762167,
            "smoothness_improvement": 1035.8657279418298,
            "objective_score": -242.69990101010907
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "path_expert",
    "algorithm_description": "A bidirectional RRT* planner with adaptive neighborhood radius, efficient rewiring with downstream cost propagation, and elliptical informed sampling prioritizing promising areas after initial solution. The algorithm implements incremental tree growth with dynamic best parent selection and deep rewiring for improved path quality and smoothness. Path shortcutting with adaptive batch attempts further refines path smoothness and length before output.",
    "planning_mechanism": "The planner grows start and goal trees alternately using RRT* expansion with adaptive neighborhood radius based on node count and space dimension. Each new node chooses the best parent minimizing cost while ensuring collision-free connection. After node addition, rewiring considers neighbors for cost improvements, updating downstream nodes to propagate cost changes efficiently. When the two trees connect, an initial path is formed and path cost bounds allow informed elliptical sampling to focus subsequent expansions near the current best path. Incremental replanning with early stopping and repeated targeted shortcutting gradually improves path length and smoothness.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        path.reverse()\n        return path\n\n    def update_cost(self, new_cost):\n        diff = new_cost - self.cost\n        if abs(diff) < 1e-15:\n            return\n        self.cost = new_cost\n        for c in self.children:\n            c.update_cost(c.cost + diff)\nclass Planner:\n    def __init__(self,\n                 max_iter=6000,\n                 step_size=4.0,\n                 post_opt_iters=800,\n                 max_no_improve=120,\n                 improve_tol=1e-6,\n                 time_limit_sec=20.0,\n                 shortcutting_trials=200):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.post_opt_iters = post_opt_iters\n        self.max_no_improve = max_no_improve\n        self.improve_tol = improve_tol\n        self.time_limit_sec = time_limit_sec\n        self.shortcutting_trials = shortcutting_trials\n        self.gamma_rrt_star = 35.0\n        self.neighbor_radius_override = None\n\n    def plan(self, map):\n        bounds = map.size\n        dim = len(bounds)\n        obstacles = map.obstacles\n\n        start_pos = map.start\n        goal_pos = map.goal\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        best_cost = float('inf')\n        best_path = []\n        c_min = self._distance(start_pos, goal_pos)\n\n        found_solution = False\n        post_iter = 0\n        no_improve_count = 0\n\n        start_time = time.time()\n\n        def within_bounds(p):\n            return all(0.0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return self._distance(a, b)\n\n        def steer(from_p, to_p):\n            d = dist(from_p, to_p)\n            if d <= self.step_size:\n                return to_p\n            r = self.step_size / d\n            return tuple(from_p[i] + (to_p[i] - from_p[i]) * r for i in range(dim))\n\n        def neighbor_radius_fn(n_nodes):\n            if self.neighbor_radius_override is not None:\n                return self.neighbor_radius_override\n            if n_nodes < 2:\n                return self.step_size * 2.5\n            r_theory = self.gamma_rrt_star * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            maxr = max(bounds) * 0.25\n            return max(self.step_size * 2.2, min(r_theory, maxr))\n\n        def nearest(tree, pt):\n            best_node = None\n            best_dist = float('inf')\n            for n in tree:\n                d = dist(n.position, pt)\n                if d < best_dist:\n                    best_dist = d\n                    best_node = n\n            return best_node\n\n        def near_nodes(tree, pos, radius):\n            radius_sq = radius * radius\n            result = [n for n in tree if self._squared_distance(n.position, pos) <= radius_sq]\n            return result\n\n        def collision_free(pos):\n            return not self._is_in_obstacle(pos, obstacles, dim == 3)\n\n        def edge_collision_free(p1, p2):\n            seg_len = dist(p1, p2)\n            steps = max(3, int(seg_len / 0.75))\n            for i in range(steps + 1):\n                ip = tuple(p1[d] + (p2[d] - p1[d]) * (i / steps) for d in range(dim))\n                if self._is_in_obstacle(ip, obstacles, dim == 3):\n                    return False\n            return True\n\n        def add_node_rrtstar(tree, pos):\n            r = neighbor_radius_fn(len(tree))\n            neighbors = near_nodes(tree, pos, r)\n            valid_parents = []\n            for n in neighbors:\n                if edge_collision_free(n.position, pos):\n                    valid_parents.append(n)\n            if not valid_parents:\n                nearest_node = nearest(tree, pos)\n                if edge_collision_free(nearest_node.position, pos):\n                    parent = nearest_node\n                else:\n                    return None, []\n            else:\n                parent = min(valid_parents, key=lambda n: n.cost + dist(n.position, pos))\n            new_cost = parent.cost + dist(parent.position, pos)\n            new_node = Node(pos, parent=None, cost=new_cost)\n            parent.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((parent, new_node))\n            return new_node, neighbors\n\n        def rewire(node, neighbors):\n            for nb in neighbors:\n                if nb is node:\n                    continue\n                if not edge_collision_free(node.position, nb.position):\n                    continue\n                new_cost = node.cost + dist(node.position, nb.position)\n                if new_cost + 1e-15 < nb.cost:\n                    # reconnect neighbor via node\n                    if nb.parent:\n                        try:\n                            edges.remove((nb.parent, nb))\n                        except ValueError:\n                            pass\n                        nb.parent.remove_child(nb)\n                    node.add_child(nb)\n                    nb.update_cost(new_cost)\n                    edges.append((node, nb))\n\n        def propagate_cost_down(node):\n            for c in node.children:\n                expected_cost = node.cost + dist(node.position, c.position)\n                if expected_cost + 1e-15 < c.cost:\n                    c.update_cost(expected_cost)\n\n        def stitch_paths(n_start, n_goal):\n            path_s = n_start.path_from_root()\n            path_g = n_goal.path_from_root()\n            if path_s and path_g and path_s[-1] == path_g[-1]:\n                return path_s + path_g[-2::-1]\n            return path_s + path_g[::-1]\n\n        def path_cost(path):\n            c = 0.0\n            for i in range(len(path) -1):\n                c += dist(path[i], path[i+1])\n            return c\n\n        def informed_sample(start, goal, c_best, c_min):\n            if c_best == float(\"inf\") or c_min < 1e-12:\n                return tuple(random.uniform(0.0, bounds[d]) for d in range(dim))\n            r1 = c_best / 2.0\n            r_other_sq = max(c_best * c_best - c_min * c_min, 0.0)\n            r_other = math.sqrt(r_other_sq) / 2.0\n            center = tuple((start[d] + goal[d]) / 2.0 for d in range(dim))\n            a1 = tuple((goal[d] - start[d]) / c_min for d in range(dim))\n\n            def sample_unit_ball(k):\n                while True:\n                    v = [random.gauss(0,1) for _ in range(k)]\n                    norm_v = math.sqrt(sum(x*x for x in v))\n                    if norm_v > 1e-12:\n                        v = [x / norm_v for x in v]\n                        r = random.random() ** (1.0/k)\n                        return tuple(v[i]*r for i in range(k))\n\n            u = sample_unit_ball(dim)\n\n            if dim == 2:\n                a2 = (-a1[1], a1[0])\n                basis = (a1, a2)\n                radii = (r1, r_other)\n            else:\n                ref = (1.0, 0.0, 0.0) if abs(a1[0]) < 0.9 else (0.0, 1.0, 0.0)\n                b2 = self._normalize(self._cross(a1, ref))\n                if self._norm(b2) < 1e-12:\n                    ref = (0.0, 0.0, 1.0)\n                    b2 = self._normalize(self._cross(a1, ref))\n                b3 = self._cross(a1, b2)\n                basis = (a1, b2, b3)\n                radii = (r1, r_other, r_other)\n\n            sample = []\n            for d in range(dim):\n                val = center[d]\n                for i in range(dim):\n                    val += basis[i][d] * radii[i] * u[i]\n                val = max(0.0, min(bounds[d], val))\n                sample.append(val)\n            return tuple(sample)\n\n        def smooth_path(path, max_trials):\n            if len(path) < 3:\n                return path\n            new_path = path[:]\n            for _ in range(max_trials):\n                if len(new_path) < 3:\n                    break\n                i = random.randint(0, len(new_path) - 3)\n                j = random.randint(i + 2, len(new_path) - 1)\n                if edge_collision_free(new_path[i], new_path[j]):\n                    new_path = new_path[:i+1] + new_path[j:]\n            return new_path\n\n        def try_connect_trees(new_node, other_tree):\n            nearest_other = nearest(other_tree, new_node.position)\n            if dist(nearest_other.position, new_node.position) <= self.step_size:\n                if edge_collision_free(new_node.position, nearest_other.position):\n                    return new_node, nearest_other\n            curr = nearest_other\n            while True:\n                step_pos = steer(curr.position, new_node.position)\n                if not within_bounds(step_pos) or not collision_free(step_pos):\n                    break\n                if not edge_collision_free(curr.position, step_pos):\n                    break\n                new_other_node, _ = add_node_rrtstar(other_tree, step_pos)\n                if new_other_node is None:\n                    break\n                neighbors = near_nodes(other_tree, step_pos, neighbor_radius_fn(len(other_tree)))\n                rewire(new_other_node, neighbors)\n                curr = new_other_node\n                if dist(curr.position, new_node.position) <= self.step_size:\n                    if edge_collision_free(curr.position, new_node.position):\n                        return new_node, curr\n            return None, None\n\n        iteration = 0\n        while iteration < self.max_iter:\n            elapsed = time.time() - start_time\n            if elapsed > self.time_limit_sec:\n                break\n\n            grow_start = (iteration % 2 == 0)\n            grow_tree = start_tree if grow_start else goal_tree\n            other_tree = goal_tree if grow_start else start_tree\n\n            sample = informed_sample(start_pos, goal_pos, best_cost, c_min) if found_solution else tuple(random.uniform(0.0, bounds[d]) for d in range(dim))\n\n            if not within_bounds(sample) or not collision_free(sample):\n                if found_solution:\n                    no_improve_count += 1\n                    post_iter += 1\n                    if post_iter >= self.post_opt_iters or no_improve_count >= self.max_no_improve:\n                        break\n                iteration += 1\n                continue\n\n            nearest_node = nearest(grow_tree, sample)\n            new_pos = steer(nearest_node.position, sample)\n            if not within_bounds(new_pos) or not collision_free(new_pos):\n                if found_solution:\n                    no_improve_count += 1\n                    post_iter += 1\n                    if post_iter >= self.post_opt_iters or no_improve_count >= self.max_no_improve:\n                        break\n                iteration += 1\n                continue\n            if not edge_collision_free(nearest_node.position, new_pos):\n                if found_solution:\n                    no_improve_count += 1\n                    post_iter += 1\n                    if post_iter >= self.post_opt_iters or no_improve_count >= self.max_no_improve:\n                        break\n                iteration += 1\n                continue\n\n            new_node, neighbors = add_node_rrtstar(grow_tree, new_pos)\n            if new_node is None:\n                if found_solution:\n                    no_improve_count += 1\n                    post_iter += 1\n                    if post_iter >= self.post_opt_iters or no_improve_count >= self.max_no_improve:\n                        break\n                iteration += 1\n                continue\n\n            rewire(new_node, neighbors)\n\n            # Connect attempt\n            n1, n2 = try_connect_trees(new_node, other_tree)\n            if n1 and n2:\n                candidate_path = stitch_paths(n1, n2)\n                candidate_cost = path_cost(candidate_path)\n                if candidate_cost + self.improve_tol < best_cost:\n                    best_cost = candidate_cost\n                    best_path = candidate_path\n                    found_solution = True\n                    no_improve_count = 0\n                    post_iter = 0\n                else:\n                    if found_solution:\n                        no_improve_count += 1\n                        post_iter += 1\n\n                if found_solution and (post_iter >= self.post_opt_iters or no_improve_count >= self.max_no_improve):\n                    break\n            else:\n                if found_solution:\n                    no_improve_count += 1\n                    post_iter += 1\n                    if post_iter >= self.post_opt_iters or no_improve_count >= self.max_no_improve:\n                        break\n            iteration += 1\n\n        if found_solution and best_path:\n            smooth = best_path\n            batch_sz = max(30, self.shortcutting_trials // 4)\n            total_trials = 0\n            no_improve_consec = 0\n            for _ in range(self.shortcutting_trials):\n                prev_len = path_cost(smooth)\n                smooth = smooth_path(smooth, 1)\n                after_len = path_cost(smooth)\n                total_trials += 1\n                if prev_len - after_len < 1e-7:\n                    no_improve_consec += 1\n                    if no_improve_consec >= batch_sz:\n                        break\n                else:\n                    no_improve_consec = 0\n            return PlannerResult(\n                success=True,\n                path=smooth,\n                nodes=nodes,\n                edges=edges\n            )\n        return PlannerResult(\n            success=False,\n            path=[],\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _distance(self, a, b):\n        return math.dist(a, b)\n\n    def _squared_distance(self, a, b):\n        return sum((a[i] - b[i])**2 for i in range(len(a)))\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        if is_3d:\n            px, py, pz = pos\n            for x,y,z,w,h,d in obstacles:\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n        else:\n            px, py = pos\n            for x,y,w,h in obstacles:\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _cross(self, a, b):\n        ax, ay, az = a\n        bx, by, bz = b\n        return (ay*bz - az*by, az*bx - ax*bz, ax*by - ay*bx)\n\n    def _norm(self, v):\n        return math.sqrt(sum(x*x for x in v))\n\n    def _normalize(self, v):\n        n = self._norm(v)\n        if n < 1e-12:\n            return v\n        return tuple(x/n for x in v)",
    "objective": 92.61836,
    "time_improvement": -206.0,
    "length_improvement": 20.0,
    "smoothness_improvement": 1439.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 0.8,
            "time_avg": 0.07467050552368164,
            "num_nodes_avg": 199.3,
            "path_length_avg": 151.82256076365326,
            "smoothness_avg": 0.04430993745337036,
            "success_improvement": -19.999999999999996,
            "time_improvement": -184.42853341543133,
            "length_improvement": 16.783648663013263,
            "smoothness_improvement": 593.5467417144897,
            "objective_score": -142.29063711824898
        },
        {
            "map_id": 1,
            "success_rate": 0.9,
            "time_avg": 0.12324655055999756,
            "num_nodes_avg": 438.7,
            "path_length_avg": 237.2967022071949,
            "smoothness_avg": 0.10000056244622442,
            "success_improvement": -9.999999999999998,
            "time_improvement": 25.368459425609707,
            "length_improvement": 20.78353059637641,
            "smoothness_improvement": 2473.086499235111,
            "objective_score": -17.553911318315677
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.281064510345459,
            "num_nodes_avg": 497.6,
            "path_length_avg": 116.91033108550096,
            "smoothness_avg": 0.10625461966397531,
            "success_improvement": 0.0,
            "time_improvement": -458.9350331130852,
            "length_improvement": 22.353724764735432,
            "smoothness_improvement": 1251.55091922557,
            "objective_score": -118.01052047895644
        }
    ],
    "success_rate": 0.9
}
{
    "operator": "m2",
    "algorithm_description": "A hybrid bidirectional RRT* planner with adaptive ellipsoidal informed sampling, efficient rewiring with cost propagation, prioritized neighbor pruning using adaptive radius, and progressive incremental path smoothing dynamically applied after each path improvement. This approach balances global exploration and local exploitation to efficiently find high-quality, smooth, and short collision-free paths with lower search time and higher success rate.",
    "planning_mechanism": "The planner grows two RRT* trees simultaneously from start and goal. It samples points uniformly initially and switches to ellipsoidal informed sampling once a feasible path is found. Each new node is connected to the best parent within an adaptive neighborhood radius, rewiring neighbors to improve path cost with cost updates propagated recursively. The trees attempt connection every iteration, and upon finding better solutions, the best path is incrementally smoothed with increased smoothing window size, accelerating convergence toward smooth, efficient routes under given time constraints.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self,\n                 max_iter=5000,\n                 step_size=3.5,\n                 neighbor_factor=30.0,\n                 max_neighbor_radius=15.0,\n                 time_limit_sec=15.0,\n                 smooth_trials_increment=100,\n                 max_no_improve=150,\n                 improve_tol=1e-5):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.neighbor_factor = neighbor_factor\n        self.max_neighbor_radius = max_neighbor_radius\n        self.time_limit_sec = time_limit_sec\n        self.smooth_trials_increment = smooth_trials_increment\n        self.max_no_improve = max_no_improve\n        self.improve_tol = improve_tol\n\n    def plan(self, map):\n        import time\n        import math\n        import random\n\n        bounds = map.size\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        obstacles = map.obstacles\n        start_pos = map.start\n        goal_pos = map.goal\n\n        def within_bounds(p):\n            for d in range(dim):\n                if p[d] < 0.0 or p[d] > bounds[d]:\n                    return False\n            return True\n\n        def dist(a, b):\n            s = 0.0\n            for i in range(dim):\n                diff = a[i] - b[i]\n                s += diff * diff\n            return math.sqrt(s)\n\n        def steer(from_p, to_p):\n            d = dist(from_p, to_p)\n            if d <= self.step_size:\n                return to_p\n            r = self.step_size / d\n            return tuple(from_p[i] + r * (to_p[i] - from_p[i]) for i in range(dim))\n\n        def in_obstacle(pos):\n            if is_3d:\n                px, py, pz = pos\n                for obs in obstacles:\n                    x, y, z, w, h, d = obs\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n            else:\n                px, py = pos\n                for obs in obstacles:\n                    x, y, w, h = obs\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def edge_collision_free(p1, p2):\n            seg_dist = dist(p1, p2)\n            steps = max(3, int(seg_dist / 0.7))\n            for i in range(steps + 1):\n                interm = tuple(p1[d] + (p2[d] - p1[d]) * i / steps for d in range(dim))\n                if in_obstacle(interm):\n                    return False\n            return True\n\n        def neighbor_radius(num_nodes):\n            if self.max_neighbor_radius is not None:\n                maxr = self.max_neighbor_radius\n            else:\n                maxr = max(bounds) * 0.22\n            if num_nodes < 2:\n                return self.step_size * 2.5\n            val = self.neighbor_factor * ((math.log(num_nodes) / num_nodes) ** (1.0 / dim))\n            return max(self.step_size * 1.8, min(maxr, val))\n\n        def nearest(tree, point):\n            best_node = None\n            best_dist = float('inf')\n            for n in tree:\n                d = dist(n.position, point)\n                if d < best_dist:\n                    best_dist = d\n                    best_node = n\n            return best_node\n\n        def near_nodes(tree, pos, radius):\n            radius_sq = radius * radius\n            result = []\n            for n in tree:\n                d_sq = 0.0\n                for i in range(dim):\n                    diff = n.position[i] - pos[i]\n                    d_sq += diff * diff\n                    if d_sq > radius_sq:\n                        break\n                if d_sq <= radius_sq:\n                    result.append(n)\n            return result\n\n        def informed_sample(start, goal, c_best, c_min):\n            if c_best == float('inf') or c_min < 1e-12:\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            r1 = c_best / 2.0\n            r_orth_sq = max(c_best * c_best - c_min * c_min, 0.0)\n            r_orth = math.sqrt(r_orth_sq) / 2.0\n            center = tuple((start[d] + goal[d]) / 2.0 for d in range(dim))\n            a1 = tuple((goal[d] - start[d]) / c_min for d in range(dim))\n\n            def sample_unit_ball(k):\n                while True:\n                    v = [random.gauss(0, 1) for _ in range(k)]\n                    norm_v = math.sqrt(sum(x*x for x in v))\n                    if norm_v > 1e-12:\n                        v = [x / norm_v for x in v]\n                        r = random.random() ** (1.0 / k)\n                        return tuple(v[i] * r for i in range(k))\n\n            u = sample_unit_ball(dim)\n\n            if dim == 2:\n                a2 = (-a1[1], a1[0])\n                basis = (a1, a2)\n                radii = (r1, r_orth)\n            else:\n                ref = (1.0, 0.0, 0.0) if abs(a1[0]) < 0.9 else (0.0, 1.0, 0.0)\n                b2 = self._normalize(self._cross(a1, ref))\n                if self._norm(b2) < 1e-12:\n                    ref = (0.0, 0.0, 1.0)\n                    b2 = self._normalize(self._cross(a1, ref))\n                b3 = self._cross(a1, b2)\n                basis = (a1, b2, b3)\n                radii = (r1, r_orth, r_orth)\n\n            sample = [0]*dim\n            for d in range(dim):\n                val = center[d]\n                for i in range(dim):\n                    val += basis[i][d] * radii[i] * u[i]\n                val = max(0.0, min(bounds[d], val))\n                sample[d] = val\n            return tuple(sample)\n\n        def cost_descendants_update(node):\n            stack = [(node, node.cost)]\n            while stack:\n                curr, base_cost = stack.pop()\n                for child in curr.children:\n                    new_cost = base_cost + dist(curr.position, child.position)\n                    if abs(child.cost - new_cost) > 1e-12:\n                        child.cost = new_cost\n                        stack.append((child, new_cost))\n\n        def add_node(tree, pos, nodes_all, edges_all):\n            r = neighbor_radius(len(tree))\n            neighbors = near_nodes(tree, pos, r)\n            candidate_parents = []\n            for nb in neighbors:\n                if edge_collision_free(nb.position, pos):\n                    candidate_parents.append(nb)\n            if not candidate_parents:\n                n_near = nearest(tree, pos)\n                if edge_collision_free(n_near.position, pos):\n                    parent = n_near\n                else:\n                    return None, []\n            else:\n                parent = min(candidate_parents, key=lambda n: n.cost + dist(n.position, pos))\n            new_cost = parent.cost + dist(parent.position, pos)\n            new_node = Node(pos, parent=None, cost=new_cost)\n            parent.add_child(new_node)\n            tree.append(new_node)\n            nodes_all.append(new_node)\n            edges_all.append((parent, new_node))\n\n            for nb in neighbors:\n                if nb is new_node or nb is parent:\n                    continue\n                if edge_collision_free(new_node.position, nb.position):\n                    new_cost_nb = new_node.cost + dist(new_node.position, nb.position)\n                    if new_cost_nb + 1e-12 < nb.cost:\n                        if nb.parent:\n                            try:\n                                edges_all.remove((nb.parent, nb))\n                            except ValueError:\n                                pass\n                            nb.parent.remove_child(nb)\n                        new_node.add_child(nb)\n                        nb.cost = new_cost_nb\n                        edges_all.append((new_node, nb))\n                        cost_descendants_update(nb)\n            return new_node, neighbors\n\n        def try_connect_trees(new_node, other_tree):\n            near_other = nearest(other_tree, new_node.position)\n            if dist(new_node.position, near_other.position) <= self.step_size and edge_collision_free(new_node.position, near_other.position):\n                return new_node, near_other\n            curr = near_other\n            while True:\n                next_pos = steer(curr.position, new_node.position)\n                if not within_bounds(next_pos) or in_obstacle(next_pos):\n                    break\n                if not edge_collision_free(curr.position, next_pos):\n                    break\n                next_node, _ = add_node(other_tree, next_pos, nodes, edges)\n                if next_node is None:\n                    break\n                curr = next_node\n                if dist(curr.position, new_node.position) <= self.step_size and edge_collision_free(curr.position, new_node.position):\n                    return new_node, curr\n            return None, None\n\n        def stitch_paths(n1, n2):\n            path1 = n1.path_from_root()\n            path2 = n2.path_from_root()\n            if path1 and path2 and path1[-1] == path2[-1]:\n                full_path = path1 + path2[-2::-1]\n            else:\n                full_path = path1 + path2[::-1]\n            return full_path\n\n        def path_cost(path):\n            total = 0.0\n            for i in range(len(path)-1):\n                total += dist(path[i], path[i+1])\n            return total\n\n        def incremental_smooth(path, trials):\n            if len(path) < 3:\n                return path\n            smooth_path = path[:]\n            for _ in range(trials):\n                if len(smooth_path) < 3:\n                    break\n                i = random.randint(0, len(smooth_path) - 3)\n                j = random.randint(i + 2, len(smooth_path) - 1)\n                if edge_collision_free(smooth_path[i], smooth_path[j]):\n                    smooth_path = smooth_path[:i + 1] + smooth_path[j:]\n            return smooth_path\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        c_min = dist(start_pos, goal_pos)\n        best_cost = float('inf')\n        best_path = []\n        found_solution = False\n        no_improve = 0\n        smooth_trials = self.smooth_trials_increment\n\n        start_time = time.time()\n        iteration = 0\n\n        while iteration < self.max_iter:\n            if time.time() - start_time > self.time_limit_sec:\n                break\n\n            tree_grow, tree_other = (tree_start, tree_goal) if (iteration % 2 == 0) else (tree_goal, tree_start)\n\n            sample = (informed_sample(start_pos, goal_pos, best_cost, c_min)\n                      if found_solution else\n                      tuple(random.uniform(0.0, bounds[d]) for d in range(dim)))\n\n            if not within_bounds(sample) or in_obstacle(sample):\n                iteration += 1\n                if found_solution:\n                    no_improve += 1\n                    if no_improve > self.max_no_improve:\n                        break\n                continue\n\n            nearest_node = nearest(tree_grow, sample)\n            new_pos = steer(nearest_node.position, sample)\n            if not within_bounds(new_pos) or in_obstacle(new_pos):\n                iteration += 1\n                if found_solution:\n                    no_improve += 1\n                    if no_improve > self.max_no_improve:\n                        break\n                continue\n            if not edge_collision_free(nearest_node.position, new_pos):\n                iteration += 1\n                if found_solution:\n                    no_improve += 1\n                    if no_improve > self.max_no_improve:\n                        break\n                continue\n\n            new_node, neighbors = add_node(tree_grow, new_pos, nodes, edges)\n            if new_node is None:\n                iteration += 1\n                if found_solution:\n                    no_improve += 1\n                    if no_improve > self.max_no_improve:\n                        break\n                continue\n\n            connect_nodes = try_connect_trees(new_node, tree_other)\n            if connect_nodes[0] is not None and connect_nodes[1] is not None:\n                n1, n2 = connect_nodes\n                candidate_path = stitch_paths(n1, n2)\n                candidate_cost = path_cost(candidate_path)\n                if candidate_cost + self.improve_tol < best_cost:\n                    best_cost = candidate_cost\n                    best_path = incremental_smooth(candidate_path, smooth_trials)\n                    found_solution = True\n                    no_improve = 0\n                    smooth_trials += self.smooth_trials_increment\n                else:\n                    if found_solution:\n                        no_improve += 1\n                        if no_improve > self.max_no_improve:\n                            break\n            else:\n                if found_solution:\n                    no_improve += 1\n                    if no_improve > self.max_no_improve:\n                        break\n\n            iteration += 1\n\n        if found_solution:\n            return PlannerResult(\n                success=True,\n                path=best_path,\n                nodes=nodes,\n                edges=edges\n            )\n        return PlannerResult(\n            success=False,\n            path=[],\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _cross(self, a, b):\n        ax, ay, az = a if len(a) == 3 else (a[0], a[1], 0.0)\n        bx, by, bz = b if len(b) == 3 else (b[0], b[1], 0.0)\n        return (ay * bz - az * by, az * bx - ax * bz, ax * by - ay * bx)\n\n    def _norm(self, v):\n        s = 0.0\n        for x in v:\n            s += x * x\n        return s ** 0.5\n\n    def _normalize(self, v):\n        n = self._norm(v)\n        if n < 1e-12:\n            return v\n        return tuple(x / n for x in v)",
    "objective": 85.21069,
    "time_improvement": -181.0,
    "length_improvement": 19.0,
    "smoothness_improvement": 1489.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 0.9,
            "time_avg": 0.1260277271270752,
            "num_nodes_avg": 287.1,
            "path_length_avg": 151.53330563998125,
            "smoothness_avg": 0.0462659024265686,
            "success_improvement": -9.999999999999998,
            "time_improvement": -380.0540902333345,
            "length_improvement": 16.94219397983864,
            "smoothness_improvement": 624.1618409909642,
            "objective_score": -150.73010147714234
        },
        {
            "map_id": 1,
            "success_rate": 0.8,
            "time_avg": 0.15287985801696777,
            "num_nodes_avg": 560.5,
            "path_length_avg": 235.4543871174469,
            "smoothness_avg": 0.10113929424209973,
            "success_improvement": -19.999999999999996,
            "time_improvement": 7.424108222436379,
            "length_improvement": 21.398548401433924,
            "smoothness_improvement": 2502.386888538343,
            "objective_score": -72.42170404971701
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.13598923683166503,
            "num_nodes_avg": 384.4,
            "path_length_avg": 120.60093256520854,
            "smoothness_avg": 0.11333587604614784,
            "success_improvement": 0.0,
            "time_improvement": -170.43310625772827,
            "length_improvement": 19.902602989470967,
            "smoothness_improvement": 1341.6239777228284,
            "objective_score": -32.48025019502175
        }
    ],
    "success_rate": 0.9
}
{
    "operator": "m1",
    "algorithm_description": "A hybrid bidirectional planner combining adaptive incremental extension, informed sampling biased toward the goal region, and dynamic rewiring of nearby nodes to optimize path cost progressively. It balances exploration and exploitation by alternating expansions from start and goal, uses adaptive step sizes for efficient growth, performs early collision checks, and rewires local neighborhoods to improve path length and smoothness dynamically. The planner integrates post-planning shortcut smoothing to enhance path smoothness without increasing computation significantly.",
    "planning_mechanism": "The planner grows two trees bidirectionally, alternately extending them toward sampled points that are mostly random but occasionally biased near the direct line connecting start and goal (informed sampling). Each extension uses adaptive step sizes proportional to target distance and validates collision-free nodes and edges. After adding a new node, the planner rewires neighbors within a dynamically computed radius to improve overall path cost. Once the trees connect, the combined path is extracted and then refined with shortcut smoothing by attempting direct connections between nonadjacent nodes along the path, further improving smoothness and length.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=3500, max_step=7.5, min_step=1.0, goal_sample_rate=0.15, gamma_rrt_star=25.0, max_radius=35.0):\n        self.max_iter = max_iter\n        self.max_step = max_step\n        self.min_step = min_step\n        self.goal_sample_rate = goal_sample_rate\n        self.gamma_rrt_star = gamma_rrt_star\n        self.max_radius = max_radius\n\n    def plan(self, map):\n        bounds = map.size\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        tree_start = [Node(start, None, 0.0)]\n        tree_goal = [Node(goal, None, 0.0)]\n        nodes = tree_start + tree_goal\n        edges = []\n\n        # Precompute dimensionality and distance function shortcut\n        dim = len(bounds)\n\n        for i in range(self.max_iter):\n            tree_a, tree_b = (tree_start, tree_goal) if (i % 2 == 0) else (tree_goal, tree_start)\n\n            sample = self._informed_sample(bounds, start, goal, obstacles, is_3d) if self._rand_float() < self.goal_sample_rate else self._sample_free(bounds, obstacles, is_3d)\n\n            new_node_a = self._extend_and_rewire(tree_a, sample, obstacles, is_3d, nodes, edges, bounds)\n            if new_node_a is None:\n                continue\n\n            new_node_b = self._connect_and_rewire(tree_b, new_node_a, obstacles, is_3d, nodes, edges, bounds)\n            if new_node_b:\n                path_start = new_node_a.path_from_root()\n                path_goal = new_node_b.path_from_root()\n                if path_start[-1] == path_goal[-1]:\n                    path = path_start + path_goal[-2::-1]\n                else:\n                    path = path_start + path_goal[::-1]\n\n                path = self._shortcut_path(path, obstacles, is_3d)\n\n                return PlannerResult(True, path, nodes, edges)\n\n        return PlannerResult(False, [], nodes, edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        while True:\n            pt = tuple(self._rand_float() * bounds[d] for d in range(len(bounds)))\n            if not self._in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def _informed_sample(self, bounds, start, goal, obstacles, is_3d):\n        # Sample within bounding box around line start-goal extended by max_step\n        max_extend = max(bounds) * 0.3\n        dir_vec = tuple(goal[d] - start[d] for d in range(len(bounds)))\n        dist_sg = self._distance(start, goal)\n        if dist_sg < 1e-6:\n            return start\n        unit_dir = tuple(dir_vec[d] / dist_sg for d in range(len(bounds)))\n        # Sample along line: uniformly choose a point between start-dist_sg extended by max_extend\n        sample_dist = self._rand_float() * (dist_sg + max_extend)\n        base_point = tuple(start[d] + unit_dir[d] * sample_dist for d in range(len(bounds)))\n\n        # Add small perpendicular random noise bounded to slight radius\n        import random\n        radius_noise = max_extend * 0.15\n        noise = []\n        for d in range(len(bounds)):\n            noise.append((self._rand_float() - 0.5) * 2 * radius_noise)\n        sample_pt = tuple(min(max(0.0, base_point[d] + noise[d]), bounds[d]) for d in range(len(bounds)))\n\n        if not self._in_obstacle(sample_pt, obstacles, is_3d):\n            return sample_pt\n        else:\n            return self._sample_free(bounds, obstacles, is_3d)\n\n    def _extend_and_rewire(self, tree, sample, obstacles, is_3d, nodes, edges, bounds):\n        nearest = self._nearest(tree, sample)\n        dist_to_sample = self._distance(nearest.position, sample)\n        step = max(self.min_step, min(self.max_step, dist_to_sample))\n        new_pos = self._steer(nearest.position, sample, step)\n\n        if not self._valid_node_and_edge(nearest.position, new_pos, obstacles, is_3d):\n            return None\n\n        neighbors = self._near_nodes(tree, new_pos, bounds)\n        min_cost = nearest.cost + self._distance(nearest.position, new_pos)\n        best_parent = nearest\n        for nb in neighbors:\n            if self._valid_node_and_edge(nb.position, new_pos, obstacles, is_3d):\n                cost = nb.cost + self._distance(nb.position, new_pos)\n                if cost < min_cost:\n                    min_cost = cost\n                    best_parent = nb\n\n        new_node = Node(new_pos, best_parent, min_cost)\n        best_parent.add_child(new_node)\n        tree.append(new_node)\n        nodes.append(new_node)\n        edges.append((best_parent, new_node))\n\n        for nb in neighbors:\n            if nb == best_parent:\n                continue\n            if self._valid_node_and_edge(new_node.position, nb.position, obstacles, is_3d):\n                updated_cost = new_node.cost + self._distance(new_node.position, nb.position)\n                if updated_cost < nb.cost:\n                    if nb.parent:\n                        try:\n                            edges.remove((nb.parent, nb))\n                        except ValueError:\n                            pass\n                        if nb in nb.parent.children:\n                            nb.parent.children.remove(nb)\n                    new_node.add_child(nb)\n                    nb.cost = updated_cost\n                    edges.append((new_node, nb))\n\n        return new_node\n\n    def _connect_and_rewire(self, tree, target_node, obstacles, is_3d, nodes, edges, bounds):\n        current = self._nearest(tree, target_node.position)\n\n        while True:\n            dist_to_target = self._distance(current.position, target_node.position)\n            if dist_to_target <= self.min_step:\n                if self._valid_node_and_edge(current.position, target_node.position, obstacles, is_3d):\n                    final_node = Node(target_node.position, current, current.cost + dist_to_target)\n                    current.add_child(final_node)\n                    tree.append(final_node)\n                    nodes.append(final_node)\n                    edges.append((current, final_node))\n                    return final_node\n                else:\n                    return None\n\n            step = max(self.min_step, min(self.max_step, dist_to_target))\n            new_pos = self._steer(current.position, target_node.position, step)\n            if not self._valid_node_and_edge(current.position, new_pos, obstacles, is_3d):\n                return None\n\n            neighbors = self._near_nodes(tree, new_pos, bounds)\n            min_cost = current.cost + self._distance(current.position, new_pos)\n            best_parent = current\n            for nb in neighbors:\n                if self._valid_node_and_edge(nb.position, new_pos, obstacles, is_3d):\n                    cost = nb.cost + self._distance(nb.position, new_pos)\n                    if cost < min_cost:\n                        min_cost = cost\n                        best_parent = nb\n\n            new_node = Node(new_pos, best_parent, min_cost)\n            best_parent.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            for nb in neighbors:\n                if nb == best_parent:\n                    continue\n                if self._valid_node_and_edge(new_node.position, nb.position, obstacles, is_3d):\n                    updated_cost = new_node.cost + self._distance(new_node.position, nb.position)\n                    if updated_cost < nb.cost:\n                        if nb.parent:\n                            try:\n                                edges.remove((nb.parent, nb))\n                            except ValueError:\n                                pass\n                            if nb in nb.parent.children:\n                                nb.parent.children.remove(nb)\n                        new_node.add_child(nb)\n                        nb.cost = updated_cost\n                        edges.append((new_node, nb))\n\n            current = new_node\n\n    def _near_nodes(self, tree, position, bounds):\n        n = max(1, len(tree))\n        d = len(position)\n        scale = max(1.0, sum(bounds) / d)\n        r_theory = self.gamma_rrt_star * ((math.log(n + 1) / (n + 1)) ** (1.0 / d))\n        radius = max(self.min_step * 2, min(self.max_radius, r_theory * 0.5 + scale * 0.035))\n        return [node for node in tree if self._distance(node.position, position) <= radius]\n\n    def _steer(self, from_pos, to_pos, step_size):\n        dist = self._distance(from_pos, to_pos)\n        if dist <= step_size:\n            return to_pos\n        ratio = step_size / dist\n        return tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(len(from_pos)))\n\n    def _valid_node_and_edge(self, from_pos, to_pos, obstacles, is_3d):\n        return (not self._in_obstacle(to_pos, obstacles, is_3d)) and (not self._edge_in_obstacle(from_pos, to_pos, obstacles, is_3d))\n\n    def _in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _edge_in_obstacle(self, p1, p2, obstacles, is_3d, resolution=0.8):\n        dist = self._distance(p1, p2)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(p1[d] + (p2[d] - p1[d]) * i / steps for d in range(len(p1)))\n            if self._in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _distance(self, a, b):\n        s = 0.0\n        for i in range(len(a)):\n            s += (a[i] - b[i]) ** 2\n        return s ** 0.5\n\n    def _nearest(self, tree, point):\n        best = None\n        best_dist = float('inf')\n        for node in tree:\n            dist = self._distance(node.position, point)\n            if dist < best_dist:\n                best_dist = dist\n                best = node\n        return best\n\n    def _rand_float(self):\n        # Minimal builtin RNG to avoid import random unless forced\n        # Use linear congruential generator parameters\n        # (for demo and reproducibility; if environment mandates import random, can switch)\n        if not hasattr(self, '_rand_state'):\n            self._rand_state = 123456789\n        self._rand_state = (1103515245 * self._rand_state + 12345) & 0x7fffffff\n        return self._rand_state / 0x7fffffff\n\n    def _shortcut_path(self, path, obstacles, is_3d):\n        # Attempts to shortcut the path by connecting pairs of nodes skipping intermediates if possible\n        if len(path) < 3:\n            return path[:]\n        shortcut_path = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) -1\n            while j > i + 1:\n                if not self._edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                    break\n                j -= 1\n            shortcut_path.append(path[j])\n            i = j\n        return shortcut_path",
    "objective": 18.02584,
    "time_improvement": 56.0,
    "length_improvement": 10.0,
    "smoothness_improvement": 1799.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.0256727933883667,
            "num_nodes_avg": 91.0,
            "path_length_avg": 185.97643111357328,
            "smoothness_avg": 0.045193882901552754,
            "success_improvement": 0.0,
            "time_improvement": 2.209380786705938,
            "length_improvement": -1.9366288784867494,
            "smoothness_improvement": 607.3824074968078,
            "objective_score": 2.537748946403771
        },
        {
            "map_id": 1,
            "success_rate": 0.9,
            "time_avg": 0.0328561544418335,
            "num_nodes_avg": 185.9,
            "path_length_avg": 243.0134396330979,
            "smoothness_avg": 0.12667451658152795,
            "success_improvement": -9.999999999999998,
            "time_improvement": 80.10406447724132,
            "length_improvement": 18.875119096446745,
            "smoothness_improvement": 3159.4265516090604,
            "objective_score": 1.153423559085752
        },
        {
            "map_id": 2,
            "success_rate": 0.8,
            "time_avg": 0.007357263565063476,
            "num_nodes_avg": 92.0,
            "path_length_avg": 129.31114898038737,
            "smoothness_avg": 0.13600652224920554,
            "success_improvement": -19.999999999999996,
            "time_improvement": 85.36908004035776,
            "length_improvement": 14.11769198244388,
            "smoothness_improvement": 1629.9929240526858,
            "objective_score": -57.7686961781629
        }
    ],
    "success_rate": 0.9
}
{
    "operator": "m1",
    "algorithm_description": "A bidirectional RRT* variant enhanced with adaptive neighborhood search radius, goal-biased intelligent sampling, progressive rewiring within dynamically scaled neighborhoods, and multi-resolution collision checking for efficient expansion and refined path quality. The planner alternates growing trees from start and goal positions, performing selective rewiring to continually optimize path cost and shape. Upon successful connection, a path smoothing step using iterative shortcutting improves path smoothness and length while preserving collision-free guarantees. This approach emphasizes computational efficiency, path optimality, and smoothness in cluttered environments.",
    "planning_mechanism": "The planner initializes two trees at start and goal, then iteratively samples points biased toward the goal line or free space, extends each tree towards samples with adaptive step length, searches a neighborhood with radius scaled by the logarithm of the tree's size for rewiring, and rewires nodes to reduce costs when collision checks pass. The trees alternate expansion until connected, then a shortcut smoothing post-processing step refines the path to improve smoothness and reduce length before returning the successful solution.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=4000, max_step=8.0, min_step=0.8, goal_sample_rate=0.2, gamma_rrt_star=35.0, max_radius=30.0):\n        self.max_iter = max_iter\n        self.max_step = max_step\n        self.min_step = min_step\n        self.goal_sample_rate = goal_sample_rate\n        self.gamma_rrt_star = gamma_rrt_star\n        self.max_radius = max_radius\n\n    def plan(self, map):\n        bounds = map.size\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        tree_start = [Node(start, None, 0.0)]\n        tree_goal = [Node(goal, None, 0.0)]\n        nodes = tree_start + tree_goal\n        edges = []\n\n        for i in range(self.max_iter):\n            tree_a, tree_b = (tree_start, tree_goal) if (i % 2 == 0) else (tree_goal, tree_start)\n\n            sample = (self._informed_sample(bounds, start, goal, obstacles, is_3d)\n                      if self._rand_float() < self.goal_sample_rate else\n                      self._sample_free(bounds, obstacles, is_3d))\n\n            new_node_a = self._extend_and_rewire(tree_a, sample, obstacles, is_3d, nodes, edges, bounds, dim)\n            if new_node_a is None:\n                continue\n\n            new_node_b = self._connect_and_rewire(tree_b, new_node_a, obstacles, is_3d, nodes, edges, bounds, dim)\n            if new_node_b is not None:\n                path_start = new_node_a.path_from_root()\n                path_goal = new_node_b.path_from_root()\n                if path_start[-1] == path_goal[-1]:\n                    raw_path = path_start + path_goal[-2::-1]\n                else:\n                    raw_path = path_start + path_goal[::-1]\n                smooth_path = self._shortcut_path(raw_path, obstacles, is_3d)\n                return PlannerResult(True, smooth_path, nodes, edges)\n\n        return PlannerResult(False, [], nodes, edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        while True:\n            pt = tuple(self._rand_float() * bounds[d] for d in range(len(bounds)))\n            if not self._in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def _informed_sample(self, bounds, start, goal, obstacles, is_3d):\n        dist_sg = self._distance(start, goal)\n        if dist_sg < 1e-8:\n            return start\n        unit_dir = tuple((goal[d] - start[d]) / dist_sg for d in range(len(bounds)))\n        max_extend = max(bounds) * 0.35\n        # Sample on line from start extending beyond goal by 30%\n        sample_dist = self._rand_float() * (dist_sg + max_extend)\n        base_point = tuple(start[d] + unit_dir[d] * sample_dist for d in range(len(bounds)))\n        # Add perpendicular noise orthogonal to unit_dir vector\n        radius_noise = max_extend * 0.15\n        noise = [ (self._rand_float() - 0.5) * 2 * radius_noise for _ in range(len(bounds))]\n        # Adjust noise orthogonal to direction to bias sampling near line segment\n        # For 2D, project noise on perpendicular vector, for 3D random normal perturbations in null space\n        if len(bounds) == 2:\n            px, py = unit_dir\n            # perpendicular vector\n            perp = (-py, px)\n            # reduce noise along direction, keep perpendicular part\n            perp_noise = perp[0]*noise[0] + perp[1]*noise[1]\n            sample_pt = tuple(min(max(0.0, base_point[d] + perp[d]*perp_noise) , bounds[d]) for d in range(2))\n        else:\n            # Simple isotropic noise clipped to bounds\n            sample_pt = tuple(min(max(0.0, base_point[d] + noise[d]), bounds[d]) for d in range(len(bounds)))\n        if not self._in_obstacle(sample_pt, obstacles, is_3d):\n            return sample_pt\n        return self._sample_free(bounds, obstacles, is_3d)\n\n    def _extend_and_rewire(self, tree, sample, obstacles, is_3d, nodes, edges, bounds, dim):\n        nearest = self._nearest(tree, sample)\n        dist_to_sample = self._distance(nearest.position, sample)\n        step = max(self.min_step, min(self.max_step, dist_to_sample))\n        new_pos = self._steer(nearest.position, sample, step)\n        if not self._valid_node_and_edge(nearest.position, new_pos, obstacles, is_3d):\n            return None\n\n        neighbors = self._near_nodes(tree, new_pos, bounds, dim)\n        min_cost = nearest.cost + self._distance(nearest.position, new_pos)\n        best_parent = nearest\n        for nb in neighbors:\n            if self._valid_node_and_edge(nb.position, new_pos, obstacles, is_3d):\n                cost = nb.cost + self._distance(nb.position, new_pos)\n                if cost < min_cost:\n                    min_cost = cost\n                    best_parent = nb\n\n        new_node = Node(new_pos, best_parent, min_cost)\n        best_parent.add_child(new_node)\n        tree.append(new_node)\n        nodes.append(new_node)\n        edges.append((best_parent, new_node))\n\n        for nb in neighbors:\n            if nb is best_parent:\n                continue\n            if self._valid_node_and_edge(new_node.position, nb.position, obstacles, is_3d):\n                updated_cost = new_node.cost + self._distance(new_node.position, nb.position)\n                if updated_cost + 1e-6 < nb.cost:\n                    if nb.parent:\n                        try:\n                            edges.remove((nb.parent, nb))\n                        except ValueError:\n                            pass\n                        if nb in nb.parent.children:\n                            nb.parent.children.remove(nb)\n                    new_node.add_child(nb)\n                    nb.cost = updated_cost\n                    edges.append((new_node, nb))\n\n        return new_node\n\n    def _connect_and_rewire(self, tree, target_node, obstacles, is_3d, nodes, edges, bounds, dim):\n        current = self._nearest(tree, target_node.position)\n        while True:\n            dist_to_target = self._distance(current.position, target_node.position)\n            if dist_to_target <= self.min_step:\n                if self._valid_node_and_edge(current.position, target_node.position, obstacles, is_3d):\n                    final_node = Node(target_node.position, current, current.cost + dist_to_target)\n                    current.add_child(final_node)\n                    tree.append(final_node)\n                    nodes.append(final_node)\n                    edges.append((current, final_node))\n                    return final_node\n                return None\n\n            step = max(self.min_step, min(self.max_step, dist_to_target))\n            new_pos = self._steer(current.position, target_node.position, step)\n            if not self._valid_node_and_edge(current.position, new_pos, obstacles, is_3d):\n                return None\n\n            neighbors = self._near_nodes(tree, new_pos, bounds, dim)\n            min_cost = current.cost + self._distance(current.position, new_pos)\n            best_parent = current\n            for nb in neighbors:\n                if self._valid_node_and_edge(nb.position, new_pos, obstacles, is_3d):\n                    cost = nb.cost + self._distance(nb.position, new_pos)\n                    if cost < min_cost:\n                        min_cost = cost\n                        best_parent = nb\n\n            new_node = Node(new_pos, best_parent, min_cost)\n            best_parent.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            for nb in neighbors:\n                if nb is best_parent:\n                    continue\n                if self._valid_node_and_edge(new_node.position, nb.position, obstacles, is_3d):\n                    updated_cost = new_node.cost + self._distance(new_node.position, nb.position)\n                    if updated_cost + 1e-6 < nb.cost:\n                        if nb.parent:\n                            try:\n                                edges.remove((nb.parent, nb))\n                            except ValueError:\n                                pass\n                            if nb in nb.parent.children:\n                                nb.parent.children.remove(nb)\n                        new_node.add_child(nb)\n                        nb.cost = updated_cost\n                        edges.append((new_node, nb))\n\n            current = new_node\n\n    def _near_nodes(self, tree, position, bounds, dim):\n        n = max(1, len(tree))\n        scale = max(1.0, sum(bounds) / dim)\n        r_theory = self.gamma_rrt_star * ((math.log(n + 1) / (n + 1)) ** (1.0 / dim))\n        radius = max(self.min_step * 1.8, min(self.max_radius, r_theory * 0.6 + scale * 0.03))\n        return [node for node in tree if self._distance(node.position, position) <= radius]\n\n    def _steer(self, from_pos, to_pos, step_size):\n        dist = self._distance(from_pos, to_pos)\n        if dist <= step_size:\n            return to_pos\n        ratio = step_size / dist\n        return tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(len(from_pos)))\n\n    def _valid_node_and_edge(self, from_pos, to_pos, obstacles, is_3d):\n        if self._in_obstacle(to_pos, obstacles, is_3d):\n            return False\n        return not self._edge_in_obstacle(from_pos, to_pos, obstacles, is_3d)\n\n    def _in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x,y,z,w,h,d = obs\n                px,py,pz = pos\n                if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                    return True\n            else:\n                x,y,w,h = obs\n                px,py = pos\n                if x <= px <= x+w and y <= py <= y+h:\n                    return True\n        return False\n\n    def _edge_in_obstacle(self, p1, p2, obstacles, is_3d, resolution=0.5):\n        dist = self._distance(p1, p2)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps+1):\n            interp = tuple(p1[d] + (p2[d]-p1[d]) * i / steps for d in range(len(p1)))\n            if self._in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _distance(self, a,b):\n        s=0.0\n        for i in range(len(a)):\n            s += (a[i]-b[i])**2\n        return s**0.5\n\n    def _nearest(self, tree, point):\n        best = None\n        best_dist = float('inf')\n        for node in tree:\n            dist = self._distance(node.position, point)\n            if dist < best_dist:\n                best_dist = dist\n                best = node\n        return best\n\n    def _rand_float(self):\n        if not hasattr(self, '_rand_state'):\n            self._rand_state = 987654321\n        self._rand_state = (1664525 * self._rand_state + 1013904223) & 0xFFFFFFFF\n        return self._rand_state / 4294967295.0\n\n    def _shortcut_path(self, path, obstacles, is_3d):\n        if len(path) < 3:\n            return path[:]\n        shortened = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            while j > i+1:\n                if not self._edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                    break\n                j -= 1\n            shortened.append(path[j])\n            i = j\n        return shortened",
    "objective": -11.1158,
    "time_improvement": 36.0,
    "length_improvement": 13.0,
    "smoothness_improvement": 1839.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 0.9,
            "time_avg": 0.03728148937225342,
            "num_nodes_avg": 87.5,
            "path_length_avg": 177.5993625994981,
            "smoothness_avg": 0.061093825863437166,
            "success_improvement": -9.999999999999998,
            "time_improvement": -42.00947578063485,
            "length_improvement": 2.6549751172230844,
            "smoothness_improvement": 856.2510421290689,
            "objective_score": -56.72860245321125
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.040665721893310545,
            "num_nodes_avg": 172.6,
            "path_length_avg": 240.60704401879048,
            "smoothness_avg": 0.11503528741526861,
            "success_improvement": 0.0,
            "time_improvement": 75.37500676751161,
            "length_improvement": 19.678443216759863,
            "smoothness_improvement": 2859.940801763299,
            "objective_score": 48.7192719691259
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.013425302505493165,
            "num_nodes_avg": 80.8,
            "path_length_avg": 124.56156413344789,
            "smoothness_avg": 0.14941690218783527,
            "success_improvement": 0.0,
            "time_improvement": 73.30195871674466,
            "length_improvement": 17.272140086854744,
            "smoothness_improvement": 1800.5719670207743,
            "objective_score": 41.356731502240116
        }
    ],
    "success_rate": 0.9666666666666667
}
{
    "operator": "m3",
    "algorithm_description": "A simplified bidirectional RRT* algorithm that grows two trees from start and goal, samples uniformly with bias towards improving the solution, rewires locally to optimize paths, attempts direct connections between trees to find a path, and performs post-processing shortcutting to smooth and shorten the final path. It uses straightforward nearest neighbor search and basic collision checking to ensure valid paths while balancing computational cost and path quality.",
    "planning_mechanism": "The planner alternates growing start and goal trees towards sampled points inside the map bounds or within the informed ellipsoid if a solution exists. New nodes are linked and rewired locally to reduce path cost. It frequently attempts to connect the two trees directly upon proximity. Upon finding a path, it applies shortcutting to improve smoothness. The search halts on first valid path or after max iterations.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\nclass Planner:\n    def __init__(self, max_iter=3000, step_size=7.5, rewire_radius=15.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.rewire_radius = rewire_radius\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        edges = []\n        best_cost = float('inf')\n        best_path = []\n\n        def dist(a, b):\n            return sum((a[i]-b[i])**2 for i in range(dim))**0.5\n\n        def in_collision(p):\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d = obs\n                    if x <= p[0] <= x+w and y <= p[1] <= y+h and z <= p[2] <= z+d:\n                        return True\n                else:\n                    x,y,w,h = obs\n                    if x <= p[0] <= x+w and y <= p[1] <= y+h:\n                        return True\n            return False\n\n        def edge_collision(a, b, resolution=1.0):\n            d = dist(a,b)\n            steps = max(1, int(d/resolution))\n            for i in range(steps+1):\n                pt = tuple(a[j] + (b[j]-a[j]) * i/steps for j in range(dim))\n                if in_collision(pt):\n                    return True\n            return False\n\n        def steer(from_p, to_p, max_step):\n            d = dist(from_p, to_p)\n            if d <= max_step:\n                return to_p\n            ratio = max_step / d\n            return tuple(from_p[i] + (to_p[i]-from_p[i])*ratio for i in range(dim))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: dist(n.position, point))\n\n        def neighbors(tree, point, radius):\n            radius_sq = radius*radius\n            result = []\n            for n in tree:\n                if sum((n.position[i]-point[i])**2 for i in range(dim)) <= radius_sq:\n                    result.append(n)\n            return result\n\n        def extract_path(node_start, node_goal):\n            path_start = []\n            n = node_start\n            while n:\n                path_start.append(n.position)\n                n = n.parent\n            path_start.reverse()\n            path_goal = []\n            n = node_goal\n            while n:\n                path_goal.append(n.position)\n                n = n.parent\n            return path_start + path_goal\n\n        def sample_informed(c_best):\n            if c_best == float('inf'):\n                while True:\n                    p = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                    if not in_collision(p):\n                        return p\n            c_min = dist(start_pos, goal_pos)\n            if c_min == 0.0:\n                return goal_pos\n            center = tuple((start_pos[i]+goal_pos[i])/2 for i in range(dim))\n            a1 = [(goal_pos[i]-start_pos[i])/c_min for i in range(dim)]\n            L1 = c_best/2.0\n            L2 = ((c_best**2 - c_min**2)**0.5)/2.0\n            while True:\n                while True:\n                    sample = [random.uniform(-1,1) for _ in range(dim)]\n                    norm_s = sum(s*s for s in sample)**0.5\n                    if 0 < norm_s <= 1:\n                        break\n                unit_s = [s/norm_s for s in sample]\n                r = random.uniform(0,1)**(1/dim)\n                unit_ball = [r*us for us in unit_s]\n                ellipsoid_sample = [L1*unit_ball[0]] + [L2*unit_ball[i] for i in range(1,dim)]\n                # Rotate ellipsoid sample to align with a1 (only 2D/3D)\n                if dim == 2:\n                    theta = 0\n                    if abs(a1[0]) < 1.0:\n                        theta = math.acos(a1[0])\n                        if a1[1] < 0:\n                            theta = -theta\n                    x = ellipsoid_sample[0]*math.cos(theta) - ellipsoid_sample[1]*math.sin(theta)\n                    y = ellipsoid_sample[0]*math.sin(theta) + ellipsoid_sample[1]*math.cos(theta)\n                    p = (center[0]+x, center[1]+y)\n                elif dim == 3:\n                    # simple rotation aligning x-axis to a1 using Householder reflection\n                    x = a1\n                    I = [[1 if i==j else 0 for j in range(3)] for i in range(3)]\n                    v = [x[0]-1, x[1], x[2]]\n                    norm_v = sum(vi*vi for vi in v)**0.5\n                    if norm_v < 1e-10:\n                        R = I\n                    else:\n                        v = [vi/norm_v for vi in v]\n                        R = [[I[i][j] - 2*v[i]*v[j] for j in range(3)] for i in range(3)]\n                    rotated = tuple(sum(R[i][j]*ellipsoid_sample[j] for j in range(3)) for i in range(3))\n                    p = tuple(center[i] + rotated[i] for i in range(3))\n                else:\n                    p = tuple(center[i] + ellipsoid_sample[i] for i in range(dim))\n                if all(0 <= p[i] <= bounds[i] for i in range(dim)) and not in_collision(p):\n                    return p\n\n        def shortcut_path(path):\n            if len(path)<3:\n                return path\n            i = 0\n            while i < len(path)-2:\n                j = len(path)-1\n                while j > i+1:\n                    if not edge_collision(path[i], path[j]):\n                        path = path[:i+1]+path[j:]\n                        break\n                    j -=1\n                i +=1\n            return path\n\n        def rewire(tree, new_node):\n            nghs = neighbors(tree, new_node.position, self.rewire_radius)\n            for ngh in nghs:\n                if ngh == new_node.parent:\n                    continue\n                if edge_collision(new_node.position, ngh.position):\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, ngh.position)\n                if new_cost + 1e-7 < ngh.cost:\n                    if ngh.parent:\n                        try:\n                            ngh.parent.children.remove(ngh)\n                        except:\n                            pass\n                    ngh.parent = new_node\n                    ngh.cost = new_cost\n                    new_node.add_child(ngh)\n\n        for iteration in range(self.max_iter):\n            sample = sample_informed(best_cost)\n            for (tree_a, tree_b) in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nn = nearest(tree_a, sample)\n                new_pos = steer(nn.position, sample, self.step_size)\n                if in_collision(new_pos) or edge_collision(nn.position, new_pos):\n                    continue\n                new_cost = nn.cost + dist(nn.position, new_pos)\n                new_node = Node(new_pos, parent=nn, cost=new_cost)\n                nn.add_child(new_node)\n                tree_a.append(new_node)\n                edges.append((nn, new_node))\n\n                rewire(tree_a, new_node)\n\n                nearest_other = nearest(tree_b, new_pos)\n                dist_trees = dist(new_pos, nearest_other.position)\n                if dist_trees <= self.step_size*2 and not edge_collision(new_pos, nearest_other.position):\n                    connect_node = Node(nearest_other.position, parent=new_node, cost=new_node.cost + dist_trees)\n                    new_node.add_child(connect_node)\n                    tree_b.append(connect_node)\n                    edges.append((new_node, connect_node))\n\n                    path = extract_path(new_node, nearest_other)\n                    path = shortcut_path(path)\n\n                    cost_path = 0.0\n                    for k in range(len(path)-1):\n                        cost_path += dist(path[k], path[k+1])\n                    if cost_path < best_cost:\n                        best_cost = cost_path\n                        best_path = path\n            if best_path:\n                return PlannerResult(True, best_path, start_tree+goal_tree, edges)\n        return PlannerResult(False, [], start_tree+goal_tree, edges)",
    "objective": -7.96217,
    "time_improvement": -25.0,
    "length_improvement": 11.0,
    "smoothness_improvement": 1799.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.05618610382080078,
            "num_nodes_avg": 139.8,
            "path_length_avg": 185.25496856355855,
            "smoothness_avg": 0.04960682018479354,
            "success_improvement": 0.0,
            "time_improvement": -114.01932390840987,
            "length_improvement": -1.5411838225179815,
            "smoothness_improvement": 676.4544588262154,
            "objective_score": -31.748235171902678
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.037730622291564944,
            "num_nodes_avg": 170.8,
            "path_length_avg": 236.8253031039858,
            "smoothness_avg": 0.12587993282534443,
            "success_improvement": 0.0,
            "time_improvement": 77.15234661209345,
            "length_improvement": 20.94089718549847,
            "smoothness_improvement": 3138.9813392469123,
            "objective_score": 51.40514899116168
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.06945254802703857,
            "num_nodes_avg": 205.7,
            "path_length_avg": 131.1004396537589,
            "smoothness_avg": 0.13218220013348647,
            "success_improvement": 0.0,
            "time_improvement": -38.11584459228801,
            "length_improvement": 12.929330314056402,
            "smoothness_improvement": 1581.3478290228345,
            "objective_score": 4.22958395586161
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m3",
    "algorithm_description": "A simplified and efficient bidirectional RRT* planner that incrementally grows two trees from start and goal, sampling free space with goal bias, extending one tree towards samples stepwise, choosing best parents within a radius, rewiring neighbors to reduce costs, and attempting connection between trees for fast solution. It ensures collision-free nodes and edges with minimal overhead and prioritized early stopping on solution discovery.",
    "planning_mechanism": "The planner alternates growing two trees toward random samples, connecting new nodes by selecting lowest cost parents in a neighborhood, rewires neighbors to optimize paths locally, and greedily connects trees incrementally. Planning stops on first found solution or max iterations.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        node, path = self, []\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=3000, step_size=4.0, gamma=50.0, max_radius=40.0, goal_sample_rate=0.05):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.gamma = gamma\n        self.max_radius = max_radius\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map):\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        tree_start = [Node(start_pos)]\n        tree_goal = [Node(goal_pos)]\n        nodes = tree_start + tree_goal\n        edges = []\n\n        def in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    px, py = pos\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def edge_collision(p1, p2, resolution=1.0):\n            dist = math.dist(p1, p2)\n            steps = max(1, int(dist / resolution))\n            for i in range(steps + 1):\n                interm = tuple(p1[d] + (p2[d] - p1[d]) * i / steps for d in range(dim))\n                if in_obstacle(interm):\n                    return True\n            return False\n\n        def sample_free():\n            if random.random() < self.goal_sample_rate:\n                return goal_pos\n            while True:\n                s = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not in_obstacle(s):\n                    return s\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: math.dist(n.position, point))\n\n        def steer(from_p, to_p):\n            dist = math.dist(from_p, to_p)\n            if dist <= self.step_size:\n                return to_p\n            ratio = self.step_size / dist\n            return tuple(from_p[d] + (to_p[d] - from_p[d]) * ratio for d in range(dim))\n\n        def neighbor_radius(n):\n            if n < 2:\n                return self.step_size * 2.0\n            r = self.gamma * ((math.log(n) / n) ** (1 / dim))\n            return min(max(self.step_size * 2, r), self.max_radius)\n\n        def near_nodes(tree, pos):\n            radius = neighbor_radius(len(tree))\n            return [n for n in tree if math.dist(n.position, pos) <= radius]\n\n        def can_connect(p1, p2):\n            return (not in_obstacle(p2) and not edge_collision(p1, p2))\n\n        def add_node(tree, new_pos):\n            near = near_nodes(tree, new_pos)\n            candidates = [n for n in near if can_connect(n.position, new_pos)]\n            if not candidates:\n                parent = nearest(tree, new_pos)\n                if not can_connect(parent.position, new_pos):\n                    return None\n                best_parent = parent\n                best_cost = parent.cost + math.dist(parent.position, new_pos)\n            else:\n                best_parent, best_cost = min(\n                    ((n, n.cost + math.dist(n.position, new_pos)) for n in candidates),\n                    key=lambda x: x[1]\n                )\n            new_node = Node(new_pos, parent=None, cost=best_cost)\n            best_parent.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n            return new_node\n\n        def rewire(new_node, neighbors):\n            for nb in neighbors:\n                if nb is new_node:\n                    continue\n                if can_connect(new_node.position, nb.position):\n                    new_cost = new_node.cost + math.dist(new_node.position, nb.position)\n                    if new_cost + 1e-12 < nb.cost:\n                        if nb.parent:\n                            try:\n                                edges.remove((nb.parent, nb))\n                            except ValueError:\n                                pass\n                            if nb in nb.parent.children:\n                                nb.parent.children.remove(nb)\n                        new_node.add_child(nb)\n                        nb.cost = new_cost\n                        edges.append((new_node, nb))\n\n        def extend(tree, target, other_tree):\n            nearest_node = nearest(tree, target)\n            new_pos = steer(nearest_node.position, target)\n            if not can_connect(nearest_node.position, new_pos):\n                return None\n            new_node = add_node(tree, new_pos)\n            if not new_node:\n                return None\n            near = near_nodes(tree, new_pos)\n            rewire(new_node, near)\n            connect_node = attempt_connect(other_tree, new_node)\n            if connect_node:\n                return new_node, connect_node\n            return new_node, None\n\n        def attempt_connect(tree, target_node):\n            nearest_node = nearest(tree, target_node.position)\n            current = nearest_node\n            while True:\n                new_pos = steer(current.position, target_node.position)\n                if not can_connect(current.position, new_pos):\n                    return None\n                new_node = add_node(tree, new_pos)\n                if not new_node:\n                    return None\n                near = near_nodes(tree, new_pos)\n                rewire(new_node, near)\n                current = new_node\n                if math.dist(current.position, target_node.position) <= self.step_size:\n                    if can_connect(current.position, target_node.position):\n                        final_node = Node(target_node.position, parent=None, cost=current.cost + math.dist(current.position, target_node.position))\n                        current.add_child(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((current, final_node))\n                        return final_node\n                    else:\n                        return None\n\n        best_path = []\n        found = False\n        for _ in range(self.max_iter):\n            sample = sample_free()\n            res = extend(tree_start, sample, tree_goal)\n            if res is None:\n                tree_start, tree_goal = tree_goal, tree_start\n                continue\n            new_node, connect_node = res\n            if connect_node:\n                path_start = new_node.path_from_root()\n                path_goal = connect_node.path_from_root()\n                if path_start[-1] == path_goal[-1]:\n                    path_goal = path_goal[:-1]\n                best_path = path_start + path_goal[::-1]\n                found = True\n                break\n            tree_start, tree_goal = tree_goal, tree_start\n\n        return PlannerResult(success=found, path=best_path, nodes=nodes, edges=edges)",
    "objective": -3.14348,
    "time_improvement": -23.0,
    "length_improvement": 15.0,
    "smoothness_improvement": 270.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.04289665222167969,
            "num_nodes_avg": 86.2,
            "path_length_avg": 154.80487257571312,
            "smoothness_avg": 0.029055568068706832,
            "success_improvement": 0.0,
            "time_improvement": -63.398276123557494,
            "length_improvement": 15.14899630106843,
            "smoothness_improvement": 354.7827354511964,
            "objective_score": -8.156171379170209
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.07331087589263915,
            "num_nodes_avg": 305.3,
            "path_length_avg": 256.0586439039306,
            "smoothness_avg": 0.012268278642848006,
            "success_improvement": 0.0,
            "time_improvement": 55.60684186400731,
            "length_improvement": 14.52025442545721,
            "smoothness_improvement": 215.67164596441225,
            "objective_score": 26.472563444298576
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.08116095066070557,
            "num_nodes_avg": 297.7,
            "path_length_avg": 129.65699918833218,
            "smoothness_avg": 0.02674729664510849,
            "success_improvement": 0.0,
            "time_improvement": -61.399596801723554,
            "length_improvement": 13.887994741944096,
            "smoothness_improvement": 240.22363904570852,
            "objective_score": -8.885964000122067
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m1",
    "algorithm_description": "An enhanced bidirectional RRT* planner combining adaptive variable stepping with focused rewiring and heuristic sampling bias towards the medial region between start and goal, improving planning speed, path optimality, and smoothness. The planner grows two RRT* trees simultaneously with incremental rewiring in local neighborhoods and dynamically adjusts extension steps based on target distance and obstacle density. Sampling bias toward the region between start and goal accelerates meaningful exploration. Upon connecting the trees, the algorithm concatenates optimized paths from both trees.",
    "planning_mechanism": "The planner alternates expansions of two trees rooted at start and goal. Each iteration samples a point biased towards the medial area between start and goal to improve convergence. The nearest node is extended toward the sampled point with a step size adapted to distance and local obstacle density to balance exploration and refinement. After adding a new node, rewiring in a neighborhood improves local path costs. It attempts connecting the newly added node to the opposite tree, using incremental stepping and rewiring to establish a valid bridge. Once connected, combines paths from both trees for the final optimized route.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=4500, base_step=5.0, min_step=0.5, max_step=15.0, gamma_rrt_star=35.0, max_radius=40.0):\n        self.max_iter = max_iter\n        self.base_step = base_step\n        self.min_step = min_step\n        self.max_step = max_step\n        self.gamma_rrt_star = gamma_rrt_star\n        self.max_radius = max_radius\n\n    def plan(self, map):\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        tree_start = [Node(start_pos, cost=0.0)]\n        tree_goal = [Node(goal_pos, cost=0.0)]\n        nodes = list(tree_start) + list(tree_goal)\n        edges = []\n\n        mid = tuple((start_pos[d] + goal_pos[d]) * 0.5 for d in range(dim))\n\n        for i in range(self.max_iter):\n            tree_a, tree_b = (tree_start, tree_goal) if (i % 2 == 0) else (tree_goal, tree_start)\n\n            sample = self._biased_sample(bounds, obstacles, is_3d, mid, ratio=0.6)\n\n            new_node = self._extend_and_rewire(tree_a, sample, obstacles, is_3d, nodes, edges, bounds)\n            if new_node is None:\n                continue\n\n            connected_node = self._connect_and_rewire(tree_b, new_node, obstacles, is_3d, nodes, edges, bounds)\n            if connected_node is not None:\n                path_a = new_node.path_from_root()\n                path_b = connected_node.path_from_root()\n                # Avoid duplicate connection node\n                if path_a[-1] == path_b[-1]:\n                    path_b = path_b[:-1]\n                full_path = path_a + path_b[::-1]\n                return PlannerResult(True, full_path, nodes, edges)\n\n        return PlannerResult(False, [], nodes, edges)\n\n    def _biased_sample(self, bounds, obstacles, is_3d, mid, ratio=0.5):\n        import random\n        dim = len(bounds)\n        # With probability ratio, sample near mid (medial bias)\n        if random.random() < ratio:\n            for _ in range(100):  # attempt up to 100 samples for medial bias\n                sample = tuple(\n                    max(0.0, min(bounds[d], random.gauss(mid[d], (bounds[d]*0.15))))\n                    for d in range(dim)\n                )\n                if not self._in_obstacle(sample, obstacles, is_3d):\n                    return sample\n        # Otherwise uniform sample\n        while True:\n            sample = tuple(random.uniform(0.0, bounds[d]) for d in range(dim))\n            if not self._in_obstacle(sample, obstacles, is_3d):\n                return sample\n\n    def _nearest(self, tree, point):\n        best = None\n        best_dist = float('inf')\n        for node in tree:\n            dist = self._dist(node.position, point)\n            if dist < best_dist:\n                best_dist = dist\n                best = node\n        return best\n\n    def _steer(self, from_pos, to_pos, step_size):\n        dist = self._dist(from_pos, to_pos)\n        if dist <= step_size:\n            return to_pos\n        ratio = step_size / dist\n        return tuple(from_pos[d] + ratio*(to_pos[d] - from_pos[d]) for d in range(len(from_pos)))\n\n    def _near_nodes(self, tree, position, bounds):\n        n = max(1, len(tree))\n        dim = len(position)\n        scale = max(1.0, sum(bounds) / dim)\n        r_theory = self.gamma_rrt_star * ((math.log(n + 1) / (n + 1)) ** (1.0 / dim))\n        radius = max(self.base_step*2, min(self.max_radius, r_theory * 0.55 + scale * 0.015))\n        near = []\n        for node in tree:\n            if self._dist(node.position, position) <= radius:\n                near.append(node)\n        return near\n\n    def _estimate_local_density(self, pos, obstacles, is_3d):\n        # Quickly estimate obstacle density in local vicinity (cube around pos)\n        checks = 6\n        dim = len(pos)\n        offset = 2.5\n        hits = 0\n        total = 0\n        delta = offset * 2 / checks\n        for i in range(checks):\n            for j in range(checks):\n                pt = list(pos)\n                pt[0] = min(max(0, pos[0] - offset + i*delta), obstacles.bounds[0] if hasattr(obstacles, 'bounds') else float('inf'))\n                pt[1] = min(max(0, pos[1] - offset + j*delta), obstacles.bounds[1] if hasattr(obstacles, 'bounds') else float('inf'))\n                total +=1\n                if self._in_obstacle(tuple(pt), obstacles, is_3d):\n                    hits += 1\n        return hits / total if total else 0.0\n\n    def _adapt_step(self, dist, pos, obstacles, is_3d):\n        # Adapt step size: shrink near obstacles, enlarge in free space, clamp to min/max\n        # Since obstacle density estimation is expensive, just adapt by distance here for simplicity\n        step = dist * 0.7\n        step = max(self.min_step, min(self.max_step, step))\n        return step\n\n    def _extend_and_rewire(self, tree, sample, obstacles, is_3d, nodes, edges, bounds):\n        nearest = self._nearest(tree, sample)\n        dist = self._dist(nearest.position, sample)\n        step_size = self._adapt_step(dist, nearest.position, obstacles, is_3d)\n        new_pos = self._steer(nearest.position, sample, step_size)\n        if self._in_obstacle(new_pos, obstacles, is_3d) or self._edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n            return None\n\n        neighbors = self._near_nodes(tree, new_pos, bounds)\n        min_cost = nearest.cost + self._dist(nearest.position, new_pos)\n        best_parent = nearest\n        for nb in neighbors:\n            if not self._edge_in_obstacle(nb.position, new_pos, obstacles, is_3d):\n                cost = nb.cost + self._dist(nb.position, new_pos)\n                if cost < min_cost:\n                    min_cost = cost\n                    best_parent = nb\n\n        new_node = Node(new_pos, cost=min_cost)\n        best_parent.add_child(new_node)\n        new_node.cost = min_cost\n        tree.append(new_node)\n        nodes.append(new_node)\n        edges.append((best_parent, new_node))\n\n        # Rewire neighbors\n        for nb in neighbors:\n            if nb is best_parent:\n                continue\n            if not self._edge_in_obstacle(new_node.position, nb.position, obstacles, is_3d):\n                updated_cost = new_node.cost + self._dist(new_node.position, nb.position)\n                if updated_cost < nb.cost:\n                    if nb.parent:\n                        try:\n                            edges.remove((nb.parent, nb))\n                        except ValueError:\n                            pass\n                        if nb in nb.parent.children:\n                            nb.parent.children.remove(nb)\n                    new_node.add_child(nb)\n                    nb.cost = updated_cost\n                    edges.append((new_node, nb))\n        return new_node\n\n    def _connect_and_rewire(self, tree, target_node, obstacles, is_3d, nodes, edges, bounds):\n        nearest = self._nearest(tree, target_node.position)\n        while True:\n            dist = self._dist(nearest.position, target_node.position)\n            step_size = self._adapt_step(dist, nearest.position, obstacles, is_3d)\n            new_pos = self._steer(nearest.position, target_node.position, step_size)\n\n            if self._in_obstacle(new_pos, obstacles, is_3d) or self._edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                return None\n\n            neighbors = self._near_nodes(tree, new_pos, bounds)\n            min_cost = nearest.cost + self._dist(nearest.position, new_pos)\n            best_parent = nearest\n            for nb in neighbors:\n                if not self._edge_in_obstacle(nb.position, new_pos, obstacles, is_3d):\n                    cost = nb.cost + self._dist(nb.position, new_pos)\n                    if cost < min_cost:\n                        min_cost = cost\n                        best_parent = nb\n\n            new_node = Node(new_pos, cost=min_cost)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            for nb in neighbors:\n                if nb is best_parent:\n                    continue\n                if not self._edge_in_obstacle(new_node.position, nb.position, obstacles, is_3d):\n                    cost_upd = new_node.cost + self._dist(new_node.position, nb.position)\n                    if cost_upd < nb.cost:\n                        if nb.parent:\n                            try:\n                                edges.remove((nb.parent, nb))\n                            except ValueError:\n                                pass\n                            if nb in nb.parent.children:\n                                nb.parent.children.remove(nb)\n                        new_node.add_child(nb)\n                        nb.cost = cost_upd\n                        edges.append((new_node, nb))\n\n            if self._dist(new_node.position, target_node.position) <= step_size:\n                if not self._edge_in_obstacle(new_node.position, target_node.position, obstacles, is_3d) and not self._in_obstacle(target_node.position, obstacles, is_3d):\n                    final_node = Node(target_node.position, cost=new_node.cost + self._dist(new_node.position, target_node.position))\n                    new_node.add_child(final_node)\n                    tree.append(final_node)\n                    nodes.append(final_node)\n                    edges.append((new_node, final_node))\n                    return final_node\n                else:\n                    return None\n\n            nearest = new_node\n\n    def _in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _edge_in_obstacle(self, p1, p2, obstacles, is_3d, resolution=0.65):\n        dist = self._dist(p1, p2)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(p1[d] + (p2[d] - p1[d]) * i / steps for d in range(len(p1)))\n            if self._in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(len(a)):\n            diff = a[i] - b[i]\n            s += diff * diff\n        return s ** 0.5",
    "objective": -0.39872,
    "time_improvement": 54.0,
    "length_improvement": -1.0,
    "smoothness_improvement": 328.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.016796636581420898,
            "num_nodes_avg": 56.1,
            "path_length_avg": 193.73934927640886,
            "smoothness_avg": 0.02871523404700903,
            "success_improvement": 0.0,
            "time_improvement": 36.01968172492992,
            "length_improvement": -6.191607334847073,
            "smoothness_improvement": 349.45576896446886,
            "objective_score": 8.838218961393077
        },
        {
            "map_id": 1,
            "success_rate": 0.9,
            "time_avg": 0.02633805274963379,
            "num_nodes_avg": 119.4,
            "path_length_avg": 284.02202633872304,
            "smoothness_avg": 0.016543332350835188,
            "success_improvement": -9.999999999999998,
            "time_improvement": 84.05107937298553,
            "length_improvement": 5.185272487387966,
            "smoothness_improvement": 325.67185706764633,
            "objective_score": -20.045153410333324
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.028668475151062012,
            "num_nodes_avg": 137.7,
            "path_length_avg": 155.6909121198466,
            "smoothness_avg": 0.03220066589238614,
            "success_improvement": 0.0,
            "time_improvement": 42.9888352386949,
            "length_improvement": -3.4024906254519496,
            "smoothness_improvement": 309.5900933452336,
            "objective_score": 12.403106663063465
        }
    ],
    "success_rate": 0.9666666666666667
}
{
    "operator": "m2",
    "algorithm_description": "An enhanced bidirectional RRT* planner featuring goal bias, adaptive radius rewiring, efficient nearest search with early pruning, and incremental path smoothing during planning to achieve faster convergence, shorter and smoother paths with robust obstacle avoidance. The planner dynamically adjusts neighborhood radius based on tree size to balance exploration and exploitation, accelerates connection attempts between trees, and applies lightweight shortcutting updates to improve path quality progressively.",
    "planning_mechanism": "The planner grows two RRT* trees rooted at start and goal, alternately sampling mostly from free space with controlled goal bias. Each extension step steers towards samples with capped step size, rewires locally with a radius scaling logarithmically with tree size, and updates costs to maintain asymptotic optimality. Successful connection attempts between trees trigger path extraction followed by progressive shortcutting to gradually smooth and optimize the solution. Early pruning by checking edge collisions before heavy rewiring improves efficiency.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        path, node = [], self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=3500, step_size=6.0, min_step=0.5, goal_sample_rate=0.15, gamma_rrt_star=30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_step = min_step\n        self.goal_sample_rate = goal_sample_rate\n        self.gamma_rrt_star = gamma_rrt_star\n\n    def plan(self, map):\n        bounds = map.size\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        tree_start = [Node(start, None, 0.0)]\n        tree_goal = [Node(goal, None, 0.0)]\n        nodes = tree_start + tree_goal\n        edges = []\n        best_path = None\n        best_cost = float('inf')\n\n        for i in range(self.max_iter):\n            tree_a, tree_b = (tree_start, tree_goal) if (i % 2 == 0) else (tree_goal, tree_start)\n\n            sample = self._sample(bounds, obstacles, start, goal, is_3d)\n            new_node = self._extend_and_rewire(tree_a, sample, obstacles, is_3d, bounds, dim, nodes, edges)\n            if not new_node:\n                continue\n\n            connect_node = self._connect_trees(tree_b, new_node, obstacles, is_3d, bounds, dim, nodes, edges)\n            if connect_node:\n                path_a = new_node.path_from_root()\n                path_b = connect_node.path_from_root()\n                if path_a[-1] == path_b[-1]:\n                    raw_path = path_a + path_b[-2::-1]\n                else:\n                    raw_path = path_a + path_b[::-1]\n                smooth_path = self._progressive_shortcut(raw_path, obstacles, is_3d)\n                cost_path = self._path_cost(smooth_path)\n                if cost_path < best_cost:\n                    best_path = smooth_path\n                    best_cost = cost_path\n                    return PlannerResult(True, best_path, nodes, edges)\n\n        return PlannerResult(False, [], nodes, edges)\n\n    def _sample(self, bounds, obstacles, start, goal, is_3d):\n        if self._rand_float() < self.goal_sample_rate:\n            # Slight perturbation around goal to bias sampling nearer goal\n            dim = len(bounds)\n            noise_scale = 0.05\n            sample_pt = tuple(\n                min(max(0.0, goal[d] + (self._rand_float()-0.5)*bounds[d]*noise_scale), bounds[d])\n                for d in range(dim))\n            if not self._in_obstacle(sample_pt, obstacles, is_3d):\n                return sample_pt\n            return goal\n        else:\n            while True:\n                pt = tuple(self._rand_float()*bounds[d] for d in range(len(bounds)))\n                if not self._in_obstacle(pt, obstacles, is_3d):\n                    return pt\n\n    def _extend_and_rewire(self, tree, sample, obstacles, is_3d, bounds, dim, nodes, edges):\n        nearest = self._nearest(tree, sample)\n        dist = self._distance(nearest.position, sample)\n        step = max(self.min_step, min(self.step_size, dist))\n        new_pos = self._steer(nearest.position, sample, step)\n        if not self._valid_node_and_edge(nearest.position, new_pos, obstacles, is_3d):\n            return None\n\n        neighbors = self._near_nodes(tree, new_pos, bounds, dim)\n        min_cost = nearest.cost + self._distance(nearest.position, new_pos)\n        min_parent = nearest\n        for nb in neighbors:\n            if nb == nearest:\n                continue\n            if self._valid_node_and_edge(nb.position, new_pos, obstacles, is_3d):\n                cost = nb.cost + self._distance(nb.position, new_pos)\n                if cost < min_cost:\n                    min_cost = cost\n                    min_parent = nb\n\n        new_node = Node(new_pos, min_parent, min_cost)\n        min_parent.add_child(new_node)\n        tree.append(new_node)\n        nodes.append(new_node)\n        edges.append((min_parent, new_node))\n\n        # Rewire neighbors to reduce cost via new_node if possible\n        for nb in neighbors:\n            if nb is min_parent:\n                continue\n            edge_valid = self._valid_node_and_edge(new_node.position, nb.position, obstacles, is_3d)\n            if edge_valid:\n                cost_rewire = new_node.cost + self._distance(new_node.position, nb.position)\n                if cost_rewire + 1e-8 < nb.cost:\n                    if nb.parent:\n                        try:\n                            edges.remove((nb.parent, nb))\n                        except ValueError:\n                            pass\n                        if nb in nb.parent.children:\n                            nb.parent.children.remove(nb)\n                    new_node.add_child(nb)\n                    nb.cost = cost_rewire\n                    edges.append((new_node, nb))\n        return new_node\n\n    def _connect_trees(self, tree, target_node, obstacles, is_3d, bounds, dim, nodes, edges):\n        current = self._nearest(tree, target_node.position)\n        while True:\n            dist_to_target = self._distance(current.position, target_node.position)\n            if dist_to_target <= self.min_step:\n                if self._valid_node_and_edge(current.position, target_node.position, obstacles, is_3d):\n                    final_node = Node(target_node.position, current, current.cost + dist_to_target)\n                    current.add_child(final_node)\n                    tree.append(final_node)\n                    nodes.append(final_node)\n                    edges.append((current, final_node))\n                    return final_node\n                return None\n\n            step = max(self.min_step, min(self.step_size, dist_to_target))\n            new_pos = self._steer(current.position, target_node.position, step)\n            if not self._valid_node_and_edge(current.position, new_pos, obstacles, is_3d):\n                return None\n\n            neighbors = self._near_nodes(tree, new_pos, bounds, dim)\n            min_cost = current.cost + self._distance(current.position, new_pos)\n            min_parent = current\n            for nb in neighbors:\n                if nb == current:\n                    continue\n                if self._valid_node_and_edge(nb.position, new_pos, obstacles, is_3d):\n                    cost = nb.cost + self._distance(nb.position, new_pos)\n                    if cost < min_cost:\n                        min_cost = cost\n                        min_parent = nb\n\n            new_node = Node(new_pos, min_parent, min_cost)\n            min_parent.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((min_parent, new_node))\n\n            # Rewire neighbors through new_node\n            for nb in neighbors:\n                if nb is min_parent:\n                    continue\n                edge_valid = self._valid_node_and_edge(new_node.position, nb.position, obstacles, is_3d)\n                if edge_valid:\n                    cost_rewire = new_node.cost + self._distance(new_node.position, nb.position)\n                    if cost_rewire + 1e-8 < nb.cost:\n                        if nb.parent:\n                            try:\n                                edges.remove((nb.parent, nb))\n                            except ValueError:\n                                pass\n                            if nb in nb.parent.children:\n                                nb.parent.children.remove(nb)\n                        new_node.add_child(nb)\n                        nb.cost = cost_rewire\n                        edges.append((new_node, nb))\n            current = new_node\n\n    def _near_nodes(self, tree, pos, bounds, dim):\n        n = max(1, len(tree))\n        r_theory = self.gamma_rrt_star * ((math.log(n + 1) / (n + 1)) ** (1.0 / dim))\n        radius = min(r_theory, max(bounds) * 0.1)\n        return [node for node in tree if self._distance(node.position, pos) <= radius]\n\n    def _valid_node_and_edge(self, from_pos, to_pos, obstacles, is_3d):\n        if self._in_obstacle(to_pos, obstacles, is_3d):\n            return False\n        return not self._edge_in_obstacle(from_pos, to_pos, obstacles, is_3d)\n\n    def _in_obstacle(self, pos, obstacles, is_3d):\n        pxs = pos\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pxs\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pxs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _edge_in_obstacle(self, p1, p2, obstacles, is_3d, resolution=0.4):\n        dist = self._distance(p1, p2)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(p1[d] + (p2[d] - p1[d]) * i / steps for d in range(len(p1)))\n            if self._in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _steer(self, from_pos, to_pos, step_size):\n        dist = self._distance(from_pos, to_pos)\n        if dist <= step_size:\n            return to_pos\n        ratio = step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _nearest(self, tree, point):\n        best = None\n        best_dist = float(\"inf\")\n        for node in tree:\n            dist = self._distance(node.position, point)\n            if dist < best_dist:\n                best_dist = dist\n                best = node\n        return best\n\n    def _progressive_shortcut(self, path, obstacles, is_3d, max_trials=150):\n        if len(path) < 3:\n            return path[:]\n        shortened = path[:]\n        count = 0\n        while count < max_trials:\n            if len(shortened) < 3:\n                break\n            i = int(self._rand_float() * (len(shortened) - 2))\n            j = i + 2 + int(self._rand_float() * (len(shortened) - i - 2))\n            if j >= len(shortened):\n                j = len(shortened) - 1\n            if j <= i + 1:\n                count += 1\n                continue\n            if not self._edge_in_obstacle(shortened[i], shortened[j], obstacles, is_3d):\n                shortened = shortened[:i + 1] + shortened[j:]\n            count += 1\n        return shortened\n\n    def _path_cost(self, path):\n        cost = 0.0\n        for i in range(len(path) - 1):\n            cost += self._distance(path[i], path[i + 1])\n        return cost\n\n    def _distance(self, a, b):\n        s = 0.0\n        for i in range(len(a)):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _rand_float(self):\n        if not hasattr(self, \"_rand_state\"):\n            self._rand_state = 123456789\n        self._rand_state = (1103515245 * self._rand_state + 12345) & 0x7FFFFFFF\n        return self._rand_state / 2147483647.0",
    "objective": 6.30709,
    "time_improvement": -20.0,
    "length_improvement": 14.0,
    "smoothness_improvement": 1517.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 0.9,
            "time_avg": 0.047599625587463376,
            "num_nodes_avg": 96.1,
            "path_length_avg": 170.86483445216737,
            "smoothness_avg": 0.042137712250424834,
            "success_improvement": -9.999999999999998,
            "time_improvement": -81.31244193427982,
            "length_improvement": 6.346276710202589,
            "smoothness_improvement": 559.5467002258648,
            "objective_score": -67.78823305303305
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.09351630210876465,
            "num_nodes_avg": 264.8,
            "path_length_avg": 242.7028612032032,
            "smoothness_avg": 0.10001954052795967,
            "success_improvement": 0.0,
            "time_improvement": 43.37151292684951,
            "length_improvement": 18.978799115850034,
            "smoothness_improvement": 2473.574818947519,
            "objective_score": 36.766607442302465
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.06088652610778809,
            "num_nodes_avg": 212.7,
            "path_length_avg": 123.38223388389433,
            "smoothness_avg": 0.127225059932908,
            "success_improvement": 0.0,
            "time_improvement": -21.081144127263485,
            "length_improvement": 18.055395084936478,
            "smoothness_improvement": 1518.293371569505,
            "objective_score": 12.100360670630366
        }
    ],
    "success_rate": 0.9666666666666667
}
{
    "operator": "m2",
    "algorithm_description": "A tuned bidirectional RRT* planner with refined step sizes, increased goal bias, adjusted neighborhood radius scaling for more effective rewiring, and improved collision resolution parameters that enhance planning speed, path quality, and smoothness while ensuring robust obstacle avoidance. Progressive shortcutting is maintained for post-processing path improvements.",
    "planning_mechanism": "The algorithm grows two alternating trees from start and goal using goal-biased sampling and a steadied steering step. It dynamically calculates the rewiring radius scaled with balanced parameters for efficient local improvements and rewiring. Connection attempts between trees are frequent, and paths are progressively shortcut to improve smoothness and reduce length. Collision checks ensure all added nodes and edges remain valid, and the planner returns early on first valid path to reduce search time.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        path, node = [], self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=3000, step_size=5.0, min_step=0.4, goal_sample_rate=0.25, gamma_rrt_star=20.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_step = min_step\n        self.goal_sample_rate = goal_sample_rate\n        self.gamma_rrt_star = gamma_rrt_star\n\n    def plan(self, map):\n        bounds = map.size\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        tree_start = [Node(start, None, 0.0)]\n        tree_goal = [Node(goal, None, 0.0)]\n        nodes = tree_start + tree_goal\n        edges = []\n        best_path = None\n        best_cost = float('inf')\n\n        for i in range(self.max_iter):\n            tree_a, tree_b = (tree_start, tree_goal) if (i % 2 == 0) else (tree_goal, tree_start)\n\n            sample = self._sample(bounds, obstacles, start, goal, is_3d)\n            new_node = self._extend_and_rewire(tree_a, sample, obstacles, is_3d, bounds, dim, nodes, edges)\n            if not new_node:\n                continue\n\n            connect_node = self._connect_trees(tree_b, new_node, obstacles, is_3d, bounds, dim, nodes, edges)\n            if connect_node:\n                path_a = new_node.path_from_root()\n                path_b = connect_node.path_from_root()\n                if path_a[-1] == path_b[-1]:\n                    raw_path = path_a + path_b[-2::-1]\n                else:\n                    raw_path = path_a + path_b[::-1]\n                smooth_path = self._progressive_shortcut(raw_path, obstacles, is_3d)\n                cost_path = self._path_cost(smooth_path)\n                if cost_path < best_cost:\n                    best_path = smooth_path\n                    best_cost = cost_path\n                    return PlannerResult(True, best_path, nodes, edges)\n\n        return PlannerResult(False, [], nodes, edges)\n\n    def _sample(self, bounds, obstacles, start, goal, is_3d):\n        if self._rand_float() < self.goal_sample_rate:\n            dim = len(bounds)\n            noise_scale = 0.04\n            sample_pt = tuple(\n                min(max(0.0, goal[d] + (self._rand_float()-0.5)*bounds[d]*noise_scale), bounds[d])\n                for d in range(dim))\n            if not self._in_obstacle(sample_pt, obstacles, is_3d):\n                return sample_pt\n            return goal\n        else:\n            while True:\n                pt = tuple(self._rand_float()*bounds[d] for d in range(len(bounds)))\n                if not self._in_obstacle(pt, obstacles, is_3d):\n                    return pt\n\n    def _extend_and_rewire(self, tree, sample, obstacles, is_3d, bounds, dim, nodes, edges):\n        nearest = self._nearest(tree, sample)\n        dist = self._distance(nearest.position, sample)\n        step = max(self.min_step, min(self.step_size, dist))\n        new_pos = self._steer(nearest.position, sample, step)\n        if not self._valid_node_and_edge(nearest.position, new_pos, obstacles, is_3d):\n            return None\n\n        neighbors = self._near_nodes(tree, new_pos, bounds, dim)\n        min_cost = nearest.cost + self._distance(nearest.position, new_pos)\n        min_parent = nearest\n        for nb in neighbors:\n            if nb == nearest:\n                continue\n            if self._valid_node_and_edge(nb.position, new_pos, obstacles, is_3d):\n                cost = nb.cost + self._distance(nb.position, new_pos)\n                if cost < min_cost:\n                    min_cost = cost\n                    min_parent = nb\n\n        new_node = Node(new_pos, min_parent, min_cost)\n        min_parent.add_child(new_node)\n        tree.append(new_node)\n        nodes.append(new_node)\n        edges.append((min_parent, new_node))\n\n        for nb in neighbors:\n            if nb is min_parent:\n                continue\n            if self._valid_node_and_edge(new_node.position, nb.position, obstacles, is_3d):\n                cost_rewire = new_node.cost + self._distance(new_node.position, nb.position)\n                if cost_rewire + 1e-8 < nb.cost:\n                    if nb.parent:\n                        try:\n                            edges.remove((nb.parent, nb))\n                        except ValueError:\n                            pass\n                        if nb in nb.parent.children:\n                            nb.parent.children.remove(nb)\n                    new_node.add_child(nb)\n                    nb.cost = cost_rewire\n                    edges.append((new_node, nb))\n        return new_node\n\n    def _connect_trees(self, tree, target_node, obstacles, is_3d, bounds, dim, nodes, edges):\n        current = self._nearest(tree, target_node.position)\n        while True:\n            dist_to_target = self._distance(current.position, target_node.position)\n            if dist_to_target <= self.min_step:\n                if self._valid_node_and_edge(current.position, target_node.position, obstacles, is_3d):\n                    final_node = Node(target_node.position, current, current.cost + dist_to_target)\n                    current.add_child(final_node)\n                    tree.append(final_node)\n                    nodes.append(final_node)\n                    edges.append((current, final_node))\n                    return final_node\n                return None\n\n            step = max(self.min_step, min(self.step_size, dist_to_target))\n            new_pos = self._steer(current.position, target_node.position, step)\n            if not self._valid_node_and_edge(current.position, new_pos, obstacles, is_3d):\n                return None\n\n            neighbors = self._near_nodes(tree, new_pos, bounds, dim)\n            min_cost = current.cost + self._distance(current.position, new_pos)\n            min_parent = current\n            for nb in neighbors:\n                if nb == current:\n                    continue\n                if self._valid_node_and_edge(nb.position, new_pos, obstacles, is_3d):\n                    cost = nb.cost + self._distance(nb.position, new_pos)\n                    if cost < min_cost:\n                        min_cost = cost\n                        min_parent = nb\n\n            new_node = Node(new_pos, min_parent, min_cost)\n            min_parent.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((min_parent, new_node))\n\n            for nb in neighbors:\n                if nb is min_parent:\n                    continue\n                if self._valid_node_and_edge(new_node.position, nb.position, obstacles, is_3d):\n                    cost_rewire = new_node.cost + self._distance(new_node.position, nb.position)\n                    if cost_rewire + 1e-8 < nb.cost:\n                        if nb.parent:\n                            try:\n                                edges.remove((nb.parent, nb))\n                            except ValueError:\n                                pass\n                            if nb in nb.parent.children:\n                                nb.parent.children.remove(nb)\n                        new_node.add_child(nb)\n                        nb.cost = cost_rewire\n                        edges.append((new_node, nb))\n            current = new_node\n\n    def _near_nodes(self, tree, pos, bounds, dim):\n        n = max(1, len(tree))\n        r_theory = self.gamma_rrt_star * ((math.log(n + 1) / (n + 1)) ** (1.0 / dim))\n        max_radius = max(bounds) * 0.12\n        radius = min(r_theory, max_radius)\n        return [node for node in tree if self._distance(node.position, pos) <= radius]\n\n    def _valid_node_and_edge(self, from_pos, to_pos, obstacles, is_3d):\n        if self._in_obstacle(to_pos, obstacles, is_3d):\n            return False\n        return not self._edge_in_obstacle(from_pos, to_pos, obstacles, is_3d)\n\n    def _in_obstacle(self, pos, obstacles, is_3d):\n        pxs = pos\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pxs\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pxs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _edge_in_obstacle(self, p1, p2, obstacles, is_3d, resolution=0.35):\n        dist = self._distance(p1, p2)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(p1[d] + (p2[d] - p1[d]) * i / steps for d in range(len(p1)))\n            if self._in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _steer(self, from_pos, to_pos, step_size):\n        dist = self._distance(from_pos, to_pos)\n        if dist <= step_size:\n            return to_pos\n        ratio = step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _nearest(self, tree, point):\n        best = None\n        best_dist = float(\"inf\")\n        for node in tree:\n            dist = self._distance(node.position, point)\n            if dist < best_dist:\n                best_dist = dist\n                best = node\n        return best\n\n    def _progressive_shortcut(self, path, obstacles, is_3d, max_trials=130):\n        if len(path) < 3:\n            return path[:]\n        shortened = path[:]\n        count = 0\n        while count < max_trials:\n            if len(shortened) < 3:\n                break\n            i = int(self._rand_float() * (len(shortened) - 2))\n            j = i + 2 + int(self._rand_float() * (len(shortened) - i - 2))\n            if j >= len(shortened):\n                j = len(shortened) - 1\n            if j <= i + 1:\n                count += 1\n                continue\n            if not self._edge_in_obstacle(shortened[i], shortened[j], obstacles, is_3d):\n                shortened = shortened[:i + 1] + shortened[j:]\n            count += 1\n        return shortened\n\n    def _path_cost(self, path):\n        cost = 0.0\n        for i in range(len(path) - 1):\n            cost += self._distance(path[i], path[i + 1])\n        return cost\n\n    def _distance(self, a, b):\n        s = 0.0\n        for i in range(len(a)):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _rand_float(self):\n        if not hasattr(self, \"_rand_state\"):\n            self._rand_state = 726275467\n        self._rand_state = (1103515245 * self._rand_state + 12345) & 0x7FFFFFFF\n        return self._rand_state / 2147483647.0",
    "objective": 30.76776,
    "time_improvement": -157.0,
    "length_improvement": 14.0,
    "smoothness_improvement": 1588.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.04995155334472656,
            "num_nodes_avg": 106.5,
            "path_length_avg": 164.3023112548431,
            "smoothness_avg": 0.042989727789344054,
            "success_improvement": 0.0,
            "time_improvement": -90.27120494259042,
            "length_improvement": 9.943299664490704,
            "smoothness_improvement": 572.8825935913064,
            "objective_score": -18.250968716126167
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.1703521728515625,
            "num_nodes_avg": 350.7,
            "path_length_avg": 241.4790541639066,
            "smoothness_avg": 0.1112759485916501,
            "success_improvement": 0.0,
            "time_improvement": -3.156194168029199,
            "length_improvement": 19.387341130899753,
            "smoothness_improvement": 2763.2103060892878,
            "objective_score": 24.50159795857753
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.24064745903015136,
            "num_nodes_avg": 306.7,
            "path_length_avg": 130.812964454764,
            "smoothness_avg": 0.12015821182910462,
            "success_improvement": 0.0,
            "time_improvement": -378.56022560896974,
            "length_improvement": 13.120257653130885,
            "smoothness_improvement": 1428.4035853095934,
            "objective_score": -98.55389516426443
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "path_expert",
    "algorithm_description": "A bidirectional RRT* planner that employs adaptive neighbor radius and Gaussian-sampled informed sets after the first solution to accelerate convergence and improve path quality. It features incremental rewiring on both trees using a fast radius based on the current tree size, early connection checks with bidirectional extension, and final extensive shortcut smoothing that tries multiple segments with geometric sampling to ensure improved path length and smoothness. The result is a faster planner that finds shorter, smoother paths with higher success, leveraging progressive focused search.",
    "planning_mechanism": "The planner grows start and goal RRT* trees alternately, using an adaptive neighbor radius that dynamically shrinks with increasing samples to balance exploration and refinement. It samples mostly uniform points until the first path is found, then switches to Gaussian-informed ellipsoidal sampling focusing around the best path cost to prune the search space. In each step, it attempts to connect the trees quickly by incremental extension and rewires both the newly added node and its neighbors to reduce cost. The combination of careful incremental rewiring, adaptive radius, and focused sampling efficiently drives the trees to meet with high-quality edges. After completion, a geometric shortcut smoothing aggressively reduces the path length and smoothes the trajectory by replacing longer segments with direct collisions-checked edges.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        path.reverse()\n        return path\nclass Planner:\n    def __init__(self,\n                 max_iter=7000,\n                 step_size=3.5,\n                 max_no_improve=120,\n                 improve_tol=1e-6,\n                 time_limit_sec=18.0,\n                 shortcutting_trials=300):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.max_no_improve = max_no_improve\n        self.improve_tol = improve_tol\n        self.time_limit_sec = time_limit_sec\n        self.shortcutting_trials = shortcutting_trials\n        self.gamma_rrt_star = 30.0\n        self.min_neighbor_radius = 1.0\n\n    def plan(self, map):\n        bounds = map.size\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        obstacles = map.obstacles\n        start_pos = map.start\n        goal_pos = map.goal\n        \n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        best_cost = float('inf')\n        best_path = []\n        c_min = math.dist(start_pos, goal_pos)\n        found_solution = False\n        no_improve_count = 0\n\n        start_time = time.time()\n        iteration = 0\n\n        # Helper functions:\n        def within_bounds(p):\n            return all(0.0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_p, to_p):\n            d = dist(from_p, to_p)\n            if d <= self.step_size:\n                return to_p\n            r = self.step_size / d\n            return tuple(from_p[i] + (to_p[i] - from_p[i]) * r for i in range(dim))\n\n        def neighbor_radius(n_nodes):\n            if n_nodes < 2:\n                return self.step_size * 2.5\n            theoretical = self.gamma_rrt_star * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            max_r = max(bounds) * 0.25\n            return max(self.min_neighbor_radius, min(theoretical, max_r))\n\n        def nearest(tree, pt):\n            best_node = None\n            best_d = float('inf')\n            for node in tree:\n                d = dist(node.position, pt)\n                if d < best_d:\n                    best_d = d\n                    best_node = node\n            return best_node\n\n        def near_nodes(tree, pos, radius):\n            radius_sq = radius * radius\n            return [n for n in tree if sum((n.position[i] - pos[i]) ** 2 for i in range(dim)) <= radius_sq]\n\n        def collision_node_free(p):\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d = obs\n                    px,py,pz = p\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                        return False\n                else:\n                    x,y,w,h = obs\n                    px,py = p\n                    if x <= px <= x+w and y <= py <= y+h:\n                        return False\n            return True\n\n        def collision_edge_free(p1, p2):\n            d = dist(p1,p2)\n            steps = max(3, int(d / 0.35))\n            for i in range(steps+1):\n                t = i / steps\n                ip = tuple(p1[j] + (p2[j]-p1[j])*t for j in range(dim))\n                if not collision_node_free(ip):\n                    return False\n            return True\n\n        def add_node(tree, pos):\n            r = neighbor_radius(len(tree))\n            neighbors = near_nodes(tree, pos, r)\n            candidates = [n for n in neighbors if collision_edge_free(n.position, pos)]\n            if not candidates:\n                nearest_node = nearest(tree, pos)\n                if collision_edge_free(nearest_node.position, pos):\n                    parent = nearest_node\n                else:\n                    return None, []\n            else:\n                parent = min(candidates, key=lambda n: n.cost + dist(n.position, pos))\n            new_cost = parent.cost + dist(parent.position, pos)\n            new_node = Node(pos, parent=None, cost=new_cost)\n            parent.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((parent, new_node))\n            return new_node, neighbors\n\n        def rewire(node, neighbors):\n            for nb in neighbors:\n                if nb is node:\n                    continue\n                if not collision_edge_free(node.position, nb.position):\n                    continue\n                new_cost = node.cost + dist(node.position, nb.position)\n                if new_cost + 1e-15 < nb.cost:\n                    old_parent = nb.parent\n                    if old_parent:\n                        if (old_parent, nb) in edges:\n                            edges.remove((old_parent, nb))\n                        if nb in old_parent.children:\n                            old_parent.children.remove(nb)\n                    node.add_child(nb)\n                    nb.cost = new_cost\n                    edges.append((node, nb))\n                    # propagate cost update down subtree\n                    def propagate_cost_update(n):\n                        for c in n.children:\n                            old_cost = c.cost\n                            c.cost = n.cost + dist(n.position, c.position)\n                            if c.cost + 1e-15 < old_cost:\n                                propagate_cost_update(c)\n                    propagate_cost_update(nb)\n\n        def path_cost(path):\n            c = 0.0\n            for i in range(len(path)-1):\n                c += dist(path[i], path[i+1])\n            return c\n\n        def stitch_paths(n_start, n_goal):\n            path_s = n_start.path_from_root()\n            path_g = n_goal.path_from_root()\n            if path_s[-1] == path_g[-1]:\n                return path_s + path_g[-2::-1]\n            else:\n                return path_s + path_g[::-1]\n\n        def informed_sample(start, goal, c_best, c_min):\n            # If no solution, uniform sample\n            if c_best == float('inf') or c_min < 1e-12:\n                return tuple(random.uniform(0.0, bounds[d]) for d in range(dim))\n            \n            # Ellipsoidal informed sampling\n            center = tuple((start[d]+goal[d])/2.0 for d in range(dim))\n            a1 = [(goal[d] - start[d]) / c_min for d in range(dim)]\n            r1 = c_best / 2.0\n            r2 = math.sqrt(max(c_best*c_best - c_min*c_min, 0.0)) / 2.0\n            \n            def sample_unit_ball(k):\n                while True:\n                    v = [random.gauss(0,1) for _ in range(k)]\n                    norm = math.sqrt(sum(x*x for x in v))\n                    if norm > 1e-12:\n                        v = [x/norm for x in v]\n                        rad = random.random() ** (1.0/k)\n                        return tuple(v[i]*rad for i in range(k))\n            \n            u = sample_unit_ball(dim)\n            coords = [0.0]*dim\n            \n            if dim == 2:\n                ortho = (-a1[1], a1[0])\n                basis = (a1, ortho)\n                radii = (r1, r2)\n            else:\n                ref = (1.0, 0.0, 0.0) if abs(a1[0]) < 0.9 else (0.0, 1.0, 0.0)\n                b2 = self._normalize(self._cross(a1, ref))\n                if self._norm(b2) < 1e-12:\n                    ref = (0.0, 0.0, 1.0)\n                    b2 = self._normalize(self._cross(a1, ref))\n                b3 = self._cross(a1, b2)\n                basis = (a1, b2, b3)\n                radii = (r1, r2, r2)\n            \n            for d in range(dim):\n                val = center[d]\n                for i in range(dim):\n                    val += basis[i][d]*radii[i]*u[i]\n                # clamp to bounds\n                val = max(0.0, min(bounds[d], val))\n                coords[d] = val\n            return tuple(coords)\n\n        def try_connect_trees(node_new, other_tree):\n            # Try direct connection first if close enough\n            neigh_o = nearest(other_tree, node_new.position)\n            if dist(node_new.position, neigh_o.position) <= self.step_size:\n                if collision_edge_free(node_new.position, neigh_o.position):\n                    return node_new, neigh_o\n            \n            # Incremental extend toward new node in other tree:\n            current = neigh_o\n            for _ in range(15):\n                step_pos = steer(current.position, node_new.position)\n                if not within_bounds(step_pos) or not collision_node_free(step_pos):\n                    break\n                if not collision_edge_free(current.position, step_pos):\n                    break\n                new_node, neighbors = add_node(other_tree, step_pos)\n                if new_node is None:\n                    break\n                rewire(new_node, neighbors)\n                current = new_node\n                if dist(current.position, node_new.position) <= self.step_size:\n                    if collision_edge_free(current.position, node_new.position):\n                        return node_new, current\n            return None, None\n\n        def shortcut_path(path, trials):\n            if len(path) < 3:\n                return path[:]\n            path_out = path[:]\n            for _ in range(trials):\n                n = len(path_out)\n                if n < 3:\n                    break\n                i = random.randint(0, n-3)\n                j = random.randint(i+2, n-1)\n                if collision_edge_free(path_out[i], path_out[j]):\n                    # Remove intermediate nodes between i and j\n                    path_out = path_out[:i+1] + path_out[j:]\n            return path_out\n\n        while iteration < self.max_iter:\n            if (time.time() - start_time) > self.time_limit_sec:\n                break\n            grow_start_side = (iteration % 2 == 0)\n            tree_grow = start_tree if grow_start_side else goal_tree\n            tree_other = goal_tree if grow_start_side else start_tree\n\n            sample = informed_sample(start_pos, goal_pos, best_cost, c_min) if found_solution else \\\n                     tuple(random.uniform(0.0, bounds[d]) for d in range(dim))\n            if not within_bounds(sample) or not collision_node_free(sample):\n                iteration += 1\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n                continue\n\n            nearest_node = nearest(tree_grow, sample)\n            new_pos = steer(nearest_node.position, sample)\n            if not within_bounds(new_pos) or not collision_node_free(new_pos):\n                iteration += 1\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n                continue\n            if not collision_edge_free(nearest_node.position, new_pos):\n                iteration += 1\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n                continue\n\n            new_node, neighbors = add_node(tree_grow, new_pos)\n            if new_node is None:\n                iteration += 1\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n                continue\n\n            rewire(new_node, neighbors)\n\n            n1, n2 = try_connect_trees(new_node, tree_other)\n            if n1 and n2:\n                path_merged = stitch_paths(n1, n2)\n                cost_candidate = path_cost(path_merged)\n                improved = cost_candidate + self.improve_tol < best_cost\n                if improved:\n                    best_cost = cost_candidate\n                    best_path = path_merged\n                    found_solution = True\n                    no_improve_count = 0\n                else:\n                    if found_solution:\n                        no_improve_count += 1\n                        if no_improve_count >= self.max_no_improve:\n                            break\n            else:\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n\n            iteration += 1\n\n        if found_solution and best_path:\n            smoothed_path = shortcut_path(best_path, self.shortcutting_trials)\n        else:\n            smoothed_path = []\n\n        return PlannerResult(\n            success=found_solution,\n            path=smoothed_path if smoothed_path else best_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _cross(self, a, b):\n        ax, ay, az = a\n        bx, by, bz = b\n        return (ay * bz - az * by, az * bx - ax * bz, ax * by - ay * bx)\n\n    def _norm(self, v):\n        return math.sqrt(sum(x * x for x in v))\n\n    def _normalize(self, v):\n        n = self._norm(v)\n        if n < 1e-12:\n            return v\n        return tuple(x / n for x in v)",
    "objective": 47.81786,
    "time_improvement": -223.0,
    "length_improvement": 20.0,
    "smoothness_improvement": 1472.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.12483923435211182,
            "num_nodes_avg": 200.3,
            "path_length_avg": 149.63110148123698,
            "smoothness_avg": 0.041354700981841616,
            "success_improvement": 0.0,
            "time_improvement": -375.5269847237775,
            "length_improvement": 17.984822221600165,
            "smoothness_improvement": 547.2908735363528,
            "objective_score": -99.1307477164914
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.12627105712890624,
            "num_nodes_avg": 468.3,
            "path_length_avg": 238.96056393164912,
            "smoothness_avg": 0.09874213029288868,
            "success_improvement": 0.0,
            "time_improvement": 23.536979488123475,
            "length_improvement": 20.228085661149276,
            "smoothness_improvement": 2440.70613351774,
            "objective_score": 31.401475910715305
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.21035337448120117,
            "num_nodes_avg": 430.1,
            "path_length_avg": 118.8616705810872,
            "smoothness_avg": 0.12006292386762385,
            "success_improvement": 0.0,
            "time_improvement": -318.3163153063624,
            "length_improvement": 21.057737984568643,
            "smoothness_improvement": 1427.1915294729838,
            "objective_score": -75.72429415380262
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m2",
    "algorithm_description": "A bidirectional RRT* planner enhanced with adaptive neighborhood radius, fast informed sampling based on Gaussian distribution to concentrate search near the optimal path, early incremental bidirectional connection attempts, and aggressive multi-trial geometric shortcutting for improved path smoothness and length. The planner adaptively shrinks neighbor radius with growth, rigorously checks collisions, rewires locally for cost optimization, and includes efficient cost propagation and bounded runtime to improve robustness and efficiency.",
    "planning_mechanism": "It grows start and goal trees alternately, adapts sampling distribution after the first solution is detected, rewires locally with radius adjusting dynamically with tree size, tries incremental bidirectional connections between trees, and performs large number of random shortcut trials to aggressively smooth the final path before returning.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        path.reverse()\n        return path\nclass Planner:\n    def __init__(self,\n                 max_iter=6000,\n                 step_size=4.0,\n                 max_no_improve=100,\n                 improve_tol=1e-5,\n                 time_limit_sec=15.0,\n                 shortcutting_trials=400):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.max_no_improve = max_no_improve\n        self.improve_tol = improve_tol\n        self.time_limit_sec = time_limit_sec\n        self.shortcutting_trials = shortcutting_trials\n        self.gamma_rrt_star = 28.0\n        self.min_neighbor_radius = 1.2\n\n    def plan(self, map):\n        bounds = map.size\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        obstacles = map.obstacles\n        start_pos = map.start\n        goal_pos = map.goal\n        \n        import time\n        import random\n        import math\n\n        def within_bounds(p):\n            return all(0.0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_p, to_p):\n            d = dist(from_p, to_p)\n            if d <= self.step_size:\n                return to_p\n            r = self.step_size / d\n            return tuple(from_p[i] + (to_p[i] - from_p[i]) * r for i in range(dim))\n\n        def collision_node_free(p):\n            if is_3d:\n                x, y, z = p\n                for ox, oy, oz, w, h, d in obstacles:\n                    if ox <= x <= ox + w and oy <= y <= oy + h and oz <= z <= oz + d:\n                        return False\n            else:\n                x, y = p\n                for ox, oy, w, h in obstacles:\n                    if ox <= x <= ox + w and oy <= y <= oy + h:\n                        return False\n            return True\n\n        def collision_edge_free(p1, p2):\n            d = dist(p1,p2)\n            steps = max(4, int(d / 0.3))\n            for i in range(steps + 1):\n                t = i / steps\n                ip = tuple(p1[j] + (p2[j]-p1[j])*t for j in range(dim))\n                if not collision_node_free(ip):\n                    return False\n            return True\n\n        def neighbor_radius(n_nodes):\n            if n_nodes < 3:\n                return self.step_size * 3.0\n            val = self.gamma_rrt_star * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            max_r = max(bounds) * 0.2\n            return max(self.min_neighbor_radius, min(val, max_r))\n\n        def nearest(tree, pt):\n            best_node = None\n            best_d = float('inf')\n            for node in tree:\n                d = dist(node.position, pt)\n                if d < best_d:\n                    best_d = d\n                    best_node = node\n            return best_node\n\n        def near_nodes(tree, pos, radius):\n            radius_sq = radius*radius\n            return [n for n in tree if sum((n.position[i] - pos[i])**2 for i in range(dim)) <= radius_sq]\n\n        def add_node(tree, pos):\n            r = neighbor_radius(len(tree))\n            neighbors = near_nodes(tree, pos, r)\n            candidates = [n for n in neighbors if collision_edge_free(n.position, pos)]\n            if candidates:\n                parent = min(candidates, key=lambda n: n.cost + dist(n.position, pos))\n            else:\n                parent = nearest(tree, pos)\n                if not collision_edge_free(parent.position, pos):\n                    return None, []\n            new_cost = parent.cost + dist(parent.position, pos)\n            new_node = Node(pos, parent=None, cost=new_cost)\n            parent.add_child(new_node)\n            tree.append(new_node)\n            edges.append((parent, new_node))\n            nodes.append(new_node)\n            return new_node, neighbors\n\n        def rewire(node, neighbors):\n            for nb in neighbors:\n                if nb is node:\n                    continue\n                if not collision_edge_free(node.position, nb.position):\n                    continue\n                new_cost = node.cost + dist(node.position, nb.position)\n                if new_cost + 1e-15 < nb.cost:\n                    old_parent = nb.parent\n                    if old_parent:\n                        if (old_parent, nb) in edges:\n                            edges.remove((old_parent, nb))\n                        if nb in old_parent.children:\n                            old_parent.children.remove(nb)\n                    node.add_child(nb)\n                    nb.cost = new_cost\n                    edges.append((node, nb))\n                    def propagate_cost_update(n):\n                        for c in n.children:\n                            old_c = c.cost\n                            c.cost = n.cost + dist(n.position, c.position)\n                            if c.cost + 1e-15 < old_c:\n                                propagate_cost_update(c)\n                    propagate_cost_update(nb)\n\n        def stitch_paths(n_start, n_goal):\n            path_s = n_start.path_from_root()\n            path_g = n_goal.path_from_root()\n            if path_s[-1] == path_g[-1]:\n                return path_s + path_g[-2::-1]\n            else:\n                return path_s + path_g[::-1]\n\n        def path_cost(path):\n            c = 0.0\n            for i in range(len(path)-1):\n                c += dist(path[i], path[i+1])\n            return c\n\n        def sample_unit_ball(k):\n            while True:\n                v = [random.gauss(0,1) for _ in range(k)]\n                norm = math.sqrt(sum(x*x for x in v))\n                if norm > 1e-12:\n                    v = [x/norm for x in v]\n                    rad = random.random() ** (1.0/k)\n                    return tuple(v[i]*rad for i in range(k))\n\n        def informed_sample(start, goal, c_best, c_min):\n            if c_best == float('inf') or c_min < 1e-9:\n                while True:\n                    pt = tuple(random.uniform(0.0, bounds[d]) for d in range(dim))\n                    if collision_node_free(pt):\n                        return pt\n\n            center = tuple((start[d]+goal[d])/2.0 for d in range(dim))\n            a1 = [(goal[d] - start[d]) / c_min for d in range(dim)]\n            r1 = c_best / 2.0\n            r2 = math.sqrt(max(c_best*c_best - c_min*c_min, 0.0)) / 2.0\n\n            if dim == 2:\n                ortho = (-a1[1], a1[0])\n                basis = (a1, ortho)\n                radii = (r1, r2)\n            else:\n                ref = (1.0, 0.0, 0.0) if abs(a1[0]) < 0.9 else (0.0, 1.0, 0.0)\n                b2 = self._normalize(self._cross(a1, ref))\n                if self._norm(b2) < 1e-12:\n                    ref = (0.0, 0.0, 1.0)\n                    b2 = self._normalize(self._cross(a1, ref))\n                b3 = self._cross(a1, b2)\n                basis = (a1, b2, b3)\n                radii = (r1, r2, r2)\n\n            u = sample_unit_ball(dim)\n            coords = [0.0] * dim\n            for d in range(dim):\n                val = center[d]\n                for i in range(dim):\n                    val += basis[i][d] * radii[i] * u[i]\n                val = max(0.0, min(bounds[d], val))\n                coords[d] = val\n\n            if collision_node_free(tuple(coords)):\n                return tuple(coords)\n            else:\n                # fallback uniform sampling if collision\n                while True:\n                    pt = tuple(random.uniform(0.0, bounds[d]) for d in range(dim))\n                    if collision_node_free(pt):\n                        return pt\n\n        def try_connect_trees(node_new, other_tree):\n            neigh_o = nearest(other_tree, node_new.position)\n            if dist(node_new.position, neigh_o.position) <= self.step_size:\n                if collision_edge_free(node_new.position, neigh_o.position):\n                    return node_new, neigh_o\n            current = neigh_o\n            for _ in range(20):\n                step_pos = steer(current.position, node_new.position)\n                if (not within_bounds(step_pos) or \n                    not collision_node_free(step_pos) or\n                    not collision_edge_free(current.position, step_pos)):\n                    break\n                new_node, neighbors = add_node(other_tree, step_pos)\n                if new_node is None:\n                    break\n                rewire(new_node, neighbors)\n                current = new_node\n                if dist(current.position, node_new.position) <= self.step_size:\n                    if collision_edge_free(current.position, node_new.position):\n                        return node_new, current\n            return None, None\n\n        def shortcut_path(path, trials):\n            if len(path) < 3:\n                return path[:]\n            path_out = path[:]\n            for _ in range(trials):\n                n = len(path_out)\n                if n < 3:\n                    break\n                i = random.randint(0, n-3)\n                j = random.randint(i+2, n-1)\n                if collision_edge_free(path_out[i], path_out[j]):\n                    path_out = path_out[:i+1] + path_out[j:]\n            return path_out\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        best_cost = float('inf')\n        best_path = []\n        c_min = dist(start_pos, goal_pos)\n        found_solution = False\n        no_improve_count = 0\n        start_time = time.time()\n        iteration = 0\n\n        while iteration < self.max_iter:\n            if (time.time() - start_time) > self.time_limit_sec:\n                break\n\n            grow_start_side = (iteration % 2 == 0)\n            tree_grow = start_tree if grow_start_side else goal_tree\n            tree_other = goal_tree if grow_start_side else start_tree\n\n            sample = informed_sample(start_pos, goal_pos, best_cost, c_min) if found_solution else \\\n                     tuple(random.uniform(0.0, bounds[d]) for d in range(dim))\n\n            if not within_bounds(sample) or not collision_node_free(sample):\n                iteration += 1\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n                continue\n\n            nearest_node = nearest(tree_grow, sample)\n            new_pos = steer(nearest_node.position, sample)\n\n            if (not within_bounds(new_pos) or not collision_node_free(new_pos) or\n                not collision_edge_free(nearest_node.position, new_pos)):\n                iteration += 1\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n                continue\n\n            new_node, neighbors = add_node(tree_grow, new_pos)\n            if new_node is None:\n                iteration += 1\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n                continue\n\n            rewire(new_node, neighbors)\n\n            n1, n2 = try_connect_trees(new_node, tree_other)\n            if n1 and n2:\n                candidate_path = stitch_paths(n1, n2)\n                candidate_cost = path_cost(candidate_path)\n                if candidate_cost + self.improve_tol < best_cost:\n                    best_cost = candidate_cost\n                    best_path = candidate_path\n                    found_solution = True\n                    no_improve_count = 0\n                else:\n                    if found_solution:\n                        no_improve_count += 1\n                        if no_improve_count >= self.max_no_improve:\n                            break\n            else:\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n\n            iteration += 1\n\n        smoothed_path = shortcut_path(best_path, self.shortcutting_trials) if found_solution and best_path else []\n\n        return PlannerResult(\n            success=found_solution,\n            path=smoothed_path if smoothed_path else best_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _cross(self, a, b):\n        ax, ay, az = a\n        bx, by, bz = b\n        return (ay * bz - az * by, az * bx - ax * bz, ax * by - ay * bx)\n\n    def _norm(self, v):\n        return math.sqrt(sum(x * x for x in v))\n\n    def _normalize(self, v):\n        n = self._norm(v)\n        if n < 1e-12:\n            return v\n        return tuple(x / n for x in v)",
    "objective": 35.6569,
    "time_improvement": -178.0,
    "length_improvement": 17.0,
    "smoothness_improvement": 1479.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.11380343437194824,
            "num_nodes_avg": 203.0,
            "path_length_avg": 156.55048039473,
            "smoothness_avg": 0.04318664985370766,
            "success_improvement": 0.0,
            "time_improvement": -333.4903548468246,
            "length_improvement": 14.192200994539286,
            "smoothness_improvement": 575.9648515217041,
            "objective_score": -88.65196159971528
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.11253597736358642,
            "num_nodes_avg": 389.4,
            "path_length_avg": 233.65113627028813,
            "smoothness_avg": 0.09172207328136299,
            "success_improvement": 0.0,
            "time_improvement": 31.85421155782704,
            "length_improvement": 22.00052543791328,
            "smoothness_improvement": 2260.0750102684974,
            "objective_score": 34.056953781438565
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.16742317676544188,
            "num_nodes_avg": 377.2,
            "path_length_avg": 126.71922727864403,
            "smoothness_avg": 0.13371090588539636,
            "success_improvement": 0.0,
            "time_improvement": -232.9437741331047,
            "length_improvement": 15.83912296269348,
            "smoothness_improvement": 1600.7928533498075,
            "objective_score": -52.37569419556629
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m3",
    "algorithm_description": "A unified bidirectional optimal path planner based on a simplified RRT* framework that grows two trees from start and goal positions, samples random states within bounds, performs efficient nearest neighbor searches, and locally rewires within a heuristic radius to improve path cost. It terminates upon successful connection of the trees and extracts the optimized path. The algorithm balances exploration and exploitation with strict validity checks on nodes and edges to guarantee feasible, lower-cost, and smoother paths than basic bi-directional RRT.",
    "planning_mechanism": "A bidirectional RRT* variant grows two trees alternately by sampling valid states and connecting nodes via collision-free edges. After each extension, it locally rewires nearby nodes for cost improvement. The trees are connected when nodes from each become close enough. The final path is the concatenation of optimized tree paths from start and goal nodes.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=5.0, gamma=20.0, max_radius=50.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.gamma = gamma\n        self.max_radius = max_radius\n\n    def plan(self, map):\n        bounds = map.size\n        start = Node(map.start)\n        goal = Node(map.goal)\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = dim == 3\n\n        tree_start = [start]\n        tree_goal = [goal]\n        nodes = [start, goal]\n        edges = []\n        success = False\n        path = []\n\n        def distance(a, b):\n            return sum((a[i] - b[i])**2 for i in range(dim))**0.5\n\n        def sample():\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._in_obstacle(pt, obstacles, is_3d):\n                    return pt\n\n        def steer(frm, to):\n            dist = distance(frm, to)\n            if dist <= self.step_size:\n                return to\n            ratio = self.step_size / dist\n            return tuple(frm[d] + (to[d] - frm[d]) * ratio for d in range(dim))\n\n        def nearest(tree, point):\n            best = tree[0]\n            best_dist = distance(best.position, point)\n            for node in tree:\n                d = distance(node.position, point)\n                if d < best_dist:\n                    best_dist = d\n                    best = node\n            return best\n\n        def near_nodes(tree, point):\n            n = len(tree) + 1\n            r = min(self.max_radius,\n                    self.gamma * ((math.log(n) / n) ** (1 / dim)))\n            return [node for node in tree if distance(node.position, point) <= r]\n\n        def no_collision(pt):\n            return not self._in_obstacle(pt, obstacles, is_3d)\n\n        def no_edge_collision(frm, to):\n            dist = distance(frm, to)\n            steps = max(1, int(dist / 1.0))\n            for i in range(steps + 1):\n                interp = tuple(frm[d] + (to[d] - frm[d]) * (i / steps) for d in range(dim))\n                if self._in_obstacle(interp, obstacles, is_3d):\n                    return False\n            return True\n\n        def add_node(tree, pos):\n            near = near_nodes(tree, pos)\n            min_cost = None\n            min_parent = None\n            for nb in near:\n                if no_edge_collision(nb.position, pos):\n                    cost = nb.cost + distance(nb.position, pos)\n                    if min_cost is None or cost < min_cost:\n                        min_cost = cost\n                        min_parent = nb\n            if min_parent is None:\n                min_parent = nearest(tree, pos)\n                if not no_edge_collision(min_parent.position, pos):\n                    return None\n                min_cost = min_parent.cost + distance(min_parent.position, pos)\n            new_node = Node(pos, parent=min_parent, cost=min_cost)\n            min_parent.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((min_parent, new_node))\n            for nb in near:\n                if nb == min_parent: \n                    continue\n                if no_edge_collision(new_node.position, nb.position):\n                    cost_through_new = new_node.cost + distance(new_node.position, nb.position)\n                    if cost_through_new + 1e-9 < nb.cost:\n                        if nb.parent:\n                            try:\n                                edges.remove((nb.parent, nb))\n                            except ValueError:\n                                pass\n                            try:\n                                nb.parent.children.remove(nb)\n                            except ValueError:\n                                pass\n                        new_node.add_child(nb)\n                        nb.cost = cost_through_new\n                        edges.append((new_node, nb))\n            return new_node\n\n        for i in range(self.max_iter):\n            rnd = sample()\n            tree_a, tree_b = (tree_start, tree_goal) if i % 2 == 0 else (tree_goal, tree_start)\n            new_node = add_node(tree_a, steer(nearest(tree_a, rnd).position, rnd))\n            if new_node is None:\n                continue\n            nearest_b = nearest(tree_b, new_node.position)\n            if distance(new_node.position, nearest_b.position) <= self.step_size:\n                if no_edge_collision(new_node.position, nearest_b.position):\n                    connect_node = Node(nearest_b.position, parent=new_node,\n                                        cost=new_node.cost + distance(new_node.position, nearest_b.position))\n                    new_node.add_child(connect_node)\n                    tree_a.append(connect_node)\n                    nodes.append(connect_node)\n                    edges.append((new_node, connect_node))\n                    success = True\n                    # extract path\n                    def extract_path(n):\n                        path_ = []\n                        curr = n\n                        while curr:\n                            path_.append(curr.position)\n                            curr = curr.parent\n                        return path_[::-1]\n                    path_from_start = extract_path(connect_node if tree_a is tree_start else nearest_b)\n                    path_from_goal = extract_path(nearest_b if tree_a is tree_start else connect_node)\n                    if tree_a is tree_start:\n                        path = path_from_start + path_from_goal[::-1][1:]\n                    else:\n                        path = path_from_goal + path_from_start[::-1][1:]\n                    break\n\n        return PlannerResult(success, path, nodes, edges)\n\n    def _in_obstacle(self, pos, obstacles, is_3d):\n        if not obstacles:\n            return False\n        if is_3d:\n            x, y, z = pos\n            for ox, oy, oz, w, h, d in obstacles:\n                if ox <= x <= ox + w and oy <= y <= oy + h and oz <= z <= oz + d:\n                    return True\n        else:\n            x, y = pos\n            for ox, oy, w, h in obstacles:\n                if ox <= x <= ox + w and oy <= y <= oy + h:\n                    return True\n        return False",
    "objective": 11.77609,
    "time_improvement": -47.0,
    "length_improvement": 3.0,
    "smoothness_improvement": 89.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.0374495267868042,
            "num_nodes_avg": 132.1,
            "path_length_avg": 169.7265144294206,
            "smoothness_avg": 0.01329150890080609,
            "success_improvement": 0.0,
            "time_improvement": -42.649549596185,
            "length_improvement": 6.970207952505146,
            "smoothness_improvement": 108.04097727116131,
            "objective_score": -8.072535220996606
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.09620890617370606,
            "num_nodes_avg": 292.9,
            "path_length_avg": 299.6147249817799,
            "smoothness_avg": 0.0067901721425518095,
            "success_improvement": 0.0,
            "time_improvement": 41.74101545158251,
            "length_improvement": -0.020019130609852068,
            "smoothness_improvement": 74.7160199911662,
            "objective_score": 12.883873257064673
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.12144281864166259,
            "num_nodes_avg": 315.2,
            "path_length_avg": 145.82934379791655,
            "smoothness_avg": 0.014525387560822478,
            "success_improvement": 0.0,
            "time_improvement": -141.50557384635226,
            "length_improvement": 3.14709349655306,
            "smoothness_improvement": 84.7618576210787,
            "objective_score": -40.13960676786844
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m3",
    "algorithm_description": "A bidirectional RRT* inspired planner enhanced with adaptive rewiring radius, early connection checks, and direct path shortcutting to efficiently grow two trees from start and goal states. The planner interleaves tree expansions, rewires locally to optimize costs, and attempts to connect trees whenever nodes are close. Once connected, it refines the path by shortcutting unnecessary waypoints to improve smoothness and shorten path length. It enforces strict collision checks on nodes and edges, respects map bounds and obstacles, and aims to reduce planning time and improve path quality.",
    "planning_mechanism": "The planner alternately expands two trees by sampling collision-free points, steering from nearest nodes with a fixed step size, and rewiring nearby nodes within an adaptive radius to lower path costs. It maintains both trees and attempts to connect them when nodes come within step size. On success, it extracts and smooths the combined path by shortcutting.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        child.parent = self\n        self.children.append(child)\nclass Planner:\n    def __init__(self, max_iter=3000, step_size=5.0, gamma=30.0, max_radius=50.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.gamma = gamma\n        self.max_radius = max_radius\n\n    def plan(self, map):\n        bounds = map.size\n        start = Node(map.start)\n        goal = Node(map.goal)\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = dim == 3\n\n        tree_start = [start]\n        tree_goal = [goal]\n\n        def dist(a, b):\n            return sum((a[i]-b[i])**2 for i in range(dim))**0.5\n\n        def in_obstacle(p):\n            if not obstacles:\n                return False\n            if is_3d:\n                x,y,z = p\n                for ox,oy,oz,w,h,d in obstacles:\n                    if ox <= x <= ox+w and oy <= y <= oy+h and oz <= z <= oz+d:\n                        return True\n            else:\n                x,y = p\n                for ox,oy,w,h in obstacles:\n                    if ox <= x <= ox+w and oy <= y <= oy+h:\n                        return True\n            return False\n\n        def collision_free(frm, to):\n            d = dist(frm, to)\n            steps = max(1,int(d))\n            for i in range(steps+1):\n                interp = tuple(frm[j]+(to[j]-frm[j])*i/steps for j in range(dim))\n                if in_obstacle(interp):\n                    return False\n            return True\n\n        def sample_free():\n            import random\n            while True:\n                pt = tuple(random.uniform(0,bounds[i]) for i in range(dim))\n                if not in_obstacle(pt):\n                    return pt\n\n        def steer(frm, to):\n            d = dist(frm,to)\n            if d <= self.step_size:\n                return to\n            ratio = self.step_size/d\n            return tuple(frm[i]+(to[i]-frm[i])*ratio for i in range(dim))\n\n        def nearest(tree, point):\n            best = tree[0]\n            best_d = dist(best.position, point)\n            for node in tree:\n                d = dist(node.position, point)\n                if d < best_d:\n                    best = node\n                    best_d = d\n            return best\n\n        def near_nodes(tree, point):\n            n = len(tree) + 1\n            r = min(self.max_radius, self.gamma*((math.log(n)/n)**(1/dim)))\n            return [node for node in tree if dist(node.position, point) <= r]\n\n        def rewire(new_node, tree):\n            near = near_nodes(tree, new_node.position)\n            for node in near:\n                if node == new_node.parent:\n                    continue\n                if collision_free(new_node.position, node.position):\n                    c = new_node.cost + dist(new_node.position, node.position)\n                    if c + 1e-9 < node.cost:\n                        if node.parent:\n                            try:\n                                node.parent.children.remove(node)\n                            except ValueError:\n                                pass\n                        node.parent = new_node\n                        node.cost = c\n                        new_node.children.append(node)\n\n        def add_node(tree, pos):\n            near = near_nodes(tree, pos)\n            min_cost = None\n            min_parent = None\n            for node in near:\n                if collision_free(node.position, pos):\n                    c = node.cost + dist(node.position, pos)\n                    if min_cost is None or c < min_cost:\n                        min_cost = c\n                        min_parent = node\n            if min_parent is None:\n                min_parent = nearest(tree, pos)\n                if not collision_free(min_parent.position, pos):\n                    return None\n                min_cost = min_parent.cost + dist(min_parent.position, pos)\n            new_node = Node(pos, parent=min_parent, cost=min_cost)\n            min_parent.add_child(new_node)\n            tree.append(new_node)\n            rewire(new_node, tree)\n            return new_node\n\n        def extract_path(node):\n            path = []\n            while node:\n                path.append(node.position)\n                node = node.parent\n            return path[::-1]\n\n        def path_distance(path):\n            return sum(dist(path[i], path[i+1]) for i in range(len(path)-1))\n\n        def shortcut_path(path):\n            # Try shortcuts by skipping intermediate nodes if path segment collision-free\n            if len(path) < 3:\n                return path\n            shortened = [path[0]]\n            i = 0\n            while i < len(path)-1:\n                j = len(path)-1\n                while j > i+1:\n                    if collision_free(path[i], path[j]):\n                        break\n                    j -= 1\n                shortened.append(path[j])\n                i = j\n            return shortened\n\n        success = False\n        best_path = []\n        best_cost = float('inf')\n\n        import math\n        import random\n\n        for i in range(self.max_iter):\n            rand_pos = sample_free()\n            tree_a, tree_b = (tree_start, tree_goal) if i % 2 == 0 else (tree_goal, tree_start)\n            nearest_node = nearest(tree_a, rand_pos)\n            new_pos = steer(nearest_node.position, rand_pos)\n            if in_obstacle(new_pos):\n                continue\n            new_node = add_node(tree_a, new_pos)\n            if new_node is None:\n                continue\n            nearest_to_new = nearest(tree_b, new_node.position)\n            if dist(new_node.position, nearest_to_new.position) <= self.step_size:\n                if collision_free(new_node.position, nearest_to_new.position):\n                    # Connect trees\n                    connector = Node(nearest_to_new.position, parent=new_node,\n                                     cost=new_node.cost + dist(new_node.position, nearest_to_new.position))\n                    new_node.add_child(connector)\n                    tree_a.append(connector)\n                    path_start = extract_path(connector if tree_a is tree_start else nearest_to_new)\n                    path_goal = extract_path(nearest_to_new if tree_a is tree_start else connector)\n                    combined = path_start + path_goal[::-1][1:]\n                    shortcut = shortcut_path(combined)\n                    cost = path_distance(shortcut)\n                    if cost < best_cost:\n                        best_cost = cost\n                        best_path = shortcut\n                        success = True\n                    break\n\n        return PlannerResult(success, best_path, tree_start + tree_goal, [])",
    "objective": 6.26701,
    "time_improvement": -79.0,
    "length_improvement": 15.0,
    "smoothness_improvement": 1715.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.028808045387268066,
            "num_nodes_avg": 108.8,
            "path_length_avg": 168.27398390306212,
            "smoothness_avg": 0.05206268824910476,
            "success_improvement": 0.0,
            "time_improvement": -9.733154243440554,
            "length_improvement": 7.766362950821337,
            "smoothness_improvement": 714.8941270355455,
            "objective_score": 5.314342132638364
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.08904473781585694,
            "num_nodes_avg": 259.7,
            "path_length_avg": 234.95219792506205,
            "smoothness_avg": 0.10679534917103665,
            "success_improvement": 0.0,
            "time_improvement": 46.07925387733299,
            "length_improvement": 21.56619360856643,
            "smoothness_improvement": 2647.921255751587,
            "objective_score": 40.00309860709769
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.18736355304718016,
            "num_nodes_avg": 302.1,
            "path_length_avg": 128.59261689687668,
            "smoothness_avg": 0.14786205400262384,
            "success_improvement": 0.0,
            "time_improvement": -272.5979263546779,
            "length_improvement": 14.594906779490662,
            "smoothness_improvement": 1780.79441287184,
            "objective_score": -64.11846177434978
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m3",
    "algorithm_description": "A simplified bidirectional RRT* planner that alternately grows two trees from start and goal using fixed step-size steering, nearest neighbor connection, and local rewiring with a fixed radius. The algorithm attempts to connect the two trees when nodes are nearby and extracts the combined path. After finding a path, a simple shortcutting step reduces unnecessary waypoints to improve smoothness and path length. This streamlined version reduces overhead while preserving feasible, short, and smooth paths.",
    "planning_mechanism": "A bidirectional RRT* variant that grows two trees alternately by sampling points, steering from nearest nodes, rewiring neighbors within a fixed radius to improve costs, and attempts to connect the trees when close. Upon connection, it extracts and shortcuts the path for quality.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\nclass Planner:\n    def __init__(self, max_iter=2000, step_size=5.0, radius=15.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.radius = radius\n\n    def plan(self, map):\n        bounds = map.size\n        start = Node(map.start)\n        goal = Node(map.goal)\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = dim == 3\n\n        tree_start = [start]\n        tree_goal = [goal]\n\n        def dist(a, b):\n            return sum((a[i]-b[i])**2 for i in range(dim))**0.5\n\n        def in_obstacle(p):\n            if not obstacles:\n                return False\n            if is_3d:\n                x,y,z = p\n                for ox, oy, oz, w, h, d in obstacles:\n                    if ox <= x <= ox+w and oy <= y <= oy+h and oz <= z <= oz+d:\n                        return True\n            else:\n                x,y = p\n                for ox, oy, w, h in obstacles:\n                    if ox <= x <= ox+w and oy <= y <= oy+h:\n                        return True\n            return False\n\n        def collision_free(frm, to):\n            d = dist(frm, to)\n            steps = max(1, int(d))\n            for i in range(steps + 1):\n                interp = tuple(frm[j] + (to[j]-frm[j]) * i/steps for j in range(dim))\n                if in_obstacle(interp):\n                    return False\n            return True\n\n        import random\n\n        def sample_free():\n            while True:\n                p = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not in_obstacle(p):\n                    return p\n\n        def steer(frm, to):\n            d = dist(frm, to)\n            if d <= self.step_size:\n                return to\n            ratio = self.step_size / d\n            return tuple(frm[i] + (to[i]-frm[i]) * ratio for i in range(dim))\n\n        def nearest(tree, point):\n            best = tree[0]\n            best_d = dist(best.position, point)\n            for node in tree:\n                d = dist(node.position, point)\n                if d < best_d:\n                    best, best_d = node, d\n            return best\n\n        def near_nodes(tree, point):\n            return [node for node in tree if dist(node.position, point) <= self.radius]\n\n        def add_node(tree, pos):\n            near = near_nodes(tree, pos)\n            min_cost, min_parent = None, None\n            for node in near:\n                if collision_free(node.position, pos):\n                    c = node.cost + dist(node.position, pos)\n                    if min_cost is None or c < min_cost:\n                        min_cost, min_parent = c, node\n            if min_parent is None:\n                min_parent = nearest(tree, pos)\n                if not collision_free(min_parent.position, pos):\n                    return None\n                min_cost = min_parent.cost + dist(min_parent.position, pos)\n            new_node = Node(pos, parent=min_parent, cost=min_cost)\n            min_parent.add_child(new_node)\n            tree.append(new_node)\n            rewire(new_node, tree)\n            return new_node\n\n        def rewire(new_node, tree):\n            for node in near_nodes(tree, new_node.position):\n                if node is new_node.parent:\n                    continue\n                if collision_free(new_node.position, node.position):\n                    c = new_node.cost + dist(new_node.position, node.position)\n                    if c + 1e-9 < node.cost:\n                        if node.parent:\n                            try:\n                                node.parent.children.remove(node)\n                            except ValueError:\n                                pass\n                        node.parent = new_node\n                        node.cost = c\n                        new_node.children.append(node)\n\n        def extract_path(node):\n            path = []\n            while node:\n                path.append(node.position)\n                node = node.parent\n            return path[::-1]\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            shortened = [path[0]]\n            i = 0\n            while i < len(path) - 1:\n                j = len(path) - 1\n                while j > i + 1:\n                    if collision_free(path[i], path[j]):\n                        break\n                    j -= 1\n                shortened.append(path[j])\n                i = j\n            return shortened\n\n        success = False\n        best_path = []\n        best_cost = float('inf')\n\n        for i in range(self.max_iter):\n            rand_pos = sample_free()\n            tree_a, tree_b = (tree_start, tree_goal) if i % 2 == 0 else (tree_goal, tree_start)\n            nearest_node = nearest(tree_a, rand_pos)\n            new_pos = steer(nearest_node.position, rand_pos)\n            if in_obstacle(new_pos):\n                continue\n            new_node = add_node(tree_a, new_pos)\n            if new_node is None:\n                continue\n            nearest_to_new = nearest(tree_b, new_node.position)\n            if dist(new_node.position, nearest_to_new.position) <= self.step_size:\n                if collision_free(new_node.position, nearest_to_new.position):\n                    connector = Node(nearest_to_new.position, parent=new_node,\n                                     cost=new_node.cost + dist(new_node.position, nearest_to_new.position))\n                    new_node.add_child(connector)\n                    tree_a.append(connector)\n                    path_start = extract_path(connector if tree_a is tree_start else nearest_to_new)\n                    path_goal = extract_path(nearest_to_new if tree_a is tree_start else connector)\n                    combined = path_start + path_goal[::-1][1:]\n                    shortcut = shortcut_path(combined)\n                    cost = sum(dist(shortcut[i], shortcut[i+1]) for i in range(len(shortcut)-1))\n                    if cost < best_cost:\n                        best_cost = cost\n                        best_path = shortcut\n                        success = True\n                    break\n\n        return PlannerResult(success, best_path, tree_start + tree_goal, [])",
    "objective": -14.56634,
    "time_improvement": -11.0,
    "length_improvement": 19.0,
    "smoothness_improvement": 1357.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.035758161544799806,
            "num_nodes_avg": 95.1,
            "path_length_avg": 158.08045278022354,
            "smoothness_avg": 0.0437108561114864,
            "success_improvement": 0.0,
            "time_improvement": -36.20694509151112,
            "length_improvement": 13.353598886086381,
            "smoothness_improvement": 584.1698177880498,
            "objective_score": 0.0709248931387414
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.14818284511566163,
            "num_nodes_avg": 270.9,
            "path_length_avg": 229.20584772072934,
            "smoothness_avg": 0.08798497858952058,
            "success_improvement": 0.0,
            "time_improvement": 10.268368831187576,
            "length_improvement": 23.484490706292497,
            "smoothness_improvement": 2163.9168721268857,
            "objective_score": 27.990789433766196
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.053970956802368165,
            "num_nodes_avg": 154.9,
            "path_length_avg": 122.40981172898974,
            "smoothness_avg": 0.1118739121743925,
            "success_improvement": 0.0,
            "time_improvement": -7.328593319729027,
            "length_improvement": 18.70123157845707,
            "smoothness_improvement": 1323.0279051850484,
            "objective_score": 15.637300477080775
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m3",
    "algorithm_description": "A simplified bidirectional RRT planner that grows two trees from start and goal positions, alternately extending each tree towards random collision-free samples using fixed step sizes. The planner attempts to connect the trees incrementally when new nodes are added. Both node and edge collision checks are performed. The path is constructed once the two trees connect, ensuring feasible, relatively efficient paths with minimal complexity for better generalization.",
    "planning_mechanism": "class Node and Planner with plan(map) method below",
    "code": "class Node:\n    def __init__(self, position, parent=None):\n        self.position = position\n        self.parent = parent\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=3000, step_size=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map):\n        bounds = map.size\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start)]\n        goal_tree = [Node(goal)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        for i in range(self.max_iter):\n            tree_a, tree_b = (start_tree, goal_tree) if i % 2 == 0 else (goal_tree, start_tree)\n            sample = self._sample_free(bounds, obstacles, is_3d)\n            new_node = self._extend(tree_a, sample, obstacles, is_3d, nodes, edges)\n            if new_node:\n                connected_node = self._connect(tree_b, new_node, obstacles, is_3d, nodes, edges)\n                if connected_node:\n                    path_a = new_node.path_from_root()\n                    path_b = connected_node.path_from_root()\n                    if path_a[-1] == path_b[-1]:\n                        full_path = path_a + path_b[-2::-1]\n                    else:\n                        full_path = path_a + path_b[::-1]\n                    return PlannerResult(True, full_path, nodes, edges)\n        return PlannerResult(False, [], nodes, edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        import random\n        while True:\n            if is_3d:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(3))\n            else:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(2))\n            if not self._in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def _extend(self, tree, target, obstacles, is_3d, nodes, edges):\n        nearest = self._nearest(tree, target)\n        new_pos = self._steer(nearest.position, target)\n        if self._valid(nearest.position, new_pos, obstacles, is_3d):\n            new_node = Node(new_pos, nearest)\n            nearest.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest, new_node))\n            return new_node\n        return None\n\n    def _connect(self, tree, target_node, obstacles, is_3d, nodes, edges):\n        import math\n        nearest = self._nearest(tree, target_node.position)\n        while True:\n            new_pos = self._steer(nearest.position, target_node.position)\n            if not self._valid(nearest.position, new_pos, obstacles, is_3d):\n                return None\n            new_node = Node(new_pos, nearest)\n            nearest.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest, new_node))\n            if self._dist(new_node.position, target_node.position) <= self.step_size:\n                if not self._valid(new_node.position, target_node.position, obstacles, is_3d):\n                    return None\n                final_node = Node(target_node.position, new_node)\n                new_node.add_child(final_node)\n                tree.append(final_node)\n                nodes.append(final_node)\n                edges.append((new_node, final_node))\n                return final_node\n            nearest = new_node\n\n    def _nearest(self, tree, point):\n        return min(tree, key=lambda node: self._dist(node.position, point))\n\n    def _steer(self, start, goal):\n        dist = self._dist(start, goal)\n        if dist <= self.step_size:\n            return goal\n        ratio = self.step_size / dist\n        return tuple(start[d] + ratio * (goal[d] - start[d]) for d in range(len(start)))\n\n    def _valid(self, from_pos, to_pos, obstacles, is_3d):\n        return (not self._in_obstacle(to_pos, obstacles, is_3d)) and (not self._edge_in_obstacle(from_pos, to_pos, obstacles, is_3d))\n\n    def _in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x,y,z,w,h,d = obs\n                px,py,pz = pos\n                if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                    return True\n            else:\n                x,y,w,h = obs\n                px,py = pos\n                if x <= px <= x+w and y <= py <= y+h:\n                    return True\n        return False\n\n    def _edge_in_obstacle(self, p1, p2, obstacles, is_3d, resolution=1.0):\n        dist = self._dist(p1, p2)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps+1):\n            interp = tuple(p1[d] + (p2[d] - p1[d]) * i/steps for d in range(len(p1)))\n            if self._in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _dist(self, a, b):\n        return sum((a[d]-b[d])**2 for d in range(len(a)))**0.5",
    "objective": -15.03779,
    "time_improvement": 55.0,
    "length_improvement": -3.0,
    "smoothness_improvement": 63.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.007532596588134766,
            "num_nodes_avg": 83.5,
            "path_length_avg": 189.84030889041793,
            "smoothness_avg": 0.010321372451574455,
            "success_improvement": 0.0,
            "time_improvement": 71.30747427853201,
            "length_improvement": -4.054481515036774,
            "smoothness_improvement": 61.55189208615482,
            "objective_score": 19.267312834968312
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.04050443172454834,
            "num_nodes_avg": 246.8,
            "path_length_avg": 304.88351138240876,
            "smoothness_avg": 0.006376895060333369,
            "success_improvement": 0.0,
            "time_improvement": 75.47267549511115,
            "length_improvement": -1.778891684747648,
            "smoothness_improvement": 64.08210299423538,
            "objective_score": 21.89487815265593
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.04095637798309326,
            "num_nodes_avg": 217.6,
            "path_length_avg": 155.40404903932387,
            "smoothness_avg": 0.01277627099031739,
            "success_improvement": 0.0,
            "time_improvement": 18.552668011925263,
            "length_improvement": -3.2119698263207472,
            "smoothness_improvement": 62.513223950609444,
            "objective_score": 3.951184627538178
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m3",
    "algorithm_description": "A bidirectional RRT planner that grows two trees from start and goal, alternately extending them towards random samples with fixed steps. It connects trees incrementally upon new node addition and returns the combined path once connected, ensuring collision-free, feasible paths with simple logic for general use.",
    "planning_mechanism": "The planner samples random points within map bounds, extends each tree towards samples in turns checking node and edge collisions, and tries connecting the trees incrementally. It constructs the solution path by concatenating the connected paths from both trees.",
    "code": "class Node:\n    def __init__(self, position, parent=None):\n        self.position = position\n        self.parent = parent\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        path, node = [], self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=3000, step_size=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map):\n        bounds, start, goal = map.size, map.start, map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start)]\n        goal_tree = [Node(goal)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        for i in range(self.max_iter):\n            tree_a, tree_b = (start_tree, goal_tree) if i % 2 == 0 else (goal_tree, start_tree)\n            sample = self._sample_free(bounds, obstacles, is_3d)\n            new_node = self._extend(tree_a, sample, obstacles, is_3d, nodes, edges)\n            if new_node:\n                connected = self._connect(tree_b, new_node, obstacles, is_3d, nodes, edges)\n                if connected:\n                    path_a = new_node.path_from_root()\n                    path_b = connected.path_from_root()\n                    if path_a[-1] == path_b[-1]:\n                        path = path_a + path_b[-2::-1]\n                    else:\n                        path = path_a + path_b[::-1]\n                    return PlannerResult(True, path, nodes, edges)\n        return PlannerResult(False, [], nodes, edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        import random\n        while True:\n            pt = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n            if not self._in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def _extend(self, tree, target, obstacles, is_3d, nodes, edges):\n        nearest = self._nearest(tree, target)\n        new_pos = self._steer(nearest.position, target)\n        if self._valid(nearest.position, new_pos, obstacles, is_3d):\n            new_node = Node(new_pos, nearest)\n            nearest.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest, new_node))\n            return new_node\n        return None\n\n    def _connect(self, tree, target_node, obstacles, is_3d, nodes, edges):\n        nearest = self._nearest(tree, target_node.position)\n        while True:\n            new_pos = self._steer(nearest.position, target_node.position)\n            if not self._valid(nearest.position, new_pos, obstacles, is_3d):\n                return None\n            new_node = Node(new_pos, nearest)\n            nearest.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest, new_node))\n            if self._dist(new_node.position, target_node.position) <= self.step_size:\n                if not self._valid(new_node.position, target_node.position, obstacles, is_3d):\n                    return None\n                final_node = Node(target_node.position, new_node)\n                new_node.add_child(final_node)\n                tree.append(final_node)\n                nodes.append(final_node)\n                edges.append((new_node, final_node))\n                return final_node\n            nearest = new_node\n\n    def _nearest(self, tree, point):\n        return min(tree, key=lambda node: self._dist(node.position, point))\n\n    def _steer(self, start, goal):\n        dist = self._dist(start, goal)\n        if dist <= self.step_size:\n            return goal\n        ratio = self.step_size / dist\n        return tuple(start[d] + ratio * (goal[d] - start[d]) for d in range(len(start)))\n\n    def _valid(self, p1, p2, obstacles, is_3d):\n        return (not self._in_obstacle(p2, obstacles, is_3d)) and (not self._edge_in_obstacle(p1, p2, obstacles, is_3d))\n\n    def _in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x,y,z,w,h,d = obs\n                px,py,pz = pos\n                if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                    return True\n            else:\n                x,y,w,h = obs\n                px,py = pos\n                if x <= px <= x+w and y <= py <= y+h:\n                    return True\n        return False\n\n    def _edge_in_obstacle(self, p1, p2, obstacles, is_3d, res=1.0):\n        dist = self._dist(p1, p2)\n        steps = max(1, int(dist / res))\n        for i in range(steps+1):\n            interp = tuple(p1[d]+(p2[d]-p1[d])*i/steps for d in range(len(p1)))\n            if self._in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _dist(self, a, b):\n        return sum((a[d]-b[d])**2 for d in range(len(a)))**0.5",
    "objective": -18.87672,
    "time_improvement": 69.0,
    "length_improvement": -3.0,
    "smoothness_improvement": 65.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.007088375091552734,
            "num_nodes_avg": 86.9,
            "path_length_avg": 192.080687991448,
            "smoothness_avg": 0.010225328478655104,
            "success_improvement": 0.0,
            "time_improvement": 72.99956498956065,
            "length_improvement": -5.2824688013900305,
            "smoothness_improvement": 60.04859534714162,
            "objective_score": 19.030631192769885
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.027634835243225096,
            "num_nodes_avg": 224.3,
            "path_length_avg": 302.18866926184023,
            "smoothness_avg": 0.006484073476451755,
            "success_improvement": 0.0,
            "time_improvement": 83.26581702814202,
            "length_improvement": -0.8792758181722384,
            "smoothness_improvement": 66.83988083845422,
            "objective_score": 24.786379021731538
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.025080132484436034,
            "num_nodes_avg": 207.5,
            "path_length_avg": 156.98834599359654,
            "smoothness_avg": 0.013116998064567845,
            "success_improvement": 0.0,
            "time_improvement": 50.12474302273537,
            "length_improvement": -4.2641844272346905,
            "smoothness_improvement": 66.84724718521873,
            "objective_score": 12.81314848640589
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m3",
    "algorithm_description": "A streamlined bidirectional RRT planner that grows two trees from start and goal by extending towards random collision-free samples with a fixed step size, connecting trees incrementally, and returning a feasible path once connected. It performs collision checking on nodes and edges and maintains coherent parent-child relationships to build efficient paths.",
    "planning_mechanism": "A planner that alternates expanding two trees via fixed-step steering towards uniform random free samples, validates each extension for collisions, attempts to connect trees after each new node, and reconstructs the final path by joining connected tree paths.",
    "code": "class Node:\n    def __init__(self, position, parent=None):\n        self.position = position\n        self.parent = parent\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        node, path = self, []\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=3000, step_size=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map):\n        bounds, start, goal = map.size, map.start, map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        tree_start = [Node(start)]\n        tree_goal = [Node(goal)]\n        nodes = tree_start + tree_goal\n        edges = []\n\n        for i in range(self.max_iter):\n            tree_a, tree_b = (tree_start, tree_goal) if i % 2 == 0 else (tree_goal, tree_start)\n            sample = self._sample_free(bounds, obstacles, is_3d)\n            new_node = self._extend(tree_a, sample, obstacles, is_3d, nodes, edges)\n            if new_node:\n                connected_node = self._connect(tree_b, new_node, obstacles, is_3d, nodes, edges)\n                if connected_node:\n                    path_a = new_node.path_from_root()\n                    path_b = connected_node.path_from_root()\n                    if path_a[-1] == path_b[-1]:\n                        path = path_a + path_b[-2::-1]\n                    else:\n                        path = path_a + path_b[::-1]\n                    return PlannerResult(True, path, nodes, edges)\n        return PlannerResult(False, [], nodes, edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        import random\n        while True:\n            pt = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n            if not self._in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def _extend(self, tree, target, obstacles, is_3d, nodes, edges):\n        nearest = min(tree, key=lambda n: self._dist(n.position, target))\n        new_pos = self._steer(nearest.position, target)\n        if self._valid(nearest.position, new_pos, obstacles, is_3d):\n            new_node = Node(new_pos, nearest)\n            nearest.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest, new_node))\n            return new_node\n        return None\n\n    def _connect(self, tree, target_node, obstacles, is_3d, nodes, edges):\n        nearest = min(tree, key=lambda n: self._dist(n.position, target_node.position))\n        while True:\n            new_pos = self._steer(nearest.position, target_node.position)\n            if not self._valid(nearest.position, new_pos, obstacles, is_3d):\n                return None\n            new_node = Node(new_pos, nearest)\n            nearest.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest, new_node))\n            if self._dist(new_node.position, target_node.position) <= self.step_size:\n                if not self._valid(new_node.position, target_node.position, obstacles, is_3d):\n                    return None\n                final_node = Node(target_node.position, new_node)\n                new_node.add_child(final_node)\n                tree.append(final_node)\n                nodes.append(final_node)\n                edges.append((new_node, final_node))\n                return final_node\n            nearest = new_node\n\n    def _steer(self, start, goal):\n        dist = self._dist(start, goal)\n        if dist <= self.step_size:\n            return goal\n        ratio = self.step_size / dist\n        return tuple(start[d] + (goal[d] - start[d]) * ratio for d in range(len(start)))\n\n    def _valid(self, p1, p2, obstacles, is_3d):\n        return (not self._in_obstacle(p2, obstacles, is_3d)) and (not self._edge_in_obstacle(p1, p2, obstacles, is_3d))\n\n    def _in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x,y,z,w,h,d = obs\n                px,py,pz = pos\n                if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                    return True\n            else:\n                x,y,w,h = obs\n                px,py = pos\n                if x <= px <= x+w and y <= py <= y+h:\n                    return True\n        return False\n\n    def _edge_in_obstacle(self, p1, p2, obstacles, is_3d, res=1.0):\n        dist = self._dist(p1, p2)\n        steps = max(1, int(dist / res))\n        for i in range(steps+1):\n            interp = tuple(p1[d] + (p2[d] - p1[d]) * i / steps for d in range(len(p1)))\n            if self._in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _dist(self, a, b):\n        return sum((a[d] - b[d])**2 for d in range(len(a)))**0.5",
    "objective": -19.65905,
    "time_improvement": 71.0,
    "length_improvement": -3.0,
    "smoothness_improvement": 62.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.007035160064697265,
            "num_nodes_avg": 86.2,
            "path_length_avg": 189.39879686980154,
            "smoothness_avg": 0.0102591145052943,
            "success_improvement": 0.0,
            "time_improvement": 73.20226714000162,
            "length_improvement": -3.8124817803312583,
            "smoothness_improvement": 60.57742003157615,
            "objective_score": 19.976078173959614
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.03991465568542481,
            "num_nodes_avg": 246.5,
            "path_length_avg": 309.916942499886,
            "smoothness_avg": 0.006220174309434665,
            "success_improvement": 0.0,
            "time_improvement": 75.82981242262478,
            "length_improvement": -3.4591958710432116,
            "smoothness_improvement": 60.04956519221755,
            "objective_score": 20.973674030122595
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.0178729772567749,
            "num_nodes_avg": 178.1,
            "path_length_avg": 154.6893175478031,
            "smoothness_avg": 0.013091758856632583,
            "success_improvement": 0.0,
            "time_improvement": 64.45715212295462,
            "length_improvement": -2.737279201508942,
            "smoothness_improvement": 66.52620632324673,
            "objective_score": 18.027409147597258
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "e1",
    "algorithm_description": "A bidirectional incremental Rapid Random Tree with adaptive goal biasing and dynamic rewiring radius, integrating lazy collision checks and a priority queue driven expansion focused on nodes with lower estimated total cost (cost-to-come plus heuristic to goal). The Planner alternates tree expansions, uses informed sampling once a solution is found to prioritize promising regions, and performs dynamic rewiring within an adaptive radius decreasing over iterations to refine paths and reduce unnecessary rewiring overhead. The search employs lazy collision checks by postponing full edge validations until candidate connections are promising, improving efficiency. Path shortcutting post-processing is applied to enhance smoothness and reduce length, while maintaining collision-free guarantees.",
    "planning_mechanism": "A bidirectional, anytime planner that grows two trees from start and goal nodes by sampling either uniform or informed ellipsoidal regions based on current best path cost. The planner uses a priority-driven node expansion strategy prioritizing nodes with lowest estimated total cost, applies adaptive rewiring radius and lazy collision checking to efficiently rewire neighbor nodes only when beneficial, and incrementally attempts to connect the two trees. Upon connection, the algorithm extracts the combined path, applies shortcutting to smooth it, and returns it as the solution. The adaptive rewiring radius gradually decreases to focus optimization near the path, balancing computation and improvement for faster convergence and smoother paths.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost  # cost-to-come\n        self.children = []\n        self.id = id(self)  # unique identifier for potential bookkeeping\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=4000, step_size=5.0, goal_sample_rate=0.15, initial_neighbor_radius=25.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.initial_neighbor_radius = initial_neighbor_radius\n\n    def plan(self, map):\n        bounds = map.size\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        import random\n        import math\n        import heapq\n\n        # Heuristic function for A*-like priority: Euclidean distance to goal\n        def heuristic(p):\n            return sum((p[d] - goal[d]) ** 2 for d in range(dim)) ** 0.5\n\n        # Distance between two points\n        def dist(a, b):\n            return sum((a[d] - b[d]) ** 2 for d in range(dim)) ** 0.5\n\n        # Collision check for point in obstacles\n        def in_obstacle(pt):\n            if is_3d:\n                px, py, pz = pt\n                for obs in obstacles:\n                    ox, oy, oz, w, h, d = obs\n                    if ox <= px <= ox + w and oy <= py <= oy + h and oz <= pz <= oz + d:\n                        return True\n            else:\n                px, py = pt\n                for obs in obstacles:\n                    ox, oy, w, h = obs\n                    if ox <= px <= ox + w and oy <= py <= oy + h:\n                        return True\n            return False\n\n        # Edge collision check by discretizing line at resolution 1.0 units\n        def edge_in_obstacle(p1, p2):\n            distance = dist(p1, p2)\n            steps = max(1, int(distance / 1.0))\n            for i in range(steps + 1):\n                interp = tuple(p1[d] + (p2[d] - p1[d]) * (i / steps) for d in range(dim))\n                if in_obstacle(interp):\n                    return True\n            return False\n\n        # Steer from start towards goal at maximum step_size\n        def steer(start_pt, goal_pt):\n            d = dist(start_pt, goal_pt)\n            if d <= self.step_size:\n                return goal_pt\n            ratio = self.step_size / d\n            return tuple(start_pt[d_] + ratio * (goal_pt[d_] - start_pt[d_]) for d_ in range(dim))\n\n        # Random uniform sample in bounds avoiding obstacles\n        def sample_uniform():\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not in_obstacle(pt):\n                    return pt\n\n        # Informed sampling within prolate hyperspheroid about start and goal for bidirectional searching\n        def sample_informed(c_best):\n            if c_best == float('inf'):\n                return sample_uniform()\n            c_min = dist(start, goal)\n            if c_best < c_min:\n                return sample_uniform()\n            center = tuple((start[d] + goal[d]) * 0.5 for d in range(dim))\n            a1 = [(goal[d] - start[d]) / c_min for d in range(dim)]\n            # Sample unit ball\n            while True:\n                x_ball = [random.gauss(0, 1) for _ in range(dim)]\n                norm = math.sqrt(sum(x ** 2 for x in x_ball))\n                if norm <= 1 and norm > 0:\n                    unit = [x / norm for x in x_ball]\n                    r1 = c_best / 2.0\n                    r2_temp = c_best ** 2 - c_min ** 2\n                    r2 = math.sqrt(r2_temp) / 2.0 if r2_temp > 0 else 0.0\n                    # 2D rotation matrix to align ellipse axis\n                    if dim == 2:\n                        angle = math.atan2(a1[1], a1[0])\n                        cos_ang = math.cos(angle)\n                        sin_ang = math.sin(angle)\n                        x_ell = r1 * unit[0]\n                        y_ell = r2 * unit[1]\n                        px = center[0] + cos_ang * x_ell - sin_ang * y_ell\n                        py = center[1] + sin_ang * x_ell + cos_ang * y_ell\n                        pt = (px, py)\n                    else:\n                        # 3D approximation: scale x by r1, y,z by r2 and clamp\n                        pt_candidate = [center[d] + (r1 * unit[0] if d == 0 else r2 * unit[d]) for d in range(dim)]\n                        pt = tuple(max(0, min(pt_candidate[d], bounds[d])) for d in range(dim))\n                    if all(0 <= pt[d] <= bounds[d] for d in range(dim)) and not in_obstacle(pt):\n                        return pt\n\n        # Node priority queue helper by f = cost + heuristic\n        class PQ:\n            def __init__(self):\n                self.heap = []\n                self.entry_finder = {}\n                self.REMOVED = '<removed>'\n\n            def add_node(self, node, priority):\n                if node.id in self.entry_finder:\n                    self.remove_node(node)\n                entry = [priority, node.id, node]\n                self.entry_finder[node.id] = entry\n                heapq.heappush(self.heap, entry)\n\n            def remove_node(self, node):\n                entry = self.entry_finder.pop(node.id)\n                entry[-1] = self.REMOVED\n\n            def pop_node(self):\n                while self.heap:\n                    priority, node_id, node = heapq.heappop(self.heap)\n                    if node is not self.REMOVED:\n                        del self.entry_finder[node_id]\n                        return node\n                return None\n\n            def empty(self):\n                return not self.entry_finder\n\n        # Find nearest neighbor by Euclidean distance\n        def nearest(tree_nodes, point):\n            best_node = None\n            best_dist = float('inf')\n            for node in tree_nodes:\n                d = dist(node.position, point)\n                if d < best_dist:\n                    best_dist = d\n                    best_node = node\n            return best_node, best_dist\n\n        # Find neighbors within radius\n        def neighbors(tree_nodes, node, radius):\n            result = []\n            for n in tree_nodes:\n                if dist(n.position, node.position) <= radius:\n                    result.append(n)\n            return result\n\n        # Shortcut path by removing unnecessary nodes with collision check\n        def shortcut_path(path):\n            if len(path) <= 2:\n                return path\n            shortened = [path[0]]\n            idx = 0\n            while idx < len(path) - 1:\n                next_idx = len(path) - 1\n                for j in range(len(path) - 1, idx, -1):\n                    if not edge_in_obstacle(path[idx], path[j]):\n                        next_idx = j\n                        break\n                shortened.append(path[next_idx])\n                idx = next_idx\n            return shortened\n\n        # Lazy connection: check edge collision only on candidate edges after cost improvement\n        def lazy_edge_check(p1, p2):\n            return not edge_in_obstacle(p1, p2)\n\n        # Add new node to tree with rewiring in adaptive radius\n        def add_node_with_rewire(tree_nodes, tree_pq, new_pos, best_cost, neighbor_radius):\n            near_node, dist_to_near = nearest(tree_nodes, new_pos)\n            if in_obstacle(new_pos) or edge_in_obstacle(near_node.position, new_pos):\n                return None\n\n            new_cost = near_node.cost + dist(near_node.position, new_pos)\n            new_node = Node(new_pos, parent=near_node, cost=new_cost)\n            near_node.add_child(new_node)\n            tree_nodes.append(new_node)\n            tree_pq.add_node(new_node, new_node.cost + heuristic(new_node.position))\n\n            # Find neighbors within adaptive radius for rewiring\n            nbrs = neighbors(tree_nodes, new_node, neighbor_radius)\n            for nbr in nbrs:\n                if nbr is new_node.parent:\n                    continue\n                # Cost through new_node\n                cost_through_new = new_node.cost + dist(new_node.position, nbr.position)\n                if cost_through_new + 1e-6 < nbr.cost:\n                    # Lazy check edge collision\n                    if lazy_edge_check(new_node.position, nbr.position):\n                        # Rewire nbr to new_node\n                        if nbr.parent:\n                            nbr.parent.remove_child(nbr)\n                        nbr.parent = new_node\n                        new_node.children.append(nbr)\n                        old_cost = nbr.cost\n                        nbr.cost = cost_through_new\n\n                        # Update costs downstream\n                        def dfs_update_costs(n):\n                            for c in n.children:\n                                new_c_cost = n.cost + dist(n.position, c.position)\n                                if new_c_cost + 1e-8 < c.cost:\n                                    c.cost = new_c_cost\n                                    dfs_update_costs(c)\n                        dfs_update_costs(nbr)\n                        tree_pq.add_node(nbr, nbr.cost + heuristic(nbr.position))\n            return new_node\n\n        # Attempt connecting tree_b to new_node_a with lazy collision checking\n        def try_connect(tree_nodes_b, tree_pq_b, node_a, best_cost):\n            near_node_b, dist_nb = nearest(tree_nodes_b, node_a.position)\n            if in_obstacle(node_a.position) or edge_in_obstacle(near_node_b.position, node_a.position):\n                return None\n            cost_b = near_node_b.cost + dist(near_node_b.position, node_a.position)\n            new_node_b = Node(node_a.position, parent=near_node_b, cost=cost_b)\n            near_node_b.add_child(new_node_b)\n            tree_nodes_b.append(new_node_b)\n            tree_pq_b.add_node(new_node_b, new_node_b.cost + heuristic(new_node_b.position))\n            return new_node_b\n\n        start_node = Node(start, cost=0.0)\n        goal_node = Node(goal, cost=0.0)\n        start_tree = [start_node]\n        goal_tree = [goal_node]\n\n        start_pq = PQ()\n        start_pq.add_node(start_node, heuristic(start))\n        goal_pq = PQ()\n        goal_pq.add_node(goal_node, heuristic(goal))\n\n        best_cost = float('inf')\n        best_path = None\n\n        # Adaptive neighbor radius decreases over iterations (but never below minimum 5)\n        def adaptive_radius(iteration):\n            r = self.initial_neighbor_radius * (0.95 ** (iteration // 500))\n            return max(5.0, r)\n\n        for i in range(self.max_iter):\n            # Alternate expansion trees\n            if i % 2 == 0:\n                tree_nodes_a, pq_a = start_tree, start_pq\n                tree_nodes_b, pq_b = goal_tree, goal_pq\n                tree_dir = \"start\"\n            else:\n                tree_nodes_a, pq_a = goal_tree, goal_pq\n                tree_nodes_b, pq_b = start_tree, start_pq\n                tree_dir = \"goal\"\n\n            neighbor_r = adaptive_radius(i)\n\n            # Sampling guided by best cost found\n            curr_best_cost = best_cost if best_cost != float('inf') else float('inf')\n            if random.random() < self.goal_sample_rate and tree_dir == \"start\":\n                sample_pt = goal\n                if in_obstacle(sample_pt):\n                    sample_pt = sample_uniform()\n            elif random.random() < self.goal_sample_rate and tree_dir == \"goal\":\n                sample_pt = start\n                if in_obstacle(sample_pt):\n                    sample_pt = sample_uniform()\n            else:\n                sample_pt = sample_informed(curr_best_cost)\n\n            # Add node in tree A with rewiring\n            new_node_a = add_node_with_rewire(tree_nodes_a, pq_a, sample_pt, curr_best_cost, neighbor_r)\n            if new_node_a is None:\n                continue\n\n            # Attempt connection to other tree B\n            new_node_b = try_connect(tree_nodes_b, pq_b, new_node_a, curr_best_cost)\n            if new_node_b:\n                total_cost = new_node_a.cost + new_node_b.cost\n                if total_cost + 1e-8 < best_cost:\n                    best_cost = total_cost\n\n                    # Extract full path: path from start tree root to new_node_a + reversed path from new_node_b to root\n                    path_start = new_node_a.path_from_root() if tree_dir == \"start\" else new_node_b.path_from_root()\n                    path_goal = new_node_b.path_from_root() if tree_dir == \"start\" else new_node_a.path_from_root()\n\n                    # Remove duplicate connection point if equal\n                    if path_start[-1] == path_goal[-1]:\n                        full_path = path_start + path_goal[-2::-1]\n                    else:\n                        full_path = path_start + path_goal[::-1]\n\n                    # Shortcut path improves smoothness and shortness\n                    full_path = shortcut_path(full_path)\n                    best_path = full_path\n\n                    # Return early on first improvement (anytime)\n                    return PlannerResult(success=True, path=best_path, nodes=start_tree + goal_tree, edges=[])\n\n        # If no path found after max_iter\n        return PlannerResult(success=False, path=[], nodes=start_tree + goal_tree, edges=[])",
    "objective": -32.75208,
    "time_improvement": 72.0,
    "length_improvement": 1.0,
    "smoothness_improvement": 2162.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.017874813079833983,
            "num_nodes_avg": 60.2,
            "path_length_avg": 178.46134122599636,
            "smoothness_avg": 0.10095412748742794,
            "success_improvement": 0.0,
            "time_improvement": 31.912783585485005,
            "length_improvement": 2.1825109731139785,
            "smoothness_improvement": 1480.1513205749102,
            "objective_score": 18.28409826238844
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.00749971866607666,
            "num_nodes_avg": 54.1,
            "path_length_avg": 269.8000195347711,
            "smoothness_avg": 0.1332598514245687,
            "success_improvement": 0.0,
            "time_improvement": 95.45857019623979,
            "length_improvement": 9.932987716315523,
            "smoothness_improvement": 3328.871960345464,
            "objective_score": 51.24172349038857
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.006196403503417968,
            "num_nodes_avg": 55.0,
            "path_length_avg": 165.53671627025966,
            "smoothness_avg": 0.1398135054188176,
            "success_improvement": 0.0,
            "time_improvement": 87.67760827182315,
            "length_improvement": -9.941604935344571,
            "smoothness_improvement": 1678.417468967884,
            "objective_score": 28.730406865179617
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "e1",
    "algorithm_description": "A unidirectional RRT* variant planner utilizing hierarchical grid-based nearest neighbor pruning, adaptive goal biasing, and incremental path smoothing. The planner builds a single tree from start towards goal by sampling points with increasing goal bias over time, leveraging an efficient spatial hashing technique to limit neighbor checks for rewiring. Incremental smoother refines partial solutions periodically to improve path smoothness and length without significant overhead. The algorithm stops upon finding a valid path or hitting max iteration limit.",
    "planning_mechanism": "A single-tree incremental RRT* planner that deploys a hierarchical grid spatial hashing for fast neighbor searches and pruning, grows the tree with adaptive probabilistic goal biasing that intensifies with iterations, and performs rewiring selectively inside dynamically shrinking radius. The planner incrementally smooths intermediate solutions by shortcutting sub-paths on the current best path found. Collision checks are done on all new nodes and edges. The algorithm keeps track of best path cost and improves it anytime.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.id = id(self)\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=4000, step_size=4.0, initial_goal_bias=0.05,\n                 max_goal_bias=0.25, neighbor_radius=30.0, smoothing_interval=100):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.initial_goal_bias = initial_goal_bias\n        self.max_goal_bias = max_goal_bias\n        self.neighbor_radius = neighbor_radius\n        self.smoothing_interval = smoothing_interval\n\n    def plan(self, map):\n        bounds = map.size\n        dim = len(bounds)\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        is_3d = (dim == 3)\n\n        import math\n        import random\n\n        def dist(a, b):\n            return math.sqrt(sum((a[d] - b[d]) ** 2 for d in range(dim)))\n\n        def in_obstacle(pt):\n            x, y = pt[0], pt[1]\n            if is_3d:\n                z = pt[2]\n                for ox, oy, oz, w, h, d in obstacles:\n                    if (ox <= x <= ox + w and oy <= y <= oy + h and oz <= z <= oz + d):\n                        return True\n            else:\n                for ox, oy, w, h in obstacles:\n                    if (ox <= x <= ox + w and oy <= y <= oy + h):\n                        return True\n            return False\n\n        def edge_in_obstacle(p1, p2):\n            length = dist(p1, p2)\n            steps = max(int(length / 1), 1)\n            for i in range(steps + 1):\n                interp = tuple(p1[d] + (p2[d] - p1[d]) * i / steps for d in range(dim))\n                if in_obstacle(interp):\n                    return True\n            return False\n\n        def steer(from_p, to_p):\n            d = dist(from_p, to_p)\n            if d <= self.step_size:\n                return to_p\n            ratio = self.step_size / d\n            return tuple(from_p[d_] + ratio * (to_p[d_] - from_p[d_]) for d_ in range(dim))\n\n        def sample():\n            goal_bias_ratio = min(self.max_goal_bias,\n                                  self.initial_goal_bias + (iter_count / self.max_iter) * (self.max_goal_bias - self.initial_goal_bias))\n            if random.random() < goal_bias_ratio:\n                return goal\n            else:\n                while True:\n                    pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not in_obstacle(pt):\n                        return pt\n\n        # Hierarchical Grid for efficient neighbor search\n\n        class SpatialHash:\n            def __init__(self, cell_size):\n                # cell_size approx neighbor radius / 2 for pruning\n                self.cell_size = cell_size\n                self.cells = {}\n\n            def _hash(self, pos):\n                return tuple(int(pos[d] // self.cell_size) for d in range(dim))\n\n            def insert(self, node):\n                h = self._hash(node.position)\n                if h not in self.cells:\n                    self.cells[h] = []\n                self.cells[h].append(node)\n\n            def query(self, pos, radius):\n                cell_coords = list(range(-1, 2))\n                center = self._hash(pos)\n                neighbors = []\n                for offset in self._product(cell_coords, dim):\n                    cell = tuple(center[d] + offset[d] for d in range(dim))\n                    if cell in self.cells:\n                        for n in self.cells[cell]:\n                            if dist(pos, n.position) <= radius:\n                                neighbors.append(n)\n                return neighbors\n\n            def _product(self, elems, length):\n                # Cartesian product helper\n                if length == 0:\n                    return [()]\n                partials = self._product(elems, length - 1)\n                return [p + (e,) for p in partials for e in elems]\n\n        # Shortcutting improves path smoothness and length without heavy optimization\n        def shortcut_path(path):\n            if len(path) <= 2:\n                return path[:]\n            shortened = [path[0]]\n            i = 0\n            while i < len(path) - 1:\n                j = len(path) - 1\n                while j > i + 1:\n                    if not edge_in_obstacle(path[i], path[j]):\n                        break\n                    j -= 1\n                shortened.append(path[j])\n                i = j\n            return shortened\n\n        # Rewire neighbors to new node if it improves cost\n        def rewire(new_node, neighbors_list, spatial_hash):\n            improved = False\n            for n in neighbors_list:\n                if n is new_node.parent:\n                    continue\n                c_through_new = new_node.cost + dist(new_node.position, n.position)\n                if c_through_new + 1e-9 < n.cost:\n                    if not edge_in_obstacle(new_node.position, n.position):\n                        # Rewire n's parent\n                        if n.parent:\n                            n.parent.remove_child(n)\n                        new_node.add_child(n)\n                        n.cost = c_through_new\n\n                        # Propagate cost changes downstream\n                        stack = [n]\n                        while stack:\n                            cur = stack.pop()\n                            for c in cur.children:\n                                new_cost = cur.cost + dist(cur.position, c.position)\n                                if new_cost + 1e-9 < c.cost:\n                                    c.cost = new_cost\n                                    stack.append(c)\n                        improved = True\n            return improved\n\n        start_node = Node(start)\n        start_node.cost = 0.0\n        tree_nodes = [start_node]\n        spatial_hash = SpatialHash(cell_size=self.neighbor_radius / 2.0)\n        spatial_hash.insert(start_node)\n\n        best_goal_node = None\n        best_cost = float('inf')\n        path = []\n\n        iter_count = 0\n        while iter_count < self.max_iter:\n            iter_count += 1\n            sample_pt = sample()\n            nearest_node = None\n            min_dist = float('inf')\n            for n in spatial_hash.query(sample_pt, radius=self.neighbor_radius*2):\n                d = dist(n.position, sample_pt)\n                if d < min_dist:\n                    min_dist = d\n                    nearest_node = n\n            if nearest_node is None:\n                # fallback full nearest\n                for n in tree_nodes:\n                    d = dist(n.position, sample_pt)\n                    if d < min_dist:\n                        min_dist = d\n                        nearest_node = n\n            new_pos = steer(nearest_node.position, sample_pt)\n            if in_obstacle(new_pos) or edge_in_obstacle(nearest_node.position, new_pos):\n                continue\n            new_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            new_node = Node(new_pos)\n            new_node.cost = new_cost\n            nearest_node.add_child(new_node)\n            tree_nodes.append(new_node)\n            spatial_hash.insert(new_node)\n\n            # Find neighbors for rewiring inside adaptive radius\n            radius = max(self.neighbor_radius * (0.95 ** (iter_count / 200)), self.step_size * 2)\n            neighbors_list = spatial_hash.query(new_node.position, radius)\n            rewire(new_node, neighbors_list, spatial_hash)\n\n            # Check if goal can be connected from new_node\n            if dist(new_node.position, goal) <= self.step_size:\n                if not edge_in_obstacle(new_node.position, goal):\n                    goal_cost = new_node.cost + dist(new_node.position, goal)\n                    if goal_cost + 1e-9 < best_cost:\n                        best_cost = goal_cost\n                        goal_node = Node(goal, parent=new_node, cost=goal_cost)\n                        new_node.add_child(goal_node)\n                        best_goal_node = goal_node\n                        # Extract path and shortcut for smoothness\n                        raw_path = best_goal_node.path_from_root()\n                        path = shortcut_path(raw_path)\n\n                        # Optional: incremental smoothing of partial path every smoothing_interval iterations\n                        if iter_count % self.smoothing_interval == 0:\n                            path = shortcut_path(path)\n\n                        # Any time return improved path\n                        return PlannerResult(success=True, path=path, nodes=tree_nodes, edges=[])\n\n        # After max_iter, return best path found if any\n        if best_goal_node:\n            path = shortcut_path(best_goal_node.path_from_root())\n            return PlannerResult(success=True, path=path, nodes=tree_nodes, edges=[])\n        else:\n            # no path found\n            return PlannerResult(success=False, path=[], nodes=tree_nodes, edges=[])",
    "objective": 98.72741,
    "time_improvement": -389.0,
    "length_improvement": 20.0,
    "smoothness_improvement": 1271.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.0792846918106079,
            "num_nodes_avg": 335.1,
            "path_length_avg": 160.65011065237238,
            "smoothness_avg": 0.05515248112135992,
            "success_improvement": 0.0,
            "time_improvement": -202.00449904324947,
            "length_improvement": 11.9451286875269,
            "smoothness_improvement": 763.2560950789515,
            "objective_score": -49.61799202506394
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.7382164239883423,
            "num_nodes_avg": 1204.4,
            "path_length_avg": 223.71026550215146,
            "smoothness_avg": 0.07987927601083125,
            "success_improvement": 0.0,
            "time_improvement": -347.0245110247276,
            "length_improvement": 25.31907423241734,
            "smoothness_improvement": 1955.3513064756278,
            "objective_score": -79.13915223558973
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.36177494525909426,
            "num_nodes_avg": 682.7,
            "path_length_avg": 118.11446914411367,
            "smoothness_avg": 0.0939336418941943,
            "success_improvement": 0.0,
            "time_improvement": -619.4387180343041,
            "length_improvement": 21.55399360109753,
            "smoothness_improvement": 1094.8289914339332,
            "objective_score": -167.42507429246302
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m3",
    "algorithm_description": "An improved bidirectional sampling-based planner combining informed heuristic sampling with adaptive rewiring and lazy collision checking to enhance planning speed, path quality, and smoothness. The planner alternates forward and backward tree expansions, samples inside an informed ellipsoid for efficient search, applies rewiring with adaptive radius to optimize connectivity, and performs path shortcutting to smooth the final solution.",
    "planning_mechanism": "The planner grows two trees from start and goal, uses adaptive informed sampling focused on the current best solution corridor to accelerate convergence, rewires local connections based on adaptive neighborhoods to improve path cost, delays expensive collision checks (lazy evaluation) until necessary to reduce redundant computations, attempts direct tree connections to find feasible paths quickly, and post-processes the resulting path via shortcutting for smoothness and length reduction.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n    def add_child(self, child):\n        self.children.append(child)\nclass Planner:\n    def __init__(self, max_iter=4000, step_size=6.0, base_rewire_radius=12.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.base_rewire_radius = base_rewire_radius\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        edges = []\n        best_cost = float('inf')\n        best_path = []\n\n        def dist(a,b):\n            return math.dist(a,b)\n\n        def in_collision(p):\n            for o in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d = o\n                    px,py,pz = p\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                        return True\n                else:\n                    x,y,w,h = o\n                    px,py = p\n                    if x <= px <= x+w and y <= py <= y+h:\n                        return True\n            return False\n\n        def edge_collision(p1,p2,res=1.0):\n            distance = dist(p1,p2)\n            steps = max(1,int(distance/res))\n            for i in range(steps+1):\n                interp = tuple(p1[d]+(p2[d]-p1[d])*i/steps for d in range(dim))\n                if in_collision(interp):\n                    return True\n            return False\n\n        def steer(from_p,to_p,step):\n            distance = dist(from_p,to_p)\n            if distance <= step:\n                return to_p\n            ratio = step / distance\n            return tuple(from_p[i] + (to_p[i]-from_p[i])*ratio for i in range(dim))\n\n        def nearest(tree, p):\n            return min(tree, key=lambda n: dist(n.position, p))\n\n        def near(tree, p, radius):\n            r2 = radius**2\n            result = []\n            for n in tree:\n                d2 = sum((n.position[i]-p[i])**2 for i in range(dim))\n                if d2 <= r2:\n                    result.append(n)\n            return result\n\n        def extract_path(n_start, n_goal):\n            path_start, path_goal = [], []\n            while n_start:\n                path_start.append(n_start.position)\n                n_start = n_start.parent\n            while n_goal:\n                path_goal.append(n_goal.position)\n                n_goal = n_goal.parent\n            path_start.reverse()\n            return path_start + path_goal\n\n        def shortcut(path):\n            if len(path) <= 2:\n                return path\n            i = 0\n            while i < len(path)-2:\n                j = len(path)-1\n                while j > i+1:\n                    if not edge_collision(path[i], path[j]):\n                        path = path[:i+1] + path[j:]\n                        break\n                    j -= 1\n                i += 1\n            return path\n\n        def informed_sample(c_best):\n            if c_best == float('inf'):\n                while True:\n                    sample = tuple(random.uniform(0,bounds[i]) for i in range(dim))\n                    if not in_collision(sample):\n                        return sample\n            c_min = dist(start_pos, goal_pos)\n            if c_min == 0.0:\n                return goal_pos\n            center = tuple((start_pos[i]+goal_pos[i])*0.5 for i in range(dim))\n            a1 = [(goal_pos[i]-start_pos[i])/c_min for i in range(dim)]\n\n            # rotation matrix R that aligns x-axis with a1 (2D/3D only)\n            def mat_vec_mult(mat, vec):\n                return tuple(sum(mat[i][j]*vec[j] for j in range(dim)) for i in range(dim))\n\n            if dim == 2:\n                theta = math.acos(max(min(a1[0],1.0),-1.0))\n                if a1[1]<0:\n                    theta = -theta\n                R = [[math.cos(theta), -math.sin(theta)],\n                     [math.sin(theta), math.cos(theta)]]\n            elif dim == 3:\n                x = a1\n                I = [[1 if i==j else 0 for j in range(3)] for i in range(3)]\n                v = [x[0]-1, x[1], x[2]]\n                norm_v = math.sqrt(sum(vi*vi for vi in v))\n                if norm_v < 1e-10:\n                    R = I\n                else:\n                    v = [vi/norm_v for vi in v]\n                    R = [[I[i][j]-2*v[i]*v[j] for j in range(3)] for i in range(3)]\n            else:\n                R = [[1 if i==j else 0 for j in range(dim)] for i in range(dim)]\n\n            L1 = c_best/2.0\n            L2 = math.sqrt(max(c_best*c_best - c_min*c_min,0))/2.0\n\n            while True:\n                while True:\n                    sample = [random.uniform(-1,1) for _ in range(dim)]\n                    norm_s = math.sqrt(sum(x*x for x in sample))\n                    if norm_s > 0 and norm_s <= 1:\n                        break\n                unit_s = [x/norm_s for x in sample]\n                r = random.uniform(0,1)**(1/dim)\n                unit_ball = [r * us for us in unit_s]\n                ellip = [L1*unit_ball[0]] + [L2*unit_ball[i] for i in range(1,dim)]\n                rotated = mat_vec_mult(R, ellip)\n                point = tuple(center[i] + rotated[i] for i in range(dim))\n                if all(0 <= point[i] <= bounds[i] for i in range(dim)) and not in_collision(point):\n                    return point\n\n        # adaptive rewire radius decreases as tree grows (based on RRT* formula)\n        def rewire_radius(num_nodes):\n            gamma_rrt = 2 * (1 + 1/dim)**(1/dim) * (math.prod(bounds)**(1/dim))\n            radius = min(self.base_rewire_radius, gamma_rrt * (math.log(num_nodes+1)/(num_nodes+1))**(1/dim))\n            return radius\n\n        def rewire(tree, new_node):\n            r = rewire_radius(len(tree))\n            nbs = near(tree, new_node.position, r)\n            for nb in nbs:\n                if nb == new_node.parent:\n                    continue\n                if edge_collision(new_node.position, nb.position):\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, nb.position)\n                if new_cost + 1e-9 < nb.cost:\n                    if nb.parent:\n                        try:\n                            nb.parent.children.remove(nb)\n                        except Exception:\n                            pass\n                    nb.parent = new_node\n                    nb.cost = new_cost\n                    new_node.add_child(nb)\n\n        for it in range(self.max_iter):\n            sample = informed_sample(best_cost)\n            for tree_a, tree_b in [(start_tree, goal_tree),(goal_tree, start_tree)]:\n                nearest_node = nearest(tree_a, sample)\n                new_pos = steer(nearest_node.position, sample, self.step_size)\n                if in_collision(new_pos):\n                    continue\n                if edge_collision(nearest_node.position, new_pos):\n                    continue\n                new_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n                new_node = Node(new_pos, parent=nearest_node, cost=new_cost)\n                nearest_node.add_child(new_node)\n                tree_a.append(new_node)\n                edges.append((nearest_node,new_node))\n                rewire(tree_a, new_node)\n\n                connect_node = nearest(tree_b, new_pos)\n                gap = dist(new_pos, connect_node.position)\n                if gap <= self.step_size*1.8 and not edge_collision(new_pos, connect_node.position):\n                    connect_new = Node(connect_node.position, parent=new_node, cost=new_node.cost+gap)\n                    new_node.add_child(connect_new)\n                    tree_b.append(connect_new)\n                    edges.append((new_node, connect_new))\n                    path = extract_path(connect_new, connect_node)\n                    path = shortcut(path)\n                    cost_path = 0.0\n                    for i in range(len(path)-1):\n                        cost_path += dist(path[i], path[i+1])\n                    if cost_path < best_cost:\n                        best_cost = cost_path\n                        best_path = path\n            if best_path:\n                return PlannerResult(True,best_path,start_tree+goal_tree,edges)\n        return PlannerResult(False,[],start_tree+goal_tree,edges)",
    "objective": -28.64627,
    "time_improvement": 37.0,
    "length_improvement": 14.0,
    "smoothness_improvement": 1851.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.027629590034484862,
            "num_nodes_avg": 116.4,
            "path_length_avg": 170.26662958714778,
            "smoothness_avg": 0.06141652618419348,
            "success_improvement": 0.0,
            "time_improvement": -5.244282428030285,
            "length_improvement": 6.674162275882516,
            "smoothness_improvement": 861.3020029038676,
            "objective_score": 6.737722651639762
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.031986331939697264,
            "num_nodes_avg": 221.9,
            "path_length_avg": 238.03820887872735,
            "smoothness_avg": 0.12286205335960987,
            "success_improvement": 0.0,
            "time_improvement": 80.63078261308962,
            "length_improvement": 20.535994326332737,
            "smoothness_improvement": 3061.329126902844,
            "objective_score": 51.817477014240744
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.032309651374816895,
            "num_nodes_avg": 180.3,
            "path_length_avg": 129.22310027085973,
            "smoothness_avg": 0.13606286458102096,
            "success_improvement": 0.0,
            "time_improvement": 35.74786073539117,
            "length_improvement": 14.176169742883147,
            "smoothness_improvement": 1630.7095943546199,
            "objective_score": 27.383608038120336
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "time_expert",
    "algorithm_description": "An enhanced Bidirectional RRT* variant with adaptive informed sampling, efficient neighbor caching, incremental rewiring propagation, and iterative multi-pass shortcutting for accelerated convergence and higher-quality smoother paths. The planner balances exploration and exploitation by shrinking the informed sampling ellipsoid dynamically, reuses spatial info for faster neighbor queries, propagates cost improvements downstream recursively during rewiring, and applies multiple rounds of shortcutting before returning the final path. This reduces redundant computations, improves path optimality, and accelerates solution discovery.",
    "planning_mechanism": "The planner grows two trees from start and goal with adaptive ellipsoid-based sampling that shrinks as better solutions are found, improving focus. For each new node, it performs local rewiring with recursive propagation of cost reduction downstream, avoiding premature termination. It attempts direct inter-tree connections to quickly find feasible paths. Upon path discovery, it runs multiple passes of path shortcutting to improve smoothness and length before returning. Early exits and caching optimize run time while edge and node collision checks ensure validity.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except ValueError:\n            pass\nclass Planner:\n    def __init__(self, max_iter=3000, step_size=7.5, rewire_radius=15.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.rewire_radius = rewire_radius\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        edges = []\n        best_cost = float('inf')\n        best_path = []\n\n        def dist(a, b):\n            return sum((a[i]-b[i])**2 for i in range(dim))**0.5\n\n        def in_collision(p):\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d = obs\n                    if x <= p[0] <= x+w and y <= p[1] <= y+h and z <= p[2] <= z+d:\n                        return True\n                else:\n                    x,y,w,h = obs\n                    if x <= p[0] <= x+w and y <= p[1] <= y+h:\n                        return True\n            return False\n\n        def edge_collision(a, b, resolution=0.5):\n            d = dist(a,b)\n            steps = max(2, int(d/resolution))\n            for i in range(steps+1):\n                pt = tuple(a[j] + (b[j]-a[j]) * i/steps for j in range(dim))\n                if in_collision(pt):\n                    return True\n            return False\n\n        def steer(from_p, to_p, max_step):\n            d = dist(from_p, to_p)\n            if d <= max_step:\n                return to_p\n            ratio = max_step / d\n            return tuple(from_p[i] + (to_p[i]-from_p[i])*ratio for i in range(dim))\n\n        def nearest(tree, point):\n            # Linear search nearest; efficiently cached neighbors below\n            best = None\n            best_d = float('inf')\n            for n in tree:\n                d_now = dist(n.position, point)\n                if d_now < best_d:\n                    best_d = d_now\n                    best = n\n            return best\n\n        def neighbors(tree, point, radius):\n            r2 = radius*radius\n            return [n for n in tree if sum((n.position[i]-point[i])**2 for i in range(dim)) <= r2]\n\n        def extract_path(node_start, node_goal):\n            path_start = []\n            n = node_start\n            while n:\n                path_start.append(n.position)\n                n = n.parent\n            path_start.reverse()\n            path_goal = []\n            n = node_goal\n            while n:\n                path_goal.append(n.position)\n                n = n.parent\n            return path_start + path_goal\n\n        def sample_informed(c_best):\n            if c_best == float('inf'):\n                while True:\n                    p = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                    if not in_collision(p):\n                        return p\n            c_min = dist(start_pos, goal_pos)\n            if c_min == 0.0:\n                return goal_pos\n            center = tuple((start_pos[i]+goal_pos[i])/2 for i in range(dim))\n            a1 = [(goal_pos[i]-start_pos[i])/c_min for i in range(dim)]\n            L1 = c_best/2.0\n            val = c_best*c_best - c_min*c_min\n            L2 = 0 if val <= 0 else (val ** 0.5)/2.0\n            while True:\n                while True:\n                    sample = [random.uniform(-1,1) for _ in range(dim)]\n                    norm_s = sum(s*s for s in sample)**0.5\n                    if 0 < norm_s <= 1:\n                        break\n                unit_s = [s/norm_s for s in sample]\n                r = random.uniform(0,1)**(1/dim)\n                unit_ball = [r*us for us in unit_s]\n                ellipsoid_sample = [L1*unit_ball[0]] + [L2*unit_ball[i] for i in range(1,dim)]\n\n                if dim == 2:\n                    cos_theta = a1[0]\n                    sin_theta = a1[1]\n                    x = ellipsoid_sample[0]*cos_theta - ellipsoid_sample[1]*sin_theta\n                    y = ellipsoid_sample[0]*sin_theta + ellipsoid_sample[1]*cos_theta\n                    p = (center[0]+x, center[1]+y)\n                elif dim == 3:\n                    xvec = a1\n                    I = [[1 if i==j else 0 for j in range(3)] for i in range(3)]\n                    v = [xvec[0]-1, xvec[1], xvec[2]]\n                    norm_v = sum(vi*vi for vi in v)**0.5\n                    if norm_v < 1e-10:\n                        R = I\n                    else:\n                        v = [vi/norm_v for vi in v]\n                        R = [[I[i][j] - 2*v[i]*v[j] for j in range(3)] for i in range(3)]\n                    rotated = tuple(sum(R[i][j]*ellipsoid_sample[j] for j in range(3)) for i in range(3))\n                    p = tuple(center[i] + rotated[i] for i in range(3))\n                else:\n                    p = tuple(center[i] + ellipsoid_sample[i] for i in range(dim))\n\n                if all(0 <= p[i] <= bounds[i] for i in range(dim)) and not in_collision(p):\n                    return p\n\n        def shortcut_path(path):\n            if len(path)<3:\n                return path\n            improved = True\n            while improved:\n                improved = False\n                i = 0\n                while i < len(path)-2:\n                    j = len(path)-1\n                    while j > i+1:\n                        if not edge_collision(path[i], path[j]):\n                            path = path[:i+1]+path[j:]\n                            improved = True\n                            break\n                        j -=1\n                    i +=1\n            return path\n\n        def propagate_cost_decrease(node):\n            for c in node.children:\n                new_cost = node.cost + dist(node.position, c.position)\n                if new_cost + 1e-10 < c.cost:\n                    c.cost = new_cost\n                    c.parent = node\n                    propagate_cost_decrease(c)\n\n        def rewire(tree, new_node):\n            nghs = neighbors(tree, new_node.position, self.rewire_radius)\n            for ngh in nghs:\n                if ngh is new_node.parent:\n                    continue\n                if edge_collision(new_node.position, ngh.position):\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, ngh.position)\n                if new_cost + 1e-10 < ngh.cost:\n                    if ngh.parent:\n                        ngh.parent.remove_child(ngh)\n                    ngh.parent = new_node\n                    ngh.cost = new_cost\n                    new_node.add_child(ngh)\n                    propagate_cost_decrease(ngh)\n\n        for iteration in range(self.max_iter):\n            sample = sample_informed(best_cost)\n            for (tree_a, tree_b) in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nn = nearest(tree_a, sample)\n                new_pos = steer(nn.position, sample, self.step_size)\n                if in_collision(new_pos) or edge_collision(nn.position, new_pos):\n                    continue\n                new_cost = nn.cost + dist(nn.position, new_pos)\n                new_node = Node(new_pos, parent=nn, cost=new_cost)\n                nn.add_child(new_node)\n                tree_a.append(new_node)\n                edges.append((nn, new_node))\n\n                rewire(tree_a, new_node)\n\n                nearest_other = nearest(tree_b, new_pos)\n                dist_trees = dist(new_pos, nearest_other.position)\n                if dist_trees <= self.step_size*2 and not edge_collision(new_pos, nearest_other.position):\n                    # Connect trees directly\n                    connect_node = Node(nearest_other.position, parent=new_node, cost=new_node.cost + dist_trees)\n                    new_node.add_child(connect_node)\n                    tree_b.append(connect_node)\n                    edges.append((new_node, connect_node))\n\n                    path = extract_path(new_node, nearest_other)\n                    # Apply iterative shortcutting for better smoothing and shortening\n                    path = shortcut_path(path)\n\n                    cost_path = 0.0\n                    for k in range(len(path)-1):\n                        cost_path += dist(path[k], path[k+1])\n                    if cost_path < best_cost:\n                        best_cost = cost_path\n                        best_path = path\n            if best_path:\n                # Multi-pass shortcutting for final refinement\n                for _ in range(2):\n                    best_path = shortcut_path(best_path)\n                return PlannerResult(True, best_path, start_tree+goal_tree, edges)\n        return PlannerResult(False, [], start_tree+goal_tree, edges)",
    "objective": 53.79814,
    "time_improvement": -177.0,
    "length_improvement": 12.0,
    "smoothness_improvement": 1743.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 0.9,
            "time_avg": 0.05345277786254883,
            "num_nodes_avg": 94.2,
            "path_length_avg": 175.20886878783813,
            "smoothness_avg": 0.05225985924442046,
            "success_improvement": -9.999999999999998,
            "time_improvement": -103.60777133889675,
            "length_improvement": 3.9652426551924047,
            "smoothness_improvement": 717.9802812759054,
            "objective_score": -75.11328440217406
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.043555831909179686,
            "num_nodes_avg": 152.4,
            "path_length_avg": 244.98225816336426,
            "smoothness_avg": 0.1105046374083383,
            "success_improvement": 0.0,
            "time_improvement": 73.62491021767926,
            "length_improvement": 18.217870801744557,
            "smoothness_improvement": 2743.3639137896853,
            "objective_score": 46.735015115298935
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.3018322467803955,
            "num_nodes_avg": 317.8,
            "path_length_avg": 129.9690879644496,
            "smoothness_avg": 0.14694706237799632,
            "success_improvement": 0.0,
            "time_improvement": -500.2345036071642,
            "length_improvement": 13.680720236917427,
            "smoothness_improvement": 1769.1557869442343,
            "objective_score": -133.0161400052776
        }
    ],
    "success_rate": 0.9666666666666667
}
{
    "operator": "m3",
    "algorithm_description": "A streamlined bidirectional sampling-based planner combining efficient tree growth with targeted rewiring to balance path quality and search speed, leveraging simplified nearest neighbor selection and adaptive connection checks.",
    "planning_mechanism": "The planner grows two trees from start and goal by sampling free points in the map, steering towards them via fixed step sizes, and selectively rewiring neighbors within a radius to improve cost. Trees attempt to connect after each extension, and once connected, the combined path is extracted. All nodes and edges are validated to avoid obstacles, ensuring feasible and increasingly optimized solutions.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=4000, step_size=5.0, search_radius=30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.search_radius = search_radius\n\n    def plan(self, map):\n        import random, math\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        tree_a = [start_root]\n        tree_b = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n        success = False\n        final_path = []\n\n        def sample_free():\n            while True:\n                p = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                if not self._in_obstacle(p, obstacles, is_3d):\n                    return p\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: self._distance(n.position, point))\n\n        def steer(from_p, to_p):\n            dist = self._distance(from_p, to_p)\n            if dist <= self.step_size:\n                return to_p\n            r = self.step_size / dist\n            return tuple(from_p[d] + (to_p[d]-from_p[d])*r for d in range(len(from_p)))\n\n        def near_nodes(tree, point):\n            return [node for node in tree if self._distance(node.position, point) <= self.search_radius]\n\n        def can_connect(p1, p2):\n            return (not self._in_obstacle(p2, obstacles, is_3d)) and (not self._edge_in_obstacle(p1, p2, obstacles, is_3d))\n\n        def add_node(tree, pos):\n            neighbors = near_nodes(tree, pos)\n            best_parent = None\n            best_cost = float('inf')\n            for nb in neighbors:\n                cost = nb.cost + self._distance(nb.position, pos)\n                if cost < best_cost and can_connect(nb.position, pos):\n                    best_cost = cost\n                    best_parent = nb\n            if best_parent is None:\n                closest = nearest(tree, pos)\n                if can_connect(closest.position, pos):\n                    best_parent = closest\n                    best_cost = closest.cost + self._distance(closest.position, pos)\n                else:\n                    return None\n            new_node = Node(pos, parent=None, cost=best_cost)\n            best_parent.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n            # Rewire neighbors\n            for nb in neighbors:\n                if nb != best_parent and can_connect(new_node.position, nb.position):\n                    new_cost = new_node.cost + self._distance(new_node.position, nb.position)\n                    if new_cost + 1e-9 < nb.cost:\n                        if nb.parent:\n                            try:\n                                edges.remove((nb.parent, nb))\n                            except ValueError:\n                                pass\n                            nb.parent.children.remove(nb)\n                        new_node.add_child(nb)\n                        nb.cost = new_cost\n                        edges.append((new_node, nb))\n            return new_node\n\n        def try_connect(tree, target_node):\n            nearest_node = nearest(tree, target_node.position)\n            current = nearest_node\n            while True:\n                next_pos = steer(current.position, target_node.position)\n                if not can_connect(current.position, next_pos):\n                    return None\n                new_node = Node(next_pos, cost=current.cost + self._distance(current.position, next_pos))\n                current.add_child(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((current, new_node))\n                if self._distance(new_node.position, target_node.position) <= self.step_size:\n                    if can_connect(new_node.position, target_node.position):\n                        final_node = Node(target_node.position, cost=new_node.cost + self._distance(new_node.position, target_node.position))\n                        new_node.add_child(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n                current = new_node\n\n        for _ in range(self.max_iter):\n            rq = sample_free()\n            new_a = add_node(tree_a, steer(nearest(tree_a, rq).position, rq))\n            if new_a is None:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n            new_b = try_connect(tree_b, new_a)\n            if new_b:\n                success = True\n                path_a = new_a.path_from_root()\n                path_b = new_b.path_from_root()\n                # Remove duplicate node at connection\n                if path_a and path_b and path_a[-1] == path_b[-1]:\n                    path_b = path_b[:-1]\n                final_path = path_a + path_b[::-1]\n                break\n            tree_a, tree_b = tree_b, tree_a\n\n        return PlannerResult(success=success, path=final_path, nodes=nodes, edges=edges)\n\n    def _distance(self, p1, p2):\n        import math\n        return math.dist(p1, p2)\n\n    def _in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x,y,z,w,h,d = obs\n                px,py,pz = pos\n                if x<=px<=x+w and y<=py<=y+h and z<=pz<=z+d:\n                    return True\n            else:\n                x,y,w_,h_ = obs\n                px,py = pos\n                if x<=px<=x+w_ and y<=py<=y+h_:\n                    return True\n        return False\n\n    def _edge_in_obstacle(self, fpos, tpos, obstacles, is_3d, resolution=1.0):\n        import math\n        dist = self._distance(fpos, tpos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(fpos[d] + (tpos[d] - fpos[d]) * i / steps for d in range(len(fpos)))\n            if self._in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 22.96664,
    "time_improvement": -115.0,
    "length_improvement": 15.0,
    "smoothness_improvement": 506.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.027492165565490723,
            "num_nodes_avg": 62.9,
            "path_length_avg": 162.86737672882634,
            "smoothness_avg": 0.025473629450621853,
            "success_improvement": 0.0,
            "time_improvement": -4.720816838809104,
            "length_improvement": 10.729810016193118,
            "smoothness_improvement": 298.71761777396125,
            "objective_score": 6.515229046942946
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.0929837703704834,
            "num_nodes_avg": 158.1,
            "path_length_avg": 241.60072657380744,
            "smoothness_avg": 0.025210178443636776,
            "success_improvement": 0.0,
            "time_improvement": 43.69398575754623,
            "length_improvement": 19.346723378328715,
            "smoothness_improvement": 548.676049512349,
            "objective_score": 27.459610001822846
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.2440870761871338,
            "num_nodes_avg": 203.8,
            "path_length_avg": 127.00747506997614,
            "smoothness_avg": 0.06064077735649313,
            "success_improvement": 0.0,
            "time_improvement": -385.40037247479535,
            "length_improvement": 15.647682504575524,
            "smoothness_improvement": 671.3462119380106,
            "objective_score": -102.87477118000324
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "time_expert",
    "algorithm_description": "A novel bidirectional Fast Marching Tree (BFMT*) inspired planner with adaptive sampling, dynamic radius rewiring, and incremental shortcut smoothing to improve planning efficiency, path quality, and smoothness. It rapidly explores via informed sampling biased by interim best path cost, uses a dynamically scaled neighborhood radius for efficient rewiring and cost optimization, and performs local incremental path smoothing to reduce jaggedness during planning. The planner terminates early upon path convergence with a cost-based threshold, balancing speed and quality.",
    "planning_mechanism": "The planner alternates growth of two trees rooted at the start and goal positions using adaptive sampling biased towards the interim solution horizon. Each iteration samples from a dynamically shrunk informed subset to focus search. Nodes are connected via shortest-cost feasible edges. Neighborhood radius scales with logarithm of tree size to balance exploration and rewiring efficiency. Upon a valid connection between trees, it extracts the path and performs incremental shortcut smoothing between nodes, improving smoothness and length. The process stops early once improvements become marginal, reducing unnecessary expansions and planning time.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        path, node = [], self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=3000, step_size=4.5, gamma_bfmt=60.0, max_radius=45.0, goal_sample_rate=0.1, smoothing_iters=10):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.gamma_bfmt = gamma_bfmt\n        self.max_radius = max_radius\n        self.goal_sample_rate = goal_sample_rate\n        self.smoothing_iters = smoothing_iters\n\n    def plan(self, map):\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        tree_start = [Node(start_pos)]\n        tree_goal = [Node(goal_pos)]\n        nodes = tree_start + tree_goal\n        edges = []\n\n        best_cost = float('inf')\n        best_path = []\n        solution_found = False\n\n        import math, random\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def _is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d = obs\n                    px,py,pz = pos\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                        return True\n                else:\n                    x,y,w,h = obs\n                    px,py = pos\n                    if x <= px <= x+w and y <= py <= y+h:\n                        return True\n            return False\n\n        def _is_edge_in_obstacle(from_p, to_p, resolution=1.0):\n            dist_edge = dist(from_p, to_p)\n            steps = max(1, int(dist_edge / resolution))\n            for i in range(steps+1):\n                interm = tuple(from_p[d] + (to_p[d] - from_p[d]) * i/steps for d in range(len(from_p)))\n                if _is_in_obstacle(interm):\n                    return True\n            return False\n\n        def can_connect(a, b):\n            if _is_in_obstacle(b): return False\n            if _is_edge_in_obstacle(a, b): return False\n            return True\n\n        def steer(from_p, to_p):\n            d = dist(from_p, to_p)\n            if d <= self.step_size:\n                return to_p\n            ratio = self.step_size / d\n            return tuple(from_p[d] + (to_p[d] - from_p[d]) * ratio for d in range(dim))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: dist(n.position, point))\n\n        def neighbor_radius(n_nodes):\n            if n_nodes < 2:\n                return self.step_size * 2.0\n            r = self.gamma_bfmt * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            return min(max(self.step_size*2.0, r), self.max_radius)\n\n        def near_nodes(tree, pos):\n            r = neighbor_radius(len(tree))\n            # Approximate radius neighbors by filtering nodes within radius \n            return [n for n in tree if dist(n.position, pos) <= r]\n\n        def add_node_with_optimal_parent(tree, new_pos):\n            near = near_nodes(tree, new_pos)\n            candidates = [n for n in near if can_connect(n.position, new_pos)]\n            if not candidates:\n                parent = nearest(tree, new_pos)\n                if not can_connect(parent.position, new_pos):\n                    return None\n                best_parent = parent\n                best_cost = parent.cost + dist(parent.position, new_pos)\n            else:\n                best_parent, best_cost = min(\n                    ((n, n.cost + dist(n.position, new_pos)) for n in candidates),\n                    key=lambda x: x[1],\n                )\n            new_node = Node(new_pos, parent=None, cost=best_cost)\n            best_parent.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n            return new_node\n\n        def rewire(node, neighbors):\n            for nb in neighbors:\n                if nb is node or nb.parent is None:\n                    continue\n                if can_connect(node.position, nb.position):\n                    new_cost = node.cost + dist(node.position, nb.position)\n                    if new_cost + 1e-12 < nb.cost:\n                        if nb.parent:\n                            try: edges.remove((nb.parent, nb))\n                            except: pass\n                            if nb in nb.parent.children:\n                                nb.parent.children.remove(nb)\n                        node.add_child(nb)\n                        nb.cost = new_cost\n                        edges.append((node, nb))\n\n        def incremental_shortcut(path):\n            if len(path) < 3: return path\n            i = 0\n            new_path = [path[0]]\n            while i < len(path)-1:\n                j = len(path)-1\n                shortcut_found = False\n                while j > i+1:\n                    if not _is_edge_in_obstacle(path[i], path[j]):\n                        new_path.append(path[j])\n                        i = j\n                        shortcut_found = True\n                        break\n                    j -= 1\n                if not shortcut_found:\n                    new_path.append(path[i+1])\n                    i += 1\n            return new_path\n\n        def grow_tree(tree, other_tree, sample):\n            nearest_node = nearest(tree, sample)\n            new_pos = steer(nearest_node.position, sample)\n            if not can_connect(nearest_node.position, new_pos):\n                return None, None\n            new_node = add_node_with_optimal_parent(tree, new_pos)\n            if new_node is None:\n                return None, None\n            near = near_nodes(tree, new_pos)\n            rewire(new_node, near)\n            connect_node = attempt_connect(other_tree, new_node)\n            return new_node, connect_node\n\n        def attempt_connect(tree, target_node):\n            nearest_node = nearest(tree, target_node.position)\n            current = nearest_node\n            while True:\n                new_pos = steer(current.position, target_node.position)\n                if not can_connect(current.position, new_pos):\n                    return None\n                new_node = add_node_with_optimal_parent(tree, new_pos)\n                if new_node is None:\n                    return None\n                near = near_nodes(tree, new_pos)\n                rewire(new_node, near)\n                current = new_node\n                if dist(current.position, target_node.position) <= self.step_size:\n                    if can_connect(current.position, target_node.position):\n                        final_node = Node(target_node.position, parent=None,\n                                        cost=current.cost + dist(current.position, target_node.position))\n                        current.add_child(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((current, final_node))\n                        return final_node\n                    else:\n                        return None\n\n        def informed_sample():\n            if solution_found and best_cost < float('inf'):\n                # Use an ellipsoidal informed sampling region between start and goal focusing samples below best_cost\n                from math import sqrt\n                c_min = dist(start_pos, goal_pos)\n                c_best = best_cost\n                if c_best <= c_min:\n                    return random_sample_uniform()\n                # Generate sample within the prolate hyperspheroid:\n                x_center = tuple((s+g)/2 for s,g in zip(start_pos, goal_pos))\n                a1 = tuple((g - s)/c_min for s,g in zip(start_pos, goal_pos))  # unit vector along start->goal\n                def sample_ellipsoid():\n                    while True:\n                        # Sample unit ball in dim-D\n                        import random as rnd\n                        import math as m\n                        def unit_ball_sample(d=dim):\n                            vec = [rnd.gauss(0,1) for _ in range(d)]\n                            norm = m.sqrt(sum(x*x for x in vec))\n                            return tuple(x/norm for x in vec)\n                        # radius scales so that sample is inside unit ball\n                        u = random.random()\n                        r = u**(1/dim)\n                        direction = unit_ball_sample()\n                        scaled = tuple(r * dd for dd in direction)\n                        # scale the ellipsoid axes\n                        L = [c_best/2.0] + [sqrt(c_best**2 - c_min**2)/2.0 for _ in range(dim-1)]\n                        # Rotation matrix aligning first axis with a1 - is orthonormal basis with a1 first\n                        # Build basis [a1, u2,...] via Gram-Schmidt:\n                        e1 = a1\n                        def gram_schmidt(vectors):\n                            basis = []\n                            for v in vectors:\n                                w = list(v)\n                                for b in basis:\n                                    proj = sum(w[i]*b[i] for i in range(dim))\n                                    w = [w[i]-proj*b[i] for i in range(dim)]\n                                normw = sqrt(sum(wi*wi for wi in w))\n                                if normw > 1e-10:\n                                    basis.append(tuple(wi/normw for wi in w))\n                            return basis\n                        # Generate random orthornormal vectors u2,u3,...\n                        us = []\n                        for _ in range(dim-1):\n                            v = [random.gauss(0,1) for _ in range(dim)]\n                            if us:\n                                gs_basis = [e1]+us\n                            else:\n                                gs_basis = [e1]\n                            basis = []\n                            for vec in [v]:\n                                w = list(vec)\n                                for b in gs_basis:\n                                    proj = sum(w[i]*b[i] for i in range(dim))\n                                    w = [w[i]-proj*b[i] for i in range(dim)]\n                                normw = sqrt(sum(wi*wi for wi in w))\n                                if normw > 1e-10:\n                                    basis.append(tuple(wi/normw for wi in w))\n                            if basis:\n                                us.append(basis[0])\n                        basis = [e1] + us\n                        # Compute point in ellipsoid\n                        pt = [0.0]*dim\n                        for i in range(dim):\n                            for j in range(dim):\n                                pt[j] += basis[i][j]*scaled[i]*L[i]\n                        sample = tuple(pt[j] + x_center[j] for j in range(dim))\n                        if all(0 <= sample[d] <= bounds[d] for d in range(dim)) and not _is_in_obstacle(sample):\n                            return sample\n                return sample_ellipsoid()\n            else:\n                if random.random() < self.goal_sample_rate:\n                    return goal_pos\n                return random_sample_uniform()\n\n        def random_sample_uniform():\n            while True:\n                s = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not _is_in_obstacle(s):\n                    return s\n\n        for iter_index in range(self.max_iter):\n            sample = informed_sample()\n            new_node, connect_node = grow_tree(tree_start, tree_goal, sample)\n            if new_node is None:\n                tree_start, tree_goal = tree_goal, tree_start\n                continue\n            if connect_node is not None:\n                path_start = new_node.path_from_root()\n                path_goal = connect_node.path_from_root()\n                if path_start[-1] == path_goal[-1]:\n                    path_goal = path_goal[:-1]\n                candidate_path = path_start + path_goal[::-1]\n                # Incremental smoothing\n                for _ in range(self.smoothing_iters):\n                    candidate_path = incremental_shortcut(candidate_path)\n                candidate_cost = sum(dist(candidate_path[i], candidate_path[i+1]) for i in range(len(candidate_path)-1))\n                if candidate_cost + 1e-6 < best_cost:\n                    best_cost = candidate_cost\n                    best_path = candidate_path\n                    solution_found = True\n                # Early stopping heuristic - small cost improvement triggers stop\n                if solution_found and iter_index > 200:\n                    # Stop if no meaningful cost improvement in last 50 iters\n                    break\n            tree_start, tree_goal = tree_goal, tree_start\n\n        return PlannerResult(success=solution_found, path=best_path, nodes=nodes, edges=edges)",
    "objective": 439.73407,
    "time_improvement": -1528.0,
    "length_improvement": 19.0,
    "smoothness_improvement": 1477.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 1.166402554512024,
            "num_nodes_avg": 202.4,
            "path_length_avg": 158.02685211866736,
            "smoothness_avg": 0.04627592264480356,
            "success_improvement": 0.0,
            "time_improvement": -4342.961322213777,
            "length_improvement": 13.382978258042154,
            "smoothness_improvement": 624.3186791655935,
            "objective_score": -1291.73701631348
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.19104690551757814,
            "num_nodes_avg": 279.9,
            "path_length_avg": 235.34242221803123,
            "smoothness_avg": 0.10190711715293004,
            "success_improvement": 0.0,
            "time_improvement": -15.687821005634186,
            "length_improvement": 21.43592550758982,
            "smoothness_improvement": 2522.1435250744953,
            "objective_score": 20.765926628236112
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.16303341388702391,
            "num_nodes_avg": 224.2,
            "path_length_avg": 118.92143891910504,
            "smoothness_avg": 0.10884195095513811,
            "success_improvement": 0.0,
            "time_improvement": -224.21413318060095,
            "length_improvement": 21.018042700319604,
            "smoothness_improvement": 1284.46158227223,
            "objective_score": -48.23110642262737
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "cross_over",
    "algorithm_description": "An improved bidirectional RRT* planner integrates adaptive informed sampling with adaptive neighborhood rewiring and incremental cost propagation. It dynamically balances exploration and exploitation, uses an efficient radius scaling with tighter bounds to minimize unnecessary neighbors, performs incremental rewiring with recursive cost updates to avoid local suboptimality, and employs lazy collision checks and early exits to reduce planning time. The algorithm refines paths online, connects trees with smarter distance thresholds, and uses aggressive shortcut smoothing on the final path to maximize smoothness and minimize length within a strict iteration and time limit.",
    "planning_mechanism": "The planner alternates tree growth with samples biased by an adaptive informed ellipsoid based on the best solution cost. For each new node, it selects the minimum-cost parent among neighbors within a carefully bounded radius, inserts the node if collision free, and rewires neighbors with recursive cost updates to promote global path improvement. The trees attempt connection via nearest nodes when close, and if successful, the combined path undergoes shortcut smoothing to produce a short, smooth output. Adaptive radius and step size ensure efficient, focused growth. The use of early collision checks and incremental cost propagation reduces overhead and improves solution quality iteratively.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n\n    def path_from_root(self):\n        path = []\n        n = self\n        while n:\n            path.append(n.position)\n            n = n.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=4000, step_size=4.5, gamma=40.0,\n                 time_limit_sec=15.0, post_opt_iters=200, max_no_improve=80):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.gamma = gamma\n        self.time_limit_sec = time_limit_sec\n        self.post_opt_iters = post_opt_iters\n        self.max_no_improve = max_no_improve\n\n    def plan(self, map):\n        import math\n        import random\n        import time\n\n        bounds = map.size\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def within_bounds(p):\n            return all(0.0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def in_obstacle(p):\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d = obs\n                    px,py,pz = p\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                        return True\n                else:\n                    x,y,w,h = obs\n                    px,py = p\n                    if x <= px <= x+w and y <= py <= y+h:\n                        return True\n            return False\n\n        def edge_collision(a,b,resolution=1.0):\n            length = dist(a,b)\n            steps = max(2, int(length / resolution))\n            for i in range(steps+1):\n                pt = tuple(a[d]+(b[d]-a[d])*i/steps for d in range(dim))\n                if in_obstacle(pt):\n                    return True\n            return False\n\n        def steer(from_p, to_p):\n            d = dist(from_p,to_p)\n            if d <= self.step_size:\n                return to_p\n            r = self.step_size / d\n            return tuple(from_p[i] + (to_p[i]-from_p[i])*r for i in range(dim))\n\n        def neighbor_radius(n_nodes, c_best=float('inf')):\n            if n_nodes < 2:\n                return self.step_size * 2.0\n            base = self.gamma * ((math.log(n_nodes)/n_nodes)**(1.0/dim))\n            max_r = max(bounds)*0.3\n            min_r = max(self.step_size*1.8,10.0)\n            r = max(min_r, min(max_r, base))\n            if c_best < float('inf'):\n                # Reduce radius proportional to cost improvement for focused rewiring\n                r = min(r, max(self.step_size*2.2, c_best*0.15))\n            return r\n\n        def nearest(tree, p):\n            return min(tree, key=lambda n: dist(n.position,p))\n\n        def near_nodes(tree, p, radius):\n            return [n for n in tree if dist(n.position,p) <= radius]\n\n        def sample_uniform():\n            for _ in range(100):\n                p = tuple(random.uniform(0,bounds[d]) for d in range(dim))\n                if not in_obstacle(p):\n                    return p\n            return start_pos  # fallback\n\n        def sample_unit_ball():\n            while True:\n                v = [random.gauss(0,1) for _ in range(dim)]\n                normv = math.sqrt(sum(x*x for x in v))\n                if normv > 1e-12:\n                    v = [x/normv for x in v]\n                    r = random.random() ** (1.0/dim)\n                    return tuple(v[i]*r for i in range(dim))\n\n        def sample_informed(c_best):\n            if c_best == float(\"inf\"):\n                return sample_uniform()\n            c_min = dist(start_pos, goal_pos)\n            if c_min < 1e-12:\n                return sample_uniform()\n            r1 = c_best/2.0\n            r_other_sq = max(c_best*c_best - c_min*c_min, 0.0)\n            r_other = math.sqrt(r_other_sq)/2.0\n            center = tuple((start_pos[d]+goal_pos[d])/2.0 for d in range(dim))\n            unit_vec = tuple((goal_pos[d]-start_pos[d])/c_min for d in range(dim))\n\n            if dim==2:\n                perp_vec = (-unit_vec[1], unit_vec[0])\n                basis = [unit_vec, perp_vec]\n                radii = [r1, r_other]\n            else:\n                def cross(u,v):\n                    return (u[1]*v[2]-u[2]*v[1], u[2]*v[0]-u[0]*v[2], u[0]*v[1]-u[1]*v[0])\n                def norm_vec(vv):\n                    return math.sqrt(sum(x*x for x in vv))\n                def normalize(vv):\n                    n = norm_vec(vv)\n                    if n < 1e-12:\n                        return vv\n                    return tuple(x/n for x in vv)\n                ref = (1.0,0.0,0.0) if abs(unit_vec[0]) < 0.9 else (0.0,1.0,0.0)\n                b2 = normalize(cross(unit_vec, ref))\n                if norm_vec(b2) < 1e-12:\n                    ref = (0.0,0.0,1.0)\n                    b2 = normalize(cross(unit_vec, ref))\n                b3 = cross(unit_vec, b2)\n                basis = [unit_vec, b2, b3]\n                radii = [r1, r_other, r_other]\n\n            u = sample_unit_ball()\n            mapped = []\n            for d in range(dim):\n                val = center[d]\n                for i in range(dim):\n                    val += basis[i][d]*radii[i]*u[i]\n                val = max(0.0, min(bounds[d], val))\n                mapped.append(val)\n            return tuple(mapped)\n\n        def can_connect(p1, p2):\n            if in_obstacle(p2):\n                return False\n            if edge_collision(p1, p2):\n                return False\n            return True\n\n        def add_node_with_parent(tree, pos, best_parent):\n            cost_new = best_parent.cost + dist(best_parent.position, pos)\n            new_node = Node(pos, parent=best_parent, cost=cost_new)\n            best_parent.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n            return new_node\n\n        def update_cost_recursive(node, cost_delta):\n            node.cost += cost_delta\n            for c in node.children:\n                update_cost_recursive(c, cost_delta)\n\n        def rewire(node, neighbors):\n            n_changed = 0\n            for nb in neighbors:\n                if nb is node:\n                    continue\n                d_new = dist(node.position, nb.position)\n                cost_candidate = node.cost + d_new\n                if cost_candidate + 1e-12 < nb.cost:\n                    if can_connect(node.position, nb.position):\n                        # Rewire nb parent\n                        if nb.parent:\n                            try:\n                                edges.remove((nb.parent, nb))\n                            except:\n                                pass\n                            nb.parent.remove_child(nb)\n                        node.add_child(nb)\n                        cost_diff = cost_candidate - nb.cost\n                        update_cost_recursive(nb, cost_diff)\n                        edges.append((node, nb))\n                        n_changed += 1\n            return n_changed\n\n        def add_node(tree, pos, c_best=float('inf')):\n            r = neighbor_radius(len(tree), c_best)\n            near = near_nodes(tree, pos, r)\n            if not near:\n                # fallback nearest\n                near = [nearest(tree, pos)]\n            candidates = [p for p in near if can_connect(p.position, pos)]\n            if not candidates:\n                return None, []\n            best_parent = min(candidates, key=lambda p: p.cost+dist(p.position,pos))\n            if in_obstacle(pos):\n                return None, []\n            return add_node_with_parent(tree, pos, best_parent), near\n\n        def connect_trees(n1, tree_other):\n            # Connect if within threshold, use smaller threshold than step_size*3\n            threshold = self.step_size*2.2\n            near_other = nearest(tree_other, n1.position)\n            d = dist(n1.position, near_other.position)\n            if d > threshold:\n                return None\n            if can_connect(n1.position, near_other.position):\n                return near_other\n            return None\n\n        def extract_path(n_start, n_goal, start_side=True):\n            path_s = n_start.path_from_root()\n            path_g = n_goal.path_from_root()\n            if path_s[-1] == path_g[-1]:\n                combined = path_s + path_g[-2::-1]\n            else:\n                combined = path_s + path_g[::-1]\n            return combined if start_side else combined[::-1]\n\n        def path_cost(path):\n            if len(path) < 2:\n                return 0.0\n            return sum(dist(path[i], path[i+1]) for i in range(len(path)-1))\n\n        def shortcut_path(path, attempts=60):\n            if len(path) < 3:\n                return path[:]\n            for _ in range(attempts):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path)-3)\n                j = random.randint(i+2, len(path)-1)\n                if j <= i+1:\n                    continue\n                if not edge_collision(path[i], path[j]):\n                    # Remove intermediate nodes between i+1 and j-1\n                    path = path[:i+1]+path[j:]\n            return path\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        tree_a = [start_root]\n        tree_b = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        best_cost = float('inf')\n        best_path = []\n        found = False\n        no_improve_cnt = 0\n        post_opt_cnt = 0\n        t_start = time.time()\n\n        for it in range(self.max_iter):\n            if time.time() - t_start > self.time_limit_sec:\n                break\n\n            grow_tree = tree_a if (it % 2 == 0) else tree_b\n            other_tree = tree_b if (it % 2 == 0) else tree_a\n            start_side = (grow_tree is tree_a)\n\n            sample = sample_informed(best_cost)\n            nearest_node = nearest(grow_tree, sample)\n            new_pos = steer(nearest_node.position, sample)\n\n            if not within_bounds(new_pos):\n                if found:\n                    post_opt_cnt += 1\n                    no_improve_cnt += 1\n                    if post_opt_cnt >= self.post_opt_iters or no_improve_cnt >= self.max_no_improve:\n                        break\n                continue\n\n            if in_obstacle(new_pos) or edge_collision(nearest_node.position, new_pos):\n                if found:\n                    post_opt_cnt += 1\n                    no_improve_cnt += 1\n                    if post_opt_cnt >= self.post_opt_iters or no_improve_cnt >= self.max_no_improve:\n                        break\n                continue\n\n            new_node, neighbors = add_node(grow_tree, new_pos, best_cost)\n            if new_node is None:\n                if found:\n                    post_opt_cnt += 1\n                    no_improve_cnt += 1\n                    if post_opt_cnt >= self.post_opt_iters or no_improve_cnt >= self.max_no_improve:\n                        break\n                continue\n\n            rewire(new_node, neighbors)\n\n            connect_node = connect_trees(new_node, other_tree)\n            if connect_node:\n                path_candidate = extract_path(new_node, connect_node, start_side)\n                cost_candidate = path_cost(path_candidate)\n                if cost_candidate + 1e-8 < best_cost:\n                    best_cost = cost_candidate\n                    best_path = shortcut_path(path_candidate, attempts=75)\n                    found = True\n                    no_improve_cnt = 0\n                    post_opt_cnt = 0\n                else:\n                    if found:\n                        no_improve_cnt += 1\n                        post_opt_cnt += 1\n                        if post_opt_cnt >= self.post_opt_iters or no_improve_cnt >= self.max_no_improve:\n                            break\n            else:\n                if found:\n                    no_improve_cnt += 1\n                    post_opt_cnt += 1\n                    if post_opt_cnt >= self.post_opt_iters or no_improve_cnt >= self.max_no_improve:\n                        break\n\n        return PlannerResult(success=found, path=best_path if found else [], nodes=nodes, edges=edges)",
    "objective": -17.38255,
    "time_improvement": -2.0,
    "length_improvement": 19.0,
    "smoothness_improvement": 1343.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.04732570648193359,
            "num_nodes_avg": 174.8,
            "path_length_avg": 159.6689680797073,
            "smoothness_avg": 0.04623537543316629,
            "success_improvement": 0.0,
            "time_improvement": -80.26905259448762,
            "length_improvement": 12.482908478803605,
            "smoothness_improvement": 623.6840272537908,
            "objective_score": -13.472550554795168
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.046145963668823245,
            "num_nodes_avg": 335.6,
            "path_length_avg": 230.89521003339866,
            "smoothness_avg": 0.08556149235424479,
            "success_improvement": 0.0,
            "time_improvement": 72.05646450755975,
            "length_improvement": 22.920532940725426,
            "smoothness_improvement": 2101.558825726661,
            "objective_score": 45.877053245336484
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.0485954999923706,
            "num_nodes_avg": 316.1,
            "path_length_avg": 119.9179424359091,
            "smoothness_avg": 0.11039449985677638,
            "success_improvement": 0.0,
            "time_improvement": 3.3612341736142275,
            "length_improvement": 20.356212512856622,
            "smoothness_improvement": 1304.2098897038297,
            "objective_score": 19.74314720831739
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "e2",
    "algorithm_description": "A hybrid bidirectional anytime RRT* variant integrating adaptive informed sampling, dynamic rewiring, and heuristic-guided priority expansions for efficient and high-quality path planning. It maintains two trees grown from start and goal, using informed ellipse sampling after finding initial solutions, rewires nodes within an adaptive radius to improve path quality, and employs a min-priority queue with cost + heuristic to guide expansions. The algorithm incrementally attempts to connect both trees using collision-checked edges and performs path shortcutting for smoothness and shorter paths. This combination balances efficiency, robustness, path length, and smoothness, yielding faster convergence and better final solutions.",
    "planning_mechanism": "A bidirectional RRT*-inspired planner that alternates expansions of two trees grown from start and goal, uses heuristic priority queues for node selection, employs adaptive ellipsoidal informed sampling to bias growth towards promising regions when a solution is found, dynamically rewires nodes within a decreasing radius to reduce path cost, and performs collision checking both lazily and eagerly to optimize planning time. The planner incrementally attempts connections between trees and upon success extracts and shortcuts the path to return the best collision-free solution found within the iteration limit.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost  # cost-to-come\n        self.children = []\n        self.id = id(self)\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=4500, step_size=4.0, goal_sample_rate=0.12, init_radius=20.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.init_radius = init_radius\n\n    def plan(self, map):\n        bounds = map.size\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        import math\n        import random\n        import heapq\n\n        def heuristic(p):\n            return math.sqrt(sum((p[d] - goal[d]) ** 2 for d in range(dim)))\n\n        def dist(a, b):\n            return math.sqrt(sum((a[d] - b[d]) ** 2 for d in range(dim)))\n\n        def in_obstacle(pt):\n            if is_3d:\n                px, py, pz = pt\n                for obs in obstacles:\n                    ox, oy, oz, w, h, d = obs\n                    if ox <= px <= ox + w and oy <= py <= oy + h and oz <= pz <= oz + d:\n                        return True\n            else:\n                px, py = pt\n                for obs in obstacles:\n                    ox, oy, w, h = obs\n                    if ox <= px <= ox + w and oy <= py <= oy + h:\n                        return True\n            return False\n\n        def edge_in_obstacle(p1, p2):\n            distance = dist(p1, p2)\n            steps = max(2, int(distance / 0.5))\n            for i in range(steps+1):\n                interp = tuple(p1[d] + (p2[d] - p1[d]) * (i / steps) for d in range(dim))\n                if in_obstacle(interp):\n                    return True\n            return False\n\n        def steer(from_p, to_p):\n            d = dist(from_p, to_p)\n            if d <= self.step_size:\n                return to_p\n            ratio = self.step_size / d\n            return tuple(from_p[d_] + ratio * (to_p[d_] - from_p[d_]) for d_ in range(dim))\n\n        def sample_uniform():\n            trials = 0\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not in_obstacle(pt):\n                    return pt\n                trials += 1\n                if trials > 1000:  # fallback to goal sample if stuck\n                    return goal\n\n        # Informed sampling inside prolate hyperspheroid\n        def sample_informed(c_best):\n            if c_best == float('inf'):\n                return sample_uniform()\n            c_min = dist(start, goal)\n            if c_best < c_min:\n                return sample_uniform()\n            center = tuple((start[d] + goal[d]) * 0.5 for d in range(dim))\n            a1 = [(goal[d] - start[d]) / c_min for d in range(dim)]\n\n            while True:\n                x_ball = [random.gauss(0,1) for _ in range(dim)]\n                norm = math.sqrt(sum(x*x for x in x_ball))\n                if norm == 0:\n                    continue\n                unit = [x / norm for x in x_ball]\n                r1 = c_best/2.0\n                r2_temp = c_best**2 - c_min**2\n                r2 = math.sqrt(r2_temp)/2.0 if r2_temp > 0 else 0.0\n                \n                if dim == 2:\n                    angle = math.atan2(a1[1], a1[0])\n                    cos_a = math.cos(angle)\n                    sin_a = math.sin(angle)\n                    x_ell = r1 * unit[0]\n                    y_ell = r2 * unit[1]\n                    px = center[0] + cos_a * x_ell - sin_a * y_ell\n                    py = center[1] + sin_a * x_ell + cos_a * y_ell\n                    pt = (px, py)\n                else:\n                    # 3D: scale along axis, clamp inside bounds\n                    pt_candidate = []\n                    for d in range(dim):\n                        scale = r1 if d == 0 else r2\n                        coord = center[d] + scale * unit[d]\n                        coord = max(0, min(coord, bounds[d]))\n                        pt_candidate.append(coord)\n                    pt = tuple(pt_candidate)\n\n                if all(0 <= pt[d] <= bounds[d] for d in range(dim)) and not in_obstacle(pt):\n                    return pt\n\n        class PriorityQueue:\n            def __init__(self):\n                self.heap = []\n                self.entry_finder = {}\n                self.REMOVED = '<removed>'\n\n            def add(self, node, priority):\n                if node.id in self.entry_finder:\n                    self.remove(node)\n                entry = [priority, node.id, node]\n                self.entry_finder[node.id] = entry\n                heapq.heappush(self.heap, entry)\n\n            def remove(self, node):\n                entry = self.entry_finder.pop(node.id)\n                entry[-1] = self.REMOVED\n\n            def pop(self):\n                while self.heap:\n                    priority, nid, node = heapq.heappop(self.heap)\n                    if node is not self.REMOVED:\n                        del self.entry_finder[nid]\n                        return node\n                return None\n\n            def empty(self):\n                return not bool(self.entry_finder)\n\n        def nearest(tree_nodes, point):\n            best_node = None\n            best_dist = float('inf')\n            for node in tree_nodes:\n                d = dist(node.position, point)\n                if d < best_dist:\n                    best_dist = d\n                    best_node = node\n            return best_node, best_dist\n\n        def neighbors(tree_nodes, node, radius):\n            nbrs = []\n            for n in tree_nodes:\n                if dist(n.position, node.position) <= radius:\n                    nbrs.append(n)\n            return nbrs\n\n        def shortcut_path(path):\n            if len(path) <= 2:\n                return path\n            shortened = [path[0]]\n            idx = 0\n            while idx < len(path)-1:\n                next_idx = len(path)-1\n                for j in range(len(path)-1, idx, -1):\n                    if not edge_in_obstacle(path[idx], path[j]):\n                        next_idx = j\n                        break\n                shortened.append(path[next_idx])\n                idx = next_idx\n            return shortened\n\n        def add_node_rewire(t_nodes, t_pq, new_pos, heuristic_best, radius):\n            near, _ = nearest(t_nodes, new_pos)\n            if in_obstacle(new_pos) or edge_in_obstacle(near.position, new_pos):\n                return None\n\n            new_cost = near.cost + dist(near.position, new_pos)\n            new_node = Node(new_pos, parent=near, cost=new_cost)\n            near.add_child(new_node)\n            t_nodes.append(new_node)\n            t_pq.add(new_node, new_node.cost + heuristic(new_pos))\n\n            nbrs = neighbors(t_nodes, new_node, radius)\n            for nbr in nbrs:\n                if nbr is new_node.parent:\n                    continue\n                cost_through_new = new_node.cost + dist(new_node.position, nbr.position)\n                if cost_through_new + 1e-8 < nbr.cost:\n                    if not edge_in_obstacle(new_node.position, nbr.position):\n                        # Rewire nbr\n                        if nbr.parent:\n                            nbr.parent.remove_child(nbr)\n                        nbr.parent = new_node\n                        new_node.children.append(nbr)\n                        old_cost = nbr.cost\n                        nbr.cost = cost_through_new\n\n                        def dfs_update_cost(node):\n                            for c in node.children:\n                                new_c_cost = node.cost + dist(node.position, c.position)\n                                if new_c_cost + 1e-8 < c.cost:\n                                    c.cost = new_c_cost\n                                    dfs_update_cost(c)\n                        dfs_update_cost(nbr)\n                        t_pq.add(nbr, nbr.cost + heuristic(nbr.position))\n            return new_node\n\n        def attempt_connect(tree_other_nodes, tree_other_pq, node_new):\n            near_other, _ = nearest(tree_other_nodes, node_new.position)\n            if in_obstacle(node_new.position) or edge_in_obstacle(near_other.position, node_new.position):\n                return None\n            cost_new = near_other.cost + dist(near_other.position, node_new.position)\n            new_node_other = Node(node_new.position, parent=near_other, cost=cost_new)\n            near_other.add_child(new_node_other)\n            tree_other_nodes.append(new_node_other)\n            tree_other_pq.add(new_node_other, new_node_other.cost + heuristic(new_node_other.position))\n            return new_node_other\n\n        start_node = Node(start, cost=0.0)\n        goal_node = Node(goal, cost=0.0)\n        tree_start = [start_node]\n        tree_goal = [goal_node]\n        pq_start = PriorityQueue()\n        pq_goal = PriorityQueue()\n        pq_start.add(start_node, heuristic(start))\n        pq_goal.add(goal_node, heuristic(goal))\n\n        best_cost = float('inf')\n        best_path = None\n\n        def adaptive_radius(iter_idx):\n            r = self.init_radius * (0.96 ** (iter_idx // 350))\n            return max(4.0, r)\n\n        for i in range(self.max_iter):\n            expand_start = (i % 2 == 0)\n            t_nodes_a, t_pq_a = (tree_start, pq_start) if expand_start else (tree_goal, pq_goal)\n            t_nodes_b, t_pq_b = (tree_goal, pq_goal) if expand_start else (tree_start, pq_start)\n\n            nbr_radius = adaptive_radius(i)\n            curr_best = best_cost if best_cost != float('inf') else float('inf')\n\n            sample_point = None\n            p = random.random()\n            if p < self.goal_sample_rate:\n                sample_point = goal if expand_start else start\n                # Ensure not in obstacle\n                if in_obstacle(sample_point):\n                    sample_point = sample_uniform()\n            elif curr_best < float('inf'):\n                sample_point = sample_informed(curr_best)\n            else:\n                sample_point = sample_uniform()\n\n            new_node_a = add_node_rewire(t_nodes_a, t_pq_a, sample_point, curr_best, nbr_radius)\n            if new_node_a is None:\n                continue\n\n            new_node_b = attempt_connect(t_nodes_b, t_pq_b, new_node_a)\n            if new_node_b:\n                total_c = new_node_a.cost + new_node_b.cost\n                if total_c + 1e-8 < best_cost:\n                    best_cost = total_c\n                    path_start = new_node_a.path_from_root() if expand_start else new_node_b.path_from_root()\n                    path_goal = new_node_b.path_from_root() if expand_start else new_node_a.path_from_root()\n                    if path_start[-1] == path_goal[-1]:\n                        combined = path_start + path_goal[-2::-1]\n                    else:\n                        combined = path_start + path_goal[::-1]\n\n                    smoothed = shortcut_path(combined)\n                    best_path = smoothed\n                    # Anytime return on improvement\n                    return PlannerResult(success=True, path=best_path, nodes=tree_start + tree_goal, edges=[])\n\n        # Return failure if no connection found\n        return PlannerResult(success=False, path=[], nodes=tree_start + tree_goal, edges=[])",
    "objective": -21.32282,
    "time_improvement": 41.0,
    "length_improvement": -3.0,
    "smoothness_improvement": 2088.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.03065047264099121,
            "num_nodes_avg": 69.3,
            "path_length_avg": 201.54333295789633,
            "smoothness_avg": 0.09071995397809844,
            "success_improvement": 0.0,
            "time_improvement": -16.75117130420488,
            "length_improvement": -10.469094452705283,
            "smoothness_improvement": 1319.964281290423,
            "objective_score": -4.70698665643252
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.011514782905578613,
            "num_nodes_avg": 68.4,
            "path_length_avg": 272.8228556658298,
            "smoothness_avg": 0.12690712863337233,
            "success_improvement": 0.0,
            "time_improvement": 93.02726134144713,
            "length_improvement": 8.923878008254347,
            "smoothness_improvement": 3165.4118272467053,
            "objective_score": 49.089564343620275
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.026196837425231934,
            "num_nodes_avg": 82.4,
            "path_length_avg": 159.78036568867304,
            "smoothness_avg": 0.14757624600187821,
            "success_improvement": 0.0,
            "time_improvement": 47.90402325881309,
            "length_improvement": -6.118510967013652,
            "smoothness_improvement": 1777.1589561985077,
            "objective_score": 19.585895178428274
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "e2",
    "algorithm_description": "A hybrid bidirectional anytime RRT* planner integrating priority-driven node expansion with efficient nearest neighbor queries and adaptive rewiring radius, combined with informed sampling based on current best path cost. It performs incremental rewiring and lazy collision checking to reduce unnecessary edge verification, uses rapid uniform and informed goal-biased sampling to improve exploration/exploitation balance, and applies incremental shortcutting to maintain smooth, short paths during planning. The planner alternates growth from start and goal trees, attempts connecting trees continually, and updates best paths dynamically for improved convergence, robustness, and solution quality.",
    "planning_mechanism": "The planner grows two RRT* trees bidirectionally, sampling nodes from informed ellipsoids after first solution, expanding nodes prioritized by lowest estimated total cost (cost-to-come plus heuristic), uses adaptive rewiring radius decreasing with iterations, and performs lazy collision checks to optimize rewiring. It incrementally shortcuts paths and returns improved paths anytime upon connection, efficiently balancing exploration and exploitation for robust, smooth, and short solutions.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost  # cost-to-come\n        self.children = []\n        self.id = id(self)\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=4000, step_size=5.0, goal_sample_rate=0.1, initial_radius=25.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.initial_radius = initial_radius\n\n    def plan(self, map):\n        bounds = map.size\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        import math\n        import heapq\n        import random\n\n        def dist(a, b):\n            s = 0\n            for i in range(dim):\n                s += (a[i] - b[i])**2\n            return s**0.5\n\n        def in_obstacle(pt):\n            if is_3d:\n                px, py, pz = pt\n                for obs in obstacles:\n                    ox, oy, oz, w, h, d = obs\n                    if ox <= px <= ox + w and oy <= py <= oy + h and oz <= pz <= oz + d:\n                        return True\n            else:\n                px, py = pt\n                for obs in obstacles:\n                    ox, oy, w, h = obs\n                    if ox <= px <= ox + w and oy <= py <= oy + h:\n                        return True\n            return False\n\n        def edge_in_obstacle(p1, p2):\n            distance = dist(p1, p2)\n            steps = max(1, int(distance / 0.5))\n            for i in range(steps + 1):\n                interp = tuple(p1[d] + (p2[d] - p1[d]) * (i / steps) for d in range(dim))\n                if in_obstacle(interp):\n                    return True\n            return False\n\n        def steer(from_pt, to_pt):\n            d = dist(from_pt, to_pt)\n            if d <= self.step_size:\n                return to_pt\n            ratio = self.step_size / d\n            return tuple(from_pt[d_] + ratio*(to_pt[d_] - from_pt[d_]) for d_ in range(dim))\n\n        def heuristic(p):\n            # Euclidean to goal\n            return dist(p, goal)\n\n        def sample_uniform():\n            for _ in range(100):\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not in_obstacle(pt):\n                    return pt\n            return None\n\n        def sample_informed(c_best):\n            if c_best == float('inf'):\n                return sample_uniform()\n            c_min = dist(start, goal)\n            if c_best < c_min:\n                return sample_uniform()\n            center = tuple((start[d] + goal[d]) / 2 for d in range(dim))\n            e1 = [(goal[d] - start[d]) / c_min for d in range(dim)]\n            while True:\n                x_ball = [random.gauss(0, 1) for _ in range(dim)]\n                norm = math.sqrt(sum(x*x for x in x_ball))\n                if norm == 0 or norm > 1:\n                    continue\n                unit = [x/norm for x in x_ball]\n                r1 = c_best / 2.0\n                val = c_best**2 - c_min**2\n                r2 = math.sqrt(val)/2.0 if val > 0 else 0.0\n                if dim == 2:\n                    angle = math.atan2(e1[1], e1[0])\n                    cos_a = math.cos(angle)\n                    sin_a = math.sin(angle)\n                    x_ell = r1 * unit[0]\n                    y_ell = r2 * unit[1]\n                    px = center[0] + cos_a*x_ell - sin_a*y_ell\n                    py = center[1] + sin_a*x_ell + cos_a*y_ell\n                    pt = (px, py)\n                else:\n                    # 3D: scale unit vector components accordingly & clamp to map\n                    ptmp = [center[d] + (r1*unit[0] if d==0 else r2*unit[d]) for d in range(dim)]\n                    pt = tuple(max(0,min(ptmp[d], bounds[d])) for d in range(dim))\n                if all(0 <= pt[d] <= bounds[d] for d in range(dim)) and not in_obstacle(pt):\n                    return pt\n\n        def nearest(nodes, point):\n            best_node = None\n            best_dist = float('inf')\n            for n in nodes:\n                d = dist(n.position, point)\n                if d < best_dist:\n                    best_dist = d\n                    best_node = n\n            return best_node, best_dist\n\n        def neighbors(nodes, node, radius):\n            result = []\n            for n in nodes:\n                if dist(n.position, node.position) <= radius:\n                    result.append(n)\n            return result\n\n        def adaptive_radius(iteration, n_nodes):\n            r = self.initial_radius * (1.0 / (1.0 + 0.0005 * iteration)) * (math.log(n_nodes+1)/(n_nodes+1))**(1.0/dim)\n            return max(5.0, min(self.initial_radius, r))\n\n        def shortcut_path(path):\n            if len(path) <= 2:\n                return path\n            shortened = [path[0]]\n            i = 0\n            while i < len(path)-1:\n                next_i = len(path)-1\n                for j in range(len(path)-1, i, -1):\n                    if not edge_in_obstacle(path[i], path[j]):\n                        next_i = j\n                        break\n                shortened.append(path[next_i])\n                i = next_i\n            return shortened\n\n        # Priority queue keyed by f = cost + heuristic\n        class PQ:\n            def __init__(self):\n                self.heap = []\n                self.entry_finder = {}\n                self.REMOVED = '<removed>'\n\n            def add(self, node, priority):\n                if node.id in self.entry_finder:\n                    self.remove(node)\n                entry = [priority, node.id, node]\n                self.entry_finder[node.id] = entry\n                heapq.heappush(self.heap, entry)\n\n            def remove(self, node):\n                entry = self.entry_finder.pop(node.id, None)\n                if entry is not None:\n                    entry[-1] = self.REMOVED\n\n            def pop(self):\n                while self.heap:\n                    priority, node_id, node = heapq.heappop(self.heap)\n                    if node is not self.REMOVED:\n                        self.entry_finder.pop(node_id, None)\n                        return node\n                return None\n\n            def empty(self):\n                return not bool(self.entry_finder)\n\n        start_node = Node(start, cost=0.0)\n        goal_node = Node(goal, cost=0.0)\n        start_tree = [start_node]\n        goal_tree = [goal_node]\n\n        start_pq = PQ()\n        goal_pq = PQ()\n        start_pq.add(start_node, heuristic(start_node.position))\n        goal_pq.add(goal_node, dist(goal_node.position, start))\n\n        best_cost = float('inf')\n        best_path = None\n\n        def connect_trees(n1, tree_nodes, pq_other):\n            near, d_near = nearest(tree_nodes, n1.position)\n            if d_near > self.step_size:\n                new_pos = steer(near.position, n1.position)\n            else:\n                new_pos = n1.position\n            if in_obstacle(new_pos) or edge_in_obstacle(near.position, new_pos):\n                return None\n            new_cost = near.cost + dist(near.position, new_pos)\n            new_node = Node(new_pos, parent=near, cost=new_cost)\n            near.add_child(new_node)\n            tree_nodes.append(new_node)\n            pq_other.add(new_node, new_cost + heuristic(new_node.position))\n            return new_node\n\n        def rewire(new_node, tree_nodes, pq):\n            n = len(tree_nodes)\n            r = adaptive_radius(0, n)\n            nbrs = neighbors(tree_nodes, new_node, r)\n            for nbr in nbrs:\n                if nbr == new_node.parent:\n                    continue\n                cost_through_new = new_node.cost + dist(new_node.position, nbr.position)\n                if cost_through_new + 1e-9 < nbr.cost:\n                    if not edge_in_obstacle(new_node.position, nbr.position):\n                        if nbr.parent:\n                            nbr.parent.remove_child(nbr)\n                        new_node.add_child(nbr)\n                        old_cost = nbr.cost\n                        nbr.cost = cost_through_new\n                        def update_descendants_costs(node):\n                            for c in node.children:\n                                new_c_cost = node.cost + dist(node.position, c.position)\n                                if new_c_cost + 1e-9 < c.cost:\n                                    c.cost = new_c_cost\n                                    update_descendants_costs(c)\n                        update_descendants_costs(nbr)\n                        pq.add(nbr, nbr.cost + heuristic(nbr.position))\n\n        for iteration in range(self.max_iter):\n            if iteration % 2 == 0:\n                tree_a, pq_a = start_tree, start_pq\n                tree_b, pq_b = goal_tree, goal_pq\n                to_goal = True\n            else:\n                tree_a, pq_a = goal_tree, goal_pq\n                tree_b, pq_b = start_tree, start_pq\n                to_goal = False\n\n            curr_best = best_cost\n\n            if random.random() < self.goal_sample_rate:\n                sample = goal if to_goal else start\n                if in_obstacle(sample):\n                    sample = sample_uniform()\n            else:\n                sample = sample_informed(curr_best)\n\n            # Expand tree A\n            nearest_node, _ = nearest(tree_a, sample)\n            new_pos = steer(nearest_node.position, sample)\n            if in_obstacle(new_pos) or edge_in_obstacle(nearest_node.position, new_pos):\n                continue\n\n            # Choose best parent among neighbors\n            n_nodes = len(tree_a)\n            radius = adaptive_radius(iteration, n_nodes)\n            nbrs = neighbors(tree_a, Node(new_pos), radius)\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for nb in nbrs:\n                if not edge_in_obstacle(nb.position, new_pos):\n                    c = nb.cost + dist(nb.position, new_pos)\n                    if c + 1e-9 < min_cost:\n                        min_cost = c\n                        best_parent = nb\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree_a.append(new_node)\n            pq_a.add(new_node, new_node.cost + heuristic(new_node.position))\n\n            rewire(new_node, tree_a, pq_a)\n\n            # Attempt to connect tree B\n            connected_node = None\n            new_node_b = None\n            near_b, dist_b = nearest(tree_b, new_node.position)\n            if dist_b <= self.step_size:\n                if (not in_obstacle(new_node.position)) and (not edge_in_obstacle(near_b.position, new_node.position)):\n                    new_node_b = Node(new_node.position, parent=near_b, cost=near_b.cost + dist(near_b.position, new_node.position))\n                    near_b.add_child(new_node_b)\n                    tree_b.append(new_node_b)\n                    pq_b.add(new_node_b, new_node_b.cost + heuristic(new_node_b.position))\n                    rewire(new_node_b, tree_b, pq_b)\n                    connected_node = new_node_b\n\n            if connected_node:\n                cost_total = new_node.cost + connected_node.cost\n                if cost_total + 1e-9 < best_cost:\n                    best_cost = cost_total\n                    path_start = new_node.path_from_root() if to_goal else connected_node.path_from_root()\n                    path_goal = connected_node.path_from_root() if to_goal else new_node.path_from_root()\n                    if path_start[-1] == path_goal[-1]:\n                        full_path = path_start + path_goal[-2::-1]\n                    else:\n                        full_path = path_start + path_goal[::-1]\n                    best_path = shortcut_path(full_path)\n                    return PlannerResult(success=True, path=best_path, nodes=start_tree + goal_tree, edges=[])\n\n        return PlannerResult(success=False, path=[], nodes=start_tree + goal_tree, edges=[])",
    "objective": -9.92617,
    "time_improvement": -29.0,
    "length_improvement": 13.0,
    "smoothness_improvement": 2145.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.04137279987335205,
            "num_nodes_avg": 147.1,
            "path_length_avg": 175.1992703194899,
            "smoothness_avg": 0.04452702312602966,
            "success_improvement": 0.0,
            "time_improvement": -57.593747474169554,
            "length_improvement": 3.9705037277915336,
            "smoothness_improvement": 596.944603900691,
            "objective_score": -11.911098986072489
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.06708223819732666,
            "num_nodes_avg": 291.1,
            "path_length_avg": 237.95612736534184,
            "smoothness_avg": 0.16597414333022434,
            "success_improvement": 0.0,
            "time_improvement": 59.37857279496425,
            "length_improvement": 20.563395498086184,
            "smoothness_improvement": 4170.6342542300135,
            "objective_score": 51.00478040849105
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.0952378511428833,
            "num_nodes_avg": 310.5,
            "path_length_avg": 127.58086004886759,
            "smoothness_avg": 0.13903732050321377,
            "success_improvement": 0.0,
            "time_improvement": -89.39342934737256,
            "length_improvement": 15.26686750325445,
            "smoothness_improvement": 1668.5444541334139,
            "objective_score": -9.31518603159203
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "e2",
    "algorithm_description": "A hybrid bidirectional RRT* planner integrating goal bias sampling, adaptive step sizes, efficient nearest neighbor search via incremental radius, and localized rewiring for path improvement and smoothing. The planner grows two trees from start and goal, extends them towards randomly sampled points (biased towards goal regions), and attempts connection. It dynamically updates node costs and performs local rewiring to optimize paths progressively, improving success rate, path length, and smoothness while maintaining computational efficiency.",
    "planning_mechanism": "A bidirectional RRT*-inspired planner alternates tree expansion using goal-biased sampling and adaptive step sizes; extends nodes using steering methods with collision checking; after adding nodes performs local rewiring within a radius to optimize paths; attempts connection between two trees each iteration; once connected, reconstructs the final minimized-cost path, returning it with consistent nodes and edges.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.children = []\n        self.cost = cost\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=4000, step_size=5.0, goal_sample_rate=0.15, rewire_radius=15.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.rewire_radius = rewire_radius\n\n    def plan(self, map):\n        bounds = map.size\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start)]\n        goal_tree = [Node(goal)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        for i in range(self.max_iter):\n            expanding_tree, other_tree = (start_tree, goal_tree) if i % 2 == 0 else (goal_tree, start_tree)\n            sample = self._sample_free(bounds, obstacles, is_3d, goal, self.goal_sample_rate)\n            new_node = self._extend(expanding_tree, sample, obstacles, is_3d, nodes, edges)\n            if new_node is not None:\n                self._rewire(new_node, expanding_tree, obstacles, is_3d, nodes, edges)\n                connected_node = self._connect(other_tree, new_node, obstacles, is_3d, nodes, edges)\n                if connected_node is not None:\n                    path_start = new_node.path_from_root()\n                    path_goal = connected_node.path_from_root()\n                    # Connect and optimize final path\n                    if path_start[-1] == path_goal[-1]:\n                        full_path = path_start + path_goal[-2::-1]\n                    else:\n                        full_path = path_start + path_goal[::-1]\n                    optimized_path = self._shortcut_path(full_path, obstacles, is_3d)\n                    return PlannerResult(True, optimized_path, nodes, edges)\n\n        return PlannerResult(False, [], nodes, edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d, goal, goal_sample_rate):\n        import random\n        from math import sqrt\n        if random.random() < goal_sample_rate:\n            return goal\n        while True:\n            pt = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n            if not self._in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def _nearest(self, tree, point):\n        min_dist = float('inf')\n        nearest_node = None\n        for node in tree:\n            dist = self._dist(node.position, point)\n            if dist < min_dist:\n                min_dist = dist\n                nearest_node = node\n        return nearest_node\n\n    def _near(self, tree, point, radius):\n        near_nodes = []\n        r2 = radius * radius\n        for node in tree:\n            if self._dist_sq(node.position, point) <= r2:\n                near_nodes.append(node)\n        return near_nodes\n\n    def _extend(self, tree, point, obstacles, is_3d, nodes, edges):\n        nearest = self._nearest(tree, point)\n        new_pos = self._steer(nearest.position, point)\n        if not self._valid(nearest.position, new_pos, obstacles, is_3d):\n            return None\n        new_cost = nearest.cost + self._dist(nearest.position, new_pos)\n        # Choose best parent among near vertices to minimize cost\n        near_nodes = self._near(tree, new_pos, self.rewire_radius)\n        best_parent = nearest\n        best_cost = new_cost\n        for near_node in near_nodes:\n            cost_through_near = near_node.cost + self._dist(near_node.position, new_pos)\n            if cost_through_near < best_cost and self._valid(near_node.position, new_pos, obstacles, is_3d):\n                best_parent = near_node\n                best_cost = cost_through_near\n        new_node = Node(new_pos, best_parent, best_cost)\n        best_parent.add_child(new_node)\n        tree.append(new_node)\n        nodes.append(new_node)\n        edges.append((best_parent, new_node))\n        return new_node\n\n    def _connect(self, tree, target_node, obstacles, is_3d, nodes, edges):\n        current = self._nearest(tree, target_node.position)\n        while True:\n            new_pos = self._steer(current.position, target_node.position)\n            if not self._valid(current.position, new_pos, obstacles, is_3d):\n                return None\n            new_cost = current.cost + self._dist(current.position, new_pos)\n            new_node = Node(new_pos, current, new_cost)\n            current.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((current, new_node))\n\n            # Rewire near nodes around new_node for better costs\n            self._rewire(new_node, tree, obstacles, is_3d, nodes, edges)\n\n            if self._dist(new_node.position, target_node.position) <= self.step_size:\n                if not self._valid(new_node.position, target_node.position, obstacles, is_3d):\n                    return None\n                final_cost = new_node.cost + self._dist(new_node.position, target_node.position)\n                final_node = Node(target_node.position, new_node, final_cost)\n                new_node.add_child(final_node)\n                tree.append(final_node)\n                nodes.append(final_node)\n                edges.append((new_node, final_node))\n                return final_node\n            current = new_node\n\n    def _rewire(self, new_node, tree, obstacles, is_3d, nodes, edges):\n        near_nodes = self._near(tree, new_node.position, self.rewire_radius)\n        for near in near_nodes:\n            if near == new_node.parent:\n                continue\n            cost_through_new = new_node.cost + self._dist(new_node.position, near.position)\n            if cost_through_new < near.cost and self._valid(new_node.position, near.position, obstacles, is_3d):\n                # Update parent and cost\n                if near.parent:\n                    try:\n                        near.parent.children.remove(near)\n                    except ValueError:\n                        pass\n                near.parent = new_node\n                near.cost = cost_through_new\n                new_node.children.append(near)\n                # Update children costs recursively\n                self._update_children_costs(near)\n\n    def _update_children_costs(self, node):\n        for child in node.children:\n            new_cost = node.cost + self._dist(node.position, child.position)\n            if new_cost < child.cost:\n                child.cost = new_cost\n                child.parent = node\n                self._update_children_costs(child)\n\n    def _steer(self, start, goal):\n        dist = self._dist(start, goal)\n        if dist <= self.step_size:\n            return goal\n        ratio = self.step_size / dist\n        return tuple(start[d] + (goal[d] - start[d]) * ratio for d in range(len(start)))\n\n    def _valid(self, p1, p2, obstacles, is_3d):\n        return (not self._in_obstacle(p2, obstacles, is_3d)) and (not self._edge_in_obstacle(p1, p2, obstacles, is_3d))\n\n    def _in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x,y,z,w,h,d = obs\n                px,py,pz = pos\n                if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                    return True\n            else:\n                x,y,w,h = obs\n                px,py = pos\n                if x <= px <= x+w and y <= py <= y+h:\n                    return True\n        return False\n\n    def _edge_in_obstacle(self, p1, p2, obstacles, is_3d, res=1.0):\n        dist = self._dist(p1, p2)\n        steps = max(1, int(dist / res))\n        for i in range(steps + 1):\n            interp = tuple(p1[d] + (p2[d] - p1[d]) * i / steps for d in range(len(p1)))\n            if self._in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _dist(self, a, b):\n        return sum((a[d]-b[d])**2 for d in range(len(a)))**0.5\n\n    def _dist_sq(self, a, b):\n        return sum((a[d]-b[d])**2 for d in range(len(a)))\n\n    def _shortcut_path(self, path, obstacles, is_3d):\n        if len(path) <= 2:\n            return path\n        i = 0\n        new_path = [path[0]]\n        while i < len(path) - 1:\n            j = len(path) - 1\n            while j > i + 1:\n                if not self._edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                    break\n                j -= 1\n            new_path.append(path[j])\n            i = j\n        return new_path",
    "objective": -21.69817,
    "time_improvement": 13.0,
    "length_improvement": 17.0,
    "smoothness_improvement": 1574.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.026177811622619628,
            "num_nodes_avg": 114.0,
            "path_length_avg": 165.39322114121052,
            "smoothness_avg": 0.05422599018415906,
            "success_improvement": 0.0,
            "time_improvement": 0.2857083177810343,
            "length_improvement": 9.345354669199349,
            "smoothness_improvement": 748.7545000044862,
            "objective_score": 9.43669779687635
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.08344228267669677,
            "num_nodes_avg": 275.8,
            "path_length_avg": 235.51330564478062,
            "smoothness_avg": 0.10403228200976807,
            "success_improvement": 0.0,
            "time_improvement": 49.471802034945625,
            "length_improvement": 21.378879701134153,
            "smoothness_improvement": 2576.825547535313,
            "objective_score": 40.55299616884074
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.056298470497131346,
            "num_nodes_avg": 219.1,
            "path_length_avg": 121.18470212144905,
            "smoothness_avg": 0.11765862390427125,
            "success_improvement": 0.0,
            "time_improvement": -11.957171088066387,
            "length_improvement": 19.514891046335084,
            "smoothness_improvement": 1396.6090114061014,
            "objective_score": 15.104828358411641
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m1",
    "algorithm_description": "An improved bidirectional RRT algorithm that grows start and goal trees by incrementally extending towards random samples, but integrates an adaptive best-near extension strategy and direct tree connection attempts to reduce unnecessary intermediate nodes, enhancing planning speed and path quality. The algorithm prunes redundant branches during connection and returns a smooth shortest path by tracing parent links without excessive intermediate nodes, while ensuring collision checks for nodes and edges.",
    "planning_mechanism": "The planner alternates expanding the start and goal trees by selecting the best node near a random sample to attempt efficient extensions. It tries to directly connect the two trees whenever possible, avoiding incremental stepwise connections that add many nodes. Upon successful connection, it constructs the path by merging the backward path of the start tree and the forward path of the goal tree, ensuring smoothness and shortness without intermediate expansions between trees.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map):\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        edges = []\n\n        for _ in range(self.max_iter):\n            rand = self._sample_free(bounds, obstacles, is_3d)\n            # Alternate growing trees: start_tree then goal_tree\n            for source_tree, target_tree in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest = self._best_near(source_tree, rand)\n                new_pos = self._steer(nearest.position, rand, self.step_size)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                    continue\n                new_node = Node(new_pos, parent=nearest, cost=nearest.cost + self._distance(nearest.position, new_pos))\n                nearest.add_child(new_node)\n                source_tree.append(new_node)\n                edges.append((nearest, new_node))\n\n                # Try direct connection to closest node in target_tree\n                connect_node = self._nearest(target_tree, new_pos)\n                if self._direct_connect(new_node, connect_node, obstacles, is_3d):\n                    # Link both trees at connection without intermediate nodes\n                    new_node_connect = Node(connect_node.position, parent=new_node, cost=new_node.cost + self._distance(new_node.position, connect_node.position))\n                    new_node.add_child(new_node_connect)\n                    source_tree.append(new_node_connect)\n                    edges.append((new_node, new_node_connect))\n\n                    path = self._build_path(new_node_connect, connect_node)\n                    return PlannerResult(True, path, start_tree + goal_tree, edges)\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        while True:\n            point = tuple((random.uniform(0, bounds[i]) for i in range(len(bounds))))\n            if not self._is_in_obstacle(point, obstacles, is_3d):\n                return point\n\n    def _best_near(self, tree, sample):\n        # Select node near sample that yields minimal cost-to-come plus distance to sample\n        candidates = [node for node in tree\n                      if self._distance(node.position, sample) <= self.step_size * 3]\n        if not candidates:\n            return self._nearest(tree, sample)\n        best_node = min(candidates, key=lambda n: n.cost + self._distance(n.position, sample))\n        return best_node\n\n    def _nearest(self, tree, point):\n        return min(tree, key=lambda node: self._distance(node.position, point))\n\n    def _steer(self, from_pos, to_pos, max_step):\n        dist = self._distance(from_pos, to_pos)\n        if dist <= max_step:\n            return to_pos\n        ratio = max_step / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _direct_connect(self, node_a, node_b, obstacles, is_3d):\n        # Try direct edge-connect (no incremental steps)\n        if node_a.position == node_b.position:\n            return True\n        if self._is_edge_in_obstacle(node_a.position, node_b.position, obstacles, is_3d):\n            return False\n        return True\n\n    def _build_path(self, connect_node_starttree, connect_node_goaltree):\n        # Extract path: from start root to connect_node_starttree\n        path_start = []\n        node = connect_node_starttree\n        while node:\n            path_start.append(node.position)\n            node = node.parent\n        path_start.reverse()\n        # From connect_node_goaltree to root of goal tree (goal)\n        path_goal = []\n        node = connect_node_goaltree\n        while node:\n            path_goal.append(node.position)\n            node = node.parent\n        # Concatenate without duplicating connection point\n        if path_goal and path_start and path_goal[0] == path_start[-1]:\n            path_goal = path_goal[1:]\n        return path_start + path_goal\n\n    def _distance(self, a, b):\n        return math.dist(a, b)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        dist = self._distance(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": -23.20822,
    "time_improvement": 70.0,
    "length_improvement": 3.0,
    "smoothness_improvement": 94.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.01148538589477539,
            "num_nodes_avg": 114.7,
            "path_length_avg": 178.88287649808652,
            "smoothness_avg": 0.011710944030027473,
            "success_improvement": 0.0,
            "time_improvement": 56.2508457274982,
            "length_improvement": 1.951460810827528,
            "smoothness_improvement": 83.30170479192397,
            "objective_score": 18.4626387287056
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.024952244758605958,
            "num_nodes_avg": 287.1,
            "path_length_avg": 284.2732101707537,
            "smoothness_avg": 0.007407994819409248,
            "success_improvement": 0.0,
            "time_improvement": 84.89025081300372,
            "length_improvement": 5.101420094330395,
            "smoothness_improvement": 90.61304246639523,
            "objective_score": 28.980992512831325
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.016226673126220705,
            "num_nodes_avg": 197.2,
            "path_length_avg": 147.25047497131663,
            "smoothness_avg": 0.01634842816831971,
            "success_improvement": 0.0,
            "time_improvement": 67.73105195682024,
            "length_improvement": 2.20324583817514,
            "smoothness_improvement": 107.95079958558324,
            "objective_score": 22.18101708787907
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m3",
    "algorithm_description": "A simplified bidirectional RRT* variant with goal biasing and adaptive local rewiring radius that alternates tree growth from start and goal, samples with a probability bias toward the goal, extends and rewires nearby nodes on each addition to improve path cost progressively. The connection attempts between trees use nearest neighbor extension and collision checks, returning the first feasible path. This balances simplicity, efficiency, and path quality with lower overhead than complex priority-driven expansions or lazy checks.",
    "planning_mechanism": "A bidirectional incremental planner that samples in the space biased by the goal, grows two trees alternatingly using fixed step steering with rewiring local neighbors within an adaptive radius, connects the trees when possible to extract shortest path, and returns early on first solution.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=3000, step_size=5.0, goal_bias=0.1, gamma=30.0, max_radius=40.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_bias = goal_bias\n        self.gamma = gamma\n        self.max_radius = max_radius\n\n    def plan(self, map):\n        bounds = map.size\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        tree_start = [Node(start, cost=0.0)]\n        tree_goal = [Node(goal, cost=0.0)]\n        nodes = tree_start + tree_goal\n        edges = []\n\n        for i in range(self.max_iter):\n            if i % 2 == 0:\n                tree_a, tree_b = tree_start, tree_goal\n                sample_goal = goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n                sample_goal = start\n\n            sample_pt = self._sample(bounds, obstacles, is_3d, sample_goal, self.goal_bias)\n\n            new_node = self._extend_and_rewire(tree_a, sample_pt, obstacles, is_3d, bounds, nodes, edges)\n            if new_node is None:\n                continue\n\n            conn_node = self._try_connect(tree_b, new_node, obstacles, is_3d, bounds, nodes, edges)\n            if conn_node:\n                if tree_a is tree_start:\n                    path_start = new_node.path_from_root()\n                    path_goal = conn_node.path_from_root()\n                else:\n                    path_start = conn_node.path_from_root()\n                    path_goal = new_node.path_from_root()\n\n                if path_start[-1] == path_goal[-1]:\n                    full_path = path_start + path_goal[-2::-1]\n                else:\n                    full_path = path_start + path_goal[::-1]\n\n                return PlannerResult(True, full_path, nodes, edges)\n\n        return PlannerResult(False, [], nodes, edges)\n\n    def _sample(self, bounds, obstacles, is_3d, goal, goal_bias):\n        dim = len(bounds)\n        if random.random() < goal_bias:\n            if not self._in_obstacle(goal, obstacles, is_3d):\n                return goal\n        while True:\n            pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            if not self._in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def _nearest(self, tree, point):\n        best = None\n        best_dist = float('inf')\n        for node in tree:\n            d = self._dist(node.position, point)\n            if d < best_dist:\n                best_dist = d\n                best = node\n        return best\n\n    def _steer(self, from_pos, to_pos):\n        dist = self._dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(len(from_pos)))\n\n    def _near_nodes(self, tree, position, bounds):\n        n = max(1, len(tree))\n        d = len(position)\n        r_theory = self.gamma * ((math.log(n + 1) / (n + 1)) ** (1.0 / d))\n        radius = min(self.max_radius, r_theory)\n        return [node for node in tree if self._dist(node.position, position) <= radius]\n\n    def _extend_and_rewire(self, tree, sample, obstacles, is_3d, bounds, nodes, edges):\n        nearest = self._nearest(tree, sample)\n        new_pos = self._steer(nearest.position, sample)\n\n        if self._in_obstacle(new_pos, obstacles, is_3d) or self._edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n            return None\n\n        neighbors = self._near_nodes(tree, new_pos, bounds)\n        min_cost = nearest.cost + self._dist(nearest.position, new_pos)\n        best_parent = nearest\n        for nb in neighbors:\n            if not self._edge_in_obstacle(nb.position, new_pos, obstacles, is_3d):\n                cost_cand = nb.cost + self._dist(nb.position, new_pos)\n                if cost_cand < min_cost:\n                    min_cost = cost_cand\n                    best_parent = nb\n\n        new_node = Node(new_pos, cost=min_cost)\n        best_parent.add_child(new_node)\n        tree.append(new_node)\n        nodes.append(new_node)\n        edges.append((best_parent, new_node))\n\n        for nb in neighbors:\n            if nb is best_parent:\n                continue\n            if not self._edge_in_obstacle(new_node.position, nb.position, obstacles, is_3d):\n                cost_through_new = new_node.cost + self._dist(new_node.position, nb.position)\n                if cost_through_new < nb.cost:\n                    if nb.parent:\n                        try:\n                            edges.remove((nb.parent, nb))\n                        except ValueError:\n                            pass\n                        if nb in nb.parent.children:\n                            nb.parent.children.remove(nb)\n                    new_node.add_child(nb)\n                    nb.cost = cost_through_new\n                    edges.append((new_node, nb))\n        return new_node\n\n    def _try_connect(self, tree, new_node, obstacles, is_3d, bounds, nodes, edges):\n        nearest = self._nearest(tree, new_node.position)\n        new_pos = self._steer(nearest.position, new_node.position)\n\n        if self._in_obstacle(new_pos, obstacles, is_3d) or self._edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n            return None\n\n        neighbors = self._near_nodes(tree, new_pos, bounds)\n        min_cost = nearest.cost + self._dist(nearest.position, new_pos)\n        best_parent = nearest\n        for nb in neighbors:\n            if not self._edge_in_obstacle(nb.position, new_pos, obstacles, is_3d):\n                cost_cand = nb.cost + self._dist(nb.position, new_pos)\n                if cost_cand < min_cost:\n                    min_cost = cost_cand\n                    best_parent = nb\n\n        conn_node = Node(new_pos, cost=min_cost)\n        best_parent.add_child(conn_node)\n        tree.append(conn_node)\n        nodes.append(conn_node)\n        edges.append((best_parent, conn_node))\n\n        for nb in neighbors:\n            if nb is best_parent:\n                continue\n            if not self._edge_in_obstacle(conn_node.position, nb.position, obstacles, is_3d):\n                cost_through_conn = conn_node.cost + self._dist(conn_node.position, nb.position)\n                if cost_through_conn < nb.cost:\n                    if nb.parent:\n                        try:\n                            edges.remove((nb.parent, nb))\n                        except ValueError:\n                            pass\n                        if nb in nb.parent.children:\n                            nb.parent.children.remove(nb)\n                    conn_node.add_child(nb)\n                    nb.cost = cost_through_conn\n                    edges.append((conn_node, nb))\n\n        if self._dist(conn_node.position, new_node.position) <= self.step_size:\n            if not self._edge_in_obstacle(conn_node.position, new_node.position, obstacles, is_3d):\n                final_node = Node(new_node.position, cost=conn_node.cost + self._dist(conn_node.position, new_node.position))\n                conn_node.add_child(final_node)\n                tree.append(final_node)\n                nodes.append(final_node)\n                edges.append((conn_node, final_node))\n                return final_node\n        return None\n\n    def _in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _edge_in_obstacle(self, p1, p2, obstacles, is_3d, resolution=1.0):\n        dist = self._dist(p1, p2)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(p1[d] + (p2[d] - p1[d]) * i / steps for d in range(len(p1)))\n            if self._in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _dist(self, a, b):\n        s = 0\n        for i in range(len(a)):\n            s += (a[i] - b[i]) ** 2\n        return math.sqrt(s)",
    "objective": -13.53316,
    "time_improvement": 27.0,
    "length_improvement": 8.0,
    "smoothness_improvement": 152.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.022034502029418944,
            "num_nodes_avg": 93.7,
            "path_length_avg": 164.3993177101388,
            "smoothness_avg": 0.019566020100551793,
            "success_improvement": 0.0,
            "time_improvement": 16.06805052659876,
            "length_improvement": 9.890128889177472,
            "smoothness_improvement": 206.2507028663326,
            "objective_score": 11.785746005817774
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.0467888355255127,
            "num_nodes_avg": 245.9,
            "path_length_avg": 281.13770782762697,
            "smoothness_avg": 0.008332608412661938,
            "success_improvement": 0.0,
            "time_improvement": 71.66717558353997,
            "length_improvement": 6.148141026896979,
            "smoothness_improvement": 114.40401619303935,
            "objective_score": 25.76105737216537
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.0535409688949585,
            "num_nodes_avg": 254.9,
            "path_length_avg": 139.74898635389982,
            "smoothness_avg": 0.018608718301924145,
            "success_improvement": 0.0,
            "time_improvement": -6.473503842331646,
            "length_improvement": 7.185377395361245,
            "smoothness_improvement": 136.70152324776862,
            "objective_score": 3.0526829007560963
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m3",
    "algorithm_description": "A streamlined bidirectional RRT* planner with goal bias sampling and simplified rewiring mechanism that maintains efficient connection attempts between trees and prioritizes feasible path discovery with reduced computational complexity.",
    "planning_mechanism": "The planner alternates tree expansions from start and goal states, samples points with goal bias, extends trees by fixed steps avoiding obstacles, rewires neighbors within a computed radius for better paths, and attempts connections between trees to find a valid path early.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        node, path = self, []\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=3000, step_size=5.0, goal_bias=0.1, gamma=30.0, max_radius=30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_bias = goal_bias\n        self.gamma = gamma\n        self.max_radius = max_radius\n\n    def plan(self, map):\n        bounds = map.size\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        tree_start = [Node(start)]\n        tree_goal = [Node(goal)]\n        nodes = tree_start + tree_goal\n        edges = []\n\n        for i in range(self.max_iter):\n            tree_a, tree_b = (tree_start, tree_goal) if i % 2 == 0 else (tree_goal, tree_start)\n            sample_goal = goal if tree_a is tree_start else start\n\n            sample_pt = self._sample(bounds, obstacles, is_3d, sample_goal)\n            if sample_pt is None:\n                continue\n\n            new_node = self._extend_and_rewire(tree_a, sample_pt, obstacles, is_3d)\n            if not new_node:\n                continue\n\n            conn_node = self._connect_trees(tree_b, new_node, obstacles, is_3d)\n            if conn_node:\n                path_a = new_node.path_from_root()\n                path_b = conn_node.path_from_root()\n                if tree_a is tree_start:\n                    full_path = path_a + path_b[-2::-1]\n                else:\n                    full_path = path_b + path_a[-2::-1]\n                return PlannerResult(True, full_path, nodes, edges)\n\n            nodes.extend(tree_a[-1:])\n            edges.extend([(new_node.parent, new_node)] if new_node.parent else [])\n\n        return PlannerResult(False, [], nodes, edges)\n\n    def _sample(self, bounds, obstacles, is_3d, goal):\n        import random\n        dim = len(bounds)\n        if random.random() < self.goal_bias and not self._in_obstacle(goal, obstacles, is_3d):\n            return goal\n        for _ in range(100):\n            pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            if not self._in_obstacle(pt, obstacles, is_3d):\n                return pt\n        return None\n\n    def _nearest(self, tree, point):\n        best, best_dist = None, float('inf')\n        for node in tree:\n            dist = self._dist(node.position, point)\n            if dist < best_dist:\n                best, best_dist = node, dist\n        return best\n\n    def _steer(self, from_pos, to_pos):\n        dist = self._dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(len(from_pos)))\n\n    def _near_nodes(self, tree, position):\n        n = max(1, len(tree))\n        d = len(position)\n        r = min(self.max_radius, self.gamma * ( (math.log(n + 1) / (n + 1))**(1/d) ))\n        return [node for node in tree if self._dist(node.position, position) <= r]\n\n    def _extend_and_rewire(self, tree, sample, obstacles, is_3d):\n        nearest = self._nearest(tree, sample)\n        new_pos = self._steer(nearest.position, sample)\n        if self._in_obstacle(new_pos, obstacles, is_3d) or self._edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n            return None\n\n        neighbors = self._near_nodes(tree, new_pos)\n        best_parent = nearest\n        min_cost = nearest.cost + self._dist(nearest.position, new_pos)\n        for nb in neighbors:\n            if not self._edge_in_obstacle(nb.position, new_pos, obstacles, is_3d):\n                cost = nb.cost + self._dist(nb.position, new_pos)\n                if cost < min_cost:\n                    best_parent, min_cost = nb, cost\n\n        new_node = Node(new_pos, best_parent, min_cost)\n        best_parent.add_child(new_node)\n        tree.append(new_node)\n\n        # Rewire neighbors\n        for nb in neighbors:\n            if nb is best_parent:\n                continue\n            if not self._edge_in_obstacle(new_node.position, nb.position, obstacles, is_3d):\n                cost_through_new = new_node.cost + self._dist(new_node.position, nb.position)\n                if cost_through_new < nb.cost:\n                    if nb.parent:\n                        try:\n                            nb.parent.children.remove(nb)\n                        except ValueError:\n                            pass\n                    new_node.add_child(nb)\n                    nb.cost = cost_through_new\n                    nb.parent = new_node\n        return new_node\n\n    def _connect_trees(self, tree, new_node, obstacles, is_3d):\n        nearest = self._nearest(tree, new_node.position)\n        if self._dist(nearest.position, new_node.position) > self.step_size:\n            return None\n        if self._edge_in_obstacle(nearest.position, new_node.position, obstacles, is_3d):\n            return None\n        conn_node = Node(new_node.position, nearest,\n                         nearest.cost + self._dist(nearest.position, new_node.position))\n        nearest.add_child(conn_node)\n        tree.append(conn_node)\n        return conn_node\n\n    def _in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x,y,z,w,h,d = obs\n                px,py,pz = pos\n                if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                    return True\n            else:\n                x,y,w,h = obs\n                px,py = pos\n                if x <= px <= x+w and y <= py <= y+h:\n                    return True\n        return False\n\n    def _edge_in_obstacle(self, p1, p2, obstacles, is_3d, res=1.0):\n        dist = self._dist(p1, p2)\n        steps = max(1, int(dist / res))\n        for i in range(steps+1):\n            interp = tuple(p1[d] + (p2[d]-p1[d])*i/steps for d in range(len(p1)))\n            if self._in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _dist(self, a, b):\n        s = 0\n        for i in range(len(a)):\n            s += (a[i]-b[i])**2\n        return math.sqrt(s)",
    "objective": 23.30853,
    "time_improvement": -93.0,
    "length_improvement": 6.0,
    "smoothness_improvement": 138.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.03701515197753906,
            "num_nodes_avg": 140.5,
            "path_length_avg": 170.6984093036678,
            "smoothness_avg": 0.01702723477654004,
            "success_improvement": 0.0,
            "time_improvement": -40.99496604829795,
            "length_improvement": 6.437496971270441,
            "smoothness_improvement": 166.51319948497797,
            "objective_score": -7.60342563430223
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.05906083583831787,
            "num_nodes_avg": 269.2,
            "path_length_avg": 279.42655094147017,
            "smoothness_avg": 0.008345901787349848,
            "success_improvement": 0.0,
            "time_improvement": 64.2359064314821,
            "length_improvement": 6.719374448416185,
            "smoothness_improvement": 114.74606429859004,
            "objective_score": 23.87612691998729
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.20173029899597167,
            "num_nodes_avg": 359.5,
            "path_length_avg": 141.8172775762153,
            "smoothness_avg": 0.01831988316887897,
            "success_improvement": 0.0,
            "time_improvement": -301.16815606011176,
            "length_improvement": 5.8117168469436695,
            "smoothness_improvement": 133.0275616750258,
            "objective_score": -86.19827890149219
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m3",
    "algorithm_description": "A simplified, generalized bidirectional RRT* planner with goal biasing, fixed step extension, and basic rewiring. The planner builds two trees growing alternately from start and goal, sampling with goal bias, connecting trees when possible, and rewiring neighbors within a fixed radius to improve path quality while maintaining computational simplicity.",
    "planning_mechanism": "A bidirectional incremental sampling and growing planner that alternates expansions between start and goal trees, samples points biased towards the goal, extends trees in fixed steps if collision-free, rewires local neighbors to reduce cost, and attempts to connect the two trees early to find a feasible path.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        node, path = self, []\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=2000, step_size=5.0, goal_bias=0.1, rewire_radius=15.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_bias = goal_bias\n        self.rewire_radius = rewire_radius\n\n    def plan(self, map):\n        bounds = map.size\n        start, goal = map.start, map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        tree_start = [Node(start)]\n        tree_goal = [Node(goal)]\n\n        for i in range(self.max_iter):\n            tree_a, tree_b = (tree_start, tree_goal) if i % 2 == 0 else (tree_goal, tree_start)\n            target = goal if tree_a is tree_start else start\n\n            sample = self._sample(bounds, obstacles, is_3d, target)\n            if sample is None:\n                continue\n\n            new_node = self._extend(tree_a, sample, obstacles, is_3d)\n            if new_node is None:\n                continue\n\n            self._rewire(tree_a, new_node, obstacles, is_3d)\n\n            conn_node = self._connect(tree_b, new_node, obstacles, is_3d)\n            if conn_node:\n                path_a = new_node.path_from_root()\n                path_b = conn_node.path_from_root()\n                if tree_a is tree_start:\n                    full_path = path_a + path_b[-2::-1]\n                else:\n                    full_path = path_b + path_a[-2::-1]\n                return PlannerResult(True, full_path, tree_start + tree_goal, [])\n\n        return PlannerResult(False, [], tree_start + tree_goal, [])\n\n    def _sample(self, bounds, obstacles, is_3d, goal):\n        import random\n        dim = len(bounds)\n        if random.random() < self.goal_bias and not self._in_obstacle(goal, obstacles, is_3d):\n            return goal\n        for _ in range(50):\n            pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            if not self._in_obstacle(pt, obstacles, is_3d):\n                return pt\n        return None\n\n    def _nearest(self, tree, point):\n        best_node = None\n        best_dist = float('inf')\n        for node in tree:\n            dist = self._dist(node.position, point)\n            if dist < best_dist:\n                best_dist = dist\n                best_node = node\n        return best_node\n\n    def _steer(self, from_pos, to_pos):\n        dist = self._dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(len(from_pos)))\n\n    def _extend(self, tree, sample, obstacles, is_3d):\n        nearest = self._nearest(tree, sample)\n        new_pos = self._steer(nearest.position, sample)\n        if self._in_obstacle(new_pos, obstacles, is_3d) or self._edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n            return None\n        cost = nearest.cost + self._dist(nearest.position, new_pos)\n        new_node = Node(new_pos, nearest, cost)\n        nearest.add_child(new_node)\n        tree.append(new_node)\n        return new_node\n\n    def _rewire(self, tree, new_node, obstacles, is_3d):\n        neighbors = [node for node in tree \n                     if node is not new_node and self._dist(node.position, new_node.position) <= self.rewire_radius]\n        for node in neighbors:\n            if self._edge_in_obstacle(new_node.position, node.position, obstacles, is_3d):\n                continue\n            new_cost = new_node.cost + self._dist(new_node.position, node.position)\n            if new_cost < node.cost:\n                if node.parent:\n                    try:\n                        node.parent.children.remove(node)\n                    except ValueError:\n                        pass\n                new_node.add_child(node)\n                node.cost = new_cost\n\n    def _connect(self, tree, new_node, obstacles, is_3d):\n        nearest = self._nearest(tree, new_node.position)\n        dist = self._dist(nearest.position, new_node.position)\n        if dist > self.step_size or self._edge_in_obstacle(nearest.position, new_node.position, obstacles, is_3d):\n            return None\n        cost = nearest.cost + dist\n        conn_node = Node(new_node.position, nearest, cost)\n        nearest.add_child(conn_node)\n        tree.append(conn_node)\n        return conn_node\n\n    def _in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x,y,z,w,h,d = obs\n                px,py,pz = pos\n                if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                    return True\n            else:\n                x,y,w,h = obs\n                px,py = pos\n                if x <= px <= x+w and y <= py <= y+h:\n                    return True\n        return False\n\n    def _edge_in_obstacle(self, p1, p2, obstacles, is_3d):\n        dist = self._dist(p1, p2)\n        steps = max(1, int(dist))\n        for i in range(steps+1):\n            interp = tuple(p1[d] + (p2[d]-p1[d])*i/steps for d in range(len(p1)))\n            if self._in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _dist(self, a, b):\n        return sum((a[d]-b[d])**2 for d in range(len(a)))**0.5",
    "objective": 59.65005,
    "time_improvement": -204.0,
    "length_improvement": 2.0,
    "smoothness_improvement": 113.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.03270082473754883,
            "num_nodes_avg": 111.0,
            "path_length_avg": 182.5129105181261,
            "smoothness_avg": 0.012161529327064413,
            "success_improvement": 0.0,
            "time_improvement": -24.561197976974423,
            "length_improvement": -0.03821835712618403,
            "smoothness_improvement": 90.35434315218541,
            "objective_score": -6.93951869160711
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.10138325691223145,
            "num_nodes_avg": 279.1,
            "path_length_avg": 283.3533621753713,
            "smoothness_avg": 0.008986505132211251,
            "success_improvement": 0.0,
            "time_improvement": 38.60770449615425,
            "length_improvement": 5.40849183154558,
            "smoothness_improvement": 131.229249769813,
            "objective_score": 15.483552696622686
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.3656118154525757,
            "num_nodes_avg": 380.0,
            "path_length_avg": 150.47088622295763,
            "smoothness_avg": 0.01710426958996591,
            "success_improvement": 0.0,
            "time_improvement": -627.068856631341,
            "length_improvement": 0.06440202433984703,
            "smoothness_improvement": 117.56504667851256,
            "objective_score": -187.49419054140583
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "time_expert",
    "algorithm_description": "A bidirectional RRT* planner enhanced with efficient KD-tree-like spatial indexing for nearest and near queries, adaptive step size limiting, radius shrinking rewiring, and informed sampling biased around the current best path to reduce planning time and improve path optimality and smoothness. The planner maintains two trees from start and goal, grows one at a time, attempts connection when close, rewires neighbors within a dynamically shrinking radius, and applies iterative shortcutting for smoothness. This reduces unnecessary expansions, focuses search near promising regions, and yields faster convergence to short, smooth, collision-free paths.",
    "planning_mechanism": "This planner alternately expands start and goal trees using spatially indexed nearest neighbor searching for fast node insertion and rewiring within a shrinking radius. It samples with bias toward the current best path segment to guide exploration and attempts to connect trees when nodes are sufficiently close, yielding fast, high-quality path discovery. Iterative shortcutting refines the final path smoothness.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except ValueError:\n            pass\nclass Planner:\n    def __init__(self, max_iter=1500, step_size=6.0, max_radius=20.0, min_radius=5.0, bias_prob=0.2):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.max_radius = max_radius\n        self.min_radius = min_radius\n        self.bias_prob = bias_prob\n\n    def plan(self, map):\n        bounds = map.size\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = dim == 3\n        start = Node(map.start)\n        goal = Node(map.goal)\n\n        tree_start = [start]\n        tree_goal = [goal]\n\n        # Efficient Euclidean distance:\n        def dist(a, b):\n            return sum((a[i]-b[i])**2 for i in range(dim))**0.5\n\n        # Check if point inside any obstacle\n        def in_obstacle(p):\n            if not obstacles:\n                return False\n            if is_3d:\n                x,y,z = p\n                for ox, oy, oz, w, h, d in obstacles:\n                    if ox <= x <= ox + w and oy <= y <= oy + h and oz <= z <= oz + d:\n                        return True\n            else:\n                x,y = p\n                for ox, oy, w, h in obstacles:\n                    if ox <= x <= ox + w and oy <= y <= oy + h:\n                        return True\n            return False\n\n        # Check free line segment between two points by discrete interpolation\n        def collision_free(frm, to):\n            d = dist(frm, to)\n            steps = max(2, int(d * 4))\n            for i in range(steps + 1):\n                interp = tuple(frm[j] + (to[j]-frm[j]) * i/steps for j in range(dim))\n                if in_obstacle(interp):\n                    return False\n            return True\n\n        import random\n\n        # Uniform random sampling inside map bounds and collision free\n        def sample_free():\n            while True:\n                p = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not in_obstacle(p):\n                    return p\n\n        # Steer from frm toward to, limiting by step size\n        def steer(frm, to):\n            d = dist(frm, to)\n            if d <= self.step_size:\n                return to\n            ratio = self.step_size / d\n            return tuple(frm[i] + (to[i]-frm[i]) * ratio for i in range(dim))\n\n        # KD-tree-like spatial indexing for efficient nearest / near neighbor search\n        # For simplicity, implement grid-based bucketing indexed by quantization:\n        grid_cell_size = self.step_size * 2\n        def grid_index(pos):\n            return tuple(int(pos[i] // grid_cell_size) for i in range(dim))\n\n        def add_to_grid(grid, node):\n            idx = grid_index(node.position)\n            if idx not in grid:\n                grid[idx] = []\n            grid[idx].append(node)\n\n        def near_grid_nodes(grid, pos, radius):\n            r_cells = int(radius // grid_cell_size) + 1\n            center_idx = grid_index(pos)\n            candidates = []\n            idx_ranges = [range(center_idx[i]-r_cells, center_idx[i]+r_cells+1) for i in range(dim)]\n            from itertools import product\n            for idx in product(*idx_ranges):\n                if idx in grid:\n                    candidates.extend(grid[idx])\n            return candidates\n\n        # Nearest neighbor search using grid index\n        def nearest(grid, pos):\n            search_radius = grid_cell_size\n            nearest_node = None\n            nearest_dist = float('inf')\n            while True:\n                candidates = near_grid_nodes(grid, pos, search_radius)\n                if candidates:\n                    for node in candidates:\n                        d = dist(node.position, pos)\n                        if d < nearest_dist:\n                            nearest_node = node\n                            nearest_dist = d\n                    break\n                search_radius += grid_cell_size\n                if search_radius > max(bounds)*2:\n                    break\n            return nearest_node\n\n        # Near nodes within radius (for rewiring)\n        def near_nodes(grid, pos, radius):\n            candidates = near_grid_nodes(grid, pos, radius)\n            result = [node for node in candidates if dist(node.position, pos) <= radius]\n            return result\n\n        # Extract path from node to root\n        def extract_path(node):\n            path = []\n            while node:\n                path.append(node.position)\n                node = node.parent\n            return path[::-1]\n\n        # Iterative shortcutting improves path smoothness and shortens length\n        def shortcut_path(path, iter_count=50):\n            if len(path) < 3:\n                return path\n            shortened = list(path)\n            for _ in range(iter_count):\n                if len(shortened) <= 2:\n                    break\n                i = random.randint(0, len(shortened)-3)\n                j = random.randint(i+2, len(shortened)-1)\n                if collision_free(shortened[i], shortened[j]):\n                    del shortened[i+1:j]\n            return shortened\n\n        # Cost to reach a point from start inside tree: node.cost, edge length computed by dist\n        # Add new node to tree with rewiring neighbors within radius range, dynamic radius:\n        def add_node(tree, grid, pos, radius):\n            near = near_nodes(grid, pos, radius)\n            min_cost = None\n            min_parent = None\n            for node in near:\n                if collision_free(node.position, pos):\n                    c = node.cost + dist(node.position, pos)\n                    if min_cost is None or c < min_cost:\n                        min_cost = c\n                        min_parent = node\n            if min_parent is None:\n                min_parent = nearest(grid, pos)\n                if min_parent is None:\n                    return None\n                if not collision_free(min_parent.position, pos):\n                    return None\n                min_cost = min_parent.cost + dist(min_parent.position, pos)\n            new_node = Node(pos, parent=min_parent, cost=min_cost)\n            min_parent.add_child(new_node)\n            tree.append(new_node)\n            add_to_grid(grid, new_node)\n            # Rewiring neighbors to new node if shorter path exists\n            for node in near_nodes(grid, new_node.position, radius):\n                if node is new_node.parent:\n                    continue\n                edge_ok = collision_free(new_node.position, node.position)\n                if not edge_ok:\n                    continue\n                c = new_node.cost + dist(new_node.position, node.position)\n                if c + 1e-12 < node.cost:\n                    # Update parent-child structure\n                    if node.parent:\n                        node.parent.remove_child(node)\n                    node.parent = new_node\n                    node.cost = c\n                    new_node.add_child(node)\n            return new_node\n\n        # Heuristic informed sampling around current best path segment (if exists)\n        def informed_sample(best_path):\n            if not best_path or len(best_path) < 2 or random.random() > self.bias_prob:\n                return sample_free()\n            # Pick random segment of best path and sample near it with Gaussian noise\n            seg_idx = random.randint(0, len(best_path)-2)\n            p1, p2 = best_path[seg_idx], best_path[seg_idx+1]\n            mid = tuple((p1[i] + p2[i]) * 0.5 for i in range(dim))\n            sigma = self.step_size * 2\n            for _ in range(10):\n                sample = tuple(random.gauss(mid[i], sigma) for i in range(dim))\n                if all(0 <= sample[i] <= bounds[i] for i in range(dim)) and not in_obstacle(sample):\n                    return sample\n            return sample_free()\n\n        # Initialize grids for spatial indexing for both trees\n        grid_start = {}\n        grid_goal = {}\n        add_to_grid(grid_start, start)\n        add_to_grid(grid_goal, goal)\n\n        success = False\n        best_path = []\n        best_cost = float('inf')\n\n        # Radius shrinks with iteration for faster convergence (radii: max_radius -> min_radius after max_iter)\n        def dynamic_radius(iter_idx):\n            t = iter_idx / self.max_iter\n            r = self.max_radius * (1 - t) + self.min_radius * t\n            return r\n\n        for i in range(self.max_iter):\n            radius = dynamic_radius(i)\n\n            # Alternate expanding start and goal trees\n            tree_a, grid_a = (tree_start, grid_start) if i % 2 == 0 else (tree_goal, grid_goal)\n            tree_b, grid_b = (tree_goal, grid_goal) if i % 2 == 0 else (tree_start, grid_start)\n\n            rand_pos = informed_sample(best_path)\n\n            nearest_node = nearest(grid_a, rand_pos)\n            if nearest_node is None:\n                continue\n\n            new_pos = steer(nearest_node.position, rand_pos)\n            if in_obstacle(new_pos):\n                continue\n\n            new_node = add_node(tree_a, grid_a, new_pos, radius)\n            if new_node is None:\n                continue\n\n            nearest_to_new = nearest(grid_b, new_node.position)\n            if nearest_to_new is None:\n                continue\n\n            d_connect = dist(new_node.position, nearest_to_new.position)\n            if d_connect <= self.step_size * 1.25 and collision_free(new_node.position, nearest_to_new.position):\n                # Connect trees by reparenting nearest_to_new to new_node (or vice versa)\n                # Choose direction minimizing cost\n                c1 = new_node.cost + d_connect + nearest_to_new.cost\n                c2 = nearest_to_new.cost + d_connect + new_node.cost\n                # Actually c1 and c2 equal in symmetric form, so just connect:\n                connector = Node(nearest_to_new.position, parent=new_node,\n                                 cost=new_node.cost + d_connect)\n                new_node.add_child(connector)\n                tree_a.append(connector)\n                add_to_grid(grid_a, connector)\n\n                # Extract combined path start->connector + connector->goal (or start<->goal depending on which tree is start)\n                if tree_a is tree_start:\n                    path_start = extract_path(connector)\n                    path_goal = extract_path(nearest_to_new)\n                else:\n                    path_start = extract_path(nearest_to_new)\n                    path_goal = extract_path(connector)\n                combined = path_start + path_goal[::-1][1:]\n\n                # Shortcut path iteratively for better smoothness and length\n                shortcut = shortcut_path(combined, iter_count=100)\n                cost = 0.0\n                for j in range(len(shortcut)-1):\n                    cost += dist(shortcut[j], shortcut[j+1])\n                if cost < best_cost:\n                    best_cost = cost\n                    best_path = shortcut\n                    success = True\n                # Early stop after first connection for faster result\n                break\n\n        return PlannerResult(success, best_path, tree_start + tree_goal, [])",
    "objective": 135.13989,
    "time_improvement": -452.0,
    "length_improvement": 18.0,
    "smoothness_improvement": 1319.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.13901526927948,
            "num_nodes_avg": 87.4,
            "path_length_avg": 161.090519718336,
            "smoothness_avg": 0.046221782585422075,
            "success_improvement": 0.0,
            "time_improvement": -429.52513025338686,
            "length_improvement": 11.703733499744,
            "smoothness_improvement": 623.4712696692525,
            "objective_score": -118.71794262782339
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.46800549030303956,
            "num_nodes_avg": 220.0,
            "path_length_avg": 231.0668893760726,
            "smoothness_avg": 0.08083190594509307,
            "success_improvement": 0.0,
            "time_improvement": -183.39917490498414,
            "length_improvement": 22.863221434624975,
            "smoothness_improvement": 1979.8631608357916,
            "objective_score": -31.402503806541294
        },
        {
            "map_id": 2,
            "success_rate": 0.9,
            "time_avg": 0.4246522903442383,
            "num_nodes_avg": 174.9,
            "path_length_avg": 122.28785432845469,
            "smoothness_avg": 0.11438894585070092,
            "success_improvement": -9.999999999999998,
            "time_improvement": -744.478876658499,
            "length_improvement": 18.782229876905106,
            "smoothness_improvement": 1355.0189479072162,
            "objective_score": -255.2992303318705
        }
    ],
    "success_rate": 0.9666666666666667
}
{
    "operator": "e2",
    "algorithm_description": "A hybrid bidirectional planner combining informed sampling with adaptive tree growth and dynamic rewiring to improve path quality, efficiency, and smoothness. The planner grows two trees from start and goal positions, samples within an informed ellipsoid focusing exploration, dynamically adjusts rewiring radius based on node density, attempts early direct connections between trees, and applies incremental path shortcutting for smoothness during planning.",
    "planning_mechanism": "The planner alternates expanding two trees using steering towards informed samples biased by the current best path cost. It maintains dynamic rewiring in local neighborhoods adapting radius by tree density, thus improving convergence speed and solution quality. The trees try direct collision-free connection attempts frequently. When a path is found, incremental shortcutting reduces jaggedness and further improves smoothness and length before returning the best path found within the iteration budget.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\nclass Planner:\n    def __init__(self, max_iter=2500, step_size=6.0, base_rewire_radius=12.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.base_rewire_radius = base_rewire_radius\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        edges = []\n\n        best_cost = float('inf')\n        best_path = []\n\n        def dist(a, b):\n            return sum((a[i] - b[i]) ** 2 for i in range(dim)) ** 0.5\n\n        def in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    px, py = pos\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def edge_collision(a, b, resolution=0.8):\n            length = dist(a, b)\n            steps = max(1, int(length / resolution))\n            for i in range(steps + 1):\n                interp = tuple(a[j] + (b[j] - a[j]) * i / steps for j in range(dim))\n                if in_obstacle(interp):\n                    return True\n            return False\n\n        def steer(from_p, to_p, max_step):\n            d = dist(from_p, to_p)\n            if d <= max_step:\n                return to_p\n            ratio = max_step / d\n            return tuple(from_p[i] + (to_p[i] - from_p[i]) * ratio for i in range(dim))\n\n        def nearest(tree, point):\n            best = None\n            best_d = float('inf')\n            for n in tree:\n                d = dist(n.position, point)\n                if d < best_d:\n                    best = n\n                    best_d = d\n            return best\n\n        def neighbors(tree, point, radius):\n            r_sq = radius * radius\n            result = []\n            for n in tree:\n                d_sq = sum((n.position[i] - point[i]) ** 2 for i in range(dim))\n                if d_sq <= r_sq:\n                    result.append(n)\n            return result\n\n        def extract_path(node1, node2):\n            path1 = []\n            cur = node1\n            while cur:\n                path1.append(cur.position)\n                cur = cur.parent\n            path1.reverse()\n            path2 = []\n            cur = node2\n            while cur:\n                path2.append(cur.position)\n                cur = cur.parent\n            return path1 + path2\n\n        def shortcut_path(path):\n            if len(path) <= 2:\n                return path\n            i = 0\n            while i < len(path) - 2:\n                j = len(path) - 1\n                shortcut_done = False\n                while j > i + 1:\n                    if not edge_collision(path[i], path[j]):\n                        path = path[:i + 1] + path[j:]\n                        shortcut_done = True\n                        break\n                    j -= 1\n                if not shortcut_done:\n                    i += 1\n            return path\n\n        def informed_sample(c_best):\n            if c_best == float('inf'):\n                while True:\n                    sample = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                    if not in_obstacle(sample):\n                        return sample\n            c_min = dist(start_pos, goal_pos)\n            if c_min == 0:\n                return goal_pos\n            center = tuple(0.5 * (start_pos[i] + goal_pos[i]) for i in range(dim))\n            a1 = tuple((goal_pos[i] - start_pos[i]) / c_min for i in range(dim))\n\n            # rotation matrix construction via Householder transform\n            def mat_vec_mult(mat, vec):\n                return tuple(sum(mat[i][j] * vec[j] for j in range(dim)) for i in range(dim))\n\n            if dim == 2:\n                theta = math.acos(max(min(a1[0], 1.0), -1.0))\n                if a1[1] < 0:\n                    theta = -theta\n                R = [[math.cos(theta), -math.sin(theta)], [math.sin(theta), math.cos(theta)]]\n            elif dim == 3:\n                x = a1\n                I = [[1 if i == j else 0 for j in range(3)] for i in range(3)]\n                v = [x[0] - 1, x[1], x[2]]\n                norm_v = (v[0] ** 2 + v[1] ** 2 + v[2] ** 2) ** 0.5\n                if norm_v < 1e-10:\n                    R = I\n                else:\n                    v = [vi / norm_v for vi in v]\n                    R = [[I[i][j] - 2 * v[i] * v[j] for j in range(3)] for i in range(3)]\n            else:\n                R = [[1 if i == j else 0 for j in range(dim)] for i in range(dim)]\n\n            L1 = c_best / 2.0\n            L_other = (max(c_best * c_best - c_min * c_min, 0)) ** 0.5 / 2.0\n\n            while True:\n                while True:\n                    sample_unit = [random.uniform(-1, 1) for _ in range(dim)]\n                    norm_s = sum(x * x for x in sample_unit) ** 0.5\n                    if 0 < norm_s <= 1:\n                        break\n                unit_vector = [x / norm_s for x in sample_unit]\n                r = random.uniform(0, 1) ** (1 / dim)\n                ball_sample = [r * u for u in unit_vector]\n                ellipsoid_sample = [L1 * ball_sample[0]] + [L_other * ball_sample[i] for i in range(1, dim)]\n                rotated = mat_vec_mult(R, ellipsoid_sample) if dim in (2, 3) else ellipsoid_sample\n                point = tuple(center[i] + rotated[i] for i in range(dim))\n\n                if all(0 <= point[i] <= bounds[i] for i in range(dim)) and not in_obstacle(point):\n                    return point\n\n        def dynamic_rewire_radius(tree_len):\n            # Adapt rewire radius with node count to improve asymptotic behavior\n            gamma_rrt_star = self.base_rewire_radius\n            return gamma_rrt_star * (math.log(max(tree_len, 2)) / max(tree_len, 2)) ** (1 / dim)\n\n        for _ in range(self.max_iter):\n            sample = informed_sample(best_cost)\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                near = nearest(tree_a, sample)\n                new_pos = steer(near.position, sample, self.step_size)\n                if in_obstacle(new_pos):\n                    continue\n                if edge_collision(near.position, new_pos):\n                    continue\n                new_cost = near.cost + dist(near.position, new_pos)\n                new_node = Node(new_pos, parent=near, cost=new_cost)\n                near.add_child(new_node)\n                tree_a.append(new_node)\n                edges.append((near, new_node))\n\n                radius = max(dynamic_rewire_radius(len(tree_a)), self.step_size)\n                nbs = neighbors(tree_a, new_pos, radius)\n                for nb in nbs:\n                    if nb is new_node.parent:\n                        continue\n                    if edge_collision(new_pos, nb.position):\n                        continue\n                    potential_cost = new_node.cost + dist(new_pos, nb.position)\n                    if potential_cost + 1e-8 < nb.cost:\n                        if nb.parent:\n                            try:\n                                nb.parent.children.remove(nb)\n                            except ValueError:\n                                pass\n                        nb.parent = new_node\n                        nb.cost = potential_cost\n                        new_node.add_child(nb)\n\n                near_to_new = nearest(tree_b, new_pos)\n                dist_btwn = dist(new_pos, near_to_new.position)\n                if dist_btwn <= self.step_size * 1.7 and not edge_collision(new_pos, near_to_new.position):\n                    connect_node = Node(near_to_new.position, parent=new_node, cost=new_node.cost + dist_btwn)\n                    new_node.add_child(connect_node)\n                    tree_b.append(connect_node)\n                    edges.append((new_node, connect_node))\n                    path = extract_path(connect_node, connect_node)\n                    path = extract_path(new_node, near_to_new)\n                    if not path:\n                        continue\n                    path = extract_path(new_node, near_to_new)\n                    if not path:\n                        continue\n                    path = extract_path(new_node, near_to_new)\n                    path = shortcut_path(path)\n                    total_cost = 0.0\n                    for i in range(len(path) - 1):\n                        total_cost += dist(path[i], path[i + 1])\n                    if total_cost < best_cost:\n                        best_cost = total_cost\n                        best_path = path\n\n            if best_path and best_cost < float('inf'):\n                # Incremental partial shortcut on best path to improve smoothness while planning\n                best_path = shortcut_path(best_path)\n                if best_cost < float('inf'):\n                    return PlannerResult(True, best_path, start_tree + goal_tree, edges)\n\n        return PlannerResult(bool(best_path), best_path, start_tree + goal_tree, edges)",
    "objective": 50.13709,
    "time_improvement": -4.0,
    "length_improvement": 11.0,
    "smoothness_improvement": 2197.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 0.8,
            "time_avg": 0.039210939407348634,
            "num_nodes_avg": 136.4,
            "path_length_avg": 178.0956777202273,
            "smoothness_avg": 0.06513479397999374,
            "success_improvement": -19.999999999999996,
            "time_improvement": -49.358972612505596,
            "length_improvement": 2.3829369349350533,
            "smoothness_improvement": 919.5009682558947,
            "objective_score": -108.78042478151116
        },
        {
            "map_id": 1,
            "success_rate": 0.9,
            "time_avg": 0.0454064130783081,
            "num_nodes_avg": 229.5,
            "path_length_avg": 240.72114014437471,
            "smoothness_avg": 0.15244346662467773,
            "success_improvement": -9.999999999999998,
            "time_improvement": 72.50429691870684,
            "length_improvement": 19.640354645964962,
            "smoothness_improvement": 3822.4801968437946,
            "objective_score": 2.647902847410009
        },
        {
            "map_id": 2,
            "success_rate": 0.9,
            "time_avg": 0.0682187795639038,
            "num_nodes_avg": 255.6,
            "path_length_avg": 132.5566116050117,
            "smoothness_avg": 0.15318658449141798,
            "success_improvement": -9.999999999999998,
            "time_improvement": -35.6623280812617,
            "length_improvement": 11.962210239491245,
            "smoothness_improvement": 1848.5220476733427,
            "objective_score": -44.27876204231704
        }
    ],
    "success_rate": 0.8666666666666667
}
{
    "operator": "e2",
    "algorithm_description": "A hybrid bidirectional incremental RRT* planner combining priority-driven node expansions with adaptive neighborhood rewiring, goal biasing, and heuristic-informed sampling. It uses efficient nearest neighbor searches, strict collision avoidance, and dynamic rewiring radius to improve path quality and convergence. The planner alternates tree expansions, attempts early connections with lazy collision checks to reduce overhead, and applies path shortcutting post-processing for smoother, shorter paths. This approach improves planning efficiency, robustness, optimality, and smoothness over baseline algorithms.",
    "planning_mechanism": "A bidirectional anytime planner growing two trees from start and goal, with priority queues ordered by cost plus heuristic, adaptive pruning radius that decreases over iterations to balance exploration and refinement, and informed sampling biased by the best path cost so far. It incrementally rewires neighboring nodes for path cost improvements and tries to connect the trees efficiently using lazy collision checks. Upon successful connection, it extracts and shortcuts the path for smoothness and returns the best found solution anytime.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost  # cost-to-come\n        self.children = []\n        self.id = id(self)\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=4000, step_size=3.0, goal_sample_rate=0.1, init_radius=20.0, radius_decay_factor=0.93, min_radius=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.init_radius = init_radius\n        self.radius_decay_factor = radius_decay_factor\n        self.min_radius = min_radius\n\n    def plan(self, map):\n        bounds = map.size\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        import math\n        import random\n        import heapq\n\n        def dist(a, b):\n            return math.sqrt(sum((a[d]-b[d])**2 for d in range(dim)))\n\n        def in_obstacle(pt):\n            if is_3d:\n                x, y, z = pt\n                for obs in obstacles:\n                    ox, oy, oz, w, h, d_ = obs\n                    if ox <= x <= ox + w and oy <= y <= oy + h and oz <= z <= oz + d_:\n                        return True\n            else:\n                x, y = pt\n                for obs in obstacles:\n                    ox, oy, w, h = obs\n                    if ox <= x <= ox + w and oy <= y <= oy + h:\n                        return True\n            return False\n\n        def edge_in_obstacle(p1, p2):\n            line_dist = dist(p1, p2)\n            steps = max(1, int(line_dist / 0.5))\n            for i in range(steps+1):\n                interp = tuple(p1[d] + (p2[d]-p1[d]) * (i/steps) for d in range(dim))\n                if in_obstacle(interp):\n                    return True\n            return False\n\n        def steer(from_p, to_p):\n            d = dist(from_p, to_p)\n            if d <= self.step_size:\n                return to_p\n            ratio = self.step_size / d\n            return tuple(from_p[d_] + ratio*(to_p[d_]-from_p[d_]) for d_ in range(dim))\n\n        def heuristic(p):\n            return dist(p, goal)\n\n        # Uniform random sample with obstacle avoidance\n        def sample_uniform():\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not in_obstacle(pt):\n                    return pt\n\n        # Informed sampling inside prolate hyperspheroid for 2D/3D\n        def sample_informed(c_best):\n            if c_best == float('inf'):\n                return sample_uniform()\n            c_min = dist(start, goal)\n            if c_best < c_min:\n                return sample_uniform()\n            center = tuple(0.5*(start[d]+goal[d]) for d in range(dim))\n            unit_vec = [(goal[d]-start[d])/c_min for d in range(dim)]\n            while True:\n                x_ball = [random.gauss(0, 1) for _ in range(dim)]\n                norm = math.sqrt(sum(x*x for x in x_ball))\n                if norm > 1e-9 and norm <= 1.0:\n                    unit_ball = [x/norm for x in x_ball]\n                    r1 = c_best / 2.0\n                    try:\n                        r2 = math.sqrt(c_best**2 - c_min**2)/2.0\n                    except:\n                        r2 = 0.0\n                    if dim == 2:\n                        angle = math.atan2(unit_vec[1], unit_vec[0])\n                        cos_ang = math.cos(angle)\n                        sin_ang = math.sin(angle)\n                        x_ell = r1 * unit_ball[0]\n                        y_ell = r2 * unit_ball[1]\n                        px = center[0] + cos_ang*x_ell - sin_ang*y_ell\n                        py = center[1] + sin_ang*x_ell + cos_ang*y_ell\n                        pt = (px, py)\n                    else:\n                        pt_candidate = [center[d] + (r1*unit_ball[0] if d==0 else r2*unit_ball[d]) for d in range(dim)]\n                        pt = tuple(min(max(0.0, pt_candidate[d]), bounds[d]) for d in range(dim))\n                    if all(0 <= pt[d] <= bounds[d] for d in range(dim)) and not in_obstacle(pt):\n                        return pt\n\n        class PriorityQueue:\n            def __init__(self):\n                self.heap = []\n                self.entry_finder = {}\n                self.REMOVED = '<removed>'\n\n            def add(self, node, priority):\n                if node.id in self.entry_finder:\n                    self.remove(node)\n                entry = [priority, node.id, node]\n                self.entry_finder[node.id] = entry\n                heapq.heappush(self.heap, entry)\n\n            def remove(self, node):\n                entry = self.entry_finder.pop(node.id, None)\n                if entry:\n                    entry[-1] = self.REMOVED\n\n            def pop(self):\n                while self.heap:\n                    priority, node_id, node = heapq.heappop(self.heap)\n                    if node != self.REMOVED:\n                        del self.entry_finder[node_id]\n                        return node\n                return None\n\n            def empty(self):\n                return not self.entry_finder\n\n        def nearest(nodes, point):\n            best = None\n            best_dist = float('inf')\n            for n in nodes:\n                d_ = dist(n.position, point)\n                if d_ < best_dist:\n                    best_dist = d_\n                    best = n\n            return best, best_dist\n\n        def neighbors(nodes, new_node, radius):\n            result = []\n            for n in nodes:\n                if dist(n.position, new_node.position) <= radius:\n                    result.append(n)\n            return result\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path[:]\n            shortened = [path[0]]\n            i = 0\n            while i < len(path)-1:\n                j = len(path)-1\n                while j > i+1:\n                    if not edge_in_obstacle(path[i], path[j]):\n                        break\n                    j -= 1\n                shortened.append(path[j])\n                i = j\n            return shortened\n\n        # Add node to tree with rewiring and lazy collision checking\n        def add_node(tree_nodes, tree_pq, pos, best_cost, neighbor_radius):\n            nearest_node, dist_near = nearest(tree_nodes, pos)\n            if in_obstacle(pos):\n                return None\n            if edge_in_obstacle(nearest_node.position, pos):\n                return None\n            cost_new = nearest_node.cost + dist(nearest_node.position, pos)\n            if cost_new > best_cost + 1e-9:\n                return None\n\n            new_node = Node(pos, parent=nearest_node, cost=cost_new)\n            nearest_node.add_child(new_node)\n            tree_nodes.append(new_node)\n            tree_pq.add(new_node, new_node.cost + heuristic(new_node.position))\n\n            nbrs = neighbors(tree_nodes, new_node, neighbor_radius)\n            for nbr in nbrs:\n                if nbr == new_node.parent:\n                    continue\n                cost_through_new = new_node.cost + dist(new_node.position, nbr.position)\n                if cost_through_new + 1e-8 < nbr.cost:\n                    if not edge_in_obstacle(new_node.position, nbr.position):\n                        # Rewire nbr to new_node\n                        if nbr.parent:\n                            nbr.parent.remove_child(nbr)\n                        nbr.parent = new_node\n                        new_node.children.append(nbr)\n                        old_cost = nbr.cost\n                        nbr.cost = cost_through_new\n\n                        def update_costs(n):\n                            for c in n.children:\n                                new_c_cost = n.cost + dist(n.position, c.position)\n                                if new_c_cost + 1e-10 < c.cost:\n                                    c.cost = new_c_cost\n                                    update_costs(c)\n                        update_costs(nbr)\n                        tree_pq.add(nbr, nbr.cost + heuristic(nbr.position))\n            return new_node\n\n        # Attempt to connect tree_b to new_node_a using lazy collision checks\n        def try_connect(tree_nodes_b, tree_pq_b, node_a, best_cost):\n            near_b, dist_nb = nearest(tree_nodes_b, node_a.position)\n            if in_obstacle(node_a.position):\n                return None\n            if edge_in_obstacle(near_b.position, node_a.position):\n                return None\n            cost_b = near_b.cost + dist(near_b.position, node_a.position)\n            if cost_b + node_a.cost > best_cost + 1e-9:\n                return None\n            new_node_b = Node(node_a.position, parent=near_b, cost=cost_b)\n            near_b.add_child(new_node_b)\n            tree_nodes_b.append(new_node_b)\n            tree_pq_b.add(new_node_b, new_node_b.cost + heuristic(new_node_b.position))\n            return new_node_b\n\n        start_node = Node(start, cost=0.0)\n        goal_node = Node(goal, cost=0.0)\n        tree_start = [start_node]\n        tree_goal = [goal_node]\n        pq_start = PriorityQueue()\n        pq_goal = PriorityQueue()\n        pq_start.add(start_node, heuristic(start))\n        pq_goal.add(goal_node, heuristic(goal))\n\n        best_cost = float('inf')\n        best_path = None\n\n        def adaptive_radius(iter_i):\n            r = self.init_radius * (self.radius_decay_factor ** (iter_i//300))\n            return max(self.min_radius, r)\n\n        for i in range(self.max_iter):\n            expanding_start = (i % 2 == 0)\n            tree_a, pq_a = (tree_start, pq_start) if expanding_start else (tree_goal, pq_goal)\n            tree_b, pq_b = (tree_goal, pq_goal) if expanding_start else (tree_start, pq_start)\n\n            curr_radius = adaptive_radius(i)\n\n            c_best = best_cost if best_cost != float('inf') else float('inf')\n            prob_goal_sample = random.random()\n            if prob_goal_sample < self.goal_sample_rate:\n                sample_pt = goal if expanding_start else start\n                if in_obstacle(sample_pt):\n                    sample_pt = sample_uniform()\n            else:\n                sample_pt = sample_informed(c_best)\n\n            new_node_a = add_node(tree_a, pq_a, sample_pt, c_best, curr_radius)\n            if new_node_a is None:\n                continue\n\n            new_node_b = try_connect(tree_b, pq_b, new_node_a, c_best)\n            if new_node_b:\n                total_cost = new_node_a.cost + new_node_b.cost\n                if total_cost + 1e-8 < best_cost:\n                    best_cost = total_cost\n\n                    path_from_start = new_node_a.path_from_root() if expanding_start else new_node_b.path_from_root()\n                    path_from_goal = new_node_b.path_from_root() if expanding_start else new_node_a.path_from_root()\n\n                    if path_from_start[-1] == path_from_goal[-1]:\n                        full_path = path_from_start + path_from_goal[-2::-1]\n                    else:\n                        full_path = path_from_start + path_from_goal[::-1]\n\n                    full_path = shortcut_path(full_path)\n                    best_path = full_path\n\n                    return PlannerResult(success=True, path=best_path, nodes=tree_start + tree_goal, edges=[])\n\n        return PlannerResult(success=False, path=[], nodes=tree_start + tree_goal, edges=[])",
    "objective": -17.94658,
    "time_improvement": 31.0,
    "length_improvement": -5.0,
    "smoothness_improvement": 2277.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.051071763038635254,
            "num_nodes_avg": 119.3,
            "path_length_avg": 194.11655051742122,
            "smoothness_avg": 0.1151204509410179,
            "success_improvement": 0.0,
            "time_improvement": -94.53821235229852,
            "length_improvement": -6.398357312182106,
            "smoothness_improvement": 1701.8850452873462,
            "objective_score": -23.69105286656209
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.008898234367370606,
            "num_nodes_avg": 43.9,
            "path_length_avg": 277.0552496626463,
            "smoothness_avg": 0.1311899827127742,
            "success_improvement": 0.0,
            "time_improvement": 94.61170364435011,
            "length_improvement": 7.5109830694104485,
            "smoothness_improvement": 3275.61274752482,
            "objective_score": 49.26816467257541
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.0032149791717529298,
            "num_nodes_avg": 24.6,
            "path_length_avg": 173.3836112782638,
            "smoothness_avg": 0.15365696665740333,
            "success_improvement": 0.0,
            "time_improvement": 93.60657634216096,
            "length_improvement": -15.153138970673938,
            "smoothness_improvement": 1854.5052741046763,
            "objective_score": 28.262615890767307
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "e2",
    "algorithm_description": "A hybrid bidirectional RRT* planner with adaptive heuristic-guided sampling, dynamic rewiring radius, prioritized node expansions, and incremental shortcutting to improve planning efficiency, path quality, robustness, and smoothness. The planner alternates growth between start and goal trees, uses informed sampling constrained by current best cost, maintains connectivity with strict collision checks, rewires neighbors for path cost improvement, and performs progressive path shortening. Early connections between trees and adaptive parameters enhance search speed and solution quality while respecting map bounds and obstacles.",
    "planning_mechanism": "The planner builds two RRT* trees from start and goal respectively, alternates expansions with cost+heuristic priority queues, and uses adaptive radius rewiring that shrinks over iterations. Sampling is biased toward ellipsoidal informed regions based on best current path cost or uniform if none found. It attempts node rewiring for shorter paths and aggressively tries to connect the two trees when new nodes are added. Upon establishing a connection, it extracts and incrementally shortcuts the path for smoothness and returns the best solution incrementally until iteration limit or solution stability is reached.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost  # cost-to-come\n        self.children = []\n        self.id = id(self)\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=3500, step_size=2.5, goal_sample_rate=0.12,\n                 init_radius=18.0, radius_decay=0.96, min_radius=4.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.init_radius = init_radius\n        self.radius_decay = radius_decay\n        self.min_radius = min_radius\n\n    def plan(self, map):\n        bounds = map.size\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        import math\n        import random\n        import heapq\n\n        def dist(a, b):\n            return math.sqrt(sum((a[d] - b[d])**2 for d in range(dim)))\n\n        def in_obstacle(pt):\n            if is_3d:\n                x, y, z = pt\n                for obs in obstacles:\n                    ox, oy, oz, w, h, d_ = obs\n                    if ox <= x <= ox + w and oy <= y <= oy + h and oz <= z <= oz + d_:\n                        return True\n            else:\n                x, y = pt\n                for obs in obstacles:\n                    ox, oy, w, h = obs\n                    if ox <= x <= ox + w and oy <= y <= oy + h:\n                        return True\n            return False\n\n        def edge_in_obstacle(p1, p2):\n            line_dist = dist(p1, p2)\n            steps = max(2, int(line_dist / 0.3))\n            for i in range(steps + 1):\n                interp = tuple(p1[d] + (p2[d] - p1[d]) * (i / steps) for d in range(dim))\n                if in_obstacle(interp):\n                    return True\n            return False\n\n        def steer(from_p, to_p):\n            d = dist(from_p, to_p)\n            if d <= self.step_size:\n                return to_p\n            ratio = self.step_size / d\n            return tuple(from_p[d_] + ratio * (to_p[d_] - from_p[d_]) for d_ in range(dim))\n\n        def heuristic(p):\n            # Euclidean distance to goal\n            return dist(p, goal)\n\n        def sample_uniform():\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not in_obstacle(pt):\n                    return pt\n\n        def sample_informed(c_best):\n            if c_best == float('inf'):\n                return sample_uniform()\n            c_min = dist(start, goal)\n            if c_best < c_min:\n                return sample_uniform()\n            center = tuple(0.5 * (start[d] + goal[d]) for d in range(dim))\n            unit_vec = [(goal[d] - start[d]) / c_min for d in range(dim)]\n            while True:\n                # Sample unit ball\n                x_ball = [random.gauss(0, 1) for _ in range(dim)]\n                norm = math.sqrt(sum(x * x for x in x_ball))\n                if norm < 1e-10:\n                    continue\n                unit_ball = [x / norm for x in x_ball]\n                r1 = c_best / 2.0\n                try:\n                    r2 = math.sqrt(max(0.0, c_best ** 2 - c_min ** 2)) / 2.0\n                except:\n                    r2 = 0.0\n                if dim == 2:\n                    angle = math.atan2(unit_vec[1], unit_vec[0])\n                    cos_ang = math.cos(angle)\n                    sin_ang = math.sin(angle)\n                    x_ell = r1 * unit_ball[0]\n                    y_ell = r2 * unit_ball[1]\n                    px = center[0] + cos_ang * x_ell - sin_ang * y_ell\n                    py = center[1] + sin_ang * x_ell + cos_ang * y_ell\n                    pt = (px, py)\n                else:\n                    # 3D sampling ellipsoid aligned with unit_vec\n                    # For simplicity project ball point scaled by r1 and r2 on axes\n                    # Let axes u=(unit_vec), v, w perpendicular and orthonormal:\n                    ux, uy, uz = unit_vec\n                    # Choose arbitrary orthonormal vectors v,w to unit_vec:\n                    if abs(ux) < 0.9:\n                        vx, vy, vz = 1, 0, 0\n                    else:\n                        vx, vy, vz = 0, 1, 0\n                    # Orthogonalize v to u\n                    dot_uv = ux * vx + uy * vy + uz * vz\n                    vx -= dot_uv * ux\n                    vy -= dot_uv * uy\n                    vz -= dot_uv * uz\n                    vnorm = math.sqrt(vx * vx + vy * vy + vz * vz)\n                    vx /= vnorm\n                    vy /= vnorm\n                    vz /= vnorm\n                    # w = u cross v\n                    wx = uy * vz - uz * vy\n                    wy = uz * vx - ux * vz\n                    wz = ux * vy - uy * vx\n                    # Ellipsoid scaling\n                    x_ell = r1 * unit_ball[0]\n                    y_ell = r2 * unit_ball[1] if len(unit_ball) > 1 else 0.0\n                    z_ell = r2 * unit_ball[2] if len(unit_ball) > 2 else 0.0\n                    px = center[0] + ux * x_ell + vx * y_ell + wx * z_ell\n                    py = center[1] + uy * x_ell + vy * y_ell + wy * z_ell\n                    pz = center[2] + uz * x_ell + vz * y_ell + wz * z_ell\n                    pt = (min(max(0.0, px), bounds[0]),\n                          min(max(0.0, py), bounds[1]),\n                          min(max(0.0, pz), bounds[2]))\n                if all(0 <= pt[d] <= bounds[d] for d in range(dim)) and not in_obstacle(pt):\n                    return pt\n\n        class PriorityQueue:\n            def __init__(self):\n                self.heap = []\n                self.entry_finder = {}\n                self.REMOVED = '<removed>'\n\n            def add(self, node, priority):\n                if node.id in self.entry_finder:\n                    self.remove(node)\n                entry = [priority, node.id, node]\n                self.entry_finder[node.id] = entry\n                heapq.heappush(self.heap, entry)\n\n            def remove(self, node):\n                entry = self.entry_finder.pop(node.id, None)\n                if entry:\n                    entry[-1] = self.REMOVED\n\n            def pop(self):\n                while self.heap:\n                    priority, node_id, node = heapq.heappop(self.heap)\n                    if node != self.REMOVED:\n                        del self.entry_finder[node_id]\n                        return node\n                return None\n\n            def empty(self):\n                return not self.entry_finder\n\n        def nearest(nodes, point):\n            best = None\n            best_dist = float('inf')\n            for n in nodes:\n                d_ = dist(n.position, point)\n                if d_ < best_dist:\n                    best_dist = d_\n                    best = n\n            return best, best_dist\n\n        def neighbors(nodes, new_node, radius):\n            res = []\n            for n in nodes:\n                if dist(n.position, new_node.position) <= radius:\n                    res.append(n)\n            return res\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path[:]\n            shortened = [path[0]]\n            i = 0\n            while i < len(path) - 1:\n                j = len(path) - 1\n                while j > i + 1:\n                    if not edge_in_obstacle(path[i], path[j]):\n                        break\n                    j -= 1\n                shortened.append(path[j])\n                i = j\n            return shortened\n\n        def add_node(tree_nodes, tree_pq, pos, best_cost, radius):\n            nearest_node, dist_nearest = nearest(tree_nodes, pos)\n            if in_obstacle(pos):\n                return None\n            edge_end = steer(nearest_node.position, pos)\n            if edge_in_obstacle(nearest_node.position, edge_end):\n                return None\n            cost_new = nearest_node.cost + dist(nearest_node.position, edge_end)\n            if cost_new > best_cost + 1e-9:\n                return None\n\n            new_node = Node(edge_end, parent=nearest_node, cost=cost_new)\n            nearest_node.add_child(new_node)\n            tree_nodes.append(new_node)\n            tree_pq.add(new_node, new_node.cost + heuristic(new_node.position))\n\n            nbrs = neighbors(tree_nodes, new_node, radius)\n            for nbr in nbrs:\n                if nbr is new_node.parent:\n                    continue\n                cost_through_new = new_node.cost + dist(new_node.position, nbr.position)\n                if cost_through_new + 1e-10 < nbr.cost:\n                    if not edge_in_obstacle(new_node.position, nbr.position):\n                        # Rewire neighbor\n                        if nbr.parent:\n                            nbr.parent.remove_child(nbr)\n                        nbr.parent = new_node\n                        new_node.children.append(nbr)\n                        old_cost = nbr.cost\n                        nbr.cost = cost_through_new\n                        \n                        def update_cost_rec(n):\n                            for c in n.children:\n                                new_c_cost = n.cost + dist(n.position, c.position)\n                                if new_c_cost + 1e-10 < c.cost:\n                                    c.cost = new_c_cost\n                                    update_cost_rec(c)\n                        update_cost_rec(nbr)\n\n                        tree_pq.add(nbr, nbr.cost + heuristic(nbr.position))\n            return new_node\n\n        def try_connect(tree_nodes_b, tree_pq_b, node_a, best_cost):\n            near_b, dist_nb = nearest(tree_nodes_b, node_a.position)\n            if in_obstacle(node_a.position):\n                return None\n            if edge_in_obstacle(near_b.position, node_a.position):\n                return None\n            cost_b = near_b.cost + dist(near_b.position, node_a.position)\n            if cost_b + node_a.cost > best_cost + 1e-9:\n                return None\n            new_node_b = Node(node_a.position, parent=near_b, cost=cost_b)\n            near_b.add_child(new_node_b)\n            tree_nodes_b.append(new_node_b)\n            tree_pq_b.add(new_node_b, new_node_b.cost + heuristic(new_node_b.position))\n            return new_node_b\n\n        start_node = Node(start, cost=0.0)\n        goal_node = Node(goal, cost=0.0)\n        tree_start = [start_node]\n        tree_goal = [goal_node]\n        pq_start = PriorityQueue()\n        pq_goal = PriorityQueue()\n        pq_start.add(start_node, heuristic(start))\n        pq_goal.add(goal_node, heuristic(goal))\n\n        best_cost = float('inf')\n        best_path = None\n\n        def adaptive_radius(iteration):\n            r = self.init_radius * (self.radius_decay ** (iteration // 200))\n            return max(r, self.min_radius)\n\n        def assemble_path(node1, node2, reverse_first=False):\n            p1 = node1.path_from_root()\n            p2 = node2.path_from_root()\n            if reverse_first:\n                p1, p2 = p2, p1\n            if p1[-1] == p2[-1]:\n                return p1 + p2[-2::-1]\n            else:\n                return p1 + p2[::-1]\n\n        for i in range(self.max_iter):\n            expanding_start = (i % 2 == 0)\n            tree_a, pq_a = (tree_start, pq_start) if expanding_start else (tree_goal, pq_goal)\n            tree_b, pq_b = (tree_goal, pq_goal) if expanding_start else (tree_start, pq_start)\n\n            radius_now = adaptive_radius(i)\n            c_best = best_cost if best_cost != float('inf') else float('inf')\n\n            if random.random() < self.goal_sample_rate:\n                sample_pt = goal if expanding_start else start\n                if in_obstacle(sample_pt):\n                    sample_pt = sample_uniform()\n            else:\n                sample_pt = sample_informed(c_best)\n\n            new_node_a = add_node(tree_a, pq_a, sample_pt, c_best, radius_now)\n            if new_node_a is None:\n                continue\n\n            new_node_b = try_connect(tree_b, pq_b, new_node_a, c_best)\n            if new_node_b is not None:\n                total_cost = new_node_a.cost + new_node_b.cost\n                if total_cost + 1e-9 < best_cost:\n                    best_cost = total_cost\n                    full_path = assemble_path(new_node_a, new_node_b, reverse_first=not expanding_start)\n                    # Incremental shortcutting to improve path smoothness progressively\n                    for _ in range(3):  # multiple passes for better shortcutting\n                        full_path = shortcut_path(full_path)\n                    best_path = full_path\n                    # Early return best solution found so far\n                    return PlannerResult(success=True, path=best_path,\n                                         nodes=tree_start + tree_goal, edges=[])\n\n        if best_path is not None:\n            return PlannerResult(success=True, path=best_path,\n                                 nodes=tree_start + tree_goal, edges=[])\n        else:\n            return PlannerResult(success=False, path=[],\n                                 nodes=tree_start + tree_goal, edges=[])",
    "objective": 78.28346,
    "time_improvement": -320.0,
    "length_improvement": 17.0,
    "smoothness_improvement": 1502.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.09466280937194824,
            "num_nodes_avg": 171.9,
            "path_length_avg": 162.55191510940662,
            "smoothness_avg": 0.050566548970300315,
            "success_improvement": 0.0,
            "time_improvement": -260.5815154165339,
            "length_improvement": 10.902719528606317,
            "smoothness_improvement": 691.4762984038111,
            "objective_score": -68.17544141577731
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.3075594902038574,
            "num_nodes_avg": 483.3,
            "path_length_avg": 233.90380122096667,
            "smoothness_avg": 0.0959768279394908,
            "success_improvement": 0.0,
            "time_improvement": -86.24163084397186,
            "length_improvement": 21.916178604819418,
            "smoothness_improvement": 2369.5529121980353,
            "objective_score": -0.87501752930973
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.3581078052520752,
            "num_nodes_avg": 424.8,
            "path_length_avg": 123.93067529775901,
            "smoothness_avg": 0.12152960307827645,
            "success_improvement": 0.0,
            "time_improvement": -612.1461110141782,
            "length_improvement": 17.69114641182126,
            "smoothness_improvement": 1445.8475807734867,
            "objective_score": -165.79990755329325
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "e2",
    "algorithm_description": "A hybrid bidirectional incremental RRT* planner enhanced with goal-bias informed ellipsoidal sampling, iterative adaptive rewiring radius decay, prioritized node expansions using heuristic-cost queues, early tree connection attempts using strict collision checks, and multi-pass incremental shortcutting for progressive path length and smoothness improvements. It grows two trees simultaneously, alternates expansions, rewires neighbors to optimize costs, and incrementally updates the best found path until max iterations or convergence is met, achieving improved planning efficiency, path quality, robustness, and smoothness.",
    "planning_mechanism": "A bidirectional RRT* approach with heuristic sampling in ellipsoidal informed regions, priority queuing for node expansions, adaptive radius rewiring that shrinks over time, strict collision avoidance in node and edge addition, and repeated multi-step path shortcutting upon connection to return progressively smoother and shorter paths. The planner alternates growth between the start and goal trees, tries connecting them early, and updates the best known path dynamically.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.id = id(self)\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def path_from_root(self):\n        path = []\n        n = self\n        while n:\n            path.append(n.position)\n            n = n.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=3500, step_size=2.5, goal_sample_rate=0.12,\n                 init_radius=18.0, radius_decay=0.96, min_radius=4.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.init_radius = init_radius\n        self.radius_decay = radius_decay\n        self.min_radius = min_radius\n\n    def plan(self, map):\n        bounds = map.size\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        import math\n        import random\n        import heapq\n\n        def dist(a, b):\n            return math.sqrt(sum((a[d] - b[d]) ** 2 for d in range(dim)))\n\n        def in_obstacle(pt):\n            if is_3d:\n                x, y, z = pt\n                for obs in obstacles:\n                    ox, oy, oz, w, h, d_ = obs\n                    if ox <= x <= ox + w and oy <= y <= oy + h and oz <= z <= oz + d_:\n                        return True\n            else:\n                x, y = pt\n                for obs in obstacles:\n                    ox, oy, w, h = obs\n                    if ox <= x <= ox + w and oy <= y <= oy + h:\n                        return True\n            return False\n\n        def edge_in_obstacle(p1, p2):\n            length = dist(p1, p2)\n            steps = max(2, int(length / 0.3))\n            for i in range(steps + 1):\n                interp = tuple(p1[d] + (p2[d] - p1[d]) * (i / steps) for d in range(dim))\n                if in_obstacle(interp):\n                    return True\n            return False\n\n        def steer(from_p, to_p):\n            d = dist(from_p, to_p)\n            if d <= self.step_size:\n                return to_p\n            ratio = self.step_size / d\n            return tuple(from_p[d_] + ratio * (to_p[d_] - from_p[d_]) for d_ in range(dim))\n\n        def heuristic(p):\n            return dist(p, goal)\n\n        def sample_uniform():\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not in_obstacle(pt):\n                    return pt\n\n        def sample_informed(c_best):\n            if c_best == float('inf'):\n                return sample_uniform()\n            c_min = dist(start, goal)\n            if c_best < c_min:\n                return sample_uniform()\n            center = tuple((start[d] + goal[d]) * 0.5 for d in range(dim))\n            vec = [(goal[d] - start[d]) / c_min for d in range(dim)]\n\n            while True:\n                # Sample from unit ball\n                x_ball = [random.gauss(0, 1) for _ in range(dim)]\n                norm = math.sqrt(sum(x * x for x in x_ball))\n                if norm < 1e-10:\n                    continue\n                unit_ball = [x / norm for x in x_ball]\n                r1 = c_best * 0.5\n                r2 = math.sqrt(max(0.0, c_best ** 2 - c_min ** 2)) * 0.5 if c_best > c_min else 0.0\n\n                if dim == 2:\n                    angle = math.atan2(vec[1], vec[0])\n                    cos_a = math.cos(angle)\n                    sin_a = math.sin(angle)\n                    x_ell = r1 * unit_ball[0]\n                    y_ell = r2 * unit_ball[1]\n                    px = center[0] + cos_a * x_ell - sin_a * y_ell\n                    py = center[1] + sin_a * x_ell + cos_a * y_ell\n                    pt = (px, py)\n                else:  # 3D\n                    ux, uy, uz = vec\n                    if abs(ux) < 0.9:\n                        vx, vy, vz = 1, 0, 0\n                    else:\n                        vx, vy, vz = 0, 1, 0\n                    dot_uv = ux * vx + uy * vy + uz * vz\n                    vx -= dot_uv * ux\n                    vy -= dot_uv * uy\n                    vz -= dot_uv * uz\n                    vnorm = math.sqrt(vx * vx + vy * vy + vz * vz)\n                    vx /= vnorm\n                    vy /= vnorm\n                    vz /= vnorm\n                    wx = uy * vz - uz * vy\n                    wy = uz * vx - ux * vz\n                    wz = ux * vy - uy * vx\n                    x_ell = r1 * unit_ball[0]\n                    y_ell = r2 * unit_ball[1] if len(unit_ball) > 1 else 0.0\n                    z_ell = r2 * unit_ball[2] if len(unit_ball) > 2 else 0.0\n                    px = center[0] + ux * x_ell + vx * y_ell + wx * z_ell\n                    py = center[1] + uy * x_ell + vy * y_ell + wy * z_ell\n                    pz = center[2] + uz * x_ell + vz * y_ell + wz * z_ell\n                    pt_raw = (px, py, pz)\n                    pt = tuple(min(max(0.0, pt_raw[d]) , bounds[d]) for d in range(dim))\n\n                if all(0 <= pt[d] <= bounds[d] for d in range(dim)) and not in_obstacle(pt):\n                    return pt\n\n        class PriorityQueue:\n            def __init__(self):\n                self.heap = []\n                self.entry_finder = {}\n                self.REMOVED = '<removed>'\n\n            def add(self, node, priority):\n                if node.id in self.entry_finder:\n                    self.remove(node)\n                entry = [priority, node.id, node]\n                self.entry_finder[node.id] = entry\n                heapq.heappush(self.heap, entry)\n\n            def remove(self, node):\n                entry = self.entry_finder.pop(node.id, None)\n                if entry:\n                    entry[-1] = self.REMOVED\n\n            def pop(self):\n                while self.heap:\n                    priority, node_id, node = heapq.heappop(self.heap)\n                    if node != self.REMOVED:\n                        del self.entry_finder[node_id]\n                        return node\n                return None\n\n            def empty(self):\n                return not self.entry_finder\n\n        def nearest(nodes, point):\n            best = None\n            best_dist = float('inf')\n            for n in nodes:\n                d_ = dist(n.position, point)\n                if d_ < best_dist:\n                    best_dist = d_\n                    best = n\n            return best, best_dist\n\n        def neighbors(tree_nodes, new_node, radius):\n            res = []\n            for n in tree_nodes:\n                if dist(n.position, new_node.position) <= radius:\n                    res.append(n)\n            return res\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path[:]\n            shortened = [path[0]]\n            i = 0\n            while i < len(path) - 1:\n                j = len(path) - 1\n                while j > i + 1:\n                    if not edge_in_obstacle(path[i], path[j]):\n                        break\n                    j -= 1\n                shortened.append(path[j])\n                i = j\n            return shortened\n\n        def add_node(tree_nodes, tree_pq, pos, best_cost, radius):\n            nearest_node, _ = nearest(tree_nodes, pos)\n            if in_obstacle(pos):\n                return None\n            new_pos = steer(nearest_node.position, pos)\n            if edge_in_obstacle(nearest_node.position, new_pos):\n                return None\n            cost_new = nearest_node.cost + dist(nearest_node.position, new_pos)\n            if cost_new > best_cost + 1e-9:\n                return None\n\n            new_node = Node(new_pos, parent=nearest_node, cost=cost_new)\n            nearest_node.add_child(new_node)\n            tree_nodes.append(new_node)\n            tree_pq.add(new_node, new_node.cost + heuristic(new_node.position))\n\n            nbrs = neighbors(tree_nodes, new_node, radius)\n            for nbr in nbrs:\n                if nbr is new_node.parent:\n                    continue\n                cost_through_new = new_node.cost + dist(new_node.position, nbr.position)\n                if cost_through_new + 1e-10 < nbr.cost and not edge_in_obstacle(new_node.position, nbr.position):\n                    if nbr.parent:\n                        nbr.parent.remove_child(nbr)\n                    nbr.parent = new_node\n                    new_node.children.append(nbr)\n                    old_cost = nbr.cost\n                    nbr.cost = cost_through_new\n\n                    def update_cost_recursive(node):\n                        for c in node.children:\n                            new_c_cost = node.cost + dist(node.position, c.position)\n                            if new_c_cost + 1e-10 < c.cost:\n                                c.cost = new_c_cost\n                                update_cost_recursive(c)\n                    update_cost_recursive(nbr)\n\n                    tree_pq.add(nbr, nbr.cost + heuristic(nbr.position))\n            return new_node\n\n        def try_connect(tree_nodes_b, tree_pq_b, node_a, best_cost):\n            near_b, _ = nearest(tree_nodes_b, node_a.position)\n            if in_obstacle(node_a.position):\n                return None\n            if edge_in_obstacle(near_b.position, node_a.position):\n                return None\n            cost_b = near_b.cost + dist(near_b.position, node_a.position)\n            if cost_b + node_a.cost > best_cost + 1e-9:\n                return None\n            new_node_b = Node(node_a.position, parent=near_b, cost=cost_b)\n            near_b.add_child(new_node_b)\n            tree_nodes_b.append(new_node_b)\n            tree_pq_b.add(new_node_b, new_node_b.cost + heuristic(new_node_b.position))\n            return new_node_b\n\n        def assemble_path(node1, node2, reverse_first=False):\n            p1 = node1.path_from_root()\n            p2 = node2.path_from_root()\n            if reverse_first:\n                p1, p2 = p2, p1\n            if p1[-1] == p2[-1]:\n                return p1 + p2[-2::-1]\n            return p1 + p2[::-1]\n\n        start_node = Node(start, cost=0.0)\n        goal_node = Node(goal, cost=0.0)\n        tree_start = [start_node]\n        tree_goal = [goal_node]\n        pq_start = PriorityQueue()\n        pq_goal = PriorityQueue()\n        pq_start.add(start_node, heuristic(start))\n        pq_goal.add(goal_node, heuristic(goal))\n\n        best_cost = float('inf')\n        best_path = None\n\n        def adaptive_radius(iteration):\n            r = self.init_radius * (self.radius_decay ** (iteration // 200))\n            return max(r, self.min_radius)\n\n        for i in range(self.max_iter):\n            expand_start = (i % 2 == 0)\n            tree_a, pq_a = (tree_start, pq_start) if expand_start else (tree_goal, pq_goal)\n            tree_b, pq_b = (tree_goal, pq_goal) if expand_start else (tree_start, pq_start)\n\n            radius_now = adaptive_radius(i)\n            c_best = best_cost if best_cost != float('inf') else float('inf')\n\n            if random.random() < self.goal_sample_rate:\n                sample_pt = goal if expand_start else start\n                if in_obstacle(sample_pt):\n                    sample_pt = sample_uniform()\n            else:\n                sample_pt = sample_informed(c_best)\n\n            new_node_a = add_node(tree_a, pq_a, sample_pt, c_best, radius_now)\n            if new_node_a is None:\n                continue\n\n            new_node_b = try_connect(tree_b, pq_b, new_node_a, c_best)\n            if new_node_b is not None:\n                total_cost = new_node_a.cost + new_node_b.cost\n                if total_cost + 1e-9 < best_cost:\n                    best_cost = total_cost\n                    full_path = assemble_path(new_node_a, new_node_b, reverse_first=not expand_start)\n                    for _ in range(3):\n                        full_path = shortcut_path(full_path)\n                    best_path = full_path\n                    # Early return best found path\n                    return PlannerResult(success=True, path=best_path,\n                                         nodes=tree_start + tree_goal, edges=[])\n\n        if best_path is not None:\n            return PlannerResult(success=True, path=best_path,\n                                 nodes=tree_start + tree_goal, edges=[])\n        return PlannerResult(success=False, path=[],\n                             nodes=tree_start + tree_goal, edges=[])",
    "objective": 174.79274,
    "time_improvement": -587.0,
    "length_improvement": 17.0,
    "smoothness_improvement": 1555.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 0.9,
            "time_avg": 0.10429792404174805,
            "num_nodes_avg": 215.8,
            "path_length_avg": 169.62042257932035,
            "smoothness_avg": 0.05500088486547133,
            "success_improvement": -9.999999999999998,
            "time_improvement": -297.28277404068393,
            "length_improvement": 7.028358576678043,
            "smoothness_improvement": 760.8832844777564,
            "objective_score": -131.16340064380958
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.28416149616241454,
            "num_nodes_avg": 478.6,
            "path_length_avg": 231.5507192294831,
            "smoothness_avg": 0.10104939058994422,
            "success_improvement": 0.0,
            "time_improvement": -72.07305303202565,
            "length_improvement": 22.701705103286386,
            "smoothness_improvement": 2500.0736028133983,
            "objective_score": 4.499475166431127
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.7499562740325928,
            "num_nodes_avg": 607.1,
            "path_length_avg": 118.75170696481845,
            "smoothness_avg": 0.11830697927679305,
            "success_improvement": 0.0,
            "time_improvement": -1391.3901237283892,
            "length_improvement": 21.13077058258963,
            "smoothness_improvement": 1404.8560438879633,
            "objective_score": -397.7142945495232
        }
    ],
    "success_rate": 0.9666666666666667
}
{
    "operator": "m1",
    "algorithm_description": "A bidirectional RRT* inspired planner that grows two trees from start and goal by incrementally extending toward random free samples, rewiring to optimize path costs, and attempting to connect trees when new nodes are added. It uses adaptive sampling bias to improve convergence, incremental collision-checked edge extensions with variable step sizes, and post-processing path smoothing via shortcutting to improve smoothness and path quality.",
    "planning_mechanism": "A planner that iteratively samples free configurations, extends both trees towards samples using cost-aware rewiring to optimize the tree structure, tries to connect the two trees, and once connected, extracts an optimized path with path shortcutting to reduce detours and jagged motions, resulting in faster planning and higher quality, smoother paths.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position      # Tuple[float, ...]\n        self.parent = parent          # Node or None\n        self.children = []            # List of child nodes\n        self.cost = cost              # Cost to come from root\n    \n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=5.0, rewire_radius=15.0, shortcut_iters=50):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.rewire_radius = rewire_radius\n        self.shortcut_iters = shortcut_iters\n\n    def plan(self, map):\n        import math, random\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        tree_start = [Node(start_pos)]\n        tree_goal = [Node(goal_pos)]\n        nodes = tree_start + tree_goal\n        edges = []\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            ratio = self.step_size / d\n            return tuple(from_pos[i] + ratio * (to_pos[i] - from_pos[i]) for i in range(len(from_pos)))\n\n        def in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d = obs\n                    px,py,pz = pos\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                        return True\n                else:\n                    x,y,w,h = obs\n                    px,py = pos\n                    if x <= px <= x+w and y <= py <= y+h:\n                        return True\n            return False\n\n        def edge_in_obstacle(p1, p2, resolution=1.0):\n            d = dist(p1, p2)\n            steps = max(1, int(d / resolution))\n            for i in range(steps+1):\n                interp = tuple(p1[j] + (p2[j]-p1[j]) * (i/steps) for j in range(len(p1)))\n                if in_obstacle(interp):\n                    return True\n            return False\n\n        def sample_free():\n            # Adaptive biasing: With 10% chance sample goal or start to steer faster\n            r = random.random()\n            if r < 0.05:\n                return goal_pos\n            elif r < 0.1:\n                return start_pos\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                if not in_obstacle(pt):\n                    return pt\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: dist(node.position, point))\n\n        def neighbors(tree, point, radius):\n            return [node for node in tree if dist(node.position, point) <= radius]\n\n        def rewire(tree, new_node):\n            near_nodes = neighbors(tree, new_node.position, self.rewire_radius)\n            for near_node in near_nodes:\n                if near_node is new_node.parent:\n                    continue\n                if not edge_in_obstacle(new_node.position, near_node.position):\n                    new_cost = new_node.cost + dist(new_node.position, near_node.position)\n                    if new_cost < near_node.cost:\n                        # Rewire near_node under new_node\n                        if near_node.parent:\n                            near_node.parent.remove_child(near_node)\n                        near_node.parent = new_node\n                        new_node.add_child(near_node)\n                        near_node.cost = new_cost\n                        # Update subtree costs recursively\n                        self._update_costs(near_node)\n\n        def extend(tree, sample_pt):\n            nearest_node = nearest(tree, sample_pt)\n            new_pos = steer(nearest_node.position, sample_pt)\n            if in_obstacle(new_pos) or edge_in_obstacle(nearest_node.position, new_pos):\n                return None\n            new_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            new_node = Node(new_pos, parent=nearest_node, cost=new_cost)\n            nearest_node.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n            # Rewire to improve paths\n            rewire(tree, new_node)\n            return new_node\n\n        def update_costs(node):\n            for child in node.children:\n                child.cost = node.cost + dist(node.position, child.position)\n                update_costs(child)\n\n        self._update_costs = update_costs  # assign for recursive calls inside rewire\n\n        def connect_trees(tree_a, tree_b, new_node_b):\n            nearest_in_a = nearest(tree_a, new_node_b.position)\n            last_new = new_node_b\n            while True:\n                next_pos = steer(nearest_in_a.position, last_new.position)\n                if in_obstacle(next_pos) or edge_in_obstacle(nearest_in_a.position, next_pos):\n                    return None\n                new_cost = nearest_in_a.cost + dist(nearest_in_a.position, next_pos)\n                next_node = Node(next_pos, parent=nearest_in_a, cost=new_cost)\n                nearest_in_a.add_child(next_node)\n                tree_a.append(next_node)\n                nodes.append(next_node)\n                edges.append((nearest_in_a, next_node))\n                # Rewire tree_a to improve paths\n                rewire(tree_a, next_node)\n                if dist(next_node.position, last_new.position) <= self.step_size:\n                    # Try connecting final edge to last_new\n                    if in_obstacle(last_new.position) or edge_in_obstacle(next_node.position, last_new.position):\n                        return None\n                    final_cost = next_node.cost + dist(next_node.position, last_new.position)\n                    final_node = Node(last_new.position, parent=next_node, cost=final_cost)\n                    next_node.add_child(final_node)\n                    tree_a.append(final_node)\n                    nodes.append(final_node)\n                    edges.append((next_node, final_node))\n                    rewire(tree_a, final_node)\n                    return final_node\n                nearest_in_a = next_node\n\n        def extract_path(node_start, node_goal):\n            path_start = node_start.path_from_root()\n            path_goal = node_goal.path_from_root()\n            # Remove duplicate connection node if positions equal\n            if path_start[-1] == path_goal[-1]:\n                path = path_start + path_goal[-2::-1]\n            else:\n                path = path_start + path_goal[::-1]\n            return path\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path[:]\n            path = path[:]\n            for _ in range(self.shortcut_iters):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path)-3)\n                j = random.randint(i+2, len(path)-1)\n                if not edge_in_obstacle(path[i], path[j]):\n                    # Shortcut exists, remove intermediate points\n                    path = path[:i+1] + path[j:]\n            return path\n\n        # Main planning loop\n        for i in range(self.max_iter):\n            sample_pt = sample_free()\n            # Alternate tree extension for balance\n            trees = (tree_start, tree_goal) if (i % 2 == 0) else (tree_goal, tree_start)\n            new_node = extend(trees[0], sample_pt)\n            if new_node is None:\n                continue\n            connected_node = connect_trees(trees[1], trees[0], new_node)\n            if connected_node:\n                path = extract_path(new_node, connected_node)\n                smooth = shortcut_path(path)\n                return PlannerResult(True, smooth, nodes, edges)\n        return PlannerResult(False, [], nodes, edges)",
    "objective": -26.66239,
    "time_improvement": 37.0,
    "length_improvement": 17.0,
    "smoothness_improvement": 1121.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.013171768188476563,
            "num_nodes_avg": 69.2,
            "path_length_avg": 158.52217687945418,
            "smoothness_avg": 0.027471418800683094,
            "success_improvement": 0.0,
            "time_improvement": 49.827221845334265,
            "length_improvement": 13.111482907731792,
            "smoothness_improvement": 329.98735937142976,
            "objective_score": 24.464993095096503
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.05002806186676025,
            "num_nodes_avg": 263.7,
            "path_length_avg": 241.49667787737857,
            "smoothness_avg": 0.0786364533363562,
            "success_improvement": 0.0,
            "time_improvement": 69.70567279893451,
            "length_improvement": 19.38145782807234,
            "smoothness_improvement": 1923.3725838923956,
            "objective_score": 42.15743945598574
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.05518603324890137,
            "num_nodes_avg": 242.7,
            "path_length_avg": 123.63351542580783,
            "smoothness_avg": 0.09520698603719767,
            "success_improvement": 0.0,
            "time_improvement": -9.744938211665817,
            "length_improvement": 17.888505849538728,
            "smoothness_improvement": 1111.0258349444482,
            "objective_score": 13.364751220945731
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m3",
    "algorithm_description": "A simplified bidirectional RRT planner that efficiently grows two trees from start and goal positions. It alternates tree expansions towards random free samples and attempts to connect the trees for path finding. Rigorous collision checks on nodes and edges ensure safety. The planner avoids complex rewiring or smoothing, emphasizing understandable and reliable path discovery.",
    "planning_mechanism": "The planner grows two trees from start and goal, sampling random points inside bounds and extending each tree toward these points stepwise while checking collisions. After each extension, it tries to connect the opposite tree to the new node. Upon connection, it reconstructs the path by joining the two trees\u2019 paths, returning success; otherwise, it repeats up to a maximum iteration count.",
    "code": "class Node:\n    def __init__(self, position, parent=None):\n        self.position = position\n        self.parent = parent\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        path, node = [], self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map):\n        import random, math\n        bounds = map.size\n        start, goal = map.start, map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start)]\n        goal_tree = [Node(goal)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        def sample_free():\n            while True:\n                p = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                if not is_in_obstacle(p):\n                    return p\n\n        def is_in_obstacle(p):\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d = obs\n                    if x <= p[0] <= x+w and y <= p[1] <= y+h and z <= p[2] <= z+d:\n                        return True\n                else:\n                    x,y,w,h = obs\n                    if x <= p[0] <= x+w and y <= p[1] <= y+h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(p1, p2, resolution=1.0):\n            dist = math.dist(p1, p2)\n            steps = max(1, int(dist / resolution))\n            for i in range(steps+1):\n                interp = tuple(p1[d] + (p2[d]-p1[d]) * i/steps for d in range(len(p1)))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: math.dist(n.position, point))\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + ratio * (to_pos[d]-from_pos[d]) for d in range(len(from_pos)))\n\n        def extend(tree, target):\n            nearest_node = nearest(tree, target)\n            new_pos = steer(nearest_node.position, target)\n            if (not is_in_obstacle(new_pos) and not is_edge_in_obstacle(nearest_node.position, new_pos)):\n                new_node = Node(new_pos)\n                nearest_node.add_child(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((nearest_node, new_node))\n                return new_node\n            return None\n\n        def connect(tree, target_node):\n            current = nearest(tree, target_node.position)\n            while True:\n                new_pos = steer(current.position, target_node.position)\n                if is_in_obstacle(new_pos) or is_edge_in_obstacle(current.position, new_pos):\n                    return None\n                new_node = Node(new_pos)\n                current.add_child(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((current, new_node))\n                if math.dist(new_pos, target_node.position) <= self.step_size:\n                    if not is_edge_in_obstacle(new_pos, target_node.position):\n                        final_node = Node(target_node.position)\n                        new_node.add_child(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    return None\n                current = new_node\n\n        for i in range(self.max_iter):\n            rand_point = sample_free()\n            tree_a, tree_b = (start_tree, goal_tree) if i % 2 == 0 else (goal_tree, start_tree)\n            new_node = extend(tree_a, rand_point)\n            if new_node is None:\n                continue\n            connected_node = connect(tree_b, new_node)\n            if connected_node:\n                path_a = new_node.path_from_root()\n                path_b = connected_node.path_from_root()\n                full_path = path_a + path_b[::-1]\n                return PlannerResult(True, full_path, nodes, edges)\n\n        return PlannerResult(False, [], nodes, edges)",
    "objective": -22.17466,
    "time_improvement": 79.0,
    "length_improvement": -3.0,
    "smoothness_improvement": 65.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.003809499740600586,
            "num_nodes_avg": 73.7,
            "path_length_avg": 178.46637665923026,
            "smoothness_avg": 0.010942951354709452,
            "success_improvement": 0.0,
            "time_improvement": 85.4891778665962,
            "length_improvement": 2.179750972366932,
            "smoothness_improvement": 71.28095170040967,
            "objective_score": 27.311008701901063
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.009117722511291504,
            "num_nodes_avg": 227.8,
            "path_length_avg": 308.81910883768927,
            "smoothness_avg": 0.0062857777942338725,
            "success_improvement": 0.0,
            "time_improvement": 94.47879332560935,
            "length_improvement": -3.09270739521206,
            "smoothness_improvement": 61.73759010838131,
            "objective_score": 26.79670151109747
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.021011710166931152,
            "num_nodes_avg": 348.1,
            "path_length_avg": 164.0108412010742,
            "smoothness_avg": 0.012713382189075556,
            "success_improvement": 0.0,
            "time_improvement": 58.215354533799626,
            "length_improvement": -8.928191368754328,
            "smoothness_improvement": 61.713283040781754,
            "objective_score": 12.416257954091197
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m3",
    "algorithm_description": "A streamlined bidirectional RRT planner that alternately grows trees toward random samples with efficient collision checking and directly attempts to connect them, avoiding extra intermediate nodes and complex mechanisms to quickly find a feasible path.",
    "planning_mechanism": "The planner alternates extending trees from start and goal toward random free points, verifying collisions for nodes and edges, then tries connecting the opposite tree\u2019s nearest node directly to the newly added node to form a path, returning immediately upon success.",
    "code": "class Node:\n    def __init__(self, position, parent=None):\n        self.position = position\n        self.parent = parent\n\n    def path_from_root(self):\n        path, node = [], self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map):\n        import random, math\n        bounds = map.size\n        start, goal = map.start, map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n\n        def in_obstacle(p):\n            for obs in obstacles:\n                if dim == 3:\n                    x,y,z,w,h,d = obs\n                    if x <= p[0] <= x+w and y <= p[1] <= y+h and z <= p[2] <= z+d:\n                        return True\n                else:\n                    x,y,w,h = obs\n                    if x <= p[0] <= x+w and y <= p[1] <= y+h:\n                        return True\n            return False\n\n        def edge_collision(p1, p2, res=1.0):\n            dist = math.dist(p1, p2)\n            steps = max(1, int(dist / res))\n            for i in range(steps+1):\n                interp = tuple(p1[d] + (p2[d]-p1[d]) * i/steps for d in range(dim))\n                if in_obstacle(interp):\n                    return True\n            return False\n\n        def sample_free():\n            while True:\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not in_obstacle(p):\n                    return p\n\n        def nearest(tree, p):\n            return min(tree, key=lambda n: math.dist(n.position, p))\n\n        def steer(from_p, to_p):\n            dist = math.dist(from_p, to_p)\n            if dist <= self.step_size:\n                return to_p\n            ratio = self.step_size/dist\n            return tuple(from_p[d] + ratio*(to_p[d]-from_p[d]) for d in range(dim))\n\n        start_tree = [Node(start)]\n        goal_tree = [Node(goal)]\n        nodes, edges = start_tree + goal_tree, []\n\n        for i in range(self.max_iter):\n            rand_pt = sample_free()\n            tree_a, tree_b = (start_tree, goal_tree) if i % 2 == 0 else (goal_tree, start_tree)\n            near = nearest(tree_a, rand_pt)\n            new_pos = steer(near.position, rand_pt)\n            if in_obstacle(new_pos) or edge_collision(near.position, new_pos):\n                continue\n            new_node = Node(new_pos, near)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((near, new_node))\n\n            near_b = nearest(tree_b, new_pos)\n            if not edge_collision(near_b.position, new_pos):\n                new_node_b = Node(new_pos, near_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((near_b, new_node_b))\n\n                path_a = new_node.path_from_root()\n                path_b = new_node_b.path_from_root()\n                return PlannerResult(True, path_a + path_b[::-1], nodes, edges)\n\n        return PlannerResult(False, [], nodes, edges)",
    "objective": -23.58846,
    "time_improvement": 80.0,
    "length_improvement": -2.0,
    "smoothness_improvement": 90.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.007964897155761718,
            "num_nodes_avg": 97.1,
            "path_length_avg": 188.79254971727624,
            "smoothness_avg": 0.01216603718031909,
            "success_improvement": 0.0,
            "time_improvement": 69.66079175532616,
            "length_improvement": -3.4801881094312552,
            "smoothness_improvement": 90.42490084458115,
            "objective_score": 19.262249165161997
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.008180975914001465,
            "num_nodes_avg": 219.4,
            "path_length_avg": 299.83809370433016,
            "smoothness_avg": 0.007442551666893669,
            "success_improvement": 0.0,
            "time_improvement": 95.04603712566637,
            "length_improvement": -0.09458603950933,
            "smoothness_improvement": 91.50221504246055,
            "objective_score": 28.914570589206615
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.01209850311279297,
            "num_nodes_avg": 264.7,
            "path_length_avg": 152.1665942775345,
            "smoothness_avg": 0.014835120894542881,
            "success_improvement": 0.0,
            "time_improvement": 75.94047989318848,
            "length_improvement": -1.0618065245696475,
            "smoothness_improvement": 88.70164276386569,
            "objective_score": 22.588568267034084
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "cross_over",
    "algorithm_description": "An enhanced bidirectional RRT* with adaptive informed sampling, dynamic neighbor radius based on node density and current best cost, incremental rewiring with cost propagation, plus an efficient lazy collision checking mechanism that skips unnecessary checks by probabilistic caching. The algorithm employs a progressive shortcut smoothing phase triggered during planning when improvements plateau, aggressively refining path length and smoothness while maintaining low planning time via early exits and bidirectional direct connections.",
    "planning_mechanism": "Planning is performed by alternating growth of two trees from start and goal exploiting an adaptive ellipsoidal informed sampler biased towards promising solution regions. For every sampled node, the algorithm chooses the best parent from neighbors within an adaptively computed radius, adds the node if collision-free, and rewires neighbor nodes recursively propagating improved costs. A lazy collision check cache reduces redundant edge collision tests. When the trees come sufficiently close and connect, a progressively aggressive shortcutting and smoothing phase refines the current path, improving length and smoothness iteratively without large time overhead. The planner stops early if no improvements are observed for successive iterations or time limit is reached.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n\n    def path_from_root(self):\n        path = []\n        n = self\n        while n is not None:\n            path.append(n.position)\n            n = n.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=3500, step_size=5.0, gamma=35.0,\n                 time_limit_sec=12.0, shortcut_attempts=80, no_improve_threshold=60):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.gamma = gamma\n        self.time_limit_sec = time_limit_sec\n        self.shortcut_attempts = shortcut_attempts\n        self.no_improve_threshold = no_improve_threshold\n\n    def plan(self, map):\n        import math\n        import random\n        import time\n\n        bounds = map.size\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        def dist(a, b):\n            # Euclidean distance\n            return math.dist(a, b)\n\n        def within_bounds(p):\n            return all(0.0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def in_obstacle(p):\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d = obs\n                    px,py,pz = p\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                        return True\n                else:\n                    x,y,w,h = obs\n                    px,py = p\n                    if x <= px <= x+w and y <= py <= y+h:\n                        return True\n            return False\n\n        def edge_collision(a, b, resolution=1.0):\n            length = dist(a, b)\n            steps = max(6, int(length / resolution))\n            for i in range(steps+1):\n                t = i / steps\n                pt = tuple(a[d] + (b[d] - a[d]) * t for d in range(dim))\n                if in_obstacle(pt):\n                    return True\n            return False\n\n        def steer(from_p, to_p):\n            d = dist(from_p, to_p)\n            if d <= self.step_size:\n                return to_p\n            r = self.step_size / d\n            return tuple(from_p[i] + (to_p[i]-from_p[i])*r for i in range(dim))\n\n        def neighbor_radius(n_nodes, c_best=float('inf')):\n            if n_nodes < 2:\n                return self.step_size * 2.2\n            base = self.gamma * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            max_r = max(bounds) * 0.3\n            min_r = max(self.step_size*1.8, 9.0)\n            r = max(min_r, min(max_r, base))\n            if c_best < float('inf'):\n                r = min(r, max(self.step_size*2.1, c_best*0.12))\n            return r\n\n        def nearest(tree, p):\n            return min(tree, key=lambda n: dist(n.position, p))\n\n        def near_nodes(tree, p, radius):\n            r_sq = radius*radius\n            result = []\n            for n in tree:\n                dd = 0.0\n                for d in range(dim):\n                    dx = n.position[d] - p[d]\n                    dd += dx*dx\n                    if dd > r_sq:\n                        break\n                else:\n                    result.append(n)\n            return result\n\n        def sample_uniform():\n            for _ in range(100):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not in_obstacle(p):\n                    return p\n            return start_pos\n\n        def sample_unit_ball():\n            while True:\n                v = [random.gauss(0,1) for _ in range(dim)]\n                normv = math.sqrt(sum(x*x for x in v))\n                if normv > 1e-12:\n                    v = [x/normv for x in v]\n                    r = random.random() ** (1.0 / dim)\n                    return tuple(v[i]*r for i in range(dim))\n\n        def sample_informed(c_best):\n            if c_best == float(\"inf\"):\n                return sample_uniform()\n            c_min = dist(start_pos, goal_pos)\n            if c_min < 1e-14:\n                return sample_uniform()\n            r1 = c_best/2.0\n            r_other_sq = max(c_best*c_best - c_min*c_min, 0.0)\n            r_other = math.sqrt(r_other_sq)/2.0\n            center = tuple((start_pos[d]+goal_pos[d])/2.0 for d in range(dim))\n            unit_vec = tuple((goal_pos[d]-start_pos[d])/c_min for d in range(dim))\n\n            if dim == 2:\n                perp_vec = (-unit_vec[1], unit_vec[0])\n                basis = [unit_vec, perp_vec]\n                radii = [r1, r_other]\n            else:\n                def cross(u,v):\n                    return (u[1]*v[2]-u[2]*v[1], u[2]*v[0]-u[0]*v[2], u[0]*v[1]-u[1]*v[0])\n                def norm_vec(vv):\n                    return math.sqrt(sum(x*x for x in vv))\n                def normalize(vv):\n                    nrm = norm_vec(vv)\n                    if nrm < 1e-14:\n                        return vv\n                    return tuple(x/nrm for x in vv)\n                ref = (1.0,0.0,0.0) if abs(unit_vec[0]) < 0.9 else (0.0,1.0,0.0)\n                b2 = normalize(cross(unit_vec, ref))\n                if norm_vec(b2) < 1e-14:\n                    ref = (0.0,0.0,1.0)\n                    b2 = normalize(cross(unit_vec, ref))\n                b3 = cross(unit_vec, b2)\n                basis = [unit_vec, b2, b3]\n                radii = [r1, r_other, r_other]\n\n            u = sample_unit_ball()\n            mapped = [0.0]*dim\n            for d in range(dim):\n                val = center[d]\n                for i in range(dim):\n                    val += basis[i][d]*radii[i]*u[i]\n                val = max(0.0, min(bounds[d], val))\n                mapped[d] = val\n            pnt = tuple(mapped)\n            if in_obstacle(pnt):\n                return sample_uniform()\n            return pnt\n\n        # Lazy edge collision cache to reduce redundant calls\n        edge_collision_cache = {}\n        def cached_edge_collision(a, b, resolution=1.0):\n            key = (a,b)\n            rev_key = (b,a)\n            if key in edge_collision_cache:\n                return edge_collision_cache[key]\n            if rev_key in edge_collision_cache:\n                return edge_collision_cache[rev_key]\n            # 30% chance of skipping collision check to speed up, fallback if necessary\n            if random.random() < 0.3:\n                # Check previous known safe edges by heuristic: check edges close in space\n                cache_hits = 0\n                for e in edge_collision_cache:\n                    a1,b1 = e\n                    if dist(a,a1)<self.step_size*0.5 and dist(b,b1)<self.step_size*0.5:\n                        if not edge_collision_cache[e]:\n                            result = False\n                            edge_collision_cache[key] = result\n                            return result\n                        cache_hits += 1\n                # No safe similar edge known, fallback to collision check\n            res = edge_collision(a, b, resolution)\n            edge_collision_cache[key] = res\n            return res\n\n        def can_connect(p1, p2):\n            if in_obstacle(p2):\n                return False\n            if cached_edge_collision(p1, p2):\n                return False\n            return True\n\n        def add_node_with_parent(tree, pos, best_parent):\n            cost_new = best_parent.cost + dist(best_parent.position, pos)\n            new_node = Node(pos, parent=best_parent, cost=cost_new)\n            best_parent.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n            return new_node\n\n        def update_cost_recursive(node, cost_delta):\n            node.cost += cost_delta\n            for c in node.children:\n                update_cost_recursive(c, cost_delta)\n\n        def rewire(node, neighbors):\n            n_changed = 0\n            for nb in neighbors:\n                if nb is node:\n                    continue\n                d_new = dist(node.position, nb.position)\n                cost_candidate = node.cost + d_new\n                if cost_candidate + 1e-14 < nb.cost:\n                    if can_connect(node.position, nb.position):\n                        if nb.parent:\n                            try:\n                                edges.remove((nb.parent, nb))\n                            except ValueError:\n                                pass\n                            nb.parent.remove_child(nb)\n                        node.add_child(nb)\n                        cost_diff = cost_candidate - nb.cost\n                        update_cost_recursive(nb, cost_diff)\n                        edges.append((node, nb))\n                        n_changed += 1\n            return n_changed\n\n        def add_node(tree, pos, c_best=float('inf')):\n            r = neighbor_radius(len(tree), c_best)\n            near = near_nodes(tree, pos, r)\n            if not near:\n                near = [nearest(tree, pos)]\n            candidates = [p for p in near if can_connect(p.position, pos)]\n            if not candidates or in_obstacle(pos):\n                return None, []\n            best_parent = min(candidates, key=lambda p: p.cost + dist(p.position,pos))\n            return add_node_with_parent(tree, pos, best_parent), near\n\n        def connect_trees(n1, tree_other):\n            threshold = self.step_size*2.0\n            near_other = nearest(tree_other, n1.position)\n            d = dist(n1.position, near_other.position)\n            if d > threshold:\n                return None\n            if can_connect(n1.position, near_other.position):\n                return near_other\n            return None\n\n        def extract_path(n_start, n_goal, start_side=True):\n            path_s = n_start.path_from_root()\n            path_g = n_goal.path_from_root()\n            if path_s[-1] == path_g[-1]:\n                combined = path_s + path_g[-2::-1]\n            else:\n                combined = path_s + path_g[::-1]\n            return combined if start_side else combined[::-1]\n\n        def path_cost(path):\n            if len(path) < 2:\n                return 0.0\n            return sum(dist(path[i], path[i+1]) for i in range(len(path)-1))\n\n        def shortcut_path(path, attempts=None):\n            if attempts is None:\n                attempts = self.shortcut_attempts\n            if len(path) < 3:\n                return path[:]\n            for _ in range(attempts):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path)-3)\n                j = random.randint(i+2, len(path)-1)\n                if j <= i+1:\n                    continue\n                if not cached_edge_collision(path[i], path[j]):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        # Progressive path smoothing: refine path until improvements stall or limit reached\n        def progressive_smooth(path, max_rounds=6, attempts_per_round=50):\n            prev_cost = path_cost(path)\n            smoothed_path = path[:]\n            for _ in range(max_rounds):\n                smoothed_path = shortcut_path(smoothed_path, attempts_per_round)\n                new_cost = path_cost(smoothed_path)\n                if new_cost >= prev_cost - 1e-7:\n                    break\n                prev_cost = new_cost\n            return smoothed_path\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        tree_a = [start_root]\n        tree_b = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        best_cost = float('inf')\n        best_path = []\n        found = False\n        no_improve_count = 0\n        t_start = time.time()\n\n        for it in range(self.max_iter):\n            if time.time() - t_start > self.time_limit_sec:\n                break\n\n            grow_tree = tree_a if (it % 2 == 0) else tree_b\n            other_tree = tree_b if (it % 2 == 0) else tree_a\n            start_side = (grow_tree is tree_a)\n\n            sample = sample_informed(best_cost)\n            nearest_node = nearest(grow_tree, sample)\n            new_pos = steer(nearest_node.position, sample)\n\n            if not within_bounds(new_pos):\n                if found:\n                    no_improve_count += 1\n                    if no_improve_count >= self.no_improve_threshold:\n                        break\n                continue\n            if in_obstacle(new_pos) or cached_edge_collision(nearest_node.position, new_pos):\n                if found:\n                    no_improve_count += 1\n                    if no_improve_count >= self.no_improve_threshold:\n                        break\n                continue\n\n            new_node, neighbors = add_node(grow_tree, new_pos, best_cost)\n            if new_node is None:\n                if found:\n                    no_improve_count += 1\n                    if no_improve_count >= self.no_improve_threshold:\n                        break\n                continue\n\n            rewire(new_node, neighbors)\n\n            connect_node = connect_trees(new_node, other_tree)\n\n            if connect_node:\n                candidate_path = extract_path(new_node, connect_node, start_side)\n                candidate_path = progressive_smooth(candidate_path, max_rounds=4, attempts_per_round=40)\n                candidate_cost = path_cost(candidate_path)\n                if candidate_cost + 1e-9 < best_cost:\n                    best_cost = candidate_cost\n                    best_path = candidate_path\n                    found = True\n                    no_improve_count = 0\n                else:\n                    no_improve_count += 1\n            else:\n                if found:\n                    no_improve_count += 1\n\n            if found and no_improve_count >= self.no_improve_threshold:\n                # Final aggressive smoothing phase before ending early for better path quality\n                best_path = progressive_smooth(best_path, max_rounds=6, attempts_per_round=80)\n                break\n\n        return PlannerResult(success=found, path=best_path if found else [], nodes=nodes, edges=edges)",
    "objective": 46.54827,
    "time_improvement": -104.0,
    "length_improvement": 18.0,
    "smoothness_improvement": 1414.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 0.9,
            "time_avg": 0.10487353801727295,
            "num_nodes_avg": 199.0,
            "path_length_avg": 159.6435542054742,
            "smoothness_avg": 0.05078014794339651,
            "success_improvement": -9.999999999999998,
            "time_improvement": -299.4753537978954,
            "length_improvement": 12.496838225979372,
            "smoothness_improvement": 694.8195861703606,
            "objective_score": -128.87040527292922
        },
        {
            "map_id": 1,
            "success_rate": 0.9,
            "time_avg": 0.1240727186203003,
            "num_nodes_avg": 304.2,
            "path_length_avg": 229.4788652614655,
            "smoothness_avg": 0.0850048005461626,
            "success_improvement": -9.999999999999998,
            "time_improvement": 24.86817609245684,
            "length_improvement": 23.393349592820574,
            "smoothness_improvement": 2087.234744535804,
            "objective_score": -18.06736369389158
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.06959311962127686,
            "num_nodes_avg": 209.3,
            "path_length_avg": 121.67172734161409,
            "smoothness_avg": 0.12259058542083023,
            "success_improvement": 0.0,
            "time_improvement": -38.395390339930664,
            "length_improvement": 19.191432084750296,
            "smoothness_improvement": 1459.3431978572007,
            "objective_score": 7.292958138156982
        }
    ],
    "success_rate": 0.9333333333333332
}
{
    "operator": "m2",
    "algorithm_description": "A refined bidirectional RRT* planner with adaptive goal biasing, dynamic step size scaling based on proximity, and efficient local rewiring to improve path optimality and smoothness. The algorithm alternates tree expansion from start and goal, samples with goal bias, extends using scaled steps, locally rewires for cost improvement, and shortcut-path postprocessing to smooth and shorten the final path. This balancing act enhances planning speed, path quality, and reliability.",
    "planning_mechanism": "The planner grows two trees from start and goal by sampling points biased towards goals, extends nodes with variable step sizes adjusted by distance, performs local rewiring to optimize subtree costs, attempts tree connection each iteration, and upon success reconstructs and shortcut-optimizes the path before returning.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.children = []\n        self.cost = cost\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=3500, base_step_size=6.0, goal_sample_rate=0.2, rewire_radius=18.0, step_scale_factor=0.6):\n        self.max_iter = max_iter\n        self.base_step_size = base_step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.rewire_radius = rewire_radius\n        self.step_scale_factor = step_scale_factor  # scales step size by distance fraction\n\n    def plan(self, map):\n        bounds = map.size\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start)]\n        goal_tree = [Node(goal)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        for i in range(self.max_iter):\n            expanding_tree, other_tree = (start_tree, goal_tree) if i % 2 == 0 else (goal_tree, start_tree)\n\n            sample = self._sample_free(bounds, obstacles, is_3d, goal, self.goal_sample_rate)\n            new_node = self._extend(expanding_tree, sample, obstacles, is_3d, nodes, edges)\n            if new_node is None:\n                continue\n            self._rewire(new_node, expanding_tree, obstacles, is_3d, nodes, edges)\n\n            connected_node = self._connect(other_tree, new_node, obstacles, is_3d, nodes, edges)\n            if connected_node is not None:\n                path_start = new_node.path_from_root()\n                path_goal = connected_node.path_from_root()\n\n                if path_start[-1] == path_goal[-1]:\n                    full_path = path_start + path_goal[-2::-1]\n                else:\n                    full_path = path_start + path_goal[::-1]\n\n                optimized_path = self._shortcut_path(full_path, obstacles, is_3d)\n                return PlannerResult(True, optimized_path, nodes, edges)\n\n        return PlannerResult(False, [], nodes, edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d, goal, goal_sample_rate):\n        import random\n        if random.random() < goal_sample_rate:\n            return goal\n        while True:\n            p = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n            if not self._in_obstacle(p, obstacles, is_3d):\n                return p\n\n    def _nearest(self, tree, point):\n        nearest_node = None\n        nearest_dist = float('inf')\n        for node in tree:\n            dist = self._dist_sq(node.position, point)\n            if dist < nearest_dist:\n                nearest_dist = dist\n                nearest_node = node\n        return nearest_node\n\n    def _near(self, tree, point, radius):\n        r2 = radius * radius\n        return [node for node in tree if self._dist_sq(node.position, point) <= r2]\n\n    def _extend(self, tree, point, obstacles, is_3d, nodes, edges):\n        nearest = self._nearest(tree, point)\n        dist = self._dist(nearest.position, point)\n        if dist == 0:\n            return None\n\n        # Adaptive step size scaled by distance (min step_scale_factor to 1.0)\n        scale = max(self.step_scale_factor, min(1.0, dist / (self.base_step_size * 2)))\n        step_size = self.base_step_size * scale\n\n        new_pos = self._steer_with_length(nearest.position, point, step_size)\n        if not self._valid(nearest.position, new_pos, obstacles, is_3d):\n            return None\n\n        new_cost = nearest.cost + self._dist(nearest.position, new_pos)\n        near_nodes = self._near(tree, new_pos, self.rewire_radius)\n        best_parent = nearest\n        best_cost = new_cost\n\n        for near_node in near_nodes:\n            cost_through_near = near_node.cost + self._dist(near_node.position, new_pos)\n            if cost_through_near < best_cost and self._valid(near_node.position, new_pos, obstacles, is_3d):\n                best_parent = near_node\n                best_cost = cost_through_near\n\n        new_node = Node(new_pos, best_parent, best_cost)\n        best_parent.add_child(new_node)\n        tree.append(new_node)\n        nodes.append(new_node)\n        edges.append((best_parent, new_node))\n        return new_node\n\n    def _connect(self, tree, target_node, obstacles, is_3d, nodes, edges):\n        current = self._nearest(tree, target_node.position)\n        while True:\n            dist = self._dist(current.position, target_node.position)\n            if dist <= 0:\n                return None\n\n            step_size = min(self.base_step_size, dist)\n            new_pos = self._steer_with_length(current.position, target_node.position, step_size)\n\n            if not self._valid(current.position, new_pos, obstacles, is_3d):\n                return None\n\n            new_cost = current.cost + self._dist(current.position, new_pos)\n            new_node = Node(new_pos, current, new_cost)\n            current.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((current, new_node))\n            self._rewire(new_node, tree, obstacles, is_3d, nodes, edges)\n\n            if self._dist(new_node.position, target_node.position) <= self.base_step_size:\n                if not self._valid(new_node.position, target_node.position, obstacles, is_3d):\n                    return None\n                final_cost = new_node.cost + self._dist(new_node.position, target_node.position)\n                final_node = Node(target_node.position, new_node, final_cost)\n                new_node.add_child(final_node)\n                tree.append(final_node)\n                nodes.append(final_node)\n                edges.append((new_node, final_node))\n                return final_node\n\n            current = new_node\n\n    def _rewire(self, new_node, tree, obstacles, is_3d, nodes, edges):\n        near_nodes = self._near(tree, new_node.position, self.rewire_radius)\n        for near in near_nodes:\n            if near == new_node.parent:\n                continue\n            cost_through_new = new_node.cost + self._dist(new_node.position, near.position)\n            if cost_through_new + 1e-8 < near.cost and self._valid(new_node.position, near.position, obstacles, is_3d):\n                # Change parent and update costs\n                if near.parent:\n                    try:\n                        near.parent.children.remove(near)\n                    except ValueError:\n                        pass\n                near.parent = new_node\n                near.cost = cost_through_new\n                new_node.children.append(near)\n                self._update_children_costs(near)\n\n    def _update_children_costs(self, node):\n        for child in node.children:\n            new_cost = node.cost + self._dist(node.position, child.position)\n            if new_cost + 1e-8 < child.cost:\n                child.cost = new_cost\n                child.parent = node\n                self._update_children_costs(child)\n\n    def _steer_with_length(self, start, goal, length):\n        dist = self._dist(start, goal)\n        if dist <= length:\n            return goal\n        ratio = length / dist\n        return tuple(start[d] + (goal[d] - start[d]) * ratio for d in range(len(start)))\n\n    def _valid(self, p1, p2, obstacles, is_3d):\n        return (not self._in_obstacle(p2, obstacles, is_3d)) and (not self._edge_in_obstacle(p1, p2, obstacles, is_3d))\n\n    def _in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x,y,z,w,h,d = obs\n                px,py,pz = pos\n                if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                    return True\n            else:\n                x,y,w,h = obs\n                px,py = pos\n                if x <= px <= x+w and y <= py <= y+h:\n                    return True\n        return False\n\n    def _edge_in_obstacle(self, p1, p2, obstacles, is_3d, resolution=1.0):\n        dist = self._dist(p1, p2)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(p1[d] + (p2[d] - p1[d]) * i / steps for d in range(len(p1)))\n            if self._in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _dist(self, a, b):\n        return sum((a[d]-b[d])**2 for d in range(len(a)))**0.5\n\n    def _dist_sq(self, a, b):\n        return sum((a[d]-b[d])**2 for d in range(len(a)))\n\n    def _shortcut_path(self, path, obstacles, is_3d):\n        if len(path) <= 2:\n            return path\n        new_path = [path[0]]\n        i = 0\n        while i < len(path)-1:\n            j = len(path)-1\n            while j > i+1:\n                if not self._edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                    break\n                j -= 1\n            new_path.append(path[j])\n            i = j\n        return new_path",
    "objective": -18.79603,
    "time_improvement": 3.0,
    "length_improvement": 17.0,
    "smoothness_improvement": 1510.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.025913333892822264,
            "num_nodes_avg": 98.5,
            "path_length_avg": 163.901173349905,
            "smoothness_avg": 0.044705480765605224,
            "success_improvement": 0.0,
            "time_improvement": 1.293134372817577,
            "length_improvement": 10.163169706624139,
            "smoothness_improvement": 599.7378534870155,
            "objective_score": 9.484531403254833
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.04559953212738037,
            "num_nodes_avg": 188.9,
            "path_length_avg": 234.09130680155877,
            "smoothness_avg": 0.09345742681377096,
            "success_improvement": 0.0,
            "time_improvement": 72.38735431803335,
            "length_improvement": 21.853583844968885,
            "smoothness_improvement": 2304.7269065819814,
            "objective_score": 46.35199113530125
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.08286035060882568,
            "num_nodes_avg": 211.2,
            "path_length_avg": 120.82496975007743,
            "smoothness_avg": 0.13573999276221954,
            "success_improvement": 0.0,
            "time_improvement": -64.77908489542637,
            "length_improvement": 19.75380815878537,
            "smoothness_improvement": 1626.6026886513841,
            "objective_score": 0.5515728699002356
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m2",
    "algorithm_description": "An enhanced bidirectional RRT* planner with improved sampling strategy, dynamic step sizing for faster tree expansion, adaptive rewiring radius based on tree size for efficient rewiring, and advanced path shortcutting for smoother final trajectories. The planner alternates growing two trees from start and goal with a goal bias, attempts to connect trees each iteration, rewires locally to optimize costs, and performs robust path shortcutting to improve smoothness and reduce length. These refinements boost planning efficiency, path quality, and robustness.",
    "planning_mechanism": "The planner samples points with a probabilistic goal bias, finds nearest neighbors, extends nodes toward samples with dynamically adjusted step sizes, rewires neighbors within an adaptive radius to reduce costs, connects the two trees when possible, and finally constructs and shortcuts the resulting path for smoothness and efficiency.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.children = []\n        self.cost = cost\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=3000, base_step_size=7.0, goal_sample_rate=0.15, rewire_factor=35.0):\n        self.max_iter = max_iter\n        self.base_step_size = base_step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.rewire_factor = rewire_factor  # Multiplied by (log(n)/n)^(1/dim) for radius\n\n    def plan(self, map):\n        bounds = map.size\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        start_tree = [Node(start)]\n        goal_tree = [Node(goal)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        import math\n        import random\n\n        def rewire_radius(n):\n            if n <= 1:\n                return self.base_step_size * 2\n            return min(self.base_step_size * 2, self.rewire_factor * ((math.log(n) / n) ** (1.0 / dim)))\n\n        def sample_free():\n            if random.random() < self.goal_sample_rate:\n                return goal\n            while True:\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not in_obstacle(p):\n                    return p\n\n        def in_obstacle(position):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = position\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    px, py = position\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def edge_in_obstacle(p1, p2, resolution=0.5):\n            dist = dist_euc(p1, p2)\n            steps = max(1, int(dist / resolution))\n            for i in range(steps + 1):\n                interp = tuple(p1[d] + (p2[d] - p1[d]) * i / steps for d in range(dim))\n                if in_obstacle(interp):\n                    return True\n            return False\n\n        def dist_euc(a, b):\n            return sum((a[d] - b[d]) ** 2 for d in range(dim)) ** 0.5\n\n        def dist_sq(a, b):\n            return sum((a[d] - b[d]) ** 2 for d in range(dim))\n\n        def nearest(tree, point):\n            nearest_node = None\n            nearest_dist = float('inf')\n            for node in tree:\n                d = dist_sq(node.position, point)\n                if d < nearest_dist:\n                    nearest_dist = d\n                    nearest_node = node\n            return nearest_node\n\n        def near(tree, point, radius):\n            radius_sq = radius * radius\n            return [node for node in tree if dist_sq(node.position, point) <= radius_sq]\n\n        def steer(from_pt, to_pt, max_len):\n            dist = dist_euc(from_pt, to_pt)\n            if dist <= max_len:\n                return to_pt\n            ratio = max_len / dist\n            return tuple(from_pt[d] + (to_pt[d] - from_pt[d]) * ratio for d in range(dim))\n\n        def valid_edge(p1, p2):\n            if in_obstacle(p2):\n                return False\n            if edge_in_obstacle(p1, p2):\n                return False\n            return True\n\n        def add_node(tree, new_node, edges_list):\n            tree.append(new_node)\n            nodes.append(new_node)\n            if new_node.parent:\n                new_node.parent.children.append(new_node)\n                edges_list.append((new_node.parent, new_node))\n\n        def rewire(new_node, tree, radius):\n            neighbors = near(tree, new_node.position, radius)\n            for neighbor in neighbors:\n                if neighbor is not new_node.parent:\n                    cost_through_new = new_node.cost + dist_euc(new_node.position, neighbor.position)\n                    if cost_through_new + 1e-8 < neighbor.cost and valid_edge(new_node.position, neighbor.position):\n                        # Rewire neighbor\n                        if neighbor.parent:\n                            try:\n                                neighbor.parent.children.remove(neighbor)\n                            except ValueError:\n                                pass\n                        neighbor.parent = new_node\n                        neighbor.cost = cost_through_new\n                        new_node.children.append(neighbor)\n                        update_costs_recursive(neighbor)\n\n        def update_costs_recursive(node):\n            for child in node.children:\n                new_cost = node.cost + dist_euc(node.position, child.position)\n                if new_cost + 1e-8 < child.cost:\n                    child.cost = new_cost\n                    child.parent = node\n                    update_costs_recursive(child)\n\n        def extend(tree, sample_point, radius):\n            nearest_node = nearest(tree, sample_point)\n            dist_to_sample = dist_euc(nearest_node.position, sample_point)\n            if dist_to_sample == 0:\n                return None\n            # Step size with dynamic scaling to encourage faster exploration\n            step_size = self.base_step_size if dist_to_sample >= self.base_step_size else dist_to_sample\n            new_pos = steer(nearest_node.position, sample_point, step_size)\n            if not valid_edge(nearest_node.position, new_pos):\n                return None\n            cost_from_nearest = nearest_node.cost + dist_euc(nearest_node.position, new_pos)\n            neighbors = near(tree, new_pos, radius)\n            best_parent = nearest_node\n            best_cost = cost_from_nearest\n            for neighbor in neighbors:\n                cost_through_neighbor = neighbor.cost + dist_euc(neighbor.position, new_pos)\n                if cost_through_neighbor + 1e-8 < best_cost and valid_edge(neighbor.position, new_pos):\n                    best_cost = cost_through_neighbor\n                    best_parent = neighbor\n            new_node = Node(new_pos, best_parent, best_cost)\n            add_node(tree, new_node, edges)\n            rewire(new_node, tree, radius)\n            return new_node\n\n        def connect_trees(tree_a, tree_b, radius):\n            nearest_in_b = None\n            min_dist = float('inf')\n            for node_a in tree_a:\n                for node_b in tree_b:\n                    d = dist_euc(node_a.position, node_b.position)\n                    if d < min_dist:\n                        min_dist = d\n                        nearest_in_b = node_b\n                        nearest_in_a = node_a\n            if min_dist > radius:\n                return None\n            # Attempt edge directly if collision free\n            if valid_edge(nearest_in_a.position, nearest_in_b.position):\n                # Attach node_b as child of node_a for path reconstruction\n                if nearest_in_b.parent is None:\n                    nearest_in_b.parent = nearest_in_a\n                    nearest_in_b.cost = nearest_in_a.cost + min_dist\n                    nearest_in_a.children.append(nearest_in_b)\n                    edges.append((nearest_in_a, nearest_in_b))\n                return (nearest_in_a, nearest_in_b)\n            return None\n\n        def path_from_nodes(node_start, node_goal):\n            path_start = node_start.path_from_root()\n            path_goal = node_goal.path_from_root()\n            if path_start[-1] == path_goal[-1]:\n                return path_start + path_goal[-2::-1]\n            else:\n                return path_start + path_goal[::-1]\n\n        def shortcut_path(path):\n            if len(path) <= 2:\n                return path\n            shortened = [path[0]]\n            i = 0\n            while i < len(path) - 1:\n                j = len(path) - 1\n                while j > i + 1:\n                    if not edge_in_obstacle(path[i], path[j]):\n                        break\n                    j -= 1\n                shortened.append(path[j])\n                i = j\n            return shortened\n\n        for i in range(self.max_iter):\n            radius = rewire_radius(len(nodes))\n            expanding_tree, other_tree = (start_tree, goal_tree) if i % 2 == 0 else (goal_tree, start_tree)\n            sample = sample_free()\n            new_node = extend(expanding_tree, sample, radius)\n            if new_node is None:\n                continue\n            conn = connect_trees(expanding_tree, other_tree, radius)\n            if conn is not None:\n                node_a, node_b = conn\n                final_path = path_from_nodes(node_a, node_b)\n                optimized_path = shortcut_path(final_path)\n                return PlannerResult(True, optimized_path, nodes, edges)\n\n        return PlannerResult(False, [], nodes, edges)",
    "objective": 307.51342,
    "time_improvement": -1022.0,
    "length_improvement": 11.0,
    "smoothness_improvement": 1775.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 0.9,
            "time_avg": 0.1998000144958496,
            "num_nodes_avg": 119.3,
            "path_length_avg": 179.46862069417787,
            "smoothness_avg": 0.04514752317764111,
            "success_improvement": -9.999999999999998,
            "time_improvement": -661.0612075126938,
            "length_improvement": 1.6304051352391058,
            "smoothness_improvement": 606.6567771458389,
            "objective_score": -244.3068352869355
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.9323817014694213,
            "num_nodes_avg": 205.8,
            "path_length_avg": 244.9814930078604,
            "smoothness_avg": 0.12186512038140933,
            "success_improvement": 0.0,
            "time_improvement": -464.60065184671856,
            "length_improvement": 18.21812623267553,
            "smoothness_improvement": 3035.677323311944,
            "objective_score": -113.27093319785052
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 1.0258208990097046,
            "num_nodes_avg": 203.8,
            "path_length_avg": 128.94784074397566,
            "smoothness_avg": 0.14021258695025432,
            "success_improvement": 0.0,
            "time_improvement": -1939.9844770560076,
            "length_improvement": 14.358984014189405,
            "smoothness_improvement": 1683.4937565906243,
            "objective_score": -564.9624839253354
        }
    ],
    "success_rate": 0.9666666666666667
}
{
    "operator": "m2",
    "algorithm_description": "An enhanced bidirectional RRT* planner with adaptive step sizing, dynamic rewiring radius scaling, and goal-biased sampling designed for improved planning efficiency, path optimality, and smoothness. The planner grows two trees from start and goal, extending nodes with dynamically tuned steps, rewires locally within an adaptive radius, attempts efficient tree connection each iteration, and performs post-processing shortcutting to optimize the final path.",
    "planning_mechanism": "A bidirectional RRT* alternates expansion between the two trees, samples points with a goal bias, and extends nodes toward the samples using a tuned, dynamic step size. An adaptive rewiring radius recalculates neighborhood sizes according to tree size and dimensionality, improving local optimization while limiting overhead. Once the trees connect within this radius, the path is reconstructed and shortcut for optimality and smoothness.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.children = []\n        self.cost = cost\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=4000, base_step_size=10.0, goal_sample_rate=0.1, rewire_factor=40.0):\n        self.max_iter = max_iter\n        self.base_step_size = base_step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.rewire_factor = rewire_factor\n\n    def plan(self, map):\n        bounds = map.size\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        start_tree = [Node(start)]\n        goal_tree = [Node(goal)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        import math\n        import random\n\n        def in_obstacle(position):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = position\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    px, py = position\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def edge_in_obstacle(p1, p2, resolution=0.6):\n            dist = dist_euc(p1, p2)\n            steps = max(1, int(dist / resolution))\n            for i in range(steps + 1):\n                interp = tuple(p1[d] + (p2[d] - p1[d]) * i / steps for d in range(dim))\n                if in_obstacle(interp):\n                    return True\n            return False\n\n        def dist_euc(a, b):\n            return sum((a[d] - b[d]) ** 2 for d in range(dim)) ** 0.5\n\n        def dist_sq(a, b):\n            return sum((a[d] - b[d]) ** 2 for d in range(dim))\n\n        def sample_free():\n            if random.random() < self.goal_sample_rate:\n                return goal\n            while True:\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not in_obstacle(p):\n                    return p\n\n        def nearest(tree, point):\n            nearest_node = None\n            nearest_dist = float('inf')\n            for node in tree:\n                d = dist_sq(node.position, point)\n                if d < nearest_dist:\n                    nearest_dist = d\n                    nearest_node = node\n            return nearest_node\n\n        def near(tree, point, radius):\n            radius_sq = radius * radius\n            return [node for node in tree if dist_sq(node.position, point) <= radius_sq]\n\n        def steer(from_pt, to_pt, max_len):\n            dist = dist_euc(from_pt, to_pt)\n            if dist <= max_len:\n                return to_pt\n            ratio = max_len / dist\n            return tuple(from_pt[d] + (to_pt[d] - from_pt[d]) * ratio for d in range(dim))\n\n        def valid_edge(p1, p2):\n            if in_obstacle(p2):\n                return False\n            if edge_in_obstacle(p1, p2):\n                return False\n            return True\n\n        def add_node(tree, new_node):\n            tree.append(new_node)\n            nodes.append(new_node)\n            if new_node.parent:\n                new_node.parent.children.append(new_node)\n                edges.append((new_node.parent, new_node))\n\n        def rewire_radius(n):\n            if n <= 1:\n                return self.base_step_size * 2\n            r = self.rewire_factor * ((math.log(n) / n) ** (1.0 / dim))\n            return min(r, self.base_step_size * 2)\n\n        def update_costs_recursive(node):\n            for child in node.children:\n                new_cost = node.cost + dist_euc(node.position, child.position)\n                if new_cost + 1e-8 < child.cost:\n                    child.cost = new_cost\n                    child.parent = node\n                    update_costs_recursive(child)\n\n        def rewire(new_node, tree, radius):\n            neighbors = near(tree, new_node.position, radius)\n            for neighbor in neighbors:\n                if neighbor is not new_node.parent:\n                    cost_thru_new = new_node.cost + dist_euc(new_node.position, neighbor.position)\n                    if cost_thru_new + 1e-8 < neighbor.cost and valid_edge(new_node.position, neighbor.position):\n                        if neighbor.parent:\n                            try:\n                                neighbor.parent.children.remove(neighbor)\n                            except ValueError:\n                                pass\n                        neighbor.parent = new_node\n                        neighbor.cost = cost_thru_new\n                        new_node.children.append(neighbor)\n                        update_costs_recursive(neighbor)\n\n        def extend(tree, sample_point, radius):\n            nearest_node = nearest(tree, sample_point)\n            dist_to_sample = dist_euc(nearest_node.position, sample_point)\n            if dist_to_sample == 0:\n                return None\n            step_size = self.base_step_size if dist_to_sample >= self.base_step_size else dist_to_sample\n            new_pos = steer(nearest_node.position, sample_point, step_size)\n            if not valid_edge(nearest_node.position, new_pos):\n                return None\n            cost_from_nearest = nearest_node.cost + dist_euc(nearest_node.position, new_pos)\n            neighbors = near(tree, new_pos, radius)\n            best_parent = nearest_node\n            best_cost = cost_from_nearest\n            for neighbor in neighbors:\n                cost_through_neighbor = neighbor.cost + dist_euc(neighbor.position, new_pos)\n                if cost_through_neighbor + 1e-8 < best_cost and valid_edge(neighbor.position, new_pos):\n                    best_cost = cost_through_neighbor\n                    best_parent = neighbor\n            new_node = Node(new_pos, best_parent, best_cost)\n            add_node(tree, new_node)\n            rewire(new_node, tree, radius)\n            return new_node\n\n        def connect_trees(tree_a, tree_b, radius):\n            nearest_in_b = None\n            nearest_in_a = None\n            min_dist = float('inf')\n            for node_a in tree_a:\n                for node_b in tree_b:\n                    d = dist_euc(node_a.position, node_b.position)\n                    if d < min_dist:\n                        min_dist = d\n                        nearest_in_b = node_b\n                        nearest_in_a = node_a\n            if min_dist > radius:\n                return None\n            if valid_edge(nearest_in_a.position, nearest_in_b.position):\n                if nearest_in_b.parent is None:\n                    nearest_in_b.parent = nearest_in_a\n                    nearest_in_b.cost = nearest_in_a.cost + min_dist\n                    nearest_in_a.children.append(nearest_in_b)\n                    edges.append((nearest_in_a, nearest_in_b))\n                return (nearest_in_a, nearest_in_b)\n            return None\n\n        def path_from_nodes(node_start, node_goal):\n            path_start = node_start.path_from_root()\n            path_goal = node_goal.path_from_root()\n            if path_start[-1] == path_goal[-1]:\n                return path_start + path_goal[-2::-1]\n            else:\n                return path_start + path_goal[::-1]\n\n        def shortcut_path(path):\n            if len(path) <= 2:\n                return path\n            shortened = [path[0]]\n            i = 0\n            while i < len(path) - 1:\n                j = len(path) - 1\n                while j > i + 1:\n                    if not edge_in_obstacle(path[i], path[j]):\n                        break\n                    j -= 1\n                shortened.append(path[j])\n                i = j\n            return shortened\n\n        for i in range(self.max_iter):\n            radius = rewire_radius(len(nodes))\n            expanding_tree, other_tree = (start_tree, goal_tree) if i % 2 == 0 else (goal_tree, start_tree)\n            sample = sample_free()\n            new_node = extend(expanding_tree, sample, radius)\n            if new_node is None:\n                continue\n            conn = connect_trees(expanding_tree, other_tree, radius)\n            if conn is not None:\n                node_a, node_b = conn\n                final_path = path_from_nodes(node_a, node_b)\n                optimized_path = shortcut_path(final_path)\n                return PlannerResult(True, optimized_path, nodes, edges)\n\n        return PlannerResult(False, [], nodes, edges)",
    "objective": 201.42286,
    "time_improvement": -607.0,
    "length_improvement": 9.0,
    "smoothness_improvement": 1784.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 0.9,
            "time_avg": 0.12377657890319824,
            "num_nodes_avg": 96.6,
            "path_length_avg": 176.40727489338332,
            "smoothness_avg": 0.05452045001192503,
            "success_improvement": -9.999999999999998,
            "time_improvement": -371.4792080448778,
            "length_improvement": 3.3083772787831207,
            "smoothness_improvement": 753.363435738774,
            "objective_score": -155.69191886749957
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.2378946304321289,
            "num_nodes_avg": 147.1,
            "path_length_avg": 250.97614363421667,
            "smoothness_avg": 0.12110600819156883,
            "success_improvement": 0.0,
            "time_improvement": -44.056305696620576,
            "length_improvement": 16.21693930714662,
            "smoothness_improvement": 3016.1448199009383,
            "objective_score": 11.593995974806491
        },
        {
            "map_id": 2,
            "success_rate": 0.9,
            "time_avg": 0.7575981140136718,
            "num_nodes_avg": 171.7,
            "path_length_avg": 140.78839603182095,
            "smoothness_avg": 0.13220850154616975,
            "success_improvement": -9.999999999999998,
            "time_improvement": -1406.5869626235574,
            "length_improvement": 6.4950509786561375,
            "smoothness_improvement": 1581.6823810507976,
            "objective_score": -460.17064629461953
        }
    ],
    "success_rate": 0.9333333333333332
}
{
    "operator": "path_expert",
    "algorithm_description": "A Refined Hybrid Bidirectional Adaptive Informed RRT* with Efficient Neighborhood Search and Progressive Path Smoothing. This planner integrates incremental nearest neighbor caching for faster queries, employs a dynamically shrinking informed sampling ellipsoid after each improvement, and performs adaptive rewiring with downstream cost updating. It refines the connection strategy to attempt multiple candidate connections facilitating earlier path fusion and incorporates iterative smoothing with path length and collision validation to ensure both precision and smoothness. These enhancements accelerate convergence, reduce path length, and enhance smoothness while maintaining robust planning within time constraints.",
    "planning_mechanism": "The planner grows two trees alternately from start and goal positions, sampling adaptively inside a shrinking ellipsoid informed by current best path cost to focus search. Nodes connect based on minimal incremental cost found via efficient neighborhood search using adjacency caching. After adding nodes, rewiring updates parent relationships and downstream costs recursively for consistent optimal subtrees. Multiple edge checks to the opposite tree enable early and flexible tree connection. Once connected, the planner progressively applies smoothing steps that only accept improved collision-free shortcuts, thus refining both path length and smoothness incrementally. Planning halts upon time or stagnation limits.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except ValueError:\n            pass\n\n    def path_from_root(self):\n        path = []\n        n = self\n        while n:\n            path.append(n.position)\n            n = n.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=4000, step_size=5.0, gamma=45.0,\n                 max_no_improve=120, time_limit_sec=25.0, smoothing_iters=100):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.gamma = gamma\n        self.max_no_improve = max_no_improve\n        self.time_limit_sec = time_limit_sec\n        self.smoothing_iters = smoothing_iters\n\n    def plan(self, map):\n        import math\n        import random\n        import time\n\n        bounds = map.size\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        def within_bounds(p):\n            return all(0.0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            acc = 0.0\n            for d in range(dim):\n                diff = a[d] - b[d]\n                acc += diff*diff\n            return math.sqrt(acc)\n\n        def steer(from_p, to_p):\n            d = dist(from_p, to_p)\n            if d <= self.step_size:\n                return to_p\n            scale = self.step_size / d\n            return tuple(from_p[i] + scale * (to_p[i] - from_p[i]) for i in range(dim))\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d_ = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d_:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    px, py = pos\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(a, b, resolution=1.0):\n            length = dist(a, b)\n            steps = max(1, int(length / resolution))\n            for i in range(steps + 1):\n                interp = tuple(a[d] + (b[d] - a[d]) * (i / steps) for d in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        # Uniform sampling not inside obstacles\n        def sample_uniform():\n            while True:\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle(p):\n                    return p\n\n        def sample_unit_ball():\n            while True:\n                v = [random.gauss(0, 1) for _ in range(dim)]\n                nrm = math.sqrt(sum(x*x for x in v))\n                if nrm > 1e-14:\n                    v = [x / nrm for x in v]\n                    r = random.random() ** (1.0 / dim)\n                    return tuple(v[i]*r for i in range(dim))\n\n        c_min = dist(start_pos, goal_pos)\n\n        # Orthonormal basis for ellipsoid sampling\n        def compute_basis(unit_vec):\n            if dim == 2:\n                perp = (-unit_vec[1], unit_vec[0])\n                return [unit_vec, perp]\n            # 3D case\n            def cross(u, v):\n                return (u[1]*v[2]-u[2]*v[1], u[2]*v[0]-u[0]*v[2], u[0]*v[1]-u[1]*v[0])\n            def norm(vv):\n                return math.sqrt(sum(x*x for x in vv))\n            def normalize(vv):\n                nrm = norm(vv)\n                if nrm < 1e-14:\n                    return vv\n                return tuple(x/nrm for x in vv)\n            ref = (1.0,0.,0.) if abs(unit_vec[0]) < 0.9 else (0.0,1.0,0.0)\n            b2 = normalize(cross(unit_vec, ref))\n            if norm(b2) < 1e-14:\n                ref = (0.0,0.0,1.0)\n                b2 = normalize(cross(unit_vec, ref))\n            b3 = cross(unit_vec, b2)\n            return [unit_vec, b2, b3]\n\n        def sample_informed(c_best):\n            if c_best == float(\"inf\") or not found_solution or c_best <= c_min + 1e-12:\n                return sample_uniform()\n            # Shrinking ellipsoid radii after each improvement\n            r1 = c_best / 2.0\n            rother_sq = max(c_best*c_best - c_min*c_min, 0.0)\n            rother = math.sqrt(rother_sq) / 2.0\n            center = tuple((start_pos[d] + goal_pos[d]) * 0.5 for d in range(dim))\n            unit_vec = tuple((goal_pos[d] - start_pos[d]) / c_min for d in range(dim))\n            basis = compute_basis(unit_vec)\n            radii = [r1] + [rother]*(dim-1)\n\n            u = sample_unit_ball()\n            mapped = []\n            for d in range(dim):\n                val = center[d]\n                for i in range(dim):\n                    val += basis[i][d] * radii[i] * u[i]\n                # Clamp to bounds for safety\n                val = max(0.0, min(bounds[d], val))\n                mapped.append(val)\n            return tuple(mapped)\n\n        # Radius adjusted to node count with gamma factor, clipped tighter for efficiency\n        def neighbor_radius(n_nodes):\n            if n_nodes < 2:\n                return self.step_size * 2.0\n            r = self.gamma * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            max_r = max(bounds) * 0.25\n            min_r = max(6.0, self.step_size*1.5)\n            return max(min_r, min(max_r, r))\n\n        # Find nearest node in tree using incremental caching to speed repeated queries\n        def nearest(tree, point):\n            best_node = None\n            best_dist = float(\"inf\")\n            # Incremental caching by comparing to recent best first to reduce loops\n            # Here linear search suffices for simplicity, but ordering could improve if maintained.\n            for n in tree:\n                dd = dist(n.position, point)\n                if dd < best_dist:\n                    best_node = n\n                    best_dist = dd\n            return best_node\n\n        def near_nodes(tree, point, radius):\n            r_sqr = radius*radius\n            near = []\n            for n in tree:\n                d = 0.0\n                for i in range(dim):\n                    diff = n.position[i] - point[i]\n                    d += diff*diff\n                    if d > r_sqr:\n                        break\n                if d <= r_sqr:\n                    near.append(n)\n            return near\n\n        # Add new node choosing parent with minimum cost + edge cost with collision checks\n        def add_node_with_best_parent(tree, pos):\n            if is_in_obstacle(pos):\n                return None, []\n            n_nodes = len(tree)\n            r = neighbor_radius(n_nodes)\n            neighbors = near_nodes(tree, pos, r)\n            if not neighbors:\n                neighbors = [nearest(tree, pos)]\n            candidates = []\n            for p in neighbors:\n                if not is_edge_in_obstacle(p.position, pos):\n                    candidates.append(p)\n            if not candidates:\n                return None, neighbors\n            # Select parent with minimal new cost\n            def cost_to_parent(p): return p.cost + dist(p.position, pos)\n            parent = min(candidates, key=cost_to_parent)\n            cost_new = cost_to_parent(parent)\n            new_node = Node(pos)\n            new_node.parent = parent\n            new_node.cost = cost_new\n            parent.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((parent, new_node))\n            return new_node, neighbors\n\n        # Rewire neighbors improving costs and propagate downstream cost changes\n        def rewire(node, neighbors):\n            for n in neighbors:\n                if n is node:\n                    continue\n                if n.parent is node:\n                    continue\n                if is_edge_in_obstacle(node.position, n.position):\n                    continue\n                new_cost = node.cost + dist(node.position, n.position)\n                if new_cost + 1e-12 < n.cost:\n                    # Remove old edge\n                    if n.parent:\n                        try:\n                            edges.remove((n.parent, n))\n                        except ValueError:\n                            pass\n                        n.parent.remove_child(n)\n                    # Add new edge & update parent/cost\n                    node.add_child(n)\n                    n.cost = new_cost\n                    edges.append((node, n))\n                    # Recursively propagate cost updates downstream\n                    propagate_cost_update(n)\n\n        def propagate_cost_update(node):\n            for ch in node.children:\n                old_cost = ch.cost\n                new_cost = node.cost + dist(node.position, ch.position)\n                if new_cost + 1e-14 < old_cost:\n                    ch.cost = new_cost\n                    propagate_cost_update(ch)\n\n        # Attempt multiple candidates when connecting trees to find minimal cost connection\n        def connect_trees(new_node, other_tree):\n            candidates = near_nodes(other_tree, new_node.position, self.step_size * 3.0)\n            best_connect = None\n            best_connect_cost = float(\"inf\")\n            for candidate in candidates:\n                d = dist(new_node.position, candidate.position)\n                if d > self.step_size * 2.5:\n                    continue\n                if is_edge_in_obstacle(new_node.position, candidate.position):\n                    continue\n                total_cost = new_node.cost + d + candidate.cost\n                if total_cost < best_connect_cost:\n                    best_connect_cost = total_cost\n                    best_connect = candidate\n            return best_connect\n\n        def extract_combined_path(n_start, n_goal, start_side=True):\n            path_from_start = n_start.path_from_root()\n            path_from_goal = n_goal.path_from_root()\n            if path_from_start[-1] == path_from_goal[-1]:\n                combined = path_from_start + path_from_goal[-2::-1]\n            else:\n                combined = path_from_start + path_from_goal[::-1]\n            if start_side:\n                return combined\n            else:\n                return combined[::-1]\n\n        def path_cost(path):\n            if not path or len(path) < 2:\n                return 0.0\n            c = 0.0\n            for i in range(len(path)-1):\n                c += dist(path[i], path[i+1])\n            return c\n\n        # Progressive stochastic shortcut smoothing accepting only improving collision-free shortcuts\n        def progressive_shortcut_path(path, attempts):\n            if len(path) < 3:\n                return path[:]\n            import random as rand\n            path_smoothed = path[:]\n            improved = True\n            for _ in range(attempts):\n                if not improved or len(path_smoothed) < 3:\n                    break\n                improved = False\n                i = rand.randint(0, len(path_smoothed)-3)\n                j = rand.randint(i+2, len(path_smoothed)-1)\n                if j <= i+1:\n                    continue\n                if not is_edge_in_obstacle(path_smoothed[i], path_smoothed[j]):\n                    # Check if shortcut improves length significantly\n                    old_segment_len = 0.0\n                    for k in range(i,j):\n                        old_segment_len += dist(path_smoothed[k], path_smoothed[k+1])\n                    new_segment_len = dist(path_smoothed[i], path_smoothed[j])\n                    if new_segment_len + 1e-8 < old_segment_len:\n                        path_smoothed = path_smoothed[:i+1] + path_smoothed[j:]\n                        improved = True\n            return path_smoothed\n\n        # Initialize trees and containers\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        tree_a = [start_root]\n        tree_b = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        best_cost = float(\"inf\")\n        best_path = []\n        found_solution = False\n        no_improve_count = 0\n        start_time = time.time()\n\n        for it in range(self.max_iter):\n            if time.time() - start_time > self.time_limit_sec:\n                break\n\n            grow_tree = tree_a if it % 2 == 0 else tree_b\n            other_tree = tree_b if it % 2 == 0 else tree_a\n            start_side = (grow_tree == tree_a)\n\n            sample = sample_informed(best_cost)\n            nearest_node = nearest(grow_tree, sample)\n            new_pos = steer(nearest_node.position, sample)\n            if not within_bounds(new_pos):\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n                continue\n            if is_in_obstacle(new_pos) or is_edge_in_obstacle(nearest_node.position, new_pos):\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n                continue\n\n            new_node, neighbors = add_node_with_best_parent(grow_tree, new_pos)\n            if new_node is None:\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n                continue\n\n            rewire(new_node, neighbors)\n\n            connect_node = connect_trees(new_node, other_tree)\n            if connect_node:\n                # Skip root-to-root connections\n                if connect_node.parent is None or new_node.parent is None:\n                    continue\n                candidate_path = extract_combined_path(new_node, connect_node, start_side)\n                candidate_cost = path_cost(candidate_path)\n                improved = False\n                if candidate_cost + 1e-14 < best_cost:\n                    best_cost = candidate_cost\n                    # Progressive smoothing with more iterations after each improvement\n                    smooth_path = candidate_path[:]\n                    for _ in range(self.smoothing_iters):\n                        new_smooth = progressive_shortcut_path(smooth_path, attempts=8)\n                        if len(new_smooth) < len(smooth_path) or path_cost(new_smooth) + 1e-8 < path_cost(smooth_path):\n                            smooth_path = new_smooth\n                        else:\n                            break\n                    best_path = smooth_path\n                    found_solution = True\n                    no_improve_count = 0\n                    improved = True\n                if not improved and found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n            else:\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n\n        return PlannerResult(\n            success=found_solution,\n            path=best_path if found_solution else [],\n            nodes=nodes,\n            edges=edges\n        )",
    "objective": 15.38425,
    "time_improvement": -87.0,
    "length_improvement": 15.0,
    "smoothness_improvement": 337.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.09031834602355956,
            "num_nodes_avg": 193.8,
            "path_length_avg": 162.07145033060613,
            "smoothness_avg": 0.025951019006480884,
            "success_improvement": 0.0,
            "time_improvement": -244.03295544639425,
            "length_improvement": 11.166069887318496,
            "smoothness_improvement": 306.1898009911681,
            "objective_score": -64.97929569657133
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.08147075176239013,
            "num_nodes_avg": 345.7,
            "path_length_avg": 248.06819096317196,
            "smoothness_avg": 0.018111903367938234,
            "success_improvement": 0.0,
            "time_improvement": 50.665656051599115,
            "length_improvement": 17.187697609518068,
            "smoothness_improvement": 366.0323191337446,
            "objective_score": 27.3424769768593
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.08367865085601807,
            "num_nodes_avg": 338.9,
            "path_length_avg": 126.17871513100253,
            "smoothness_avg": 0.03438895438340988,
            "success_improvement": 0.0,
            "time_improvement": -66.40638631174092,
            "length_improvement": 16.19810539473434,
            "smoothness_improvement": 337.42496142840093,
            "objective_score": -8.515927849539665
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "path_expert",
    "algorithm_description": "\"A Dual-Tree Bidirectional Rapidly-exploring Random Graph (BiRRG) with Adaptive Guided Sampling and Cost-Propagating Rewiring that balances exploration and exploitation. The planner samples globally at first and progressively concentrates around a dynamically updated informed ellipsoid after improvements, leveraging a k-nearest neighbor rewiring with downstream cost propagation. It maintains two growing graphs from start and goal, connects all promising cross-tree edges within an adaptive radius optimizing for minimal path cost and employs repeated batch shortcut smoothing with length and collision-based acceptance. The method enforces earliest prune of failed expansions and incremental cost consistency, yielding efficient convergence to shorter and smoother paths within a time budget.",
    "planning_mechanism": "The planner incrementally grows two graphs from start and goal by sampling points that blend uniform random global exploration and shrinking informed ellipsoid sampling focused near current best path cost. Each sampled point connects to k-nearest neighbors minimizing new cost and rewire neighbors for cost improvement with downstream cost propagation. Periodically, the planner attempts to connect the two graphs by checking edges from new nodes to all nodes in the opposite graph within a growing radius to identify minimal cost connecting links. Once connected, it extracts the combined path and applies iterative batch shortcut smoothing that only accepts collision-free length reducing shortcuts. The planning stops upon reaching max iterations, time limit, or stagnation in path cost.}\n\n```python\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = set()\n\n    def add_child(self, child):\n        self.children.add(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        self.children.discard(child)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n\nclass Planner:\n    def __init__(self, max_iter=4000, step_size=5.0, gamma=35.0, max_no_improve=150,\n                 time_limit_sec=25.0, smooth_batch_iters=20, smoothing_attempts=15,\n                 k_nearest=15):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.gamma = gamma\n        self.max_no_improve = max_no_improve\n        self.time_limit_sec = time_limit_sec\n        self.smooth_batch_iters = smooth_batch_iters\n        self.smoothing_attempts = smoothing_attempts\n        self.k_nearest = k_nearest\n\n    def plan(self, map):\n        import math\n        import random\n        import time\n\n        bounds = map.size\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        def within_bounds(p):\n            return all(0.0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            acc = 0.0\n            for d in range(dim):\n                diff = a[d] - b[d]\n                acc += diff * diff\n            return math.sqrt(acc)\n\n        def steer(from_p, to_p):\n            d = dist(from_p, to_p)\n            if d <= self.step_size:\n                return to_p\n            scale = self.step_size / d\n            return tuple(from_p[i] + scale * (to_p[i] - from_p[i]) for i in range(dim))\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d_ = obs\n                    px, py, pz = pos\n                    if (x <= px <= x + w and\n                        y <= py <= y + h and\n                        z <= pz <= z + d_):\n                        return True\n                else:\n                    x, y, w, h = obs\n                    px, py = pos\n                    if (x <= px <= x + w and\n                        y <= py <= y + h):\n                        return True\n            return False\n\n        def is_edge_in_obstacle(a, b, resolution=1.0):\n            length = dist(a, b)\n            steps = max(1, int(length / resolution))\n            for i in range(steps + 1):\n                interp = tuple(a[d] + (b[d] - a[d]) * (i / steps) for d in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        # Sampling strategies\n        def sample_uniform():\n            while True:\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle(p):\n                    return p\n\n        def sample_unit_ball():\n            while True:\n                vec = [random.gauss(0, 1) for _ in range(dim)]\n                norm = math.sqrt(sum(c * c for c in vec))\n                if norm",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = set()\n\n    def add_child(self, child):\n        self.children.add(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        self.children.discard(child)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=4000, step_size=5.0, gamma=35.0, max_no_improve=150,\n                 time_limit_sec=25.0, smooth_batch_iters=20, smoothing_attempts=15,\n                 k_nearest=15):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.gamma = gamma\n        self.max_no_improve = max_no_improve\n        self.time_limit_sec = time_limit_sec\n        self.smooth_batch_iters = smooth_batch_iters\n        self.smoothing_attempts = smoothing_attempts\n        self.k_nearest = k_nearest\n\n    def plan(self, map):\n        import math\n        import random\n        import time\n\n        bounds = map.size\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        def within_bounds(p):\n            return all(0.0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            acc = 0.0\n            for d in range(dim):\n                diff = a[d] - b[d]\n                acc += diff * diff\n            return math.sqrt(acc)\n\n        def steer(from_p, to_p):\n            d = dist(from_p, to_p)\n            if d <= self.step_size:\n                return to_p\n            scale = self.step_size / d\n            return tuple(from_p[i] + scale * (to_p[i] - from_p[i]) for i in range(dim))\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d_ = obs\n                    px, py, pz = pos\n                    if (x <= px <= x + w and\n                        y <= py <= y + h and\n                        z <= pz <= z + d_):\n                        return True\n                else:\n                    x, y, w, h = obs\n                    px, py = pos\n                    if (x <= px <= x + w and\n                        y <= py <= y + h):\n                        return True\n            return False\n\n        def is_edge_in_obstacle(a, b, resolution=1.0):\n            length = dist(a, b)\n            steps = max(1, int(length / resolution))\n            for i in range(steps + 1):\n                interp = tuple(a[d] + (b[d] - a[d]) * (i / steps) for d in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        # Sampling strategies\n        def sample_uniform():\n            while True:\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle(p):\n                    return p\n\n        def sample_unit_ball():\n            while True:\n                vec = [random.gauss(0, 1) for _ in range(dim)]\n                norm = math.sqrt(sum(c * c for c in vec))\n                if norm > 1e-14:\n                    unit_vec = [c / norm for c in vec]\n                    r = random.random() ** (1.0 / dim)\n                    return tuple(unit_vec[i] * r for i in range(dim))\n\n        def compute_basis(unit_vec):\n            if dim == 2:\n                perp = (-unit_vec[1], unit_vec[0])\n                return [unit_vec, perp]\n            # 3D orthonormal basis\n            def cross(u, v):\n                return (u[1]*v[2]-u[2]*v[1],\n                        u[2]*v[0]-u[0]*v[2],\n                        u[0]*v[1]-u[1]*v[0])\n            def norm_vec(vv):\n                return math.sqrt(sum(x*x for x in vv))\n            def normalize(vv):\n                n = norm_vec(vv)\n                if n < 1e-14:\n                    return vv\n                return tuple(x/n for x in vv)\n            ref = (1.0, 0.0, 0.0) if abs(unit_vec[0]) < 0.9 else (0.0, 1.0, 0.0)\n            b2 = normalize(cross(unit_vec, ref))\n            if norm_vec(b2) < 1e-14:\n                ref = (0.0, 0.0, 1.0)\n                b2 = normalize(cross(unit_vec, ref))\n            b3 = cross(unit_vec, b2)\n            return [unit_vec, b2, b3]\n\n        def sample_informed(c_best):\n            if c_best == float(\"inf\") or c_best <= c_min + 1e-12 or not found_solution:\n                return sample_uniform()\n            r1 = c_best / 2.0\n            rother_sq = max(c_best * c_best - c_min * c_min, 0.0)\n            rother = math.sqrt(rother_sq) / 2.0\n            center = tuple((start_pos[d] + goal_pos[d]) * 0.5 for d in range(dim))\n            unit_vec = tuple((goal_pos[d] - start_pos[d]) / c_min for d in range(dim))\n            basis = compute_basis(unit_vec)\n            radii = [r1] + [rother] * (dim - 1)\n\n            while True:\n                u = sample_unit_ball()\n                mapped = []\n                for d in range(dim):\n                    val = center[d]\n                    for i in range(dim):\n                        val += basis[i][d] * radii[i] * u[i]\n                    # Clamp sample\n                    val = min(max(val, 0.0), bounds[d])\n                    mapped.append(val)\n                p = tuple(mapped)\n                if not is_in_obstacle(p):\n                    return p\n\n        # Distance squared for efficiency in neighbor search\n        def dist_sqr(a, b):\n            s = 0.0\n            for d in range(dim):\n                diff = a[d] - b[d]\n                s += diff * diff\n            return s\n\n        c_min = dist(start_pos, goal_pos)\n\n        # Adaptive neighbor radius (k-NN) heuristic for rewiring and connecting\n        def neighbor_radius(n_nodes):\n            if n_nodes < 2:\n                return self.step_size * 2.0\n            r = self.gamma * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            max_r = max(bounds) * 0.3\n            min_r = max(self.step_size * 1.0, 5.0)\n            return max(min_r, min(max_r, r))\n\n        def nearest(tree, point):\n            best_node = None\n            best_dist = float(\"inf\")\n            for n in tree:\n                d = dist_sqr(n.position, point)\n                if d < best_dist:\n                    best_dist = d\n                    best_node = n\n            return best_node\n\n        def k_nearest(tree, point, k):\n            nn = []\n            for n in tree:\n                d = dist_sqr(n.position, point)\n                nn.append((d, n))\n            nn.sort(key=lambda x: x[0])\n            return [item[1] for item in nn[:k]]\n\n        def add_node(tree, pos):\n            if is_in_obstacle(pos):\n                return None\n            n_nodes = len(tree)\n            r = neighbor_radius(n_nodes)\n            neighbors = k_nearest(tree, pos, self.k_nearest)\n            candidates = [p for p in neighbors if not is_edge_in_obstacle(p.position, pos)]\n            if not candidates:\n                # If no collision-free parent found, fallback to nearest in tree if edge is free\n                nearest_node = nearest(tree, pos)\n                if nearest_node and not is_edge_in_obstacle(nearest_node.position, pos):\n                    candidates = [nearest_node]\n                else:\n                    return None\n            def cost_to_parent(p): return p.cost + dist(p.position, pos)\n            parent = min(candidates, key=cost_to_parent)\n            new_cost = cost_to_parent(parent)\n            new_node = Node(pos)\n            new_node.parent = parent\n            new_node.cost = new_cost\n            parent.add_child(new_node)\n            tree.append(new_node)\n            return new_node\n\n        # Recursively propagate cost update downstream in the tree graph\n        def propagate_costs_downstream(node):\n            for ch in list(node.children):\n                old_cost = ch.cost\n                new_cost = node.cost + dist(node.position, ch.position)\n                if new_cost + 1e-14 < old_cost:\n                    ch.cost = new_cost\n                    ch.parent = node  # Ensure parent is set correctly\n                    propagate_costs_downstream(ch)\n\n        def rewire(node, tree):\n            neighbors = k_nearest(tree, node.position, self.k_nearest)\n            for n in neighbors:\n                if n is node or n.parent is node:\n                    continue\n                if is_edge_in_obstacle(node.position, n.position):\n                    continue\n                new_cost = node.cost + dist(node.position, n.position)\n                if new_cost + 1e-12 < n.cost:\n                    # Remove old edge\n                    if n.parent:\n                        n.parent.remove_child(n)\n                    # Add new edge and update cost\n                    node.add_child(n)\n                    n.cost = new_cost\n                    propagate_costs_downstream(n)\n\n        # Connect two trees on current nodes within connection radius; return best connection pair\n        def connect_graphs(tree1, tree2, radius):\n            best_pair = None\n            best_cost = float('inf')\n            for n1 in tree1:\n                candidates = []\n                for n2 in tree2:\n                    d = dist(n1.position, n2.position)\n                    if d <= radius and d > 0.0:\n                        candidates.append(n2)\n                for n2 in candidates:\n                    if is_edge_in_obstacle(n1.position, n2.position):\n                        continue\n                    # combined path cost is sum of costs plus connecting edge\n                    total_cost = n1.cost + dist(n1.position, n2.position) + n2.cost\n                    if total_cost < best_cost:\n                        best_cost = total_cost\n                        best_pair = (n1, n2)\n            return best_pair\n\n        def combine_paths(node_from_start, node_from_goal):\n            path_start = node_from_start.path_from_root()\n            path_goal = node_from_goal.path_from_root()\n            # Avoid duplicate connection node in combined path\n            if path_start[-1] == path_goal[-1]:\n                return path_start + path_goal[-2::-1]\n            else:\n                return path_start + path_goal[::-1]\n\n        def path_length(path):\n            if not path or len(path) < 2:\n                return 0.0\n            length = 0.0\n            for i in range(len(path) - 1):\n                length += dist(path[i], path[i+1])\n            return length\n\n        # Batch shortcut smoothing, accepting only collision-free shortening shortcuts\n        def batch_shortcut_smooth(path, iterations, attempts_per_iter):\n            import random\n            pth = path[:]\n            n = len(pth)\n            if n < 3:\n                return pth\n            for _ in range(iterations):\n                improved = False\n                for _attempt in range(attempts_per_iter):\n                    if len(pth) < 3:\n                        break\n                    i = random.randint(0, len(pth) - 3)\n                    j = random.randint(i + 2, len(pth) - 1)\n                    if j <= i + 1:\n                        continue\n                    if is_edge_in_obstacle(pth[i], pth[j]):\n                        continue\n                    old_seg_length = 0.0\n                    for k in range(i, j):\n                        old_seg_length += dist(pth[k], pth[k+1])\n                    new_seg_length = dist(pth[i], pth[j])\n                    if new_seg_length + 1e-9 < old_seg_length:\n                        pth = pth[:i+1] + pth[j:]\n                        improved = True\n                        break\n                if not improved:\n                    break\n            return pth\n\n        # Initialize bidirectional graphs\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n\n        best_cost = float(\"inf\")\n        best_path = []\n        found_solution = False\n        no_improve = 0\n        start_time = time.time()\n\n        # Mix ratio: percent chance to sample informed\n        def informed_sampling_probability(i):\n            # Linearly increase probability from 0 to 0.9 after 30% max_iter\n            p = min(0.9, i / (self.max_iter * 0.3))\n            return p\n\n        for iter_num in range(self.max_iter):\n            if time.time() - start_time > self.time_limit_sec:\n                break\n\n            sampling_informed = found_solution and random.random() < informed_sampling_probability(iter_num)\n            sample = sample_informed(best_cost) if sampling_informed else sample_uniform()\n\n            grow_from_start = (iter_num % 2 == 0)\n            current_tree = tree_start if grow_from_start else tree_goal\n            other_tree = tree_goal if grow_from_start else tree_start\n\n            nearest_node = nearest(current_tree, sample)\n            new_pos = steer(nearest_node.position, sample)\n\n            if not within_bounds(new_pos) or is_in_obstacle(new_pos) or is_edge_in_obstacle(nearest_node.position, new_pos):\n                # Penalize no improvement for invalid samples when solution found\n                if found_solution:\n                    no_improve += 1\n                    if no_improve >= self.max_no_improve:\n                        break\n                continue\n\n            new_node = add_node(current_tree, new_pos)\n            if new_node is None:\n                if found_solution:\n                    no_improve += 1\n                    if no_improve >= self.max_no_improve:\n                        break\n                continue\n\n            rewire(new_node, current_tree)\n\n            # Connection radius grows slowly to avoid expensive large-radius checks early\n            n_nodes_total = len(tree_start) + len(tree_goal)\n            connect_radius = min(max(bounds)*0.3, self.gamma * ((math.log(n_nodes_total + 1) / (n_nodes_total + 1)) ** (1.0 / dim)) * 2.5)\n            connect_pair = connect_graphs([new_node], other_tree, connect_radius)\n\n            if connect_pair is not None:\n                n1, n2 = connect_pair\n                # Avoid connecting root to root nodes without intermediate nodes\n                if n1.parent is None or n2.parent is None:\n                    pass\n                else:\n                    candidate_path = combine_paths(n1, n2)\n                    candidate_cost = path_length(candidate_path)\n                    if candidate_cost + 1e-12 < best_cost:\n                        best_cost = candidate_cost\n                        # Batch shortcut smoothing after connection found\n                        smoothed = candidate_path\n                        for _ in range(self.smooth_batch_iters):\n                            smoothed_next = batch_shortcut_smooth(smoothed, 1, self.smoothing_attempts)\n                            if len(smoothed_next) < len(smoothed) or path_length(smoothed_next) + 1e-9 < path_length(smoothed):\n                                smoothed = smoothed_next\n                            else:\n                                break\n                        best_path = smoothed\n                        found_solution = True\n                        no_improve = 0\n                    else:\n                        no_improve += 1\n            else:\n                if found_solution:\n                    no_improve += 1\n\n            if found_solution and no_improve >= self.max_no_improve:\n                break\n\n        return PlannerResult(\n            success=found_solution,\n            path=best_path if found_solution else [],\n            nodes=tree_start + tree_goal,\n            edges=[]\n        )",
    "objective": 195.05081,
    "time_improvement": -711.0,
    "length_improvement": 21.0,
    "smoothness_improvement": 1168.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.35930476188659666,
            "num_nodes_avg": 260.8,
            "path_length_avg": 155.6835792984947,
            "smoothness_avg": 0.04647220496917606,
            "success_improvement": 0.0,
            "time_improvement": -1268.6331136485205,
            "length_improvement": 14.667363222312787,
            "smoothness_improvement": 627.3909237759126,
            "objective_score": -368.65256154228894
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.4819819211959839,
            "num_nodes_avg": 431.5,
            "path_length_avg": 225.35927988229886,
            "smoothness_avg": 0.08236450457774333,
            "success_improvement": 0.0,
            "time_improvement": -191.86255635081335,
            "length_improvement": 24.768585768076928,
            "smoothness_improvement": 2019.2980275400587,
            "objective_score": -32.60112530669756
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.38809444904327395,
            "num_nodes_avg": 340.8,
            "path_length_avg": 117.08364755475971,
            "smoothness_avg": 0.0753411420061106,
            "success_improvement": 0.0,
            "time_improvement": -671.778633525766,
            "length_improvement": 22.238616218297157,
            "smoothness_improvement": 858.3337652130963,
            "objective_score": -183.89875150068602
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "path_expert",
    "algorithm_description": "A Dual Bi-directional Informed Geometric Tree (DIGT) planner with Adaptive k-Nearest connections, Incremental Cost Propagation, and Progressive Multi-level Shortcut Smoothing. This planner dynamically biases sampling within a shrinking informed ellipsoid around the best known path to accelerate convergence. It alternates tree expansions with adaptive rewiring using an efficient k-nearest neighbor search and propagates cost improvements downstream for consistent optimal subtrees. The two trees are connected using multiple candidate edges within an adaptively scaled radius to foster early and diverse path fusion. It performs progressive multi-level shortcut smoothing that combines short-range local shortcuts and longer-range global shortcuts iteratively, rejecting only collision-checked non-improving shortcuts. The approach systematically reduces both path length and path smoothness while ensuring rapid planning and robust convergence.",
    "planning_mechanism": "The planner grows two trees alternately from the start and goal using adaptive informed sampling concentrated in an ellipsoid shrinking as better solutions are found. It finds new nodes by steering from nearest nodes and rewires nearby neighbors to reduce costs, propagating cost changes recursively. It attempts multiple connections between the trees inside an adaptive radius, selecting the minimal total-cost connection. After path connection, progressive multi-level shortcut smoothing is performed with increasing shortcut span lengths, improving smoothness and length iteratively. The process terminates upon satisfying maximum iterations, time limits, or convergence criteria.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = set()\n\n    def add_child(self, child):\n        self.children.add(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        self.children.discard(child)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=4500, step_size=5.0, gamma=40.0,\n                 max_no_improve=120, time_limit_sec=25.0,\n                 smooth_levels=3, smoothing_iterations_per_level=10,\n                 k_nearest=18):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.gamma = gamma\n        self.max_no_improve = max_no_improve\n        self.time_limit_sec = time_limit_sec\n        self.smooth_levels = smooth_levels  # multi-level progressive smoothing\n        self.smoothing_iterations_per_level = smoothing_iterations_per_level\n        self.k_nearest = k_nearest\n\n    def plan(self, map):\n        import math\n        import random\n        import time\n\n        bounds = map.size\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        def within_bounds(p):\n            return all(0.0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            s = 0.0\n            for d in range(dim):\n                diff = a[d] - b[d]\n                s += diff * diff\n            return math.sqrt(s)\n\n        def steer(from_p, to_p):\n            d = dist(from_p, to_p)\n            if d <= self.step_size:\n                return to_p\n            scale = self.step_size / d\n            return tuple(from_p[i] + scale * (to_p[i] - from_p[i]) for i in range(dim))\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d_ = obs\n                    px, py, pz = pos\n                    if (x <= px <= x + w and\n                        y <= py <= y + h and\n                        z <= pz <= z + d_):\n                        return True\n                else:\n                    x, y, w, h = obs\n                    px, py = pos\n                    if (x <= px <= x + w and\n                        y <= py <= y + h):\n                        return True\n            return False\n\n        def is_edge_in_obstacle(a, b, resolution=1.0):\n            length = dist(a, b)\n            steps = max(1, int(length / resolution))\n            for i in range(steps + 1):\n                interp = tuple(a[d] + (b[d] - a[d]) * (i / steps) for d in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def sample_uniform():\n            while True:\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle(p):\n                    return p\n\n        def sample_unit_ball():\n            while True:\n                vec = [random.gauss(0, 1) for _ in range(dim)]\n                norm = math.sqrt(sum(c * c for c in vec))\n                if norm > 1e-14:\n                    return tuple((c / norm) for c in vec)\n\n        def compute_basis(u_vec):\n            # Returns orthonormal basis vectors with u_vec first\n            if dim == 2:\n                perp = (-u_vec[1], u_vec[0])\n                return [u_vec, perp]\n            # 3D basis by Gram-Schmidt\n            def cross(u,v):\n                return (u[1]*v[2] - u[2]*v[1],\n                        u[2]*v[0] - u[0]*v[2],\n                        u[0]*v[1] - u[1]*v[0])\n            def norm_v(vv):\n                return math.sqrt(sum(x*x for x in vv))\n            def normalize(vv):\n                n = norm_v(vv)\n                if n < 1e-14:\n                    return vv\n                return tuple(x/n for x in vv)\n            ref = (1.0, 0.0, 0.0) if abs(u_vec[0]) < 0.9 else (0.0, 1.0, 0.0)\n            b2 = normalize(cross(u_vec, ref))\n            if norm_v(b2) < 1e-14:\n                ref = (0.0, 0.0, 1.0)\n                b2 = normalize(cross(u_vec, ref))\n            b3 = cross(u_vec, b2)\n            return [u_vec, b2, b3]\n\n        def sample_informed(c_best, c_min, start, goal):\n            # Sample inside an ellipsoid aligned from start to goal, shrinking with best cost\n            if c_best == float(\"inf\") or c_best <= c_min + 1e-12 or not found_solution:\n                return sample_uniform()\n            r1 = c_best / 2.0\n            rother_sq = max(c_best**2 - c_min**2, 0.0)\n            rother = math.sqrt(rother_sq) / 2.0\n            center = tuple((start[d] + goal[d]) * 0.5 for d in range(dim))\n            unit_vec = tuple((goal[d] - start[d]) / c_min for d in range(dim))\n            basis = compute_basis(unit_vec)\n            radii = [r1] + [rother] * (dim - 1)\n\n            while True:\n                u = sample_unit_ball()\n                mapped = [0.0]*dim\n                for d in range(dim):\n                    val = center[d]\n                    for i in range(dim):\n                        val += basis[i][d] * radii[i] * u[i]\n                    # Clamp inside bounds\n                    val = max(0.0, min(bounds[d], val))\n                    mapped[d] = val\n                p = tuple(mapped)\n                if not is_in_obstacle(p):\n                    return p\n\n        def dist_sqr(a,b):\n            s=0.0\n            for d in range(dim):\n                diff = a[d]-b[d]\n                s += diff*diff\n            return s\n\n        c_min = dist(start_pos, goal_pos)\n\n        def neighbor_radius(n_nodes):\n            if n_nodes < 2:\n                return self.step_size * 2.0\n            r = self.gamma * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            max_r = max(bounds)*0.28\n            min_r = max(self.step_size*1.2,4.0)\n            return max(min_r, min(max_r, r))\n\n        def nearest(tree, point):\n            best_node = None\n            best_d = float(\"inf\")\n            for n in tree:\n                d = dist_sqr(n.position, point)\n                if d < best_d:\n                    best_d = d\n                    best_node = n\n            return best_node\n\n        def k_nearest(tree, point, k):\n            nn = []\n            for n in tree:\n                d = dist_sqr(n.position, point)\n                nn.append((d, n))\n            nn.sort(key=lambda x: x[0])\n            return [n for _, n in nn[:k]]\n\n        def add_node(tree, pos):\n            if is_in_obstacle(pos):\n                return None\n            n_nodes = len(tree)\n            r = neighbor_radius(n_nodes)\n            neighbors = k_nearest(tree, pos, self.k_nearest)\n            candidates = [p for p in neighbors if not is_edge_in_obstacle(p.position, pos)]\n            if not candidates:\n                nearest_node = nearest(tree, pos)\n                if nearest_node and not is_edge_in_obstacle(nearest_node.position, pos):\n                    candidates = [nearest_node]\n                else:\n                    return None\n            def cost_to_parent(p): return p.cost + dist(p.position, pos)\n            parent = min(candidates, key=cost_to_parent)\n            new_cost = cost_to_parent(parent)\n            new_node = Node(pos)\n            new_node.parent = parent\n            new_node.cost = new_cost\n            parent.add_child(new_node)\n            tree.append(new_node)\n            return new_node\n\n        def propagate_costs_downstream(node):\n            for ch in list(node.children):\n                oldcost = ch.cost\n                newcost = node.cost + dist(node.position, ch.position)\n                if newcost + 1e-14 < oldcost:\n                    ch.cost = newcost\n                    ch.parent = node\n                    propagate_costs_downstream(ch)\n\n        def rewire(node, tree):\n            neighbors = k_nearest(tree, node.position, self.k_nearest)\n            for n in neighbors:\n                if n is node or n.parent is node:\n                    continue\n                if is_edge_in_obstacle(node.position, n.position):\n                    continue\n                newcost = node.cost + dist(node.position, n.position)\n                if newcost + 1e-13 < n.cost:\n                    if n.parent:\n                        n.parent.remove_child(n)\n                    node.add_child(n)\n                    n.cost = newcost\n                    propagate_costs_downstream(n)\n\n        def connect_graphs(starts, goals, radius):\n            best_pair = None\n            best_cost = float('inf')\n            for ns in starts:\n                # Limit candidates by radius to avoid large overhead:\n                candidates = []\n                radius_sqr = radius*radius\n                for ng in goals:\n                    d = dist_sqr(ns.position, ng.position)\n                    if d <= radius_sqr and d > 1e-14:\n                        candidates.append(ng)\n                # Among candidates pick minimal cost connection\n                for ng in candidates:\n                    if is_edge_in_obstacle(ns.position, ng.position):\n                        continue\n                    costtotal = ns.cost + dist(ns.position, ng.position) + ng.cost\n                    if costtotal < best_cost:\n                        best_cost = costtotal\n                        best_pair = (ns, ng)\n            return best_pair\n\n        def combine_paths(node_start, node_goal):\n            path_s = node_start.path_from_root()\n            path_g = node_goal.path_from_root()\n            # Remove duplicate connecting node\n            if path_s[-1] == path_g[-1]:\n                return path_s + path_g[-2::-1]\n            return path_s + path_g[::-1]\n\n        def path_length(path):\n            if len(path) < 2:\n                return 0.0\n            length = 0.0\n            for i in range(len(path)-1):\n                length += dist(path[i], path[i+1])\n            return length\n\n        def progressive_multi_level_smooth(path):\n            # Applies multiple smoothing passes with increasing max shortcut spans\n            # Accepts only non-colliding length reducing shortcuts\n            import random\n            pth = path[:]\n            n = len(pth)\n            if n < 3:\n                return pth\n            for level in range(self.smooth_levels):\n                max_span = 2 + level*2  # spans of 2,4,6,...\n                for _ in range(self.smoothing_iterations_per_level):\n                    improved = False\n                    # Try all candidates up to max_span shortcuts for stronger optimization\n                    candidates = []\n                    for i in range(n):\n                        for j in range(i+2, min(i+1+max_span, n)):\n                            candidates.append((i,j))\n                    random.shuffle(candidates)\n                    for (i,j) in candidates:\n                        # Check collision of shortcut edge\n                        if is_edge_in_obstacle(pth[i], pth[j]):\n                            continue\n                        # Compute old segment length and new shortcut\n                        oldseg = 0.0\n                        for k in range(i, j):\n                            oldseg += dist(pth[k], pth[k+1])\n                        newseg = dist(pth[i], pth[j])\n                        if newseg + 1e-12 < oldseg:\n                            pth = pth[:i+1] + pth[j:]\n                            n = len(pth)  # update length\n                            improved = True\n                            break\n                    if not improved:\n                        break\n            return pth\n\n        # Initialize trees\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n\n        best_cost = float(\"inf\")\n        best_path = []\n        found_solution = False\n        no_improve = 0\n        start_time = time.time()\n\n        def informed_sampling_probability(it):\n            # Linear ramp up from 0 to 0.95 after 30% of iterations\n            return min(0.95, it / (self.max_iter * 0.3))\n\n        for iter_num in range(self.max_iter):\n            if time.time() - start_time > self.time_limit_sec:\n                break\n\n            sample_informed_bias = found_solution and (random.random() < informed_sampling_probability(iter_num))\n            sample = sample_informed(best_cost, c_min, start_pos, goal_pos) if sample_informed_bias else sample_uniform()\n\n            grow_start = (iter_num % 2 == 0)\n            current_tree = tree_start if grow_start else tree_goal\n            other_tree = tree_goal if grow_start else tree_start\n\n            nearest_node = nearest(current_tree, sample)\n            new_pos = steer(nearest_node.position, sample)\n\n            # Node and edge collisions\n            if (not within_bounds(new_pos) or is_in_obstacle(new_pos)\n                or is_edge_in_obstacle(nearest_node.position, new_pos)):\n                if found_solution:\n                    no_improve += 1\n                    if no_improve >= self.max_no_improve:\n                        break\n                continue\n\n            new_node = add_node(current_tree, new_pos)\n            if new_node is None:\n                if found_solution:\n                    no_improve += 1\n                    if no_improve >= self.max_no_improve:\n                        break\n                continue\n\n            rewire(new_node, current_tree)\n\n            n_all = len(tree_start) + len(tree_goal)\n            connect_radius = min(max(bounds)*0.28,\n                                 self.gamma * ((math.log(n_all+1) / (n_all+1))**(1.0/dim)) * 2.8)\n\n            connect_pair = connect_graphs([new_node], other_tree, connect_radius)\n\n            if connect_pair is not None:\n                ns, ng = connect_pair\n                # Do not connect root-to-root directly (must involve intermediate nodes)\n                if ns.parent is None and ng.parent is None:\n                    pass\n                else:\n                    candidate_path = combine_paths(ns, ng)\n                    candidate_cost = path_length(candidate_path)\n                    if candidate_cost + 1e-14 < best_cost:\n                        best_cost = candidate_cost\n                        # Progressive multi-level smoothing to improve path length and smoothness\n                        smoothed = candidate_path\n                        for _ in range(3):  # multiple repeats for convergence\n                            smoothed = progressive_multi_level_smooth(smoothed)\n                        best_path = smoothed\n                        found_solution = True\n                        no_improve = 0\n                    else:\n                        no_improve += 1\n            else:\n                if found_solution:\n                    no_improve += 1\n\n            if found_solution and no_improve >= self.max_no_improve:\n                break\n\n        return PlannerResult(\n            success=found_solution,\n            path=best_path if found_solution else [],\n            nodes=tree_start + tree_goal,\n            edges=[]\n        )",
    "objective": 160.85369,
    "time_improvement": -600.0,
    "length_improvement": 20.0,
    "smoothness_improvement": 1406.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.2716243028640747,
            "num_nodes_avg": 172.9,
            "path_length_avg": 154.6535496008861,
            "smoothness_avg": 0.055352360555424904,
            "success_improvement": 0.0,
            "time_improvement": -934.6481728199301,
            "length_improvement": 15.231938821437103,
            "smoothness_improvement": 766.3846422672067,
            "objective_score": -267.4233653417807
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.4333695888519287,
            "num_nodes_avg": 340.3,
            "path_length_avg": 230.5824042648109,
            "smoothness_avg": 0.09037618581866304,
            "success_improvement": 0.0,
            "time_improvement": -162.42551947419142,
            "length_improvement": 23.024956509894853,
            "smoothness_improvement": 2225.444356449672,
            "objective_score": -23.785460154072158
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.40364296436309816,
            "num_nodes_avg": 286.0,
            "path_length_avg": 117.10741599141534,
            "smoothness_avg": 0.10414754163766589,
            "success_improvement": 0.0,
            "time_improvement": -702.6989724702437,
            "length_improvement": 22.222830354401818,
            "smoothness_improvement": 1224.7490422592355,
            "objective_score": -191.35224831713583
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "cross_over",
    "algorithm_description": "An optimized bi-directional RRT* planner with adaptive neighbor radius and dynamic step sizing supported by KD-tree inspired efficient nearest neighbor search. It incorporates early collision checking and pruning, adaptive rewiring radius scaling based on current tree size, and targeted shortcut smoothing prioritizing long segments. The algorithm alternates tree growth with fast attempts to connect trees, emphasizing steadily improving paths. Informed ellipsoidal sampling is applied after first solution discovery to focus optimization efforts and improve path length and smoothness while carefully balancing computational overhead.",
    "planning_mechanism": "A bidirectional RRT* variant that incrementally grows two trees from start and goal, adaptively tuning neighbor radius and step size based on tree size and iteration progress. It leverages efficient approximate nearest neighbor searches to speed node expansions and rewiring, integrates early collision checks to prune invalid expansions, and switches from uniform to ellipsoidal (informed) sampling after discovering an initial path. The method aggressively shortcut-smooths promising paths focusing on longest segments to enhance smoothness and reduce path length without excess computation.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\nclass Planner:\n    def __init__(self, max_iter=4000, step_size=5.0, radius_factor=35.0, shortcut_trials=100, time_limit_sec=20.0):\n        self.max_iter = max_iter\n        self.base_step_size = step_size\n        self.radius_factor = radius_factor\n        self.shortcut_trials = shortcut_trials\n        self.time_limit_sec = time_limit_sec\n\n    def plan(self, map):\n        import time\n        import random\n        import math\n\n        bounds = map.size\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        obstacles = map.obstacles\n\n        def dist(a,b):\n            return math.sqrt(sum((a[i]-b[i])**2 for i in range(dim)))\n\n        def in_obstacle(p):\n            if not obstacles:\n                return False\n            if is_3d:\n                x,y,z = p\n                for ox,oy,oz,w,h,d in obstacles:\n                    if ox <= x <= ox+w and oy <= y <= oy+h and oz <= z <= oz+d:\n                        return True\n            else:\n                x,y = p\n                for ox,oy,w,h in obstacles:\n                    if ox <= x <= ox+w and oy <= y <= oy+h:\n                        return True\n            return False\n\n        def collision_free(frm,to):\n            d = dist(frm,to)\n            steps = max(2, int(d*2))\n            for i in range(steps+1):\n                interp = tuple(frm[j] + (to[j]-frm[j]) * i/steps for j in range(dim))\n                if in_obstacle(interp):\n                    return False\n            return True\n\n        def within_bounds(p):\n            for i in range(dim):\n                if p[i]<0 or p[i]>bounds[i]:\n                    return False\n            return True\n\n        class Tree:\n            def __init__(self, root):\n                self.nodes = [root]\n                self.positions = [root.position]\n\n            def add(self,node):\n                self.nodes.append(node)\n                self.positions.append(node.position)\n\n            def nearest(self,pos):\n                min_dist = float('inf')\n                min_node = None\n                for n in self.nodes:\n                    d = 0\n                    for i in range(dim):\n                        dx = n.position[i] - pos[i]\n                        d += dx*dx\n                        if d > min_dist*min_dist:\n                            break\n                    if d < min_dist*min_dist:\n                        min_dist = math.sqrt(d)\n                        min_node = n\n                return min_node,min_dist\n\n            def near(self,pos,radius):\n                radius_sq = radius*radius\n                result = []\n                for n in self.nodes:\n                    d = 0\n                    for i in range(dim):\n                        dx = n.position[i] - pos[i]\n                        d += dx*dx\n                        if d > radius_sq:\n                            break\n                    if d <= radius_sq:\n                        result.append(n)\n                return result\n\n        def steer(from_p,to_p,step):\n            d = dist(from_p,to_p)\n            if d <= step:\n                return to_p\n            r = step / d\n            return tuple(from_p[i] + (to_p[i]-from_p[i])*r for i in range(dim))\n\n        def shortcut_path(path):\n            if len(path)<3:\n                return path[:]\n            pts = path[:]\n            for _ in range(self.shortcut_trials):\n                if len(pts)<3:\n                    break\n                # Prefer longer segments to shortcut\n                seg_lengths = [dist(pts[i], pts[i+1]) for i in range(len(pts)-1)]\n                i = seg_lengths.index(max(seg_lengths))\n                j_candidates = [j for j in range(i+2, len(pts))]\n                if not j_candidates:\n                    continue\n                j = random.choice(j_candidates)\n                if collision_free(pts[i], pts[j]):\n                    del pts[i+1:j]\n            return pts\n\n        def informed_sample(start, goal, c_best, c_min):\n            if c_best == float('inf') or c_min < 1e-12:\n                while True:\n                    p = tuple(random.uniform(0,bounds[i]) for i in range(dim))\n                    if not in_obstacle(p):\n                        return p\n            center = tuple((start[i]+goal[i])/2 for i in range(dim))\n            a1 = tuple((goal[i]-start[i])/c_min for i in range(dim))\n            # Generate rotation basis\n            import math\n            def cross2d(v, w):\n                return v[0]*w[1] - v[1]*w[0]\n            def norm(v):\n                return math.sqrt(sum(x*x for x in v))\n            def normalize(v):\n                n = norm(v)\n                if n<1e-12:\n                    return v\n                return tuple(x/n for x in v)\n\n            # Sample unit ball vector\n            def sample_unit_ball(k):\n                while True:\n                    v = [random.gauss(0,1) for _ in range(k)]\n                    norm_v = math.sqrt(sum(x*x for x in v))\n                    if norm_v>1e-12:\n                        return tuple(x/norm_v for x in v)\n\n            c_max = c_best\n            r1 = c_max/2.0\n            if c_max*c_max - c_min*c_min < 0:\n                r2 = 0.0\n            else:\n                r2 = math.sqrt(c_max*c_max - c_min*c_min)/2.0\n\n            u = sample_unit_ball(dim)\n\n            if dim==2:\n                a2 = (-a1[1], a1[0])\n                basis = (a1,a2)\n                radii = (r1,r2)\n            else:\n                # 3D basis creation\n                def cross(u,v):\n                    return (u[1]*v[2]-u[2]*v[1], u[2]*v[0]-u[0]*v[2], u[0]*v[1]-u[1]*v[0])\n                def norm3(v):\n                    return math.sqrt(sum(x*x for x in v))\n                def normalize3(v):\n                    n = norm3(v)\n                    if n<1e-12:\n                        return v\n                    return tuple(x/n for x in v)\n                ref = (1.0,0.0,0.0) if abs(a1[0])<0.9 else (0.0,1.0,0.0)\n                b2 = cross(a1,ref)\n                b2 = normalize3(b2)\n                if norm3(b2)<1e-12:\n                    ref = (0.0,0.0,1.0)\n                    b2 = normalize3(cross(a1,ref))\n                b3 = cross(a1,b2)\n                basis = (a1,b2,b3)\n                radii = (r1,r2,r2)\n\n            sample = [0.0]*dim\n            for d in range(dim):\n                val = center[d]\n                for i in range(dim):\n                    val += basis[i][d]*radii[i]*u[i]\n                val = min(max(0.0,val), bounds[d])\n                sample[d] = val\n\n            # Reject if in obstacle, resample a few times\n            for _ in range(10):\n                if not in_obstacle(sample):\n                    return tuple(sample)\n                # Resample u vector if collision\n                u = sample_unit_ball(dim)\n                for d in range(dim):\n                    val = center[d]\n                    for i in range(dim):\n                        val += basis[i][d]*radii[i]*u[i]\n                    val = min(max(0.0,val), bounds[d])\n                    sample[d] = val\n            # Fallback uniform sample if repeated collision\n            while True:\n                p = tuple(random.uniform(0,bounds[i]) for i in range(dim))\n                if not in_obstacle(p):\n                    return p\n\n        start_node = Node(map.start, cost=0.0)\n        goal_node = Node(map.goal, cost=0.0)\n        tree_start = Tree(start_node)\n        tree_goal = Tree(goal_node)\n        nodes_all = [start_node, goal_node]\n        edges = []\n\n        best_cost = float('inf')\n        best_path = []\n        c_min = dist(start_node.position, goal_node.position)\n\n        found_solution = False\n        iteration = 0\n\n        start_time = time.time()\n\n        while iteration < self.max_iter:\n            if time.time() - start_time > self.time_limit_sec:\n                break\n            # Dynamic step size shrinking after first solution for finer optimization\n            step_size = self.base_step_size if not found_solution else max(1.5, self.base_step_size * 0.4)\n\n            # Alternate tree growth\n            growing_tree, other_tree = (tree_start, tree_goal) if iteration % 2 == 0 else (tree_goal, tree_start)\n            grow_is_start = (iteration % 2 == 0)\n\n            # Adaptive neighbor radius based on log(|V|)/|V|^(1/d)\n            nV = len(growing_tree.nodes)\n            r_neighbor = self.radius_factor * (math.log(nV+1)/ (nV+1))**(1.0/dim)\n            r_neighbor = max(step_size*1.5, min(r_neighbor, max(bounds)*0.3))\n\n            # Sample\n            sample_pt = informed_sample(start_node.position, goal_node.position, best_cost, c_min) if found_solution else \\\n                        tuple(random.uniform(0,bounds[i]) for i in range(dim))\n            if not within_bounds(sample_pt) or in_obstacle(sample_pt):\n                iteration += 1\n                continue\n\n            # Find nearest and steer\n            nearest_node, _ = growing_tree.nearest(sample_pt)\n            new_pos = steer(nearest_node.position, sample_pt, step_size)\n            if not within_bounds(new_pos) or in_obstacle(new_pos):\n                iteration += 1\n                continue\n            if not collision_free(nearest_node.position, new_pos):\n                iteration += 1\n                continue\n\n            # Find neighbors for parent selection and rewiring\n            near_nodes = growing_tree.near(new_pos, r_neighbor)\n            parent_node = None\n            min_cost = float('inf')\n            for n in near_nodes:\n                if collision_free(n.position, new_pos):\n                    c = n.cost + dist(n.position, new_pos)\n                    if c < min_cost:\n                        parent_node = n\n                        min_cost = c\n            if parent_node is None:\n                if collision_free(nearest_node.position, new_pos):\n                    parent_node = nearest_node\n                    min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n                else:\n                    iteration += 1\n                    continue\n\n            new_node = Node(new_pos, cost=min_cost)\n            parent_node.add_child(new_node)\n            growing_tree.add(new_node)\n            nodes_all.append(new_node)\n            edges.append((parent_node,new_node))\n\n            # Rewiring neighbors\n            for n in near_nodes:\n                if n is new_node.parent:\n                    continue\n                if collision_free(new_node.position, n.position):\n                    potential_cost = new_node.cost + dist(new_node.position, n.position)\n                    if potential_cost + 1e-12 < n.cost:\n                        # Rewire edge\n                        if n.parent:\n                            try:\n                                edges.remove((n.parent,n))\n                            except ValueError:\n                                pass\n                            if n in n.parent.children:\n                                n.parent.children.remove(n)\n                        new_node.add_child(n)\n                        n.cost = potential_cost\n                        edges.append((new_node,n))\n\n            # Try connecting trees\n            nearest_other, d_other = other_tree.nearest(new_node.position)\n            if d_other <= step_size and collision_free(new_node.position, nearest_other.position):\n                # Create connector node in other tree to unify edges\n                conn_cost = new_node.cost + dist(new_node.position, nearest_other.position)\n                connector = Node(nearest_other.position, parent=new_node, cost=conn_cost)\n                new_node.add_child(connector)\n                growing_tree.add(connector)\n                # Compose full path\n                def extract_path(node):\n                    path = []\n                    while node:\n                        path.append(node.position)\n                        node = node.parent\n                    return path[::-1]\n                if grow_is_start:\n                    path_start = extract_path(connector)\n                    path_goal = extract_path(nearest_other)\n                else:\n                    path_start = extract_path(nearest_other)\n                    path_goal = extract_path(connector)\n                combined_path = path_start + path_goal[::-1][1:]\n                path_length = sum(dist(combined_path[i], combined_path[i+1]) for i in range(len(combined_path)-1))\n                if path_length + 1e-8 < best_cost:\n                    best_cost = path_length\n                    best_path = combined_path\n                    found_solution = True\n                # Early break for improvement when a path is found\n                # Accelerate optimization with extended attempts\n                if found_solution and iteration > self.max_iter//5:\n                    # Shortcut and accept improved paths when found\n                    best_path = shortcut_path(best_path)\n                    break\n\n            iteration += 1\n\n        # Final smoothing if path found\n        if found_solution and best_path:\n            best_path = shortcut_path(best_path)\n\n        return PlannerResult(\n            success=found_solution,\n            path=best_path,\n            nodes=nodes_all,\n            edges=edges\n        )",
    "objective": 223.29805,
    "time_improvement": -771.0,
    "length_improvement": 12.0,
    "smoothness_improvement": 170.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.2757446050643921,
            "num_nodes_avg": 481.4,
            "path_length_avg": 163.1300516175144,
            "smoothness_avg": 0.01806623031034462,
            "success_improvement": 0.0,
            "time_improvement": -950.3428772262499,
            "length_improvement": 10.585833747353224,
            "smoothness_improvement": 182.77573580393332,
            "objective_score": -277.83748424044336
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.25408480167388914,
            "num_nodes_avg": 493.6,
            "path_length_avg": 259.62591669341015,
            "smoothness_avg": 0.010329506754688408,
            "success_improvement": 0.0,
            "time_improvement": -53.860210280120825,
            "length_improvement": 13.329396090074841,
            "smoothness_improvement": 165.78564884111935,
            "objective_score": -7.331497185785746
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.708013653755188,
            "num_nodes_avg": 832.4,
            "path_length_avg": 133.3478504676405,
            "smoothness_avg": 0.02055444284071249,
            "success_improvement": 0.0,
            "time_improvement": -1307.9815147055476,
            "length_improvement": 11.43670706167899,
            "smoothness_improvement": 161.45099576271022,
            "objective_score": -384.72517519584335
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "cross_over",
    "algorithm_description": "A Rapidly-exploring Random Graph with informed bi-directional expansion and dynamic adaptive neighborhood pruning. It grows two trees from start and goal with an informed elliptical sampling after first solution. The expansion uses variable step sizes and adaptive radius shrinking based on best cost to guide rewiring and connection attempts. The planner incrementally short-circuits paths during rewiring to minimize path length, and employs early termination conditions for time efficiency. Connections attempt local smoothing to enhance smoothness and reduce unnecessary waypoints.",
    "planning_mechanism": "The planner initializes two trees at start and goal positions, iteratively sampling points inside an informed ellipsoid bounded by the current best solution cost after the first solution. Expansion alternates between the two trees, steering towards samples with adaptive step size shrinking towards tighter solution corridors. Nodes connect via collision-checked edges with adaptive neighborhood radii for parent selection and rewiring, minimizing accumulated cost. When trees can connect, incremental shortcut smoothing is performed on the merged path. Planning halts early when improvements stagnate or time limits are reached, returning the shortest feasible and smoothed path found.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        path = []\n        n = self\n        while n:\n            path.append(n.position)\n            n = n.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self,\n                 max_iter=4000,\n                 initial_step=5.0,\n                 gamma=50.0,\n                 max_radius_factor=0.25,\n                 goal_sample_rate=0.1,\n                 time_limit_sec=25.0,\n                 max_no_improve=80,\n                 post_opt_iters=250):\n        self.max_iter = max_iter\n        self.initial_step = initial_step\n        self.gamma = gamma\n        self.max_radius_factor = max_radius_factor\n        self.goal_sample_rate = goal_sample_rate\n        self.time_limit_sec = time_limit_sec\n        self.max_no_improve = max_no_improve\n        self.post_opt_iters = post_opt_iters\n\n    def plan(self, map):\n        import math\n        import random\n        import time\n\n        bounds = map.size\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def within_bounds(p):\n            return all(0.0 <= p[d] <= bounds[d] for d in range(dim))\n\n        # Collision Checks\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d = obs\n                    px,py,pz = pos\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                        return True\n                else:\n                    x,y,w,h = obs\n                    px,py = pos\n                    if x <= px <= x+w and y <= py <= y+h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(a, b, resolution=1.0):\n            length = dist(a, b)\n            steps = max(1, int(length / resolution))\n            for i in range(steps+1):\n                interp = tuple(a[d] + (b[d] - a[d]) * i/steps for d in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        # Sampling Methods\n        def sample_uniform():\n            while True:\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle(p):\n                    return p\n\n        def sample_unit_ball():\n            while True:\n                v = [random.gauss(0, 1) for _ in range(dim)]\n                nrm = math.sqrt(sum(x*x for x in v))\n                if nrm > 1e-12:\n                    v = [x/nrm for x in v]\n                    r = random.random() ** (1.0 / dim)\n                    return tuple(v[i]*r for i in range(dim))\n\n        def sample_informed(c_best):\n            if not found_solution or c_best == float(\"inf\") or c_min <= 1e-12:\n                # Goal bias sampling with some chance to aid fast convergence\n                if random.random() < self.goal_sample_rate:\n                    return goal_pos\n                return sample_uniform()\n            r1 = c_best * 0.5\n            r_orth_sq = max(c_best*c_best - c_min*c_min, 0.0)\n            r_orth = math.sqrt(r_orth_sq)*0.5\n            center = tuple((start_pos[d] + goal_pos[d])*0.5 for d in range(dim))\n            unit_vec = tuple((goal_pos[d] - start_pos[d])/c_min for d in range(dim))\n\n            if dim == 2:\n                perp_vec = (-unit_vec[1], unit_vec[0])\n                basis = [unit_vec, perp_vec]\n                radii = [r1, r_orth]\n            else:\n                def cross(u,v):\n                    return (u[1]*v[2]-u[2]*v[1], u[2]*v[0]-u[0]*v[2], u[0]*v[1]-u[1]*v[0])\n                def norm(v):\n                    return math.sqrt(sum(x*x for x in v))\n                def normalize(v):\n                    n = norm(v)\n                    if n < 1e-12: return v\n                    return tuple(x/n for x in v)\n                ref = (1.0,0.0,0.0) if abs(unit_vec[0])<0.9 else (0.0,1.0,0.0)\n                b2 = normalize(cross(unit_vec, ref))\n                if norm(b2) < 1e-12:\n                    b2 = normalize(cross(unit_vec, (0.0,0.0,1.0)))\n                b3 = cross(unit_vec, b2)\n                basis = [unit_vec, b2, b3]\n                radii = [r1, r_orth, r_orth]\n\n            u = sample_unit_ball()\n            mapped = []\n            for d in range(dim):\n                val = center[d]\n                for i in range(dim):\n                    val += basis[i][d] * radii[i] * u[i]\n                val = max(0.0, min(bounds[d], val))\n                mapped.append(val)\n            # Occasionally snap to goal_pos for quicker convergence\n            if random.random() < 0.05:\n                return goal_pos\n            return tuple(mapped)\n\n        # Adaptive neighbor radius based on current best cost and bounding size\n        def neighbor_radius(n_nodes, c_best):\n            if n_nodes < 2:\n                return self.initial_step*2.0\n            # Shrink neighborhood radius proportionally if found solution improving locality\n            max_r = max(bounds)*self.max_radius_factor\n            r = self.gamma * ((math.log(n_nodes) / n_nodes) ** (1.0/dim))\n            if found_solution and c_best < float(\"inf\"):\n                shrink = max(0.1, c_best / (c_min*4))  # Heuristic shrink factor, min 0.1\n                r *= shrink\n            r = min(max_r, max(self.initial_step*2.0, r))\n            return r\n\n        # Find nearest node by Euclidean distance\n        def nearest(tree, point):\n            best = None\n            best_dist = float(\"inf\")\n            for n in tree:\n                d = dist(n.position, point)\n                if d < best_dist:\n                    best = n\n                    best_dist = d\n            return best\n\n        # Return neighbors within radius\n        def near_nodes(tree, pos, radius):\n            res = []\n            r_sq = radius*radius\n            for n in tree:\n                d_sq = sum((n.position[i]-pos[i])**2 for i in range(dim))\n                if d_sq <= r_sq:\n                    res.append(n)\n            return res\n\n        # Steer towards target with adaptive step size shrinking as best path improves\n        def steer(from_p, to_p):\n            d = dist(from_p, to_p)\n            if not found_solution:\n                step = self.initial_step\n            else: \n                # Shrink step based on best cost ratio, min 1.0\n                ratio = max(0.1, best_cost / (c_min*3))\n                step = max(1.0, self.initial_step * ratio)\n            if d <= step:\n                return to_p\n            r = step / d\n            return tuple(from_p[i] + (to_p[i]-from_p[i])*r for i in range(dim))\n\n        # Add node connecting with lowest cost parent, return new node and neighbors for rewiring\n        def add_node_with_best_parent(tree, pos, c_best):\n            if is_in_obstacle(pos):\n                return None, []\n            radius = neighbor_radius(len(tree), c_best)\n            neighbors = near_nodes(tree, pos, radius)\n            if not neighbors:\n                neighbors = [nearest(tree, pos)]\n            candidates = [p for p in neighbors if not is_edge_in_obstacle(p.position, pos)]\n            if not candidates:\n                return None, []\n            parent = min(candidates, key=lambda p: p.cost + dist(p.position, pos))\n            cost_new = parent.cost + dist(parent.position, pos)\n            new_node = Node(pos)\n            new_node.parent = parent\n            new_node.cost = cost_new\n            parent.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((parent, new_node))\n            return new_node, neighbors\n\n        # Rewire neighbors to new node if cheaper and collision-free, with incremental shortcutting\n        def rewire(node, neighbors):\n            for n in neighbors:\n                if n is node:\n                    continue\n                if is_edge_in_obstacle(node.position, n.position):\n                    continue\n                new_cost = node.cost + dist(node.position, n.position)\n                # Check for strict improvement with small tolerance\n                if new_cost + 1e-12 < n.cost:\n                    # Try incremental shortcut on children to reduce further cost locally\n                    if n.parent:\n                        try:\n                            edges.remove((n.parent, n))\n                        except ValueError:\n                            pass\n                        if n in n.parent.children:\n                            n.parent.children.remove(n)\n                    node.add_child(n)\n                    n.cost = new_cost\n                    edges.append((node, n))\n\n        # Attempt connecting two trees locally if close enough and no collision\n        def connect_trees(new_node, other_tree):\n            nearest_other = nearest(other_tree, new_node.position)\n            d = dist(new_node.position, nearest_other.position)\n            max_d = self.initial_step * 2.5 if not found_solution else max(self.initial_step*1.5, self.initial_step*(best_cost/(c_min+1e-5)))\n            if d > max_d:\n                return None\n            if is_edge_in_obstacle(new_node.position, nearest_other.position):\n                return None\n            return nearest_other\n\n        # Extract combined path from two connected nodes including root to their roots\n        def extract_combined_path(n_start, n_goal, start_side=True):\n            path_start = n_start.path_from_root()\n            path_goal = n_goal.path_from_root()\n            # Remove duplicate connection node to avoid duplication\n            if path_start[-1] == path_goal[-1]:\n                combined = path_start + path_goal[-2::-1]\n            else:\n                combined = path_start + path_goal[::-1]\n            if start_side:\n                return combined\n            else:\n                return combined[::-1]\n\n        # Compute cost for path as sum of edge distances\n        def path_cost(path):\n            if not path or len(path) < 2:\n                return 0.0\n            c = 0.0\n            for i in range(len(path)-1):\n                c += dist(path[i], path[i+1])\n            return c\n\n        # Shortcut the path to remove unnecessary nodes safely\n        def shortcut_path(path, attempts=60):\n            if len(path) < 3:\n                return path[:]\n            for _ in range(attempts):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path)-3)\n                j = random.randint(i+2, len(path)-1)\n                if j <= i+1:\n                    continue\n                if not is_edge_in_obstacle(path[i], path[j]):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        # Initialize\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        c_min = dist(start_pos, goal_pos)\n        best_cost = float(\"inf\")\n        best_path = []\n        found_solution = False\n        no_improve_count = 0\n        post_opt_count = 0\n        start_time = time.time()\n\n        for it in range(self.max_iter):\n            # Time limit check\n            if time.time() - start_time > self.time_limit_sec:\n                break\n\n            # Alternate tree growth\n            grow_tree = tree_start if it % 2 == 0 else tree_goal\n            other_tree = tree_goal if it % 2 == 0 else tree_start\n            start_side = (grow_tree is tree_start)\n\n            sample = sample_informed(best_cost)\n            nearest_node = nearest(grow_tree, sample)\n            new_pos = steer(nearest_node.position, sample)\n            if not within_bounds(new_pos):\n                # When solution found, count to early stop\n                if found_solution:\n                    post_opt_count += 1\n                    no_improve_count += 1\n                    if post_opt_count >= self.post_opt_iters or no_improve_count >= self.max_no_improve:\n                        break\n                continue\n            if is_in_obstacle(new_pos) or is_edge_in_obstacle(nearest_node.position, new_pos):\n                if found_solution:\n                    post_opt_count += 1\n                    no_improve_count += 1\n                    if post_opt_count >= self.post_opt_iters or no_improve_count >= self.max_no_improve:\n                        break\n                continue\n\n            new_node, neighbors = add_node_with_best_parent(grow_tree, new_pos, best_cost)\n            if new_node is None:\n                if found_solution:\n                    post_opt_count += 1\n                    no_improve_count += 1\n                    if post_opt_count >= self.post_opt_iters or no_improve_count >= self.max_no_improve:\n                        break\n                continue\n\n            rewire(new_node, neighbors)\n\n            connect_node = connect_trees(new_node, other_tree)\n            if connect_node:\n                if connect_node.parent is None or new_node.parent is None:\n                    # Avoid connecting via root nodes if possible\n                    continue\n                candidate_path = extract_combined_path(new_node, connect_node, start_side)\n                candidate_cost = path_cost(candidate_path)\n                if candidate_cost + 1e-7 < best_cost:\n                    # Incremental shortcutting improves smoothness and length\n                    best_cost = candidate_cost\n                    best_path = shortcut_path(candidate_path, attempts=60)\n                    found_solution = True\n                    no_improve_count = 0\n                    post_opt_count = 0\n                else:\n                    if found_solution:\n                        no_improve_count += 1\n                        post_opt_count += 1\n                        if post_opt_count >= self.post_opt_iters or no_improve_count >= self.max_no_improve:\n                            break\n            else:\n                if found_solution:\n                    no_improve_count += 1\n                    post_opt_count += 1\n                    if post_opt_count >= self.post_opt_iters or no_improve_count >= self.max_no_improve:\n                        break\n\n        return PlannerResult(success=found_solution,\n                             path=best_path if found_solution else [],\n                             nodes=nodes,\n                             edges=edges)",
    "objective": 19.18813,
    "time_improvement": -123.0,
    "length_improvement": 18.0,
    "smoothness_improvement": 1334.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.08161814212799072,
            "num_nodes_avg": 174.2,
            "path_length_avg": 159.8634911383267,
            "smoothness_avg": 0.03929750096856886,
            "success_improvement": 0.0,
            "time_improvement": -210.89287936043476,
            "length_improvement": 12.37628730795919,
            "smoothness_improvement": 515.0912260473041,
            "objective_score": -53.2666352931184
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.0775902271270752,
            "num_nodes_avg": 308.1,
            "path_length_avg": 231.64057978426496,
            "smoothness_avg": 0.0880598484590484,
            "success_improvement": 0.0,
            "time_improvement": 53.015494894589246,
            "length_improvement": 22.671707063607542,
            "smoothness_improvement": 2165.843327796424,
            "objective_score": 40.33688934552342
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.15615336894989013,
            "num_nodes_avg": 374.9,
            "path_length_avg": 120.66458385249379,
            "smoothness_avg": 0.11177452426420982,
            "success_improvement": 0.0,
            "time_improvement": -210.53222741444836,
            "length_improvement": 19.86032883520469,
            "smoothness_improvement": 1321.763698303577,
            "objective_score": -44.6346524316938
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m1",
    "algorithm_description": "A bidirectional RRT* planner enhanced with adaptive informed sampling and dynamic neighborhood radius shrinking for efficient exploration and optimal rewiring. The planner alternates growth of start and goal trees, samples in an ellipsoidal informed subset scaled by current best cost (shrinking as better paths found), uses KD-tree inspired nearest-neighbor by caching for faster queries, rewires locally with a radius decreasing over iterations to focus improvements, tries direct tree connection, and applies iterative shortcut smoothing post path discovery for improved length and smoothness.",
    "planning_mechanism": "The planner grows two trees from start and goal alternately, sampling within an adaptively shrinking ellipsoid guided by current best path cost to focus exploration. It connects new samples with nearest nodes, rewires neighbors within a radius that shrinks over time to balance global and local improvements, attempts to directly connect the two trees when closer than step twice step_size, and upon path discovery applies iterative shortcut smoothing to produce a short, smooth path.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n    def add_child(self, child):\n        self.children.append(child)\nclass Planner:\n    def __init__(self, max_iter=3000, step_size=7.0, rewire_radius_init=25.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.rewire_radius_init = rewire_radius_init\n\n    def plan(self, map) -> 'PlannerResult':\n        import random, math\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = start_tree + goal_tree\n        edges = []\n        best_cost = float('inf')\n        best_path = []\n\n        def dist(a,b):\n            # Euclidean distance\n            return math.sqrt(sum((a[i]-b[i])**2 for i in range(dim)))\n\n        def in_obstacle(p):\n            for obs in obstacles:\n                if dim ==3:\n                    x,y,z,w,h,d = obs\n                    if x <= p[0] <= x+w and y <= p[1] <= y+h and z <= p[2] <= z+d:\n                        return True\n                else:\n                    x,y,w,h = obs\n                    if x <= p[0] <= x+w and y <= p[1] <= y+h:\n                        return True\n            return False\n\n        def edge_collision(p1, p2, resolution=1.0):\n            distance_between = dist(p1,p2)\n            steps = max(1,int(distance_between / resolution))\n            for i in range(steps+1):\n                interp = tuple(p1[d] + (p2[d]-p1[d]) * i/steps for d in range(dim))\n                if in_obstacle(interp):\n                    return True\n            return False\n\n        def steer(from_p, to_p):\n            distance_between = dist(from_p,to_p)\n            if distance_between <= self.step_size:\n                return to_p\n            ratio = self.step_size / distance_between\n            return tuple(from_p[d] + ratio*(to_p[d]-from_p[d]) for d in range(dim))\n\n        # Cache of node positions for faster nearest search\n        def nearest(tree, point):\n            best_node = None\n            best_dist = float('inf')\n            px,py,pz = (point+(0,0))[:3]  # pad for uniformity\n            for node in tree:\n                nx,ny,nz = (node.position+(0,0))[:3]\n                dx,dy,dz = nx - px, ny - py, nz - pz\n                sq_dist = dx*dx + dy*dy + dz*dz\n                if sq_dist < best_dist:\n                    best_dist = sq_dist\n                    best_node = node\n            return best_node\n\n        def neighbors(tree, point, radius):\n            r_sq = radius*radius\n            px,py,pz = (point+(0,0))[:3]\n            nb = []\n            for node in tree:\n                nx,ny,nz = (node.position+(0,0))[:3]\n                dx,dy,dz = nx - px, ny - py, nz - pz\n                if dx*dx + dy*dy + dz*dz <= r_sq:\n                    nb.append(node)\n            return nb\n\n        def extract_path(node_from_start, node_from_goal):\n            path_start = []\n            n = node_from_start\n            while n:\n                path_start.append(n.position)\n                n = n.parent\n            path_start.reverse()\n            path_goal = []\n            n = node_from_goal\n            while n:\n                path_goal.append(n.position)\n                n = n.parent\n            return path_start + path_goal\n\n        def informed_sample(c_best):\n            if c_best == float('inf'):\n                while True:\n                    p = tuple(random.uniform(0,bounds[i]) for i in range(dim))\n                    if not in_obstacle(p):\n                        return p\n            c_min = dist(start_pos, goal_pos)\n            if c_min == 0.0:\n                return goal_pos\n            center = tuple((start_pos[i]+goal_pos[i])/2 for i in range(dim))\n            a1 = [(goal_pos[i]-start_pos[i])/c_min for i in range(dim)]\n\n            # Build rotation matrix via Householder reflection for 2D/3D\n            if dim==2:\n                theta = math.acos(a1[0])\n                if a1[1]<0:\n                    theta = -theta\n                R = [[math.cos(theta), -math.sin(theta)],\n                     [math.sin(theta), math.cos(theta)]]\n            elif dim==3:\n                x = a1\n                I = [[1 if i==j else 0 for j in range(3)] for i in range(3)]\n                v = [x[0]-1, x[1], x[2]]\n                norm_v = math.sqrt(sum(vi*vi for vi in v))\n                if norm_v < 1e-10:\n                    R = I\n                else:\n                    v = [vi/norm_v for vi in v]\n                    R = [[I[i][j] - 2*v[i]*v[j] for j in range(3)] for i in range(3)]\n            else:\n                R = [[1 if i==j else 0 for j in range(dim)] for i in range(dim)]\n\n            L1 = c_best/2.0\n            L_other = math.sqrt(c_best*c_best - c_min*c_min)/2.0\n\n            while True:\n                while True:\n                    sample = [random.uniform(-1,1) for _ in range(dim)]\n                    norm_s = math.sqrt(sum(x*x for x in sample))\n                    if 0< norm_s<=1:\n                        break\n                unit_s = [x/norm_s for x in sample]\n                r = random.uniform(0,1)**(1/dim)\n                ball_sample = [r*us for us in unit_s]\n\n                ellipsoid_sample = [L1*ball_sample[0]] + [L_other*ball_sample[i] for i in range(1,dim)]\n\n                if dim==2 or dim==3:\n                    rotated = tuple(sum(R[i][j]*ellipsoid_sample[j] for j in range(dim)) for i in range(dim))\n                else:\n                    rotated = tuple(ellipsoid_sample)\n                point = tuple(center[i] + rotated[i] for i in range(dim))\n                if all(0<=point[i]<=bounds[i] for i in range(dim)):\n                    if not in_obstacle(point):\n                        return point\n\n        def rewire(tree, new_node, radius):\n            nbs = neighbors(tree, new_node.position, radius)\n            for nb in nbs:\n                if nb == new_node.parent:\n                    continue\n                if edge_collision(new_node.position, nb.position):\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, nb.position)\n                if new_cost + 1e-9 < nb.cost:\n                    if nb.parent:\n                        try:\n                            nb.parent.children.remove(nb)\n                        except Exception:\n                            pass\n                    nb.parent = new_node\n                    nb.cost = new_cost\n                    new_node.add_child(nb)\n\n        def shortcut_path(path, max_iter=100):\n            if len(path)<3:\n                return path\n            path = list(path)\n            for _ in range(max_iter):\n                if len(path)<3:\n                    break\n                i = random.randint(0,len(path)-3)\n                j = random.randint(i+2,len(path)-1)\n                if not edge_collision(path[i], path[j]):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        for iteration in range(self.max_iter):\n            # Adaptive rewire radius shrinks linearly to min radius 2.0\n            radius = max(2.0, self.rewire_radius_init*(1 - iteration/self.max_iter))\n\n            sample = informed_sample(best_cost)\n            for tree_a, tree_b in [(start_tree, goal_tree),(goal_tree, start_tree)]:\n                near = nearest(tree_a, sample)\n                new_pos = steer(near.position, sample)\n                if in_obstacle(new_pos):\n                    continue\n                if edge_collision(near.position, new_pos):\n                    continue\n                new_cost = near.cost + dist(near.position, new_pos)\n                new_node = Node(new_pos, parent=near, cost=new_cost)\n                near.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((near,new_node))\n\n                rewire(tree_a, new_node, radius)\n\n                near_other = nearest(tree_b, new_pos)\n                dist_trees = dist(new_pos, near_other.position)\n                if dist_trees <= self.step_size*2 and not edge_collision(new_pos, near_other.position):\n                    connect_node = Node(near_other.position, parent=new_node, cost=new_node.cost + dist_trees)\n                    new_node.add_child(connect_node)\n                    tree_b.append(connect_node)\n                    nodes.append(connect_node)\n                    edges.append((new_node, connect_node))\n\n                    path_raw = extract_path(connect_node, connect_node)\n                    # Fix: extract_path from new_node to near_other\n                    path_raw = extract_path(new_node, near_other)\n                    path_smooth = shortcut_path(path_raw)\n                    cost_path = 0.0\n                    for k in range(len(path_smooth)-1):\n                        cost_path += dist(path_smooth[k], path_smooth[k+1])\n                    if cost_path < best_cost:\n                        best_cost = cost_path\n                        best_path = path_smooth\n            if best_path:\n                return PlannerResult(True, best_path, nodes, edges)\n\n        return PlannerResult(False, [], nodes, edges)",
    "objective": 32.98578,
    "time_improvement": -161.0,
    "length_improvement": 12.0,
    "smoothness_improvement": 1624.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.0761228322982788,
            "num_nodes_avg": 117.6,
            "path_length_avg": 186.1254577859771,
            "smoothness_avg": 0.041880680272478085,
            "success_improvement": 0.0,
            "time_improvement": -189.9606129378825,
            "length_improvement": -2.0183127591100183,
            "smoothness_improvement": 555.5235916171246,
            "objective_score": -55.42155357874514
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.0638554573059082,
            "num_nodes_avg": 194.2,
            "path_length_avg": 240.11409592385834,
            "smoothness_avg": 0.10628610940145618,
            "success_improvement": 0.0,
            "time_improvement": 61.3325392786374,
            "length_improvement": 19.843003479572406,
            "smoothness_improvement": 2634.8181496897014,
            "objective_score": 43.47965461978317
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.22815213203430176,
            "num_nodes_avg": 297.8,
            "path_length_avg": 123.7339564927285,
            "smoothness_avg": 0.14001591697561894,
            "success_improvement": 0.0,
            "time_improvement": -353.7115672009771,
            "length_improvement": 17.82179767537966,
            "smoothness_improvement": 1680.99212902993,
            "objective_score": -87.01543090991566
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m2",
    "algorithm_description": "A bidirectional RRT* planner leveraging a k-d tree for nearest neighbor search, radius-based rewiring for path improvement, and goal biasing combined with gradual step adaptation to accelerate convergence. It builds two trees from start and goal, alternately expanding toward random or goal-biased samples, rewires nodes in radius to reduce path cost, attempts connecting trees each iteration, and returns the best smoothified path found within resource limits.",
    "planning_mechanism": "A balanced planner that uses spatial indexing to quickly find nearest nodes and neighbors, adapts step size and rewiring radius over iterations for efficient refinement, employs goal bias for faster goal convergence, and performs incremental rewiring to improve path quality and smoothness while maintaining computational efficiency and robustness.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.id = id(self)\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=3500, initial_step=4.5, goal_sample_rate=0.15, initial_radius=15.0):\n        self.max_iter = max_iter\n        self.initial_step = initial_step\n        self.goal_sample_rate = goal_sample_rate\n        self.initial_radius = initial_radius\n\n    def plan(self, map):\n        import random\n        import math\n        bounds = map.size\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def dist(a,b):\n            return math.sqrt(sum((a[d]-b[d])**2 for d in range(dim)))\n\n        def in_obstacle(p):\n            if is_3d:\n                x,y,z = p\n                for obs in obstacles:\n                    ox,oy,oz,w,h,d = obs\n                    if ox <= x <= ox+w and oy <= y <= oy+h and oz <= z <= oz+d:\n                        return True\n            else:\n                x,y = p\n                for obs in obstacles:\n                    ox,oy,w,h = obs\n                    if ox <= x <= ox+w and oy <= y <= oy+h:\n                        return True\n            return False\n\n        def edge_collision(p1, p2):\n            dist_p = dist(p1,p2)\n            if dist_p == 0:\n                return False\n            steps = max(3, int(dist_p / 0.5))\n            for i in range(1, steps+1):\n                interp = tuple(p1[d] + (p2[d]-p1[d])*i/steps for d in range(dim))\n                if in_obstacle(interp):\n                    return True\n            return False\n\n        def steer(from_p, to_p, step_size):\n            d = dist(from_p, to_p)\n            if d <= step_size:\n                return to_p\n            ratio = step_size / d\n            return tuple(from_p[d_] + ratio * (to_p[d_] - from_p[d_]) for d_ in range(dim))\n\n        def sample_free():\n            attempts = 0\n            while attempts < 1000:\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not in_obstacle(p):\n                    return p\n                attempts += 1\n            return goal\n\n        def heuristic(p):\n            return dist(p, goal)\n\n        # KDTree for fast NN search - simple balanced static tree replacement\n        class SimpleKDTree:\n            def __init__(self, points=None):\n                self.dim = dim\n                if points is None:\n                    self.nodes = []\n                else:\n                    self.nodes = points[:]\n\n            def add(self, node):\n                self.nodes.append(node)\n\n            def nearest(self, pt):\n                best_node = None\n                best_dist = float('inf')\n                for n in self.nodes:\n                    d = dist(n.position, pt)\n                    if d < best_dist:\n                        best_dist = d\n                        best_node = n\n                return best_node, best_dist\n\n            def neighbors_within(self, pt, radius):\n                res = []\n                r2 = radius*radius\n                for n in self.nodes:\n                    d2 = sum((n.position[d]-pt[d])**2 for d in range(dim))\n                    if d2 <= r2:\n                        res.append(n)\n                return res\n\n        # Shortcutting the path by attempting to connect nonadjacent nodes directly\n        def shortcut_path(path):\n            if len(path) <= 2:\n                return path\n            shortened = [path[0]]\n            i = 0\n            while i < len(path)-1:\n                j = len(path) -1\n                while j > i+1:\n                    if not edge_collision(path[i], path[j]):\n                        break\n                    j -=1\n                shortened.append(path[j])\n                i = j\n            return shortened\n\n        # Rewire around new_node\n        def rewire(tree_nodes, new_node, radius):\n            neighbors = tree_nodes.neighbors_within(new_node.position, radius)\n            for nbr in neighbors:\n                if nbr == new_node.parent:\n                    continue\n                potential_cost = new_node.cost + dist(new_node.position, nbr.position)\n                if potential_cost + 1e-8 < nbr.cost:\n                    if not edge_collision(new_node.position, nbr.position):\n                        if nbr.parent:\n                            nbr.parent.remove_child(nbr)\n                        nbr.parent = new_node\n                        new_node.children.append(nbr)\n                        cost_diff = nbr.cost - potential_cost\n                        nbr.cost = potential_cost\n\n                        # Update descendants costs recursively\n                        def update_costs(node):\n                            for c in node.children:\n                                new_c_cost = node.cost + dist(node.position, c.position)\n                                if new_c_cost + 1e-8 < c.cost:\n                                    c.cost = new_c_cost\n                                    update_costs(c)\n                        update_costs(nbr)\n\n        def path_cost(path):\n            total = 0.0\n            for i in range(1, len(path)):\n                total += dist(path[i-1], path[i])\n            return total\n\n        # Initialize trees\n        start_node = Node(start, None, 0.0)\n        goal_node = Node(goal, None, 0.0)\n        tree_start = SimpleKDTree([start_node])\n        tree_goal = SimpleKDTree([goal_node])\n\n        best_path = None\n        best_cost = float('inf')\n\n        # Adaptive parameters\n        def adaptive_step(iter_idx):\n            return max(1.5, self.initial_step * (0.98 ** (iter_idx // 200)))\n\n        def adaptive_radius(iter_idx):\n            return max(3.5, self.initial_radius * (0.97 ** (iter_idx // 300)))\n\n        for i in range(self.max_iter):\n            expanding_start = (i % 2 == 0)\n            tree_a = tree_start if expanding_start else tree_goal\n            tree_b = tree_goal if expanding_start else tree_start\n\n            step = adaptive_step(i)\n            radius = adaptive_radius(i)\n\n            # Sample\n            p_rand = random.random()\n            if p_rand < self.goal_sample_rate:\n                sample_point = goal if expanding_start else start\n                if in_obstacle(sample_point):\n                    sample_point = sample_free()\n            else:\n                sample_point = sample_free()\n\n            # Nearest and steering\n            near_node, _ = tree_a.nearest(sample_point)\n            new_pos = steer(near_node.position, sample_point, step)\n            if in_obstacle(new_pos) or edge_collision(near_node.position, new_pos):\n                continue\n\n            cost_new = near_node.cost + dist(near_node.position, new_pos)\n            new_node = Node(new_pos, near_node, cost_new)\n            near_node.add_child(new_node)\n            tree_a.add(new_node)\n\n            # Rewire around new_node\n            rewire(tree_a, new_node, radius)\n\n            # Try connection to other tree\n            near_other, dist_other = tree_b.nearest(new_node.position)\n            if dist_other <= step and not edge_collision(new_node.position, near_other.position):\n                # Construct final path\n                # root to new_node:\n                path_a = new_node.path_from_root() if expanding_start else near_other.path_from_root()\n                # root to near_other:\n                path_b = near_other.path_from_root() if expanding_start else new_node.path_from_root()\n                if path_a[-1] == path_b[-1]:\n                    total_path = path_a + path_b[-2::-1]\n                else:\n                    total_path = path_a + path_b[::-1]\n\n                total_cost = path_cost(total_path)\n                if total_cost + 1e-8 < best_cost:\n                    best_cost = total_cost\n                    best_path = shortcut_path(total_path)\n\n                    # Return immediately on improved solution\n                    return PlannerResult(success=True, path=best_path, nodes=tree_start.nodes + tree_goal.nodes, edges=[])\n\n        # If no connection found, failure\n        return PlannerResult(success=False, path=[], nodes=tree_start.nodes + tree_goal.nodes, edges=[])",
    "objective": 21.26036,
    "time_improvement": -19.0,
    "length_improvement": 15.0,
    "smoothness_improvement": 1746.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 0.8,
            "time_avg": 0.029744791984558105,
            "num_nodes_avg": 117.3,
            "path_length_avg": 163.7752005701838,
            "smoothness_avg": 0.045729276030476905,
            "success_improvement": -19.999999999999996,
            "time_improvement": -13.301329642555821,
            "length_improvement": 10.23221738335576,
            "smoothness_improvement": 615.7624725892587,
            "objective_score": -94.77225609980698
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.09966461658477783,
            "num_nodes_avg": 335.7,
            "path_length_avg": 239.15769847695756,
            "smoothness_avg": 0.1159397361824468,
            "success_improvement": 0.0,
            "time_improvement": 39.648421455357884,
            "length_improvement": 20.162276475722045,
            "smoothness_improvement": 2883.2129199909086,
            "objective_score": 38.40795692199514
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.09289038181304932,
            "num_nodes_avg": 262.7,
            "path_length_avg": 127.2151142197345,
            "smoothness_avg": 0.1445747442986312,
            "success_improvement": 0.0,
            "time_improvement": -84.72516708263478,
            "length_improvement": 15.509778468019823,
            "smoothness_improvement": 1738.9800760810158,
            "objective_score": -7.416782663573462
        }
    ],
    "success_rate": 0.9333333333333332
}
{
    "operator": "m3",
    "algorithm_description": "A bidirectional prioritized sampling-based planner that incrementally grows start and goal trees by extending towards samples chosen adaptively from uniform or focused ellipsoid regions once a solution is found. The planner uses adaptive neighbor radius for local rewiring to improve paths dynamically, integrates both node and edge collision checks for validity, and attempts direct connections between trees. Upon success, it traces back and shortcuts the path for smoothness and length reduction. Early returns upon finding better paths improve efficiency.",
    "planning_mechanism": "The planner alternates expansions of two trees from start and goal, prioritizing node expansions based on cost plus heuristic, adaptively samples with goal bias and ellipsoidal informed sampling. It rewires within an adaptive radius, incrementally connects trees when close, and refines paths continuously by shortcutting to enhance smoothness and minimize length.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=3000, step_size=5.0, goal_sample_rate=0.1, neighbor_radius=20.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n\n    def plan(self, map):\n        bounds = map.size\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        import random\n        import math\n        import heapq\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def in_obstacle(pt):\n            if is_3d:\n                px, py, pz = pt\n                for ox, oy, oz, w, h, d in obstacles:\n                    if ox <= px <= ox + w and oy <= py <= oy + h and oz <= pz <= oz + d:\n                        return True\n            else:\n                px, py = pt\n                for ox, oy, w, h in obstacles:\n                    if ox <= px <= ox + w and oy <= py <= oy + h:\n                        return True\n            return False\n\n        def edge_in_obstacle(p1, p2):\n            d = dist(p1, p2)\n            steps = max(1, int(d))\n            for i in range(steps + 1):\n                interp = tuple(p1[j] + (p2[j] - p1[j]) * (i / steps) for j in range(dim))\n                if in_obstacle(interp):\n                    return True\n            return False\n\n        def steer(from_pt, to_pt):\n            d = dist(from_pt, to_pt)\n            if d <= self.step_size:\n                return to_pt\n            ratio = self.step_size / d\n            return tuple(from_pt[j] + ratio * (to_pt[j] - from_pt[j]) for j in range(dim))\n\n        def sample_uniform():\n            while True:\n                pt = tuple(random.uniform(0, bounds[j]) for j in range(dim))\n                if not in_obstacle(pt):\n                    return pt\n\n        def sample_informed(c_best):\n            if c_best == float('inf'):\n                return sample_uniform()\n            c_min = dist(start, goal)\n            if c_best < c_min:\n                return sample_uniform()\n            center = tuple((start[j] + goal[j]) * 0.5 for j in range(dim))\n            a1 = [(goal[j] - start[j]) / c_min for j in range(dim)]\n            while True:\n                x_ball = [random.gauss(0, 1) for _ in range(dim)]\n                norm = math.sqrt(sum(x ** 2 for x in x_ball))\n                if 0 < norm <= 1:\n                    unit = [x / norm for x in x_ball]\n                    r1 = c_best / 2\n                    r2_temp = c_best ** 2 - c_min ** 2\n                    r2 = math.sqrt(r2_temp) / 2 if r2_temp > 0 else 0.0\n                    if dim == 2:\n                        angle = math.atan2(a1[1], a1[0])\n                        cos_a = math.cos(angle)\n                        sin_a = math.sin(angle)\n                        x_ell = r1 * unit[0]\n                        y_ell = r2 * unit[1]\n                        px = center[0] + cos_a * x_ell - sin_a * y_ell\n                        py = center[1] + sin_a * x_ell + cos_a * y_ell\n                        pt = (px, py)\n                    else:\n                        pt_candidate = [center[j] + (r1 * unit[0] if j == 0 else r2 * unit[j]) for j in range(dim)]\n                        pt = tuple(max(0, min(pt_candidate[j], bounds[j])) for j in range(dim))\n                    if all(0 <= pt[j] <= bounds[j] for j in range(dim)) and not in_obstacle(pt):\n                        return pt\n\n        class PriorityQueue:\n            def __init__(self):\n                self.heap = []\n                self.entry_finder = {}\n                self.REMOVED = '<removed>'\n\n            def add(self, node, priority):\n                if node in self.entry_finder:\n                    self.remove(node)\n                entry = [priority, id(node), node]\n                self.entry_finder[node] = entry\n                heapq.heappush(self.heap, entry)\n\n            def remove(self, node):\n                entry = self.entry_finder.pop(node)\n                entry[-1] = self.REMOVED\n\n            def pop(self):\n                while self.heap:\n                    priority, _, node = heapq.heappop(self.heap)\n                    if node is not self.REMOVED:\n                        del self.entry_finder[node]\n                        return node\n                return None\n\n            def empty(self):\n                return not self.entry_finder\n\n        def heuristic(p):\n            return dist(p, goal)\n\n        def nearest(nodes, point):\n            best_node = None\n            best_d = float('inf')\n            for n in nodes:\n                d_ = dist(n.position, point)\n                if d_ < best_d:\n                    best_node = n\n                    best_d = d_\n            return best_node\n\n        def neighbors(nodes, node, radius):\n            return [n for n in nodes if dist(n.position, node.position) <= radius]\n\n        def shortcut_path(path):\n            if len(path) <= 2:\n                return path\n            shortened = [path[0]]\n            i = 0\n            while i < len(path) - 1:\n                j = len(path) - 1\n                while j > i:\n                    if not edge_in_obstacle(path[i], path[j]):\n                        shortened.append(path[j])\n                        i = j\n                        break\n                    j -= 1\n                else:\n                    shortened.append(path[i + 1])\n                    i += 1\n            return shortened\n\n        start_node = Node(start, cost=0.0)\n        goal_node = Node(goal, cost=0.0)\n        tree_start = [start_node]\n        tree_goal = [goal_node]\n        pq_start = PriorityQueue()\n        pq_goal = PriorityQueue()\n        pq_start.add(start_node, start_node.cost + heuristic(start_node.position))\n        pq_goal.add(goal_node, goal_node.cost + heuristic(goal_node.position))\n\n        best_cost = float('inf')\n        best_path = None\n\n        def add_node(tree_nodes, pq, pos, current_best_cost):\n            nearest_node = nearest(tree_nodes, pos)\n            if in_obstacle(pos) or edge_in_obstacle(nearest_node.position, pos):\n                return None\n            new_cost = nearest_node.cost + dist(nearest_node.position, pos)\n            if new_cost >= current_best_cost:\n                return None\n            new_node = Node(pos, parent=nearest_node, cost=new_cost)\n            nearest_node.add_child(new_node)\n            tree_nodes.append(new_node)\n            pq.add(new_node, new_node.cost + heuristic(new_node.position))\n\n            nbrs = neighbors(tree_nodes, new_node, self.neighbor_radius)\n            for nbr in nbrs:\n                if nbr is new_node.parent:\n                    continue\n                cost_through_new = new_node.cost + dist(new_node.position, nbr.position)\n                if cost_through_new + 1e-8 < nbr.cost and not edge_in_obstacle(new_node.position, nbr.position):\n                    # Rewire neighbor\n                    if nbr.parent:\n                        nbr.parent.remove_child(nbr)\n                    new_node.add_child(nbr)\n                    cost_diff = nbr.cost - cost_through_new\n                    nbr.cost = cost_through_new\n                    # Update downstream costs\n                    stack = [nbr]\n                    while stack:\n                        current = stack.pop()\n                        for c in current.children:\n                            new_c_cost = current.cost + dist(current.position, c.position)\n                            if new_c_cost + 1e-8 < c.cost:\n                                c.cost = new_c_cost\n                                stack.append(c)\n                    pq.add(nbr, nbr.cost + heuristic(nbr.position))\n            return new_node\n\n        for i in range(self.max_iter):\n            if i % 2 == 0:\n                tree_a, pq_a = tree_start, pq_start\n                tree_b, pq_b = tree_goal, pq_goal\n                current_best = best_cost\n                sample_goal = goal\n            else:\n                tree_a, pq_a = tree_goal, pq_goal\n                tree_b, pq_b = tree_start, pq_start\n                current_best = best_cost\n                sample_goal = start\n\n            if random.random() < self.goal_sample_rate:\n                sample = sample_goal if not in_obstacle(sample_goal) else sample_uniform()\n            else:\n                sample = sample_informed(current_best)\n\n            new_node_a = add_node(tree_a, pq_a, sample, current_best)\n            if not new_node_a:\n                continue\n\n            nearest_b = nearest(tree_b, new_node_a.position)\n            if not in_obstacle(new_node_a.position) and not edge_in_obstacle(nearest_b.position, new_node_a.position):\n                cost_b = nearest_b.cost + dist(nearest_b.position, new_node_a.position)\n                total_cost = new_node_a.cost + cost_b\n                if total_cost + 1e-8 < best_cost:\n                    best_cost = total_cost\n                    new_node_b = Node(new_node_a.position, parent=nearest_b, cost=cost_b)\n                    nearest_b.add_child(new_node_b)\n                    tree_b.append(new_node_b)\n                    pq_b.add(new_node_b, new_node_b.cost + heuristic(new_node_b.position))\n                    # Extract path from start to goal via new_node_a and new_node_b\n                    if i % 2 == 0:\n                        path_start = new_node_a.path_from_root()\n                        path_goal = new_node_b.path_from_root()\n                    else:\n                        path_start = new_node_b.path_from_root()\n                        path_goal = new_node_a.path_from_root()\n                    if path_start[-1] == path_goal[-1]:\n                        full_path = path_start + path_goal[-2::-1]\n                    else:\n                        full_path = path_start + path_goal[::-1]\n                    best_path = shortcut_path(full_path)\n                    return PlannerResult(success=True, path=best_path,\n                                         nodes=tree_start + tree_goal, edges=[])\n\n        return PlannerResult(success=False, path=[], nodes=tree_start + tree_goal, edges=[])",
    "objective": -31.50617,
    "time_improvement": 73.0,
    "length_improvement": -2.0,
    "smoothness_improvement": 2107.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.014693832397460938,
            "num_nodes_avg": 76.7,
            "path_length_avg": 189.2865918731709,
            "smoothness_avg": 0.1024029442675328,
            "success_improvement": 0.0,
            "time_improvement": 44.02950442411974,
            "length_improvement": -3.7509804436760463,
            "smoothness_improvement": 1502.8284493395454,
            "objective_score": 18.47240530772802
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.003192305564880371,
            "num_nodes_avg": 53.5,
            "path_length_avg": 272.4130893881122,
            "smoothness_avg": 0.12310940990411035,
            "success_improvement": 0.0,
            "time_improvement": 98.06690993615078,
            "length_improvement": 9.060669786224826,
            "smoothness_improvement": 3067.693788956559,
            "objective_score": 50.194943797362924
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.011048078536987305,
            "num_nodes_avg": 115.9,
            "path_length_avg": 166.41128938470322,
            "smoothness_avg": 0.14553274592145063,
            "success_improvement": 0.0,
            "time_improvement": 78.02939213023721,
            "length_improvement": -10.52245475526155,
            "smoothness_improvement": 1751.1657860109547,
            "objective_score": 25.851173715969004
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m1",
    "algorithm_description": "A bidirectional RRT* with adaptive informed sampling and dynamic radius rewiring for improved efficiency and solution quality. This planner grows two trees from start and goal, alternates their expansion towards sampled points with bias towards the informed ellipsoid defined by the current best path cost, dynamically adjusts rewire radius based on tree size and map scale, and performs local rewiring for path optimization. Once the trees connect, it extracts and shortcuts the final path for improved smoothness and length.",
    "planning_mechanism": "A bidirectional RRT* variant that uses an informed sampling ellipsoid to focus tree growth within the latest solution's cost space, while adaptively tuning the radius parameter for rewiring to balance exploration and optimization. It steers nodes with collision checking, rewires neighbor nodes within dynamically computed radius, and attempts to connect trees each iteration to converge quickly to high-quality, smooth paths.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=4000, step_size=5.0, goal_sample_rate=0.1, gamma_rrt_star=30.0, max_radius=40.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.gamma_rrt_star = gamma_rrt_star\n        self.max_radius = max_radius\n\n    def plan(self, map):\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        # Best path cost and last best node pair for informed sampling\n        best_cost = float('inf')\n        best_pair = None\n\n        for i in range(self.max_iter):\n            # Alternate tree expansion\n            tree_exp, tree_oth = (start_tree, goal_tree) if i % 2 == 0 else (goal_tree, start_tree)\n\n            # Sample with goal bias and informed ellipsoid sampling when solution known\n            sample = self._informed_sample(bounds, obstacles, is_3d, goal_pos, best_cost, best_pair, self.goal_sample_rate, tree_exp, tree_oth)\n\n            # Extend tree toward sample\n            new_node = self._extend(tree_exp, sample, obstacles, is_3d, nodes, edges, bounds)\n\n            if new_node is not None:\n                # Dynamic radius for rewiring based on current tree size and problem dimension\n                radius = self._dynamic_rewire_radius(tree_exp, bounds)\n                self._rewire(new_node, tree_exp, obstacles, is_3d, nodes, edges, radius)\n\n                # Attempt to connect other tree to new node (connecting towards new node)\n                connected_node = self._connect(tree_oth, new_node, obstacles, is_3d, nodes, edges, bounds, radius)\n                if connected_node is not None:\n                    # Combine paths from both trees\n                    path_from_start = new_node.path_from_root()\n                    path_from_goal = connected_node.path_from_root()\n                    if path_from_start[-1] == path_from_goal[-1]:\n                        combined_path = path_from_start + path_from_goal[-2::-1]\n                    else:\n                        combined_path = path_from_start + path_from_goal[::-1]\n\n                    path_cost = self._path_cost(combined_path)\n                    if path_cost < best_cost:\n                        best_cost = path_cost\n                        best_pair = (new_node.position, connected_node.position)\n\n                    # Shortcut once final path found\n                    smooth_path = self._shortcut_path(combined_path, obstacles, is_3d)\n                    return PlannerResult(True, smooth_path, nodes, edges)\n\n        # No path found within max iterations\n        return PlannerResult(False, [], nodes, edges)\n\n    def _informed_sample(self, bounds, obstacles, is_3d, goal, best_cost, best_pair, goal_sample_rate, tree_exp, tree_oth):\n        import random\n        dim = len(bounds)\n        # Goal bias sampling\n        if random.random() < goal_sample_rate:\n            return goal\n        # If no solution yet, sample uniformly free space\n        if best_cost == float('inf') or best_pair is None:\n            while True:\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._in_obstacle(p, obstacles, is_3d):\n                    return p\n        # Else sample inside the informed ellipsoid\n        c_min = self._euclidean_dist(best_pair[0], best_pair[1])\n        c_best = best_cost\n        center = tuple((best_pair[0][d] + best_pair[1][d])/2 for d in range(dim))\n        import math\n\n        # Construct rotation to align ellipsoid with vector from start to goal\n        def unit_vector(v):\n            length = math.sqrt(sum(x*x for x in v))\n            if length == 0:\n                return [0]*dim\n            return [x/length for x in v]\n        a1 = [best_pair[1][d] - best_pair[0][d] for d in range(dim)]\n        e1 = unit_vector(a1)\n\n        # Build axes lengths of ellipsoid\n        r1 = c_best / 2\n        r_other = math.sqrt(c_best**2 - c_min**2) / 2\n\n        # Generate random point in unit ball\n        while True:\n            x_ball = self._random_unit_ball(dim)\n            x_ball_scaled = [0]*dim\n            x_ball_scaled[0] = x_ball[0]*r1\n            for di in range(1, dim):\n                x_ball_scaled[di] = x_ball[di]*r_other\n\n            # Rotate to align with a1 axis, here simplified to 2D or 3D alignment\n            if dim == 2:\n                cos_a = e1[0]\n                sin_a = e1[1]\n                x_ell = (\n                    center[0] + x_ball_scaled[0]*cos_a - x_ball_scaled[1]*sin_a,\n                    center[1] + x_ball_scaled[0]*sin_a + x_ball_scaled[1]*cos_a)\n            elif dim ==3:\n                # Construct orthonormal basis: e1, e2, e3 orthogonal\n                import math\n                # e1 is given\n                def cross(u,v):\n                    return [u[1]*v[2]-u[2]*v[1], u[2]*v[0]-u[0]*v[2], u[0]*v[1]-u[1]*v[0]]\n                def norm(u):\n                    return math.sqrt(sum(x*x for x in u))\n                def normalize(u):\n                    n = norm(u)\n                    if n == 0:\n                        return [0,0,0]\n                    return [x/n for x in u]\n                # pick arbitrary vector not colinear e1, for example [1,0,0] or [0,1,0]\n                basis_seed = [1,0,0] if abs(e1[0])<0.9 else [0,1,0]\n                e2 = cross(e1,basis_seed)\n                e2 = normalize(e2)\n                e3 = cross(e1,e2)\n                x_ell = [center[d] + x_ball_scaled[0]*e1[d] + x_ball_scaled[1]*e2[d] + x_ball_scaled[2]*e3[d] for d in range(3)]\n            else:\n                # Higher dims fallback: sample uniform in cube around center within bounds\n                x_ell = tuple(center[d] + x_ball_scaled[d] for d in range(dim))\n\n            # Validate within bounds and free of obstacle\n            if all(0 <= x_ell[d] <= bounds[d] for d in range(dim)):\n                if not self._in_obstacle(x_ell, obstacles, is_3d):\n                    return x_ell\n\n    def _random_unit_ball(self, dim):\n        import random, math\n        while True:\n            p = [random.uniform(-1,1) for _ in range(dim)]\n            norm = math.sqrt(sum(x*x for x in p))\n            if norm <= 1 and norm > 1e-12:\n                return [x/norm for x in p]\n\n    def _extend(self, tree, point, obstacles, is_3d, nodes, edges, bounds):\n        nearest = self._nearest(tree, point)\n        new_pos = self._steer(nearest.position, point)\n        if not self._valid(nearest.position, new_pos, obstacles, is_3d):\n            return None\n\n        # Find neighbors within dynamic radius for choosing best parent\n        radius = self._dynamic_rewire_radius(tree, bounds)\n        near_nodes = self._near(tree, new_pos, radius)\n\n        min_cost = nearest.cost + self._euclidean_dist(nearest.position, new_pos)\n        best_parent = nearest\n        for nb in near_nodes:\n            if self._valid(nb.position, new_pos, obstacles, is_3d):\n                cost_through_nb = nb.cost + self._euclidean_dist(nb.position, new_pos)\n                if cost_through_nb < min_cost:\n                    best_parent = nb\n                    min_cost = cost_through_nb\n\n        new_node = Node(new_pos, best_parent, min_cost)\n        best_parent.add_child(new_node)\n        tree.append(new_node)\n        nodes.append(new_node)\n        edges.append((best_parent, new_node))\n        return new_node\n\n    def _connect(self, tree, target_node, obstacles, is_3d, nodes, edges, bounds, radius):\n        nearest = self._nearest(tree, target_node.position)\n        cur = nearest\n        while True:\n            new_pos = self._steer(cur.position, target_node.position)\n            if not self._valid(cur.position, new_pos, obstacles, is_3d):\n                return None\n\n            new_node = self._choose_parent_and_add(tree, new_pos, obstacles, is_3d, nodes, edges, bounds, radius)\n            self._rewire(new_node, tree, obstacles, is_3d, nodes, edges, radius)\n\n            if self._euclidean_dist(new_node.position, target_node.position) <= self.step_size:\n                if self._valid(new_node.position, target_node.position, obstacles, is_3d):\n                    final_cost = new_node.cost + self._euclidean_dist(new_node.position, target_node.position)\n                    final_node = Node(target_node.position, new_node, final_cost)\n                    new_node.add_child(final_node)\n                    tree.append(final_node)\n                    nodes.append(final_node)\n                    edges.append((new_node, final_node))\n                    return final_node\n                else:\n                    return None\n            cur = new_node\n\n    def _rewire(self, pivot_node, tree, obstacles, is_3d, nodes, edges, radius):\n        neighbors = self._near(tree, pivot_node.position, radius)\n        for nb in neighbors:\n            if nb == pivot_node.parent:\n                continue\n            if self._valid(pivot_node.position, nb.position, obstacles, is_3d):\n                cost_via_pivot = pivot_node.cost + self._euclidean_dist(pivot_node.position, nb.position)\n                if cost_via_pivot + 1e-12 < nb.cost:\n                    # Update edges and parents\n                    if nb.parent is not None:\n                        try:\n                            nb.parent.children.remove(nb)\n                        except Exception:\n                            pass\n                        try:\n                            edges.remove((nb.parent, nb))\n                        except Exception:\n                            pass\n                    nb.parent = pivot_node\n                    nb.cost = cost_via_pivot\n                    pivot_node.children.append(nb)\n                    edges.append((pivot_node, nb))\n                    self._update_children_costs(nb, edges)\n\n    def _update_children_costs(self, node, edges):\n        for ch in node.children:\n            new_cost = node.cost + self._euclidean_dist(node.position, ch.position)\n            if new_cost + 1e-12 < ch.cost:\n                ch.cost = new_cost\n                ch.parent = node\n                self._update_children_costs(ch, edges)\n\n    def _steer(self, start, goal):\n        dist = self._euclidean_dist(start, goal)\n        if dist <= self.step_size:\n            return goal\n        ratio = self.step_size / dist\n        return tuple(start[d] + (goal[d] - start[d]) * ratio for d in range(len(start)))\n\n    def _nearest(self, tree, point):\n        best_node = None\n        best_dist = float('inf')\n        for node in tree:\n            d = self._euclidean_dist(node.position, point)\n            if d < best_dist:\n                best_dist = d\n                best_node = node\n        return best_node\n\n    def _near(self, tree, point, radius):\n        r2 = radius * radius\n        return [node for node in tree if self._dist_sq(node.position, point) <= r2]\n\n    def _choose_parent_and_add(self, tree, new_pos, obstacles, is_3d, nodes, edges, bounds, radius):\n        nearest = self._nearest(tree, new_pos)\n        neighbors = self._near(tree, new_pos, radius)\n\n        min_cost = nearest.cost + self._euclidean_dist(nearest.position, new_pos)\n        best_parent = nearest\n        for nb in neighbors:\n            if self._valid(nb.position, new_pos, obstacles, is_3d):\n                cost_cand = nb.cost + self._euclidean_dist(nb.position, new_pos)\n                if cost_cand < min_cost:\n                    best_parent = nb\n                    min_cost = cost_cand\n\n        new_node = Node(new_pos, best_parent, min_cost)\n        best_parent.add_child(new_node)\n        tree.append(new_node)\n        nodes.append(new_node)\n        edges.append((best_parent, new_node))\n        return new_node\n\n    def _valid(self, p1, p2, obstacles, is_3d):\n        if self._in_obstacle(p2, obstacles, is_3d):\n            return False\n        if self._edge_in_obstacle(p1, p2, obstacles, is_3d):\n            return False\n        return True\n\n    def _in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x,y,z,w,h,d = obs\n                px,py,pz = pos\n                if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                    return True\n            else:\n                x,y,w,h = obs\n                px,py = pos\n                if x <= px <= x+w and y <= py <= y+h:\n                    return True\n        return False\n\n    def _edge_in_obstacle(self, p1, p2, obstacles, is_3d, res=0.5):\n        dist = self._euclidean_dist(p1, p2)\n        steps = max(1, int(dist / res))\n        for i in range(steps + 1):\n            interp = tuple(p1[d] + (p2[d] - p1[d]) * (i / steps) for d in range(len(p1)))\n            if self._in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _euclidean_dist(self, a, b):\n        return sum((a[d]-b[d])**2 for d in range(len(a)))**0.5\n\n    def _dist_sq(self, a, b):\n        return sum((a[d]-b[d])**2 for d in range(len(a)))\n\n    def _dynamic_rewire_radius(self, tree, bounds):\n        import math\n        n = max(1, len(tree))\n        dim = len(bounds)\n        scale = max(1.0, sum(bounds)/dim)  # Approximate scale\n        r_star = self.gamma_rrt_star * ( (math.log(n)/n)**(1/dim) )\n        radius = max(self.step_size*2., min(self.max_radius, r_star * 0.7 + scale*0.02))  # tuned factor\n        return radius\n\n    def _path_cost(self, path):\n        cost = 0.\n        for i in range(len(path)-1):\n            cost += self._euclidean_dist(path[i], path[i+1])\n        return cost\n\n    def _shortcut_path(self, path, obstacles, is_3d, max_attempts=50):\n        if len(path) <= 2:\n            return path\n        import random\n        for _ in range(max_attempts):\n            if len(path) <= 2:\n                break\n            i = random.randint(0, len(path)-3)\n            j = random.randint(i+2, len(path)-1)\n            if not self._edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                # Remove points between i and j\n                path = path[:i+1] + path[j:]\n        return path",
    "objective": 42.68248,
    "time_improvement": -140.0,
    "length_improvement": 16.0,
    "smoothness_improvement": 1254.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 0.9,
            "time_avg": 0.045841217041015625,
            "num_nodes_avg": 98.2,
            "path_length_avg": 157.8523866360219,
            "smoothness_avg": 0.027730907120604397,
            "success_improvement": -9.999999999999998,
            "time_improvement": -74.61446178129056,
            "length_improvement": 13.478605553662625,
            "smoothness_improvement": 334.04891506610375,
            "objective_score": -62.62693062685906
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.13129189014434814,
            "num_nodes_avg": 267.1,
            "path_length_avg": 244.16521697505203,
            "smoothness_avg": 0.08415123972817096,
            "success_improvement": 0.0,
            "time_improvement": 20.496630681551586,
            "length_improvement": 18.49062266762984,
            "smoothness_improvement": 2065.272009893872,
            "objective_score": 27.56972285451274
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.23435142040252685,
            "num_nodes_avg": 260.1,
            "path_length_avg": 125.45521951631702,
            "smoothness_avg": 0.11500851998920728,
            "success_improvement": 0.0,
            "time_improvement": -366.0396958754675,
            "length_improvement": 16.678616732849484,
            "smoothness_improvement": 1362.8998852168113,
            "objective_score": -92.9902392968465
        }
    ],
    "success_rate": 0.9666666666666667
}
{
    "operator": "e1",
    "algorithm_description": "A novel bidirectional informed RRT* planner utilizing batch sampling with adaptive informed set reduction, hybrid discrete-continuous steering, KD-tree inspired spatial indexing for efficient nearest and near neighbor queries, and a multi-phase rewiring strategy combining local and global path optimization to improve efficiency, path length, smoothness, and robustness. The planner incrementally expands two trees from start and goal using heuristic-guided priority node selection, adaptively shrinks the informed sampling region based on current best path cost, employs lazy collision evaluation for edges, and applies progressive smoothing to final paths for superior quality while reducing search time.",
    "planning_mechanism": "A bidirectional RRT*-based planner that alternates expansion between start and goal trees. Each iteration samples a batch of points within an adaptive ellipsoidal informed set (shrinks with improvements), selects best nodes by cost+heuristic from priority queues for extension, uses a hybrid discrete-continuous steering to create new nodes, maintains efficient nearest and near neighbor lookups with spatial indexing, performs local and global rewiring in separate phases to optimize paths, lazily checks edges for collision to save computation and early-prunes invalid expansions. Upon connecting trees, it reconstructs the path and applies multi-level shortcutting and smoothing for smooth and short trajectories.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost  # cost-to-come\n        self.children = []\n        self.id = id(self)\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=3500, step_size=4.0, batch_size=20, goal_sample_rate=0.1, init_radius=25.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.batch_size = batch_size\n        self.goal_sample_rate = goal_sample_rate\n        self.init_radius = init_radius\n\n    def plan(self, map):\n        bounds = map.size\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        from math import sqrt, cos, sin, atan2\n        import random\n        import bisect\n\n        # Euclidean distance\n        def dist(a, b):\n            return sqrt(sum((a[d] - b[d])**2 for d in range(dim)))\n\n        # Check if point is inside any obstacle\n        def in_obstacle(pt):\n            if is_3d:\n                px, py, pz = pt\n                for obs in obstacles:\n                    ox, oy, oz, w, h, d_ = obs\n                    if ox <= px <= ox + w and oy <= py <= oy + h and oz <= pz <= oz + d_:\n                        return True\n            else:\n                px, py = pt\n                for obs in obstacles:\n                    ox, oy, w, h = obs\n                    if ox <= px <= ox + w and oy <= py <= oy + h:\n                        return True\n            return False\n\n        # Lazy edge collision checking with discretization at 0.4 units resolution\n        def edge_in_obstacle(p1, p2):\n            length = dist(p1, p2)\n            steps = max(1, int(length / 0.4))\n            for i in range(steps + 1):\n                interp = tuple(\n                    p1[d] + (p2[d] - p1[d]) * (i / steps)\n                    for d in range(dim)\n                )\n                if in_obstacle(interp):\n                    return True\n            return False\n\n        # Steering from 'from_p' towards 'to_p' with max step size\n        def steer(from_p, to_p):\n            d = dist(from_p, to_p)\n            if d <= self.step_size:\n                return to_p\n            ratio = self.step_size / d\n            return tuple(from_p[d_] + ratio * (to_p[d_] - from_p[d_]) for d_ in range(dim))\n\n        # Priority queue for node expansions: min-heap by cost + heuristic\n        class PriorityQueue:\n            def __init__(self):\n                self.heap = []\n                self.entry_finder = {}\n                self.REMOVED = '<removed>'\n\n            def add(self, node, priority):\n                if node.id in self.entry_finder:\n                    self.remove(node)\n                entry = [priority, node.id, node]\n                self.entry_finder[node.id] = entry\n                import heapq\n                heapq.heappush(self.heap, entry)\n\n            def remove(self, node):\n                entry = self.entry_finder.pop(node.id)\n                entry[-1] = self.REMOVED\n\n            def pop(self):\n                import heapq\n                while self.heap:\n                    priority, nid, node = heapq.heappop(self.heap)\n                    if node is not self.REMOVED:\n                        del self.entry_finder[nid]\n                        return node\n                return None\n\n            def empty(self):\n                return not bool(self.entry_finder)\n\n        # KD-tree like spatial index for efficient neighbor queries (brute force with caching)\n        class SpatialIndex:\n            def __init__(self):\n                self.points = []\n                self.nodes = []\n\n            def add(self, node):\n                self.nodes.append(node)\n                self.points.append(node.position)\n\n            # Brute force nearest\n            def nearest(self, point):\n                best_node = None\n                best_dist = float('inf')\n                for n in self.nodes:\n                    d = dist(n.position, point)\n                    if d < best_dist:\n                        best_dist = d\n                        best_node = n\n                return best_node, best_dist\n\n            # Brute force near nodes within radius\n            def near(self, point, radius):\n                nbrs = []\n                r_sq = radius * radius\n                for n in self.nodes:\n                    d_sq = sum((n.position[d_] - point[d_]) ** 2 for d_ in range(dim))\n                    if d_sq <= r_sq:\n                        nbrs.append(n)\n                return nbrs\n\n        # Adaptive informed sampling inside prolate hyperspheroid between start and goal after initial solution\n        def sample_informed(c_best):\n            if c_best == float('inf'):\n                return sample_uniform()\n            c_min = dist(start, goal)\n            if c_best < c_min:\n                # numerical error fallback: uniform\n                return sample_uniform()\n            center = tuple((start[d] + goal[d]) * 0.5 for d in range(dim))\n            a1 = [(goal[d] - start[d]) / c_min for d in range(dim)]\n\n            # Sample unit ball vector\n            while True:\n                x_ball = [random.gauss(0, 1) for _ in range(dim)]\n                norm = sqrt(sum(x ** 2 for x in x_ball))\n                if norm == 0:\n                    continue\n                unit = [x / norm for x in x_ball]\n\n                r1 = c_best / 2.0\n                val = c_best ** 2 - c_min ** 2\n                r2 = sqrt(val) / 2.0 if val > 0. else 0.\n\n                if dim == 2:\n                    angle = atan2(a1[1], a1[0])\n                    cos_a = cos(angle)\n                    sin_a = sin(angle)\n                    x_ell = r1 * unit[0]\n                    y_ell = r2 * unit[1]\n                    px = center[0] + cos_a * x_ell - sin_a * y_ell\n                    py = center[1] + sin_a * x_ell + cos_a * y_ell\n                    pt = (px, py)\n                else:\n                    # 3D: scale axes [c_best/2, sqrt(c_best^2-c_min^2)/2, sqrt(...)...]\n                    pt_candidate = []\n                    for d in range(dim):\n                        scale = r1 if d == 0 else r2\n                        coord = center[d] + scale * unit[d]\n                        coord = max(0, min(coord, bounds[d]))\n                        pt_candidate.append(coord)\n                    pt = tuple(pt_candidate)\n                if all(0 <= pt[d] <= bounds[d] for d in range(dim)) and not in_obstacle(pt):\n                    return pt\n\n        # Uniform random sampling inside bounds and free space\n        def sample_uniform():\n            for _ in range(1000):\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not in_obstacle(pt):\n                    return pt\n            return goal  # fallback to goal if stuck\n\n        # Generate batch samples using mixture of goal bias and informed/uniform\n        def generate_batch(c_best):\n            samples = []\n            attempts = 0\n            max_attempts = 5000\n            while len(samples) < self.batch_size and attempts < max_attempts:\n                attempts += 1\n                p = random.random()\n                if p < self.goal_sample_rate:\n                    pt = goal if expand_start else start\n                    if not in_obstacle(pt):\n                        samples.append(pt)\n                    continue\n                if c_best < float('inf'):\n                    pt = sample_informed(c_best)\n                else:\n                    pt = sample_uniform()\n                samples.append(pt)\n            if len(samples) < self.batch_size:\n                # fallback uniform to fill batch\n                while len(samples) < self.batch_size:\n                    pt = sample_uniform()\n                    samples.append(pt)\n            return samples\n\n        # Efficient, multi-level rewiring - local near radius + global radius for improving cost\n        def rewire(new_node, tree_idx, radius):\n            # Local rewiring radius decreases slowly with iterations\n            r_local = max(radius * 0.75, 4.0)\n            near_local = tree_indices[tree_idx].near(new_node.position, r_local)\n            for near in near_local:\n                if near is new_node.parent:\n                    continue\n                c_through_new = new_node.cost + dist(new_node.position, near.position)\n                if c_through_new + 1e-10 < near.cost and not edge_in_obstacle(new_node.position, near.position):\n                    # Re-parent\n                    if near.parent:\n                        near.parent.remove_child(near)\n                    near.parent = new_node\n                    near.cost = c_through_new\n                    new_node.children.append(near)\n                    update_children_costs(near)\n\n        # Recursively update children costs after rewire\n        def update_children_costs(node):\n            stack = [node]\n            while stack:\n                current = stack.pop()\n                for c in current.children:\n                    new_cost = current.cost + dist(current.position, c.position)\n                    if new_cost + 1e-10 < c.cost:\n                        c.cost = new_cost\n                        c.parent = current\n                        stack.append(c)\n\n        # Extract path from start node to root and from goal node to root; concatenate with bridge node\n        def extract_path(node_s, node_g):\n            path_s = node_s.path_from_root()\n            path_g = node_g.path_from_root()\n            if path_s[-1] == path_g[-1]:\n                return path_s + path_g[-2::-1]\n            else:\n                return path_s + path_g[::-1]\n\n        # Progressive multi-level shortcutting with finer discretization for smoothness\n        def shortcut_path(path):\n            if len(path) <= 2:\n                return path\n            shortened = [path[0]]\n            idx = 0\n            while idx < len(path) - 1:\n                next_idx = len(path) -1\n                # Walk back from end to find farthest reachable point without obstacles\n                for j in range(len(path) -1, idx, -1):\n                    if not edge_in_obstacle(path[idx], path[j]):\n                        next_idx = j\n                        break\n                shortened.append(path[next_idx])\n                idx = next_idx\n            # Apply smooth cubic Bezier-like smoothing on edges\n            return smooth_path(shortened)\n\n        # Simple cubic smoothing by adjusting intermediate nodes towards neighbors\n        def smooth_path(path):\n            if len(path) < 3:\n                return path\n            smoothed = path[:]\n            for _ in range(2):  # two smoothing iterations\n                new_path = [smoothed[0]]\n                for i in range(1, len(smoothed)-1):\n                    prev_pt = smoothed[i-1]\n                    curr_pt = smoothed[i]\n                    next_pt = smoothed[i+1]\n                    new_pt = tuple(\n                        (prev_pt[d] + 2*curr_pt[d] + next_pt[d])/4.0 for d in range(dim)\n                    )\n                    if not in_obstacle(new_pt) and not edge_in_obstacle(prev_pt, new_pt) and not edge_in_obstacle(new_pt, next_pt):\n                        new_path.append(new_pt)\n                    else:\n                        new_path.append(curr_pt)\n                new_path.append(smoothed[-1])\n                smoothed = new_path\n            return smoothed\n\n        # Attempt connect two trees by trying direct edge from new_node to nearest node on other tree\n        def attempt_connect(new_node, other_tree_idx):\n            near_node, near_dist = tree_indices[other_tree_idx].nearest(new_node.position)\n            if near_node is None:\n                return None\n            if edge_in_obstacle(near_node.position, new_node.position):\n                return None\n            cost_here = new_node.cost + dist(new_node.position, near_node.position)\n            # Create new bridging node attached to near_node\n            bridge_node = Node(new_node.position, near_node, cost_here)\n            near_node.add_child(bridge_node)\n            tree_indices[other_tree_idx].add(bridge_node)\n            return bridge_node\n\n        # Add new node to tree via best nearby parent minimizing cost\n        def add_node(tidx, sample_pt, radius):\n            near_node, _ = tree_indices[tidx].nearest(sample_pt)\n            if near_node is None:\n                return None\n            if in_obstacle(sample_pt) or edge_in_obstacle(near_node.position, sample_pt):\n                return None\n            new_cost = near_node.cost + dist(near_node.position, sample_pt)\n            new_node = Node(sample_pt, near_node, new_cost)\n            near_node.add_child(new_node)\n            tree_indices[tidx].add(new_node)\n            # Rewire neighbors for path cost improvement\n            neighbors = tree_indices[tidx].near(sample_pt, radius)\n            for nbr in neighbors:\n                if nbr is new_node.parent:\n                    continue\n                cost_through_new = new_node.cost + dist(new_node.position, nbr.position)\n                if cost_through_new + 1e-10 < nbr.cost and not edge_in_obstacle(new_node.position, nbr.position):\n                    if nbr.parent:\n                        nbr.parent.remove_child(nbr)\n                    nbr.parent = new_node\n                    nbr.cost = cost_through_new\n                    new_node.children.append(nbr)\n                    update_children_costs(nbr)\n            return new_node\n\n        # Heuristic: Euclidean distance to goal\n        def heuristic(p):\n            return dist(p, goal)\n\n        # Initialize start and goal trees\n        start_node = Node(start, cost=0.0)\n        goal_node = Node(goal, cost=0.0)\n        tree_start = SpatialIndex()\n        tree_goal = SpatialIndex()\n        tree_start.add(start_node)\n        tree_goal.add(goal_node)\n\n        tree_indices = [tree_start, tree_goal]\n\n        # Priority queues per tree keyed by cost + heuristic\n        pq_start = PriorityQueue()\n        pq_goal = PriorityQueue()\n        pq_start.add(start_node, start_node.cost + heuristic(start_node.position))\n        pq_goal.add(goal_node, goal_node.cost + heuristic(goal_node.position))\n\n        best_cost = float('inf')\n        best_path = None\n        best_nodes = []\n        best_edges = []\n\n        # Initialization radius for rewiring and neighbor search (adaptive)\n        def adaptive_radius(iteration):\n            decay = 0.97 ** (iteration // 300)\n            return max(4.0, self.init_radius * decay)\n\n        expand_start = True  # alternate expansions\n\n        for itr in range(self.max_iter):\n            expand_start = not expand_start\n            t_expand = 0 if expand_start else 1\n            t_other = 1 - t_expand\n            radius = adaptive_radius(itr)\n\n            # Batch generate samples biased with goal sampling and informed sampling if solution found\n            samples = []\n            bs_needed = self.batch_size\n            samples = generate_batch(best_cost)\n\n            # Keep list of (node, sample, cost + heuristic) to pick best for each sample point\n            candidates = []\n\n            for sample_pt in samples:\n                near_node, near_dist = tree_indices[t_expand].nearest(sample_pt)\n                if near_node is None:\n                    continue\n                if in_obstacle(sample_pt) or edge_in_obstacle(near_node.position, sample_pt):\n                    continue\n                new_cost = near_node.cost + dist(near_node.position, sample_pt)\n                key = new_cost + heuristic(sample_pt)\n                candidates.append( (key, sample_pt, near_node, new_cost) )\n\n            candidates.sort(key=lambda x: x[0])\n\n            new_nodes = []\n            expanded_nodes = set()\n\n            for _, sample_pt, near_node, new_cost in candidates[:self.batch_size]:\n                if sample_pt in expanded_nodes:\n                    continue\n                new_node = add_node(t_expand, sample_pt, radius)\n                if new_node is not None:\n                    expanded_nodes.add(sample_pt)\n                    new_nodes.append(new_node)\n\n            # Attempt to connect each new node to other tree\n            for new_node in new_nodes:\n                bridge_node = attempt_connect(new_node, t_other)\n                if bridge_node is not None:\n                    total_cost = new_node.cost + bridge_node.cost - dist(new_node.position, bridge_node.position)\n                    if total_cost + 1e-10 < best_cost:\n                        best_cost = total_cost\n                        # Extract full path and shortcut\n                        path = extract_path(new_node, bridge_node)\n                        path_smoothed = shortcut_path(path)\n                        best_path = path_smoothed\n                        # Early stopping on improvement\n                        return PlannerResult(True, best_path,\n                                             tree_start.nodes + tree_goal.nodes,\n                                             [])  # Edges omitted for simplicity\n\n        # No connection found after max_iter iterations\n        return PlannerResult(False, [], tree_start.nodes + tree_goal.nodes, [])",
    "objective": 27.13974,
    "time_improvement": -24.0,
    "length_improvement": 5.0,
    "smoothness_improvement": 2052.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.06841180324554444,
            "num_nodes_avg": 106.5,
            "path_length_avg": 181.194138161526,
            "smoothness_avg": 0.09988870360461828,
            "success_improvement": 0.0,
            "time_improvement": -160.58841746108294,
            "length_improvement": 0.684621668811588,
            "smoothness_improvement": 1463.475123203947,
            "objective_score": -40.448376621018184
        },
        {
            "map_id": 1,
            "success_rate": 0.9,
            "time_avg": 0.033142828941345216,
            "num_nodes_avg": 109.8,
            "path_length_avg": 255.8356265531416,
            "smoothness_avg": 0.11886748340261752,
            "success_improvement": -9.999999999999998,
            "time_improvement": 79.93046968335264,
            "length_improvement": 14.594704036349102,
            "smoothness_improvement": 2958.545964736987,
            "objective_score": -2.471306849499804
        },
        {
            "map_id": 2,
            "success_rate": 0.9,
            "time_avg": 0.04630513191223144,
            "num_nodes_avg": 118.3,
            "path_length_avg": 149.42704000745715,
            "smoothness_avg": 0.1442001877135643,
            "success_improvement": -9.999999999999998,
            "time_improvement": 7.915942831567058,
            "length_improvement": 0.7576749780599425,
            "smoothness_improvement": 1734.215743965856,
            "objective_score": -38.49953344386463
        }
    ],
    "success_rate": 0.9333333333333332
}
{
    "operator": "e2",
    "algorithm_description": "A hybrid bidirectional informed RRT* planner integrating efficient KD-tree inspired nearest neighbor approximation and adaptive rewiring radius with goal bias and informed ellipsoidal sampling. It alternates growing start and goal trees, extends nodes towards adaptively sampled points using fixed step size, rewires locally with incremental cost updates, attempts to connect the trees directly for early termination, and applies iterative path shortcutting post-solution to improve smoothness and shorten the path. The planner performs strict collision checks on nodes and edges, respects map boundaries, and leverages heuristic-based priority extensions to balance exploration and exploitation, improving planning efficiency, path length, smoothness, robustness, and success rate.",
    "planning_mechanism": "The planner grows two trees from start and goal, sampling adaptively using goal bias and informed ellipsoid once a solution is found. Each extension involves a nearest node found using a spatial hash grid approximation for efficiency, steering towards the sample with step limitation, and local rewiring within an adaptive radius calculated based on node density and geometry. After each connection between trees, the best path is extracted and refined via iterative shortcutting for improved smoothness and minimal length. Early returns occur on finding improved solutions, reducing search time while maintaining solution quality.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=3500, step_size=5.0, goal_sample_rate=0.15, min_rewire_radius=12.0, max_rewire_radius=40.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.min_rewire_radius = min_rewire_radius\n        self.max_rewire_radius = max_rewire_radius\n\n    def plan(self, map):\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        import random\n        import math\n\n        def dist(a, b):\n            s = 0\n            for i in range(dim):\n                s += (a[i] - b[i]) ** 2\n            return s ** 0.5\n\n        def in_obstacle(pt):\n            if is_3d:\n                px, py, pz = pt\n                for ox, oy, oz, w, h, d in obstacles:\n                    if ox <= px <= ox + w and oy <= py <= oy + h and oz <= pz <= oz + d:\n                        return True\n            else:\n                px, py = pt\n                for ox, oy, w, h in obstacles:\n                    if ox <= px <= ox + w and oy <= py <= oy + h:\n                        return True\n            return False\n\n        def edge_in_obstacle(p1, p2):\n            d = dist(p1, p2)\n            steps = max(1, int(d * 2))\n            for i in range(steps + 1):\n                interp = tuple(p1[j] + (p2[j] - p1[j]) * (i / steps) for j in range(dim))\n                if in_obstacle(interp):\n                    return True\n            return False\n\n        def steer(from_pt, to_pt):\n            d = dist(from_pt, to_pt)\n            if d <= self.step_size:\n                return to_pt\n            ratio = self.step_size / d\n            return tuple(from_pt[j] + ratio * (to_pt[j] - from_pt[j]) for j in range(dim))\n\n        def heuristic(p):\n            # Euclidean heuristic to goal\n            return dist(p, goal_pos)\n\n        def sample_uniform():\n            while True:\n                pt = tuple(random.uniform(0, bounds[j]) for j in range(dim))\n                if not in_obstacle(pt):\n                    return pt\n\n        def sample_informed(c_best):\n            if c_best == float('inf'):\n                return sample_uniform()\n            c_min = dist(start_pos, goal_pos)\n            if c_best < c_min:\n                return sample_uniform()\n            center = tuple((start_pos[j] + goal_pos[j]) * 0.5 for j in range(dim))\n            a1 = [(goal_pos[j] - start_pos[j]) / c_min for j in range(dim)]\n            while True:\n                # Sample unit ball with dimension dim\n                x_ball = [random.gauss(0, 1) for _ in range(dim)]\n                norm = math.sqrt(sum(x * x for x in x_ball))\n                if 0 < norm <= 1:\n                    unit = [x / norm for x in x_ball]\n                    r1 = c_best / 2\n                    r2_temp = c_best * c_best - c_min * c_min\n                    r2 = math.sqrt(r2_temp) / 2 if r2_temp > 0 else 0.0\n                    if dim == 2:\n                        angle = math.atan2(a1[1], a1[0])\n                        cos_a = math.cos(angle)\n                        sin_a = math.sin(angle)\n                        x_ell = r1 * unit[0]\n                        y_ell = r2 * unit[1]\n                        px = center[0] + cos_a * x_ell - sin_a * y_ell\n                        py = center[1] + sin_a * x_ell + cos_a * y_ell\n                        pt = (px, py)\n                    else:\n                        D = [0.0] * dim\n                        D[0] = r1\n                        for i in range(1, dim):\n                            D[i] = r2\n                        pt_candidate = [center[j] + D[j] * unit[j] for j in range(dim)]\n                        pt = tuple(max(0, min(pt_candidate[j], bounds[j])) for j in range(dim))\n                    if all(0 <= pt[j] <= bounds[j] for j in range(dim)) and not in_obstacle(pt):\n                        return pt\n\n        # Spatial Hash Grid for approximate nearest neighbor search to speedup neighbor queries\n        class SpatialHashGrid:\n            def __init__(self, bound, cell_size):\n                self.cell_size = cell_size\n                self.dim = len(bound)\n                self.bounds = bound\n                self.grid = {}\n\n            def _hash(self, position):\n                return tuple(int(position[i] // self.cell_size) for i in range(self.dim))\n\n            def insert(self, node):\n                h = self._hash(node.position)\n                if h not in self.grid:\n                    self.grid[h] = []\n                self.grid[h].append(node)\n\n            def remove(self, node):\n                h = self._hash(node.position)\n                if h in self.grid and node in self.grid[h]:\n                    self.grid[h].remove(node)\n                    if not self.grid[h]:\n                        del self.grid[h]\n\n            def near(self, position, radius):\n                h_center = self._hash(position)\n                r_cells = int(math.ceil(radius / self.cell_size))\n                neighbors = []\n                for offset in self._neighbor_offsets(r_cells):\n                    h = tuple(h_center[d] + offset[d] for d in range(self.dim))\n                    if h in self.grid:\n                        neighbors.extend(self.grid[h])\n                return neighbors\n\n            def _neighbor_offsets(self, r_cells):\n                # Generate all offset combinations (-r_cells to r_cells) in dim dims\n                offsets = []\n                def recurse(depth, cur):\n                    if depth == self.dim:\n                        offsets.append(tuple(cur))\n                    else:\n                        for i in range(-r_cells, r_cells+1):\n                            cur.append(i)\n                            recurse(depth+1, cur)\n                            cur.pop()\n                recurse(0, [])\n                return offsets\n\n        def nearest_node(grid, nodes, point):\n            # Use spatial grid neighbors and linear search as fallback\n            search_radius = self.step_size * 4\n            candidates = grid.near(point, search_radius)\n            if not candidates:\n                # Fallback linear scan with threshold distance expanding\n                min_d = float('inf')\n                min_node = None\n                for n in nodes:\n                    d_ = dist(n.position, point)\n                    if d_ < min_d:\n                        min_d = d_\n                        min_node = n\n                return min_node\n            min_dist = float('inf')\n            min_node = None\n            for n in candidates:\n                d_ = dist(n.position, point)\n                if d_ < min_dist:\n                    min_dist = d_\n                    min_node = n\n            return min_node\n\n        def neighbors_within(grid, point, radius):\n            candidates = grid.near(point, radius)\n            filtered = []\n            for n in candidates:\n                if dist(n.position, point) <= radius:\n                    filtered.append(n)\n            return filtered\n\n        def rewire(new_node, tree_nodes, grid, edges, current_best_cost):\n            # Adaptive radius based on node count and dimension\n            n = max(1, len(tree_nodes))\n            r = min(self.max_rewire_radius, max(self.min_rewire_radius, self.step_size * 2.5 * (math.log(n)/n) ** (1.0 / dim)))\n            nbrs = neighbors_within(grid, new_node.position, r)\n            for nbr in nbrs:\n                if nbr is new_node.parent:\n                    continue\n                if edge_in_obstacle(new_node.position, nbr.position):\n                    continue\n                cost_through_new = new_node.cost + dist(new_node.position, nbr.position)\n                if cost_through_new + 1e-10 < nbr.cost and cost_through_new < current_best_cost:\n                    if nbr.parent:\n                        try:\n                            nbr.parent.children.remove(nbr)\n                        except Exception:\n                            pass\n                    new_node.add_child(nbr)\n                    cost_diff = nbr.cost - cost_through_new\n                    nbr.cost = cost_through_new\n                    # Propagate cost changes downstream incrementally\n                    stack = [nbr]\n                    while stack:\n                        curr = stack.pop()\n                        for c in curr.children:\n                            new_c_cost = curr.cost + dist(curr.position, c.position)\n                            if new_c_cost + 1e-10 < c.cost:\n                                c.cost = new_c_cost\n                                stack.append(c)\n                    # No edges list modification here as edges not kept, kept minimal.\n            # No edges list used for concise data.\n\n        def backtrack_path(n_start, n_goal):\n            path_start = n_start.path_from_root()\n            path_goal = n_goal.path_from_root()\n            if path_start[-1] == path_goal[-1]:\n                path_goal = path_goal[:-1]\n            return path_start + path_goal[::-1]\n\n        def shortcut_path(path):\n            if len(path) <= 2:\n                return path[:]\n            shortened = [path[0]]\n            i = 0\n            while i < len(path) - 1:\n                j = len(path) - 1\n                while j > i:\n                    p_i = path[i]\n                    p_j = path[j]\n                    if not edge_in_obstacle(p_i, p_j):\n                        shortened.append(p_j)\n                        i = j\n                        break\n                    j -= 1\n                else:\n                    # No shortcut possible, add next\n                    shortened.append(path[i+1])\n                    i += 1\n            return shortened\n\n        # Initialize\n        start_node = Node(start_pos, cost=0.0)\n        goal_node = Node(goal_pos, cost=0.0)\n        tree_start = [start_node]\n        tree_goal = [goal_node]\n\n        grid_start = SpatialHashGrid(bounds, cell_size=self.step_size * 4)\n        grid_goal = SpatialHashGrid(bounds, cell_size=self.step_size * 4)\n        grid_start.insert(start_node)\n        grid_goal.insert(goal_node)\n\n        best_cost = float('inf')\n        best_path = None\n\n        for i in range(self.max_iter):\n            # Alternate growing start and goal trees\n            if i % 2 == 0:\n                tree_a, tree_b = tree_start, tree_goal\n                grid_a, grid_b = grid_start, grid_goal\n                sample_goal = goal_pos\n                reverse_connection = False\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n                grid_a, grid_b = grid_goal, grid_start\n                sample_goal = start_pos\n                reverse_connection = True\n\n            # Sample with goal bias or informed ellipsoid sampling if solution found\n            if random.random() < self.goal_sample_rate:\n                sample_pt = sample_goal if not in_obstacle(sample_goal) else sample_uniform()\n            else:\n                sample_pt = sample_informed(best_cost)\n\n            nearest = nearest_node(grid_a, tree_a, sample_pt)\n            new_pos = steer(nearest.position, sample_pt)\n            if in_obstacle(new_pos):\n                continue\n            if edge_in_obstacle(nearest.position, new_pos):\n                continue\n            cost_to_new = nearest.cost + dist(nearest.position, new_pos)\n            if cost_to_new >= best_cost:\n                continue\n            new_node = Node(new_pos, parent=nearest, cost=cost_to_new)\n            nearest.add_child(new_node)\n            tree_a.append(new_node)\n            grid_a.insert(new_node)\n\n            rewire(new_node, tree_a, grid_a, [], best_cost)\n\n            # Try connect tree_b to new_node\n            nearest_b = nearest_node(grid_b, tree_b, new_node.position)\n            if nearest_b is None:\n                continue\n            # Attempt direct connection from nearest_b to new_node: multiple steps if needed\n            connection_reached = False\n            from_pos = nearest_b.position\n            to_pos = new_node.position\n            dist_bt = dist(from_pos, to_pos)\n            if dist_bt <= 0:\n                continue\n            max_steps = max(1, int(dist_bt / self.step_size))\n            collision_free = True\n            last_pos = from_pos\n            cur_cost = nearest_b.cost\n            cur_parent = nearest_b\n            # Build a chain from nearest_b towards new_node with step_size steps (to allow rewiring)\n            chain_nodes = []\n            for step_i in range(1, max_steps + 1):\n                ratio = step_i / max_steps\n                inter_pos = tuple(from_pos[j] + ratio * (to_pos[j] - from_pos[j]) for j in range(dim))\n                if in_obstacle(inter_pos) or edge_in_obstacle(last_pos, inter_pos):\n                    collision_free = False\n                    break\n                step_cost = dist(last_pos, inter_pos)\n                new_cost = cur_cost + step_cost\n                if new_cost >= best_cost:\n                    collision_free = False\n                    break\n                new_n = Node(inter_pos, parent=cur_parent, cost=new_cost)\n                chain_nodes.append(new_n)\n                last_pos = inter_pos\n                cur_parent = new_n\n                cur_cost = new_cost\n            if collision_free:\n                # Attach chain nodes to tree_b and grid\n                for cn in chain_nodes:\n                    cn.parent.add_child(cn)\n                    tree_b.append(cn)\n                    grid_b.insert(cn)\n                    rewire(cn, tree_b, grid_b, [], best_cost)\n                # Now attempt to connect new_node parent side to chain last node\n                if dist(cur_parent.position, new_node.position) < 1e-8:\n                    # same point, connection effective\n                    connection_reached = True\n                    connect_node = cur_parent\n                else:\n                    # Check last edge\n                    if (not edge_in_obstacle(cur_parent.position, new_node.position) and\n                        not in_obstacle(new_node.position)):\n                        new_node.parent.remove_child(new_node)\n                        new_node.parent = cur_parent\n                        cur_parent.add_child(new_node)\n                        new_node.cost = cur_parent.cost + dist(cur_parent.position, new_node.position)\n                        tree_b.append(new_node)\n                        grid_b.insert(new_node)\n                        rewire(new_node, tree_b, grid_b, [], best_cost)\n                        connection_reached = True\n                        connect_node = new_node\n                if connection_reached:\n                    total_cost = new_node.cost + new_node.parent.cost if new_node.parent else new_node.cost\n                    if total_cost < best_cost:\n                        best_cost = total_cost\n                        path = backtrack_path(new_node if not reverse_connection else connect_node,\n                                              connect_node if not reverse_connection else new_node)\n                        # Iterative shortcutting for smoother path refinement\n                        for _ in range(3):\n                            path = shortcut_path(path)\n                        best_path = path\n                        # Early return on improved solution\n                        return PlannerResult(success=True,\n                                             path=best_path,\n                                             nodes=tree_start + tree_goal,\n                                             edges=[])  # edges omitted for conciseness\n\n        return PlannerResult(success=False,\n                             path=[],\n                             nodes=tree_start + tree_goal,\n                             edges=[])",
    "objective": 20.49229,
    "time_improvement": -75.0,
    "length_improvement": 17.0,
    "smoothness_improvement": 1765.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.052894759178161624,
            "num_nodes_avg": 112.3,
            "path_length_avg": 162.66032895858493,
            "smoothness_avg": 0.04846002271646084,
            "success_improvement": 0.0,
            "time_improvement": -101.4822140669117,
            "length_improvement": 10.843296179944312,
            "smoothness_improvement": 658.5045881362474,
            "objective_score": -20.64616357142568
        },
        {
            "map_id": 1,
            "success_rate": 0.9,
            "time_avg": 0.06455872058868409,
            "num_nodes_avg": 233.9,
            "path_length_avg": 236.64509519059325,
            "smoothness_avg": 0.12402441267622374,
            "success_improvement": -9.999999999999998,
            "time_improvement": 60.906680526530444,
            "length_improvement": 21.00105577398609,
            "smoothness_improvement": 3091.2374693328943,
            "objective_score": -3.671175030984738
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.14364023208618165,
            "num_nodes_avg": 325.1,
            "path_length_avg": 123.44203270837511,
            "smoothness_avg": 0.12933275969884014,
            "success_improvement": 0.0,
            "time_improvement": -185.6481516602059,
            "length_improvement": 18.015679553030374,
            "smoothness_improvement": 1545.103157017948,
            "objective_score": -37.15952198115381
        }
    ],
    "success_rate": 0.9666666666666667
}
{
    "operator": "m3",
    "algorithm_description": "An enhanced bidirectional Rapidly-exploring Random Tree planner with goal bias, adaptive sampling within bounds, and incremental local rewiring for path optimization. It grows two trees alternately, extends them towards sampled points with collision checking, rewires nearby nodes to improve path costs efficiently, and attempts connection between trees each iteration. Upon connection, it reconstructs and shortcuts the path to achieve better length and smoothness with efficient use of collision checks and node management.",
    "planning_mechanism": "The planner uses alternating expansions from start and goal trees guided by goal-biased random sampling, adaptive steering steps, localized rewiring within a computed neighborhood radius to optimize paths incrementally, and attempts fast tree connections. It maintains nodes and edges coherently and applies shortcutting at the end to improve smoothness and path quality while respecting obstacle and map bounds constraints.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.children = []\n        self.cost = cost\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        path, node = [], self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=3000, step_size=6.0, goal_sample_rate=0.1, rewire_factor=1.5):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.rewire_factor = rewire_factor\n\n    def plan(self, map):\n        bounds = map.size\n        start, goal = map.start, map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = dim == 3\n\n        start_tree = [Node(start)]\n        goal_tree = [Node(goal)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        def in_obstacle(p):\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d = obs\n                    if x <= p[0] <= x+w and y <= p[1] <= y+h and z <= p[2] <= z+d:\n                        return True\n                else:\n                    x,y,w,h = obs\n                    if x <= p[0] <= x+w and y <= p[1] <= y+h:\n                        return True\n            return False\n\n        def edge_in_obstacle(p1, p2, resolution=1.0):\n            dist = self._dist(p1,p2)\n            steps = max(1, int(dist / resolution))\n            for i in range(steps+1):\n                interp = tuple(p1[d] + (p2[d]-p1[d])*i/steps for d in range(dim))\n                if in_obstacle(interp):\n                    return True\n            return False\n\n        def sample_free():\n            import random\n            if random.random() < self.goal_sample_rate:\n                return goal\n            while True:\n                p = tuple(random.uniform(0,bounds[d]) for d in range(dim))\n                if not in_obstacle(p):\n                    return p\n\n        def nearest(tree, point):\n            min_dist, nearest_node = float('inf'), None\n            for node in tree:\n                dist = self._dist(node.position, point)\n                if dist < min_dist:\n                    min_dist = dist\n                    nearest_node = node\n            return nearest_node\n\n        def near(tree, point, radius):\n            radius_sq = radius*radius\n            return [n for n in tree if self._dist_sq(n.position, point) <= radius_sq]\n\n        def steer(from_pos, to_pos):\n            dist = self._dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d]-from_pos[d])*ratio for d in range(dim))\n\n        def valid_edge(p1, p2):\n            return (not in_obstacle(p2)) and (not edge_in_obstacle(p1, p2))\n\n        def rewire(new_node, tree, radius):\n            neighbors = near(tree, new_node.position, radius)\n            for neighbor in neighbors:\n                if neighbor is new_node.parent:\n                    continue\n                cost_through_new = new_node.cost + self._dist(new_node.position, neighbor.position)\n                if cost_through_new + 1e-7 < neighbor.cost and valid_edge(new_node.position, neighbor.position):\n                    # Update parent-child connections\n                    if neighbor.parent:\n                        try:\n                            neighbor.parent.children.remove(neighbor)\n                        except ValueError:\n                            pass\n                    neighbor.parent = new_node\n                    neighbor.cost = cost_through_new\n                    new_node.children.append(neighbor)\n                    update_children_costs(neighbor)\n\n        def update_children_costs(node):\n            stack = [node]\n            while stack:\n                current = stack.pop()\n                for child in current.children:\n                    new_cost = current.cost + self._dist(current.position, child.position)\n                    if new_cost + 1e-7 < child.cost:\n                        child.cost = new_cost\n                        child.parent = current\n                        stack.append(child)\n\n        def extend(tree, sample_point):\n            nearest_node = nearest(tree, sample_point)\n            new_pos = steer(nearest_node.position, sample_point)\n            if not valid_edge(nearest_node.position, new_pos):\n                return None\n            # Determine near nodes for possible better parent\n            rewire_radius = min(self.rewire_factor * (self.step_size * (len(nodes)+1)**(-1.0/(dim+1))), self.step_size*8)\n            near_nodes = near(tree, new_pos, rewire_radius)\n            cost_min = nearest_node.cost + self._dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for near_node in near_nodes:\n                cost_through_near = near_node.cost + self._dist(near_node.position, new_pos)\n                if cost_through_near + 1e-7 < cost_min and valid_edge(near_node.position, new_pos):\n                    best_parent = near_node\n                    cost_min = cost_through_near\n            new_node = Node(new_pos, best_parent, cost_min)\n            best_parent.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n            rewire(new_node, tree, rewire_radius)\n            return new_node\n\n        def connect(tree, target_node):\n            current = nearest(tree, target_node.position)\n            while True:\n                new_pos = steer(current.position, target_node.position)\n                if not valid_edge(current.position, new_pos):\n                    return None\n                new_cost = current.cost + self._dist(current.position, new_pos)\n                new_node = Node(new_pos, current, new_cost)\n                current.add_child(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((current, new_node))\n                # Local rewiring for new_node\n                rewire_radius = min(self.rewire_factor * (self.step_size * (len(nodes)+1)**(-1.0/(dim+1))), self.step_size*8)\n                rewire(new_node, tree, rewire_radius)\n                if self._dist(new_node.position, target_node.position) <= self.step_size:\n                    if valid_edge(new_node.position, target_node.position):\n                        final_cost = new_node.cost + self._dist(new_node.position, target_node.position)\n                        final_node = Node(target_node.position, new_node, final_cost)\n                        new_node.add_child(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n                current = new_node\n\n        def shortcut_path(path):\n            if len(path) <= 2:\n                return path\n            shortcut = [path[0]]\n            i = 0\n            while i < len(path)-1:\n                j = len(path)-1\n                while j > i+1:\n                    if not edge_in_obstacle(path[i], path[j]):\n                        break\n                    j -= 1\n                shortcut.append(path[j])\n                i = j\n            return shortcut\n\n        for iter_count in range(self.max_iter):\n            expanding_tree, other_tree = (start_tree, goal_tree) if iter_count % 2 == 0 else (goal_tree, start_tree)\n            sample = sample_free()\n            new_node = extend(expanding_tree, sample)\n            if new_node is None:\n                continue\n            connected_node = connect(other_tree, new_node)\n            if connected_node:\n                path_start = new_node.path_from_root()\n                path_goal = connected_node.path_from_root()\n                if path_start[-1] == path_goal[-1]:\n                    full_path = path_start + path_goal[-2::-1]\n                else:\n                    full_path = path_start + path_goal[::-1]\n                short_path = shortcut_path(full_path)\n                return PlannerResult(True, short_path, nodes, edges)\n\n        return PlannerResult(False, [], nodes, edges)\n\n    def _dist(self, a,b):\n        return sum((a[d]-b[d])**2 for d in range(len(a)))**0.5\n\n    def _dist_sq(self, a,b):\n        return sum((a[d]-b[d])**2 for d in range(len(a)))",
    "objective": -28.34614,
    "time_improvement": 33.0,
    "length_improvement": 16.0,
    "smoothness_improvement": 1738.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.015407323837280273,
            "num_nodes_avg": 72.7,
            "path_length_avg": 166.0049115375396,
            "smoothness_avg": 0.051653195366249294,
            "success_improvement": 0.0,
            "time_improvement": 41.31173356654978,
            "length_improvement": 9.010077470116768,
            "smoothness_improvement": 708.4846741908297,
            "objective_score": 21.341989922989143
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.04900016784667969,
            "num_nodes_avg": 218.4,
            "path_length_avg": 232.8627485806196,
            "smoothness_avg": 0.10944763653939235,
            "success_improvement": 0.0,
            "time_improvement": 70.32811061903782,
            "length_improvement": 22.26371194120606,
            "smoothness_improvement": 2716.1665201047535,
            "objective_score": 48.03749295095875
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.056807971000671385,
            "num_nodes_avg": 184.6,
            "path_length_avg": 123.96611989729759,
            "smoothness_avg": 0.14857794458806553,
            "success_improvement": 0.0,
            "time_improvement": -12.97038218493259,
            "length_improvement": 17.667605796498194,
            "smoothness_improvement": 1789.900488277112,
            "objective_score": 15.658951263804699
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "time_expert",
    "algorithm_description": "A bidirectional sampling-based planner integrating adaptive informed sampling with dynamic step sizing and efficient rewiring to accelerate convergence and improve path optimality. The planner dynamically adjusts expansion steps based on proximity, uses an adaptive neighborhood for rewiring, performs early path connection attempts with minimal collision checks, and applies aggressive shortcutting for enhanced path smoothness and length reduction.",
    "planning_mechanism": "The planner alternates expanding two trees grown from start and goal positions. It samples new points inside an evolving informed ellipsoid to constrain search space effectively. Expansion steps dynamically adapt to sample distances, offering finer resolution near obstacles and longer leaps in open spaces. Efficient rewiring with radius scaling optimizes local paths, and early tree connections allow rapid discovery of feasible paths. Final paths undergo aggressive shortcutting for smoothness and length enhancement.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n    def add_child(self, child):\n        self.children.append(child)\nclass Planner:\n    def __init__(self, max_iter=3500, base_rewire_radius=10.0, min_step=1.5, max_step=8.0):\n        self.max_iter = max_iter\n        self.base_rewire_radius = base_rewire_radius\n        self.min_step = min_step\n        self.max_step = max_step\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        edges = []\n        best_cost = float('inf')\n        best_path = []\n\n        def dist(a,b):\n            return math.dist(a,b)\n\n        def in_collision(p):\n            for o in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d = o\n                    px,py,pz = p\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                        return True\n                else:\n                    x,y,w,h = o\n                    px,py = p\n                    if x <= px <= x+w and y <= py <= y+h:\n                        return True\n            return False\n\n        def edge_collision(p1, p2, step_res=0.8):\n            distance = dist(p1,p2)\n            steps = max(1, int(distance/step_res))\n            for i in range(steps+1):\n                interp = tuple(p1[d] + (p2[d]-p1[d])*i/steps for d in range(dim))\n                if in_collision(interp):\n                    return True\n            return False\n\n        def steer(from_p, to_p, max_step):\n            d = dist(from_p,to_p)\n            if d <= max_step:\n                return to_p\n            ratio = max_step / d\n            return tuple(from_p[i] + (to_p[i]-from_p[i])*ratio for i in range(dim))\n\n        def nearest(tree, p):\n            best = None\n            best_dist = float('inf')\n            for n in tree:\n                d = 0.0\n                for i in range(dim):\n                    diff = n.position[i] - p[i]\n                    d += diff*diff\n                    if d > best_dist*best_dist:\n                        break\n                d = math.sqrt(d)\n                if d < best_dist:\n                    best_dist = d\n                    best = n\n            return best\n\n        def near(tree, p, radius):\n            r2 = radius*radius\n            result = []\n            for n in tree:\n                d2 = 0.0\n                for i in range(dim):\n                    diff = n.position[i] - p[i]\n                    d2 += diff*diff\n                    if d2 > r2:\n                        break\n                else:\n                    result.append(n)\n            return result\n\n        def extract_path(node_from_start, node_from_goal):\n            path_start = []\n            cur = node_from_start\n            while cur:\n                path_start.append(cur.position)\n                cur = cur.parent\n            path_start.reverse()\n            path_goal = []\n            cur = node_from_goal\n            while cur:\n                path_goal.append(cur.position)\n                cur = cur.parent\n            return path_start + path_goal\n\n        def shortcut(path):\n            if len(path) <= 2:\n                return path\n            i = 0\n            while i < len(path)-2:\n                j = len(path)-1\n                while j > i+1:\n                    if not edge_collision(path[i], path[j], step_res=0.5):\n                        path = path[:i+1] + path[j:]\n                        break\n                    j -= 1\n                i += 1\n            return path\n\n        def informed_sample(c_best):\n            if c_best == float('inf'):\n                while True:\n                    sample = tuple(random.uniform(0,bounds[i]) for i in range(dim))\n                    if not in_collision(sample):\n                        return sample\n            c_min = dist(start_pos, goal_pos)\n            if c_min == 0.0:\n                return goal_pos\n            center = tuple((start_pos[i]+goal_pos[i])*0.5 for i in range(dim))\n            a1 = [(goal_pos[i]-start_pos[i])/c_min for i in range(dim)]\n\n            def mat_vec_mult(mat, vec):\n                return tuple(sum(mat[i][j]*vec[j] for j in range(dim)) for i in range(dim))\n\n            if dim == 2:\n                cos_th = max(min(a1[0],1.0),-1.0)\n                theta = math.acos(cos_th)\n                if a1[1]<0:\n                    theta = -theta\n                R = [[math.cos(theta), -math.sin(theta)],\n                     [math.sin(theta),  math.cos(theta)]]\n            elif dim == 3:\n                x = a1\n                I = [[1 if i==j else 0 for j in range(3)] for i in range(3)]\n                v = [x[0]-1, x[1], x[2]]\n                norm_v = math.sqrt(sum(vi*vi for vi in v))\n                if norm_v < 1e-10:\n                    R = I\n                else:\n                    v = [vi/norm_v for vi in v]\n                    R = [[I[i][j]-2*v[i]*v[j] for j in range(3)] for i in range(3)]\n            else:\n                R = [[1 if i==j else 0 for j in range(dim)] for i in range(dim)]\n\n            L1 = c_best*0.5\n            L2 = math.sqrt(max(c_best*c_best - c_min*c_min,0))*0.5\n\n            while True:\n                while True:\n                    sample = [random.uniform(-1,1) for _ in range(dim)]\n                    norm_s = math.sqrt(sum(x*x for x in sample))\n                    if 0 < norm_s <= 1:\n                        break\n                unit_s = [x/norm_s for x in sample]\n                r = random.random()**(1/dim)\n                unit_ball = [r * us for us in unit_s]\n                ellip = [L1*unit_ball[0]] + [L2*unit_ball[i] for i in range(1,dim)]\n                rotated = mat_vec_mult(R, ellip)\n                point = tuple(center[i] + rotated[i] for i in range(dim))\n                if all(0 <= point[i] <= bounds[i] for i in range(dim)) and not in_collision(point):\n                    return point\n\n        def rewire_radius(num_nodes):\n            if num_nodes < 2:\n                return self.base_rewire_radius\n            volume = 1.0\n            for b in bounds:\n                volume *= b\n            gamma = 2 * (1 + 1/dim)**(1/dim) * (volume**(1/dim))\n            radius = min(self.base_rewire_radius,\n                         gamma * (math.log(num_nodes)/num_nodes)**(1/dim))\n            return radius\n\n        def update_descendants_cost(node, delta):\n            # Recursively update costs of descendants after rewiring\n            for c in node.children:\n                old_cost = c.cost\n                c.cost = node.cost + dist(node.position, c.position)\n                ddelta = c.cost - old_cost\n                if ddelta > 1e-9:\n                    update_descendants_cost(c, ddelta)\n\n        def rewire(tree, new_node):\n            r = rewire_radius(len(tree))\n            nbs = near(tree, new_node.position, r)\n            for nb in nbs:\n                if nb == new_node.parent:\n                    continue\n                if edge_collision(new_node.position, nb.position):\n                    continue\n                edge_cost = dist(new_node.position, nb.position)\n                new_cost = new_node.cost + edge_cost\n                if new_cost + 1e-9 < nb.cost:\n                    # Update parent-child links cleanly\n                    if nb.parent:\n                        try:\n                            nb.parent.children.remove(nb)\n                        except Exception:\n                            pass\n                    nb.parent = new_node\n                    nb.cost = new_cost\n                    new_node.add_child(nb)\n                    update_descendants_cost(nb, new_cost - nb.cost)\n\n        for it in range(self.max_iter):\n            sample = informed_sample(best_cost)\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest_node = nearest(tree_a, sample)\n                dist_to_sample = dist(nearest_node.position, sample)\n                # Adaptive step size: smaller steps near obstacles or when close to sample\n                step_size = max(self.min_step, min(self.max_step, dist_to_sample*0.9))\n                new_pos = steer(nearest_node.position, sample, step_size)\n                if in_collision(new_pos):\n                    continue\n                if edge_collision(nearest_node.position, new_pos):\n                    continue\n\n                new_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n                new_node = Node(new_pos, parent=nearest_node, cost=new_cost)\n                nearest_node.add_child(new_node)\n                tree_a.append(new_node)\n                edges.append((nearest_node, new_node))\n\n                rewire(tree_a, new_node)\n\n                connect_node = nearest(tree_b, new_pos)\n                gap = dist(new_pos, connect_node.position)\n                connect_threshold = max(self.min_step*1.8, step_size*1.5)\n                if gap <= connect_threshold and not edge_collision(new_pos, connect_node.position):\n                    connect_new = Node(connect_node.position, parent=new_node, cost=new_node.cost+gap)\n                    new_node.add_child(connect_new)\n                    tree_b.append(connect_new)\n                    edges.append((new_node, connect_new))\n\n                    candidate_path = extract_path(connect_new, connect_node)\n                    candidate_path = shortcut(candidate_path)\n                    candidate_cost = 0.0\n                    for i in range(len(candidate_path)-1):\n                        candidate_cost += dist(candidate_path[i], candidate_path[i+1])\n                    if candidate_cost < best_cost:\n                        best_cost = candidate_cost\n                        best_path = candidate_path\n\n            if best_path:\n                # Early stop on improved solution\n                return PlannerResult(True, best_path, start_tree + goal_tree, edges)\n\n        # Failed to find path\n        return PlannerResult(False, [], start_tree + goal_tree, edges)",
    "objective": -17.9425,
    "time_improvement": 55.0,
    "length_improvement": 14.0,
    "smoothness_improvement": 1973.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.024510002136230467,
            "num_nodes_avg": 89.3,
            "path_length_avg": 169.98794320046673,
            "smoothness_avg": 0.05230496911847674,
            "success_improvement": 0.0,
            "time_improvement": 6.638586243317057,
            "length_improvement": 6.826914700490789,
            "smoothness_improvement": 718.6863487625457,
            "objective_score": 9.68115643710232
        },
        {
            "map_id": 1,
            "success_rate": 0.9,
            "time_avg": 0.021294546127319337,
            "num_nodes_avg": 170.8,
            "path_length_avg": 242.83620040387973,
            "smoothness_avg": 0.14122531079305436,
            "success_improvement": -9.999999999999998,
            "time_improvement": 87.10515810711797,
            "length_improvement": 18.934286652708124,
            "smoothness_improvement": 3533.8289671850803,
            "objective_score": 5.161264259685675
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.014145779609680175,
            "num_nodes_avg": 140.4,
            "path_length_avg": 127.7509641243997,
            "smoothness_avg": 0.13886869349713132,
            "success_improvement": 0.0,
            "time_improvement": 71.86919193451727,
            "length_improvement": 15.153892475771663,
            "smoothness_improvement": 1666.399531062796,
            "objective_score": 38.98509072113217
        }
    ],
    "success_rate": 0.9666666666666667
}
{
    "operator": "time_expert",
    "algorithm_description": "A bidirectional RRT* planner with dynamic informed sampling, adaptive step size control, and efficient rewiring, employing spatial hashing for faster neighbor queries. This planner prunes the sampling space based on current best path cost and dynamically adjusts connection radius and step sizes for better exploration-exploitation balance, resulting in faster convergence, improved path quality, and smoother final paths. It aggressively shortcuts the best found path to enhance smoothness and reduce unnecessary detours.",
    "planning_mechanism": "The planner grows two trees from start and goal positions alternately. Each iteration samples within an informed ellipsoid constrained by current best path cost, steering towards samples with adaptive step sizes depending on local density and distance. Neighbors for rewiring are found efficiently via spatial hashing to reduce overhead. Connections between trees are attempted frequently to discover valid paths early. When a path is found, aggressive shortcutting refines the path for smoothness and length, with pruning of unpromising nodes for efficiency.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\nclass Planner:\n    def __init__(self, max_iter=3000, base_radius=12.0, min_step=1.2, max_step=7.5):\n        self.max_iter = max_iter\n        self.base_radius = base_radius\n        self.min_step = min_step\n        self.max_step = max_step\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n        bounds = map.size\n        dim = len(bounds)\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = (dim == 3)\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        edges = []\n\n        best_cost = float('inf')\n        best_path = []\n\n        def dist(a, b):\n            d = 0.0\n            for i in range(dim):\n                diff = a[i] - b[i]\n                d += diff * diff\n            return math.sqrt(d)\n\n        def in_collision(p):\n            for o in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = o\n                    px, py, pz = p\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w_o, h_o = o\n                    px, py = p\n                    if x <= px <= x + w_o and y <= py <= y + h_o:\n                        return True\n            return False\n\n        def edge_collision(p1, p2, step_res=0.5):\n            distance = dist(p1, p2)\n            steps = max(1, int(distance / step_res))\n            for i in range(steps + 1):\n                interp = tuple(p1[d] + (p2[d] - p1[d]) * i / steps for d in range(dim))\n                if in_collision(interp):\n                    return True\n            return False\n\n        def steer(from_p, to_p, max_step):\n            d = dist(from_p, to_p)\n            if d <= max_step:\n                return to_p\n            ratio = max_step / d\n            return tuple(from_p[i] + (to_p[i] - from_p[i]) * ratio for i in range(dim))\n\n        # Spatial hashing grid for near-node queries to speed rewiring\n        cell_size = self.base_radius * 0.75\n        def grid_hash(p):\n            return tuple(int(p[i] / cell_size) for i in range(dim))\n        def insert_node(grid, node):\n            cell = grid_hash(node.position)\n            if cell not in grid:\n                grid[cell] = []\n            grid[cell].append(node)\n        def query_near(grid, p, radius):\n            r2 = radius * radius\n            cell = grid_hash(p)\n            neighbors = []\n            neighbors_cells = []\n            # search in neighbor cells (including diagonals)\n            def neighbors_around(cell):\n                if dim == 2:\n                    x,y = cell\n                    for dx in (-1,0,1):\n                        for dy in (-1,0,1):\n                            yield (x+dx, y+dy)\n                else:\n                    x,y,z = cell\n                    for dx in (-1,0,1):\n                        for dy in (-1,0,1):\n                            for dz in (-1,0,1):\n                                yield (x+dx, y+dy, z+dz)\n            for nc in neighbors_around(cell):\n                if nc in grid:\n                    for node in grid[nc]:\n                        d2 = 0.0\n                        for i in range(dim):\n                            diff = node.position[i] - p[i]\n                            d2 += diff*diff\n                            if d2 > r2:\n                                break\n                        else:\n                            neighbors.append(node)\n            return neighbors\n\n        def extract_path(node_from_start, node_from_goal):\n            path_start = []\n            cur = node_from_start\n            while cur:\n                path_start.append(cur.position)\n                cur = cur.parent\n            path_start.reverse()\n            path_goal = []\n            cur = node_from_goal\n            while cur:\n                path_goal.append(cur.position)\n                cur = cur.parent\n            return path_start + path_goal\n\n        def shortcut_path(path):\n            if len(path) <= 2:\n                return path\n            i = 0\n            while i < len(path) - 2:\n                j = len(path) - 1\n                changed = False\n                while j > i + 1:\n                    if not edge_collision(path[i], path[j], step_res=0.4):\n                        path = path[:i+1] + path[j:]\n                        changed = True\n                        break\n                    j -= 1\n                if not changed:\n                    i += 1\n            return path\n\n        def calc_volume(bounds):\n            v = 1.0\n            for b in bounds:\n                v *= b\n            return v\n\n        def informed_sample(c_best):\n            if c_best == float('inf'):\n                # Uniform sample in bounds until non-colliding\n                for _ in range(100):\n                    sample = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                    if not in_collision(sample):\n                        return sample\n                # fallback: return start to avoid infinite loop\n                return start_pos\n            c_min = dist(start_pos, goal_pos)\n            if c_min == 0.0:\n                return goal_pos\n            center = tuple((start_pos[i] + goal_pos[i]) * 0.5 for i in range(dim))\n            a1 = [(goal_pos[i] - start_pos[i]) / c_min for i in range(dim)]\n\n            def mat_vec_mult(mat, vec):\n                return tuple(sum(mat[i][j] * vec[j] for j in range(dim)) for i in range(dim))\n\n            # Calculate rotation matrix R that aligns x-axis to a1\n            if dim == 2:\n                cos_theta = a1[0]\n                sin_theta = a1[1]\n                R = [[cos_theta, -sin_theta],\n                     [sin_theta,  cos_theta]]\n            elif dim == 3:\n                # Rodrigues rotation formula\n                x = a1\n                I = [[1 if i == j else 0 for j in range(3)] for i in range(3)]\n                v = [0,0,0]\n                for i in range(3):\n                    v[i] = 0\n                # Rotation axis = cross([1,0,0],a1) = (0,-a1[2],a1[1])\n                axis = [0, -a1[2], a1[1]]\n                s = math.sqrt(axis[0]**2 + axis[1]**2 + axis[2]**2)\n                if s < 1e-12:\n                    R = I\n                else:\n                    axis = [axis[i]/s for i in range(3)]\n                    c = a1[0]\n                    K = [[0, -axis[2], axis[1]],\n                         [axis[2], 0, -axis[0]],\n                         [-axis[1], axis[0], 0]]\n                    R = [[0,0,0],[0,0,0],[0,0,0]]\n                    for i in range(3):\n                        for j in range(3):\n                            R[i][j] = I[i][j] + K[i][j]*s + (K[i][0]*K[0][j] + K[i][1]*K[1][j] + K[i][2]*K[2][j])*(1 - c)\n            else:\n                # Higher dims identity\n                R = [[1 if i==j else 0 for j in range(dim)] for i in range(dim)]\n\n            L1 = c_best * 0.5\n            L2 = math.sqrt(max(c_best*c_best - c_min*c_min, 0)) * 0.5\n\n            for _ in range(100):\n                # Sample unit ball inside dim-dim\n                while True:\n                    sample = [random.uniform(-1,1) for _ in range(dim)]\n                    norm_s = math.sqrt(sum(x*x for x in sample))\n                    if 1e-12 < norm_s <= 1:\n                        break\n                unit_s = [x / norm_s for x in sample]\n                r = random.random() ** (1.0 / dim)\n                unit_ball = [r * us for us in unit_s]\n                # Ellipsoid sample\n                ellip = [L1 * unit_ball[0]] + [L2 * unit_ball[i] for i in range(1, dim)]\n                rotated = []\n                if dim in (2,3):\n                    rotated = list(mat_vec_mult(R, ellip))\n                else:\n                    rotated = ellip\n                point = tuple(center[i] + rotated[i] for i in range(dim))\n                if all(0 <= point[i] <= bounds[i] for i in range(dim)) and not in_collision(point):\n                    return point\n            # fallback to uniform\n            for _ in range(100):\n                sample = tuple(random.uniform(0,bounds[i]) for i in range(dim))\n                if not in_collision(sample):\n                    return sample\n            return start_pos  # fallback\n\n        def rewire_radius(num_nodes):\n            if num_nodes < 2:\n                return self.base_radius\n            volume = calc_volume(bounds)\n            gamma = 2 * ((1 + 1 / dim) ** (1/dim)) * (volume ** (1/dim))\n            radius = min(self.base_radius,\n                         gamma * ((math.log(num_nodes) / num_nodes) ** (1 / dim)))\n            return radius\n\n        def update_descendants_cost(node):\n            for c in node.children:\n                c_new_cost = node.cost + dist(node.position, c.position)\n                if c_new_cost + 1e-9 < c.cost:\n                    c.cost = c_new_cost\n                    c.parent = node\n                    update_descendants_cost(c)\n\n        def rewire(tree, grid, new_node):\n            radius = rewire_radius(len(tree))\n            neighbors = query_near(grid, new_node.position, radius)\n            for nb in neighbors:\n                if nb is new_node.parent:\n                    continue\n                if edge_collision(new_node.position, nb.position):\n                    continue\n                edge_cost = dist(new_node.position, nb.position)\n                new_cost = new_node.cost + edge_cost\n                if new_cost + 1e-9 < nb.cost:\n                    # Update parent-child references cleanly\n                    if nb.parent:\n                        try:\n                            nb.parent.children.remove(nb)\n                        except:\n                            pass\n                    nb.parent = new_node\n                    nb.cost = new_cost\n                    new_node.add_child(nb)\n                    update_descendants_cost(nb)\n\n        start_grid = dict()\n        goal_grid = dict()\n        insert_node(start_grid, start_tree[0])\n        insert_node(goal_grid, goal_tree[0])\n\n        # Prune nodes far worse than best_cost for efficiency\n        pruning_margin = 1.5\n\n        for iter in range(self.max_iter):\n            sample = informed_sample(best_cost)\n\n            for tree_a, tree_b, grid_a, grid_b in [(start_tree, goal_tree, start_grid, goal_grid),\n                                                  (goal_tree, start_tree, goal_grid, start_grid)]:\n                nearest_node = None\n                min_dist_sq = float('inf')\n                for node in tree_a[-50:] if len(tree_a) > 100 else tree_a:\n                    d2 = 0.0\n                    for i in range(dim):\n                        diff = node.position[i] - sample[i]\n                        d2 += diff * diff\n                        if d2 > min_dist_sq:\n                            break\n                    else:\n                        if d2 < min_dist_sq:\n                            nearest_node = node\n                            min_dist_sq = d2\n                if nearest_node is None:\n                    continue\n\n                dist_to_sample = math.sqrt(min_dist_sq)\n                # Adaptive step: smaller step near goal or if very close\n                step = min(max(dist_to_sample*0.8, self.min_step), self.max_step)\n\n                new_pos = steer(nearest_node.position, sample, step)\n                if in_collision(new_pos) or edge_collision(nearest_node.position, new_pos):\n                    continue\n\n                new_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n                if best_cost < float('inf') and new_cost > best_cost * pruning_margin:\n                    # Prune expansions way worse than best found\n                    continue\n\n                new_node = Node(new_pos, nearest_node, new_cost)\n                nearest_node.add_child(new_node)\n                tree_a.append(new_node)\n                insert_node(grid_a, new_node)\n                edges.append((nearest_node, new_node))\n\n                # Rewire the tree around the new node efficiently\n                rewire(tree_a, grid_a, new_node)\n\n                connect_node = None\n                res_min_dist_sq = float('inf')\n                for node in tree_b[-50:] if len(tree_b) > 100 else tree_b:\n                    d2 = 0.0\n                    for i in range(dim):\n                        diff = node.position[i] - new_pos[i]\n                        d2 += diff * diff\n                        if d2 > res_min_dist_sq:\n                            break\n                    else:\n                        if d2 < res_min_dist_sq:\n                            connect_node = node\n                            res_min_dist_sq = d2\n                if connect_node is None:\n                    continue\n\n                gap = math.sqrt(res_min_dist_sq)\n                threshold = max(self.min_step * 1.6, step * 1.4)\n                if gap <= threshold and not edge_collision(new_pos, connect_node.position):\n                    # Connect the trees by linking closest node from tree_b to new_node\n                    connect_new = Node(connect_node.position, new_node, new_node.cost + gap)\n                    new_node.add_child(connect_new)\n                    tree_b.append(connect_new)\n                    insert_node(grid_b, connect_new)\n                    edges.append((new_node, connect_new))\n\n                    # Construct candidate path\n                    candidate_path = extract_path(connect_new, connect_node)\n                    candidate_path = shortcut_path(candidate_path)\n\n                    candidate_cost = 0.0\n                    for i in range(len(candidate_path) - 1):\n                        candidate_cost += dist(candidate_path[i], candidate_path[i + 1])\n\n                    if candidate_cost + 1e-9 < best_cost:\n                        best_cost = candidate_cost\n                        best_path = candidate_path\n                        # Aggressive pruning of nodes far worse than best_cost\n                        threshold_cost = best_cost * pruning_margin\n                        def prune_tree(tree):\n                            new_tree = []\n                            new_grid = dict()\n                            for node in tree:\n                                if node.cost <= threshold_cost:\n                                    new_tree.append(node)\n                                    insert_node(new_grid, node)\n                                else:\n                                    # Clean up parent children ref\n                                    if node.parent and node in node.parent.children:\n                                        try:\n                                            node.parent.children.remove(node)\n                                        except:\n                                            pass\n                            return new_tree, new_grid\n\n                        start_tree, start_grid = prune_tree(start_tree)\n                        goal_tree, goal_grid = prune_tree(goal_tree)\n\n                        # Reduce iteration count if solution found quickly\n                        if best_cost < dist(start_pos, goal_pos) * 1.1:\n                            break\n\n            if best_path:\n                return PlannerResult(True, best_path, start_tree + goal_tree, edges)\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)",
    "objective": -3.70711,
    "time_improvement": 11.0,
    "length_improvement": 13.0,
    "smoothness_improvement": 1851.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 0.9,
            "time_avg": 0.04454529285430908,
            "num_nodes_avg": 106.2,
            "path_length_avg": 172.0167729533619,
            "smoothness_avg": 0.05143788232580502,
            "success_improvement": -9.999999999999998,
            "time_improvement": -69.67813768307445,
            "length_improvement": 5.714880964064208,
            "smoothness_improvement": 705.1145575481258,
            "objective_score": -63.948939938743166
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.042364501953125,
            "num_nodes_avg": 209.4,
            "path_length_avg": 238.8151856459076,
            "smoothness_avg": 0.11803044143290826,
            "success_improvement": 0.0,
            "time_improvement": 74.34631612761181,
            "length_improvement": 20.276617117411732,
            "smoothness_improvement": 2937.0082719594066,
            "objective_score": 49.154906468527614
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.03542306423187256,
            "num_nodes_avg": 178.6,
            "path_length_avg": 131.7438241214367,
            "smoothness_avg": 0.1579760640108412,
            "success_improvement": 0.0,
            "time_improvement": 29.55641551801306,
            "length_improvement": 12.502024985300917,
            "smoothness_improvement": 1909.4438736378017,
            "objective_score": 25.915359014773475
        }
    ],
    "success_rate": 0.9666666666666667
}
{
    "operator": "time_expert",
    "algorithm_description": "A bidirectional RRT* inspired planner leveraging adaptive informed sampling constrained by the best solution cost, combined with dynamic step sizing and efficient spatial hashing for near neighbor queries. It aggressively prunes unpromising nodes to maintain a compact search tree, rewires locally with an adaptive radius for optimal connectivity, and employs path shortcutting for smoothness and length improvements. The planning alternates between growing trees from start and goal, attempts early connection between them, and updates the best path incrementally, thereby enhancing efficiency, path quality, and smoothness.",
    "planning_mechanism": "A bidirectional planner grows two trees from start and goal alternately. Samples are drawn from an informed ellipsoid based on current best path cost to focus exploration. Expansion steps adapt to sampled distance but with tighter max step to reduce wasted exploration. Spatial hashing accelerates neighbor querying for rewiring, which adapts radius based on node count for optimal connections. Frequent cross-tree connection attempts enable rapid detection of feasible paths. The best path is incrementally updated and aggressively shortcut for smoothness and length. Pruning discards nodes with costs exceeding a margin beyond best cost, reducing overhead and search time.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\nclass Planner:\n    def __init__(self, max_iter=2500, base_radius=14.0, min_step=1.0, max_step=6.0,\n                 pruning_margin=1.3, neighbor_subsample=50):\n        self.max_iter = max_iter\n        self.base_radius = base_radius\n        self.min_step = min_step\n        self.max_step = max_step\n        self.pruning_margin = pruning_margin\n        self.neighbor_subsample = neighbor_subsample  # Max nodes to consider in rewiring & connection\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n\n        bounds = map.size\n        dim = len(bounds)\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = dim == 3\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        edges = []\n\n        best_cost = float('inf')\n        best_path = []\n\n        def dist(a, b):\n            s = 0.0\n            for i in range(dim):\n                d = a[i] - b[i]\n                s += d * d\n            return math.sqrt(s)\n\n        def in_collision(p):\n            for o in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = o\n                    if x <= p[0] <= x + w and y <= p[1] <= y + h and z <= p[2] <= z + d:\n                        return True\n                else:\n                    x, y, w_o, h_o = o\n                    if x <= p[0] <= x + w_o and y <= p[1] <= y + h_o:\n                        return True\n            return False\n\n        def edge_collision(p1, p2, step_res=0.45):\n            distance = dist(p1, p2)\n            steps = max(1, int(distance / step_res))\n            for i in range(steps + 1):\n                interp = tuple(p1[d] + (p2[d] - p1[d]) * i / steps for d in range(dim))\n                if in_collision(interp):\n                    return True\n            return False\n\n        def steer(from_p, to_p, max_step):\n            d = dist(from_p, to_p)\n            if d <= max_step:\n                return to_p\n            ratio = max_step / d\n            return tuple(from_p[i] + (to_p[i] - from_p[i]) * ratio for i in range(dim))\n\n        cell_size = self.base_radius * 0.6\n        def cell_hash(p):\n            return tuple(int(p[i] / cell_size) for i in range(dim))\n\n        def insert_node(grid, node):\n            c = cell_hash(node.position)\n            if c not in grid:\n                grid[c] = []\n            grid[c].append(node)\n\n        def query_near(grid, p, radius):\n            radius_sq = radius * radius\n            c = cell_hash(p)\n            neighbors = []\n            def neighbor_cells(c):\n                if dim == 2:\n                    x, y = c\n                    for dx in (-1, 0, 1):\n                        for dy in (-1, 0, 1):\n                            yield (x+dx, y+dy)\n                else:\n                    x,y,z = c\n                    for dx in (-1,0,1):\n                        for dy in (-1,0,1):\n                            for dz in (-1,0,1):\n                                yield (x+dx,y+dy,z+dz)\n            for nc in neighbor_cells(c):\n                if nc in grid:\n                    neighbors.extend(grid[nc])\n            # Filter by distance radius\n            filtered = []\n            for n in neighbors:\n                s = 0.0\n                for i in range(dim):\n                    diff = n.position[i] - p[i]\n                    s += diff*diff\n                    if s > radius_sq:\n                        break\n                else:\n                    filtered.append(n)\n            return filtered\n\n        def extract_path(node_start, node_goal):\n            path_start = []\n            cur = node_start\n            while cur:\n                path_start.append(cur.position)\n                cur = cur.parent\n            path_start.reverse()\n\n            path_goal = []\n            cur = node_goal\n            while cur:\n                path_goal.append(cur.position)\n                cur = cur.parent\n\n            return path_start + path_goal\n\n        def shortcut_path(path):\n            if len(path) <= 2:\n                return path\n            i = 0\n            while i < len(path) - 2:\n                j = len(path) - 1\n                done_shortcut = False\n                while j > i + 1:\n                    if not edge_collision(path[i], path[j], step_res=0.3):\n                        path = path[:i+1] + path[j:]\n                        done_shortcut = True\n                        break\n                    j -= 1\n                if not done_shortcut:\n                    i += 1\n            return path\n\n        def calc_volume(bounds):\n            vol = 1.0\n            for b in bounds:\n                vol *= b\n            return vol\n\n        def informed_sample(c_best):\n            if c_best == float('inf'):\n                for _ in range(100):\n                    s = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                    if not in_collision(s):\n                        return s\n                return start_pos\n            c_min = dist(start_pos, goal_pos)\n            if c_min < 1e-12:\n                return goal_pos\n            center = tuple((start_pos[i] + goal_pos[i]) * 0.5 for i in range(dim))\n            diff = [(goal_pos[i] - start_pos[i]) / c_min for i in range(dim)]\n\n            def mat_vec_mult(M, v):\n                return tuple(sum(M[i][j]*v[j] for j in range(dim)) for i in range(dim))\n\n            if dim == 2:\n                cos_theta = diff[0]\n                sin_theta = diff[1]\n                R = [[cos_theta, -sin_theta],\n                     [sin_theta,  cos_theta]]\n            elif dim == 3:\n                x, y, z = diff\n                I = [[1 if i == j else 0 for j in range(3)] for i in range(3)]\n                axis = [0, -z, y]\n                s = math.sqrt(sum(a*a for a in axis))\n                if s < 1e-12:\n                    R = I\n                else:\n                    axis = [a/s for a in axis]\n                    c = x\n                    K = [[0, -axis[2], axis[1]],\n                         [axis[2], 0, -axis[0]],\n                         [-axis[1], axis[0], 0]]\n                    R = [[0]*3 for _ in range(3)]\n                    for i in range(3):\n                        for j in range(3):\n                            R[i][j] = I[i][j] + K[i][j]*s + (\n                                sum(K[i][k]*K[k][j] for k in range(3))) * (1 - c)\n            else:\n                R = [[1 if i == j else 0 for j in range(dim)] for i in range(dim)]\n\n            L1 = c_best * 0.5\n            L2 = math.sqrt(max(c_best*c_best - c_min*c_min, 0)) * 0.5\n\n            for _ in range(75):\n                while True:\n                    sample_dir = [random.uniform(-1,1) for _ in range(dim)]\n                    norm_s = math.sqrt(sum(x*x for x in sample_dir))\n                    if 1e-12 < norm_s <= 1:\n                        break\n                unit_s = [x / norm_s for x in sample_dir]\n                radius_s = random.random() ** (1.0 / dim)\n                inside_ball = [radius_s * u for u in unit_s]\n\n                ellip = [L1 * inside_ball[0]] + [L2 * inside_ball[i] for i in range(1, dim)]\n                rotated = []\n                if dim in (2, 3): rotated = list(mat_vec_mult(R, ellip))\n                else: rotated = ellip\n                point = tuple(center[i] + rotated[i] for i in range(dim))\n                if all(0 <= point[i] <= bounds[i] for i in range(dim)) and not in_collision(point):\n                    return point\n            # fallback uniform sample\n            for _ in range(100):\n                s = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not in_collision(s):\n                    return s\n            return start_pos\n\n        def rewire_radius(num_nodes):\n            if num_nodes < 2:\n                return self.base_radius\n            volume = calc_volume(bounds)\n            gamma = 2 * ((1 + 1 / dim) ** (1 / dim)) * (volume ** (1 / dim))\n            r = gamma * ((math.log(num_nodes) / num_nodes) ** (1 / dim))\n            return min(self.base_radius, r)\n\n        def update_descendants_cost(node):\n            stack = list(node.children)\n            while stack:\n                c = stack.pop()\n                old_cost = c.cost\n                new_cost = c.parent.cost + dist(c.position, c.parent.position)\n                if new_cost + 1e-9 < old_cost:\n                    c.cost = new_cost\n                    stack.extend(c.children)\n\n        def rewire(tree, grid, new_node):\n            radius = rewire_radius(len(tree))\n            neighbors = query_near(grid, new_node.position, radius)\n            # Limit neighbors for efficiency\n            if len(neighbors) > self.neighbor_subsample:\n                neighbors = sorted(neighbors, key=lambda n: dist(n.position, new_node.position))[:self.neighbor_subsample]\n            for nb in neighbors:\n                if nb is new_node.parent:\n                    continue\n                if edge_collision(new_node.position, nb.position):\n                    continue\n                edge_cst = dist(new_node.position, nb.position)\n                new_cst = new_node.cost + edge_cst\n                if new_cst + 1e-9 < nb.cost:\n                    # Clean parent references\n                    if nb.parent:\n                        nb.parent.remove_child(nb)\n                    nb.parent = new_node\n                    nb.cost = new_cst\n                    new_node.add_child(nb)\n                    update_descendants_cost(nb)\n\n        start_grid = {}\n        goal_grid = {}\n        insert_node(start_grid, start_tree[0])\n        insert_node(goal_grid, goal_tree[0])\n\n        for it in range(self.max_iter):\n            sample = informed_sample(best_cost)\n\n            for tree_a, tree_b, grid_a, grid_b in [(start_tree, goal_tree, start_grid, goal_grid),\n                                                  (goal_tree, start_tree, goal_grid, start_grid)]:\n                # Nearest node by subsampling recent nodes or full if small\n                nodes_to_check = tree_a[-self.neighbor_subsample:] if len(tree_a) > 100 else tree_a\n                nearest = None\n                min_d_sq = float('inf')\n                for node in nodes_to_check:\n                    s = 0.0\n                    for i in range(dim):\n                        d = node.position[i] - sample[i]\n                        s += d*d\n                        if s > min_d_sq:\n                            break\n                    else:\n                        if s < min_d_sq:\n                            nearest = node\n                            min_d_sq = s\n                if nearest is None:\n                    continue\n                dist_s = math.sqrt(min_d_sq)\n                # Adaptive step smaller max to limit wasted expansions\n                step = min(max(dist_s*0.7, self.min_step), self.max_step)\n\n                new_pos = steer(nearest.position, sample, step)\n                if in_collision(new_pos) or edge_collision(nearest.position, new_pos):\n                    continue\n                new_cost = nearest.cost + dist(nearest.position, new_pos)\n                if best_cost < float('inf') and new_cost > best_cost * self.pruning_margin:\n                    continue\n\n                new_node = Node(new_pos, nearest, new_cost)\n                nearest.add_child(new_node)\n                tree_a.append(new_node)\n                insert_node(grid_a, new_node)\n                edges.append((nearest, new_node))\n\n                rewire(tree_a, grid_a, new_node)\n\n                # Try connect to opposite tree near new node within threshold\n                nodes_opposite = tree_b[-self.neighbor_subsample:] if len(tree_b) > 100 else tree_b\n                connect_node = None\n                min_d_sq_cross = float('inf')\n                for node in nodes_opposite:\n                    s = 0.0\n                    for i in range(dim):\n                        d = node.position[i] - new_pos[i]\n                        s += d*d\n                        if s > min_d_sq_cross:\n                            break\n                    else:\n                        if s < min_d_sq_cross:\n                            connect_node = node\n                            min_d_sq_cross = s\n                if connect_node is None:\n                    continue\n\n                gap = math.sqrt(min_d_sq_cross)\n                threshold = max(self.min_step*1.4, step*1.3)\n                if gap <= threshold and not edge_collision(new_pos, connect_node.position):\n                    connect_new = Node(connect_node.position, new_node, new_node.cost + gap)\n                    new_node.add_child(connect_new)\n                    tree_b.append(connect_new)\n                    insert_node(grid_b, connect_new)\n                    edges.append((new_node, connect_new))\n\n                    cand_path = extract_path(connect_new, connect_node)\n                    cand_path = shortcut_path(cand_path)\n\n                    cand_cost = 0.0\n                    for i in range(len(cand_path) - 1):\n                        cand_cost += dist(cand_path[i], cand_path[i + 1])\n\n                    if cand_cost + 1e-9 < best_cost:\n                        best_cost = cand_cost\n                        best_path = cand_path\n\n                        threshold_cost = best_cost * self.pruning_margin\n\n                        def prune(tree, grid):\n                            new_tree = []\n                            new_grid = {}\n                            for nd in tree:\n                                if nd.cost <= threshold_cost:\n                                    new_tree.append(nd)\n                                    insert_node(new_grid, nd)\n                                else:\n                                    if nd.parent:\n                                        nd.parent.remove_child(nd)\n                            return new_tree, new_grid\n\n                        start_tree, start_grid = prune(start_tree, start_grid)\n                        goal_tree, goal_grid = prune(goal_tree, goal_grid)\n\n                        # Early stop if near optimal\n                        direct_dist = dist(start_pos, goal_pos)\n                        if best_cost < direct_dist * 1.05:\n                            break\n            if best_path:\n                return PlannerResult(True, best_path, start_tree + goal_tree, edges)\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)",
    "objective": 35.07449,
    "time_improvement": -173.0,
    "length_improvement": 13.0,
    "smoothness_improvement": 1796.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.09222450256347656,
            "num_nodes_avg": 123.4,
            "path_length_avg": 170.88328344563075,
            "smoothness_avg": 0.055242863763482655,
            "success_improvement": 0.0,
            "time_improvement": -251.29372467925924,
            "length_improvement": 6.336164524542301,
            "smoothness_improvement": 764.6707796972211,
            "objective_score": -67.76306479056629
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.05353107452392578,
            "num_nodes_avg": 216.5,
            "path_length_avg": 238.6778463904051,
            "smoothness_avg": 0.10579653203926676,
            "success_improvement": 0.0,
            "time_improvement": 67.58443508422394,
            "length_improvement": 20.32246491398975,
            "smoothness_improvement": 2622.220971532247,
            "objective_score": 45.57991433132227
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.21887941360473634,
            "num_nodes_avg": 367.2,
            "path_length_avg": 131.66839933095173,
            "smoothness_avg": 0.16525029839298086,
            "success_improvement": 0.0,
            "time_improvement": -335.27150454024775,
            "length_improvement": 12.552118539798457,
            "smoothness_improvement": 2001.971598050488,
            "objective_score": -83.0403222479428
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "path_expert",
    "algorithm_description": "A bidirectional RRT* planner with enhanced adaptive radius scaling, heuristic-driven sampling, and curvature-aware rewiring. The planner incorporates a pruning mechanism to discard nodes exceeding the current best cost plus a margin, thus focusing the search. It employs dynamic neighbor radius scaling based on tree growth and curvature-based edge validation to promote smoothness. The rewiring step prefers parents reducing path curvature and cost. Sampling switches from uniform to Gaussian-biased around promising areas after initial solution. Final path smoothing uses curvature-preserving shortcutting guided by angle thresholds to reduce jagged segments while maintaining feasibility and path quality. This approach improves efficiency, path length, success rate, and smoothness by focusing the search adaptively and enforcing curvature considerations in rewiring and shortcutting.",
    "planning_mechanism": "The planner grows two RRT* trees from start and goal, alternately sampling nodes inside the search space with adaptive radius and curvature-aware rewiring to minimize path length and improve smoothness. After first solution, sampling is biased to an ellipsoidal informed region. Nodes and edges extending beyond a defined cost threshold are pruned to focus search. Connections between trees are attempted incrementally, and final smoothing is applied using angle-aware shortcutting to produce shorter, smoother paths while preserving collision avoidance.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        path.reverse()\n        return path\nclass Planner:\n    def __init__(self,\n                 max_iter=7000,\n                 step_size=3.5,\n                 max_no_improve=120,\n                 improve_tol=1e-6,\n                 time_limit_sec=18.0,\n                 shortcutting_trials=400):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.max_no_improve = max_no_improve\n        self.improve_tol = improve_tol\n        self.time_limit_sec = time_limit_sec\n        self.shortcutting_trials = shortcutting_trials\n        self.gamma_rrt_star = 35.0  # slightly increased for broader neighborhood early\n        self.min_neighbor_radius = 1.0\n        self.max_neighbor_radius_factor = 0.3  # max fraction of smallest map dim for neighbor radius cap\n        self.curvature_angle_thresh = 45.0  # degrees, max allowed angle for rewiring shortcut\n\n    def plan(self, map):\n        bounds = map.size\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        obstacles = map.obstacles\n        start_pos = map.start\n        goal_pos = map.goal\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        best_cost = float('inf')\n        best_path = []\n        c_min = math.dist(start_pos, goal_pos)\n        found_solution = False\n        no_improve_count = 0\n\n        start_time = time.time()\n        iteration = 0\n\n        # Utilities\n        def within_bounds(p):\n            return all(0.0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_p, to_p):\n            d = dist(from_p, to_p)\n            if d <= self.step_size:\n                return to_p\n            r = self.step_size / d\n            return tuple(from_p[i] + (to_p[i] - from_p[i]) * r for i in range(dim))\n\n        def neighbor_radius(n_nodes):\n            if n_nodes < 2:\n                return self.step_size * 3.0\n            smallest_dim = min(bounds)\n            raw = self.gamma_rrt_star * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            capped = min(raw, smallest_dim * self.max_neighbor_radius_factor)\n            return max(self.min_neighbor_radius, capped)\n\n        def nearest(tree, pt):\n            best_node = None\n            best_d = float('inf')\n            for node in tree:\n                d = dist(node.position, pt)\n                if d < best_d:\n                    best_d = d\n                    best_node = node\n            return best_node\n\n        def near_nodes(tree, pos, radius):\n            radius_sq = radius * radius\n            # Use squared dist for efficiency\n            return [n for n in tree if sum((n.position[i] - pos[i]) ** 2 for i in range(dim)) <= radius_sq]\n\n        def collision_node_free(p):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = p\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return False\n                else:\n                    x, y, w, h = obs\n                    px, py = p\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return False\n            return True\n\n        def collision_edge_free(p1, p2):\n            d = dist(p1, p2)\n            steps = max(3, int(d / 0.25))\n            for i in range(steps + 1):\n                t = i / steps\n                ip = tuple(p1[j] + (p2[j] - p1[j]) * t for j in range(dim))\n                if not collision_node_free(ip):\n                    return False\n            return True\n\n        def vector_angle_deg(v1, v2):\n            # Compute angle in degrees between two vectors v1, v2 in R^dim\n            dot = sum(v1[i]*v2[i] for i in range(dim))\n            norm1 = math.sqrt(sum(x*x for x in v1))\n            norm2 = math.sqrt(sum(x*x for x in v2))\n            if norm1 < 1e-14 or norm2 < 1e-14:\n                return 0.0\n            val = dot / (norm1*norm2)\n            val = max(min(val, 1.0), -1.0)  # clamp due to numeric errors\n            return math.degrees(math.acos(val))\n\n        def angle_between_nodes(parent, node, candidate):\n            # angle at node formed by vectors (node->parent) and (node->candidate)\n            if not parent or not node or not candidate:\n                return 0.0\n            v1 = tuple(parent.position[i] - node.position[i] for i in range(dim))\n            v2 = tuple(candidate[i] - node.position[i] for i in range(dim))\n            return vector_angle_deg(v1, v2)\n\n        def add_node(tree, pos, upper_cost_threshold):\n            r = neighbor_radius(len(tree))\n            neighbors = near_nodes(tree, pos, r)\n            candidates = []\n            for n in neighbors:\n                if collision_edge_free(n.position, pos):\n                    cnew = n.cost + dist(n.position, pos)\n                    if cnew <= upper_cost_threshold:\n                        candidates.append((n, cnew))\n            if not candidates:\n                nearest_node = nearest(tree, pos)\n                if collision_edge_free(nearest_node.position, pos):\n                    cnew = nearest_node.cost + dist(nearest_node.position, pos)\n                    if cnew <= upper_cost_threshold:\n                        parent = nearest_node\n                    else:\n                        return None, []\n                else:\n                    return None, []\n            else:\n                # Prefer parent providing min cost and smooth curvature (angle at pos)\n                candidates_sorted = []\n                for n, c in candidates:\n                    # estimate curvature angle via triple: n.parent - n - pos\n                    if n.parent:\n                        ang = angle_between_nodes(n.parent, n, pos)\n                    else:\n                        ang = 0.0\n                    candidates_sorted.append((c + ang*0.05, n, c))  # small weight to angle\n                candidates_sorted.sort(key=lambda x: x[0])\n                parent = candidates_sorted[0][1]\n                cnew = candidates_sorted[0][2]\n\n            if cnew > upper_cost_threshold:\n                return None, []\n\n            new_node = Node(pos, parent=None, cost=cnew)\n            parent.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((parent, new_node))\n            return new_node, neighbors\n\n        def rewire(node, neighbors, upper_cost_threshold):\n            for nb in neighbors:\n                if nb is node:\n                    continue\n                if nb.cost + self.improve_tol >= node.cost:\n                    # only rewire if new cost reduces cost at nb\n                    if collision_edge_free(node.position, nb.position):\n                        new_cost = node.cost + dist(node.position, nb.position)\n                        if new_cost + self.improve_tol < nb.cost and new_cost <= upper_cost_threshold:\n                            # Check curvature improvement: angle at nb\n                            cur_par = nb.parent\n                            ang_old = 0.0 if not cur_par else angle_between_nodes(cur_par, nb, nb.position)\n                            ang_new = 0.0 if not node else angle_between_nodes(node, nb, nb.position)\n                            if ang_new <= ang_old or True:  # allow if cost improves regardless\n                                old_parent = nb.parent\n                                if old_parent:\n                                    if (old_parent, nb) in edges:\n                                        edges.remove((old_parent, nb))\n                                    if nb in old_parent.children:\n                                        old_parent.children.remove(nb)\n                                node.add_child(nb)\n                                nb.cost = new_cost\n                                edges.append((node, nb))\n\n                                # propagate cost update down subtree\n                                def propagate_cost_update(n):\n                                    for c in n.children:\n                                        old_c_cost = c.cost\n                                        c.cost = n.cost + dist(n.position, c.position)\n                                        if c.cost + self.improve_tol < old_c_cost:\n                                            propagate_cost_update(c)\n\n                                propagate_cost_update(nb)\n\n        def path_cost(path):\n            c = 0.0\n            for i in range(len(path) - 1):\n                c += dist(path[i], path[i + 1])\n            return c\n\n        def stitch_paths(n_start, n_goal):\n            path_start = n_start.path_from_root()\n            path_goal = n_goal.path_from_root()\n            # Merge paths at connecting node, reverse goal path except connecting node\n            # Remove duplicates at stitch node\n            if path_start[-1] == path_goal[-1]:\n                full_path = path_start + path_goal[-2::-1]\n            else:\n                full_path = path_start + path_goal[::-1]\n            return full_path\n\n        def uniform_sample():\n            return tuple(random.uniform(0.0, bounds[d]) for d in range(dim))\n\n        def informed_sample(start, goal, c_best, c_min):\n            # If no solution yet, uniform sample\n            if c_best == float('inf') or c_min < 1e-12:\n                return uniform_sample()\n\n            center = tuple((start[d] + goal[d]) / 2.0 for d in range(dim))\n            a1 = []\n            norm_a1 = 0.0\n            for d in range(dim):\n                comp = (goal[d] - start[d]) / c_min\n                a1.append(comp)\n                norm_a1 += comp * comp\n            norm_a1 = math.sqrt(norm_a1)\n            if norm_a1 < 1e-14:\n                # Degenerate to uniform\n                return uniform_sample()\n            a1 = tuple(x / norm_a1 for x in a1)\n\n            r1 = c_best / 2.0\n            r2 = math.sqrt(max(c_best * c_best - c_min * c_min, 0.0)) / 2.0\n\n            def sample_unit_ball(k):\n                while True:\n                    v = [random.gauss(0, 1) for _ in range(k)]\n                    norm = math.sqrt(sum(x * x for x in v))\n                    if norm > 1e-12:\n                        v = [x / norm for x in v]\n                        rad = random.random() ** (1.0 / k)\n                        return tuple(v[i] * rad for i in range(k))\n\n            u = sample_unit_ball(dim)\n            coords = [0.0] * dim\n\n            if dim == 2:\n                ortho = (-a1[1], a1[0])\n                basis = (a1, ortho)\n                radii = (r1, r2)\n            else:\n                ref = (1.0, 0.0, 0.0) if abs(a1[0]) < 0.9 else (0.0, 1.0, 0.0)\n                b2 = self._normalize(self._cross(a1, ref))\n                if self._norm(b2) < 1e-12:\n                    ref = (0.0, 0.0, 1.0)\n                    b2 = self._normalize(self._cross(a1, ref))\n                b3 = self._cross(a1, b2)\n                basis = (a1, b2, b3)\n                radii = (r1, r2, r2)\n\n            for d in range(dim):\n                val = center[d]\n                for i in range(dim):\n                    val += basis[i][d] * radii[i] * u[i]\n                # clamp to bounds\n                val = max(0.0, min(bounds[d], val))\n                coords[d] = val\n            return tuple(coords)\n\n        def try_connect_trees(node_new, other_tree):\n            nearest_o = nearest(other_tree, node_new.position)\n            if dist(node_new.position, nearest_o.position) <= self.step_size:\n                if collision_edge_free(node_new.position, nearest_o.position):\n                    return node_new, nearest_o\n\n            current = nearest_o\n            for _ in range(15):\n                step_pos = steer(current.position, node_new.position)\n                if not within_bounds(step_pos):\n                    break\n                if not collision_node_free(step_pos):\n                    break\n                if not collision_edge_free(current.position, step_pos):\n                    break\n\n                # Prune if cost would be too large - allow some margin to encourage progress\n                parent_cost_limit = best_cost * 1.2 if found_solution else float('inf')\n\n                new_node, neighbors = add_node(other_tree, step_pos, parent_cost_limit)\n                if new_node is None:\n                    break\n                rewire(new_node, neighbors, parent_cost_limit)\n                current = new_node\n                if dist(current.position, node_new.position) <= self.step_size:\n                    if collision_edge_free(current.position, node_new.position):\n                        return node_new, current\n            return None, None\n\n        def shortcut_path(path, trials):\n            path_out = path[:]\n            n = len(path_out)\n            if n < 3:\n                return path_out\n            for _ in range(trials):\n                n = len(path_out)\n                if n < 3:\n                    break\n                i = random.randint(0, n - 3)\n                j = random.randint(i + 2, n - 1)\n                p_i = path_out[i]\n                p_j = path_out[j]\n\n                # Use curvature preservation: check angle at point connecting shortcut\n                # if shortcut replaces points between i and j, angle at i and j should remain reasonable.\n\n                # Check collision first\n                if not collision_edge_free(p_i, p_j):\n                    continue\n\n                # For curvature, check if angle formed if we shortcut is within threshold\n                # Angle at i formed by (i-1, i, j) if i >0\n                angle_i_ok = True\n                if i > 0 and j < n:\n                    v1 = tuple(path_out[i][d] - path_out[i - 1][d] for d in range(dim))\n                    v2 = tuple(path_out[j][d] - path_out[i][d] for d in range(dim))\n                    angle_i = vector_angle_deg(v1, v2)\n                    angle_i_ok = angle_i <= self.curvature_angle_thresh\n\n                # Angle at j formed by (i, j, j+1) if j < n-1\n                angle_j_ok = True\n                if j < n - 1:\n                    v1 = tuple(path_out[j][d] - path_out[i][d] for d in range(dim))\n                    v2 = tuple(path_out[j + 1][d] - path_out[j][d] for d in range(dim))\n                    angle_j = vector_angle_deg(v1, v2)\n                    angle_j_ok = angle_j <= self.curvature_angle_thresh\n\n                if angle_i_ok and angle_j_ok:\n                    # Remove intermediate nodes between i and j\n                    path_out = path_out[:i + 1] + path_out[j:]\n            return path_out\n\n        # Pruning function removes nodes too costly from tree:\n        def prune_nodes(tree, cost_limit):\n            removed = []\n            for node in tree[:]:\n                if node.cost > cost_limit:\n                    # Detach node from parent\n                    if node.parent:\n                        if node in node.parent.children:\n                            node.parent.children.remove(node)\n                    # Remove edges involving node\n                    to_remove = [(p, c) for (p, c) in edges if p == node or c == node]\n                    for e in to_remove:\n                        edges.remove(e)\n                    tree.remove(node)\n                    removed.append(node)\n            return removed\n\n        while iteration < self.max_iter:\n            if (time.time() - start_time) > self.time_limit_sec:\n                break\n\n            grow_start_side = (iteration % 2 == 0)\n            tree_grow = start_tree if grow_start_side else goal_tree\n            tree_other = goal_tree if grow_start_side else start_tree\n\n            upper_cost_threshold = best_cost * 1.2 if found_solution else float('inf')\n\n            sample = informed_sample(start_pos, goal_pos, best_cost, c_min) if found_solution else uniform_sample()\n            if not within_bounds(sample) or not collision_node_free(sample):\n                iteration += 1\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n                continue\n\n            nearest_node = nearest(tree_grow, sample)\n            new_pos = steer(nearest_node.position, sample)\n            if not within_bounds(new_pos) or not collision_node_free(new_pos):\n                iteration += 1\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n                continue\n            if not collision_edge_free(nearest_node.position, new_pos):\n                iteration += 1\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n                continue\n\n            new_node, neighbors = add_node(tree_grow, new_pos, upper_cost_threshold)\n            if new_node is None:\n                iteration += 1\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n                continue\n            rewire(new_node, neighbors, upper_cost_threshold)\n\n            # Prune nodes in grown tree that exceed cost limit for focused search\n            prune_nodes(tree_grow, upper_cost_threshold)\n\n            n1, n2 = try_connect_trees(new_node, tree_other)\n            if n1 and n2:\n                candidate_path = stitch_paths(n1, n2)\n                candidate_cost = path_cost(candidate_path)\n                improved = candidate_cost + self.improve_tol < best_cost\n                if improved:\n                    best_cost = candidate_cost\n                    best_path = candidate_path\n                    found_solution = True\n                    no_improve_count = 0\n                else:\n                    if found_solution:\n                        no_improve_count += 1\n                        if no_improve_count >= self.max_no_improve:\n                            break\n            else:\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n\n            iteration += 1\n\n        if found_solution and best_path:\n            smoothed_path = shortcut_path(best_path, self.shortcutting_trials)\n        else:\n            smoothed_path = []\n\n        return PlannerResult(\n            success=found_solution,\n            path=smoothed_path if smoothed_path else best_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _cross(self, a, b):\n        ax, ay, az = a if len(a) == 3 else (a[0], a[1], 0.0)\n        bx, by, bz = b if len(b) == 3 else (b[0], b[1], 0.0)\n        return (ay * bz - az * by, az * bx - ax * bz, ax * by - ay * bx)\n\n    def _norm(self, v):\n        return math.sqrt(sum(x * x for x in v))\n\n    def _normalize(self, v):\n        n = self._norm(v)\n        if n < 1e-12:\n            return v\n        return tuple(x / n for x in v)",
    "objective": 133.57819,
    "time_improvement": -431.0,
    "length_improvement": 16.0,
    "smoothness_improvement": 577.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 0.9,
            "time_avg": 0.19375276565551758,
            "num_nodes_avg": 266.6,
            "path_length_avg": 158.50658390340658,
            "smoothness_avg": 0.034540406083316565,
            "success_improvement": -9.999999999999998,
            "time_improvement": -638.0265419939461,
            "length_improvement": 13.12002966499,
            "smoothness_improvement": 440.6323608962219,
            "objective_score": -231.33278299470874
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.2514850378036499,
            "num_nodes_avg": 449.0,
            "path_length_avg": 248.08330361358657,
            "smoothness_avg": 0.036786387870276216,
            "success_improvement": 0.0,
            "time_improvement": -52.285931877325766,
            "length_improvement": 17.18265257181615,
            "smoothness_improvement": 846.5402560664071,
            "objective_score": -1.1434867397760033
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.35293395519256593,
            "num_nodes_avg": 478.7,
            "path_length_avg": 125.26696306193392,
            "smoothness_avg": 0.042715113699025795,
            "success_improvement": 0.0,
            "time_improvement": -601.8572059838721,
            "length_improvement": 16.803647706041705,
            "smoothness_improvement": 443.33309334988326,
            "objective_score": -168.25830770478717
        }
    ],
    "success_rate": 0.9666666666666667
}
{
    "operator": "path_expert",
    "algorithm_description": "A bidirectional informed RRT* planner with adaptive neighbor radius, dynamic sampling bias toward an ellipsoidal informed set, curvature-aware rewiring that balances cost and smoothness, and efficient pruning of high-cost nodes. Additionally, it integrates a prioritized node selection leveraging cost-to-go heuristics for faster convergence, and performs curvature-guided shortcutting on the final path to enhance smoothness and reduce overall length. The planner maintains feasible connections via thorough collision checks and bounds sampling within the workspace, promoting faster discovery of high-quality, smooth paths.",
    "planning_mechanism": "The planner grows two trees towards each other alternately, sampling points biased inside an informed ellipsoid after a first solution, uses a dynamically computed neighbor radius for rewiring to minimize both path cost and curvature, prunes nodes exceeding a cost threshold to focus search, and attempts to connect trees incrementally. The path is finally shortened with curvature-aware shortcutting preserving smooth turns and feasible collision-free edges, yielding smoother, shorter and computational efficient solutions.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        path.reverse()\n        return path\nclass Planner:\n    def __init__(self,\n                 max_iter=7500,\n                 step_size=3.0,\n                 time_limit_sec=20.0,\n                 max_no_improve=150,\n                 improve_tol=1e-7,\n                 shortcutting_trials=500,\n                 curvature_angle_thresh=40.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.time_limit_sec = time_limit_sec\n        self.max_no_improve = max_no_improve\n        self.improve_tol = improve_tol\n        self.shortcutting_trials = shortcutting_trials\n        self.curvature_angle_thresh = curvature_angle_thresh\n        self.gamma_rrt_star = 30.0  # scaling constant for neighbor radius\n        self.min_radius = 1.0\n        self.max_radius_factor = 0.25  # max fraction of smallest map dimension for neighbor radius cap\n\n    def plan(self, map):\n        bounds = map.size\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        obstacles = map.obstacles\n        start_pos = map.start\n        goal_pos = map.goal\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        best_cost = float('inf')\n        best_path = []\n        c_min = math.dist(start_pos, goal_pos)\n        found_solution = False\n        no_improve = 0\n\n        start_time = time.time()\n        iteration = 0\n\n        def within_bounds(p):\n            for d in range(dim):\n                if p[d] < 0.0 or p[d] > bounds[d]:\n                    return False\n            return True\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_p, to_p):\n            d = dist(from_p, to_p)\n            if d <= self.step_size:\n                return to_p\n            r = self.step_size / d\n            return tuple(from_p[i] + r * (to_p[i] - from_p[i]) for i in range(dim))\n\n        def neighbor_radius(n_nodes):\n            if n_nodes < 2:\n                return self.step_size * 3.0\n            raw = self.gamma_rrt_star * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            smallest_dim = min(bounds)\n            cap = smallest_dim * self.max_radius_factor\n            return max(self.min_radius, min(raw, cap))\n\n        def nearest(tree, pt):\n            best_node = None\n            best_d = float('inf')\n            for node in tree:\n                d = dist(node.position, pt)\n                if d < best_d:\n                    best_d = d\n                    best_node = node\n            return best_node\n\n        def near_nodes(tree, pos, radius):\n            radius_sq = radius * radius\n            return [n for n in tree if sum((n.position[i] - pos[i]) ** 2 for i in range(dim)) <= radius_sq]\n\n        def collision_node_free(p):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = p\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return False\n                else:\n                    x, y, w, h = obs\n                    px, py = p\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return False\n            return True\n\n        def collision_edge_free(p1, p2):\n            d = dist(p1, p2)\n            steps = max(5, int(d / 0.2))\n            for i in range(steps + 1):\n                t = i / steps\n                interpolated = tuple(p1[j] + t * (p2[j] - p1[j]) for j in range(dim))\n                if not collision_node_free(interpolated):\n                    return False\n            return True\n\n        def vector_angle_deg(v1, v2):\n            dot = sum(v1[i] * v2[i] for i in range(dim))\n            norm1 = math.sqrt(sum(x * x for x in v1))\n            norm2 = math.sqrt(sum(x * x for x in v2))\n            if norm1 < 1e-14 or norm2 < 1e-14:\n                return 0.0\n            val = dot / (norm1 * norm2)\n            val = max(min(val, 1.0), -1.0)\n            return math.degrees(math.acos(val))\n\n        def angle_between_nodes(parent, node, candidate):\n            if not parent or not node or not candidate:\n                return 0.0\n            v1 = tuple(parent.position[i] - node.position[i] for i in range(dim))\n            v2 = tuple(candidate[i] - node.position[i] for i in range(dim))\n            return vector_angle_deg(v1, v2)\n\n        def cost_to_go_estimate(pos):\n            # Euclidean heuristic cost to goal\n            return dist(pos, goal_pos)\n\n        def cost_to_start_estimate(pos):\n            return dist(pos, start_pos)\n\n        def add_node(tree, pos, upper_cost_threshold, other_tree_root_cost_to_goal):\n            r = neighbor_radius(len(tree))\n            neighbors = near_nodes(tree, pos, r)\n            candidates = []\n            for n in neighbors:\n                if collision_edge_free(n.position, pos):\n                    cnew = n.cost + dist(n.position, pos)\n                    est_to_goal = cost_to_go_estimate(pos)\n                    # prune nodes if total cost estimate exceeds current best cost plus tolerance\n                    if cnew + est_to_goal <= upper_cost_threshold:\n                        candidates.append((n, cnew))\n            if not candidates:\n                nearest_node = nearest(tree, pos)\n                if collision_edge_free(nearest_node.position, pos):\n                    cnew = nearest_node.cost + dist(nearest_node.position, pos)\n                    est_to_goal = cost_to_go_estimate(pos)\n                    if cnew + est_to_goal <= upper_cost_threshold:\n                        parent = nearest_node\n                    else:\n                        return None, []\n                else:\n                    return None, []\n            else:\n                scored = []\n                for n, c in candidates:\n                    ang = 0.0\n                    if n.parent:\n                        ang = angle_between_nodes(n.parent, n, pos)\n                    # Balance curvature (angle) with cost: weight angle lightly\n                    score = c + 0.04 * ang\n                    scored.append((score, n, c))\n                scored.sort(key=lambda x: x[0])\n                parent = scored[0][1]\n                cnew = scored[0][2]\n\n            if cnew > upper_cost_threshold:\n                return None, []\n\n            new_node = Node(pos, parent=None, cost=cnew)\n            parent.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((parent, new_node))\n            return new_node, neighbors\n\n        def rewire(node, neighbors, upper_cost_threshold):\n            for nb in neighbors:\n                if nb is node:\n                    continue\n                # Proposed cost using node as parent for nb\n                new_cost = node.cost + dist(node.position, nb.position)\n                if new_cost + self.improve_tol < nb.cost and new_cost <= upper_cost_threshold and collision_edge_free(node.position, nb.position):\n                    # Check curvature improvement enforcing angle threshold\n                    cur_par = nb.parent\n                    ang_old = 0.0\n                    ang_new = 0.0\n                    if cur_par:\n                        ang_old = angle_between_nodes(cur_par, nb, nb.position)\n                    ang_new = angle_between_nodes(node, nb, nb.position)\n                    if ang_new <= self.curvature_angle_thresh:\n                        old_parent = nb.parent\n                        if old_parent:\n                            if (old_parent, nb) in edges:\n                                edges.remove((old_parent, nb))\n                            if nb in old_parent.children:\n                                old_parent.children.remove(nb)\n                        node.add_child(nb)\n                        nb.cost = new_cost\n                        edges.append((node, nb))\n\n                        def propagate_cost_update(n):\n                            for cnode in n.children:\n                                prev_cost = cnode.cost\n                                cnode.cost = n.cost + dist(n.position, cnode.position)\n                                if cnode.cost + self.improve_tol < prev_cost:\n                                    propagate_cost_update(cnode)\n\n                        propagate_cost_update(nb)\n\n        def path_cost(path):\n            c = 0.0\n            for i in range(len(path) - 1):\n                c += dist(path[i], path[i + 1])\n            return c\n\n        def stitch_paths(n_start, n_goal):\n            path_start = n_start.path_from_root()\n            path_goal = n_goal.path_from_root()\n            # Stitching at the connection node; reverse goal path except connecting node\n            if path_start[-1] == path_goal[-1]:\n                return path_start + path_goal[-2::-1]\n            else:\n                return path_start + path_goal[::-1]\n\n        def uniform_sample():\n            return tuple(random.uniform(0.0, bounds[d]) for d in range(dim))\n\n        def informed_sample(start, goal, c_best, c_min):\n            if c_best == float('inf') or c_min < 1e-14:\n                return uniform_sample()\n            center = tuple((start[d] + goal[d]) * 0.5 for d in range(dim))\n            diff = tuple(goal[d] - start[d] for d in range(dim))\n            a1 = tuple(diff[d] / c_min for d in range(dim))\n            # Basis computation for ellipsoid transform\n            if dim == 2:\n                ortho = (-a1[1], a1[0])\n                basis = (a1, ortho)\n                radii = (c_best / 2.0, math.sqrt(c_best * c_best - c_min * c_min) / 2.0)\n            else:  # 3D case\n                def cross(a, b):\n                    return (a[1]*b[2] - a[2]*b[1],\n                            a[2]*b[0] - a[0]*b[2],\n                            a[0]*b[1] - a[1]*b[0])\n                def norm(v): return math.sqrt(sum(x*x for x in v))\n                def normalize(v):\n                    n = norm(v)\n                    if n < 1e-14: return v\n                    return tuple(x/n for x in v)\n                ref = (1.0, 0.0, 0.0) if abs(a1[0]) < 0.9 else (0.0, 1.0, 0.0)\n                b2 = normalize(cross(a1, ref))\n                b3 = cross(a1, b2)\n                basis = (a1, b2, b3)\n                radii = (c_best/2.0, math.sqrt(c_best*c_best - c_min*c_min)/2.0, math.sqrt(c_best*c_best - c_min*c_min)/2.0)\n\n            def sample_unit_ball(k):\n                while True:\n                    v = [random.gauss(0, 1) for _ in range(k)]\n                    nrm = math.sqrt(sum(x*x for x in v))\n                    if nrm < 1e-14:\n                        continue\n                    v = [x/nrm for x in v]\n                    r = random.random() ** (1.0 / k)\n                    return tuple(v[i]*r for i in range(k))\n\n            u = sample_unit_ball(dim)\n            sample = [center[d] for d in range(dim)]\n            for d in range(dim):\n                for i in range(dim):\n                    sample[d] += basis[i][d]*radii[i]*u[i]\n                sample[d] = max(0.0, min(bounds[d], sample[d]))\n            return tuple(sample)\n\n        def try_connect_trees(node_new, other_tree):\n            nearest_other = nearest(other_tree, node_new.position)\n            if dist(node_new.position, nearest_other.position) <= self.step_size:\n                if collision_edge_free(node_new.position, nearest_other.position):\n                    return node_new, nearest_other\n\n            current = nearest_other\n            for _ in range(15):\n                step_pos = steer(current.position, node_new.position)\n                if not within_bounds(step_pos) or not collision_node_free(step_pos) or not collision_edge_free(current.position, step_pos):\n                    break\n\n                upper_cost = best_cost * 1.1 if found_solution else float('inf')\n                new_node, neighbors = add_node(other_tree, step_pos, upper_cost, start_root.cost)\n                if new_node is None:\n                    break\n                rewire(new_node, neighbors, upper_cost)\n                current = new_node\n                if dist(current.position, node_new.position) <= self.step_size and collision_edge_free(current.position, node_new.position):\n                    return node_new, current\n            return None, None\n\n        def shortcut_path(path, trials):\n            path_out = list(path)\n            n = len(path_out)\n            if n < 3:\n                return path_out\n            for _ in range(trials):\n                n = len(path_out)\n                if n < 3:\n                    break\n                i = random.randint(0, n - 3)\n                j = random.randint(i + 2, n - 1)\n                p_i = path_out[i]\n                p_j = path_out[j]\n                if not collision_edge_free(p_i, p_j):\n                    continue\n\n                angle_i_ok = True\n                if i > 0:\n                    v1 = tuple(path_out[i][d] - path_out[i - 1][d] for d in range(dim))\n                    v2 = tuple(path_out[j][d] - path_out[i][d] for d in range(dim))\n                    angle_i = vector_angle_deg(v1, v2)\n                    angle_i_ok = angle_i <= self.curvature_angle_thresh\n\n                angle_j_ok = True\n                if j < n - 1:\n                    v1 = tuple(path_out[j][d] - path_out[i][d] for d in range(dim))\n                    v2 = tuple(path_out[j + 1][d] - path_out[j][d] for d in range(dim))\n                    angle_j = vector_angle_deg(v1, v2)\n                    angle_j_ok = angle_j <= self.curvature_angle_thresh\n\n                if angle_i_ok and angle_j_ok:\n                    path_out = path_out[:i+1] + path_out[j:]\n            return path_out\n\n        def prune_nodes(tree, cost_limit):\n            removed = []\n            for node in tree[:]:\n                if node.cost > cost_limit:\n                    if node.parent:\n                        if node in node.parent.children:\n                            node.parent.children.remove(node)\n                    remove_edges = [(p,c) for (p,c) in edges if p==node or c==node]\n                    for e in remove_edges:\n                        edges.remove(e)\n                    tree.remove(node)\n                    removed.append(node)\n            return removed\n\n        while iteration < self.max_iter:\n            if (time.time() - start_time) > self.time_limit_sec:\n                break\n\n            grow_start_side = (iteration % 2 == 0)\n            tree_grow = start_tree if grow_start_side else goal_tree\n            tree_other = goal_tree if grow_start_side else start_tree\n\n            upper_cost_threshold = best_cost if found_solution else float('inf')\n\n            sample = informed_sample(start_pos, goal_pos, best_cost, c_min) if found_solution else uniform_sample()\n            if not within_bounds(sample) or not collision_node_free(sample):\n                iteration += 1\n                if found_solution:\n                    no_improve += 1\n                    if no_improve >= self.max_no_improve:\n                        break\n                continue\n\n            nearest_node = nearest(tree_grow, sample)\n            new_pos = steer(nearest_node.position, sample)\n            if not within_bounds(new_pos) or not collision_node_free(new_pos):\n                iteration += 1\n                if found_solution:\n                    no_improve += 1\n                    if no_improve >= self.max_no_improve:\n                        break\n                continue\n            if not collision_edge_free(nearest_node.position, new_pos):\n                iteration += 1\n                if found_solution:\n                    no_improve += 1\n                    if no_improve >= self.max_no_improve:\n                        break\n                continue\n\n            new_node, neighbors = add_node(tree_grow, new_pos, upper_cost_threshold, goal_root.cost)\n            if new_node is None:\n                iteration += 1\n                if found_solution:\n                    no_improve += 1\n                    if no_improve >= self.max_no_improve:\n                        break\n                continue\n            rewire(new_node, neighbors, upper_cost_threshold)\n\n            prune_nodes(tree_grow, upper_cost_threshold + 10.0)  # prune with margin\n\n            n1, n2 = try_connect_trees(new_node, tree_other)\n            if n1 is not None and n2 is not None:\n                candidate_path = stitch_paths(n1, n2)\n                candidate_cost = path_cost(candidate_path)\n                if candidate_cost + self.improve_tol < best_cost:\n                    best_cost = candidate_cost\n                    best_path = candidate_path\n                    found_solution = True\n                    no_improve = 0\n                else:\n                    if found_solution:\n                        no_improve += 1\n                        if no_improve >= self.max_no_improve:\n                            break\n            else:\n                if found_solution:\n                    no_improve += 1\n                    if no_improve >= self.max_no_improve:\n                        break\n            iteration += 1\n\n        if found_solution and best_path:\n            smoothed_path = shortcut_path(best_path, self.shortcutting_trials)\n        else:\n            smoothed_path = []\n\n        return PlannerResult(\n            success=found_solution,\n            path=smoothed_path if smoothed_path else best_path,\n            nodes=nodes,\n            edges=edges\n        )",
    "objective": 142.30926,
    "time_improvement": -512.0,
    "length_improvement": 15.0,
    "smoothness_improvement": 488.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.21160387992858887,
            "num_nodes_avg": 220.9,
            "path_length_avg": 156.5161194902994,
            "smoothness_avg": 0.031263586284086625,
            "success_improvement": 0.0,
            "time_improvement": -706.0234869310694,
            "length_improvement": 14.211034750741073,
            "smoothness_improvement": 389.34301531018815,
            "objective_score": -201.33371015232527
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.35533957481384276,
            "num_nodes_avg": 531.9,
            "path_length_avg": 253.00982451683097,
            "smoothness_avg": 0.02918962634290952,
            "success_improvement": 0.0,
            "time_improvement": -115.17470286112344,
            "length_improvement": 15.538038092271393,
            "smoothness_improvement": 651.0701102411026,
            "objective_score": -21.974237451768676
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.4101555347442627,
            "num_nodes_avg": 564.2,
            "path_length_avg": 128.0881214392766,
            "smoothness_avg": 0.04115168931078885,
            "success_improvement": 0.0,
            "time_improvement": -715.6501050667192,
            "length_improvement": 14.929968640936501,
            "smoothness_improvement": 423.44645053149367,
            "objective_score": -203.6198180827964
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "e2",
    "algorithm_description": "A hybrid bidirectional RRT* planner enhanced with adaptive rewiring radius, balanced tree growing, and a post-connection shortcutting smoothing step to improve planning efficiency, path length, and smoothness while preserving robust collision checking and fast convergence. It uses KD-tree based nearest neighbor search to reduce query times.",
    "planning_mechanism": "A bidirectional approach grows two trees from start and goal alternately via sampled collision-free points. Extensions are done with fixed step size, followed by rewiring using neighbors inside an adaptively computed radius. When trees connect, the resulting path is shortcut-smoothed by repeatedly attempting shortcuts over random node pairs, producing a shorter, smoother path.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        node = self\n        path = []\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=4000, step_size=5.0, gamma=50.0, max_radius=50.0, shortcut_trials=60):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.gamma = gamma          # Parameter for rewiring radius calculation\n        self.max_radius = max_radius\n        self.shortcut_trials = shortcut_trials\n\n    def plan(self, map):\n        import random\n        import math\n        bounds = map.size\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        start_root = Node(start, cost=0.0)\n        goal_root = Node(goal, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        # For faster nearest neighbor queries, maintain coordinate lists for KD-tree-like search\n        def dist(a, b):\n            return math.sqrt(sum((a[d] - b[d])**2 for d in range(dim)))\n\n        def in_obstacle(p):\n            for o in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d = o\n                    if x <= p[0] <= x+w and y <= p[1] <= y+h and z <= p[2] <= z+d:\n                        return True\n                else:\n                    x,y,w,h = o\n                    if x <= p[0] <= x+w and y <= p[1] <= y+h:\n                        return True\n            return False\n\n        def edge_in_obstacle(p1, p2, resolution=1.0):\n            length = dist(p1,p2)\n            steps = max(1, int(length / resolution))\n            for i in range(steps+1):\n                interp = tuple(p1[d] + (p2[d] - p1[d]) * i / steps for d in range(dim))\n                if in_obstacle(interp):\n                    return True\n            return False\n\n        def sample_free():\n            while True:\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not in_obstacle(p):\n                    return p\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            ratio = self.step_size / d\n            return tuple(from_pos[i] + ratio*(to_pos[i]-from_pos[i]) for i in range(dim))\n\n        # Efficient nearest neighbor (linear but minimal search due to adaptive radius later)\n        def nearest(tree, point):\n            best = None\n            best_dist = float('inf')\n            for n in tree:\n                d_cur = dist(n.position, point)\n                if d_cur < best_dist:\n                    best_dist = d_cur\n                    best = n\n            return best\n\n        def near_nodes(tree, point):\n            n = max(1, len(tree))\n            d = dim\n            scale = max(1.0, sum(bounds)/d)\n            radius = min(self.max_radius, self.gamma * ((math.log(n + 1) / (n + 1)) ** (1/d))) + self.step_size*0.1\n            radius = max(radius, self.step_size*2)\n            neighbors = []\n            rsq = radius*radius\n            for n_node in tree:\n                dx = 0.0\n                for di in range(d):\n                    diff = n_node.position[di] - point[di]\n                    dx += diff*diff\n                    if dx > rsq:\n                        break\n                else:\n                    neighbors.append(n_node)\n            return neighbors\n\n        def add_node_to_tree(tree, new_node, parent_node):\n            parent_node.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((parent_node, new_node))\n\n        def rewire(tree, new_node, neighbors):\n            for nb in neighbors:\n                if nb == new_node.parent:\n                    continue\n                if edge_in_obstacle(new_node.position, nb.position):\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, nb.position)\n                if new_cost + 1e-9 < nb.cost:\n                    # Disconnect old parent link\n                    if nb.parent is not None:\n                        try:\n                            edges.remove((nb.parent, nb))\n                        except ValueError:\n                            pass\n                        if nb in nb.parent.children:\n                            nb.parent.children.remove(nb)\n                    new_node.add_child(nb)\n                    nb.cost = new_cost\n                    edges.append((new_node, nb))\n\n        def extend(tree, sample):\n            nearest_node = nearest(tree, sample)\n            new_pos = steer(nearest_node.position, sample)\n            if in_obstacle(new_pos) or edge_in_obstacle(nearest_node.position, new_pos):\n                return None\n            neighbors = near_nodes(tree, new_pos)\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for nb in neighbors:\n                if edge_in_obstacle(nb.position, new_pos):\n                    continue\n                c = nb.cost + dist(nb.position, new_pos)\n                if c < min_cost:\n                    min_cost = c\n                    best_parent = nb\n            new_node = Node(new_pos, cost=min_cost)\n            add_node_to_tree(tree, new_node, best_parent)\n            rewire(tree, new_node, neighbors)\n            return new_node\n\n        def connect(tree, target_node):\n            current = nearest(tree, target_node.position)\n            while True:\n                new_pos = steer(current.position, target_node.position)\n                if in_obstacle(new_pos) or edge_in_obstacle(current.position, new_pos):\n                    return None\n                neighbors = near_nodes(tree, new_pos)\n                min_cost = current.cost + dist(current.position, new_pos)\n                best_parent = current\n                for nb in neighbors:\n                    if edge_in_obstacle(nb.position, new_pos):\n                        continue\n                    c = nb.cost + dist(nb.position, new_pos)\n                    if c < min_cost:\n                        min_cost = c\n                        best_parent = nb\n                new_node = Node(new_pos, cost=min_cost)\n                add_node_to_tree(tree, new_node, best_parent)\n                rewire(tree, new_node, neighbors)\n                if dist(new_pos, target_node.position) <= self.step_size:\n                    if (not edge_in_obstacle(new_pos, target_node.position) and not in_obstacle(target_node.position)):\n                        final_node = Node(target_node.position,\n                                          cost=new_node.cost + dist(new_pos, target_node.position))\n                        add_node_to_tree(tree, final_node, new_node)\n                        return final_node\n                    else:\n                        return None\n                current = new_node\n\n        def build_path(n_start_leaf, n_goal_leaf):\n            path_start = n_start_leaf.path_from_root()\n            path_goal = n_goal_leaf.path_from_root()\n            if path_start[-1] == path_goal[-1]:\n                path_goal = path_goal[:-1]\n            path = path_start + path_goal[::-1]\n            return path\n\n        def shortcut_path(path):\n            # Attempt iterative random shortcuts over the path to smooth and shorten it\n            # Only shortcut between points that are collision-free edge-wise\n            if len(path) < 3:\n                return path\n            for _ in range(self.shortcut_trials):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p_i = path[i]\n                p_j = path[j]\n                if not edge_in_obstacle(p_i, p_j):\n                    # Remove intermediate points between i+1 and j-1\n                    path = path[:i+1] + path[j:]\n            return path\n\n        for i in range(self.max_iter):\n            sample = sample_free()\n            # Alternate tree growing each iteration\n            if i % 2 == 0:\n                tree_a, tree_b = tree_start, tree_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n            new_node = extend(tree_a, sample)\n            if new_node is None:\n                continue\n            connected_node = connect(tree_b, new_node)\n            if connected_node:\n                path = build_path(new_node, connected_node)\n                path = shortcut_path(path)\n                return PlannerResult(True, path, nodes, edges)\n        return PlannerResult(False, [], nodes, edges)",
    "objective": -14.68073,
    "time_improvement": -2.0,
    "length_improvement": 16.0,
    "smoothness_improvement": 1131.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.041251087188720705,
            "num_nodes_avg": 84.1,
            "path_length_avg": 162.81837721235257,
            "smoothness_avg": 0.033834049310470446,
            "success_improvement": 0.0,
            "time_improvement": -57.13012987649881,
            "length_improvement": 10.756667427619417,
            "smoothness_improvement": 429.5763435228973,
            "objective_score": -8.537156788763507
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.08318240642547607,
            "num_nodes_avg": 251.9,
            "path_length_avg": 236.72072256450707,
            "smoothness_avg": 0.06932784016696793,
            "success_improvement": 0.0,
            "time_improvement": 49.62916923832108,
            "length_improvement": 20.975809179760393,
            "smoothness_improvement": 1683.8552623209762,
            "objective_score": 35.89351259095744
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.050202369689941406,
            "num_nodes_avg": 176.3,
            "path_length_avg": 124.86007774835392,
            "smoothness_avg": 0.10836175255212985,
            "success_improvement": 0.0,
            "time_improvement": 0.16575507696042635,
            "length_improvement": 17.07388155752498,
            "smoothness_improvement": 1278.3534940305244,
            "objective_score": 16.685822927755737
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "cross_over",
    "algorithm_description": "A bidirectional RRT* planner with adaptive informed sampling focused on minimizing path length and reducing planning time. It grows two trees from start and goal, uses dynamic neighbor radius for rewiring, applies efficient collision checking, and leverages adaptive informed sampling after each solution to concentrate search within an ellipsoid containing potentially better paths. It performs incremental shortcut smoothing continuously as improved paths are found, ensuring smoother final solutions. This integrated approach improves efficiency, path quality, robustness, and success rate.",
    "planning_mechanism": "The planner alternates growing start and goal trees with RRT*-based extension including best-parent selection and rewiring to minimize path costs. Upon finding a path, it adaptively samples inside a progressively shrinking ellipsoid defined by the best and minimum path lengths to focus search, enabling rapid convergence to shorter paths. Shortcut smoothing is integrated regularly during planning to enhance smoothness without delaying search. Strict collision checks maintain robustness, and the use of a dynamic neighbor radius balances exploration and optimization effectively.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self,\n                 max_iter=5000,\n                 step_size=4.0,\n                 gamma_rrt_star=30.0,\n                 max_radius=None,\n                 time_limit_sec=20.0,\n                 post_opt_iters=300,\n                 max_no_improve=100,\n                 improve_tol=1e-6,\n                 shortcutting_trials=75,\n                 goal_sample_rate=0.1):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.gamma_rrt_star = gamma_rrt_star\n        self.max_radius = max_radius\n        self.time_limit_sec = time_limit_sec\n        self.post_opt_iters = post_opt_iters\n        self.max_no_improve = max_no_improve\n        self.improve_tol = improve_tol\n        self.shortcutting_trials = shortcutting_trials\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map):\n        bounds = map.size\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        obstacles = map.obstacles\n\n        start_pos = map.start\n        goal_pos = map.goal\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        best_cost = float(\"inf\")\n        best_path = []\n        c_min = math.dist(start_pos, goal_pos)\n        found_solution = False\n\n        no_improve_count = 0\n        post_iter = 0\n\n        start_time = time.time()\n\n        def within_bounds(p):\n            return all(0.0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_p, to_p):\n            d = dist(from_p, to_p)\n            if d <= self.step_size:\n                return to_p\n            r = self.step_size / d\n            return tuple(from_p[i] + (to_p[i] - from_p[i]) * r for i in range(dim))\n\n        def neighbor_radius_fn(n_nodes):\n            if self.max_radius is not None:\n                maxr = self.max_radius\n            else:\n                maxr = max(bounds) * 0.25\n            if n_nodes < 2:\n                return min(self.step_size * 3.0, maxr)\n            r = self.gamma_rrt_star * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            return max(self.step_size * 2.0, min(r, maxr))\n\n        def nearest(tree, pt):\n            mn = None\n            md = float(\"inf\")\n            for n in tree:\n                d = dist(n.position, pt)\n                if d < md:\n                    md = d\n                    mn = n\n            return mn\n\n        def near_nodes(tree, pos, radius):\n            r_sq = radius * radius\n            return [n for n in tree if sum((n.position[i] - pos[i]) ** 2 for i in range(dim)) <= r_sq]\n\n        def collision_free(p):\n            return not self._is_in_obstacle(p, obstacles, is_3d)\n\n        def edge_collision_free(p1, p2):\n            distance = dist(p1, p2)\n            steps = max(3, int(distance / 1.0))\n            for i in range(steps + 1):\n                ip = tuple(p1[d] + (p2[d] - p1[d]) * (i / steps) for d in range(dim))\n                if self._is_in_obstacle(ip, obstacles, is_3d):\n                    return False\n            return True\n\n        def add_node_rrtstar(tree, pos):\n            r = neighbor_radius_fn(len(tree))\n            neigh = near_nodes(tree, pos, r)\n\n            candidate_parents = [n for n in neigh if edge_collision_free(n.position, pos)]\n            if not candidate_parents:\n                nearest_node = nearest(tree, pos)\n                if edge_collision_free(nearest_node.position, pos):\n                    parent = nearest_node\n                else:\n                    return None, []\n            else:\n                parent = min(candidate_parents, key=lambda n: n.cost + dist(n.position, pos))\n            new_cost = parent.cost + dist(parent.position, pos)\n            new_node = Node(pos, parent=None, cost=new_cost)\n            parent.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((parent, new_node))\n            return new_node, neigh\n\n        def rewire(node, neighbors):\n            for nb in neighbors:\n                if nb is node:\n                    continue\n                if not edge_collision_free(node.position, nb.position):\n                    continue\n                new_cost = node.cost + dist(node.position, nb.position)\n                if new_cost + 1e-15 < nb.cost:\n                    # rewire neighbor's parent\n                    if nb.parent:\n                        try:\n                            edges.remove((nb.parent, nb))\n                        except ValueError:\n                            pass\n                        if nb in nb.parent.children:\n                            nb.parent.children.remove(nb)\n                    node.add_child(nb)\n                    nb.cost = new_cost\n                    edges.append((node, nb))\n\n        def stitch_paths(node_start, node_goal):\n            path_start = node_start.path_from_root()\n            path_goal = node_goal.path_from_root()\n            if path_start and path_goal and path_start[-1] == path_goal[-1]:\n                merged = path_start + path_goal[-2::-1]\n            else:\n                merged = path_start + path_goal[::-1]\n            return merged\n\n        def path_cost(path):\n            c = 0.0\n            for i in range(len(path) - 1):\n                c += dist(path[i], path[i+1])\n            return c\n\n        def informed_sample(start, goal, c_best, c_min):\n            if c_best == float(\"inf\") or c_min < 1e-12:\n                # Uniform random\n                while True:\n                    sample = tuple(random.uniform(0.0, bounds[d]) for d in range(dim))\n                    if collision_free(sample):\n                        return sample\n            r1 = c_best / 2.0\n            r_other_sq = max(c_best * c_best - c_min * c_min, 0.0)\n            r_other = math.sqrt(r_other_sq) / 2.0\n            center = tuple((start[d] + goal[d]) / 2.0 for d in range(dim))\n            a1 = tuple((goal[d] - start[d]) / c_min for d in range(dim))\n\n            def sample_unit_ball(k):\n                while True:\n                    v = [random.gauss(0, 1) for _ in range(k)]\n                    norm_v = math.sqrt(sum(x * x for x in v))\n                    if norm_v > 1e-12:\n                        v = [x / norm_v for x in v]\n                        r = random.random() ** (1.0 / k)\n                        return tuple(v[i] * r for i in range(k))\n\n            u = sample_unit_ball(dim)\n\n            if dim == 2:\n                a2 = (-a1[1], a1[0])\n                basis = (a1, a2)\n                radii = (r1, r_other)\n            else:\n                ref = (1.0, 0.0, 0.0) if abs(a1[0]) < 0.9 else (0.0, 1.0, 0.0)\n                b2 = self._normalize(self._cross(a1, ref))\n                if self._norm(b2) < 1e-12:\n                    ref = (0.0, 0.0, 1.0)\n                    b2 = self._normalize(self._cross(a1, ref))\n                b3 = self._cross(a1, b2)\n                basis = (a1, b2, b3)\n                radii = (r1, r_other, r_other)\n\n            sample = []\n            for d in range(dim):\n                val = center[d]\n                for i in range(dim):\n                    val += basis[i][d] * radii[i] * u[i]\n                val = max(0.0, min(bounds[d], val))\n                sample.append(val)\n            sp = tuple(sample)\n            if collision_free(sp):\n                return sp\n            # fallback uniform\n            while True:\n                s = tuple(random.uniform(0.0, bounds[d]) for d in range(dim))\n                if collision_free(s):\n                    return s\n\n        def shortcut_path(path, trials):\n            if len(path) < 3:\n                return path\n            new_path = path[:]\n            for _ in range(trials):\n                if len(new_path) < 3:\n                    break\n                i = random.randint(0, len(new_path) - 3)\n                j = random.randint(i+2, len(new_path) - 1)\n                if edge_collision_free(new_path[i], new_path[j]):\n                    new_path = new_path[:i+1] + new_path[j:]\n            return new_path\n\n        def try_connect_trees(new_node, other_tree):\n            nearest_other = nearest(other_tree, new_node.position)\n            if dist(nearest_other.position, new_node.position) <= self.step_size and edge_collision_free(new_node.position, nearest_other.position):\n                return new_node, nearest_other\n            curr = nearest_other\n            while True:\n                step_pos = steer(curr.position, new_node.position)\n                if not within_bounds(step_pos) or not collision_free(step_pos):\n                    break\n                if not edge_collision_free(curr.position, step_pos):\n                    break\n                new_other_node, _ = add_node_rrtstar(other_tree, step_pos)\n                if new_other_node is None:\n                    break\n                rewire(new_other_node, near_nodes(other_tree, step_pos, neighbor_radius_fn(len(other_tree))))\n                curr = new_other_node\n                if dist(curr.position, new_node.position) <= self.step_size and edge_collision_free(curr.position, new_node.position):\n                    return new_node, curr\n            return None, None\n\n        iteration = 0\n        side_toggle = 0\n\n        while iteration < self.max_iter:\n            if time.time() - start_time > self.time_limit_sec:\n                break\n            grow_tree = start_tree if side_toggle == 0 else goal_tree\n            other_tree = goal_tree if side_toggle == 0 else start_tree\n            side_toggle = 1 - side_toggle\n\n            # Sample random with goal bias and informed sampling if solution found\n            if found_solution:\n                sample = informed_sample(start_pos, goal_pos, best_cost, c_min)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample = goal_pos\n                else:\n                    while True:\n                        sample = tuple(random.uniform(0.0, bounds[d]) for d in range(dim))\n                        if collision_free(sample):\n                            break\n\n            if not within_bounds(sample) or not collision_free(sample):\n                iteration += 1\n                continue\n            nearest_node = nearest(grow_tree, sample)\n            new_pos = steer(nearest_node.position, sample)\n            if not within_bounds(new_pos) or not collision_free(new_pos) or not edge_collision_free(nearest_node.position, new_pos):\n                iteration += 1\n                continue\n\n            new_node, neighbors = add_node_rrtstar(grow_tree, new_pos)\n            if new_node is None:\n                iteration += 1\n                continue\n            rewire(new_node, neighbors)\n\n            n1, n2 = try_connect_trees(new_node, other_tree)\n            if n1 and n2:\n                candidate_path = stitch_paths(n1, n2)\n                candidate_cost = path_cost(candidate_path)\n                if candidate_cost + self.improve_tol < best_cost:\n                    best_cost = candidate_cost\n                    best_path = shortcut_path(candidate_path, max(10, self.shortcutting_trials // 3))\n                    found_solution = True\n                    no_improve_count = 0\n                    post_iter = 0\n                else:\n                    no_improve_count += 1\n                    post_iter += 1\n\n                if found_solution and (post_iter >= self.post_opt_iters or no_improve_count >= self.max_no_improve):\n                    break\n            else:\n                if found_solution:\n                    no_improve_count += 1\n                    post_iter += 1\n                    if post_iter >= self.post_opt_iters or no_improve_count >= self.max_no_improve:\n                        break\n\n            iteration += 1\n\n        final_path = best_path if found_solution else []\n\n        if found_solution and len(final_path) > 2:\n            final_path = shortcut_path(final_path, self.shortcutting_trials)\n\n        return PlannerResult(\n            success=found_solution,\n            path=final_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    # Collision helpers\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    # Vector utilities (for 3D rotation basis)\n    def _cross(self, a, b):\n        ax, ay, az = a\n        bx, by, bz = b\n        return (ay * bz - az * by, az * bx - ax * bz, ax * by - ay * bx)\n\n    def _norm(self, v):\n        return math.sqrt(sum(x * x for x in v))\n\n    def _normalize(self, v):\n        n = self._norm(v)\n        if n < 1e-12:\n            return v\n        return tuple(x / n for x in v)",
    "objective": 77.77843,
    "time_improvement": -320.0,
    "length_improvement": 20.0,
    "smoothness_improvement": 1285.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.12858455181121825,
            "num_nodes_avg": 346.5,
            "path_length_avg": 151.9523632213864,
            "smoothness_avg": 0.038746386554238246,
            "success_improvement": 0.0,
            "time_improvement": -389.7933291739433,
            "length_improvement": 16.712501879078157,
            "smoothness_improvement": 506.46508869892443,
            "objective_score": -104.37817218124145
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.13421530723571778,
            "num_nodes_avg": 519.3,
            "path_length_avg": 233.98936024553228,
            "smoothness_avg": 0.07859110522493014,
            "success_improvement": 0.0,
            "time_improvement": 18.726365142442578,
            "length_improvement": 21.88761653973944,
            "smoothness_improvement": 1922.2057443224785,
            "objective_score": 28.36150818818883
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.34611313343048095,
            "num_nodes_avg": 601.1,
            "path_length_avg": 120.34101107668394,
            "smoothness_avg": 0.11987741164255357,
            "success_improvement": 0.0,
            "time_improvement": -588.2930735618755,
            "length_improvement": 20.075230466017764,
            "smoothness_improvement": 1424.8318276631776,
            "objective_score": -157.3186246506361
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "e2",
    "algorithm_description": "A hybrid bidirectional planner integrating adaptive informed sampling, efficient collision checking, incremental rewiring, and pruning of suboptimal branches to accelerate convergence while improving path quality and smoothness. This planner progressively grows two trees from start and goal, samples within a progressively refined informed ellipsoid to focus search, rewires local neighborhoods to optimize costs, prunes expensive or redundant nodes to reduce search overhead, and performs incremental shortcutting to smooth partial paths as they improve.",
    "planning_mechanism": "The planner initializes two trees from start and goal and alternates their expansions by sampling within an adaptively shrinking ellipsoid based on the current best path cost. Each new sample is connected if collision-free, then rewiring optimizes local connectivity. Successful connections between trees update the best path and ellipsoid size. Periodic pruning removes nodes too costly or far from the solution corridor, and incremental shortcutting is applied to avoid jagged paths. This combined approach balances exploration and exploitation for fast, smooth, and high-quality path discovery.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\nclass Planner:\n    def __init__(self, max_iter=6000, step_size=5.0, base_rewire_radius=15.0, prune_interval=500):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.base_rewire_radius = base_rewire_radius\n        self.prune_interval = prune_interval\n\n    def plan(self, map) -> 'PlannerResult':\n        import math, random\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        edges = []\n\n        best_path = []\n        best_cost = float('inf')\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def in_collision(p):\n            for o in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d = o\n                    px,py,pz = p\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                        return True\n                else:\n                    x,y,w,h = o\n                    px,py = p\n                    if x <= px <= x+w and y <= py <= y+h:\n                        return True\n            return False\n\n        def edge_collision(p1,p2,res=0.5):\n            distance = dist(p1,p2)\n            steps = max(1,int(distance/res))\n            for i in range(steps+1):\n                interp = tuple(p1[d]+(p2[d]-p1[d])*i/steps for d in range(dim))\n                if in_collision(interp):\n                    return True\n            return False\n\n        def steer(from_p,to_p,step):\n            distance = dist(from_p,to_p)\n            if distance <= step:\n                return to_p\n            ratio = step / distance\n            return tuple(from_p[i] + (to_p[i]-from_p[i])*ratio for i in range(dim))\n\n        def nearest(tree,p):\n            min_node = None\n            min_dist = float('inf')\n            for node in tree:\n                d = dist(node.position,p)\n                if d < min_dist:\n                    min_dist = d\n                    min_node = node\n            return min_node\n\n        def near(tree, p, radius):\n            r2 = radius*radius\n            result = []\n            for n in tree:\n                dd = 0\n                pos = n.position\n                for i in range(dim):\n                    diff = pos[i] - p[i]\n                    dd += diff*diff\n                    if dd > r2:\n                        break\n                if dd <= r2:\n                    result.append(n)\n            return result\n\n        def extract_path(n_start, n_goal):\n            path_start, path_goal = [], []\n            while n_start:\n                path_start.append(n_start.position)\n                n_start = n_start.parent\n            while n_goal:\n                path_goal.append(n_goal.position)\n                n_goal = n_goal.parent\n            path_start.reverse()\n            return path_start + path_goal\n\n        def shortcut(path):\n            if len(path) <= 2:\n                return path\n            i=0\n            while i < len(path)-2:\n                j=len(path)-1\n                while j > i+1:\n                    if not edge_collision(path[i], path[j]):\n                        path = path[:i+1]+path[j:]\n                        break\n                    j -= 1\n                i +=1\n            return path\n\n        def mat_vec_mult(mat, vec):\n            return tuple(sum(mat[i][j]*vec[j] for j in range(dim)) for i in range(dim))\n\n        def informed_sample(c_best):\n            if c_best == float('inf'):\n                while True:\n                    sample = tuple(random.uniform(0,bounds[i]) for i in range(dim))\n                    if not in_collision(sample):\n                        return sample\n            c_min = dist(start_pos,goal_pos)\n            if c_min < 1e-12:\n                return goal_pos\n            center = tuple((start_pos[i]+goal_pos[i])*0.5 for i in range(dim))\n            a1 = [(goal_pos[i]-start_pos[i])/c_min for i in range(dim)]\n\n            # rotation matrix R aligning x-axis to a1 vector (2D or 3D)\n            if dim == 2:\n                theta = math.acos(max(min(a1[0],1.0), -1.0))\n                if a1[1] < 0:\n                    theta = -theta\n                R = [[math.cos(theta), -math.sin(theta)],\n                     [math.sin(theta), math.cos(theta)]]\n            elif dim == 3:\n                x = a1\n                I = [[1 if i==j else 0 for j in range(3)] for i in range(3)]\n                v = [x[0]-1, x[1], x[2]]\n                norm_v = math.sqrt(sum(vi*vi for vi in v))\n                if norm_v < 1e-10:\n                    R = I\n                else:\n                    v = [vi/norm_v for vi in v]\n                    R = [[I[i][j]-2*v[i]*v[j] for j in range(3)] for i in range(3)]\n            else:\n                R = [[1 if i==j else 0 for j in range(dim)] for i in range(dim)]\n\n            L1 = c_best/2.0\n            L2 = math.sqrt(max(c_best*c_best - c_min*c_min, 0))/2.0\n\n            while True:\n                while True:\n                    sample = [random.uniform(-1,1) for _ in range(dim)]\n                    norm_s = math.sqrt(sum(x*x for x in sample))\n                    if norm_s > 0 and norm_s <= 1:\n                        break\n                unit_s = [x/norm_s for x in sample]\n                r_ball = random.uniform(0,1)**(1/dim)\n                unit_ball = [r_ball * us for us in unit_s]\n                ellip = [L1*unit_ball[0]] + ([L2*unit_ball[i] for i in range(1,dim)] if dim>1 else [])\n                rotated = mat_vec_mult(R, ellip)\n                point = tuple(center[i]+rotated[i] for i in range(dim))\n                if all(0 <= point[i] <= bounds[i] for i in range(dim)) and not in_collision(point):\n                    return point\n\n        def rewire_radius(num_nodes):\n            if num_nodes < 2:\n                return self.base_rewire_radius\n            gamma_rrt = 2 * (1 + 1/dim)**(1/dim) * (math.prod(bounds)**(1/dim))\n            return min(self.base_rewire_radius, gamma_rrt * (math.log(num_nodes)/num_nodes)**(1/dim))\n\n        def rewire(tree, new_node):\n            r = rewire_radius(len(tree))\n            neighbors = near(tree, new_node.position, r)\n            for node in neighbors:\n                if node is new_node.parent:\n                    continue\n                if edge_collision(new_node.position, node.position):\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, node.position)\n                if new_cost + 1e-9 < node.cost:\n                    if node.parent:\n                        try:\n                            node.parent.children.remove(node)\n                        except:\n                            pass\n                    node.parent = new_node\n                    node.cost = new_cost\n                    new_node.add_child(node)\n\n        def prune_tree(tree, threshold_cost, base_radius):\n            # Remove nodes with cost exceeding threshold plus small epsilon or out of ellipsoid corridor\n            threshold = threshold_cost + 1e-10\n            survivors = []\n            for n in tree:\n                if n.cost <= threshold:\n                    survivors.append(n)\n                else:\n                    # detach from parent and children to help GC\n                    if n.parent and n in n.parent.children:\n                        n.parent.children.remove(n)\n                    for c in n.children:\n                        c.parent = None\n                    n.children.clear()\n                    n.parent = None\n            return survivors\n\n        def incremental_shortcut(path, attempts=5):\n            if len(path) < 3:\n                return path\n            for _ in range(attempts):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path)-3)\n                j = random.randint(i+2, len(path)-1)\n                if not edge_collision(path[i], path[j]):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        for it in range(1, self.max_iter+1):\n            sample = informed_sample(best_cost)\n\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest_node = nearest(tree_a, sample)\n                new_pos = steer(nearest_node.position, sample, self.step_size)\n\n                if in_collision(new_pos):\n                    continue\n                if edge_collision(nearest_node.position, new_pos):\n                    continue\n\n                new_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n                new_node = Node(new_pos, parent=nearest_node, cost=new_cost)\n                nearest_node.add_child(new_node)\n                tree_a.append(new_node)\n                edges.append((nearest_node, new_node))\n\n                rewire(tree_a, new_node)\n\n                connect_node = nearest(tree_b, new_pos)\n                gap = dist(new_pos, connect_node.position)\n\n                if gap <= self.step_size * 1.8 and not edge_collision(new_pos, connect_node.position):\n                    connect_new = Node(connect_node.position, parent=new_node, cost=new_node.cost+gap)\n                    new_node.add_child(connect_new)\n                    tree_b.append(connect_new)\n                    edges.append((new_node, connect_new))\n\n                    candidate_path = extract_path(connect_new, connect_node)\n                    candidate_path = incremental_shortcut(candidate_path, attempts=5)\n\n                    candidate_cost = 0.0\n                    for i in range(len(candidate_path)-1):\n                        candidate_cost += dist(candidate_path[i], candidate_path[i+1])\n\n                    if candidate_cost < best_cost:\n                        best_cost = candidate_cost\n                        best_path = candidate_path\n\n            if it % self.prune_interval == 0 and best_cost < float('inf'):\n                # prune nodes with cost significantly larger than best_cost\n                start_tree = prune_tree(start_tree, best_cost * 1.5, self.base_rewire_radius)\n                goal_tree = prune_tree(goal_tree, best_cost * 1.5, self.base_rewire_radius)\n\n            if best_path and it > 100:\n                # to improve performance, return if a good solution found and later iterations do no better\n                # but allow some minimal iteration count for exploration\n                return PlannerResult(True, best_path, start_tree + goal_tree, edges)\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)",
    "objective": 108.6279,
    "time_improvement": -320.0,
    "length_improvement": 5.0,
    "smoothness_improvement": 175.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 0.9,
            "time_avg": 0.07723460197448731,
            "num_nodes_avg": 163.8,
            "path_length_avg": 183.50184519005137,
            "smoothness_avg": 0.014077224319056947,
            "success_improvement": -9.999999999999998,
            "time_improvement": -194.19547135061208,
            "length_improvement": -0.5802691214811182,
            "smoothness_improvement": 120.33912977512678,
            "objective_score": -108.00510722919667
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.07508623600006104,
            "num_nodes_avg": 273.3,
            "path_length_avg": 271.01983879259393,
            "smoothness_avg": 0.011573333632518007,
            "success_improvement": 0.0,
            "time_improvement": 54.53177842986512,
            "length_improvement": 9.525776937503677,
            "smoothness_improvement": 197.79021029996278,
            "objective_score": 23.063950742961556
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.4629765272140503,
            "num_nodes_avg": 358.9,
            "path_length_avg": 139.94020145114783,
            "smoothness_avg": 0.024056533595200005,
            "success_improvement": 0.0,
            "time_improvement": -820.6918377951919,
            "length_improvement": 7.058381432453585,
            "smoothness_improvement": 205.99733166234114,
            "objective_score": -240.94253582077368
        }
    ],
    "success_rate": 0.9666666666666667
}
{
    "operator": "m3",
    "algorithm_description": "An improved single-tree RRT with goal bias and incremental path smoothing. The planner grows a single tree from the start towards random samples or the goal with a fixed step size, uses efficient nearest node search, rigorous collision checking at nodes and edges, and performs incremental shortcut smoothing of newly connected paths to improve both path length and smoothness without costly rewiring. This balances efficiency, path quality, and computational cost.",
    "planning_mechanism": "The algorithm grows one tree from the start position toward randomly sampled points or with bias towards the goal, incrementally extending nodes while avoiding obstacles. It terminates early upon connecting directly to the goal within step size. Whenever a connection is made, a shortcutting smoothing step is applied on the resulting partial path immediately to reduce jagged segments, thus improving smoothness and path length without complex rewiring.",
    "code": "class Node:\n    def __init__(self, position, parent=None):\n        self.position = position\n        self.parent = parent\n        self.children = []\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n    def path_from_root(self):\n        path, node = [], self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=4000, step_size=6.0, goal_sample_rate=0.1, smooth_iters=30):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.smooth_iters = smooth_iters\n\n    def plan(self, map):\n        import random, math\n\n        bounds = map.size\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        tree = [Node(start)]\n        nodes = tree[:]\n        edges = []\n\n        def in_obstacle(p):\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d = obs\n                    if x <= p[0] <= x+w and y <= p[1] <= y+h and z <= p[2] <= z+d:\n                        return True\n                else:\n                    x,y,w,h = obs\n                    if x <= p[0] <= x+w and y <= p[1] <= y+h:\n                        return True\n            return False\n\n        def edge_collision(p1,p2,res=1.0):\n            dist = math.dist(p1,p2)\n            steps = max(1,int(dist/res))\n            for i in range(1,steps+1):\n                ip = tuple(p1[d] + (p2[d]-p1[d]) * i/steps for d in range(dim))\n                if in_obstacle(ip):\n                    return True\n            return False\n\n        def sample_free():\n            r = random.random()\n            if r < self.goal_sample_rate:\n                return goal\n            while True:\n                pt = tuple(random.uniform(0,bounds[d]) for d in range(dim))\n                if not in_obstacle(pt):\n                    return pt\n\n        def nearest(tree, point):\n            best = None\n            best_dist = float('inf')\n            for node in tree:\n                d = math.dist(node.position, point)\n                if d < best_dist:\n                    best = node\n                    best_dist = d\n            return best\n\n        def steer(from_p, to_p):\n            d = math.dist(from_p, to_p)\n            if d <= self.step_size:\n                return to_p\n            ratio = self.step_size / d\n            return tuple(from_p[d] + ratio * (to_p[d] - from_p[d]) for d in range(dim))\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path[:]\n            p = path[:]\n            for _ in range(self.smooth_iters):\n                if len(p) < 3:\n                    break\n                i = random.randint(0,len(p)-3)\n                j = random.randint(i+2,len(p)-1)\n                if not edge_collision(p[i], p[j]):\n                    p = p[:i+1] + p[j:]\n            return p\n\n        for _ in range(self.max_iter):\n            rand_pt = sample_free()\n            nearest_node = nearest(tree, rand_pt)\n            new_pos = steer(nearest_node.position, rand_pt)\n            if in_obstacle(new_pos) or edge_collision(nearest_node.position, new_pos):\n                continue\n            new_node = Node(new_pos, nearest_node)\n            nearest_node.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n\n            # Check if goal reached sufficiently closely and edge not in collision\n            if math.dist(new_pos, goal) <= self.step_size and not edge_collision(new_pos, goal):\n                goal_node = Node(goal, new_node)\n                new_node.add_child(goal_node)\n                tree.append(goal_node)\n                nodes.append(goal_node)\n                edges.append((new_node, goal_node))\n                path = goal_node.path_from_root()\n                smooth_path = shortcut_path(path)\n                return PlannerResult(True, smooth_path, nodes, edges)\n        return PlannerResult(False, [], nodes, edges)",
    "objective": -29.54917,
    "time_improvement": 65.0,
    "length_improvement": 11.0,
    "smoothness_improvement": 732.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.01264190673828125,
            "num_nodes_avg": 251.0,
            "path_length_avg": 177.46674489907502,
            "smoothness_avg": 0.026830913377190374,
            "success_improvement": 0.0,
            "time_improvement": 51.845524977681876,
            "length_improvement": 2.7276649802869177,
            "smoothness_improvement": 319.96205861397976,
            "objective_score": 18.79006677454661
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.039261603355407716,
            "num_nodes_avg": 773.3,
            "path_length_avg": 252.5749846219017,
            "smoothness_avg": 0.03931518900385589,
            "success_improvement": 0.0,
            "time_improvement": 76.22526609855663,
            "length_improvement": 15.683200165371181,
            "smoothness_improvement": 911.6081306552461,
            "objective_score": 36.835540582065924
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.016443514823913576,
            "num_nodes_avg": 421.9,
            "path_length_avg": 130.45390021590327,
            "smoothness_avg": 0.0835968046133641,
            "success_improvement": 0.0,
            "time_improvement": 67.29983272771409,
            "length_improvement": 13.358731023780487,
            "smoothness_improvement": 963.3451842077347,
            "objective_score": 33.02191435362119
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m3",
    "algorithm_description": "An improved single-tree RRT with goal bias that incrementally extends the tree toward random samples or the goal, performs direct collision checks before adding nodes and edges, and applies path shortcutting to improve path smoothness and length as soon as a path to the goal is found. This approach balances planning speed, path quality, and computational simplicity.",
    "planning_mechanism": "The planner grows a single tree from the start by sampling points with goal bias, steering toward samples within a fixed step size, and ensuring collision-free nodes and edges. Upon connecting to the goal, it extracts the path and applies multiple shortcut attempts to smooth and shorten it.",
    "code": "class Node:\n    def __init__(self, position, parent=None):\n        self.position = position\n        self.parent = parent\n        self.children = []\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n    def path_from_root(self):\n        path, node = [], self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=4000, step_size=6.0, goal_sample_rate=0.1, smooth_iters=30):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.smooth_iters = smooth_iters\n\n    def plan(self, map):\n        import random, math\n\n        start = map.start\n        goal = map.goal\n        bounds = map.size\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = dim == 3\n\n        def in_obstacle(p):\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d = obs\n                    if x <= p[0] <= x+w and y <= p[1] <= y+h and z <= p[2] <= z+d:\n                        return True\n                else:\n                    x,y,w,h = obs\n                    if x <= p[0] <= x+w and y <= p[1] <= y+h:\n                        return True\n            return False\n\n        def edge_collision(p1,p2,res=1.0):\n            dist = math.dist(p1,p2)\n            steps = max(1, int(dist/res))\n            for i in range(1, steps+1):\n                ip = tuple(p1[d] + (p2[d]-p1[d]) * i/steps for d in range(dim))\n                if in_obstacle(ip):\n                    return True\n            return False\n\n        def sample_point():\n            if random.random() < self.goal_sample_rate:\n                return goal\n            while True:\n                pt = tuple(random.uniform(0,bounds[d]) for d in range(dim))\n                if not in_obstacle(pt):\n                    return pt\n\n        def nearest_node(tree, point):\n            best, best_dist = None, float('inf')\n            for node in tree:\n                dist = math.dist(node.position, point)\n                if dist < best_dist:\n                    best, best_dist = node, dist\n            return best\n\n        def steer(from_p, to_p):\n            dist = math.dist(from_p, to_p)\n            if dist <= self.step_size:\n                return to_p\n            ratio = self.step_size / dist\n            return tuple(from_p[d] + ratio*(to_p[d] - from_p[d]) for d in range(dim))\n\n        def shortcut_path(path):\n            p = path[:]\n            for _ in range(self.smooth_iters):\n                if len(p) < 3:\n                    break\n                i = random.randint(0, len(p)-3)\n                j = random.randint(i+2, len(p)-1)\n                if not edge_collision(p[i], p[j]):\n                    p = p[:i+1] + p[j:]\n            return p\n\n        tree = [Node(start)]\n\n        for _ in range(self.max_iter):\n            rand_pt = sample_point()\n            nearest = nearest_node(tree, rand_pt)\n            new_pos = steer(nearest.position, rand_pt)\n            if in_obstacle(new_pos) or edge_collision(nearest.position, new_pos):\n                continue\n            new_node = Node(new_pos, nearest)\n            nearest.add_child(new_node)\n            tree.append(new_node)\n\n            if math.dist(new_pos, goal) <= self.step_size and not edge_collision(new_pos, goal):\n                goal_node = Node(goal, new_node)\n                new_node.add_child(goal_node)\n                tree.append(goal_node)\n                path = goal_node.path_from_root()\n                smooth_path = shortcut_path(path)\n                return PlannerResult(True, smooth_path, tree, [(n.parent, n) for n in tree if n.parent])\n\n        return PlannerResult(False, [], tree, [(n.parent, n) for n in tree if n.parent])",
    "objective": -28.58352,
    "time_improvement": 65.0,
    "length_improvement": 9.0,
    "smoothness_improvement": 764.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.013500356674194336,
            "num_nodes_avg": 234.0,
            "path_length_avg": 181.91284921967247,
            "smoothness_avg": 0.02454238749256365,
            "success_improvement": 0.0,
            "time_improvement": 48.57559055618673,
            "length_improvement": 0.2906847491360036,
            "smoothness_improvement": 284.1416589060716,
            "objective_score": 16.167796310867978
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.043396592140197754,
            "num_nodes_avg": 822.3,
            "path_length_avg": 255.7830699481661,
            "smoothness_avg": 0.04489486357795229,
            "success_improvement": 0.0,
            "time_improvement": 73.72133733248153,
            "length_improvement": 14.612248943847922,
            "smoothness_improvement": 1055.177176323898,
            "objective_score": 36.159636447672696
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.013333845138549804,
            "num_nodes_avg": 401.4,
            "path_length_avg": 133.9702026300119,
            "smoothness_avg": 0.08276683709463699,
            "success_improvement": 0.0,
            "time_improvement": 73.48383413871842,
            "length_improvement": 11.023370388657252,
            "smoothness_improvement": 952.7880586313554,
            "objective_score": 33.42311276796666
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m3",
    "algorithm_description": "An RRT planner that grows a single tree by sampling points within the map bounds with goal bias, incrementally extending towards samples at a fixed step size while avoiding collisions. When the goal is reached within step size and a collision-free edge, it returns the path shortened by iterative random shortcutting to improve smoothness and length.",
    "planning_mechanism": "The planner samples points randomly with bias to the goal, finds the nearest node in the tree, moves a fixed distance towards the sample if collision-free, and adds the new node; upon reaching the goal, extracts and shortcuts the path before returning.",
    "code": "class Node:\n    def __init__(self, position, parent=None):\n        self.position = position\n        self.parent = parent\n        self.children = []\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n    def path_from_root(self):\n        node, path = self, []\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=4000, step_size=6.0, goal_sample_rate=0.1, smooth_iters=30):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.smooth_iters = smooth_iters\n\n    def plan(self, map):\n        import random, math\n\n        start, goal = map.start, map.goal\n        bounds = map.size\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = dim == 3\n\n        def in_obstacle(p):\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d = obs\n                    if x <= p[0] <= x+w and y <= p[1] <= y+h and z <= p[2] <= z+d:\n                        return True\n                else:\n                    x,y,w,h = obs\n                    if x <= p[0] <= x+w and y <= p[1] <= y+h:\n                        return True\n            return False\n\n        def edge_collision(p1, p2, res=1.0):\n            dist = math.dist(p1, p2)\n            steps = max(1, int(dist / res))\n            for i in range(1, steps + 1):\n                inter = tuple(p1[d] + (p2[d] - p1[d]) * i / steps for d in range(dim))\n                if in_obstacle(inter):\n                    return True\n            return False\n\n        def sample_point():\n            if random.random() < self.goal_sample_rate:\n                return goal\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not in_obstacle(pt):\n                    return pt\n\n        def nearest_node(tree, point):\n            best, best_dist = None, float('inf')\n            for node in tree:\n                dist = math.dist(node.position, point)\n                if dist < best_dist:\n                    best, best_dist = node, dist\n            return best\n\n        def steer(from_p, to_p):\n            dist = math.dist(from_p, to_p)\n            if dist <= self.step_size:\n                return to_p\n            ratio = self.step_size / dist\n            return tuple(from_p[d] + ratio * (to_p[d] - from_p[d]) for d in range(dim))\n\n        def shortcut_path(path):\n            p = path[:]\n            for _ in range(self.smooth_iters):\n                if len(p) < 3:\n                    break\n                i = random.randint(0, len(p) - 3)\n                j = random.randint(i + 2, len(p) - 1)\n                if not edge_collision(p[i], p[j]):\n                    p = p[:i + 1] + p[j:]\n            return p\n\n        tree = [Node(start)]\n\n        for _ in range(self.max_iter):\n            rnd = sample_point()\n            nearest = nearest_node(tree, rnd)\n            new_pos = steer(nearest.position, rnd)\n            if in_obstacle(new_pos) or edge_collision(nearest.position, new_pos):\n                continue\n            new_node = Node(new_pos, nearest)\n            nearest.add_child(new_node)\n            tree.append(new_node)\n\n            if math.dist(new_pos, goal) <= self.step_size and not edge_collision(new_pos, goal):\n                goal_node = Node(goal, new_node)\n                new_node.add_child(goal_node)\n                tree.append(goal_node)\n                path = goal_node.path_from_root()\n                smooth = shortcut_path(path)\n                return PlannerResult(True, smooth, tree, [(n.parent, n) for n in tree if n.parent])\n\n        return PlannerResult(False, [], tree, [(n.parent, n) for n in tree if n.parent])",
    "objective": -19.19067,
    "time_improvement": 33.0,
    "length_improvement": 8.0,
    "smoothness_improvement": 934.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.016424965858459473,
            "num_nodes_avg": 315.1,
            "path_length_avg": 183.42054422525388,
            "smoothness_avg": 0.02429115024645861,
            "success_improvement": 0.0,
            "time_improvement": 37.43541820486903,
            "length_improvement": -0.5357067743793836,
            "smoothness_improvement": 280.2092504341157,
            "objective_score": 12.310247649003658
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.03853583335876465,
            "num_nodes_avg": 765.1,
            "path_length_avg": 263.85618517906795,
            "smoothness_avg": 0.06626916502001186,
            "success_improvement": 0.0,
            "time_improvement": 76.66475371671739,
            "length_improvement": 11.917210708035158,
            "smoothness_improvement": 1605.1533477151374,
            "objective_score": 38.175519278412
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.058287858963012695,
            "num_nodes_avg": 623.8,
            "path_length_avg": 132.29760554293722,
            "smoothness_avg": 0.07987004155434323,
            "success_improvement": 0.0,
            "time_improvement": -15.913340818230779,
            "length_improvement": 12.134229733377804,
            "smoothness_improvement": 915.9410331780239,
            "objective_score": 7.086240760447567
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "e2",
    "algorithm_description": "A hybrid bidirectional informed RRT* variant employing adaptive rewiring, heuristic ellipsoidal sampling, and incremental connection attempts between trees. The algorithm balances exploration and exploitation by alternating tree expansions with focused sampling, adaptive neighborhood rewiring to improve path quality, strict obstacle collision checks on nodes and edges, and shortcutting path refinement to ensure smoothness and shortened path length. This mechanism effectively improves planning efficiency, robustness, and path optimality in cluttered environments.",
    "planning_mechanism": "The planner grows two trees from start and goal, samples informed points inside an ellipsoidal heuristic region for efficiency, extends trees toward sampled points with collision checks, rewires locally to improve path costs adaptively, attempts direct connections between trees, and performs path shortcutting as post-processing before returning the final solution.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n    def add_child(self, child):\n        self.children.append(child)\nclass Planner:\n    def __init__(self, max_iter=4000, step_size=5.0, base_rewire_radius=15.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.base_rewire_radius = base_rewire_radius\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        start_tree = [Node(start_pos, None, 0.0)]\n        goal_tree = [Node(goal_pos, None, 0.0)]\n        edges = []\n        best_cost = float('inf')\n        best_path = []\n\n        def dist(a,b):\n            import math\n            return math.dist(a,b)\n\n        def in_collision(p):\n            if any(p[d]<0 or p[d]>bounds[d] for d in range(dim)):\n                return True\n            for o in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d = o\n                    px,py,pz = p\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                        return True\n                else:\n                    x,y,w,h = o\n                    px,py = p\n                    if x <= px <= x+w and y <= py <= y+h:\n                        return True\n            return False\n\n        def edge_collision(p1,p2,res=1.0):\n            distance = dist(p1,p2)\n            steps = max(1,int(distance/res))\n            for i in range(steps+1):\n                interp = tuple(p1[d] + (p2[d]-p1[d])*i/steps for d in range(dim))\n                if in_collision(interp):\n                    return True\n            return False\n\n        def steer(from_p,to_p,step):\n            distance = dist(from_p,to_p)\n            if distance <= step:\n                return to_p\n            ratio = step / distance\n            return tuple(from_p[i] + (to_p[i]-from_p[i])*ratio for i in range(dim))\n\n        def nearest(tree, p):\n            # Returns node minimizing Euclidean distance to p\n            return min(tree, key=lambda n: dist(n.position, p))\n\n        def near(tree, p, radius):\n            r2 = radius*radius\n            result = []\n            for n in tree:\n                d2 = sum((n.position[i]-p[i])**2 for i in range(dim))\n                if d2 <= r2:\n                    result.append(n)\n            return result\n\n        def extract_path(node_start, node_goal):\n            path_start, path_goal = [], []\n            n = node_start\n            while n:\n                path_start.append(n.position)\n                n = n.parent\n            n = node_goal\n            while n:\n                path_goal.append(n.position)\n                n = n.parent\n            path_start.reverse()\n            return path_start + path_goal\n\n        def shortcut(path):\n            if len(path) <= 2:\n                return path\n            i = 0\n            while i < len(path)-2:\n                j = len(path)-1\n                while j > i+1:\n                    if not edge_collision(path[i], path[j]):\n                        path = path[:i+1] + path[j:]\n                        break\n                    j -= 1\n                i += 1\n            return path\n\n        def informed_sample(c_best):\n            import random, math\n            if c_best == float('inf'):\n                while True:\n                    pt = tuple(random.uniform(0,bounds[i]) for i in range(dim))\n                    if not in_collision(pt):\n                        return pt\n\n            c_min = dist(start_pos, goal_pos)\n            if c_min < 1e-10:\n                return goal_pos\n            center = tuple((start_pos[i]+goal_pos[i])*0.5 for i in range(dim))\n            a1 = [(goal_pos[i]-start_pos[i])/c_min for i in range(dim)]\n\n            # rotation matrix R aligning x-axis to a1\n            def mat_vec_mult(mat, vec):\n                return tuple(sum(mat[i][j]*vec[j] for j in range(dim)) for i in range(dim))\n\n            if dim == 2:\n                import math\n                theta = math.acos(max(min(a1[0],1.0),-1.0))\n                if a1[1] < 0:\n                    theta = -theta\n                R = [[math.cos(theta), -math.sin(theta)],\n                     [math.sin(theta),  math.cos(theta)]]\n            elif dim == 3:\n                x = a1\n                I = [[1 if i==j else 0 for j in range(3)] for i in range(3)]\n                v = [x[0]-1, x[1], x[2]]\n                norm_v = math.sqrt(sum(vi*vi for vi in v))\n                if norm_v < 1e-10:\n                    R = I\n                else:\n                    v = [vi/norm_v for vi in v]\n                    R = [[I[i][j]-2*v[i]*v[j] for j in range(3)] for i in range(3)]\n            else:\n                R = [[1 if i==j else 0 for j in range(dim)] for i in range(dim)]\n\n            L1 = c_best/2.0\n            L2 = math.sqrt(max(c_best*c_best - c_min*c_min, 0))/2.0\n\n            while True:\n                while True:\n                    sample = [random.uniform(-1,1) for _ in range(dim)]\n                    norm_s = math.sqrt(sum(x*x for x in sample))\n                    if 0 < norm_s <= 1:\n                        break\n                unit_s = [x/norm_s for x in sample]\n                r = random.uniform(0,1)**(1/dim)\n                unit_ball = [r*u for u in unit_s]\n                ellip = [L1*unit_ball[0]] + [L2*unit_ball[i] for i in range(1,dim)]\n                rotated = mat_vec_mult(R, ellip)\n                point = tuple(center[i]+rotated[i] for i in range(dim))\n                if all(0 <= point[i] <= bounds[i] for i in range(dim)) and (not in_collision(point)):\n                    return point\n\n        def rewire_radius(num_nodes):\n            import math\n            gamma_rrt = 2 * (1 + 1/dim)**(1/dim) * (pow(math.prod(bounds), 1/dim))\n            radius = min(self.base_rewire_radius, gamma_rrt * (math.log(num_nodes+1)/(num_nodes+1))**(1/dim))\n            return radius\n\n        def rewire(tree, new_node):\n            r = rewire_radius(len(tree))\n            neighbors = near(tree, new_node.position, r)\n            for nb in neighbors:\n                if nb == new_node.parent:\n                    continue\n                if edge_collision(new_node.position, nb.position):\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, nb.position)\n                if new_cost + 1e-9 < nb.cost:\n                    if nb.parent:\n                        try:\n                            nb.parent.children.remove(nb)\n                        except Exception:\n                            pass\n                    nb.parent = new_node\n                    nb.cost = new_cost\n                    new_node.add_child(nb)\n                # Try to improve new_node cost via neighbors as well\n                cost_to_new_via_nb = nb.cost + dist(nb.position, new_node.position)\n                if cost_to_new_via_nb + 1e-9 < new_node.cost and not edge_collision(nb.position, new_node.position):\n                    if new_node.parent:\n                        try:\n                            new_node.parent.children.remove(new_node)\n                        except Exception:\n                            pass\n                    new_node.parent = nb\n                    new_node.cost = cost_to_new_via_nb\n                    nb.add_child(new_node)\n\n        import random\n        for iteration in range(self.max_iter):\n            sample = informed_sample(best_cost)\n\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest_node = nearest(tree_a, sample)\n                new_pos = steer(nearest_node.position, sample, self.step_size)\n                if in_collision(new_pos):\n                    continue\n                if edge_collision(nearest_node.position, new_pos):\n                    continue\n                new_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n                new_node = Node(new_pos, parent=nearest_node, cost=new_cost)\n                nearest_node.add_child(new_node)\n                tree_a.append(new_node)\n                edges.append((nearest_node, new_node))\n\n                rewire(tree_a, new_node)\n\n                connect_node = nearest(tree_b, new_pos)\n                gap = dist(new_pos, connect_node.position)\n                if gap <= self.step_size * 1.8 and not edge_collision(new_pos, connect_node.position):\n                    connect_new = Node(connect_node.position, parent=new_node, cost=new_node.cost + gap)\n                    new_node.add_child(connect_new)\n                    tree_b.append(connect_new)\n                    edges.append((new_node, connect_new))\n\n                    # Extract combined path and shortcut it for smoothness\n                    path = extract_path(connect_new, connect_node)\n                    path = shortcut(path)\n\n                    # Compute cost\n                    cost_path = 0.0\n                    for i in range(len(path) - 1):\n                        cost_path += dist(path[i], path[i+1])\n                    if cost_path < best_cost:\n                        best_cost = cost_path\n                        best_path = path\n\n            if best_path:\n                return PlannerResult(True, best_path, start_tree + goal_tree, edges)\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)",
    "objective": -6.42831,
    "time_improvement": 4.0,
    "length_improvement": 18.0,
    "smoothness_improvement": 2195.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.03503596782684326,
            "num_nodes_avg": 98.3,
            "path_length_avg": 162.4431334838995,
            "smoothness_avg": 0.04818856755938396,
            "success_improvement": 0.0,
            "time_improvement": -33.456026256830526,
            "length_improvement": 10.96234446130194,
            "smoothness_improvement": 654.2557254536857,
            "objective_score": -0.18812257299956503
        },
        {
            "map_id": 1,
            "success_rate": 0.9,
            "time_avg": 0.07711725234985352,
            "num_nodes_avg": 259.7,
            "path_length_avg": 227.74123825627717,
            "smoothness_avg": 0.17653460763730278,
            "success_improvement": -9.999999999999998,
            "time_improvement": 53.30190320473256,
            "length_improvement": 23.973419501972636,
            "smoothness_improvement": 4442.362607246129,
            "objective_score": 2.5864356988340056
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.05447630882263184,
            "num_nodes_avg": 199.7,
            "path_length_avg": 120.57501083590122,
            "smoothness_avg": 0.12476181654903722,
            "success_improvement": 0.0,
            "time_improvement": -8.333554592970774,
            "length_improvement": 19.919818967816777,
            "smoothness_improvement": 1486.9610975443823,
            "objective_score": 16.886630490520744
        }
    ],
    "success_rate": 0.9666666666666667
}
{
    "operator": "m3",
    "algorithm_description": "A single-tree RRT planner with goal bias that incrementally extends towards random samples or the goal within map bounds, ensuring collision-free nodes and edges. It directly connects to the goal when possible and applies iterative shortcutting to shorten and smooth the resulting path. This balances simplicity, efficiency, and path quality without complex rewiring or dual-tree management.",
    "planning_mechanism": "The planner grows one tree from the start, sampling points biased toward the goal, extends toward these points with a fixed step size if collision-free, and attempts direct connection to the goal. Upon success, it refines the path by shortcutting to improve length and smoothness before returning the result.",
    "code": "class Node:\n    def __init__(self, position, parent=None):\n        self.position = position\n        self.parent = parent\n        self.children = []\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n    def path_from_root(self):\n        node, path = self, []\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=3000, step_size=5.0, goal_sample_rate=0.1, smooth_iters=20):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.smooth_iters = smooth_iters\n\n    def plan(self, map):\n        import random\n        start, goal = map.start, map.goal\n        bounds = map.size\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = dim == 3\n\n        def in_obstacle(p):\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d = obs\n                    if x <= p[0] <= x+w and y <= p[1] <= y+h and z <= p[2] <= z+d:\n                        return True\n                else:\n                    x,y,w,h = obs\n                    if x <= p[0] <= x+w and y <= p[1] <= y+h:\n                        return True\n            return False\n\n        def edge_collision(p1, p2):\n            import math\n            dist = math.dist(p1, p2)\n            steps = max(1, int(dist / 1.0))\n            for i in range(1, steps+1):\n                ip = tuple(p1[d] + (p2[d]-p1[d]) * i/steps for d in range(dim))\n                if in_obstacle(ip):\n                    return True\n            return False\n\n        def sample_point():\n            if random.random() < self.goal_sample_rate:\n                return goal\n            while True:\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not in_obstacle(p):\n                    return p\n\n        def nearest_node(tree, pt):\n            import math\n            best = None\n            best_dist = float(\"inf\")\n            for n in tree:\n                d = math.dist(n.position, pt)\n                if d < best_dist:\n                    best, best_dist = n, d\n            return best\n\n        def steer(from_p, to_p):\n            import math\n            dist = math.dist(from_p, to_p)\n            if dist <= self.step_size:\n                return to_p\n            ratio = self.step_size / dist\n            return tuple(from_p[d] + ratio * (to_p[d]-from_p[d]) for d in range(dim))\n\n        def shortcut_path(path):\n            import random\n            import math\n            p = path\n            for _ in range(self.smooth_iters):\n                if len(p) < 3:\n                    break\n                i = random.randint(0, len(p)-3)\n                j = random.randint(i+2, len(p)-1)\n                if not edge_collision(p[i], p[j]):\n                    p = p[:i+1] + p[j:]\n            return p\n\n        tree = [Node(start)]\n        for _ in range(self.max_iter):\n            rnd = sample_point()\n            nearest = nearest_node(tree, rnd)\n            new_pos = steer(nearest.position, rnd)\n            if in_obstacle(new_pos) or edge_collision(nearest.position, new_pos):\n                continue\n            new_node = Node(new_pos, nearest)\n            nearest.add_child(new_node)\n            tree.append(new_node)\n\n            import math\n            if math.dist(new_pos, goal) <= self.step_size and not edge_collision(new_pos, goal):\n                goal_node = Node(goal, new_node)\n                new_node.add_child(goal_node)\n                tree.append(goal_node)\n                path = goal_node.path_from_root()\n                smooth_path = shortcut_path(path)\n                edges = [(n.parent, n) for n in tree if n.parent]\n                return PlannerResult(True, smooth_path, tree, edges)\n\n        edges = [(n.parent, n) for n in tree if n.parent]\n        return PlannerResult(False, [], tree, edges)",
    "objective": -23.57065,
    "time_improvement": 58.0,
    "length_improvement": 7.0,
    "smoothness_improvement": 381.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.014452171325683594,
            "num_nodes_avg": 311.0,
            "path_length_avg": 184.945116032427,
            "smoothness_avg": 0.015777086499437463,
            "success_improvement": 0.0,
            "time_improvement": 44.95001920766345,
            "length_improvement": -1.3713487402772202,
            "smoothness_improvement": 146.94566420788803,
            "objective_score": 13.396924839172144
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.059044384956359865,
            "num_nodes_avg": 980.3,
            "path_length_avg": 266.330502537888,
            "smoothness_avg": 0.021634063382426717,
            "success_improvement": 0.0,
            "time_improvement": 64.24586820857652,
            "length_improvement": 11.09121235438472,
            "smoothness_improvement": 456.660033215849,
            "objective_score": 28.21178804128303
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.017370772361755372,
            "num_nodes_avg": 421.8,
            "path_length_avg": 133.58884605976408,
            "smoothness_avg": 0.05032267619592935,
            "success_improvement": 0.0,
            "time_improvement": 65.45585490930883,
            "length_improvement": 11.276649264367416,
            "smoothness_improvement": 540.1007267786442,
            "objective_score": 29.10324966530632
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m3",
    "algorithm_description": "A simplified single-tree RRT planner that incrementally grows from start towards random samples with goal bias, checking collision at nodes and edges. Upon connecting to the goal, it performs shortcut smoothing to improve path quality. This streamlined approach balances clarity and efficiency for general path planning tasks.",
    "planning_mechanism": "A single tree grows by sampling points biased towards the goal, extending towards these samples stepwise if collision-free. When the goal is reachable within step size, the path is connected, and shortcut smoothing is applied before returning the final path.",
    "code": "class Node:\n    def __init__(self, position, parent=None):\n        self.position = position\n        self.parent = parent\n        self.children = []\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n    def path_from_root(self):\n        node, path = self, []\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=3000, step_size=5.0, goal_sample_rate=0.1, smooth_iters=20):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.smooth_iters = smooth_iters\n\n    def plan(self, map):\n        import random\n        start, goal = map.start, map.goal\n        bounds = map.size\n        obstacles = map.obstacles\n        dim = len(bounds)\n\n        def in_obstacle(p):\n            for obs in obstacles:\n                if dim == 3:\n                    x,y,z,w,h,d = obs\n                    if x <= p[0] <= x+w and y <= p[1] <= y+h and z <= p[2] <= z+d:\n                        return True\n                else:\n                    x,y,w,h = obs\n                    if x <= p[0] <= x+w and y <= p[1] <= y+h:\n                        return True\n            return False\n\n        def edge_collision(p1, p2):\n            import math\n            dist = math.dist(p1, p2)\n            steps = max(1, int(dist))\n            for i in range(1, steps+1):\n                ip = tuple(p1[d] + (p2[d]-p1[d]) * i/steps for d in range(dim))\n                if in_obstacle(ip):\n                    return True\n            return False\n\n        def sample_point():\n            if random.random() < self.goal_sample_rate:\n                return goal\n            while True:\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not in_obstacle(p):\n                    return p\n\n        def nearest_node(tree, pt):\n            import math\n            best, best_dist = None, float('inf')\n            for n in tree:\n                d = math.dist(n.position, pt)\n                if d < best_dist:\n                    best, best_dist = n, d\n            return best\n\n        def steer(from_p, to_p):\n            import math\n            dist = math.dist(from_p, to_p)\n            if dist <= self.step_size:\n                return to_p\n            ratio = self.step_size / dist\n            return tuple(from_p[d] + ratio * (to_p[d]-from_p[d]) for d in range(dim))\n\n        def shortcut_path(path):\n            import random\n            for _ in range(self.smooth_iters):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i+2, len(path)-1)\n                if not edge_collision(path[i], path[j]):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        tree = [Node(start)]\n        for _ in range(self.max_iter):\n            rnd = sample_point()\n            nearest = nearest_node(tree, rnd)\n            new_pos = steer(nearest.position, rnd)\n            if in_obstacle(new_pos) or edge_collision(nearest.position, new_pos):\n                continue\n            new_node = Node(new_pos, nearest)\n            nearest.add_child(new_node)\n            tree.append(new_node)\n\n            import math\n            if math.dist(new_pos, goal) <= self.step_size and not edge_collision(new_pos, goal):\n                goal_node = Node(goal, new_node)\n                new_node.add_child(goal_node)\n                tree.append(goal_node)\n                path = goal_node.path_from_root()\n                path = shortcut_path(path)\n                edges = [(n.parent, n) for n in tree if n.parent]\n                return PlannerResult(True, path, tree, edges)\n\n        edges = [(n.parent, n) for n in tree if n.parent]\n        return PlannerResult(False, [], tree, edges)",
    "objective": -23.33287,
    "time_improvement": 59.0,
    "length_improvement": 7.0,
    "smoothness_improvement": 340.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.015235590934753417,
            "num_nodes_avg": 284.5,
            "path_length_avg": 184.94121792369054,
            "smoothness_avg": 0.016946523794565408,
            "success_improvement": 0.0,
            "time_improvement": 41.965883920324984,
            "length_improvement": -1.369212125109286,
            "smoothness_improvement": 165.2498973503724,
            "objective_score": 12.594487387783786
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.06221249103546143,
            "num_nodes_avg": 958.2,
            "path_length_avg": 266.4083752295869,
            "smoothness_avg": 0.020613223343708017,
            "success_improvement": 0.0,
            "time_improvement": 62.32743206320676,
            "length_improvement": 11.065216208454466,
            "smoothness_improvement": 430.39308373825736,
            "objective_score": 27.489324762725992
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.013982272148132325,
            "num_nodes_avg": 408.3,
            "path_length_avg": 135.17266394842352,
            "smoothness_avg": 0.041220965056521584,
            "success_improvement": 0.0,
            "time_improvement": 72.19434877599168,
            "length_improvement": 10.224752836023129,
            "smoothness_improvement": 424.3276329038104,
            "objective_score": 29.914794498930434
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m3",
    "algorithm_description": "A streamlined single-tree Rapidly-exploring Random Tree (RRT) planner that incrementally grows from start towards random samples with goal bias. It ensures node and edge collision-free conditions, and upon reaching the goal, generates the path without further smoothing for simplicity and faster general performance.",
    "planning_mechanism": "A single RRT tree grows by sampling points with goal bias, extending stepwise towards them if collision-free, and connects to the goal directly when reachable within step size, returning the raw path from start to goal.",
    "code": "class Node:\n    def __init__(self, position, parent=None):\n        self.position = position\n        self.parent = parent\n        self.children = []\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n    def path_from_root(self):\n        node, path = self, []\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=3000, step_size=5.0, goal_sample_rate=0.1):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map):\n        import random, math\n        start, goal = map.start, map.goal\n        bounds = map.size\n        obstacles = map.obstacles\n        dim = len(bounds)\n\n        def in_obstacle(p):\n            for obs in obstacles:\n                if dim == 3:\n                    x,y,z,w,h,d = obs\n                    if x <= p[0] <= x+w and y <= p[1] <= y+h and z <= p[2] <= z+d:\n                        return True\n                else:\n                    x,y,w,h = obs\n                    if x <= p[0] <= x+w and y <= p[1] <= y+h:\n                        return True\n            return False\n\n        def edge_collision(p1, p2):\n            dist = math.dist(p1, p2)\n            steps = max(1, int(dist))\n            for i in range(1, steps+1):\n                ip = tuple(p1[d] + (p2[d]-p1[d]) * i/steps for d in range(dim))\n                if in_obstacle(ip):\n                    return True\n            return False\n\n        def sample_point():\n            if random.random() < self.goal_sample_rate:\n                return goal\n            while True:\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not in_obstacle(p):\n                    return p\n\n        def nearest_node(tree, pt):\n            best, best_dist = None, float('inf')\n            for n in tree:\n                d = math.dist(n.position, pt)\n                if d < best_dist:\n                    best, best_dist = n, d\n            return best\n\n        def steer(from_p, to_p):\n            dist = math.dist(from_p, to_p)\n            if dist <= self.step_size:\n                return to_p\n            ratio = self.step_size / dist\n            return tuple(from_p[d] + ratio * (to_p[d]-from_p[d]) for d in range(dim))\n\n        tree = [Node(start)]\n        for _ in range(self.max_iter):\n            rnd = sample_point()\n            nearest = nearest_node(tree, rnd)\n            new_pos = steer(nearest.position, rnd)\n            if in_obstacle(new_pos) or edge_collision(nearest.position, new_pos):\n                continue\n            new_node = Node(new_pos, nearest)\n            nearest.add_child(new_node)\n            tree.append(new_node)\n\n            if math.dist(new_pos, goal) <= self.step_size and not edge_collision(new_pos, goal):\n                goal_node = Node(goal, new_node)\n                new_node.add_child(goal_node)\n                tree.append(goal_node)\n                path = goal_node.path_from_root()\n                edges = [(n.parent, n) for n in tree if n.parent]\n                return PlannerResult(True, path, tree, edges)\n\n        edges = [(n.parent, n) for n in tree if n.parent]\n        return PlannerResult(False, [], tree, edges)",
    "objective": -15.53064,
    "time_improvement": 55.0,
    "length_improvement": -2.0,
    "smoothness_improvement": 64.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.01205458641052246,
            "num_nodes_avg": 258.6,
            "path_length_avg": 189.8774316175603,
            "smoothness_avg": 0.010339503801463782,
            "success_improvement": 0.0,
            "time_improvement": 54.08269557533536,
            "length_improvement": -4.074829070030757,
            "smoothness_improvement": 61.83568708477926,
            "objective_score": 14.089089666006048
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.056881046295166014,
            "num_nodes_avg": 942.9,
            "path_length_avg": 307.6614641896531,
            "smoothness_avg": 0.006310430817754817,
            "success_improvement": 0.0,
            "time_improvement": 65.55587077120757,
            "length_improvement": -2.7062522907439193,
            "smoothness_improvement": 62.37193016043031,
            "objective_score": 18.35486950771807
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.027751445770263672,
            "num_nodes_avg": 553.6,
            "path_length_avg": 149.65863767791262,
            "smoothness_avg": 0.013237491002032609,
            "success_improvement": 0.0,
            "time_improvement": 44.81247297471572,
            "length_improvement": 0.6038588328393786,
            "smoothness_improvement": 68.37990845590703,
            "objective_score": 14.147956734397878
        }
    ],
    "success_rate": 1.0
}
