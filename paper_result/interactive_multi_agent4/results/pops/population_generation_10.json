[
     {
          "operator": "e1",
          "algorithm_description": "A bidirectional incremental Rapid Random Tree with adaptive goal biasing and dynamic rewiring radius, integrating lazy collision checks and a priority queue driven expansion focused on nodes with lower estimated total cost (cost-to-come plus heuristic to goal). The Planner alternates tree expansions, uses informed sampling once a solution is found to prioritize promising regions, and performs dynamic rewiring within an adaptive radius decreasing over iterations to refine paths and reduce unnecessary rewiring overhead. The search employs lazy collision checks by postponing full edge validations until candidate connections are promising, improving efficiency. Path shortcutting post-processing is applied to enhance smoothness and reduce length, while maintaining collision-free guarantees.",
          "planning_mechanism": "A bidirectional, anytime planner that grows two trees from start and goal nodes by sampling either uniform or informed ellipsoidal regions based on current best path cost. The planner uses a priority-driven node expansion strategy prioritizing nodes with lowest estimated total cost, applies adaptive rewiring radius and lazy collision checking to efficiently rewire neighbor nodes only when beneficial, and incrementally attempts to connect the two trees. Upon connection, the algorithm extracts the combined path, applies shortcutting to smooth it, and returns it as the solution. The adaptive rewiring radius gradually decreases to focus optimization near the path, balancing computation and improvement for faster convergence and smoother paths.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost  # cost-to-come\n        self.children = []\n        self.id = id(self)  # unique identifier for potential bookkeeping\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=4000, step_size=5.0, goal_sample_rate=0.15, initial_neighbor_radius=25.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.initial_neighbor_radius = initial_neighbor_radius\n\n    def plan(self, map):\n        bounds = map.size\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        import random\n        import math\n        import heapq\n\n        # Heuristic function for A*-like priority: Euclidean distance to goal\n        def heuristic(p):\n            return sum((p[d] - goal[d]) ** 2 for d in range(dim)) ** 0.5\n\n        # Distance between two points\n        def dist(a, b):\n            return sum((a[d] - b[d]) ** 2 for d in range(dim)) ** 0.5\n\n        # Collision check for point in obstacles\n        def in_obstacle(pt):\n            if is_3d:\n                px, py, pz = pt\n                for obs in obstacles:\n                    ox, oy, oz, w, h, d = obs\n                    if ox <= px <= ox + w and oy <= py <= oy + h and oz <= pz <= oz + d:\n                        return True\n            else:\n                px, py = pt\n                for obs in obstacles:\n                    ox, oy, w, h = obs\n                    if ox <= px <= ox + w and oy <= py <= oy + h:\n                        return True\n            return False\n\n        # Edge collision check by discretizing line at resolution 1.0 units\n        def edge_in_obstacle(p1, p2):\n            distance = dist(p1, p2)\n            steps = max(1, int(distance / 1.0))\n            for i in range(steps + 1):\n                interp = tuple(p1[d] + (p2[d] - p1[d]) * (i / steps) for d in range(dim))\n                if in_obstacle(interp):\n                    return True\n            return False\n\n        # Steer from start towards goal at maximum step_size\n        def steer(start_pt, goal_pt):\n            d = dist(start_pt, goal_pt)\n            if d <= self.step_size:\n                return goal_pt\n            ratio = self.step_size / d\n            return tuple(start_pt[d_] + ratio * (goal_pt[d_] - start_pt[d_]) for d_ in range(dim))\n\n        # Random uniform sample in bounds avoiding obstacles\n        def sample_uniform():\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not in_obstacle(pt):\n                    return pt\n\n        # Informed sampling within prolate hyperspheroid about start and goal for bidirectional searching\n        def sample_informed(c_best):\n            if c_best == float('inf'):\n                return sample_uniform()\n            c_min = dist(start, goal)\n            if c_best < c_min:\n                return sample_uniform()\n            center = tuple((start[d] + goal[d]) * 0.5 for d in range(dim))\n            a1 = [(goal[d] - start[d]) / c_min for d in range(dim)]\n            # Sample unit ball\n            while True:\n                x_ball = [random.gauss(0, 1) for _ in range(dim)]\n                norm = math.sqrt(sum(x ** 2 for x in x_ball))\n                if norm <= 1 and norm > 0:\n                    unit = [x / norm for x in x_ball]\n                    r1 = c_best / 2.0\n                    r2_temp = c_best ** 2 - c_min ** 2\n                    r2 = math.sqrt(r2_temp) / 2.0 if r2_temp > 0 else 0.0\n                    # 2D rotation matrix to align ellipse axis\n                    if dim == 2:\n                        angle = math.atan2(a1[1], a1[0])\n                        cos_ang = math.cos(angle)\n                        sin_ang = math.sin(angle)\n                        x_ell = r1 * unit[0]\n                        y_ell = r2 * unit[1]\n                        px = center[0] + cos_ang * x_ell - sin_ang * y_ell\n                        py = center[1] + sin_ang * x_ell + cos_ang * y_ell\n                        pt = (px, py)\n                    else:\n                        # 3D approximation: scale x by r1, y,z by r2 and clamp\n                        pt_candidate = [center[d] + (r1 * unit[0] if d == 0 else r2 * unit[d]) for d in range(dim)]\n                        pt = tuple(max(0, min(pt_candidate[d], bounds[d])) for d in range(dim))\n                    if all(0 <= pt[d] <= bounds[d] for d in range(dim)) and not in_obstacle(pt):\n                        return pt\n\n        # Node priority queue helper by f = cost + heuristic\n        class PQ:\n            def __init__(self):\n                self.heap = []\n                self.entry_finder = {}\n                self.REMOVED = '<removed>'\n\n            def add_node(self, node, priority):\n                if node.id in self.entry_finder:\n                    self.remove_node(node)\n                entry = [priority, node.id, node]\n                self.entry_finder[node.id] = entry\n                heapq.heappush(self.heap, entry)\n\n            def remove_node(self, node):\n                entry = self.entry_finder.pop(node.id)\n                entry[-1] = self.REMOVED\n\n            def pop_node(self):\n                while self.heap:\n                    priority, node_id, node = heapq.heappop(self.heap)\n                    if node is not self.REMOVED:\n                        del self.entry_finder[node_id]\n                        return node\n                return None\n\n            def empty(self):\n                return not self.entry_finder\n\n        # Find nearest neighbor by Euclidean distance\n        def nearest(tree_nodes, point):\n            best_node = None\n            best_dist = float('inf')\n            for node in tree_nodes:\n                d = dist(node.position, point)\n                if d < best_dist:\n                    best_dist = d\n                    best_node = node\n            return best_node, best_dist\n\n        # Find neighbors within radius\n        def neighbors(tree_nodes, node, radius):\n            result = []\n            for n in tree_nodes:\n                if dist(n.position, node.position) <= radius:\n                    result.append(n)\n            return result\n\n        # Shortcut path by removing unnecessary nodes with collision check\n        def shortcut_path(path):\n            if len(path) <= 2:\n                return path\n            shortened = [path[0]]\n            idx = 0\n            while idx < len(path) - 1:\n                next_idx = len(path) - 1\n                for j in range(len(path) - 1, idx, -1):\n                    if not edge_in_obstacle(path[idx], path[j]):\n                        next_idx = j\n                        break\n                shortened.append(path[next_idx])\n                idx = next_idx\n            return shortened\n\n        # Lazy connection: check edge collision only on candidate edges after cost improvement\n        def lazy_edge_check(p1, p2):\n            return not edge_in_obstacle(p1, p2)\n\n        # Add new node to tree with rewiring in adaptive radius\n        def add_node_with_rewire(tree_nodes, tree_pq, new_pos, best_cost, neighbor_radius):\n            near_node, dist_to_near = nearest(tree_nodes, new_pos)\n            if in_obstacle(new_pos) or edge_in_obstacle(near_node.position, new_pos):\n                return None\n\n            new_cost = near_node.cost + dist(near_node.position, new_pos)\n            new_node = Node(new_pos, parent=near_node, cost=new_cost)\n            near_node.add_child(new_node)\n            tree_nodes.append(new_node)\n            tree_pq.add_node(new_node, new_node.cost + heuristic(new_node.position))\n\n            # Find neighbors within adaptive radius for rewiring\n            nbrs = neighbors(tree_nodes, new_node, neighbor_radius)\n            for nbr in nbrs:\n                if nbr is new_node.parent:\n                    continue\n                # Cost through new_node\n                cost_through_new = new_node.cost + dist(new_node.position, nbr.position)\n                if cost_through_new + 1e-6 < nbr.cost:\n                    # Lazy check edge collision\n                    if lazy_edge_check(new_node.position, nbr.position):\n                        # Rewire nbr to new_node\n                        if nbr.parent:\n                            nbr.parent.remove_child(nbr)\n                        nbr.parent = new_node\n                        new_node.children.append(nbr)\n                        old_cost = nbr.cost\n                        nbr.cost = cost_through_new\n\n                        # Update costs downstream\n                        def dfs_update_costs(n):\n                            for c in n.children:\n                                new_c_cost = n.cost + dist(n.position, c.position)\n                                if new_c_cost + 1e-8 < c.cost:\n                                    c.cost = new_c_cost\n                                    dfs_update_costs(c)\n                        dfs_update_costs(nbr)\n                        tree_pq.add_node(nbr, nbr.cost + heuristic(nbr.position))\n            return new_node\n\n        # Attempt connecting tree_b to new_node_a with lazy collision checking\n        def try_connect(tree_nodes_b, tree_pq_b, node_a, best_cost):\n            near_node_b, dist_nb = nearest(tree_nodes_b, node_a.position)\n            if in_obstacle(node_a.position) or edge_in_obstacle(near_node_b.position, node_a.position):\n                return None\n            cost_b = near_node_b.cost + dist(near_node_b.position, node_a.position)\n            new_node_b = Node(node_a.position, parent=near_node_b, cost=cost_b)\n            near_node_b.add_child(new_node_b)\n            tree_nodes_b.append(new_node_b)\n            tree_pq_b.add_node(new_node_b, new_node_b.cost + heuristic(new_node_b.position))\n            return new_node_b\n\n        start_node = Node(start, cost=0.0)\n        goal_node = Node(goal, cost=0.0)\n        start_tree = [start_node]\n        goal_tree = [goal_node]\n\n        start_pq = PQ()\n        start_pq.add_node(start_node, heuristic(start))\n        goal_pq = PQ()\n        goal_pq.add_node(goal_node, heuristic(goal))\n\n        best_cost = float('inf')\n        best_path = None\n\n        # Adaptive neighbor radius decreases over iterations (but never below minimum 5)\n        def adaptive_radius(iteration):\n            r = self.initial_neighbor_radius * (0.95 ** (iteration // 500))\n            return max(5.0, r)\n\n        for i in range(self.max_iter):\n            # Alternate expansion trees\n            if i % 2 == 0:\n                tree_nodes_a, pq_a = start_tree, start_pq\n                tree_nodes_b, pq_b = goal_tree, goal_pq\n                tree_dir = \"start\"\n            else:\n                tree_nodes_a, pq_a = goal_tree, goal_pq\n                tree_nodes_b, pq_b = start_tree, start_pq\n                tree_dir = \"goal\"\n\n            neighbor_r = adaptive_radius(i)\n\n            # Sampling guided by best cost found\n            curr_best_cost = best_cost if best_cost != float('inf') else float('inf')\n            if random.random() < self.goal_sample_rate and tree_dir == \"start\":\n                sample_pt = goal\n                if in_obstacle(sample_pt):\n                    sample_pt = sample_uniform()\n            elif random.random() < self.goal_sample_rate and tree_dir == \"goal\":\n                sample_pt = start\n                if in_obstacle(sample_pt):\n                    sample_pt = sample_uniform()\n            else:\n                sample_pt = sample_informed(curr_best_cost)\n\n            # Add node in tree A with rewiring\n            new_node_a = add_node_with_rewire(tree_nodes_a, pq_a, sample_pt, curr_best_cost, neighbor_r)\n            if new_node_a is None:\n                continue\n\n            # Attempt connection to other tree B\n            new_node_b = try_connect(tree_nodes_b, pq_b, new_node_a, curr_best_cost)\n            if new_node_b:\n                total_cost = new_node_a.cost + new_node_b.cost\n                if total_cost + 1e-8 < best_cost:\n                    best_cost = total_cost\n\n                    # Extract full path: path from start tree root to new_node_a + reversed path from new_node_b to root\n                    path_start = new_node_a.path_from_root() if tree_dir == \"start\" else new_node_b.path_from_root()\n                    path_goal = new_node_b.path_from_root() if tree_dir == \"start\" else new_node_a.path_from_root()\n\n                    # Remove duplicate connection point if equal\n                    if path_start[-1] == path_goal[-1]:\n                        full_path = path_start + path_goal[-2::-1]\n                    else:\n                        full_path = path_start + path_goal[::-1]\n\n                    # Shortcut path improves smoothness and shortness\n                    full_path = shortcut_path(full_path)\n                    best_path = full_path\n\n                    # Return early on first improvement (anytime)\n                    return PlannerResult(success=True, path=best_path, nodes=start_tree + goal_tree, edges=[])\n\n        # If no path found after max_iter\n        return PlannerResult(success=False, path=[], nodes=start_tree + goal_tree, edges=[])",
          "objective": -32.75208,
          "time_improvement": 72.0,
          "length_improvement": 1.0,
          "smoothness_improvement": 2162.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.017874813079833983,
                    "num_nodes_avg": 60.2,
                    "path_length_avg": 178.46134122599636,
                    "smoothness_avg": 0.10095412748742794,
                    "success_improvement": 0.0,
                    "time_improvement": 31.912783585485005,
                    "length_improvement": 2.1825109731139785,
                    "smoothness_improvement": 1480.1513205749102,
                    "objective_score": 18.28409826238844
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.00749971866607666,
                    "num_nodes_avg": 54.1,
                    "path_length_avg": 269.8000195347711,
                    "smoothness_avg": 0.1332598514245687,
                    "success_improvement": 0.0,
                    "time_improvement": 95.45857019623979,
                    "length_improvement": 9.932987716315523,
                    "smoothness_improvement": 3328.871960345464,
                    "objective_score": 51.24172349038857
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.006196403503417968,
                    "num_nodes_avg": 55.0,
                    "path_length_avg": 165.53671627025966,
                    "smoothness_avg": 0.1398135054188176,
                    "success_improvement": 0.0,
                    "time_improvement": 87.67760827182315,
                    "length_improvement": -9.941604935344571,
                    "smoothness_improvement": 1678.417468967884,
                    "objective_score": 28.730406865179617
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "initial",
          "algorithm_description": "This algorithm grows two trees simultaneously, one from the start position and one from the goal position, and attempts to connect them to find a feasible path. This bidirectional approach accelerates convergence and increases the success rate compared to a single tree RRT.",
          "planning_mechanism": "The planning mechanism involves randomly sampling points within the map bounds, extending each tree towards the sampled points, and attempting to connect the two trees whenever new nodes are added. Collision checks are performed for nodes and edges to ensure safety, and once the two trees connect, the final path is reconstructed by backtracking through the parent nodes of each tree.",
          "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map) -> PlannerResult:\n        import math, random\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position)\n        goal_root = Node(goal_position)\n        nodes.extend([start_root, goal_root])\n        tree_a, tree_b = [start_root], [goal_root]\n\n        for _ in range(self.max_iter):\n            rand_point = self._sample_free(bounds, obstacles, is_3d)\n            new_a = self._extend_tree(tree_a, rand_point, obstacles, is_3d, nodes, edges)\n            if new_a is None:\n                continue\n\n            new_b = self._connect_trees(tree_b, new_a, obstacles, is_3d, nodes, edges)\n            if new_b:\n                success_state = True\n                path_a = new_a.path_from_root()\n                path_b = new_b.path_from_root()\n                extracted_path = path_a + path_b[::-1]\n                break\n\n            tree_a, tree_b = tree_b, tree_a  # Swap trees\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        import random\n        while True:\n            if is_3d:\n                p = (random.uniform(0, bounds[0]),\n                     random.uniform(0, bounds[1]),\n                     random.uniform(0, bounds[2]))\n            else:\n                p = (random.uniform(0, bounds[0]),\n                     random.uniform(0, bounds[1]))\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    def _nearest(self, tree, point):\n        import math\n        return min(tree, key=lambda node: math.dist(node.position, point))\n\n    def _steer(self, from_pos, to_pos):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _extend_tree(self, tree, point, obstacles, is_3d, nodes, edges):\n        nearest_node = self._nearest(tree, point)\n        new_pos = self._steer(nearest_node.position, point)\n        if not self._is_in_obstacle(new_pos, obstacles, is_3d) and not self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n            new_node = Node(new_pos, parent=nearest_node)\n            nearest_node.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n            return new_node\n        return None\n\n    def _connect_trees(self, tree, new_node, obstacles, is_3d, nodes, edges):\n        import math\n        nearest_node = self._nearest(tree, new_node.position)\n        while True:\n            new_pos = self._steer(nearest_node.position, new_node.position)\n            if (not self._is_in_obstacle(new_pos, obstacles, is_3d) and\n                not self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d)):\n                next_node = Node(new_pos, parent=nearest_node)\n                nearest_node.add_child(next_node)\n                tree.append(next_node)\n                nodes.append(next_node)\n                edges.append((nearest_node, next_node))\n\n                if math.dist(next_node.position, new_node.position) <= self.step_size:\n                    if not self._is_edge_in_obstacle(next_node.position, new_node.position, obstacles, is_3d):\n                        final_node = Node(new_node.position, parent=next_node)\n                        next_node.add_child(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((next_node, final_node))\n                        return final_node\n                    else:\n                        return None\n                nearest_node = next_node\n            else:\n                return None\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n",
          "objective": -28.87615591314666,
          "time_improvement": 93.0,
          "length_improvement": 1.0,
          "smoothness_improvement": 69.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.0022002458572387695,
                    "num_nodes_avg": 57.5,
                    "path_length_avg": 171.4810676267031,
                    "smoothness_avg": 0.011144018674089623,
                    "success_improvement": 0.0,
                    "time_improvement": 91.61901077354663,
                    "length_improvement": 6.008509542400028,
                    "smoothness_improvement": 74.42809187338179,
                    "objective_score": 31.462949416870917
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.009090876579284668,
                    "num_nodes_avg": 226.2,
                    "path_length_avg": 305.50514541182173,
                    "smoothness_avg": 0.00636488258654892,
                    "success_improvement": 0.0,
                    "time_improvement": 94.49504979083876,
                    "length_improvement": -1.986411016509145,
                    "smoothness_improvement": 63.77301339152637,
                    "objective_score": 27.475533394303774
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.004314684867858886,
                    "num_nodes_avg": 127.6,
                    "path_length_avg": 150.78647946614691,
                    "smoothness_avg": 0.013383825302451875,
                    "success_improvement": 0.0,
                    "time_improvement": 91.41966188998718,
                    "length_improvement": -0.14519998085115468,
                    "smoothness_improvement": 70.24126995596559,
                    "objective_score": 27.68998492826529
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "An improved bidirectional sampling-based planner combining informed heuristic sampling with adaptive rewiring and lazy collision checking to enhance planning speed, path quality, and smoothness. The planner alternates forward and backward tree expansions, samples inside an informed ellipsoid for efficient search, applies rewiring with adaptive radius to optimize connectivity, and performs path shortcutting to smooth the final solution.",
          "planning_mechanism": "The planner grows two trees from start and goal, uses adaptive informed sampling focused on the current best solution corridor to accelerate convergence, rewires local connections based on adaptive neighborhoods to improve path cost, delays expensive collision checks (lazy evaluation) until necessary to reduce redundant computations, attempts direct tree connections to find feasible paths quickly, and post-processes the resulting path via shortcutting for smoothness and length reduction.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n    def add_child(self, child):\n        self.children.append(child)\nclass Planner:\n    def __init__(self, max_iter=4000, step_size=6.0, base_rewire_radius=12.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.base_rewire_radius = base_rewire_radius\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        edges = []\n        best_cost = float('inf')\n        best_path = []\n\n        def dist(a,b):\n            return math.dist(a,b)\n\n        def in_collision(p):\n            for o in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d = o\n                    px,py,pz = p\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                        return True\n                else:\n                    x,y,w,h = o\n                    px,py = p\n                    if x <= px <= x+w and y <= py <= y+h:\n                        return True\n            return False\n\n        def edge_collision(p1,p2,res=1.0):\n            distance = dist(p1,p2)\n            steps = max(1,int(distance/res))\n            for i in range(steps+1):\n                interp = tuple(p1[d]+(p2[d]-p1[d])*i/steps for d in range(dim))\n                if in_collision(interp):\n                    return True\n            return False\n\n        def steer(from_p,to_p,step):\n            distance = dist(from_p,to_p)\n            if distance <= step:\n                return to_p\n            ratio = step / distance\n            return tuple(from_p[i] + (to_p[i]-from_p[i])*ratio for i in range(dim))\n\n        def nearest(tree, p):\n            return min(tree, key=lambda n: dist(n.position, p))\n\n        def near(tree, p, radius):\n            r2 = radius**2\n            result = []\n            for n in tree:\n                d2 = sum((n.position[i]-p[i])**2 for i in range(dim))\n                if d2 <= r2:\n                    result.append(n)\n            return result\n\n        def extract_path(n_start, n_goal):\n            path_start, path_goal = [], []\n            while n_start:\n                path_start.append(n_start.position)\n                n_start = n_start.parent\n            while n_goal:\n                path_goal.append(n_goal.position)\n                n_goal = n_goal.parent\n            path_start.reverse()\n            return path_start + path_goal\n\n        def shortcut(path):\n            if len(path) <= 2:\n                return path\n            i = 0\n            while i < len(path)-2:\n                j = len(path)-1\n                while j > i+1:\n                    if not edge_collision(path[i], path[j]):\n                        path = path[:i+1] + path[j:]\n                        break\n                    j -= 1\n                i += 1\n            return path\n\n        def informed_sample(c_best):\n            if c_best == float('inf'):\n                while True:\n                    sample = tuple(random.uniform(0,bounds[i]) for i in range(dim))\n                    if not in_collision(sample):\n                        return sample\n            c_min = dist(start_pos, goal_pos)\n            if c_min == 0.0:\n                return goal_pos\n            center = tuple((start_pos[i]+goal_pos[i])*0.5 for i in range(dim))\n            a1 = [(goal_pos[i]-start_pos[i])/c_min for i in range(dim)]\n\n            # rotation matrix R that aligns x-axis with a1 (2D/3D only)\n            def mat_vec_mult(mat, vec):\n                return tuple(sum(mat[i][j]*vec[j] for j in range(dim)) for i in range(dim))\n\n            if dim == 2:\n                theta = math.acos(max(min(a1[0],1.0),-1.0))\n                if a1[1]<0:\n                    theta = -theta\n                R = [[math.cos(theta), -math.sin(theta)],\n                     [math.sin(theta), math.cos(theta)]]\n            elif dim == 3:\n                x = a1\n                I = [[1 if i==j else 0 for j in range(3)] for i in range(3)]\n                v = [x[0]-1, x[1], x[2]]\n                norm_v = math.sqrt(sum(vi*vi for vi in v))\n                if norm_v < 1e-10:\n                    R = I\n                else:\n                    v = [vi/norm_v for vi in v]\n                    R = [[I[i][j]-2*v[i]*v[j] for j in range(3)] for i in range(3)]\n            else:\n                R = [[1 if i==j else 0 for j in range(dim)] for i in range(dim)]\n\n            L1 = c_best/2.0\n            L2 = math.sqrt(max(c_best*c_best - c_min*c_min,0))/2.0\n\n            while True:\n                while True:\n                    sample = [random.uniform(-1,1) for _ in range(dim)]\n                    norm_s = math.sqrt(sum(x*x for x in sample))\n                    if norm_s > 0 and norm_s <= 1:\n                        break\n                unit_s = [x/norm_s for x in sample]\n                r = random.uniform(0,1)**(1/dim)\n                unit_ball = [r * us for us in unit_s]\n                ellip = [L1*unit_ball[0]] + [L2*unit_ball[i] for i in range(1,dim)]\n                rotated = mat_vec_mult(R, ellip)\n                point = tuple(center[i] + rotated[i] for i in range(dim))\n                if all(0 <= point[i] <= bounds[i] for i in range(dim)) and not in_collision(point):\n                    return point\n\n        # adaptive rewire radius decreases as tree grows (based on RRT* formula)\n        def rewire_radius(num_nodes):\n            gamma_rrt = 2 * (1 + 1/dim)**(1/dim) * (math.prod(bounds)**(1/dim))\n            radius = min(self.base_rewire_radius, gamma_rrt * (math.log(num_nodes+1)/(num_nodes+1))**(1/dim))\n            return radius\n\n        def rewire(tree, new_node):\n            r = rewire_radius(len(tree))\n            nbs = near(tree, new_node.position, r)\n            for nb in nbs:\n                if nb == new_node.parent:\n                    continue\n                if edge_collision(new_node.position, nb.position):\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, nb.position)\n                if new_cost + 1e-9 < nb.cost:\n                    if nb.parent:\n                        try:\n                            nb.parent.children.remove(nb)\n                        except Exception:\n                            pass\n                    nb.parent = new_node\n                    nb.cost = new_cost\n                    new_node.add_child(nb)\n\n        for it in range(self.max_iter):\n            sample = informed_sample(best_cost)\n            for tree_a, tree_b in [(start_tree, goal_tree),(goal_tree, start_tree)]:\n                nearest_node = nearest(tree_a, sample)\n                new_pos = steer(nearest_node.position, sample, self.step_size)\n                if in_collision(new_pos):\n                    continue\n                if edge_collision(nearest_node.position, new_pos):\n                    continue\n                new_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n                new_node = Node(new_pos, parent=nearest_node, cost=new_cost)\n                nearest_node.add_child(new_node)\n                tree_a.append(new_node)\n                edges.append((nearest_node,new_node))\n                rewire(tree_a, new_node)\n\n                connect_node = nearest(tree_b, new_pos)\n                gap = dist(new_pos, connect_node.position)\n                if gap <= self.step_size*1.8 and not edge_collision(new_pos, connect_node.position):\n                    connect_new = Node(connect_node.position, parent=new_node, cost=new_node.cost+gap)\n                    new_node.add_child(connect_new)\n                    tree_b.append(connect_new)\n                    edges.append((new_node, connect_new))\n                    path = extract_path(connect_new, connect_node)\n                    path = shortcut(path)\n                    cost_path = 0.0\n                    for i in range(len(path)-1):\n                        cost_path += dist(path[i], path[i+1])\n                    if cost_path < best_cost:\n                        best_cost = cost_path\n                        best_path = path\n            if best_path:\n                return PlannerResult(True,best_path,start_tree+goal_tree,edges)\n        return PlannerResult(False,[],start_tree+goal_tree,edges)",
          "objective": -28.64627,
          "time_improvement": 37.0,
          "length_improvement": 14.0,
          "smoothness_improvement": 1851.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.027629590034484862,
                    "num_nodes_avg": 116.4,
                    "path_length_avg": 170.26662958714778,
                    "smoothness_avg": 0.06141652618419348,
                    "success_improvement": 0.0,
                    "time_improvement": -5.244282428030285,
                    "length_improvement": 6.674162275882516,
                    "smoothness_improvement": 861.3020029038676,
                    "objective_score": 6.737722651639762
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.031986331939697264,
                    "num_nodes_avg": 221.9,
                    "path_length_avg": 238.03820887872735,
                    "smoothness_avg": 0.12286205335960987,
                    "success_improvement": 0.0,
                    "time_improvement": 80.63078261308962,
                    "length_improvement": 20.535994326332737,
                    "smoothness_improvement": 3061.329126902844,
                    "objective_score": 51.817477014240744
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.032309651374816895,
                    "num_nodes_avg": 180.3,
                    "path_length_avg": 129.22310027085973,
                    "smoothness_avg": 0.13606286458102096,
                    "success_improvement": 0.0,
                    "time_improvement": 35.74786073539117,
                    "length_improvement": 14.176169742883147,
                    "smoothness_improvement": 1630.7095943546199,
                    "objective_score": 27.383608038120336
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m2",
          "algorithm_description": "A bidirectional RRT* variant that uses informed sampling within an ellipsoidal region (informed RRT*) to bias samples towards the subset of the state space likely to improve the current solution, combined with rewiring for asymptotic optimality. It incorporates direct connection attempts between trees and post-processing shortcutting for smoother, shorter paths.",
          "planning_mechanism": "The planner grows two trees from start and goal alternately, sampling randomly inside an ellipsoid defined by start, goal, and the current best path cost to focus growth in promising areas. Each new node is connected and rewired locally to improve path cost. The trees attempt direct connection when close, and after finding a solution, the planner shortcut-postprocesses the path to enhance smoothness and reduce length.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\nclass Planner:\n    def __init__(self, max_iter=3000, step_size=7.5, rewire_radius=15.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.rewire_radius = rewire_radius\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        edges = []\n        best_cost = float('inf')\n        best_path = []\n\n        def distance(a,b):\n            return math.dist(a,b)\n\n        def is_in_collision(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d = obs\n                    px,py,pz = pos\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                        return True\n                else:\n                    x,y,w,h = obs\n                    px,py = pos\n                    if x <= px <= x+w and y <= py <= y+h:\n                        return True\n            return False\n\n        def is_edge_collision(from_pos, to_pos, resolution=1.0):\n            dist = distance(from_pos, to_pos)\n            steps = max(1,int(dist / resolution))\n            for i in range(steps+1):\n                interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * i/steps for d in range(len(from_pos)))\n                if is_in_collision(interp):\n                    return True\n            return False\n\n        def steer(from_pos, to_pos, max_step):\n            dist = distance(from_pos, to_pos)\n            if dist <= max_step:\n                return to_pos\n            ratio = max_step / dist\n            return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: distance(node.position, point))\n\n        def neighbors(tree, point, radius):\n            result = []\n            r_sq = radius*radius\n            for node in tree:\n                dx = node.position[0] - point[0]\n                dy = node.position[1] - point[1]\n                dz = node.position[2] - point[2] if is_3d else 0.0\n                dist_sq = dx*dx + dy*dy + dz*dz\n                if dist_sq <= r_sq:\n                    result.append(node)\n            return result\n\n        def extract_path(node_start, node_goal):\n            path_start = []\n            while node_start:\n                path_start.append(node_start.position)\n                node_start = node_start.parent\n            path_start.reverse()\n            path_goal = []\n            while node_goal:\n                path_goal.append(node_goal.position)\n                node_goal = node_goal.parent\n            return path_start + path_goal\n\n        def try_connect(node_from, tree_to):\n            near = nearest(tree_to, node_from.position)\n            if is_edge_collision(node_from.position, near.position):\n                return None\n            # direct connection possible, make new node\n            new_node = Node(near.position, parent=node_from, cost=node_from.cost + distance(node_from.position, near.position))\n            node_from.add_child(new_node)\n            tree_to.append(new_node)\n            edges.append((node_from,new_node))\n            return new_node\n\n        def rewire(tree, new_node):\n            nbs = neighbors(tree, new_node.position, self.rewire_radius)\n            for nb in nbs:\n                if nb == new_node.parent:\n                    continue\n                if is_edge_collision(new_node.position, nb.position):\n                    continue\n                new_cost = new_node.cost + distance(new_node.position, nb.position)\n                if new_cost + 1e-7 < nb.cost:\n                    # Rewire nb's parent link\n                    if nb.parent:\n                        try:\n                            nb.parent.children.remove(nb)\n                        except ValueError:\n                            pass\n                    nb.parent = new_node\n                    nb.cost = new_cost\n                    new_node.add_child(nb)\n\n        def informed_sample(c_best):\n            # Sample uniformly inside ellipsoid defined by start, goal, c_best\n            if c_best == float('inf'):\n                # No solution found yet, uniform sample in bounds\n                while True:\n                    sample = tuple(random.uniform(0, bounds[i]) for i in range(len(bounds)))\n                    if not is_in_collision(sample):\n                        return sample\n            else:\n                c_min = distance(start_pos, goal_pos)\n                if c_min == 0.0:\n                    return goal_pos\n                # Ellipsoid parameters\n                center = tuple((start_pos[i]+goal_pos[i])/2 for i in range(len(bounds)))\n                a1 = [(goal_pos[i]-start_pos[i])/c_min for i in range(len(bounds))]\n                # Build rotation matrix to transform unit ball samples\n                # For 2D or 3D the rotation matrix is based on a1 vector\n                # Using Householder transform for rotation to align x-axis with a1\n                dim = len(bounds)\n                def mat_vec_mult(mat, vec):\n                    return tuple(sum(mat[i][j]*vec[j] for j in range(dim)) for i in range(dim))\n                # Construct orthonormal basis with a1 as first basis vector\n                # For 2D and 3D:\n                if dim == 2:\n                    # rotation angle\n                    theta = math.acos(a1[0])\n                    if a1[1]<0:\n                        theta = -theta\n                    # rotation matrix\n                    R = [[math.cos(theta), -math.sin(theta)],\n                         [math.sin(theta), math.cos(theta)]]\n                elif dim ==3:\n                    # Construct a rotation matrix using Householder reflection\n                    # vector to rotate to x = a1\n                    x = a1\n                    I = [[1 if i==j else 0 for j in range(3)] for i in range(3)]\n                    v = [x[0]-1, x[1], x[2]]\n                    norm_v = math.sqrt(sum(vi*vi for vi in v))\n                    if norm_v < 1e-10:\n                        R = I\n                    else:\n                        v = [vi/norm_v for vi in v]\n                        R = [[I[i][j] - 2*v[i]*v[j] for j in range(3)] for i in range(3)]\n                else:\n                    R = [[1 if i==j else 0 for j in range(dim)] for i in range(dim)]\n\n                # lengths of ellipsoid axes\n                L1 = c_best/2.0\n                L_other = math.sqrt(c_best*c_best - c_min*c_min)/2.0\n\n                while True:\n                    # sample random unit vector in unit ball\n                    while True:\n                        sample = [random.uniform(-1,1) for _ in range(dim)]\n                        norm_sample = math.sqrt(sum(x*x for x in sample))\n                        if 0 < norm_sample <= 1:\n                            break\n                    unit_s = [x/norm_sample for x in sample]\n                    r = random.uniform(0,1)**(1/dim)  # radius for uniform ball sampling\n                    unit_ball_sample = [r*us for us in unit_s]\n\n                    # scale by axes\n                    ellipsoid_sample = [L1*unit_ball_sample[0]] + [L_other*unit_ball_sample[i] for i in range(1,dim)]\n\n                    # rotate and translate\n                    if dim == 2 or dim == 3:\n                        rotated = mat_vec_mult(R, ellipsoid_sample)\n                    else:\n                        rotated = ellipsoid_sample\n                    point = tuple(center[i] + rotated[i] for i in range(dim))\n                    if all(0 <= point[i] <= bounds[i] for i in range(dim)):\n                        if not is_in_collision(point):\n                            return point\n\n        def shortcut_path(path):\n            if len(path)<=2:\n                return path\n            i = 0\n            while i < len(path)-2:\n                j = len(path)-1\n                while j > i+1:\n                    if not is_edge_collision(path[i], path[j]):\n                        # shortcut between i and j\n                        path = path[:i+1] + path[j:]\n                        break\n                    j -=1\n                i +=1\n            return path\n\n        for it in range(self.max_iter):\n            sample = informed_sample(best_cost)\n            for tree_a, tree_b in [(start_tree, goal_tree),(goal_tree, start_tree)]:\n                near = nearest(tree_a, sample)\n                new_pos = steer(near.position, sample, self.step_size)\n                if is_in_collision(new_pos):\n                    continue\n                if is_edge_collision(near.position, new_pos):\n                    continue\n                new_cost = near.cost + distance(near.position, new_pos)\n                new_node = Node(new_pos, parent=near, cost=new_cost)\n                near.add_child(new_node)\n                tree_a.append(new_node)\n                edges.append((near,new_node))\n\n                rewire(tree_a, new_node)\n\n                near_to_new = nearest(tree_b, new_pos)\n                dist_trees = distance(new_pos, near_to_new.position)\n                if dist_trees <= self.step_size*2 and not is_edge_collision(new_pos, near_to_new.position):\n                    connect_node = Node(near_to_new.position, parent=new_node, cost=new_node.cost + dist_trees)\n                    new_node.add_child(connect_node)\n                    tree_b.append(connect_node)\n                    edges.append((new_node, connect_node))\n                    path = extract_path(connect_node, connect_node)\n                    # extract_path from new_node to nearest node in other tree\n                    path = extract_path(new_node, near_to_new)\n                    path = shortcut_path(path)\n                    cost_path = 0.0\n                    for k in range(len(path)-1):\n                        cost_path += distance(path[k], path[k+1])\n                    if cost_path < best_cost:\n                        best_cost = cost_path\n                        best_path = path\n            if best_path:\n                return PlannerResult(True, best_path, start_tree+goal_tree, edges)\n        return PlannerResult(False, [], start_tree+goal_tree, edges)",
          "objective": -24.54042,
          "time_improvement": 22.0,
          "length_improvement": 15.0,
          "smoothness_improvement": 1806.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.019874000549316408,
                    "num_nodes_avg": 86.7,
                    "path_length_avg": 165.53372291805212,
                    "smoothness_avg": 0.05590834490258338,
                    "success_improvement": 0.0,
                    "time_improvement": 24.29764885485091,
                    "length_improvement": 9.26834341891934,
                    "smoothness_improvement": 775.0870046395709,
                    "objective_score": 16.725735731004733
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.017957305908203124,
                    "num_nodes_avg": 144.4,
                    "path_length_avg": 240.5533294992943,
                    "smoothness_avg": 0.12055312154964279,
                    "success_improvement": 0.0,
                    "time_improvement": 89.12601287090475,
                    "length_improvement": 19.696374669454404,
                    "smoothness_improvement": 3001.9186483760295,
                    "objective_score": 53.56522190482421
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.07342400550842285,
                    "num_nodes_avg": 284.9,
                    "path_length_avg": 128.16200978596154,
                    "smoothness_avg": 0.13688525836651863,
                    "success_improvement": 0.0,
                    "time_improvement": -46.01362832932536,
                    "length_improvement": 14.88089551925333,
                    "smoothness_improvement": 1641.1703826033552,
                    "objective_score": 3.3303007257711688
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "A simplified bidirectional RRT* inspired planner that alternates growing trees from start and goal by sampling collision-free points, extends toward samples with fixed step size, and rewires local neighbors to improve path cost dynamically. It attempts connecting the trees at each iteration, returning the combined path upon success. This approach balances planning efficiency, path quality, and smoothness through incremental rewiring and early collision checks.",
          "planning_mechanism": "The planner operates by sampling points within bounds avoiding obstacles, nearest neighbor extension with fixed step, rewiring neighbors within a computed radius to optimize cost, and alternating tree expansion. Once the two trees connect, their paths are concatenated to form the final solution.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=4000, step_size=5.0, gamma_rrt_star=30.0, max_radius=40.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.gamma_rrt_star = gamma_rrt_star\n        self.max_radius = max_radius\n\n    def plan(self, map):\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        for i in range(self.max_iter):\n            tree_a, tree_b = (tree_start, tree_goal) if i % 2 == 0 else (tree_goal, tree_start)\n            sample = self._sample_free(bounds, obstacles, is_3d)\n\n            new_node = self._extend_and_rewire(tree_a, sample, obstacles, is_3d, nodes, edges, bounds)\n            if new_node is None:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            connect_node = self._connect_and_rewire(tree_b, new_node, obstacles, is_3d, nodes, edges, bounds)\n            if connect_node:\n                path_a = new_node.path_from_root()\n                path_b = connect_node.path_from_root()\n                if path_a[-1] == path_b[-1]:\n                    path_b = path_b[:-1]\n                full_path = path_a + path_b[::-1]\n                return PlannerResult(True, full_path, nodes, edges)\n\n            tree_a, tree_b = tree_b, tree_a\n\n        return PlannerResult(False, [], nodes, edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        import random\n        dim = len(bounds)\n        while True:\n            pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            if not self._in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def _nearest(self, tree, point):\n        best = None\n        best_dist = float('inf')\n        for node in tree:\n            dist = self._dist(node.position, point)\n            if dist < best_dist:\n                best_dist = dist\n                best = node\n        return best\n\n    def _steer(self, from_pos, to_pos):\n        dist = self._dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(len(from_pos)))\n\n    def _near_nodes(self, tree, position, bounds):\n        n = max(1, len(tree))\n        d = len(position)\n        scale = max(1.0, sum(bounds) / d)\n        r_theory = self.gamma_rrt_star * ((math.log(n + 1) / (n + 1)) ** (1.0 / d))\n        radius = max(self.step_size * 2, min(self.max_radius, r_theory * 0.5 + scale * 0.02))\n        return [node for node in tree if self._dist(node.position, position) <= radius]\n\n    def _extend_and_rewire(self, tree, sample, obstacles, is_3d, nodes, edges, bounds):\n        nearest = self._nearest(tree, sample)\n        new_pos = self._steer(nearest.position, sample)\n        if self._in_obstacle(new_pos, obstacles, is_3d):\n            return None\n        if self._edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n            return None\n\n        neighbors = self._near_nodes(tree, new_pos, bounds)\n        min_cost = nearest.cost + self._dist(nearest.position, new_pos)\n        best_parent = nearest\n        for nb in neighbors:\n            if not self._edge_in_obstacle(nb.position, new_pos, obstacles, is_3d):\n                cost = nb.cost + self._dist(nb.position, new_pos)\n                if cost < min_cost:\n                    min_cost = cost\n                    best_parent = nb\n\n        new_node = Node(new_pos, cost=min_cost)\n        best_parent.add_child(new_node)\n        new_node.cost = min_cost\n        tree.append(new_node)\n        nodes.append(new_node)\n        edges.append((best_parent, new_node))\n\n        for nb in neighbors:\n            if nb == best_parent:\n                continue\n            if not self._edge_in_obstacle(new_node.position, nb.position, obstacles, is_3d):\n                updated_cost = new_node.cost + self._dist(new_node.position, nb.position)\n                if updated_cost < nb.cost:\n                    if nb.parent:\n                        try:\n                            edges.remove((nb.parent, nb))\n                        except ValueError:\n                            pass\n                        if nb in nb.parent.children:\n                            nb.parent.children.remove(nb)\n                    new_node.add_child(nb)\n                    nb.cost = updated_cost\n                    edges.append((new_node, nb))\n        return new_node\n\n    def _connect_and_rewire(self, tree, target_node, obstacles, is_3d, nodes, edges, bounds):\n        nearest = self._nearest(tree, target_node.position)\n        while True:\n            new_pos = self._steer(nearest.position, target_node.position)\n            if self._in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                return None\n\n            neighbors = self._near_nodes(tree, new_pos, bounds)\n            min_cost = nearest.cost + self._dist(nearest.position, new_pos)\n            best_parent = nearest\n            for nb in neighbors:\n                if not self._edge_in_obstacle(nb.position, new_pos, obstacles, is_3d):\n                    cost = nb.cost + self._dist(nb.position, new_pos)\n                    if cost < min_cost:\n                        min_cost = cost\n                        best_parent = nb\n\n            new_node = Node(new_pos, cost=min_cost)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            for nb in neighbors:\n                if nb == best_parent:\n                    continue\n                if not self._edge_in_obstacle(new_node.position, nb.position, obstacles, is_3d):\n                    updated_cost = new_node.cost + self._dist(new_node.position, nb.position)\n                    if updated_cost < nb.cost:\n                        if nb.parent:\n                            try:\n                                edges.remove((nb.parent, nb))\n                            except ValueError:\n                                pass\n                            if nb in nb.parent.children:\n                                nb.parent.children.remove(nb)\n                        new_node.add_child(nb)\n                        nb.cost = updated_cost\n                        edges.append((new_node, nb))\n\n            if self._dist(new_node.position, target_node.position) <= self.step_size:\n                if (not self._edge_in_obstacle(new_node.position, target_node.position, obstacles, is_3d)\n                   and not self._in_obstacle(target_node.position, obstacles, is_3d)):\n                    final_node = Node(target_node.position, cost=new_node.cost + self._dist(new_node.position, target_node.position))\n                    new_node.add_child(final_node)\n                    tree.append(final_node)\n                    nodes.append(final_node)\n                    edges.append((new_node, final_node))\n                    return final_node\n                else:\n                    return None\n            nearest = new_node\n\n    def _in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _edge_in_obstacle(self, p1, p2, obstacles, is_3d, resolution=1.0):\n        dist = self._dist(p1, p2)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(p1[d] + (p2[d] - p1[d]) * i / steps for d in range(len(p1)))\n            if self._in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _dist(self, a, b):\n        s = 0\n        for i in range(len(a)):\n            s += (a[i] - b[i]) ** 2\n        return s ** 0.5",
          "objective": -23.86958,
          "time_improvement": 56.0,
          "length_improvement": 11.0,
          "smoothness_improvement": 157.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.010033559799194337,
                    "num_nodes_avg": 60.9,
                    "path_length_avg": 164.20093510394682,
                    "smoothness_avg": 0.01583828018408221,
                    "success_improvement": 0.0,
                    "time_improvement": 61.78101810606081,
                    "length_improvement": 9.99886553920486,
                    "smoothness_improvement": 147.90347825679143,
                    "objective_score": 25.273142146625116
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.050237512588500975,
                    "num_nodes_avg": 241.6,
                    "path_length_avg": 264.8016597340139,
                    "smoothness_avg": 0.010300759767330584,
                    "success_improvement": 0.0,
                    "time_improvement": 69.57884060795715,
                    "length_improvement": 11.601584087618049,
                    "smoothness_improvement": 165.04596815078446,
                    "objective_score": 28.659832475711898
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.0325772762298584,
                    "num_nodes_avg": 182.9,
                    "path_length_avg": 134.71639352764254,
                    "smoothness_avg": 0.020352271921149336,
                    "success_improvement": 0.0,
                    "time_improvement": 35.21565228605458,
                    "length_improvement": 10.527785924243197,
                    "smoothness_improvement": 158.87939658857192,
                    "objective_score": 17.67576422330515
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m1",
          "algorithm_description": "An improved bidirectional RRT algorithm that grows start and goal trees by incrementally extending towards random samples, but integrates an adaptive best-near extension strategy and direct tree connection attempts to reduce unnecessary intermediate nodes, enhancing planning speed and path quality. The algorithm prunes redundant branches during connection and returns a smooth shortest path by tracing parent links without excessive intermediate nodes, while ensuring collision checks for nodes and edges.",
          "planning_mechanism": "The planner alternates expanding the start and goal trees by selecting the best node near a random sample to attempt efficient extensions. It tries to directly connect the two trees whenever possible, avoiding incremental stepwise connections that add many nodes. Upon successful connection, it constructs the path by merging the backward path of the start tree and the forward path of the goal tree, ensuring smoothness and shortness without intermediate expansions between trees.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map):\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        edges = []\n\n        for _ in range(self.max_iter):\n            rand = self._sample_free(bounds, obstacles, is_3d)\n            # Alternate growing trees: start_tree then goal_tree\n            for source_tree, target_tree in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest = self._best_near(source_tree, rand)\n                new_pos = self._steer(nearest.position, rand, self.step_size)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                    continue\n                new_node = Node(new_pos, parent=nearest, cost=nearest.cost + self._distance(nearest.position, new_pos))\n                nearest.add_child(new_node)\n                source_tree.append(new_node)\n                edges.append((nearest, new_node))\n\n                # Try direct connection to closest node in target_tree\n                connect_node = self._nearest(target_tree, new_pos)\n                if self._direct_connect(new_node, connect_node, obstacles, is_3d):\n                    # Link both trees at connection without intermediate nodes\n                    new_node_connect = Node(connect_node.position, parent=new_node, cost=new_node.cost + self._distance(new_node.position, connect_node.position))\n                    new_node.add_child(new_node_connect)\n                    source_tree.append(new_node_connect)\n                    edges.append((new_node, new_node_connect))\n\n                    path = self._build_path(new_node_connect, connect_node)\n                    return PlannerResult(True, path, start_tree + goal_tree, edges)\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        while True:\n            point = tuple((random.uniform(0, bounds[i]) for i in range(len(bounds))))\n            if not self._is_in_obstacle(point, obstacles, is_3d):\n                return point\n\n    def _best_near(self, tree, sample):\n        # Select node near sample that yields minimal cost-to-come plus distance to sample\n        candidates = [node for node in tree\n                      if self._distance(node.position, sample) <= self.step_size * 3]\n        if not candidates:\n            return self._nearest(tree, sample)\n        best_node = min(candidates, key=lambda n: n.cost + self._distance(n.position, sample))\n        return best_node\n\n    def _nearest(self, tree, point):\n        return min(tree, key=lambda node: self._distance(node.position, point))\n\n    def _steer(self, from_pos, to_pos, max_step):\n        dist = self._distance(from_pos, to_pos)\n        if dist <= max_step:\n            return to_pos\n        ratio = max_step / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _direct_connect(self, node_a, node_b, obstacles, is_3d):\n        # Try direct edge-connect (no incremental steps)\n        if node_a.position == node_b.position:\n            return True\n        if self._is_edge_in_obstacle(node_a.position, node_b.position, obstacles, is_3d):\n            return False\n        return True\n\n    def _build_path(self, connect_node_starttree, connect_node_goaltree):\n        # Extract path: from start root to connect_node_starttree\n        path_start = []\n        node = connect_node_starttree\n        while node:\n            path_start.append(node.position)\n            node = node.parent\n        path_start.reverse()\n        # From connect_node_goaltree to root of goal tree (goal)\n        path_goal = []\n        node = connect_node_goaltree\n        while node:\n            path_goal.append(node.position)\n            node = node.parent\n        # Concatenate without duplicating connection point\n        if path_goal and path_start and path_goal[0] == path_start[-1]:\n            path_goal = path_goal[1:]\n        return path_start + path_goal\n\n    def _distance(self, a, b):\n        return math.dist(a, b)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        dist = self._distance(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -23.20822,
          "time_improvement": 70.0,
          "length_improvement": 3.0,
          "smoothness_improvement": 94.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.01148538589477539,
                    "num_nodes_avg": 114.7,
                    "path_length_avg": 178.88287649808652,
                    "smoothness_avg": 0.011710944030027473,
                    "success_improvement": 0.0,
                    "time_improvement": 56.2508457274982,
                    "length_improvement": 1.951460810827528,
                    "smoothness_improvement": 83.30170479192397,
                    "objective_score": 18.4626387287056
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.024952244758605958,
                    "num_nodes_avg": 287.1,
                    "path_length_avg": 284.2732101707537,
                    "smoothness_avg": 0.007407994819409248,
                    "success_improvement": 0.0,
                    "time_improvement": 84.89025081300372,
                    "length_improvement": 5.101420094330395,
                    "smoothness_improvement": 90.61304246639523,
                    "objective_score": 28.980992512831325
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.016226673126220705,
                    "num_nodes_avg": 197.2,
                    "path_length_avg": 147.25047497131663,
                    "smoothness_avg": 0.01634842816831971,
                    "success_improvement": 0.0,
                    "time_improvement": 67.73105195682024,
                    "length_improvement": 2.20324583817514,
                    "smoothness_improvement": 107.95079958558324,
                    "objective_score": 22.18101708787907
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e2",
          "algorithm_description": "A hybrid bidirectional RRT* planner integrating goal bias sampling, adaptive step sizes, efficient nearest neighbor search via incremental radius, and localized rewiring for path improvement and smoothing. The planner grows two trees from start and goal, extends them towards randomly sampled points (biased towards goal regions), and attempts connection. It dynamically updates node costs and performs local rewiring to optimize paths progressively, improving success rate, path length, and smoothness while maintaining computational efficiency.",
          "planning_mechanism": "A bidirectional RRT*-inspired planner alternates tree expansion using goal-biased sampling and adaptive step sizes; extends nodes using steering methods with collision checking; after adding nodes performs local rewiring within a radius to optimize paths; attempts connection between two trees each iteration; once connected, reconstructs the final minimized-cost path, returning it with consistent nodes and edges.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.children = []\n        self.cost = cost\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=4000, step_size=5.0, goal_sample_rate=0.15, rewire_radius=15.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.rewire_radius = rewire_radius\n\n    def plan(self, map):\n        bounds = map.size\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start)]\n        goal_tree = [Node(goal)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        for i in range(self.max_iter):\n            expanding_tree, other_tree = (start_tree, goal_tree) if i % 2 == 0 else (goal_tree, start_tree)\n            sample = self._sample_free(bounds, obstacles, is_3d, goal, self.goal_sample_rate)\n            new_node = self._extend(expanding_tree, sample, obstacles, is_3d, nodes, edges)\n            if new_node is not None:\n                self._rewire(new_node, expanding_tree, obstacles, is_3d, nodes, edges)\n                connected_node = self._connect(other_tree, new_node, obstacles, is_3d, nodes, edges)\n                if connected_node is not None:\n                    path_start = new_node.path_from_root()\n                    path_goal = connected_node.path_from_root()\n                    # Connect and optimize final path\n                    if path_start[-1] == path_goal[-1]:\n                        full_path = path_start + path_goal[-2::-1]\n                    else:\n                        full_path = path_start + path_goal[::-1]\n                    optimized_path = self._shortcut_path(full_path, obstacles, is_3d)\n                    return PlannerResult(True, optimized_path, nodes, edges)\n\n        return PlannerResult(False, [], nodes, edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d, goal, goal_sample_rate):\n        import random\n        from math import sqrt\n        if random.random() < goal_sample_rate:\n            return goal\n        while True:\n            pt = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n            if not self._in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def _nearest(self, tree, point):\n        min_dist = float('inf')\n        nearest_node = None\n        for node in tree:\n            dist = self._dist(node.position, point)\n            if dist < min_dist:\n                min_dist = dist\n                nearest_node = node\n        return nearest_node\n\n    def _near(self, tree, point, radius):\n        near_nodes = []\n        r2 = radius * radius\n        for node in tree:\n            if self._dist_sq(node.position, point) <= r2:\n                near_nodes.append(node)\n        return near_nodes\n\n    def _extend(self, tree, point, obstacles, is_3d, nodes, edges):\n        nearest = self._nearest(tree, point)\n        new_pos = self._steer(nearest.position, point)\n        if not self._valid(nearest.position, new_pos, obstacles, is_3d):\n            return None\n        new_cost = nearest.cost + self._dist(nearest.position, new_pos)\n        # Choose best parent among near vertices to minimize cost\n        near_nodes = self._near(tree, new_pos, self.rewire_radius)\n        best_parent = nearest\n        best_cost = new_cost\n        for near_node in near_nodes:\n            cost_through_near = near_node.cost + self._dist(near_node.position, new_pos)\n            if cost_through_near < best_cost and self._valid(near_node.position, new_pos, obstacles, is_3d):\n                best_parent = near_node\n                best_cost = cost_through_near\n        new_node = Node(new_pos, best_parent, best_cost)\n        best_parent.add_child(new_node)\n        tree.append(new_node)\n        nodes.append(new_node)\n        edges.append((best_parent, new_node))\n        return new_node\n\n    def _connect(self, tree, target_node, obstacles, is_3d, nodes, edges):\n        current = self._nearest(tree, target_node.position)\n        while True:\n            new_pos = self._steer(current.position, target_node.position)\n            if not self._valid(current.position, new_pos, obstacles, is_3d):\n                return None\n            new_cost = current.cost + self._dist(current.position, new_pos)\n            new_node = Node(new_pos, current, new_cost)\n            current.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((current, new_node))\n\n            # Rewire near nodes around new_node for better costs\n            self._rewire(new_node, tree, obstacles, is_3d, nodes, edges)\n\n            if self._dist(new_node.position, target_node.position) <= self.step_size:\n                if not self._valid(new_node.position, target_node.position, obstacles, is_3d):\n                    return None\n                final_cost = new_node.cost + self._dist(new_node.position, target_node.position)\n                final_node = Node(target_node.position, new_node, final_cost)\n                new_node.add_child(final_node)\n                tree.append(final_node)\n                nodes.append(final_node)\n                edges.append((new_node, final_node))\n                return final_node\n            current = new_node\n\n    def _rewire(self, new_node, tree, obstacles, is_3d, nodes, edges):\n        near_nodes = self._near(tree, new_node.position, self.rewire_radius)\n        for near in near_nodes:\n            if near == new_node.parent:\n                continue\n            cost_through_new = new_node.cost + self._dist(new_node.position, near.position)\n            if cost_through_new < near.cost and self._valid(new_node.position, near.position, obstacles, is_3d):\n                # Update parent and cost\n                if near.parent:\n                    try:\n                        near.parent.children.remove(near)\n                    except ValueError:\n                        pass\n                near.parent = new_node\n                near.cost = cost_through_new\n                new_node.children.append(near)\n                # Update children costs recursively\n                self._update_children_costs(near)\n\n    def _update_children_costs(self, node):\n        for child in node.children:\n            new_cost = node.cost + self._dist(node.position, child.position)\n            if new_cost < child.cost:\n                child.cost = new_cost\n                child.parent = node\n                self._update_children_costs(child)\n\n    def _steer(self, start, goal):\n        dist = self._dist(start, goal)\n        if dist <= self.step_size:\n            return goal\n        ratio = self.step_size / dist\n        return tuple(start[d] + (goal[d] - start[d]) * ratio for d in range(len(start)))\n\n    def _valid(self, p1, p2, obstacles, is_3d):\n        return (not self._in_obstacle(p2, obstacles, is_3d)) and (not self._edge_in_obstacle(p1, p2, obstacles, is_3d))\n\n    def _in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x,y,z,w,h,d = obs\n                px,py,pz = pos\n                if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                    return True\n            else:\n                x,y,w,h = obs\n                px,py = pos\n                if x <= px <= x+w and y <= py <= y+h:\n                    return True\n        return False\n\n    def _edge_in_obstacle(self, p1, p2, obstacles, is_3d, res=1.0):\n        dist = self._dist(p1, p2)\n        steps = max(1, int(dist / res))\n        for i in range(steps + 1):\n            interp = tuple(p1[d] + (p2[d] - p1[d]) * i / steps for d in range(len(p1)))\n            if self._in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _dist(self, a, b):\n        return sum((a[d]-b[d])**2 for d in range(len(a)))**0.5\n\n    def _dist_sq(self, a, b):\n        return sum((a[d]-b[d])**2 for d in range(len(a)))\n\n    def _shortcut_path(self, path, obstacles, is_3d):\n        if len(path) <= 2:\n            return path\n        i = 0\n        new_path = [path[0]]\n        while i < len(path) - 1:\n            j = len(path) - 1\n            while j > i + 1:\n                if not self._edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                    break\n                j -= 1\n            new_path.append(path[j])\n            i = j\n        return new_path",
          "objective": -21.69817,
          "time_improvement": 13.0,
          "length_improvement": 17.0,
          "smoothness_improvement": 1574.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.026177811622619628,
                    "num_nodes_avg": 114.0,
                    "path_length_avg": 165.39322114121052,
                    "smoothness_avg": 0.05422599018415906,
                    "success_improvement": 0.0,
                    "time_improvement": 0.2857083177810343,
                    "length_improvement": 9.345354669199349,
                    "smoothness_improvement": 748.7545000044862,
                    "objective_score": 9.43669779687635
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.08344228267669677,
                    "num_nodes_avg": 275.8,
                    "path_length_avg": 235.51330564478062,
                    "smoothness_avg": 0.10403228200976807,
                    "success_improvement": 0.0,
                    "time_improvement": 49.471802034945625,
                    "length_improvement": 21.378879701134153,
                    "smoothness_improvement": 2576.825547535313,
                    "objective_score": 40.55299616884074
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.056298470497131346,
                    "num_nodes_avg": 219.1,
                    "path_length_avg": 121.18470212144905,
                    "smoothness_avg": 0.11765862390427125,
                    "success_improvement": 0.0,
                    "time_improvement": -11.957171088066387,
                    "length_improvement": 19.514891046335084,
                    "smoothness_improvement": 1396.6090114061014,
                    "objective_score": 15.104828358411641
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e2",
          "algorithm_description": "A hybrid bidirectional anytime RRT* variant integrating adaptive informed sampling, dynamic rewiring, and heuristic-guided priority expansions for efficient and high-quality path planning. It maintains two trees grown from start and goal, using informed ellipse sampling after finding initial solutions, rewires nodes within an adaptive radius to improve path quality, and employs a min-priority queue with cost + heuristic to guide expansions. The algorithm incrementally attempts to connect both trees using collision-checked edges and performs path shortcutting for smoothness and shorter paths. This combination balances efficiency, robustness, path length, and smoothness, yielding faster convergence and better final solutions.",
          "planning_mechanism": "A bidirectional RRT*-inspired planner that alternates expansions of two trees grown from start and goal, uses heuristic priority queues for node selection, employs adaptive ellipsoidal informed sampling to bias growth towards promising regions when a solution is found, dynamically rewires nodes within a decreasing radius to reduce path cost, and performs collision checking both lazily and eagerly to optimize planning time. The planner incrementally attempts connections between trees and upon success extracts and shortcuts the path to return the best collision-free solution found within the iteration limit.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost  # cost-to-come\n        self.children = []\n        self.id = id(self)\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=4500, step_size=4.0, goal_sample_rate=0.12, init_radius=20.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.init_radius = init_radius\n\n    def plan(self, map):\n        bounds = map.size\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        import math\n        import random\n        import heapq\n\n        def heuristic(p):\n            return math.sqrt(sum((p[d] - goal[d]) ** 2 for d in range(dim)))\n\n        def dist(a, b):\n            return math.sqrt(sum((a[d] - b[d]) ** 2 for d in range(dim)))\n\n        def in_obstacle(pt):\n            if is_3d:\n                px, py, pz = pt\n                for obs in obstacles:\n                    ox, oy, oz, w, h, d = obs\n                    if ox <= px <= ox + w and oy <= py <= oy + h and oz <= pz <= oz + d:\n                        return True\n            else:\n                px, py = pt\n                for obs in obstacles:\n                    ox, oy, w, h = obs\n                    if ox <= px <= ox + w and oy <= py <= oy + h:\n                        return True\n            return False\n\n        def edge_in_obstacle(p1, p2):\n            distance = dist(p1, p2)\n            steps = max(2, int(distance / 0.5))\n            for i in range(steps+1):\n                interp = tuple(p1[d] + (p2[d] - p1[d]) * (i / steps) for d in range(dim))\n                if in_obstacle(interp):\n                    return True\n            return False\n\n        def steer(from_p, to_p):\n            d = dist(from_p, to_p)\n            if d <= self.step_size:\n                return to_p\n            ratio = self.step_size / d\n            return tuple(from_p[d_] + ratio * (to_p[d_] - from_p[d_]) for d_ in range(dim))\n\n        def sample_uniform():\n            trials = 0\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not in_obstacle(pt):\n                    return pt\n                trials += 1\n                if trials > 1000:  # fallback to goal sample if stuck\n                    return goal\n\n        # Informed sampling inside prolate hyperspheroid\n        def sample_informed(c_best):\n            if c_best == float('inf'):\n                return sample_uniform()\n            c_min = dist(start, goal)\n            if c_best < c_min:\n                return sample_uniform()\n            center = tuple((start[d] + goal[d]) * 0.5 for d in range(dim))\n            a1 = [(goal[d] - start[d]) / c_min for d in range(dim)]\n\n            while True:\n                x_ball = [random.gauss(0,1) for _ in range(dim)]\n                norm = math.sqrt(sum(x*x for x in x_ball))\n                if norm == 0:\n                    continue\n                unit = [x / norm for x in x_ball]\n                r1 = c_best/2.0\n                r2_temp = c_best**2 - c_min**2\n                r2 = math.sqrt(r2_temp)/2.0 if r2_temp > 0 else 0.0\n                \n                if dim == 2:\n                    angle = math.atan2(a1[1], a1[0])\n                    cos_a = math.cos(angle)\n                    sin_a = math.sin(angle)\n                    x_ell = r1 * unit[0]\n                    y_ell = r2 * unit[1]\n                    px = center[0] + cos_a * x_ell - sin_a * y_ell\n                    py = center[1] + sin_a * x_ell + cos_a * y_ell\n                    pt = (px, py)\n                else:\n                    # 3D: scale along axis, clamp inside bounds\n                    pt_candidate = []\n                    for d in range(dim):\n                        scale = r1 if d == 0 else r2\n                        coord = center[d] + scale * unit[d]\n                        coord = max(0, min(coord, bounds[d]))\n                        pt_candidate.append(coord)\n                    pt = tuple(pt_candidate)\n\n                if all(0 <= pt[d] <= bounds[d] for d in range(dim)) and not in_obstacle(pt):\n                    return pt\n\n        class PriorityQueue:\n            def __init__(self):\n                self.heap = []\n                self.entry_finder = {}\n                self.REMOVED = '<removed>'\n\n            def add(self, node, priority):\n                if node.id in self.entry_finder:\n                    self.remove(node)\n                entry = [priority, node.id, node]\n                self.entry_finder[node.id] = entry\n                heapq.heappush(self.heap, entry)\n\n            def remove(self, node):\n                entry = self.entry_finder.pop(node.id)\n                entry[-1] = self.REMOVED\n\n            def pop(self):\n                while self.heap:\n                    priority, nid, node = heapq.heappop(self.heap)\n                    if node is not self.REMOVED:\n                        del self.entry_finder[nid]\n                        return node\n                return None\n\n            def empty(self):\n                return not bool(self.entry_finder)\n\n        def nearest(tree_nodes, point):\n            best_node = None\n            best_dist = float('inf')\n            for node in tree_nodes:\n                d = dist(node.position, point)\n                if d < best_dist:\n                    best_dist = d\n                    best_node = node\n            return best_node, best_dist\n\n        def neighbors(tree_nodes, node, radius):\n            nbrs = []\n            for n in tree_nodes:\n                if dist(n.position, node.position) <= radius:\n                    nbrs.append(n)\n            return nbrs\n\n        def shortcut_path(path):\n            if len(path) <= 2:\n                return path\n            shortened = [path[0]]\n            idx = 0\n            while idx < len(path)-1:\n                next_idx = len(path)-1\n                for j in range(len(path)-1, idx, -1):\n                    if not edge_in_obstacle(path[idx], path[j]):\n                        next_idx = j\n                        break\n                shortened.append(path[next_idx])\n                idx = next_idx\n            return shortened\n\n        def add_node_rewire(t_nodes, t_pq, new_pos, heuristic_best, radius):\n            near, _ = nearest(t_nodes, new_pos)\n            if in_obstacle(new_pos) or edge_in_obstacle(near.position, new_pos):\n                return None\n\n            new_cost = near.cost + dist(near.position, new_pos)\n            new_node = Node(new_pos, parent=near, cost=new_cost)\n            near.add_child(new_node)\n            t_nodes.append(new_node)\n            t_pq.add(new_node, new_node.cost + heuristic(new_pos))\n\n            nbrs = neighbors(t_nodes, new_node, radius)\n            for nbr in nbrs:\n                if nbr is new_node.parent:\n                    continue\n                cost_through_new = new_node.cost + dist(new_node.position, nbr.position)\n                if cost_through_new + 1e-8 < nbr.cost:\n                    if not edge_in_obstacle(new_node.position, nbr.position):\n                        # Rewire nbr\n                        if nbr.parent:\n                            nbr.parent.remove_child(nbr)\n                        nbr.parent = new_node\n                        new_node.children.append(nbr)\n                        old_cost = nbr.cost\n                        nbr.cost = cost_through_new\n\n                        def dfs_update_cost(node):\n                            for c in node.children:\n                                new_c_cost = node.cost + dist(node.position, c.position)\n                                if new_c_cost + 1e-8 < c.cost:\n                                    c.cost = new_c_cost\n                                    dfs_update_cost(c)\n                        dfs_update_cost(nbr)\n                        t_pq.add(nbr, nbr.cost + heuristic(nbr.position))\n            return new_node\n\n        def attempt_connect(tree_other_nodes, tree_other_pq, node_new):\n            near_other, _ = nearest(tree_other_nodes, node_new.position)\n            if in_obstacle(node_new.position) or edge_in_obstacle(near_other.position, node_new.position):\n                return None\n            cost_new = near_other.cost + dist(near_other.position, node_new.position)\n            new_node_other = Node(node_new.position, parent=near_other, cost=cost_new)\n            near_other.add_child(new_node_other)\n            tree_other_nodes.append(new_node_other)\n            tree_other_pq.add(new_node_other, new_node_other.cost + heuristic(new_node_other.position))\n            return new_node_other\n\n        start_node = Node(start, cost=0.0)\n        goal_node = Node(goal, cost=0.0)\n        tree_start = [start_node]\n        tree_goal = [goal_node]\n        pq_start = PriorityQueue()\n        pq_goal = PriorityQueue()\n        pq_start.add(start_node, heuristic(start))\n        pq_goal.add(goal_node, heuristic(goal))\n\n        best_cost = float('inf')\n        best_path = None\n\n        def adaptive_radius(iter_idx):\n            r = self.init_radius * (0.96 ** (iter_idx // 350))\n            return max(4.0, r)\n\n        for i in range(self.max_iter):\n            expand_start = (i % 2 == 0)\n            t_nodes_a, t_pq_a = (tree_start, pq_start) if expand_start else (tree_goal, pq_goal)\n            t_nodes_b, t_pq_b = (tree_goal, pq_goal) if expand_start else (tree_start, pq_start)\n\n            nbr_radius = adaptive_radius(i)\n            curr_best = best_cost if best_cost != float('inf') else float('inf')\n\n            sample_point = None\n            p = random.random()\n            if p < self.goal_sample_rate:\n                sample_point = goal if expand_start else start\n                # Ensure not in obstacle\n                if in_obstacle(sample_point):\n                    sample_point = sample_uniform()\n            elif curr_best < float('inf'):\n                sample_point = sample_informed(curr_best)\n            else:\n                sample_point = sample_uniform()\n\n            new_node_a = add_node_rewire(t_nodes_a, t_pq_a, sample_point, curr_best, nbr_radius)\n            if new_node_a is None:\n                continue\n\n            new_node_b = attempt_connect(t_nodes_b, t_pq_b, new_node_a)\n            if new_node_b:\n                total_c = new_node_a.cost + new_node_b.cost\n                if total_c + 1e-8 < best_cost:\n                    best_cost = total_c\n                    path_start = new_node_a.path_from_root() if expand_start else new_node_b.path_from_root()\n                    path_goal = new_node_b.path_from_root() if expand_start else new_node_a.path_from_root()\n                    if path_start[-1] == path_goal[-1]:\n                        combined = path_start + path_goal[-2::-1]\n                    else:\n                        combined = path_start + path_goal[::-1]\n\n                    smoothed = shortcut_path(combined)\n                    best_path = smoothed\n                    # Anytime return on improvement\n                    return PlannerResult(success=True, path=best_path, nodes=tree_start + tree_goal, edges=[])\n\n        # Return failure if no connection found\n        return PlannerResult(success=False, path=[], nodes=tree_start + tree_goal, edges=[])",
          "objective": -21.32282,
          "time_improvement": 41.0,
          "length_improvement": -3.0,
          "smoothness_improvement": 2088.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.03065047264099121,
                    "num_nodes_avg": 69.3,
                    "path_length_avg": 201.54333295789633,
                    "smoothness_avg": 0.09071995397809844,
                    "success_improvement": 0.0,
                    "time_improvement": -16.75117130420488,
                    "length_improvement": -10.469094452705283,
                    "smoothness_improvement": 1319.964281290423,
                    "objective_score": -4.70698665643252
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.011514782905578613,
                    "num_nodes_avg": 68.4,
                    "path_length_avg": 272.8228556658298,
                    "smoothness_avg": 0.12690712863337233,
                    "success_improvement": 0.0,
                    "time_improvement": 93.02726134144713,
                    "length_improvement": 8.923878008254347,
                    "smoothness_improvement": 3165.4118272467053,
                    "objective_score": 49.089564343620275
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.026196837425231934,
                    "num_nodes_avg": 82.4,
                    "path_length_avg": 159.78036568867304,
                    "smoothness_avg": 0.14757624600187821,
                    "success_improvement": 0.0,
                    "time_improvement": 47.90402325881309,
                    "length_improvement": -6.118510967013652,
                    "smoothness_improvement": 1777.1589561985077,
                    "objective_score": 19.585895178428274
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "A streamlined bidirectional RRT planner that grows two trees from start and goal by extending towards random collision-free samples with a fixed step size, connecting trees incrementally, and returning a feasible path once connected. It performs collision checking on nodes and edges and maintains coherent parent-child relationships to build efficient paths.",
          "planning_mechanism": "A planner that alternates expanding two trees via fixed-step steering towards uniform random free samples, validates each extension for collisions, attempts to connect trees after each new node, and reconstructs the final path by joining connected tree paths.",
          "code": "class Node:\n    def __init__(self, position, parent=None):\n        self.position = position\n        self.parent = parent\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        node, path = self, []\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=3000, step_size=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map):\n        bounds, start, goal = map.size, map.start, map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        tree_start = [Node(start)]\n        tree_goal = [Node(goal)]\n        nodes = tree_start + tree_goal\n        edges = []\n\n        for i in range(self.max_iter):\n            tree_a, tree_b = (tree_start, tree_goal) if i % 2 == 0 else (tree_goal, tree_start)\n            sample = self._sample_free(bounds, obstacles, is_3d)\n            new_node = self._extend(tree_a, sample, obstacles, is_3d, nodes, edges)\n            if new_node:\n                connected_node = self._connect(tree_b, new_node, obstacles, is_3d, nodes, edges)\n                if connected_node:\n                    path_a = new_node.path_from_root()\n                    path_b = connected_node.path_from_root()\n                    if path_a[-1] == path_b[-1]:\n                        path = path_a + path_b[-2::-1]\n                    else:\n                        path = path_a + path_b[::-1]\n                    return PlannerResult(True, path, nodes, edges)\n        return PlannerResult(False, [], nodes, edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        import random\n        while True:\n            pt = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n            if not self._in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def _extend(self, tree, target, obstacles, is_3d, nodes, edges):\n        nearest = min(tree, key=lambda n: self._dist(n.position, target))\n        new_pos = self._steer(nearest.position, target)\n        if self._valid(nearest.position, new_pos, obstacles, is_3d):\n            new_node = Node(new_pos, nearest)\n            nearest.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest, new_node))\n            return new_node\n        return None\n\n    def _connect(self, tree, target_node, obstacles, is_3d, nodes, edges):\n        nearest = min(tree, key=lambda n: self._dist(n.position, target_node.position))\n        while True:\n            new_pos = self._steer(nearest.position, target_node.position)\n            if not self._valid(nearest.position, new_pos, obstacles, is_3d):\n                return None\n            new_node = Node(new_pos, nearest)\n            nearest.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest, new_node))\n            if self._dist(new_node.position, target_node.position) <= self.step_size:\n                if not self._valid(new_node.position, target_node.position, obstacles, is_3d):\n                    return None\n                final_node = Node(target_node.position, new_node)\n                new_node.add_child(final_node)\n                tree.append(final_node)\n                nodes.append(final_node)\n                edges.append((new_node, final_node))\n                return final_node\n            nearest = new_node\n\n    def _steer(self, start, goal):\n        dist = self._dist(start, goal)\n        if dist <= self.step_size:\n            return goal\n        ratio = self.step_size / dist\n        return tuple(start[d] + (goal[d] - start[d]) * ratio for d in range(len(start)))\n\n    def _valid(self, p1, p2, obstacles, is_3d):\n        return (not self._in_obstacle(p2, obstacles, is_3d)) and (not self._edge_in_obstacle(p1, p2, obstacles, is_3d))\n\n    def _in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x,y,z,w,h,d = obs\n                px,py,pz = pos\n                if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                    return True\n            else:\n                x,y,w,h = obs\n                px,py = pos\n                if x <= px <= x+w and y <= py <= y+h:\n                    return True\n        return False\n\n    def _edge_in_obstacle(self, p1, p2, obstacles, is_3d, res=1.0):\n        dist = self._dist(p1, p2)\n        steps = max(1, int(dist / res))\n        for i in range(steps+1):\n            interp = tuple(p1[d] + (p2[d] - p1[d]) * i / steps for d in range(len(p1)))\n            if self._in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _dist(self, a, b):\n        return sum((a[d] - b[d])**2 for d in range(len(a)))**0.5",
          "objective": -19.65905,
          "time_improvement": 71.0,
          "length_improvement": -3.0,
          "smoothness_improvement": 62.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.007035160064697265,
                    "num_nodes_avg": 86.2,
                    "path_length_avg": 189.39879686980154,
                    "smoothness_avg": 0.0102591145052943,
                    "success_improvement": 0.0,
                    "time_improvement": 73.20226714000162,
                    "length_improvement": -3.8124817803312583,
                    "smoothness_improvement": 60.57742003157615,
                    "objective_score": 19.976078173959614
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.03991465568542481,
                    "num_nodes_avg": 246.5,
                    "path_length_avg": 309.916942499886,
                    "smoothness_avg": 0.006220174309434665,
                    "success_improvement": 0.0,
                    "time_improvement": 75.82981242262478,
                    "length_improvement": -3.4591958710432116,
                    "smoothness_improvement": 60.04956519221755,
                    "objective_score": 20.973674030122595
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.0178729772567749,
                    "num_nodes_avg": 178.1,
                    "path_length_avg": 154.6893175478031,
                    "smoothness_avg": 0.013091758856632583,
                    "success_improvement": 0.0,
                    "time_improvement": 64.45715212295462,
                    "length_improvement": -2.737279201508942,
                    "smoothness_improvement": 66.52620632324673,
                    "objective_score": 18.027409147597258
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "A bidirectional RRT planner that grows two trees from start and goal, alternately extending them towards random samples with fixed steps. It connects trees incrementally upon new node addition and returns the combined path once connected, ensuring collision-free, feasible paths with simple logic for general use.",
          "planning_mechanism": "The planner samples random points within map bounds, extends each tree towards samples in turns checking node and edge collisions, and tries connecting the trees incrementally. It constructs the solution path by concatenating the connected paths from both trees.",
          "code": "class Node:\n    def __init__(self, position, parent=None):\n        self.position = position\n        self.parent = parent\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        path, node = [], self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=3000, step_size=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map):\n        bounds, start, goal = map.size, map.start, map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start)]\n        goal_tree = [Node(goal)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        for i in range(self.max_iter):\n            tree_a, tree_b = (start_tree, goal_tree) if i % 2 == 0 else (goal_tree, start_tree)\n            sample = self._sample_free(bounds, obstacles, is_3d)\n            new_node = self._extend(tree_a, sample, obstacles, is_3d, nodes, edges)\n            if new_node:\n                connected = self._connect(tree_b, new_node, obstacles, is_3d, nodes, edges)\n                if connected:\n                    path_a = new_node.path_from_root()\n                    path_b = connected.path_from_root()\n                    if path_a[-1] == path_b[-1]:\n                        path = path_a + path_b[-2::-1]\n                    else:\n                        path = path_a + path_b[::-1]\n                    return PlannerResult(True, path, nodes, edges)\n        return PlannerResult(False, [], nodes, edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        import random\n        while True:\n            pt = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n            if not self._in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def _extend(self, tree, target, obstacles, is_3d, nodes, edges):\n        nearest = self._nearest(tree, target)\n        new_pos = self._steer(nearest.position, target)\n        if self._valid(nearest.position, new_pos, obstacles, is_3d):\n            new_node = Node(new_pos, nearest)\n            nearest.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest, new_node))\n            return new_node\n        return None\n\n    def _connect(self, tree, target_node, obstacles, is_3d, nodes, edges):\n        nearest = self._nearest(tree, target_node.position)\n        while True:\n            new_pos = self._steer(nearest.position, target_node.position)\n            if not self._valid(nearest.position, new_pos, obstacles, is_3d):\n                return None\n            new_node = Node(new_pos, nearest)\n            nearest.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest, new_node))\n            if self._dist(new_node.position, target_node.position) <= self.step_size:\n                if not self._valid(new_node.position, target_node.position, obstacles, is_3d):\n                    return None\n                final_node = Node(target_node.position, new_node)\n                new_node.add_child(final_node)\n                tree.append(final_node)\n                nodes.append(final_node)\n                edges.append((new_node, final_node))\n                return final_node\n            nearest = new_node\n\n    def _nearest(self, tree, point):\n        return min(tree, key=lambda node: self._dist(node.position, point))\n\n    def _steer(self, start, goal):\n        dist = self._dist(start, goal)\n        if dist <= self.step_size:\n            return goal\n        ratio = self.step_size / dist\n        return tuple(start[d] + ratio * (goal[d] - start[d]) for d in range(len(start)))\n\n    def _valid(self, p1, p2, obstacles, is_3d):\n        return (not self._in_obstacle(p2, obstacles, is_3d)) and (not self._edge_in_obstacle(p1, p2, obstacles, is_3d))\n\n    def _in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x,y,z,w,h,d = obs\n                px,py,pz = pos\n                if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                    return True\n            else:\n                x,y,w,h = obs\n                px,py = pos\n                if x <= px <= x+w and y <= py <= y+h:\n                    return True\n        return False\n\n    def _edge_in_obstacle(self, p1, p2, obstacles, is_3d, res=1.0):\n        dist = self._dist(p1, p2)\n        steps = max(1, int(dist / res))\n        for i in range(steps+1):\n            interp = tuple(p1[d]+(p2[d]-p1[d])*i/steps for d in range(len(p1)))\n            if self._in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _dist(self, a, b):\n        return sum((a[d]-b[d])**2 for d in range(len(a)))**0.5",
          "objective": -18.87672,
          "time_improvement": 69.0,
          "length_improvement": -3.0,
          "smoothness_improvement": 65.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.007088375091552734,
                    "num_nodes_avg": 86.9,
                    "path_length_avg": 192.080687991448,
                    "smoothness_avg": 0.010225328478655104,
                    "success_improvement": 0.0,
                    "time_improvement": 72.99956498956065,
                    "length_improvement": -5.2824688013900305,
                    "smoothness_improvement": 60.04859534714162,
                    "objective_score": 19.030631192769885
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.027634835243225096,
                    "num_nodes_avg": 224.3,
                    "path_length_avg": 302.18866926184023,
                    "smoothness_avg": 0.006484073476451755,
                    "success_improvement": 0.0,
                    "time_improvement": 83.26581702814202,
                    "length_improvement": -0.8792758181722384,
                    "smoothness_improvement": 66.83988083845422,
                    "objective_score": 24.786379021731538
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.025080132484436034,
                    "num_nodes_avg": 207.5,
                    "path_length_avg": 156.98834599359654,
                    "smoothness_avg": 0.013116998064567845,
                    "success_improvement": 0.0,
                    "time_improvement": 50.12474302273537,
                    "length_improvement": -4.2641844272346905,
                    "smoothness_improvement": 66.84724718521873,
                    "objective_score": 12.81314848640589
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "initial",
          "algorithm_description": "This algorithm enhances the standard BI-RRT by incorporating an optimization step that rewires nearby nodes to minimize cost, resulting in asymptotically optimal paths. It grows two trees\u2014one from the start and one from the goal\u2014and attempts to connect them while optimizing the path cost dynamically.",
          "planning_mechanism": "The planning mechanism includes sampling a random point, extending each tree toward it, rewiring neighbors within a radius to optimize the cost, and attempting to connect the two trees. When a connection is established, the combined path is extracted from both trees. Node validity and edge collision checks are strictly enforced throughout the process.",
          "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost: float = 0.0):\n        self.position = position              # Tuple[float, ...]\n        self.parent: Optional[\"Node\"] = parent\n        self.cost: float = cost\n        self.children: List[\"Node\"] = []\n        self.valid = True\n\n    def add_child(self, child_node: \"Node\"):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n\nclass Planner:\n    def __init__(\n        self,\n        max_iter: int = 5000,\n        step_size: float = 5.0,\n        gamma_rrt_star: float = 50.0,\n        max_radius: float = 60.0,\n    ):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.gamma_rrt_star = gamma_rrt_star\n        self.max_radius = max_radius\n\n    # ======================= Public API =======================\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        start_root = Node(start_position, parent=None, cost=0.0)\n        goal_root  = Node(goal_position,  parent=None, cost=0.0)\n        nodes.extend([start_root, goal_root])\n\n        tree_a: List[Node] = [start_root]\n        tree_b: List[Node] = [goal_root]\n\n        for _ in range(self.max_iter):\n            rand_point = self._sample_free(bounds, obstacles, is_3d)\n\n            new_a = self._extend_and_rewire(tree_a, rand_point, obstacles, is_3d, nodes, edges, bounds)\n            if new_a is None:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            new_b = self._connect_and_rewire(tree_b, new_a, obstacles, is_3d, nodes, edges, bounds)\n            if new_b:\n                success_state = True\n                path_a = new_a.path_from_root()\n                path_b = new_b.path_from_root()\n                if path_a and path_b and path_a[-1] == path_b[-1]:\n                    path_b = path_b[:-1]\n                extracted_path = path_a + path_b[::-1]\n                break\n\n            tree_a, tree_b = tree_b, tree_a\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        while True:\n            p = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    def _nearest(self, tree: List[Node], point):\n        return min(tree, key=lambda node: math.dist(node.position, point))\n\n    def _steer(self, from_pos, to_pos):\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _near_nodes(self, tree: List[Node], position, bounds) -> List[Node]:\n        n = max(1, len(tree))\n        d = len(position)\n        # \uacf5\uac04 \uc2a4\ucf00\uc77c\uc744 \uac04\ub2e8\ud788 bounds\ub85c \ucd94\uc815 (\uc815\ubc00 X, \uc2e4\uc6a9\uc801)\n        scale = max(1.0, sum(bounds) / d)\n        r_theory = self.gamma_rrt_star * ((math.log(n + 1) / (n + 1)) ** (1.0 / d))\n        radius = max(self.step_size * 2.0, min(self.max_radius, r_theory * 0.5 + scale * 0.02))\n        return [node for node in tree if math.dist(node.position, position) <= radius]\n\n    def _choose_parent_and_add(self, tree, new_pos, obstacles, is_3d, nodes, edges, bounds):\n        nearest = self._nearest(tree, new_pos)\n        neighbors = self._near_nodes(tree, new_pos, bounds)\n\n        min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n        best_parent = nearest\n\n        for nb in neighbors:\n            if not self._is_edge_in_obstacle(nb.position, new_pos, obstacles, is_3d):\n                cand = nb.cost + math.dist(nb.position, new_pos)\n                if cand < min_cost:\n                    min_cost = cand\n                    best_parent = nb\n\n        new_node = Node(new_pos, parent=None, cost=min_cost)\n        best_parent.add_child(new_node)\n        tree.append(new_node)\n        nodes.append(new_node)\n        edges.append((best_parent, new_node))\n        return new_node, neighbors\n\n    def _rewire_from(self, pivot: Node, neighbors: List[Node], obstacles, is_3d, edges):\n        for nb in neighbors:\n            if not self._is_edge_in_obstacle(pivot.position, nb.position, obstacles, is_3d):\n                new_cost = pivot.cost + math.dist(pivot.position, nb.position)\n                if new_cost + 1e-12 < nb.cost:  # \uc791\uc740 \uc218\uce58 \ubc84\ud37c\n                    if nb.parent is not None:\n                        try:\n                            edges.remove((nb.parent, nb))\n                        except ValueError:\n                            pass\n                        if nb in nb.parent.children:\n                            nb.parent.children.remove(nb)\n                    pivot.add_child(nb)\n                    nb.cost = new_cost\n                    edges.append((pivot, nb))\n\n    def _extend_and_rewire(self, tree, sample_point, obstacles, is_3d, nodes, edges, bounds):\n        nearest = self._nearest(tree, sample_point)\n        new_pos = self._steer(nearest.position, sample_point)\n\n        if self._is_in_obstacle(new_pos, obstacles, is_3d):\n            return None\n        if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n            return None\n\n        new_node, neighbors = self._choose_parent_and_add(tree, new_pos, obstacles, is_3d, nodes, edges, bounds)\n        self._rewire_from(new_node, neighbors, obstacles, is_3d, edges)\n        return new_node\n\n    def _connect_and_rewire(self, tree, target_node: Node, obstacles, is_3d, nodes, edges, bounds):\n        nearest = self._nearest(tree, target_node.position)\n\n        while True:\n            new_pos = self._steer(nearest.position, target_node.position)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                return None\n\n            connect_node, neighbors = self._choose_parent_and_add(tree, new_pos, obstacles, is_3d, nodes, edges, bounds)\n            self._rewire_from(connect_node, neighbors, obstacles, is_3d, edges)\n\n            if math.dist(connect_node.position, target_node.position) <= self.step_size:\n                if (not self._is_edge_in_obstacle(connect_node.position, target_node.position, obstacles, is_3d) and\n                    not self._is_in_obstacle(target_node.position, obstacles, is_3d)):\n                    final_node = Node(target_node.position, parent=None, cost=connect_node.cost + math.dist(connect_node.position, target_node.position))\n                    connect_node.add_child(final_node)\n                    tree.append(final_node)\n                    nodes.append(final_node)\n                    edges.append((connect_node, final_node))\n                    return final_node\n                else:\n                    return None\n\n            nearest = connect_node\n\n        \n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n        \n        \n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n",
          "objective": -18.596615900992976,
          "time_improvement": 38.0,
          "length_improvement": 11.0,
          "smoothness_improvement": 172.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.0230562686920166,
                    "num_nodes_avg": 97.6,
                    "path_length_avg": 161.12249215478707,
                    "smoothness_avg": 0.018062462568387585,
                    "success_improvement": 0.0,
                    "time_improvement": 12.176023931931311,
                    "length_improvement": 11.686208900689492,
                    "smoothness_improvement": 182.71676246052309,
                    "objective_score": 11.578116332295703
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.035856032371521,
                    "num_nodes_avg": 250.1,
                    "path_length_avg": 265.1599124520743,
                    "smoothness_avg": 0.010159869700973916,
                    "success_improvement": 0.0,
                    "time_improvement": 78.28749833068048,
                    "length_improvement": 11.481989018596753,
                    "smoothness_improvement": 161.42076526441443,
                    "objective_score": 31.182546736684266
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.038674354553222656,
                    "num_nodes_avg": 237.3,
                    "path_length_avg": 137.40430639955787,
                    "smoothness_avg": 0.021326989594760596,
                    "success_improvement": 0.0,
                    "time_improvement": 23.090782197070272,
                    "length_improvement": 8.742602179373693,
                    "smoothness_improvement": 171.27773345073243,
                    "objective_score": 13.02918463399896
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "cross_over",
          "algorithm_description": "An improved bidirectional RRT* planner integrates adaptive informed sampling with adaptive neighborhood rewiring and incremental cost propagation. It dynamically balances exploration and exploitation, uses an efficient radius scaling with tighter bounds to minimize unnecessary neighbors, performs incremental rewiring with recursive cost updates to avoid local suboptimality, and employs lazy collision checks and early exits to reduce planning time. The algorithm refines paths online, connects trees with smarter distance thresholds, and uses aggressive shortcut smoothing on the final path to maximize smoothness and minimize length within a strict iteration and time limit.",
          "planning_mechanism": "The planner alternates tree growth with samples biased by an adaptive informed ellipsoid based on the best solution cost. For each new node, it selects the minimum-cost parent among neighbors within a carefully bounded radius, inserts the node if collision free, and rewires neighbors with recursive cost updates to promote global path improvement. The trees attempt connection via nearest nodes when close, and if successful, the combined path undergoes shortcut smoothing to produce a short, smooth output. Adaptive radius and step size ensure efficient, focused growth. The use of early collision checks and incremental cost propagation reduces overhead and improves solution quality iteratively.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n\n    def path_from_root(self):\n        path = []\n        n = self\n        while n:\n            path.append(n.position)\n            n = n.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=4000, step_size=4.5, gamma=40.0,\n                 time_limit_sec=15.0, post_opt_iters=200, max_no_improve=80):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.gamma = gamma\n        self.time_limit_sec = time_limit_sec\n        self.post_opt_iters = post_opt_iters\n        self.max_no_improve = max_no_improve\n\n    def plan(self, map):\n        import math\n        import random\n        import time\n\n        bounds = map.size\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def within_bounds(p):\n            return all(0.0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def in_obstacle(p):\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d = obs\n                    px,py,pz = p\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                        return True\n                else:\n                    x,y,w,h = obs\n                    px,py = p\n                    if x <= px <= x+w and y <= py <= y+h:\n                        return True\n            return False\n\n        def edge_collision(a,b,resolution=1.0):\n            length = dist(a,b)\n            steps = max(2, int(length / resolution))\n            for i in range(steps+1):\n                pt = tuple(a[d]+(b[d]-a[d])*i/steps for d in range(dim))\n                if in_obstacle(pt):\n                    return True\n            return False\n\n        def steer(from_p, to_p):\n            d = dist(from_p,to_p)\n            if d <= self.step_size:\n                return to_p\n            r = self.step_size / d\n            return tuple(from_p[i] + (to_p[i]-from_p[i])*r for i in range(dim))\n\n        def neighbor_radius(n_nodes, c_best=float('inf')):\n            if n_nodes < 2:\n                return self.step_size * 2.0\n            base = self.gamma * ((math.log(n_nodes)/n_nodes)**(1.0/dim))\n            max_r = max(bounds)*0.3\n            min_r = max(self.step_size*1.8,10.0)\n            r = max(min_r, min(max_r, base))\n            if c_best < float('inf'):\n                # Reduce radius proportional to cost improvement for focused rewiring\n                r = min(r, max(self.step_size*2.2, c_best*0.15))\n            return r\n\n        def nearest(tree, p):\n            return min(tree, key=lambda n: dist(n.position,p))\n\n        def near_nodes(tree, p, radius):\n            return [n for n in tree if dist(n.position,p) <= radius]\n\n        def sample_uniform():\n            for _ in range(100):\n                p = tuple(random.uniform(0,bounds[d]) for d in range(dim))\n                if not in_obstacle(p):\n                    return p\n            return start_pos  # fallback\n\n        def sample_unit_ball():\n            while True:\n                v = [random.gauss(0,1) for _ in range(dim)]\n                normv = math.sqrt(sum(x*x for x in v))\n                if normv > 1e-12:\n                    v = [x/normv for x in v]\n                    r = random.random() ** (1.0/dim)\n                    return tuple(v[i]*r for i in range(dim))\n\n        def sample_informed(c_best):\n            if c_best == float(\"inf\"):\n                return sample_uniform()\n            c_min = dist(start_pos, goal_pos)\n            if c_min < 1e-12:\n                return sample_uniform()\n            r1 = c_best/2.0\n            r_other_sq = max(c_best*c_best - c_min*c_min, 0.0)\n            r_other = math.sqrt(r_other_sq)/2.0\n            center = tuple((start_pos[d]+goal_pos[d])/2.0 for d in range(dim))\n            unit_vec = tuple((goal_pos[d]-start_pos[d])/c_min for d in range(dim))\n\n            if dim==2:\n                perp_vec = (-unit_vec[1], unit_vec[0])\n                basis = [unit_vec, perp_vec]\n                radii = [r1, r_other]\n            else:\n                def cross(u,v):\n                    return (u[1]*v[2]-u[2]*v[1], u[2]*v[0]-u[0]*v[2], u[0]*v[1]-u[1]*v[0])\n                def norm_vec(vv):\n                    return math.sqrt(sum(x*x for x in vv))\n                def normalize(vv):\n                    n = norm_vec(vv)\n                    if n < 1e-12:\n                        return vv\n                    return tuple(x/n for x in vv)\n                ref = (1.0,0.0,0.0) if abs(unit_vec[0]) < 0.9 else (0.0,1.0,0.0)\n                b2 = normalize(cross(unit_vec, ref))\n                if norm_vec(b2) < 1e-12:\n                    ref = (0.0,0.0,1.0)\n                    b2 = normalize(cross(unit_vec, ref))\n                b3 = cross(unit_vec, b2)\n                basis = [unit_vec, b2, b3]\n                radii = [r1, r_other, r_other]\n\n            u = sample_unit_ball()\n            mapped = []\n            for d in range(dim):\n                val = center[d]\n                for i in range(dim):\n                    val += basis[i][d]*radii[i]*u[i]\n                val = max(0.0, min(bounds[d], val))\n                mapped.append(val)\n            return tuple(mapped)\n\n        def can_connect(p1, p2):\n            if in_obstacle(p2):\n                return False\n            if edge_collision(p1, p2):\n                return False\n            return True\n\n        def add_node_with_parent(tree, pos, best_parent):\n            cost_new = best_parent.cost + dist(best_parent.position, pos)\n            new_node = Node(pos, parent=best_parent, cost=cost_new)\n            best_parent.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n            return new_node\n\n        def update_cost_recursive(node, cost_delta):\n            node.cost += cost_delta\n            for c in node.children:\n                update_cost_recursive(c, cost_delta)\n\n        def rewire(node, neighbors):\n            n_changed = 0\n            for nb in neighbors:\n                if nb is node:\n                    continue\n                d_new = dist(node.position, nb.position)\n                cost_candidate = node.cost + d_new\n                if cost_candidate + 1e-12 < nb.cost:\n                    if can_connect(node.position, nb.position):\n                        # Rewire nb parent\n                        if nb.parent:\n                            try:\n                                edges.remove((nb.parent, nb))\n                            except:\n                                pass\n                            nb.parent.remove_child(nb)\n                        node.add_child(nb)\n                        cost_diff = cost_candidate - nb.cost\n                        update_cost_recursive(nb, cost_diff)\n                        edges.append((node, nb))\n                        n_changed += 1\n            return n_changed\n\n        def add_node(tree, pos, c_best=float('inf')):\n            r = neighbor_radius(len(tree), c_best)\n            near = near_nodes(tree, pos, r)\n            if not near:\n                # fallback nearest\n                near = [nearest(tree, pos)]\n            candidates = [p for p in near if can_connect(p.position, pos)]\n            if not candidates:\n                return None, []\n            best_parent = min(candidates, key=lambda p: p.cost+dist(p.position,pos))\n            if in_obstacle(pos):\n                return None, []\n            return add_node_with_parent(tree, pos, best_parent), near\n\n        def connect_trees(n1, tree_other):\n            # Connect if within threshold, use smaller threshold than step_size*3\n            threshold = self.step_size*2.2\n            near_other = nearest(tree_other, n1.position)\n            d = dist(n1.position, near_other.position)\n            if d > threshold:\n                return None\n            if can_connect(n1.position, near_other.position):\n                return near_other\n            return None\n\n        def extract_path(n_start, n_goal, start_side=True):\n            path_s = n_start.path_from_root()\n            path_g = n_goal.path_from_root()\n            if path_s[-1] == path_g[-1]:\n                combined = path_s + path_g[-2::-1]\n            else:\n                combined = path_s + path_g[::-1]\n            return combined if start_side else combined[::-1]\n\n        def path_cost(path):\n            if len(path) < 2:\n                return 0.0\n            return sum(dist(path[i], path[i+1]) for i in range(len(path)-1))\n\n        def shortcut_path(path, attempts=60):\n            if len(path) < 3:\n                return path[:]\n            for _ in range(attempts):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path)-3)\n                j = random.randint(i+2, len(path)-1)\n                if j <= i+1:\n                    continue\n                if not edge_collision(path[i], path[j]):\n                    # Remove intermediate nodes between i+1 and j-1\n                    path = path[:i+1]+path[j:]\n            return path\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        tree_a = [start_root]\n        tree_b = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        best_cost = float('inf')\n        best_path = []\n        found = False\n        no_improve_cnt = 0\n        post_opt_cnt = 0\n        t_start = time.time()\n\n        for it in range(self.max_iter):\n            if time.time() - t_start > self.time_limit_sec:\n                break\n\n            grow_tree = tree_a if (it % 2 == 0) else tree_b\n            other_tree = tree_b if (it % 2 == 0) else tree_a\n            start_side = (grow_tree is tree_a)\n\n            sample = sample_informed(best_cost)\n            nearest_node = nearest(grow_tree, sample)\n            new_pos = steer(nearest_node.position, sample)\n\n            if not within_bounds(new_pos):\n                if found:\n                    post_opt_cnt += 1\n                    no_improve_cnt += 1\n                    if post_opt_cnt >= self.post_opt_iters or no_improve_cnt >= self.max_no_improve:\n                        break\n                continue\n\n            if in_obstacle(new_pos) or edge_collision(nearest_node.position, new_pos):\n                if found:\n                    post_opt_cnt += 1\n                    no_improve_cnt += 1\n                    if post_opt_cnt >= self.post_opt_iters or no_improve_cnt >= self.max_no_improve:\n                        break\n                continue\n\n            new_node, neighbors = add_node(grow_tree, new_pos, best_cost)\n            if new_node is None:\n                if found:\n                    post_opt_cnt += 1\n                    no_improve_cnt += 1\n                    if post_opt_cnt >= self.post_opt_iters or no_improve_cnt >= self.max_no_improve:\n                        break\n                continue\n\n            rewire(new_node, neighbors)\n\n            connect_node = connect_trees(new_node, other_tree)\n            if connect_node:\n                path_candidate = extract_path(new_node, connect_node, start_side)\n                cost_candidate = path_cost(path_candidate)\n                if cost_candidate + 1e-8 < best_cost:\n                    best_cost = cost_candidate\n                    best_path = shortcut_path(path_candidate, attempts=75)\n                    found = True\n                    no_improve_cnt = 0\n                    post_opt_cnt = 0\n                else:\n                    if found:\n                        no_improve_cnt += 1\n                        post_opt_cnt += 1\n                        if post_opt_cnt >= self.post_opt_iters or no_improve_cnt >= self.max_no_improve:\n                            break\n            else:\n                if found:\n                    no_improve_cnt += 1\n                    post_opt_cnt += 1\n                    if post_opt_cnt >= self.post_opt_iters or no_improve_cnt >= self.max_no_improve:\n                        break\n\n        return PlannerResult(success=found, path=best_path if found else [], nodes=nodes, edges=edges)",
          "objective": -17.38255,
          "time_improvement": -2.0,
          "length_improvement": 19.0,
          "smoothness_improvement": 1343.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.04732570648193359,
                    "num_nodes_avg": 174.8,
                    "path_length_avg": 159.6689680797073,
                    "smoothness_avg": 0.04623537543316629,
                    "success_improvement": 0.0,
                    "time_improvement": -80.26905259448762,
                    "length_improvement": 12.482908478803605,
                    "smoothness_improvement": 623.6840272537908,
                    "objective_score": -13.472550554795168
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.046145963668823245,
                    "num_nodes_avg": 335.6,
                    "path_length_avg": 230.89521003339866,
                    "smoothness_avg": 0.08556149235424479,
                    "success_improvement": 0.0,
                    "time_improvement": 72.05646450755975,
                    "length_improvement": 22.920532940725426,
                    "smoothness_improvement": 2101.558825726661,
                    "objective_score": 45.877053245336484
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.0485954999923706,
                    "num_nodes_avg": 316.1,
                    "path_length_avg": 119.9179424359091,
                    "smoothness_avg": 0.11039449985677638,
                    "success_improvement": 0.0,
                    "time_improvement": 3.3612341736142275,
                    "length_improvement": 20.356212512856622,
                    "smoothness_improvement": 1304.2098897038297,
                    "objective_score": 19.74314720831739
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "A simplified bidirectional RRT planner that balances efficient path finding and computational efficiency by alternating tree expansion from start and goal positions, using straightforward extension steps and rigorous collision checks without costly rewiring or informed sampling. The algorithm prioritizes easy implementation and reliable success at the cost of advanced path cost optimization or smoothing.",
          "planning_mechanism": "class 'Node'",
          "code": "class Node:\n    def __init__(self, position, parent=None):\n        self.position = position\n        self.parent = parent\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map):\n        bounds = map.size\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start)]\n        goal_tree = [Node(goal)]\n\n        nodes = start_tree + goal_tree\n        edges = []\n\n        for i in range(self.max_iter):\n            tree_a, tree_b = (start_tree, goal_tree) if i % 2 == 0 else (goal_tree, start_tree)\n\n            rand_point = self._sample_free(bounds, obstacles, is_3d)\n            new_node_a = self._extend(tree_a, rand_point, obstacles, is_3d, nodes, edges)\n            if new_node_a is None:\n                continue\n\n            new_node_b = self._connect(tree_b, new_node_a, obstacles, is_3d, nodes, edges)\n            if new_node_b is not None:\n                path_start = new_node_a.path_from_root()\n                path_goal = new_node_b.path_from_root()\n                # Avoid duplicating connecting node\n                if path_start[-1] == path_goal[-1]:\n                    full_path = path_start + path_goal[-2::-1]\n                else:\n                    full_path = path_start + path_goal[::-1]\n                return PlannerResult(\n                    success=True,\n                    path=full_path,\n                    nodes=nodes,\n                    edges=edges\n                )\n\n        return PlannerResult(\n            success=False,\n            path=[],\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        while True:\n            if is_3d:\n                p = tuple(random.uniform(0, bounds[d]) for d in range(3))\n            else:\n                p = tuple(random.uniform(0, bounds[d]) for d in range(2))\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    def _nearest(self, tree, point):\n        return min(tree, key=lambda node: self._distance(node.position, point))\n\n    def _steer(self, from_pos, to_pos):\n        dist = self._distance(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(len(from_pos)))\n\n    def _extend(self, tree, point, obstacles, is_3d, nodes, edges):\n        nearest = self._nearest(tree, point)\n        new_pos = self._steer(nearest.position, point)\n        if (self._within_bounds(new_pos, edges, nodes) and\n            not self._is_in_obstacle(new_pos, obstacles, is_3d) and\n            not self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d)):\n            new_node = Node(new_pos)\n            nearest.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest, new_node))\n            return new_node\n        return None\n\n    def _connect(self, tree, target_node, obstacles, is_3d, nodes, edges):\n        current = self._nearest(tree, target_node.position)\n        while True:\n            new_pos = self._steer(current.position, target_node.position)\n            if not self._within_bounds(new_pos, edges, nodes):\n                return None\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(current.position, new_pos, obstacles, is_3d):\n                return None\n            new_node = Node(new_pos)\n            current.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((current, new_node))\n            if self._distance(new_node.position, target_node.position) <= self.step_size:\n                if not self._is_edge_in_obstacle(new_node.position, target_node.position, obstacles, is_3d):\n                    final_node = Node(target_node.position)\n                    new_node.add_child(final_node)\n                    tree.append(final_node)\n                    nodes.append(final_node)\n                    edges.append((new_node, final_node))\n                    return final_node\n                else:\n                    return None\n            current = new_node\n\n    def _within_bounds(self, pos, edges, nodes):\n        dims = len(pos)\n        if hasattr(edges, '__len__') and nodes:\n            # edges and nodes arguments don't provide bounds, re-checking not needed\n            # Instead, handle bounds from map.size (caller)\n            # Simplify to true since map bounds are enforced in sampling and steering\n            return True\n        # fallback check (shouldn't occur)\n        return all(0.0 <= pos[d] <= 10000.0 for d in range(dims))  # large bound\n\n    def _distance(self, a, b):\n        return math.sqrt(sum((a[d]-b[d])**2 for d in range(len(a))))\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, p1, p2, obstacles, is_3d, resolution=1.0):\n        dist = self._distance(p1, p2)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(p1[d] + (p2[d] - p1[d]) * i / steps for d in range(len(p1)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -15.67822,
          "time_improvement": 51.0,
          "length_improvement": 0.0,
          "smoothness_improvement": 68.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.007469820976257324,
                    "num_nodes_avg": 73.1,
                    "path_length_avg": 176.0623468550158,
                    "smoothness_avg": 0.0107998836069439,
                    "success_improvement": 0.0,
                    "time_improvement": 71.54659379560685,
                    "length_improvement": 3.4974378023468984,
                    "smoothness_improvement": 69.04163077129193,
                    "objective_score": 23.907648973946657
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.03709430694580078,
                    "num_nodes_avg": 234.9,
                    "path_length_avg": 302.79595763742356,
                    "smoothness_avg": 0.006446290084951689,
                    "success_improvement": 0.0,
                    "time_improvement": 77.53766526263358,
                    "length_improvement": -1.0820061577686475,
                    "smoothness_improvement": 65.86768696088066,
                    "objective_score": 22.941434318933286
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.04822392463684082,
                    "num_nodes_avg": 247.1,
                    "path_length_avg": 154.05757544889508,
                    "smoothness_avg": 0.013304546360919387,
                    "success_improvement": 0.0,
                    "time_improvement": 4.100162341356848,
                    "length_improvement": -2.3177061797402922,
                    "smoothness_improvement": 69.23284767143511,
                    "objective_score": 0.1855892329200547
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "A simplified bidirectional RRT planner that grows two trees from start and goal positions, alternately extending each tree towards random collision-free samples using fixed step sizes. The planner attempts to connect the trees incrementally when new nodes are added. Both node and edge collision checks are performed. The path is constructed once the two trees connect, ensuring feasible, relatively efficient paths with minimal complexity for better generalization.",
          "planning_mechanism": "class Node and Planner with plan(map) method below",
          "code": "class Node:\n    def __init__(self, position, parent=None):\n        self.position = position\n        self.parent = parent\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=3000, step_size=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map):\n        bounds = map.size\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start)]\n        goal_tree = [Node(goal)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        for i in range(self.max_iter):\n            tree_a, tree_b = (start_tree, goal_tree) if i % 2 == 0 else (goal_tree, start_tree)\n            sample = self._sample_free(bounds, obstacles, is_3d)\n            new_node = self._extend(tree_a, sample, obstacles, is_3d, nodes, edges)\n            if new_node:\n                connected_node = self._connect(tree_b, new_node, obstacles, is_3d, nodes, edges)\n                if connected_node:\n                    path_a = new_node.path_from_root()\n                    path_b = connected_node.path_from_root()\n                    if path_a[-1] == path_b[-1]:\n                        full_path = path_a + path_b[-2::-1]\n                    else:\n                        full_path = path_a + path_b[::-1]\n                    return PlannerResult(True, full_path, nodes, edges)\n        return PlannerResult(False, [], nodes, edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        import random\n        while True:\n            if is_3d:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(3))\n            else:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(2))\n            if not self._in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def _extend(self, tree, target, obstacles, is_3d, nodes, edges):\n        nearest = self._nearest(tree, target)\n        new_pos = self._steer(nearest.position, target)\n        if self._valid(nearest.position, new_pos, obstacles, is_3d):\n            new_node = Node(new_pos, nearest)\n            nearest.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest, new_node))\n            return new_node\n        return None\n\n    def _connect(self, tree, target_node, obstacles, is_3d, nodes, edges):\n        import math\n        nearest = self._nearest(tree, target_node.position)\n        while True:\n            new_pos = self._steer(nearest.position, target_node.position)\n            if not self._valid(nearest.position, new_pos, obstacles, is_3d):\n                return None\n            new_node = Node(new_pos, nearest)\n            nearest.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest, new_node))\n            if self._dist(new_node.position, target_node.position) <= self.step_size:\n                if not self._valid(new_node.position, target_node.position, obstacles, is_3d):\n                    return None\n                final_node = Node(target_node.position, new_node)\n                new_node.add_child(final_node)\n                tree.append(final_node)\n                nodes.append(final_node)\n                edges.append((new_node, final_node))\n                return final_node\n            nearest = new_node\n\n    def _nearest(self, tree, point):\n        return min(tree, key=lambda node: self._dist(node.position, point))\n\n    def _steer(self, start, goal):\n        dist = self._dist(start, goal)\n        if dist <= self.step_size:\n            return goal\n        ratio = self.step_size / dist\n        return tuple(start[d] + ratio * (goal[d] - start[d]) for d in range(len(start)))\n\n    def _valid(self, from_pos, to_pos, obstacles, is_3d):\n        return (not self._in_obstacle(to_pos, obstacles, is_3d)) and (not self._edge_in_obstacle(from_pos, to_pos, obstacles, is_3d))\n\n    def _in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x,y,z,w,h,d = obs\n                px,py,pz = pos\n                if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                    return True\n            else:\n                x,y,w,h = obs\n                px,py = pos\n                if x <= px <= x+w and y <= py <= y+h:\n                    return True\n        return False\n\n    def _edge_in_obstacle(self, p1, p2, obstacles, is_3d, resolution=1.0):\n        dist = self._dist(p1, p2)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps+1):\n            interp = tuple(p1[d] + (p2[d] - p1[d]) * i/steps for d in range(len(p1)))\n            if self._in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _dist(self, a, b):\n        return sum((a[d]-b[d])**2 for d in range(len(a)))**0.5",
          "objective": -15.03779,
          "time_improvement": 55.0,
          "length_improvement": -3.0,
          "smoothness_improvement": 63.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.007532596588134766,
                    "num_nodes_avg": 83.5,
                    "path_length_avg": 189.84030889041793,
                    "smoothness_avg": 0.010321372451574455,
                    "success_improvement": 0.0,
                    "time_improvement": 71.30747427853201,
                    "length_improvement": -4.054481515036774,
                    "smoothness_improvement": 61.55189208615482,
                    "objective_score": 19.267312834968312
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.04050443172454834,
                    "num_nodes_avg": 246.8,
                    "path_length_avg": 304.88351138240876,
                    "smoothness_avg": 0.006376895060333369,
                    "success_improvement": 0.0,
                    "time_improvement": 75.47267549511115,
                    "length_improvement": -1.778891684747648,
                    "smoothness_improvement": 64.08210299423538,
                    "objective_score": 21.89487815265593
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.04095637798309326,
                    "num_nodes_avg": 217.6,
                    "path_length_avg": 155.40404903932387,
                    "smoothness_avg": 0.01277627099031739,
                    "success_improvement": 0.0,
                    "time_improvement": 18.552668011925263,
                    "length_improvement": -3.2119698263207472,
                    "smoothness_improvement": 62.513223950609444,
                    "objective_score": 3.951184627538178
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "initial",
          "algorithm_description": "This algorithm is a bidirectional extension of RRT* that grows two trees from start and goal while optimizing paths via rewiring. It combines RRT*\u2018s asymptotic optimality with RRT-Connect\u2019s fast convergence through connection attempts between the trees.",
          "planning_mechanism": "The planner alternates growing two trees with sampling, extension, and rewiring. After each extension, it attempts to connect both trees. When connection is successful, a rewired optimal path is extracted across both trees.",
          "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, radius: float = 10.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.radius = radius\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n        nodes = []\n        edges = []\n        success_state = False\n        extracted_path = []\n\n        for iter in range(self.max_iter):\n            rand = self._sample_free(bounds, obstacles, is_3d)\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest = self._nearest(tree_a, rand)\n                new_pos = self._steer(nearest.position, rand, self.step_size)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                    continue\n\n                new_node = Node(new_pos)\n                near_nodes = self._near(tree_a, new_pos, self.radius)\n                min_cost = nearest.cost + self._distance(nearest.position, new_pos)\n                min_parent = nearest\n\n                for near in near_nodes:\n                    cost = near.cost + self._distance(near.position, new_pos)\n                    if cost < min_cost and not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d):\n                        min_cost = cost\n                        min_parent = near\n\n                new_node.parent = min_parent\n                new_node.cost = min_cost\n                min_parent.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((min_parent, new_node))\n\n                for near in near_nodes:\n                    if near == min_parent:\n                        continue\n                    new_cost = new_node.cost + self._distance(new_node.position, near.position)\n                    if new_cost < near.cost and not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                        if near.parent:\n                            edges.remove((near.parent, near))\n                        near.parent = new_node\n                        near.cost = new_cost\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n\n                connect_node = self._nearest(tree_b, new_node.position)\n                if self._distance(new_node.position, connect_node.position) < self.step_size and not self._is_edge_in_obstacle(new_node.position, connect_node.position, obstacles, is_3d):\n                    success_state = True\n                    extracted_path = self._extract_path(new_node, connect_node)\n                    return PlannerResult(True, extracted_path, start_tree + goal_tree, edges)\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        while True:\n            point = tuple(random.uniform(0, bounds[i]) for i in range(3 if is_3d else 2))\n            if not self._is_in_obstacle(point, obstacles, is_3d):\n                return point\n\n    def _nearest(self, tree, point):\n        return min(tree, key=lambda node: self._distance(node.position, point))\n\n    def _near(self, tree, point, radius):\n        return [node for node in tree if self._distance(node.position, point) <= radius]\n\n    def _steer(self, from_pos, to_pos, step_size):\n        dist = self._distance(from_pos, to_pos)\n        if dist <= step_size:\n            return to_pos\n        ratio = step_size / dist\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n    def _extract_path(self, node_a, node_b):\n        path_a = []\n        while node_a:\n            path_a.append(node_a.position)\n            node_a = node_a.parent\n        path_b = []\n        while node_b:\n            path_b.append(node_b.position)\n            node_b = node_b.parent\n        return list(reversed(path_a)) + path_b\n\n    def _distance(self, a, b):\n        return math.dist(a, b)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = self._distance(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n    ",
          "objective": -14.623200909903078,
          "time_improvement": 26.0,
          "length_improvement": 10.0,
          "smoothness_improvement": 172.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.01557013988494873,
                    "num_nodes_avg": 154.3,
                    "path_length_avg": 176.4019709606193,
                    "smoothness_avg": 0.016468810147838416,
                    "success_improvement": 0.0,
                    "time_improvement": 40.69154853726605,
                    "length_improvement": 3.3112844483772665,
                    "smoothness_improvement": 157.7726414073074,
                    "objective_score": 14.983098437242711
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.019739508628845215,
                    "num_nodes_avg": 283.4,
                    "path_length_avg": 260.814162084563,
                    "smoothness_avg": 0.010965222085418455,
                    "success_improvement": 0.0,
                    "time_improvement": 88.04680591498561,
                    "length_improvement": 12.9327255767608,
                    "smoothness_improvement": 182.14306218804825,
                    "objective_score": 35.084392431492404
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.07533800601959229,
                    "num_nodes_avg": 439.2,
                    "path_length_avg": 130.82946919354052,
                    "smoothness_avg": 0.021737514839812764,
                    "success_improvement": 0.0,
                    "time_improvement": -49.81987885086595,
                    "length_improvement": 13.109295991506725,
                    "smoothness_improvement": 176.49958426597442,
                    "objective_score": -6.197888139025877
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "A simplified bidirectional RRT* planner that alternately grows two trees from start and goal using fixed step-size steering, nearest neighbor connection, and local rewiring with a fixed radius. The algorithm attempts to connect the two trees when nodes are nearby and extracts the combined path. After finding a path, a simple shortcutting step reduces unnecessary waypoints to improve smoothness and path length. This streamlined version reduces overhead while preserving feasible, short, and smooth paths.",
          "planning_mechanism": "A bidirectional RRT* variant that grows two trees alternately by sampling points, steering from nearest nodes, rewiring neighbors within a fixed radius to improve costs, and attempts to connect the trees when close. Upon connection, it extracts and shortcuts the path for quality.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\nclass Planner:\n    def __init__(self, max_iter=2000, step_size=5.0, radius=15.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.radius = radius\n\n    def plan(self, map):\n        bounds = map.size\n        start = Node(map.start)\n        goal = Node(map.goal)\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = dim == 3\n\n        tree_start = [start]\n        tree_goal = [goal]\n\n        def dist(a, b):\n            return sum((a[i]-b[i])**2 for i in range(dim))**0.5\n\n        def in_obstacle(p):\n            if not obstacles:\n                return False\n            if is_3d:\n                x,y,z = p\n                for ox, oy, oz, w, h, d in obstacles:\n                    if ox <= x <= ox+w and oy <= y <= oy+h and oz <= z <= oz+d:\n                        return True\n            else:\n                x,y = p\n                for ox, oy, w, h in obstacles:\n                    if ox <= x <= ox+w and oy <= y <= oy+h:\n                        return True\n            return False\n\n        def collision_free(frm, to):\n            d = dist(frm, to)\n            steps = max(1, int(d))\n            for i in range(steps + 1):\n                interp = tuple(frm[j] + (to[j]-frm[j]) * i/steps for j in range(dim))\n                if in_obstacle(interp):\n                    return False\n            return True\n\n        import random\n\n        def sample_free():\n            while True:\n                p = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not in_obstacle(p):\n                    return p\n\n        def steer(frm, to):\n            d = dist(frm, to)\n            if d <= self.step_size:\n                return to\n            ratio = self.step_size / d\n            return tuple(frm[i] + (to[i]-frm[i]) * ratio for i in range(dim))\n\n        def nearest(tree, point):\n            best = tree[0]\n            best_d = dist(best.position, point)\n            for node in tree:\n                d = dist(node.position, point)\n                if d < best_d:\n                    best, best_d = node, d\n            return best\n\n        def near_nodes(tree, point):\n            return [node for node in tree if dist(node.position, point) <= self.radius]\n\n        def add_node(tree, pos):\n            near = near_nodes(tree, pos)\n            min_cost, min_parent = None, None\n            for node in near:\n                if collision_free(node.position, pos):\n                    c = node.cost + dist(node.position, pos)\n                    if min_cost is None or c < min_cost:\n                        min_cost, min_parent = c, node\n            if min_parent is None:\n                min_parent = nearest(tree, pos)\n                if not collision_free(min_parent.position, pos):\n                    return None\n                min_cost = min_parent.cost + dist(min_parent.position, pos)\n            new_node = Node(pos, parent=min_parent, cost=min_cost)\n            min_parent.add_child(new_node)\n            tree.append(new_node)\n            rewire(new_node, tree)\n            return new_node\n\n        def rewire(new_node, tree):\n            for node in near_nodes(tree, new_node.position):\n                if node is new_node.parent:\n                    continue\n                if collision_free(new_node.position, node.position):\n                    c = new_node.cost + dist(new_node.position, node.position)\n                    if c + 1e-9 < node.cost:\n                        if node.parent:\n                            try:\n                                node.parent.children.remove(node)\n                            except ValueError:\n                                pass\n                        node.parent = new_node\n                        node.cost = c\n                        new_node.children.append(node)\n\n        def extract_path(node):\n            path = []\n            while node:\n                path.append(node.position)\n                node = node.parent\n            return path[::-1]\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            shortened = [path[0]]\n            i = 0\n            while i < len(path) - 1:\n                j = len(path) - 1\n                while j > i + 1:\n                    if collision_free(path[i], path[j]):\n                        break\n                    j -= 1\n                shortened.append(path[j])\n                i = j\n            return shortened\n\n        success = False\n        best_path = []\n        best_cost = float('inf')\n\n        for i in range(self.max_iter):\n            rand_pos = sample_free()\n            tree_a, tree_b = (tree_start, tree_goal) if i % 2 == 0 else (tree_goal, tree_start)\n            nearest_node = nearest(tree_a, rand_pos)\n            new_pos = steer(nearest_node.position, rand_pos)\n            if in_obstacle(new_pos):\n                continue\n            new_node = add_node(tree_a, new_pos)\n            if new_node is None:\n                continue\n            nearest_to_new = nearest(tree_b, new_node.position)\n            if dist(new_node.position, nearest_to_new.position) <= self.step_size:\n                if collision_free(new_node.position, nearest_to_new.position):\n                    connector = Node(nearest_to_new.position, parent=new_node,\n                                     cost=new_node.cost + dist(new_node.position, nearest_to_new.position))\n                    new_node.add_child(connector)\n                    tree_a.append(connector)\n                    path_start = extract_path(connector if tree_a is tree_start else nearest_to_new)\n                    path_goal = extract_path(nearest_to_new if tree_a is tree_start else connector)\n                    combined = path_start + path_goal[::-1][1:]\n                    shortcut = shortcut_path(combined)\n                    cost = sum(dist(shortcut[i], shortcut[i+1]) for i in range(len(shortcut)-1))\n                    if cost < best_cost:\n                        best_cost = cost\n                        best_path = shortcut\n                        success = True\n                    break\n\n        return PlannerResult(success, best_path, tree_start + tree_goal, [])",
          "objective": -14.56634,
          "time_improvement": -11.0,
          "length_improvement": 19.0,
          "smoothness_improvement": 1357.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.035758161544799806,
                    "num_nodes_avg": 95.1,
                    "path_length_avg": 158.08045278022354,
                    "smoothness_avg": 0.0437108561114864,
                    "success_improvement": 0.0,
                    "time_improvement": -36.20694509151112,
                    "length_improvement": 13.353598886086381,
                    "smoothness_improvement": 584.1698177880498,
                    "objective_score": 0.0709248931387414
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.14818284511566163,
                    "num_nodes_avg": 270.9,
                    "path_length_avg": 229.20584772072934,
                    "smoothness_avg": 0.08798497858952058,
                    "success_improvement": 0.0,
                    "time_improvement": 10.268368831187576,
                    "length_improvement": 23.484490706292497,
                    "smoothness_improvement": 2163.9168721268857,
                    "objective_score": 27.990789433766196
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.053970956802368165,
                    "num_nodes_avg": 154.9,
                    "path_length_avg": 122.40981172898974,
                    "smoothness_avg": 0.1118739121743925,
                    "success_improvement": 0.0,
                    "time_improvement": -7.328593319729027,
                    "length_improvement": 18.70123157845707,
                    "smoothness_improvement": 1323.0279051850484,
                    "objective_score": 15.637300477080775
               }
          ],
          "success_rate": 1.0
     }
]