{
     "operator": "e1",
     "algorithm_description": "A bidirectional incremental Rapid Random Tree with adaptive goal biasing and dynamic rewiring radius, integrating lazy collision checks and a priority queue driven expansion focused on nodes with lower estimated total cost (cost-to-come plus heuristic to goal). The Planner alternates tree expansions, uses informed sampling once a solution is found to prioritize promising regions, and performs dynamic rewiring within an adaptive radius decreasing over iterations to refine paths and reduce unnecessary rewiring overhead. The search employs lazy collision checks by postponing full edge validations until candidate connections are promising, improving efficiency. Path shortcutting post-processing is applied to enhance smoothness and reduce length, while maintaining collision-free guarantees.",
     "planning_mechanism": "A bidirectional, anytime planner that grows two trees from start and goal nodes by sampling either uniform or informed ellipsoidal regions based on current best path cost. The planner uses a priority-driven node expansion strategy prioritizing nodes with lowest estimated total cost, applies adaptive rewiring radius and lazy collision checking to efficiently rewire neighbor nodes only when beneficial, and incrementally attempts to connect the two trees. Upon connection, the algorithm extracts the combined path, applies shortcutting to smooth it, and returns it as the solution. The adaptive rewiring radius gradually decreases to focus optimization near the path, balancing computation and improvement for faster convergence and smoother paths.",
     "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost  # cost-to-come\n        self.children = []\n        self.id = id(self)  # unique identifier for potential bookkeeping\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=4000, step_size=5.0, goal_sample_rate=0.15, initial_neighbor_radius=25.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.initial_neighbor_radius = initial_neighbor_radius\n\n    def plan(self, map):\n        bounds = map.size\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        import random\n        import math\n        import heapq\n\n        # Heuristic function for A*-like priority: Euclidean distance to goal\n        def heuristic(p):\n            return sum((p[d] - goal[d]) ** 2 for d in range(dim)) ** 0.5\n\n        # Distance between two points\n        def dist(a, b):\n            return sum((a[d] - b[d]) ** 2 for d in range(dim)) ** 0.5\n\n        # Collision check for point in obstacles\n        def in_obstacle(pt):\n            if is_3d:\n                px, py, pz = pt\n                for obs in obstacles:\n                    ox, oy, oz, w, h, d = obs\n                    if ox <= px <= ox + w and oy <= py <= oy + h and oz <= pz <= oz + d:\n                        return True\n            else:\n                px, py = pt\n                for obs in obstacles:\n                    ox, oy, w, h = obs\n                    if ox <= px <= ox + w and oy <= py <= oy + h:\n                        return True\n            return False\n\n        # Edge collision check by discretizing line at resolution 1.0 units\n        def edge_in_obstacle(p1, p2):\n            distance = dist(p1, p2)\n            steps = max(1, int(distance / 1.0))\n            for i in range(steps + 1):\n                interp = tuple(p1[d] + (p2[d] - p1[d]) * (i / steps) for d in range(dim))\n                if in_obstacle(interp):\n                    return True\n            return False\n\n        # Steer from start towards goal at maximum step_size\n        def steer(start_pt, goal_pt):\n            d = dist(start_pt, goal_pt)\n            if d <= self.step_size:\n                return goal_pt\n            ratio = self.step_size / d\n            return tuple(start_pt[d_] + ratio * (goal_pt[d_] - start_pt[d_]) for d_ in range(dim))\n\n        # Random uniform sample in bounds avoiding obstacles\n        def sample_uniform():\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not in_obstacle(pt):\n                    return pt\n\n        # Informed sampling within prolate hyperspheroid about start and goal for bidirectional searching\n        def sample_informed(c_best):\n            if c_best == float('inf'):\n                return sample_uniform()\n            c_min = dist(start, goal)\n            if c_best < c_min:\n                return sample_uniform()\n            center = tuple((start[d] + goal[d]) * 0.5 for d in range(dim))\n            a1 = [(goal[d] - start[d]) / c_min for d in range(dim)]\n            # Sample unit ball\n            while True:\n                x_ball = [random.gauss(0, 1) for _ in range(dim)]\n                norm = math.sqrt(sum(x ** 2 for x in x_ball))\n                if norm <= 1 and norm > 0:\n                    unit = [x / norm for x in x_ball]\n                    r1 = c_best / 2.0\n                    r2_temp = c_best ** 2 - c_min ** 2\n                    r2 = math.sqrt(r2_temp) / 2.0 if r2_temp > 0 else 0.0\n                    # 2D rotation matrix to align ellipse axis\n                    if dim == 2:\n                        angle = math.atan2(a1[1], a1[0])\n                        cos_ang = math.cos(angle)\n                        sin_ang = math.sin(angle)\n                        x_ell = r1 * unit[0]\n                        y_ell = r2 * unit[1]\n                        px = center[0] + cos_ang * x_ell - sin_ang * y_ell\n                        py = center[1] + sin_ang * x_ell + cos_ang * y_ell\n                        pt = (px, py)\n                    else:\n                        # 3D approximation: scale x by r1, y,z by r2 and clamp\n                        pt_candidate = [center[d] + (r1 * unit[0] if d == 0 else r2 * unit[d]) for d in range(dim)]\n                        pt = tuple(max(0, min(pt_candidate[d], bounds[d])) for d in range(dim))\n                    if all(0 <= pt[d] <= bounds[d] for d in range(dim)) and not in_obstacle(pt):\n                        return pt\n\n        # Node priority queue helper by f = cost + heuristic\n        class PQ:\n            def __init__(self):\n                self.heap = []\n                self.entry_finder = {}\n                self.REMOVED = '<removed>'\n\n            def add_node(self, node, priority):\n                if node.id in self.entry_finder:\n                    self.remove_node(node)\n                entry = [priority, node.id, node]\n                self.entry_finder[node.id] = entry\n                heapq.heappush(self.heap, entry)\n\n            def remove_node(self, node):\n                entry = self.entry_finder.pop(node.id)\n                entry[-1] = self.REMOVED\n\n            def pop_node(self):\n                while self.heap:\n                    priority, node_id, node = heapq.heappop(self.heap)\n                    if node is not self.REMOVED:\n                        del self.entry_finder[node_id]\n                        return node\n                return None\n\n            def empty(self):\n                return not self.entry_finder\n\n        # Find nearest neighbor by Euclidean distance\n        def nearest(tree_nodes, point):\n            best_node = None\n            best_dist = float('inf')\n            for node in tree_nodes:\n                d = dist(node.position, point)\n                if d < best_dist:\n                    best_dist = d\n                    best_node = node\n            return best_node, best_dist\n\n        # Find neighbors within radius\n        def neighbors(tree_nodes, node, radius):\n            result = []\n            for n in tree_nodes:\n                if dist(n.position, node.position) <= radius:\n                    result.append(n)\n            return result\n\n        # Shortcut path by removing unnecessary nodes with collision check\n        def shortcut_path(path):\n            if len(path) <= 2:\n                return path\n            shortened = [path[0]]\n            idx = 0\n            while idx < len(path) - 1:\n                next_idx = len(path) - 1\n                for j in range(len(path) - 1, idx, -1):\n                    if not edge_in_obstacle(path[idx], path[j]):\n                        next_idx = j\n                        break\n                shortened.append(path[next_idx])\n                idx = next_idx\n            return shortened\n\n        # Lazy connection: check edge collision only on candidate edges after cost improvement\n        def lazy_edge_check(p1, p2):\n            return not edge_in_obstacle(p1, p2)\n\n        # Add new node to tree with rewiring in adaptive radius\n        def add_node_with_rewire(tree_nodes, tree_pq, new_pos, best_cost, neighbor_radius):\n            near_node, dist_to_near = nearest(tree_nodes, new_pos)\n            if in_obstacle(new_pos) or edge_in_obstacle(near_node.position, new_pos):\n                return None\n\n            new_cost = near_node.cost + dist(near_node.position, new_pos)\n            new_node = Node(new_pos, parent=near_node, cost=new_cost)\n            near_node.add_child(new_node)\n            tree_nodes.append(new_node)\n            tree_pq.add_node(new_node, new_node.cost + heuristic(new_node.position))\n\n            # Find neighbors within adaptive radius for rewiring\n            nbrs = neighbors(tree_nodes, new_node, neighbor_radius)\n            for nbr in nbrs:\n                if nbr is new_node.parent:\n                    continue\n                # Cost through new_node\n                cost_through_new = new_node.cost + dist(new_node.position, nbr.position)\n                if cost_through_new + 1e-6 < nbr.cost:\n                    # Lazy check edge collision\n                    if lazy_edge_check(new_node.position, nbr.position):\n                        # Rewire nbr to new_node\n                        if nbr.parent:\n                            nbr.parent.remove_child(nbr)\n                        nbr.parent = new_node\n                        new_node.children.append(nbr)\n                        old_cost = nbr.cost\n                        nbr.cost = cost_through_new\n\n                        # Update costs downstream\n                        def dfs_update_costs(n):\n                            for c in n.children:\n                                new_c_cost = n.cost + dist(n.position, c.position)\n                                if new_c_cost + 1e-8 < c.cost:\n                                    c.cost = new_c_cost\n                                    dfs_update_costs(c)\n                        dfs_update_costs(nbr)\n                        tree_pq.add_node(nbr, nbr.cost + heuristic(nbr.position))\n            return new_node\n\n        # Attempt connecting tree_b to new_node_a with lazy collision checking\n        def try_connect(tree_nodes_b, tree_pq_b, node_a, best_cost):\n            near_node_b, dist_nb = nearest(tree_nodes_b, node_a.position)\n            if in_obstacle(node_a.position) or edge_in_obstacle(near_node_b.position, node_a.position):\n                return None\n            cost_b = near_node_b.cost + dist(near_node_b.position, node_a.position)\n            new_node_b = Node(node_a.position, parent=near_node_b, cost=cost_b)\n            near_node_b.add_child(new_node_b)\n            tree_nodes_b.append(new_node_b)\n            tree_pq_b.add_node(new_node_b, new_node_b.cost + heuristic(new_node_b.position))\n            return new_node_b\n\n        start_node = Node(start, cost=0.0)\n        goal_node = Node(goal, cost=0.0)\n        start_tree = [start_node]\n        goal_tree = [goal_node]\n\n        start_pq = PQ()\n        start_pq.add_node(start_node, heuristic(start))\n        goal_pq = PQ()\n        goal_pq.add_node(goal_node, heuristic(goal))\n\n        best_cost = float('inf')\n        best_path = None\n\n        # Adaptive neighbor radius decreases over iterations (but never below minimum 5)\n        def adaptive_radius(iteration):\n            r = self.initial_neighbor_radius * (0.95 ** (iteration // 500))\n            return max(5.0, r)\n\n        for i in range(self.max_iter):\n            # Alternate expansion trees\n            if i % 2 == 0:\n                tree_nodes_a, pq_a = start_tree, start_pq\n                tree_nodes_b, pq_b = goal_tree, goal_pq\n                tree_dir = \"start\"\n            else:\n                tree_nodes_a, pq_a = goal_tree, goal_pq\n                tree_nodes_b, pq_b = start_tree, start_pq\n                tree_dir = \"goal\"\n\n            neighbor_r = adaptive_radius(i)\n\n            # Sampling guided by best cost found\n            curr_best_cost = best_cost if best_cost != float('inf') else float('inf')\n            if random.random() < self.goal_sample_rate and tree_dir == \"start\":\n                sample_pt = goal\n                if in_obstacle(sample_pt):\n                    sample_pt = sample_uniform()\n            elif random.random() < self.goal_sample_rate and tree_dir == \"goal\":\n                sample_pt = start\n                if in_obstacle(sample_pt):\n                    sample_pt = sample_uniform()\n            else:\n                sample_pt = sample_informed(curr_best_cost)\n\n            # Add node in tree A with rewiring\n            new_node_a = add_node_with_rewire(tree_nodes_a, pq_a, sample_pt, curr_best_cost, neighbor_r)\n            if new_node_a is None:\n                continue\n\n            # Attempt connection to other tree B\n            new_node_b = try_connect(tree_nodes_b, pq_b, new_node_a, curr_best_cost)\n            if new_node_b:\n                total_cost = new_node_a.cost + new_node_b.cost\n                if total_cost + 1e-8 < best_cost:\n                    best_cost = total_cost\n\n                    # Extract full path: path from start tree root to new_node_a + reversed path from new_node_b to root\n                    path_start = new_node_a.path_from_root() if tree_dir == \"start\" else new_node_b.path_from_root()\n                    path_goal = new_node_b.path_from_root() if tree_dir == \"start\" else new_node_a.path_from_root()\n\n                    # Remove duplicate connection point if equal\n                    if path_start[-1] == path_goal[-1]:\n                        full_path = path_start + path_goal[-2::-1]\n                    else:\n                        full_path = path_start + path_goal[::-1]\n\n                    # Shortcut path improves smoothness and shortness\n                    full_path = shortcut_path(full_path)\n                    best_path = full_path\n\n                    # Return early on first improvement (anytime)\n                    return PlannerResult(success=True, path=best_path, nodes=start_tree + goal_tree, edges=[])\n\n        # If no path found after max_iter\n        return PlannerResult(success=False, path=[], nodes=start_tree + goal_tree, edges=[])",
     "objective": -32.75208,
     "time_improvement": 72.0,
     "length_improvement": 1.0,
     "smoothness_improvement": 2162.0,
     "other_inf": [
          {
               "map_id": 0,
               "success_rate": 1.0,
               "time_avg": 0.017874813079833983,
               "num_nodes_avg": 60.2,
               "path_length_avg": 178.46134122599636,
               "smoothness_avg": 0.10095412748742794,
               "success_improvement": 0.0,
               "time_improvement": 31.912783585485005,
               "length_improvement": 2.1825109731139785,
               "smoothness_improvement": 1480.1513205749102,
               "objective_score": 18.28409826238844
          },
          {
               "map_id": 1,
               "success_rate": 1.0,
               "time_avg": 0.00749971866607666,
               "num_nodes_avg": 54.1,
               "path_length_avg": 269.8000195347711,
               "smoothness_avg": 0.1332598514245687,
               "success_improvement": 0.0,
               "time_improvement": 95.45857019623979,
               "length_improvement": 9.932987716315523,
               "smoothness_improvement": 3328.871960345464,
               "objective_score": 51.24172349038857
          },
          {
               "map_id": 2,
               "success_rate": 1.0,
               "time_avg": 0.006196403503417968,
               "num_nodes_avg": 55.0,
               "path_length_avg": 165.53671627025966,
               "smoothness_avg": 0.1398135054188176,
               "success_improvement": 0.0,
               "time_improvement": 87.67760827182315,
               "length_improvement": -9.941604935344571,
               "smoothness_improvement": 1678.417468967884,
               "objective_score": 28.730406865179617
          }
     ],
     "success_rate": 1.0
}