[
    {
        "operator": "e2",
        "algorithm_description": "A hybrid bidirectional planner combining fast incremental exploration and post-path optimization with rewiring and informed sampling to improve efficiency, path length, success rate, and smoothness. It grows start and goal trees with RRT* style sampling, parent selection, and rewiring, attempting connection at each step. Once a valid path is found, informed sampling inside the ellipsoid between start and goal focuses search to optimize the path further. The final returned path is shortcut-smoothed to reduce unnecessary waypoints and sharp turns.",
        "planning_mechanism": "The planner alternates growing start and goal trees with RRT* expansions including best-parent selection and rewiring to improve path quality. Random samples are drawn uniformly initially, then inside an ellipsoid after first solution for focused optimization. Each extension tries to connect the two trees, and after the first connection the planner continues optimizing until iteration or improvement limits. Optionally, the output path is shortcut-smoothed to reduce length and increase smoothness.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True  # reserved for future collision checking updates\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        path.reverse()\n        return path\nclass Planner:\n    def __init__(self,\n                 max_iter=6000,\n                 step_size=4.0,\n                 neighbor_radius=None,\n                 post_opt_iters=600,\n                 max_no_improve=150,\n                 improve_tol=1e-5,\n                 time_limit_sec=25.0,\n                 shortcutting_trials=150):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.post_opt_iters = post_opt_iters\n        self.max_no_improve = max_no_improve\n        self.improve_tol = improve_tol\n        self.time_limit_sec = time_limit_sec\n        self.shortcutting_trials = shortcutting_trials\n        # neighbor radius factor for RRT*\n        self.gamma_rrt_star = 50.0\n        self.neighbor_radius = neighbor_radius  # if None will compute dynamically\n\n    def plan(self, map):\n        bounds = map.size\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        obstacles = map.obstacles\n\n        start_pos = map.start\n        goal_pos = map.goal\n\n        # Initialize data\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        best_cost = float('inf')\n        best_path = []\n        c_min = math.dist(start_pos, goal_pos)\n\n        found_solution = False\n        post_iter = 0\n        no_improve_count = 0\n\n        start_time = time.time()\n\n        def within_bounds(p):\n            return all(0.0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_p, to_p):\n            d = dist(from_p, to_p)\n            if d <= self.step_size:\n                return to_p\n            r = self.step_size / d\n            return tuple(from_p[i] + (to_p[i] - from_p[i]) * r for i in range(dim))\n\n        def neighbor_radius_fn(n_nodes):\n            if self.neighbor_radius is not None:\n                return self.neighbor_radius\n            if n_nodes < 2:\n                return self.step_size * 2.0\n            r_theory = self.gamma_rrt_star * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            maxr = max(bounds) * 0.25\n            return max(self.step_size * 2.0, min(r_theory, maxr))\n\n        def nearest(tree, pt):\n            mn = None\n            md = float(\"inf\")\n            for n in tree:\n                d = dist(n.position, pt)\n                if d < md:\n                    md = d\n                    mn = n\n            return mn\n\n        def near_nodes(tree, pos, radius):\n            result = []\n            r_sq = radius * radius\n            for n in tree:\n                d_sq = sum((n.position[i] - pos[i]) ** 2 for i in range(dim))\n                if d_sq <= r_sq:\n                    result.append(n)\n            return result\n\n        def edge_collision_free(p1, p2):\n            distance = dist(p1, p2)\n            steps = max(2, int(distance / 1.0))\n            for i in range(steps + 1):\n                ip = tuple(p1[d] + (p2[d] - p1[d]) * (i / steps) for d in range(dim))\n                if self._is_in_obstacle(ip, obstacles, is_3d):\n                    return False\n            return True\n\n        def collision_free(p):\n            return not self._is_in_obstacle(p, obstacles, is_3d)\n\n        def add_node_rrtstar(tree, pos):\n            r = neighbor_radius_fn(len(tree))\n            neigh = near_nodes(tree, pos, r)\n\n            candidate_parents = [n for n in neigh if edge_collision_free(n.position, pos)]\n            if not candidate_parents:\n                # fallback to nearest if no collision-free neighbors found\n                nnear = nearest(tree, pos)\n                if edge_collision_free(nnear.position, pos):\n                    parent = nnear\n                else:\n                    return None, []\n            else:\n                parent = min(candidate_parents, key=lambda n: n.cost + dist(n.position, pos))\n            new_cost = parent.cost + dist(parent.position, pos)\n            new_node = Node(pos, parent=None, cost=new_cost)\n            parent.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((parent, new_node))\n            return new_node, neigh\n\n        def rewire(node, neighbors):\n            for nb in neighbors:\n                if nb is node:\n                    continue\n                if not edge_collision_free(node.position, nb.position):\n                    continue\n                new_cost = node.cost + dist(node.position, nb.position)\n                if new_cost + 1e-12 < nb.cost:\n                    # reconnect neighbor via node\n                    if nb.parent:\n                        try:\n                            edges.remove((nb.parent, nb))\n                        except ValueError:\n                            pass\n                        if nb in nb.parent.children:\n                            nb.parent.children.remove(nb)\n                    node.add_child(nb)\n                    nb.cost = new_cost\n                    edges.append((node, nb))\n\n        def stitch_paths(node_start, node_goal):\n            path_start = node_start.path_from_root()\n            path_goal = node_goal.path_from_root()\n            # remove duplicated meeting node if any\n            if path_start and path_goal and path_start[-1] == path_goal[-1]:\n                merged = path_start + path_goal[-2::-1]\n            else:\n                merged = path_start + path_goal[::-1]\n            return merged\n\n        def path_cost(path):\n            c = 0.0\n            for i in range(len(path) - 1):\n                c += dist(path[i], path[i+1])\n            return c\n\n        def informed_sample(start, goal, c_best, c_min):\n            if c_best == float(\"inf\") or c_min < 1e-12:\n                return tuple(random.uniform(0.0, bounds[d]) for d in range(dim))\n            r1 = c_best / 2.0\n            r_other_sq = max(c_best * c_best - c_min * c_min, 0.0)\n            r_other = math.sqrt(r_other_sq) / 2.0\n            center = tuple((start[d] + goal[d]) / 2.0 for d in range(dim))\n            a1 = tuple((goal[d] - start[d]) / c_min for d in range(dim))\n\n            def sample_unit_ball(k):\n                while True:\n                    v = [random.gauss(0, 1) for _ in range(k)]\n                    norm_v = math.sqrt(sum(x * x for x in v))\n                    if norm_v > 1e-12:\n                        v = [x / norm_v for x in v]\n                        r = random.random() ** (1.0 / k)\n                        return tuple(v[i] * r for i in range(k))\n\n            u = sample_unit_ball(dim)\n\n            if dim == 2:\n                a2 = (-a1[1], a1[0])\n                basis = (a1, a2)\n                radii = (r1, r_other)\n            else:\n                ref = (1.0, 0.0, 0.0) if abs(a1[0]) < 0.9 else (0.0, 1.0, 0.0)\n                b2 = self._normalize(self._cross(a1, ref))\n                if self._norm(b2) < 1e-12:\n                    ref = (0.0, 0.0, 1.0)\n                    b2 = self._normalize(self._cross(a1, ref))\n                b3 = self._cross(a1, b2)\n                basis = (a1, b2, b3)\n                radii = (r1, r_other, r_other)\n\n            sample = []\n            for d in range(dim):\n                val = center[d]\n                for i in range(dim):\n                    val += basis[i][d] * radii[i] * u[i]\n                # Clamp inside bounds\n                val = max(0.0, min(bounds[d], val))\n                sample.append(val)\n            return tuple(sample)\n\n        def smooth_path(path, max_trials):\n            if len(path) < 3:\n                return path\n            new_path = path[:]\n            for _ in range(max_trials):\n                if len(new_path) < 3:\n                    break\n                i = random.randint(0, len(new_path) - 3)\n                j = random.randint(i+2, len(new_path) - 1)\n                if edge_collision_free(new_path[i], new_path[j]):\n                    # remove intermediate points between i and j\n                    new_path = new_path[:i+1] + new_path[j:]\n            return new_path\n\n        def try_connect_trees(new_node, other_tree, other_tree_nodes):\n            nearest_other = nearest(other_tree, new_node.position)\n            if dist(nearest_other.position, new_node.position) <= self.step_size:\n                if edge_collision_free(new_node.position, nearest_other.position):\n                    # Connect by creating new node optionally in other_tree for symmetry\n                    return new_node, nearest_other\n            # Otherwise try incremental steer connection on other tree side\n            curr = nearest_other\n            while True:\n                step_pos = steer(curr.position, new_node.position)\n                if not within_bounds(step_pos) or not collision_free(step_pos):\n                    break\n                if not edge_collision_free(curr.position, step_pos):\n                    break\n                new_other_node, _ = add_node_rrtstar(other_tree, step_pos)\n                if new_other_node is None:\n                    break\n                rewire(new_other_node, near_nodes(other_tree, step_pos, neighbor_radius_fn(len(other_tree))))\n                curr = new_other_node\n                if dist(curr.position, new_node.position) <= self.step_size:\n                    if edge_collision_free(curr.position, new_node.position):\n                        # Create virtual connection node aligned with new_node\n                        return new_node, curr\n            return None, None\n\n        iteration = 0\n        while iteration < self.max_iter:\n            if time.time() - start_time > self.time_limit_sec:\n                break\n            side_toggle = iteration % 2\n            if side_toggle == 0:\n                grow_tree, other_tree = start_tree, goal_tree\n                grow_is_start = True\n            else:\n                grow_tree, other_tree = goal_tree, start_tree\n                grow_is_start = False\n\n            # Sample either uniformly or informed if solution known\n            sample = informed_sample(start_pos, goal_pos, best_cost, c_min) if found_solution else \\\n                     tuple(random.uniform(0.0, bounds[d]) for d in range(dim))\n\n            if not within_bounds(sample) or not collision_free(sample):\n                if found_solution:\n                    post_iter += 1\n                    no_improve_count += 1\n                    if post_iter >= self.post_opt_iters or no_improve_count >= self.max_no_improve:\n                        break\n                iteration += 1\n                continue\n\n            nearest_node = nearest(grow_tree, sample)\n            new_pos = steer(nearest_node.position, sample)\n            if not within_bounds(new_pos) or not collision_free(new_pos):\n                if found_solution:\n                    post_iter += 1\n                    no_improve_count += 1\n                    if post_iter >= self.post_opt_iters or no_improve_count >= self.max_no_improve:\n                        break\n                iteration += 1\n                continue\n            if not edge_collision_free(nearest_node.position, new_pos):\n                if found_solution:\n                    post_iter += 1\n                    no_improve_count += 1\n                    if post_iter >= self.post_opt_iters or no_improve_count >= self.max_no_improve:\n                        break\n                iteration += 1\n                continue\n\n            new_node, neighbors = add_node_rrtstar(grow_tree, new_pos)\n            if new_node is None:\n                if found_solution:\n                    post_iter += 1\n                    no_improve_count += 1\n                    if post_iter >= self.post_opt_iters or no_improve_count >= self.max_no_improve:\n                        break\n                iteration += 1\n                continue\n\n            rewire(new_node, neighbors)\n\n            # Attempt to connect trees via new_node\n            n1, n2 = try_connect_trees(new_node, other_tree, nodes)\n            if n1 and n2:\n                candidate_path = stitch_paths(n1, n2)\n                candidate_cost = path_cost(candidate_path)\n\n                if candidate_cost + self.improve_tol < best_cost:\n                    best_cost = candidate_cost\n                    best_path = candidate_path\n                    found_solution = True\n                    no_improve_count = 0\n                    post_iter = 0\n                else:\n                    if found_solution:\n                        no_improve_count += 1\n                        post_iter += 1\n\n                if found_solution and (post_iter >= self.post_opt_iters or no_improve_count >= self.max_no_improve):\n                    break\n            else:\n                if found_solution:\n                    post_iter += 1\n                    no_improve_count += 1\n                    if post_iter >= self.post_opt_iters or no_improve_count >= self.max_no_improve:\n                        break\n\n            iteration += 1\n\n        if found_solution and best_path:\n            smooth = smooth_path(best_path, self.shortcutting_trials)\n        else:\n            smooth = []\n\n        return PlannerResult(\n            success=found_solution,\n            path=smooth if smooth else best_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    # ---------------- Collision Helpers ----------------\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    # ----------------------------------------------------------------\n    # Vector math utilities\n    # ----------------------------------------------------------------\n    def _cross(self, a, b):\n        ax, ay, az = a\n        bx, by, bz = b\n        return (ay * bz - az * by, az * bx - ax * bz, ax * by - ay * bx)\n\n    def _norm(self, v):\n        return math.sqrt(sum(x * x for x in v))\n\n    def _normalize(self, v):\n        n = self._norm(v)\n        if n < 1e-12:\n            return v\n        return tuple(x / n for x in v)",
        "objective": 30.8005,
        "time_improvement": -164.0,
        "length_improvement": 20.0,
        "smoothness_improvement": 1288.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.0989145278930664,
                "num_nodes_avg": 208.6,
                "path_length_avg": 152.44922059390572,
                "smoothness_avg": 0.04405342963083721,
                "success_improvement": 0.0,
                "time_improvement": -276.7767996854121,
                "length_improvement": 16.440166479991422,
                "smoothness_improvement": 589.5318372761939,
                "objective_score": -70.2212808312478
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.12343411445617676,
                "num_nodes_avg": 460.7,
                "path_length_avg": 228.4633553814897,
                "smoothness_avg": 0.08673156530289851,
                "success_improvement": 0.0,
                "time_improvement": 25.25488072937533,
                "length_improvement": 23.7323560205877,
                "smoothness_improvement": 2131.665645465001,
                "objective_score": 32.474206058490225
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.17110490798950195,
                "num_nodes_avg": 411.5,
                "path_length_avg": 121.1728155761859,
                "smoothness_avg": 0.09766590253227968,
                "success_improvement": 0.0,
                "time_improvement": -240.2653977742545,
                "length_improvement": 19.52278552372241,
                "smoothness_improvement": 1142.3030712635552,
                "objective_score": -54.65443266172513
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "m1",
        "algorithm_description": "This algorithm introduces an enhanced informed sampling, tree pruning, and adaptive neighborhood to improve planning speed, path length, and smoothness in a unidirectional RRT* variant with post-optimization. It prunes the tree to remove unreachable nodes, dynamically adjusts the search neighborhood radius based on the number of nodes, and smoothens the final path with shortcutting to better reduce unnecessary zigzags and length.",
        "planning_mechanism": "The planner initially explores the entire map by uniform sampling, then once a feasible path is found, it switches to informed sampling within the ellipsoidal region defined by start, goal, and best path cost. It prunes nodes outside this region to focus search, dynamically calculates rewiring radius for better efficiency, performs rewiring to optimize locally, and finally applies shortcut-based path smoothing for improved smoothness and length.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=4000, step_size=5.0, improve_tol=1e-6, max_no_improve=100, post_opt_iters=300):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.improve_tol = improve_tol\n        self.max_no_improve = max_no_improve\n        self.post_opt_iters = post_opt_iters\n\n    def plan(self, map):\n        bounds = map.size\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        import math\n        import random\n\n        root = Node(start)\n        tree = [root]\n        nodes = [root]\n        edges = []\n\n        best_goal_node = None\n        best_cost = float('inf')\n        c_min = math.dist(start, goal)\n        found_solution = False\n\n        no_improve = 0\n        post_opt_count = 0\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def in_ellipsoid(point, c_best, c_min, start, goal):\n            # Check if point is within the prolate hyperspheroid\n            from math import sqrt\n            center = [(s + g) / 2 for s, g in zip(start, goal)]\n            diff = [p - c for p, c in zip(point, center)]\n            a1 = [g - s for s, g in zip(start, goal)]\n            norm_a1 = math.sqrt(sum(x*x for x in a1))\n            if norm_a1 < 1e-12:\n                return True\n            a1_unit = [x / norm_a1 for x in a1]\n\n            # Rotation matrix C (only rotation needed to align a1 with first axis)\n            # For low dimension (2 or 3), we create C via Gram-Schmidt and SVD is avoided\n            # We use a simplified test: x_M = C^T (point - center)\n            # To simplify, project difference vector onto a1_unit axis and orthogonal directions\n            proj = sum(d*u for d, u in zip(diff, a1_unit))\n            ortho_sq = sum((d - proj*u)**2 for d, u in zip(diff, a1_unit))\n            if c_best == float('inf'):\n                return True\n            val = (proj/(c_best/2))**2 + (ortho_sq/((math.sqrt(c_best**2 - c_min**2)/2)**2) if c_best > c_min else 1e10)\n            return val <= 1.0\n\n        def sample():\n            if not found_solution or best_cost == float('inf'):\n                while True:\n                    pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not self._is_in_obstacle(pt, obstacles, is_3d):\n                        return pt\n            else:\n                # informed sampling in ellipsoid\n                while True:\n                    # Sample in unit ball\n                    import random as rnd\n                    import math as m\n                    from math import sqrt\n                    from random import uniform\n                    # Generate random point in unit ball\n                    while True:\n                        pt_ball = [uniform(-1,1) for _ in range(dim)]\n                        norm_pt = math.sqrt(sum(x*x for x in pt_ball))\n                        if 0 < norm_pt <= 1: break\n                    # Scale to unit hypersphere\n                    pt_ball = [x / norm_pt for x in pt_ball]\n                    radius = rnd.random() ** (1/dim)\n                    pt_ball = [x * radius for x in pt_ball]\n\n                    # Apply ellipsoid scaling and rotation approx: aligned with axis a1\n                    # Use eigenvalues: c_best/2 along a1 and sqrt(c_best^2-c_min^2)/2 others\n                    a1 = [g - s for s, g in zip(start, goal)]\n                    norm_a1 = sqrt(sum(x*x for x in a1))\n                    if norm_a1 < 1e-9:\n                        return tuple(start)\n                    a1_unit = [x / norm_a1 for x in a1]\n\n                    L = [c / 2 for c in [best_cost] + [math.sqrt(best_cost*best_cost - c_min*c_min)]*(dim - 1)]\n                    center = [(s + g)/2 for s, g in zip(start, goal)]\n                    # Construct point in ellipsoid: x_center + C*L*x_ball\n                    # Using simplified approx. C aligns first dim with a1_unit\n                    # Compute dot product along a1_unit\n                    x_at_axis = pt_ball[0] * L[0]\n                    ortho_comp = [pt_ball[i] * L[i] for i in range(1, dim)]\n                    result = [center[i] + a1_unit[i]*x_at_axis for i in range(dim)]\n                    # to add orthogonal components, find basis orthogonal to a1_unit\n                    # we can just approximate by summing orthogonal components to axes\n                    # For 2D: orthogonal vector\n                    if dim == 2:\n                        # orth vector\n                        o = [-a1_unit[1], a1_unit[0]]\n                        for i in range(dim):\n                            result[i] += ortho_comp[0]*o[i]\n                    elif dim == 3:\n                        # Create arbitrary orthonormal basis {a1_unit, u, v}\n                        # u = normalized cross product with z axis if not parallel\n                        z_axis = [0,0,1]\n                        cross = [a1_unit[1]*z_axis[2]-a1_unit[2]*z_axis[1],\n                                 a1_unit[2]*z_axis[0]-a1_unit[0]*z_axis[2],\n                                 a1_unit[0]*z_axis[1]-a1_unit[1]*z_axis[0]]\n                        norm_cross = math.sqrt(sum(x*x for x in cross))\n                        if norm_cross < 1e-6:\n                            # a1_unit parallel to z-axis, use x axis for u\n                            u = [1,0,0]\n                        else:\n                            u = [x / norm_cross for x in cross]\n                        # v = a1_unit cross u\n                        v = [a1_unit[1]*u[2] - a1_unit[2]*u[1],\n                             a1_unit[2]*u[0] - a1_unit[0]*u[2],\n                             a1_unit[0]*u[1] - a1_unit[1]*u[0]]\n                        for i in range(dim):\n                            result[i] += ortho_comp[0]*u[i] + ortho_comp[1]*v[i]\n                    # else dim >3: just ignore orthogonal components (rare)\n                    if all(0 <= result[d] <= bounds[d] for d in range(dim)) and not self._is_in_obstacle(tuple(result), obstacles, is_3d):\n                        return tuple(result)\n\n        def nearest(pt):\n            return min(tree, key=lambda n:n.cost + dist(n.position, pt))\n\n        def near(pt, n):\n            # adaptive radius heuristic for RRT*\n            gamma_rrt = 2.0 * (1 + 1/dim)**(1/dim) * ( ( (math.factorial(dim) * (4/3) )) )**(1/dim)\n            r = min(self.step_size*5, gamma_rrt*(math.log(n)/n)**(1.0/dim))\n            return [node for node in tree if dist(node.position, pt) <= r]\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * self.step_size / d for i in range(dim))\n\n        def collision_free_edge(p1, p2):\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d)\n\n        def prune_outside_ellipsoid():\n            nonlocal tree, nodes, edges, best_cost\n            if best_cost == float('inf'):\n                return\n            new_tree = []\n            nodes_set = set(tree)\n            allowed_nodes = []\n            # mark reachable from root prune nodes outside ellipsoid\n            for n in tree:\n                if in_ellipsoid(n.position, best_cost, c_min, start, goal):\n                    allowed_nodes.append(n)\n            # rebuild tree with allowed nodes and parents therein\n            allowed_set = set(allowed_nodes)\n            # forcibly remove nodes whose parents not in allowed nodes\n            queue = []\n            new_tree = []\n            for n in allowed_nodes:\n                p = n.parent\n                while p is not None and p not in allowed_set:\n                    p = p.parent\n                if p in allowed_set or p is None:\n                    new_tree.append(n)\n            tree.clear()\n            tree.extend(new_tree)\n\n        def shortcut_path(path):\n            # attempt simple path shortcutting to remove unnecessary bends\n            if len(path) < 3:\n                return path\n            shortened = [path[0]]\n            i = 0\n            while i < len(path) - 1:\n                j = len(path) - 1\n                while j > i + 1:\n                    if collision_free_edge(shortened[-1], path[j]):\n                        shortened.append(path[j])\n                        i = j\n                        break\n                    j -= 1\n                else:\n                    shortened.append(path[i+1])\n                    i += 1\n            return shortened\n\n        n = 1\n        for _ in range(self.max_iter):\n            x_rand = sample()\n            x_nearest = min(tree, key=lambda n_: dist(n_.position, x_rand))\n            x_new_pos = steer(x_nearest.position, x_rand)\n            if self._is_in_obstacle(x_new_pos, obstacles, is_3d):\n                continue\n            if not collision_free_edge(x_nearest.position, x_new_pos):\n                continue\n            near_nodes = near(x_new_pos, len(tree))\n\n            # Find best parent among near nodes for min cost\n            min_cost = x_nearest.cost + dist(x_nearest.position, x_new_pos)\n            best_parent = x_nearest\n            for node in near_nodes:\n                edge_cost = dist(node.position, x_new_pos)\n                c = node.cost + edge_cost\n                if c + self.improve_tol < min_cost and collision_free_edge(node.position, x_new_pos):\n                    min_cost = c\n                    best_parent = node\n\n            x_new = Node(x_new_pos)\n            best_parent.add_child(x_new)\n            x_new.cost = min_cost\n            tree.append(x_new)\n            nodes.append(x_new)\n            edges.append((best_parent, x_new))\n\n            # Rewire neighbors\n            for node in near_nodes:\n                if node is x_new or node is best_parent:\n                    continue\n                potential_cost = x_new.cost + dist(x_new.position, node.position)\n                if potential_cost + self.improve_tol < node.cost and collision_free_edge(x_new.position, node.position):\n                    prev_parent = node.parent\n                    if prev_parent:\n                        if (prev_parent, node) in edges:\n                            edges.remove((prev_parent, node))\n                        if node in prev_parent.children:\n                            prev_parent.children.remove(node)\n                    x_new.add_child(node)\n                    node.cost = potential_cost\n                    edges.append((x_new, node))\n\n            # Check connection direct to goal\n            if dist(x_new.position, goal) <= self.step_size and collision_free_edge(x_new.position, goal):\n                potential_cost = x_new.cost + dist(x_new.position, goal)\n                if potential_cost + self.improve_tol < best_cost:\n                    goal_node = Node(goal)\n                    x_new.add_child(goal_node)\n                    goal_node.cost = potential_cost\n                    tree.append(goal_node)\n                    nodes.append(goal_node)\n                    edges.append((x_new, goal_node))\n                    best_cost = potential_cost\n                    best_goal_node = goal_node\n                    found_solution = True\n                    no_improve = 0\n                    post_opt_count = 0\n                else:\n                    no_improve += 1\n                    post_opt_count += 1\n            else:\n                if found_solution:\n                    no_improve += 1\n                    post_opt_count += 1\n\n            # Periodically prune tree outside ellipsoid for best_cost\n            if found_solution and (_ % 250) == 0:\n                prune_outside_ellipsoid()\n\n            n += 1\n            if found_solution and (post_opt_count >= self.post_opt_iters or no_improve >= self.max_no_improve):\n                break\n\n        if found_solution and best_goal_node:\n            extracted_path = best_goal_node.path_from_root()\n            # Smooth path shortcutting to improve length & smoothness:\n            extracted_path = shortcut_path(extracted_path)\n        else:\n            extracted_path = []\n\n        return PlannerResult(True if found_solution else False, extracted_path, nodes, edges)\n\n    def _distance(self, a, b):\n        import math\n        return math.dist(a, b)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * i / steps for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
        "objective": 18.79497,
        "time_improvement": -121.0,
        "length_improvement": 13.0,
        "smoothness_improvement": 1893.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.05898122787475586,
                "num_nodes_avg": 510.2,
                "path_length_avg": 172.7134244349467,
                "smoothness_avg": 0.06581379164236674,
                "success_improvement": 0.0,
                "time_improvement": -124.66627252359639,
                "length_improvement": 5.3330352478584375,
                "smoothness_improvement": 930.1287561390558,
                "objective_score": -29.549416827668576
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.2983426332473755,
                "num_nodes_avg": 1301.1,
                "path_length_avg": 243.83195303851275,
                "smoothness_avg": 0.11834135251907138,
                "success_improvement": 0.0,
                "time_improvement": -80.6603936345688,
                "length_improvement": 18.601875762117196,
                "smoothness_improvement": 2945.008238146587,
                "objective_score": 1.6880485576326105
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.1290714979171753,
                "num_nodes_avg": 611.6,
                "path_length_avg": 126.843073163169,
                "smoothness_avg": 0.14976835208119793,
                "success_improvement": 0.0,
                "time_improvement": -156.6762408872638,
                "length_improvement": 15.756870423099286,
                "smoothness_improvement": 1805.0423837230148,
                "objective_score": -28.523538093704484
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "e2",
        "algorithm_description": "A Hybrid Bidirectional Informed RRT* with Adaptive Neighborhood and Smooth Path Post-processing. The planner alternates growing two asymptotically optimal trees from start and goal using informed sampling within ellipsoidal bounds after first solution. It uses an adaptive neighborhood radius for rewiring and best parent selection to improve path quality while ensuring collision-free incremental expansion. Upon connecting trees, the algorithm performs shortcut smoothing on the path to enhance smoothness and reduce length before returning the result. This combination accelerates convergence, improves path optimality, and produces smoother feasible paths efficiently.",
        "planning_mechanism": "The planner initializes two trees at start and goal, grows them iteratively by sampling points either uniformly or informed within an ellipsoid after first solution, selecting parents for new nodes based on minimal path cost, and rewires neighbors within a dynamically computed radius to optimize local subtrees. Trees attempt connection after new node insertion; a feasible connection yields a combined path which is then shortcut-smoothed to reduce unnecessary turns and path length. This hybrid approach balances exploration and exploitation, improves computation efficiency, and delivers practical high-quality solutions.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        path = []\n        n = self\n        while n:\n            path.append(n.position)\n            n = n.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=5.0, gamma=60.0, \n                 post_opt_iters=300, max_no_improve=100, time_limit_sec=30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.gamma = gamma\n        self.post_opt_iters = post_opt_iters\n        self.max_no_improve = max_no_improve\n        self.time_limit_sec = time_limit_sec\n\n    def plan(self, map):\n        import math\n        import random\n        import time\n\n        bounds = map.size\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        def within_bounds(p):\n            return all(0.0 <= p[d] <= bounds[d] for d in range(dim))\n\n        # Initialize trees and data containers\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        tree_a = [start_root]\n        tree_b = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        c_min = math.dist(start_pos, goal_pos)\n        best_cost = float(\"inf\")\n        best_path = []\n        found_solution = False\n        no_improve_count = 0\n        post_opt_count = 0\n        start_time = time.time()\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_p, to_p):\n            d = dist(from_p, to_p)\n            if d <= self.step_size:\n                return to_p\n            r = self.step_size / d\n            return tuple(from_p[i] + (to_p[i] - from_p[i]) * r for i in range(dim))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: dist(n.position, point))\n\n        def neighbor_radius(n_nodes):\n            if n_nodes < 2:\n                return self.step_size * 2.0\n            r = self.gamma * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            max_r = max(bounds) * 0.30\n            min_r = max(10.0, self.step_size * 2.0)\n            return max(min_r, min(max_r, r))\n\n        def near_nodes(tree, point, radius):\n            return [n for n in tree if dist(n.position, point) <= radius]\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    px, py = pos\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(a, b, resolution=1.0):\n            length = dist(a, b)\n            steps = max(1, int(length / resolution))\n            for i in range(steps + 1):\n                interp = tuple(a[d] + (b[d] - a[d]) * (i / steps) for d in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def sample_uniform():\n            while True:\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle(p):\n                    return p\n\n        def sample_unit_ball():\n            while True:\n                v = [random.gauss(0, 1) for _ in range(dim)]\n                nrm = math.sqrt(sum(x*x for x in v))\n                if nrm > 1e-12:\n                    v = [x / nrm for x in v]\n                    r = random.random() ** (1.0 / dim)\n                    return tuple(v[i]*r for i in range(dim))\n\n        # Informed sampling inside the ellipsoid (or uniform if no solution)\n        def sample_informed(c_best):\n            if not found_solution or c_best == float(\"inf\") or c_min <= 1e-12:\n                return sample_uniform()\n            r1 = c_best / 2.0\n            r_other_sq = max(c_best * c_best - c_min * c_min, 0.0)\n            r_other = math.sqrt(r_other_sq) / 2.0\n            center = tuple((start_pos[d] + goal_pos[d]) / 2.0 for d in range(dim))\n            unit_vec = tuple((goal_pos[d] - start_pos[d]) / c_min for d in range(dim))\n\n            # Construct orthonormal basis for the ellipsoid axes\n            if dim == 2:\n                # Perp vector in 2D\n                perp_vec = (-unit_vec[1], unit_vec[0])\n                basis = [unit_vec, perp_vec]\n                radii = [r1, r_other]\n            else:  # 3D\n                # Create two perpendicular vectors using cross products\n                def cross(u,v):\n                    return (u[1]*v[2]-u[2]*v[1], u[2]*v[0]-u[0]*v[2], u[0]*v[1]-u[1]*v[0])\n                def norm(v):\n                    return math.sqrt(sum(x*x for x in v))\n                def normalize(v):\n                    n = norm(v)\n                    if n < 1e-12:\n                        return v\n                    return tuple(x/n for x in v)\n                ref = (1.0, 0.0, 0.0) if abs(unit_vec[0]) < 0.9 else (0.0, 1.0, 0.0)\n                b2 = normalize(cross(unit_vec, ref))\n                if norm(b2) < 1e-12:\n                    ref = (0.0, 0.0, 1.0)\n                    b2 = normalize(cross(unit_vec, ref))\n                b3 = cross(unit_vec, b2)\n                basis = [unit_vec, b2, b3]\n                radii = [r1, r_other, r_other]\n\n            u = sample_unit_ball()\n            mapped = []\n            for d in range(dim):\n                val = center[d]\n                for i in range(dim):\n                    val += basis[i][d] * radii[i] * u[i]\n                # Clamp to bounds\n                val = max(0.0, min(bounds[d], val))\n                mapped.append(val)\n            return tuple(mapped)\n\n        def add_node_with_best_parent(tree, pos):\n            r = neighbor_radius(len(tree))\n            neighbors = near_nodes(tree, pos, r)\n            if not neighbors:\n                # Use nearest if no neighbor within radius\n                neighbors = [nearest(tree, pos)]\n            candidates = [p for p in neighbors if not is_edge_in_obstacle(p.position, pos)]\n            if not candidates:\n                return None, []\n            parent = min(candidates, key=lambda p: p.cost + dist(p.position, pos))\n            cost_new = parent.cost + dist(parent.position, pos)\n            if is_in_obstacle(pos):\n                return None, []\n            new_node = Node(pos)\n            new_node.parent = parent\n            new_node.cost = cost_new\n            parent.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((parent, new_node))\n            return new_node, neighbors\n\n        def rewire(node, neighbors):\n            for n in neighbors:\n                if n is node:\n                    continue\n                if is_edge_in_obstacle(node.position, n.position):\n                    continue\n                new_cost = node.cost + dist(node.position, n.position)\n                if new_cost + 1e-12 < n.cost:\n                    if n.parent:\n                        try:\n                            edges.remove((n.parent, n))\n                        except ValueError:\n                            pass\n                        if n in n.parent.children:\n                            n.parent.children.remove(n)\n                    node.add_child(n)\n                    n.cost = new_cost\n                    edges.append((node, n))\n\n        def connect_trees(new_node, other_tree):\n            nearest_to_new = nearest(other_tree, new_node.position)\n            d = dist(new_node.position, nearest_to_new.position)\n            if d > self.step_size * 2.5:\n                return None\n            if is_edge_in_obstacle(new_node.position, nearest_to_new.position):\n                return None\n            return nearest_to_new\n\n        def extract_combined_path(n_start, n_goal, start_side=True):\n            path_from_start = n_start.path_from_root()\n            path_from_goal = n_goal.path_from_root()\n            if path_from_start[-1] == path_from_goal[-1]:\n                combined = path_from_start + path_from_goal[-2::-1]\n            else:\n                combined = path_from_start + path_from_goal[::-1]\n            if start_side:\n                return combined\n            else:\n                return combined[::-1]\n\n        def path_cost(path):\n            if not path or len(path) < 2:\n                return 0.0\n            c = 0.0\n            for i in range(len(path)-1):\n                c += dist(path[i], path[i+1])\n            return c\n\n        # Shortcut smoothing: tries to shortcut path pairs if collision free\n        def shortcut_path(path, attempts=40):\n            if len(path) < 3:\n                return path[:]\n            import random as rand\n            path_smoothed = path[:]\n            for _ in range(attempts):\n                if len(path_smoothed) < 3:\n                    break\n                i = rand.randint(0, len(path_smoothed)-3)\n                j = rand.randint(i+2, len(path_smoothed)-1)\n                if j <= i+1:\n                    continue\n                if not is_edge_in_obstacle(path_smoothed[i], path_smoothed[j]):\n                    # Shortcut possible, remove intermediate nodes\n                    path_smoothed = path_smoothed[:i+1] + path_smoothed[j:]\n            return path_smoothed\n\n        # Main planning loop\n        for it in range(self.max_iter):\n            # Time limit check\n            if time.time() - start_time > self.time_limit_sec:\n                break\n\n            # Alternate growth\n            grow_tree = tree_a if it % 2 == 0 else tree_b\n            other_tree = tree_b if it % 2 == 0 else tree_a\n            start_side = (grow_tree == tree_a)\n\n            sample = sample_informed(best_cost)\n            nearest_node = nearest(grow_tree, sample)\n            new_pos = steer(nearest_node.position, sample)\n\n            if not within_bounds(new_pos):\n                # Count post optimization if solution found\n                if found_solution:\n                    post_opt_count += 1\n                    no_improve_count += 1\n                    if post_opt_count >= self.post_opt_iters or no_improve_count >= self.max_no_improve:\n                        break\n                continue\n\n            if is_in_obstacle(new_pos) or is_edge_in_obstacle(nearest_node.position, new_pos):\n                if found_solution:\n                    post_opt_count += 1\n                    no_improve_count += 1\n                    if post_opt_count >= self.post_opt_iters or no_improve_count >= self.max_no_improve:\n                        break\n                continue\n\n            new_node, neighbors = add_node_with_best_parent(grow_tree, new_pos)\n            if new_node is None:\n                if found_solution:\n                    post_opt_count += 1\n                    no_improve_count += 1\n                    if post_opt_count >= self.post_opt_iters or no_improve_count >= self.max_no_improve:\n                        break\n                continue\n\n            rewire(new_node, neighbors)\n\n            # Attempt connection to other tree\n            connect_node = connect_trees(new_node, other_tree)\n            if connect_node:\n                # Join trees\n                if connect_node.parent is None or new_node.parent is None:\n                    # Should not happen, skip if roots\n                    continue\n                # Combine paths\n                candidate_path = extract_combined_path(new_node, connect_node, start_side)\n                candidate_cost = path_cost(candidate_path)\n                # If improved path found\n                if candidate_cost + 1e-7 < best_cost:\n                    best_cost = candidate_cost\n                    # Smooth path before recording\n                    best_path = shortcut_path(candidate_path, attempts=50)\n                    found_solution = True\n                    no_improve_count = 0\n                    post_opt_count = 0\n                else:\n                    if found_solution:\n                        no_improve_count += 1\n                        post_opt_count += 1\n                        if post_opt_count >= self.post_opt_iters or no_improve_count >= self.max_no_improve:\n                            break\n            else:\n                if found_solution:\n                    no_improve_count += 1\n                    post_opt_count += 1\n                    if post_opt_count >= self.post_opt_iters or no_improve_count >= self.max_no_improve:\n                        break\n\n        return PlannerResult(\n            success=found_solution,\n            path=best_path if found_solution else [],\n            nodes=nodes,\n            edges=edges\n        )",
        "objective": 14.32975,
        "time_improvement": -103.0,
        "length_improvement": 19.0,
        "smoothness_improvement": 1026.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.11174523830413818,
                "num_nodes_avg": 170.3,
                "path_length_avg": 155.95946117163558,
                "smoothness_avg": 0.04431890634175788,
                "success_improvement": 0.0,
                "time_improvement": -325.65044958646763,
                "length_improvement": 14.516147996016231,
                "smoothness_improvement": 593.6871242940072,
                "objective_score": -86.0170104568605
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.08233952522277832,
                "num_nodes_avg": 319.1,
                "path_length_avg": 230.98919001369396,
                "smoothness_avg": 0.06524519533690301,
                "success_improvement": 0.0,
                "time_improvement": 50.13957315950754,
                "length_improvement": 22.889159718239107,
                "smoothness_improvement": 1578.8058702331955,
                "objective_score": 36.6693971299617
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.06728522777557373,
                "num_nodes_avg": 254.4,
                "path_length_avg": 120.52492557718756,
                "smoothness_avg": 0.0790609987636083,
                "success_improvement": 0.0,
                "time_improvement": -33.805833289081406,
                "length_improvement": 19.953083211850664,
                "smoothness_improvement": 905.6500685972023,
                "objective_score": 6.358350283371988
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "m3",
        "algorithm_description": "A simplified bidirectional RRT* planner that balances exploration and optimization with clear structure. It grows two trees from start and goal, alternates extension towards random samples with mild goal bias, uses radius-based neighbor rewiring to improve paths, and attempts greedy connection of the two trees for fast solution discovery. Strict collision checking ensures robustness.",
        "planning_mechanism": "The planner samples in free space, extends one tree towards the sample with step-wise steering, chooses the best parent among neighbors within a neighborhood radius, rewires neighbors to reduce path costs, then attempts to connect the other tree greedily. Upon connecting, it extracts and returns the combined path, iterating until a solution is found or iteration limit is reached.",
        "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent: Optional[\"Node\"]=None, cost: float=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children: List[\"Node\"] = []\n\n    def add_child(self, child: \"Node\"):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        node, path = self, []\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 3000, step_size: float = 4.0, gamma_rrt_star: float = 50.0, max_radius: float = 40.0, goal_sample_rate: float = 0.05):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.gamma_rrt_star = gamma_rrt_star\n        self.max_radius = max_radius\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map) -> \"PlannerResult\":\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        tree_start = [Node(start_pos)]\n        tree_goal = [Node(goal_pos)]\n        nodes = tree_start + tree_goal\n        edges: List[Tuple[Node,Node]] = []\n\n        def sample_free():\n            if random.random() < self.goal_sample_rate:\n                return goal_pos\n            while True:\n                s = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(s, obstacles, is_3d):\n                    return s\n\n        def nearest(tree: List[Node], point: Tuple[float, ...]) -> Node:\n            return min(tree, key=lambda n: math.dist(n.position, point))\n\n        def steer(from_pos, to_pos) -> Tuple[float, ...]:\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dim))\n\n        def neighbor_radius(n_nodes: int) -> float:\n            if n_nodes < 2:\n                return self.step_size * 2.0\n            r = self.gamma_rrt_star * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            return min(max(self.step_size*2.0, r), self.max_radius)\n\n        def near_nodes(tree: List[Node], pos: Tuple[float,...]) -> List[Node]:\n            r = neighbor_radius(len(tree))\n            return [n for n in tree if math.dist(n.position, pos) <= r]\n\n        def can_connect(from_p, to_p) -> bool:\n            return (not self._is_in_obstacle(to_p, obstacles, is_3d)\n                    and not self._is_edge_in_obstacle(from_p, to_p, obstacles, is_3d))\n\n        def add_node_with_parent(tree: List[Node], new_pos: Tuple[float, ...]) -> Optional[Node]:\n            near = near_nodes(tree, new_pos)\n            candidates = [n for n in near if can_connect(n.position, new_pos)]\n            if not candidates:\n                parent = nearest(tree, new_pos)\n                if not can_connect(parent.position, new_pos):\n                    return None\n                best_parent = parent\n                best_cost = parent.cost + math.dist(parent.position, new_pos)\n            else:\n                best_parent, best_cost = min(\n                    ((n, n.cost + math.dist(n.position, new_pos)) for n in candidates),\n                    key=lambda x: x[1]\n                )\n            new_node = Node(new_pos, parent=None, cost=best_cost)\n            best_parent.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n            return new_node\n\n        def rewire(node: Node, neighbors: List[Node]):\n            for nb in neighbors:\n                if nb is node:\n                    continue\n                if can_connect(node.position, nb.position):\n                    new_cost = node.cost + math.dist(node.position, nb.position)\n                    if new_cost + 1e-12 < nb.cost:\n                        if nb.parent is not None:\n                            try:\n                                edges.remove((nb.parent, nb))\n                            except ValueError:\n                                pass\n                            if nb in nb.parent.children:\n                                nb.parent.children.remove(nb)\n                        node.add_child(nb)\n                        nb.cost = new_cost\n                        edges.append((node, nb))\n\n        def extend(tree: List[Node], target_point: Tuple[float, ...], other_tree: List[Node]) -> Optional[Node]:\n            nearest_node = nearest(tree, target_point)\n            new_pos = steer(nearest_node.position, target_point)\n            if not can_connect(nearest_node.position, new_pos):\n                return None\n            new_node = add_node_with_parent(tree, new_pos)\n            if not new_node:\n                return None\n            near = near_nodes(tree, new_pos)\n            rewire(new_node, near)\n            # Attempt connect with other_tree greedily\n            connect_node = attempt_connect(other_tree, new_node)\n            if connect_node:\n                return (new_node, connect_node)\n            return (new_node, None)\n\n        def attempt_connect(tree: List[Node], target_node: Node) -> Optional[Node]:\n            nearest_node = nearest(tree, target_node.position)\n            current = nearest_node\n            while True:\n                new_pos = steer(current.position, target_node.position)\n                if not can_connect(current.position, new_pos):\n                    return None\n                new_node = add_node_with_parent(tree, new_pos)\n                if new_node is None:\n                    return None\n                near = near_nodes(tree, new_pos)\n                rewire(new_node, near)\n                current = new_node\n                if math.dist(current.position, target_node.position) <= self.step_size:\n                    if can_connect(current.position, target_node.position):\n                        final_node = Node(target_node.position, parent=None, cost=current.cost + math.dist(current.position, target_node.position))\n                        current.add_child(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((current, final_node))\n                        return final_node\n                    else:\n                        return None\n\n        best_path: List[Tuple[float,...]] = []\n        solution_found = False\n\n        for _ in range(self.max_iter):\n            sample = sample_free()\n            result = extend(tree_start, sample, tree_goal)\n            if result is None:\n                tree_start, tree_goal = tree_goal, tree_start\n                continue\n            new_node, connect_node = result\n            if connect_node:\n                path_start = new_node.path_from_root()\n                path_goal = connect_node.path_from_root()\n                if path_start[-1] == path_goal[-1]:\n                    path_goal = path_goal[:-1]\n                best_path = path_start + path_goal[::-1]\n                solution_found = True\n                break\n            tree_start, tree_goal = tree_goal, tree_start\n\n        return PlannerResult(success=solution_found, path=best_path, nodes=nodes, edges=edges)\n\n    def _is_in_obstacle(self, pos: Tuple[float,...], obstacles, is_3d: bool) -> bool:\n        for obs in obstacles:\n            if is_3d:\n                x,y,z,w,h,d = obs\n                px,py,pz = pos\n                if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                    return True\n            else:\n                x,y,w,h = obs\n                px,py = pos\n                if x <= px <= x+w and y <= py <= y+h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_p: Tuple[float,...], to_p: Tuple[float,...], obstacles, is_3d: bool, resolution: float=1.0) -> bool:\n        dist = math.dist(from_p, to_p)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps+1):\n            interm = tuple(from_p[d] + (to_p[d] - from_p[d]) * i/steps for d in range(len(from_p)))\n            if self._is_in_obstacle(interm, obstacles, is_3d):\n                return True\n        return False",
        "objective": 2.60201,
        "time_improvement": -40.0,
        "length_improvement": 14.0,
        "smoothness_improvement": 242.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.049528646469116214,
                "num_nodes_avg": 102.8,
                "path_length_avg": 163.73573386408458,
                "smoothness_avg": 0.024721319861977082,
                "success_improvement": 0.0,
                "time_improvement": -88.66030407138894,
                "length_improvement": 10.253849710358729,
                "smoothness_improvement": 286.9423390452511,
                "objective_score": -19.011069699975188
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.07662971019744873,
                "num_nodes_avg": 315.6,
                "path_length_avg": 257.08848163237656,
                "smoothness_avg": 0.011895872353594215,
                "success_improvement": 0.0,
                "time_improvement": 53.59713274067979,
                "length_improvement": 14.176464949466494,
                "smoothness_improvement": 206.0893639085042,
                "objective_score": 25.615465611426355
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.09266290664672852,
                "num_nodes_avg": 359.9,
                "path_length_avg": 126.19502968546935,
                "smoothness_avg": 0.02608580925521416,
                "success_improvement": 0.0,
                "time_improvement": -84.27280175389355,
                "length_improvement": 16.18727004447308,
                "smoothness_improvement": 231.80956827217284,
                "objective_score": -14.410430658123351
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "m2",
        "algorithm_description": "A hybrid bidirectional RRT* planner with adaptive neighbor radius and incremental rewiring that dynamically balances exploration and exploitation. It samples with goal and bridge bias and adapts rewiring radius by node count to improve path quality and search speed. After first solution, it performs focused post-optimization with early stopping, using efficient collision checking to maintain path validity and smoothness.",
        "planning_mechanism": "The planner grows two trees simultaneously, alternately extending them toward biased random samples near goals or opposite tree roots. For each new node, it selects the best parent in a dynamically scaled neighbor radius and rewires neighbors to locally optimize costs. Upon connecting the two trees, it refines the path with limited post-optimization iterations or until convergence or time run out, thereby significantly improving efficiency, path length, and smoothness.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(\n        self,\n        max_iter=6000,\n        step_size=5.0,\n        post_opt_iters=500,\n        max_no_improve=100,\n        improve_tol=1e-5,\n        goal_sample_rate=0.08,\n        bridge_bias_rate=0.12,\n        neighbor_gamma=60.0,\n        time_limit_sec=28.0\n    ):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.post_opt_iters = post_opt_iters\n        self.max_no_improve = max_no_improve\n        self.improve_tol = improve_tol\n        self.goal_sample_rate = goal_sample_rate\n        self.bridge_bias_rate = bridge_bias_rate\n        self.neighbor_gamma = neighbor_gamma\n        self.time_limit_sec = time_limit_sec\n\n    def plan(self, map):\n        import time\n        import math\n        import random\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def in_bounds(p):\n            return all(0.0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def clamp(p):\n            return tuple(min(max(p[d], 0.0), bounds[d]) for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_p, to_p):\n            d = dist(from_p, to_p)\n            if d <= self.step_size:\n                return clamp(to_p)\n            r = self.step_size / d\n            return clamp(tuple(from_p[i] + (to_p[i] - from_p[i]) * r for i in range(dim)))\n\n        def is_in_obstacle(pos):\n            px = pos[0]\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d=obs\n                    if x <= pos[0] <= x + w and y <= pos[1] <= y + h and z <= pos[2] <= z + d:\n                        return True\n                else:\n                    x,y,w,h=obs\n                    if x <= pos[0] <= x + w and y <= pos[1] <= y + h:\n                        return True\n            return False\n\n        def edge_collision(f_pos, t_pos, resolution=1.0):\n            d = dist(f_pos, t_pos)\n            steps = max(1, int(d / resolution))\n            for i in range(steps + 1):\n                interp = tuple(f_pos[j] + (t_pos[j] - f_pos[j]) * (i / steps) for j in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def sample_uniform():\n            return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        def sample_free(active_tree, other_tree):\n            r = random.random()\n            if r < self.goal_sample_rate:\n                return goal_pos if active_tree is tree_start else start_pos\n            if r < self.goal_sample_rate + self.bridge_bias_rate:\n                root_o = other_tree[0].position\n                jitter = tuple(random.uniform(-2*self.step_size, 2*self.step_size) for _ in range(dim))\n                s = clamp(tuple(root_o[i] + jitter[i] for i in range(dim)))\n                return s if not is_in_obstacle(s) else sample_uniform()\n            return sample_uniform()\n\n        def nearest(tree, p):\n            nearest_node = None\n            min_dist = float('inf')\n            for n in tree:\n                d = dist(n.position, p)\n                if d < min_dist:\n                    min_dist = d\n                    nearest_node = n\n            return nearest_node\n\n        def neighbor_radius(n_nodes):\n            if n_nodes < 2:\n                return max(10.0, self.step_size*2)\n            r = self.neighbor_gamma * ((math.log(n_nodes)/n_nodes) ** (1.0 / dim))\n            return max(10.0, min(max(bounds), r))\n\n        def near(tree, pos, radius):\n            return [nd for nd in tree if dist(nd.position, pos) <= radius]\n\n        def add_node_with_best_parent(tree, pos):\n            radius = neighbor_radius(len(tree))\n            near_nodes = near(tree, pos, radius)\n            candidates = [n for n in near_nodes if not edge_collision(n.position, pos)]\n            if not candidates:\n                parent = nearest(tree, pos)\n                if edge_collision(parent.position, pos):\n                    return None, []\n            else:\n                parent = min(candidates, key=lambda c: c.cost + dist(c.position, pos))\n            cost_c = parent.cost + dist(parent.position, pos)\n            new_node = Node(pos, parent=None, cost=cost_c)\n            parent.add_child(new_node)\n            tree.append(new_node)\n            return new_node, near_nodes\n\n        def rewire(node, neighbors, tree, edges):\n            for nb in neighbors:\n                if nb is node:\n                    continue\n                if edge_collision(node.position, nb.position):\n                    continue\n                new_cost = node.cost + dist(node.position, nb.position)\n                if new_cost + 1e-12 < nb.cost:\n                    if nb.parent:\n                        try:\n                            edges.remove((nb.parent, nb))\n                        except ValueError:\n                            pass\n                        if nb in nb.parent.children:\n                            nb.parent.children.remove(nb)\n                    node.add_child(nb)\n                    nb.cost = new_cost\n                    edges.append((node, nb))\n\n        def stitch_path(a_node, b_node, a_start=True):\n            path_a = a_node.path_from_root()\n            path_b = b_node.path_from_root()\n            if path_a[-1] == path_b[-1]:\n                full_path = path_a + path_b[-2::-1]\n            else:\n                full_path = path_a + path_b[::-1]\n            if a_start:\n                return full_path\n            return full_path[::-1]\n\n        def path_cost(path):\n            return sum(dist(path[i], path[i+1]) for i in range(len(path)-1))\n\n        start_time = time.time()\n\n        tree_start = [Node(start_pos, cost=0.0)]\n        tree_goal = [Node(goal_pos, cost=0.0)]\n        nodes = tree_start + tree_goal[:]\n        edges = []\n        best_path = []\n        best_cost = float('inf')\n        found_solution = False\n        post_opt_counter = 0\n        no_improve = 0\n\n        for i in range(self.max_iter):\n            if time.time() - start_time > self.time_limit_sec:\n                break\n\n            grow_tree, other_tree = (tree_start, tree_goal) if i % 2 == 0 else (tree_goal, tree_start)\n            a_is_start_tree = (grow_tree is tree_start)\n\n            sample_pos = sample_free(grow_tree, other_tree)\n            nearest_node = nearest(grow_tree, sample_pos)\n            new_pos = steer(nearest_node.position, sample_pos)\n\n            if not in_bounds(new_pos) or is_in_obstacle(new_pos):\n                if found_solution:\n                    post_opt_counter += 1\n                    no_improve += 1\n                    if post_opt_counter >= self.post_opt_iters or no_improve >= self.max_no_improve:\n                        break\n                continue\n            if edge_collision(nearest_node.position, new_pos):\n                if found_solution:\n                    post_opt_counter += 1\n                    no_improve += 1\n                    if post_opt_counter >= self.post_opt_iters or no_improve >= self.max_no_improve:\n                        break\n                continue\n\n            new_node, neighbors = add_node_with_best_parent(grow_tree, new_pos)\n            if new_node is None:\n                if found_solution:\n                    post_opt_counter += 1\n                    no_improve += 1\n                    if post_opt_counter >= self.post_opt_iters or no_improve >= self.max_no_improve:\n                        break\n                continue\n\n            edges.append((new_node.parent, new_node))\n            nodes.append(new_node)\n            rewire(new_node, neighbors, grow_tree, edges)\n\n            # Try to connect other tree greedily one step toward new_node with rewiring\n            other_near = nearest(other_tree, new_node.position)\n            curr = other_near\n            connected_node = None\n\n            while True:\n                step_pos = steer(curr.position, new_node.position)\n                if not in_bounds(step_pos) or is_in_obstacle(step_pos):\n                    break\n                if edge_collision(curr.position, step_pos):\n                    break\n\n                w_new_node, w_neighbors = add_node_with_best_parent(other_tree, step_pos)\n                if w_new_node is None:\n                    break\n                edges.append((w_new_node.parent, w_new_node))\n                nodes.append(w_new_node)\n                rewire(w_new_node, w_neighbors, other_tree, edges)\n                curr = w_new_node\n\n                if dist(curr.position, new_node.position) <= self.step_size:\n                    if not edge_collision(curr.position, new_node.position) and new_node.valid:\n                        bridge_node = Node(new_node.position, parent=None,\n                                           cost=curr.cost + dist(curr.position, new_node.position))\n                        curr.add_child(bridge_node)\n                        other_tree.append(bridge_node)\n                        nodes.append(bridge_node)\n                        edges.append((curr, bridge_node))\n                        connected_node = bridge_node\n                    break\n\n            if connected_node is not None:\n                candidate_path = stitch_path(new_node, connected_node, a_start=a_is_start_tree)\n                candidate_cost = path_cost(candidate_path)\n                if candidate_cost + self.improve_tol < best_cost:\n                    best_cost = candidate_cost\n                    best_path = candidate_path\n                    found_solution = True\n                    no_improve = 0\n                    post_opt_counter = 0\n                else:\n                    no_improve += 1\n                    post_opt_counter += 1\n\n                if post_opt_counter >= self.post_opt_iters or no_improve >= self.max_no_improve:\n                    break\n            else:\n                if found_solution:\n                    no_improve += 1\n                    post_opt_counter += 1\n                    if post_opt_counter >= self.post_opt_iters or no_improve >= self.max_no_improve:\n                        break\n\n        return PlannerResult(\n            success=found_solution,\n            path=best_path if found_solution else [],\n            nodes=nodes,\n            edges=edges\n        )",
        "objective": 64.09836,
        "time_improvement": -256.0,
        "length_improvement": 18.0,
        "smoothness_improvement": 371.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.12574965953826905,
                "num_nodes_avg": 297.2,
                "path_length_avg": 157.25260125169626,
                "smoothness_avg": 0.031982096882791765,
                "success_improvement": 0.0,
                "time_improvement": -378.99489884418006,
                "length_improvement": 13.807357427019118,
                "smoothness_improvement": 400.5892664506616,
                "objective_score": -103.41110886478924
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.3570851802825928,
                "num_nodes_avg": 801.0,
                "path_length_avg": 235.28089610184898,
                "smoothness_avg": 0.01636074260770513,
                "success_improvement": 0.0,
                "time_improvement": -116.23174847234705,
                "length_improvement": 21.456464696102515,
                "smoothness_improvement": 320.9736914628338,
                "objective_score": -20.390777266728442
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.18697638511657716,
                "num_nodes_avg": 356.5,
                "path_length_avg": 122.72864267507502,
                "smoothness_avg": 0.03870353042699551,
                "success_improvement": 0.0,
                "time_improvement": -271.8279902291744,
                "length_improvement": 18.489479245165384,
                "smoothness_improvement": 392.30605023393406,
                "objective_score": -68.49317927048341
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "e1",
        "algorithm_description": "A hybrid bidirectional RRT* with informed sampling and dynamic neighborhood rewiring. The planner grows two trees simultaneously from start and goal while using informed sampling ellipses to focus the search within an approximate solution space, reducing unnecessary expansions. It dynamically adapts the neighborhood radius for rewiring based on node density and applies incremental rewiring for improved path quality. After connection, a path shortcutting postprocess reduces path length and smoothens the trajectory. This method improves convergence speed, path optimality, and smoothness while maintaining collision safety.",
        "planning_mechanism": "The planner alternately grows two trees using informed uniform sampling constrained by an ellipse defined by current best solution cost to bias sampling towards promising regions. Each extension attempts rewiring with dynamically computed radius and performs incremental path cost improvement both locally and across the trees. When a connection between trees is found, the combined path undergoes shortcutting to reduce unnecessary waypoints and smooth angular transitions. The search halts when maximum iterations or time limit is reached or when no better solution is found over a period.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost  # cost from root\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=3.0, search_radius_factor=50.0, time_limit=10.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.search_radius_factor = search_radius_factor  # parameter to compute rewiring radius dynamically\n        self.time_limit = time_limit\n\n    def plan(self, map):\n        import math\n        import random\n        import time\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = dim == 3\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_p, to_p, max_step):\n            d = dist(from_p, to_p)\n            if d <= max_step:\n                return to_p\n            ratio = max_step / d\n            return tuple(from_p[i] + ratio * (to_p[i] - from_p[i]) for i in range(dim))\n\n        def in_obstacle(p):\n            px, py = p[0], p[1]\n            if is_3d:\n                pz = p[2]\n                for ox, oy, oz, ow, oh, od in obstacles:\n                    if ox <= px <= ox + ow and oy <= py <= oy + oh and oz <= pz <= oz + od:\n                        return True\n            else:\n                for ox, oy, ow, oh in obstacles:\n                    if ox <= px <= ox + ow and oy <= py <= oy + oh:\n                        return True\n            return False\n\n        def edge_collision(f, t, resolution=0.2):\n            length = dist(f, t)\n            steps = max(1, int(length / resolution))\n            for i in range(steps + 1):\n                interp = tuple(f[d] + (t[d] - f[d]) * (i/steps) for d in range(dim))\n                if in_obstacle(interp):\n                    return True\n            return False\n\n        # Nodes and edges\n        start_node = Node(start_pos, parent=None, cost=0.0)\n        goal_node = Node(goal_pos, parent=None, cost=0.0)\n        tree_start = [start_node]\n        tree_goal = [goal_node]\n\n        all_nodes = [start_node, goal_node]\n        all_edges = []\n\n        # For informed sampling ellipse params\n        c_best = float('inf')\n        c_min = dist(start_pos, goal_pos)\n        center = tuple((start_pos[i] + goal_pos[i]) / 2.0 for i in range(dim))\n        # Unit vector from start to goal\n        unit_vector = tuple((goal_pos[i] - start_pos[i]) / c_min if c_min > 0 else 1.0 for i in range(dim))\n\n        def sample_in_ellipse():\n            # If no solution found, sample uniformly in bounds\n            if c_best == float('inf'):\n                while True:\n                    sample = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                    if not in_obstacle(sample):\n                        return sample\n            else:\n                # Sample point inside ellipse defined by start and goal and cost c_best\n                while True:\n                    # Sample uniformly in unit ball\n                    import math\n                    while True:\n                        pt = [random.uniform(-1, 1) for _ in range(dim)]\n                        norm = math.sqrt(sum(x * x for x in pt))\n                        if norm <= 1 and norm > 0:\n                            break\n                    # Scale unit ball by ellipse radii\n                    r1 = c_best / 2.0\n                    rest = math.sqrt(max(c_best * c_best - c_min * c_min, 0)) / 2.0\n                    # Compute orthonormal basis with unit_vector as first basis vector\n                    # Use Householder reflection or Gram-Schmidt; simplified for 2D and 3D\n                    # We'll build rotation matrix from unit_vector\n                    # For numerical stability and general dim, just approximate by aligning first axis to unit_vector\n\n                    # Construct rotation matrix R: map e1=[1,0..] to unit_vector\n                    # Here approximate: rotation for 2D or 3D only\n\n                    if dim == 2:\n                        ux, uy = unit_vector\n                        cos_theta = ux\n                        sin_theta = uy\n                        # scale coords: first axis r1, second rest\n                        x = pt[0] * r1\n                        y = pt[1] * rest\n                        # Rotate\n                        rx = cos_theta * x - sin_theta * y\n                        ry = sin_theta * x + cos_theta * y\n                        sample = (rx + center[0], ry + center[1])\n                    elif dim == 3:\n                        # Construct an orthonormal basis (u, v, w)\n                        # u = unit_vector\n                        # v = arbitrary vector orthogonal to u\n                        # w = u cross v\n                        u = unit_vector\n                        # Choose v:\n                        if abs(u[0]) < 0.9:\n                            v = (-u[1], u[0], 0.0)\n                        else:\n                            v = (0.0, -u[2], u[1])\n                        norm_v = math.sqrt(sum(x*x for x in v))\n                        v = tuple(x / norm_v for x in v)\n                        # w = u cross v\n                        w = (u[1]*v[2] - u[2]*v[1],\n                             u[2]*v[0] - u[0]*v[2],\n                             u[0]*v[1] - u[1]*v[0])\n                        # scale coords\n                        x = pt[0] * r1\n                        y = pt[1] * rest\n                        z = pt[2] * rest\n                        rx = u[0]*x + v[0]*y + w[0]*z + center[0]\n                        ry = u[1]*x + v[1]*y + w[1]*z + center[1]\n                        rz = u[2]*x + v[2]*y + w[2]*z + center[2]\n                        sample = (rx, ry, rz)\n                    else:\n                        # fallback to uniform sample in bounds\n                        return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n\n                    # Check bounds\n                    in_bounds = True\n                    for i in range(dim):\n                        if sample[i] < 0 or sample[i] > bounds[i]:\n                            in_bounds = False\n                            break\n                    if not in_bounds:\n                        continue\n                    if not in_obstacle(sample):\n                        return sample\n\n        # Dynamic radius for rewiring based on formula for RRT*\n        def compute_radius(n_nodes):\n            gamma_rrt_star = self.search_radius_factor\n            radius = min(self.step_size * 20.0, gamma_rrt_star * (math.log(n_nodes + 1) / (n_nodes + 1)) ** (1 / dim))\n            return radius\n\n        def near_nodes(tree, point, radius):\n            return [node for node in tree if dist(node.position, point) <= radius]\n\n        def rewire(tree, new_node, radius):\n            neighbors = near_nodes(tree, new_node.position, radius)\n            for near_node in neighbors:\n                if near_node is new_node.parent:\n                    continue\n                # If connecting near_node from new_node reduces cost and edge valid\n                proposed_cost = new_node.cost + dist(new_node.position, near_node.position)\n                if proposed_cost < near_node.cost:\n                    if not edge_collision(new_node.position, near_node.position):\n                        # rewire near_node to new_node\n                        old_parent = near_node.parent\n                        if old_parent:\n                            try:\n                                old_parent.children.remove(near_node)\n                            except ValueError:\n                                pass\n                        near_node.parent = new_node\n                        near_node.cost = proposed_cost\n                        new_node.children.append(near_node)\n                        # propagate cost updates to descendants\n                        self._update_costs(near_node)\n\n        def insert_node(tree, new_pos, parent_node):\n            cost = parent_node.cost + dist(parent_node.position, new_pos)\n            new_node = Node(new_pos, parent=parent_node, cost=cost)\n            parent_node.children.append(new_node)\n            tree.append(new_node)\n            all_nodes.append(new_node)\n            all_edges.append((parent_node, new_node))\n            return new_node\n\n        def try_extend(tree, sample):\n            nearest = min(tree, key=lambda node: dist(node.position, sample))\n            new_pos = steer(nearest.position, sample, self.step_size)\n            if in_obstacle(new_pos):\n                return None\n            if edge_collision(nearest.position, new_pos):\n                return None\n            return insert_node(tree, new_pos, nearest)\n\n        def try_connect_trees(node_start, tree_goal):\n            import collections\n            # Attempt to connect node_start to nearest node(s) in tree_goal by extending edges (like RRT*)\n            radius = compute_radius(len(tree_goal))\n            neighbors = near_nodes(tree_goal, node_start.position, radius)\n            best_connection = None\n            best_cost = float('inf')\n            for goal_node in neighbors:\n                if not edge_collision(node_start.position, goal_node.position):\n                    cost = node_start.cost + dist(node_start.position, goal_node.position) + goal_node.cost\n                    if cost < best_cost:\n                        best_cost = cost\n                        best_connection = goal_node\n            return best_connection, best_cost if best_connection is not None else (None, None)\n\n        def extract_path(node_from_start, node_from_goal):\n            path_start = []\n            n = node_from_start\n            while n is not None:\n                path_start.append(n.position)\n                n = n.parent\n            path_start.reverse()\n            path_goal = []\n            n = node_from_goal\n            while n is not None:\n                path_goal.append(n.position)\n                n = n.parent\n            return path_start + path_goal\n\n        def shortcut_path(path, max_trials=100):\n            # Attempts to shortcut path by replacing subpaths with direct segments if valid\n            if len(path) < 3:\n                return path\n            shortened = path[:]\n            for _ in range(max_trials):\n                if len(shortened) < 3:\n                    break\n                import random\n                i = random.randint(0, len(shortened) - 3)\n                j = random.randint(i + 2, len(shortened) - 1)\n                if not edge_collision(shortened[i], shortened[j]):\n                    # remove points i+1 to j-1\n                    shortened = shortened[:i+1] + shortened[j:]\n            return shortened\n\n        def cost_via_nodes(n1, n2):\n            return n1.cost + dist(n1.position, n2.position) + n2.cost\n\n        self._update_costs = lambda node: self._propagate_costs(node, dist)\n\n        start_time = time.time()\n        best_path = None\n        best_cost = float('inf')\n        last_improve_iter = 0\n\n        for it in range(self.max_iter):\n            if time.time() - start_time > self.time_limit:\n                break\n\n            sample = sample_in_ellipse()\n            # Alternate growth\n            grow_start = (it % 2 == 0)\n            if grow_start:\n                new_node = try_extend(tree_start, sample)\n                tree_grow = tree_start\n                tree_connect = tree_goal\n            else:\n                new_node = try_extend(tree_goal, sample)\n                tree_grow = tree_goal\n                tree_connect = tree_start\n\n            if new_node is None:\n                continue\n\n            radius = compute_radius(len(tree_grow))\n            rewire(tree_grow, new_node, radius)\n\n            conn_node, conn_cost = try_connect_trees(new_node, tree_connect)\n            if conn_node is not None and conn_cost < best_cost:\n                best_cost = conn_cost\n                if grow_start:\n                    path = extract_path(new_node, conn_node)\n                else:\n                    path = extract_path(conn_node, new_node)\n                best_path = shortcut_path(path)\n                last_improve_iter = it\n\n            # Early stop if no improvement for many iterations\n            if it - last_improve_iter > 150 and best_path is not None:\n                break\n\n        success = best_path is not None\n\n        return PlannerResult(success, best_path if success else [],\n                             all_nodes, all_edges)\n\n\n    def _propagate_costs(self, node, dist_func):\n        # Recursive update of costs for subtree rooted at node\n        for child in node.children:\n            new_cost = node.cost + dist_func(node.position, child.position)\n            if child.cost > new_cost:\n                child.cost = new_cost\n                self._propagate_costs(child, dist_func)",
        "objective": 67.34584,
        "time_improvement": -280.0,
        "length_improvement": 18.0,
        "smoothness_improvement": 1165.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.13730175495147706,
                "num_nodes_avg": 326.4,
                "path_length_avg": 163.7196844298599,
                "smoothness_avg": 0.0323232060861102,
                "success_improvement": 0.0,
                "time_improvement": -422.99815733573814,
                "length_improvement": 10.262646659576829,
                "smoothness_improvement": 405.928366213086,
                "objective_score": -118.71221737390991
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.10871767997741699,
                "num_nodes_avg": 544.6,
                "path_length_avg": 225.24784467050148,
                "smoothness_avg": 0.0736347701135599,
                "success_improvement": 0.0,
                "time_improvement": 34.16636889615569,
                "length_improvement": 24.805786049259623,
                "smoothness_improvement": 1794.675672003038,
                "objective_score": 34.10676065841767
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.27789170742034913,
                "num_nodes_avg": 756.1,
                "path_length_avg": 120.74631266459755,
                "smoothness_avg": 0.10962272805060783,
                "success_improvement": 0.0,
                "time_improvement": -452.62548266209484,
                "length_improvement": 19.80604844971319,
                "smoothness_improvement": 1294.3930092956348,
                "objective_score": -117.43205068232234
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "e2",
        "algorithm_description": "A hybrid bidirectional RRT* variant integrating goal bias sampling, informed rewiring, and adaptive step size to efficiently find shorter, smoother, and feasible paths in 2D/3D spaces. It uses informed sampling to speed convergence, rigorous collision checking ensuring safe expansions, incremental rewiring to optimize path cost, and path shortcutting to smooth the final output.",
        "planning_mechanism": "A bidirectional tree grows from start and goal, alternately sampling with goal bias and within an ellipsoidal informed set once a solution is found. New nodes are extended from nearest tree nodes with adaptive step size considering proximity. After adding a new node, rewiring is performed to update neighbor connections minimizing cost to come. The two trees attempt connection after each extension. Upon successful connection, the combined path is shortcut and returned.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def path_from_root(self):\n        path, node = [], self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=4.0, goal_sample_rate=0.1, neighbor_radius=10.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate  # Probability of sampling goal\n        self.neighbor_radius = neighbor_radius    # Radius to search for rewiring neighbors\n\n    def plan(self, map):\n        bounds = map.size\n        start, goal = map.start, map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        start_tree = [Node(start, cost=0.0)]\n        goal_tree = [Node(goal, cost=0.0)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        best_cost = float('inf')\n        best_connection = None\n\n        def dist(a, b):\n            return sum((a[d]-b[d])**2 for d in range(dim))**0.5\n\n        def line_cost(a, b):\n            return dist(a, b)\n\n        # Utility for collision checking a single point\n        def in_obstacle(p):\n            if is_3d:\n                x, y, z = p\n                for ox, oy, oz, w, h, d in obstacles:\n                    if ox <= x <= ox + w and oy <= y <= oy + h and oz <= z <= oz + d:\n                        return True\n            else:\n                x, y = p\n                for ox, oy, w, h in obstacles:\n                    if ox <= x <= ox + w and oy <= y <= oy + h:\n                        return True\n            return False\n\n        # Checks collision for edge p1->p2 by interpolation with resolution = 1.0 units\n        def edge_in_obstacle(p1, p2):\n            dist_p = dist(p1, p2)\n            steps = max(1, int(dist_p / 1.0))\n            for i in range(steps + 1):\n                interp = tuple(p1[d] + (p2[d]-p1[d])*i/steps for d in range(dim))\n                if in_obstacle(interp):\n                    return True\n            return False\n\n        # Sample free point with goal bias and informed ellipsoid sampling if solution found\n        def sample_free():\n            if best_connection and random.random() > self.goal_sample_rate:\n                # Informed ellipsoid sampling within informed subset (prolate hyperspheroid)\n                c_min = dist(start, goal)\n                c_best = best_cost\n                if c_best < float('inf') and c_best > c_min:\n                    center = [(s+g)*0.5 for s,g in zip(start, goal)]\n                    a1 = [(g - s)/c_min for s,g in zip(start, goal)]\n                    # Sample unit ball in dim-dim space and transform\n                    while True:\n                        x_ball = [random.gauss(0,1) for _ in range(dim)]\n                        norm = (sum(x**2 for x in x_ball))**0.5\n                        if norm <= 1:\n                            unit = [x / norm for x in x_ball]\n                            r1 = c_best / 2.0\n                            r2 = (c_best**2 - c_min**2)**0.5 / 2.0 if c_best**2 - c_min**2 > 0 else 0.0\n                            # Construct scaled unit vector in bounding box of ellipsoid\n                            if dim == 2:\n                                # Rotation matrix from a1 to x axis\n                                angle = math.atan2(a1[1], a1[0])\n                                cos_ang = math.cos(angle)\n                                sin_ang = math.sin(angle)\n                                # Scale unit ball coordinates\n                                x_ell = r1 * unit[0]\n                                y_ell = r2 * unit[1]\n                                # Rotate back to world frame and translate\n                                px = center[0] + cos_ang * x_ell - sin_ang * y_ell\n                                py = center[1] + sin_ang * x_ell + cos_ang * y_ell\n                                pt = (px, py)\n                            else:\n                                # 3D case: align a1 with x axis by rotation matrix (approximate)\n                                # To simplify, sample box around center limited by bounds\n                                pt_candidate = [center[d] + r1*unit[0] if d == 0 else center[d] + r2*unit[d] for d in range(dim)]\n                                pt = tuple(max(0,min(pt_candidate[d], bounds[d])) for d in range(dim))\n                            if (all(0 <= pt[d] <= bounds[d] for d in range(dim)) and not in_obstacle(pt)):\n                                return pt\n                else:\n                    # If no valid c_best, fall back to uniform\n                    return uniform_sample()\n            # else regular or goal biased sample\n            if random.random() < self.goal_sample_rate:\n                return goal\n            else:\n                return uniform_sample()\n\n        def uniform_sample():\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not in_obstacle(pt):\n                    return pt\n\n        # Find the nearest node in a tree by Euclidean distance\n        def nearest(tree, point):\n            best = None\n            best_dist = float('inf')\n            for node in tree:\n                d = dist(node.position, point)\n                if d < best_dist:\n                    best = node\n                    best_dist = d\n            return best\n\n        # Steer from from_pos towards to_pos by step size or closer\n        def steer(from_pos, to_pos, max_step):\n            d = dist(from_pos, to_pos)\n            if d <= max_step:\n                return to_pos\n            ratio = max_step / d\n            return tuple(from_pos[d_] + ratio * (to_pos[d_] - from_pos[d_]) for d_ in range(dim))\n\n        # Find neighbors within radius for rewiring\n        def near(tree, node, radius):\n            ret = []\n            for n in tree:\n                if dist(n.position, node.position) <= radius:\n                    ret.append(n)\n            return ret\n\n        # Attempt to add new node to tree with rewiring for cost improvement\n        def extend_with_rewire(tree, point):\n            nearest_node = nearest(tree, point)\n            new_pos = steer(nearest_node.position, point, self.step_size)\n            if in_obstacle(new_pos) or edge_in_obstacle(nearest_node.position, new_pos):\n                return None\n            new_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            new_node = Node(new_pos, parent=nearest_node, cost=new_cost)\n            nearest_node.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n\n            # Rewire neighbors if cheaper to reach via new_node\n            neighbors = near(tree, new_node, self.neighbor_radius)\n            for neighbor in neighbors:\n                if neighbor == new_node.parent:\n                    continue\n                cost_to_neighbor = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_to_neighbor < neighbor.cost:\n                    # Check if edge is collision free before rewiring\n                    if not edge_in_obstacle(new_node.position, neighbor.position):\n                        # Rewire\n                        if neighbor.parent:\n                            neighbor.parent.remove_child(neighbor)\n                        neighbor.parent = new_node\n                        new_node.children.append(neighbor)\n                        # Update costs downstream by DFS\n                        def update_costs(n):\n                            for c in n.children:\n                                old_cost = c.cost\n                                c.cost = n.cost + dist(n.position, c.position)\n                                if c.cost < old_cost:\n                                    update_costs(c)\n                        neighbor.cost = cost_to_neighbor\n                        update_costs(neighbor)\n\n            return new_node\n\n        # Try to connect tree_b to node from tree_a by single edge\n        def try_connect(tree_b, node_a):\n            nearest_node = nearest(tree_b, node_a.position)\n            if edge_in_obstacle(nearest_node.position, node_a.position) or in_obstacle(node_a.position):\n                return None\n            c_cost = nearest_node.cost + dist(nearest_node.position, node_a.position)\n            new_node = Node(node_a.position, parent=nearest_node, cost=c_cost)\n            nearest_node.add_child(new_node)\n            tree_b.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n            return new_node\n\n        # Shortcut the final path by removing unnecessary waypoints with collision checking\n        def shortcut_path(path):\n            if len(path) <= 2:\n                return path\n            shortened = [path[0]]\n            idx = 0\n            while idx < len(path) - 1:\n                next_idx = len(path) -1\n                for j in range(len(path)-1, idx, -1):\n                    if not edge_in_obstacle(path[idx], path[j]):\n                        next_idx = j\n                        break\n                shortened.append(path[next_idx])\n                idx = next_idx\n            return shortened\n\n        import random\n        import math\n\n        for itr in range(self.max_iter):\n            tree_a, tree_b = (start_tree, goal_tree) if itr % 2 == 0 else (goal_tree, start_tree)\n\n            sample = sample_free()\n            new_node_a = extend_with_rewire(tree_a, sample)\n            if new_node_a is None:\n                continue\n\n            new_node_b = try_connect(tree_b, new_node_a)\n            if new_node_b:\n                total_cost = new_node_a.cost + new_node_b.cost\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_connection = (new_node_a, new_node_b)\n\n                # Build full path from start to goal via connecting nodes\n                path_start = new_node_a.path_from_root()\n                path_goal = new_node_b.path_from_root()\n                # Remove duplication of connecting node\n                if path_start[-1] == path_goal[-1]:\n                    full_path = path_start + path_goal[-2::-1]\n                else:\n                    full_path = path_start + path_goal[::-1]\n                # Shortcut path to improve smoothness and length\n                full_path = shortcut_path(full_path)\n                return PlannerResult(\n                    success=True,\n                    path=full_path,\n                    nodes=nodes,\n                    edges=edges\n                )\n\n        # If no connection found after max_iter\n        return PlannerResult(\n            success=False,\n            path=[],\n            nodes=nodes,\n            edges=edges\n        )",
        "objective": -13.10341,
        "time_improvement": -17.0,
        "length_improvement": 15.0,
        "smoothness_improvement": 1770.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.03586246967315674,
                "num_nodes_avg": 158.2,
                "path_length_avg": 169.64979962636318,
                "smoothness_avg": 0.04954703801688554,
                "success_improvement": 0.0,
                "time_improvement": -36.60426673496058,
                "length_improvement": 7.012256551684769,
                "smoothness_improvement": 675.5187380793998,
                "objective_score": -3.3963323990803147
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.07881088256835937,
                "num_nodes_avg": 308.2,
                "path_length_avg": 237.82271271086537,
                "smoothness_avg": 0.12127577225727508,
                "success_improvement": 0.0,
                "time_improvement": 52.276331034184054,
                "length_improvement": 20.60793314987834,
                "smoothness_improvement": 3020.512971587674,
                "objective_score": 43.150224058120585
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.08306193351745605,
                "num_nodes_avg": 277.3,
                "path_length_avg": 122.87997069169981,
                "smoothness_avg": 0.13485837299586953,
                "success_improvement": 0.0,
                "time_improvement": -65.17995994568392,
                "length_improvement": 18.388974381988994,
                "smoothness_improvement": 1615.3885502978142,
                "objective_score": -0.4436606030227068
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "m2",
        "algorithm_description": "A bidirectional RRT* variant that uses informed sampling within an ellipsoidal region (informed RRT*) to bias samples towards the subset of the state space likely to improve the current solution, combined with rewiring for asymptotic optimality. It incorporates direct connection attempts between trees and post-processing shortcutting for smoother, shorter paths.",
        "planning_mechanism": "The planner grows two trees from start and goal alternately, sampling randomly inside an ellipsoid defined by start, goal, and the current best path cost to focus growth in promising areas. Each new node is connected and rewired locally to improve path cost. The trees attempt direct connection when close, and after finding a solution, the planner shortcut-postprocesses the path to enhance smoothness and reduce length.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\nclass Planner:\n    def __init__(self, max_iter=3000, step_size=7.5, rewire_radius=15.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.rewire_radius = rewire_radius\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        edges = []\n        best_cost = float('inf')\n        best_path = []\n\n        def distance(a,b):\n            return math.dist(a,b)\n\n        def is_in_collision(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d = obs\n                    px,py,pz = pos\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                        return True\n                else:\n                    x,y,w,h = obs\n                    px,py = pos\n                    if x <= px <= x+w and y <= py <= y+h:\n                        return True\n            return False\n\n        def is_edge_collision(from_pos, to_pos, resolution=1.0):\n            dist = distance(from_pos, to_pos)\n            steps = max(1,int(dist / resolution))\n            for i in range(steps+1):\n                interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * i/steps for d in range(len(from_pos)))\n                if is_in_collision(interp):\n                    return True\n            return False\n\n        def steer(from_pos, to_pos, max_step):\n            dist = distance(from_pos, to_pos)\n            if dist <= max_step:\n                return to_pos\n            ratio = max_step / dist\n            return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: distance(node.position, point))\n\n        def neighbors(tree, point, radius):\n            result = []\n            r_sq = radius*radius\n            for node in tree:\n                dx = node.position[0] - point[0]\n                dy = node.position[1] - point[1]\n                dz = node.position[2] - point[2] if is_3d else 0.0\n                dist_sq = dx*dx + dy*dy + dz*dz\n                if dist_sq <= r_sq:\n                    result.append(node)\n            return result\n\n        def extract_path(node_start, node_goal):\n            path_start = []\n            while node_start:\n                path_start.append(node_start.position)\n                node_start = node_start.parent\n            path_start.reverse()\n            path_goal = []\n            while node_goal:\n                path_goal.append(node_goal.position)\n                node_goal = node_goal.parent\n            return path_start + path_goal\n\n        def try_connect(node_from, tree_to):\n            near = nearest(tree_to, node_from.position)\n            if is_edge_collision(node_from.position, near.position):\n                return None\n            # direct connection possible, make new node\n            new_node = Node(near.position, parent=node_from, cost=node_from.cost + distance(node_from.position, near.position))\n            node_from.add_child(new_node)\n            tree_to.append(new_node)\n            edges.append((node_from,new_node))\n            return new_node\n\n        def rewire(tree, new_node):\n            nbs = neighbors(tree, new_node.position, self.rewire_radius)\n            for nb in nbs:\n                if nb == new_node.parent:\n                    continue\n                if is_edge_collision(new_node.position, nb.position):\n                    continue\n                new_cost = new_node.cost + distance(new_node.position, nb.position)\n                if new_cost + 1e-7 < nb.cost:\n                    # Rewire nb's parent link\n                    if nb.parent:\n                        try:\n                            nb.parent.children.remove(nb)\n                        except ValueError:\n                            pass\n                    nb.parent = new_node\n                    nb.cost = new_cost\n                    new_node.add_child(nb)\n\n        def informed_sample(c_best):\n            # Sample uniformly inside ellipsoid defined by start, goal, c_best\n            if c_best == float('inf'):\n                # No solution found yet, uniform sample in bounds\n                while True:\n                    sample = tuple(random.uniform(0, bounds[i]) for i in range(len(bounds)))\n                    if not is_in_collision(sample):\n                        return sample\n            else:\n                c_min = distance(start_pos, goal_pos)\n                if c_min == 0.0:\n                    return goal_pos\n                # Ellipsoid parameters\n                center = tuple((start_pos[i]+goal_pos[i])/2 for i in range(len(bounds)))\n                a1 = [(goal_pos[i]-start_pos[i])/c_min for i in range(len(bounds))]\n                # Build rotation matrix to transform unit ball samples\n                # For 2D or 3D the rotation matrix is based on a1 vector\n                # Using Householder transform for rotation to align x-axis with a1\n                dim = len(bounds)\n                def mat_vec_mult(mat, vec):\n                    return tuple(sum(mat[i][j]*vec[j] for j in range(dim)) for i in range(dim))\n                # Construct orthonormal basis with a1 as first basis vector\n                # For 2D and 3D:\n                if dim == 2:\n                    # rotation angle\n                    theta = math.acos(a1[0])\n                    if a1[1]<0:\n                        theta = -theta\n                    # rotation matrix\n                    R = [[math.cos(theta), -math.sin(theta)],\n                         [math.sin(theta), math.cos(theta)]]\n                elif dim ==3:\n                    # Construct a rotation matrix using Householder reflection\n                    # vector to rotate to x = a1\n                    x = a1\n                    I = [[1 if i==j else 0 for j in range(3)] for i in range(3)]\n                    v = [x[0]-1, x[1], x[2]]\n                    norm_v = math.sqrt(sum(vi*vi for vi in v))\n                    if norm_v < 1e-10:\n                        R = I\n                    else:\n                        v = [vi/norm_v for vi in v]\n                        R = [[I[i][j] - 2*v[i]*v[j] for j in range(3)] for i in range(3)]\n                else:\n                    R = [[1 if i==j else 0 for j in range(dim)] for i in range(dim)]\n\n                # lengths of ellipsoid axes\n                L1 = c_best/2.0\n                L_other = math.sqrt(c_best*c_best - c_min*c_min)/2.0\n\n                while True:\n                    # sample random unit vector in unit ball\n                    while True:\n                        sample = [random.uniform(-1,1) for _ in range(dim)]\n                        norm_sample = math.sqrt(sum(x*x for x in sample))\n                        if 0 < norm_sample <= 1:\n                            break\n                    unit_s = [x/norm_sample for x in sample]\n                    r = random.uniform(0,1)**(1/dim)  # radius for uniform ball sampling\n                    unit_ball_sample = [r*us for us in unit_s]\n\n                    # scale by axes\n                    ellipsoid_sample = [L1*unit_ball_sample[0]] + [L_other*unit_ball_sample[i] for i in range(1,dim)]\n\n                    # rotate and translate\n                    if dim == 2 or dim == 3:\n                        rotated = mat_vec_mult(R, ellipsoid_sample)\n                    else:\n                        rotated = ellipsoid_sample\n                    point = tuple(center[i] + rotated[i] for i in range(dim))\n                    if all(0 <= point[i] <= bounds[i] for i in range(dim)):\n                        if not is_in_collision(point):\n                            return point\n\n        def shortcut_path(path):\n            if len(path)<=2:\n                return path\n            i = 0\n            while i < len(path)-2:\n                j = len(path)-1\n                while j > i+1:\n                    if not is_edge_collision(path[i], path[j]):\n                        # shortcut between i and j\n                        path = path[:i+1] + path[j:]\n                        break\n                    j -=1\n                i +=1\n            return path\n\n        for it in range(self.max_iter):\n            sample = informed_sample(best_cost)\n            for tree_a, tree_b in [(start_tree, goal_tree),(goal_tree, start_tree)]:\n                near = nearest(tree_a, sample)\n                new_pos = steer(near.position, sample, self.step_size)\n                if is_in_collision(new_pos):\n                    continue\n                if is_edge_collision(near.position, new_pos):\n                    continue\n                new_cost = near.cost + distance(near.position, new_pos)\n                new_node = Node(new_pos, parent=near, cost=new_cost)\n                near.add_child(new_node)\n                tree_a.append(new_node)\n                edges.append((near,new_node))\n\n                rewire(tree_a, new_node)\n\n                near_to_new = nearest(tree_b, new_pos)\n                dist_trees = distance(new_pos, near_to_new.position)\n                if dist_trees <= self.step_size*2 and not is_edge_collision(new_pos, near_to_new.position):\n                    connect_node = Node(near_to_new.position, parent=new_node, cost=new_node.cost + dist_trees)\n                    new_node.add_child(connect_node)\n                    tree_b.append(connect_node)\n                    edges.append((new_node, connect_node))\n                    path = extract_path(connect_node, connect_node)\n                    # extract_path from new_node to nearest node in other tree\n                    path = extract_path(new_node, near_to_new)\n                    path = shortcut_path(path)\n                    cost_path = 0.0\n                    for k in range(len(path)-1):\n                        cost_path += distance(path[k], path[k+1])\n                    if cost_path < best_cost:\n                        best_cost = cost_path\n                        best_path = path\n            if best_path:\n                return PlannerResult(True, best_path, start_tree+goal_tree, edges)\n        return PlannerResult(False, [], start_tree+goal_tree, edges)",
        "objective": -24.54042,
        "time_improvement": 22.0,
        "length_improvement": 15.0,
        "smoothness_improvement": 1806.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.019874000549316408,
                "num_nodes_avg": 86.7,
                "path_length_avg": 165.53372291805212,
                "smoothness_avg": 0.05590834490258338,
                "success_improvement": 0.0,
                "time_improvement": 24.29764885485091,
                "length_improvement": 9.26834341891934,
                "smoothness_improvement": 775.0870046395709,
                "objective_score": 16.725735731004733
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.017957305908203124,
                "num_nodes_avg": 144.4,
                "path_length_avg": 240.5533294992943,
                "smoothness_avg": 0.12055312154964279,
                "success_improvement": 0.0,
                "time_improvement": 89.12601287090475,
                "length_improvement": 19.696374669454404,
                "smoothness_improvement": 3001.9186483760295,
                "objective_score": 53.56522190482421
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.07342400550842285,
                "num_nodes_avg": 284.9,
                "path_length_avg": 128.16200978596154,
                "smoothness_avg": 0.13688525836651863,
                "success_improvement": 0.0,
                "time_improvement": -46.01362832932536,
                "length_improvement": 14.88089551925333,
                "smoothness_improvement": 1641.1703826033552,
                "objective_score": 3.3303007257711688
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "m3",
        "algorithm_description": "A simplified bidirectional RRT* inspired planner that alternates growing trees from start and goal by sampling collision-free points, extends toward samples with fixed step size, and rewires local neighbors to improve path cost dynamically. It attempts connecting the trees at each iteration, returning the combined path upon success. This approach balances planning efficiency, path quality, and smoothness through incremental rewiring and early collision checks.",
        "planning_mechanism": "The planner operates by sampling points within bounds avoiding obstacles, nearest neighbor extension with fixed step, rewiring neighbors within a computed radius to optimize cost, and alternating tree expansion. Once the two trees connect, their paths are concatenated to form the final solution.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=4000, step_size=5.0, gamma_rrt_star=30.0, max_radius=40.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.gamma_rrt_star = gamma_rrt_star\n        self.max_radius = max_radius\n\n    def plan(self, map):\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        for i in range(self.max_iter):\n            tree_a, tree_b = (tree_start, tree_goal) if i % 2 == 0 else (tree_goal, tree_start)\n            sample = self._sample_free(bounds, obstacles, is_3d)\n\n            new_node = self._extend_and_rewire(tree_a, sample, obstacles, is_3d, nodes, edges, bounds)\n            if new_node is None:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            connect_node = self._connect_and_rewire(tree_b, new_node, obstacles, is_3d, nodes, edges, bounds)\n            if connect_node:\n                path_a = new_node.path_from_root()\n                path_b = connect_node.path_from_root()\n                if path_a[-1] == path_b[-1]:\n                    path_b = path_b[:-1]\n                full_path = path_a + path_b[::-1]\n                return PlannerResult(True, full_path, nodes, edges)\n\n            tree_a, tree_b = tree_b, tree_a\n\n        return PlannerResult(False, [], nodes, edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        import random\n        dim = len(bounds)\n        while True:\n            pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            if not self._in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def _nearest(self, tree, point):\n        best = None\n        best_dist = float('inf')\n        for node in tree:\n            dist = self._dist(node.position, point)\n            if dist < best_dist:\n                best_dist = dist\n                best = node\n        return best\n\n    def _steer(self, from_pos, to_pos):\n        dist = self._dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(len(from_pos)))\n\n    def _near_nodes(self, tree, position, bounds):\n        n = max(1, len(tree))\n        d = len(position)\n        scale = max(1.0, sum(bounds) / d)\n        r_theory = self.gamma_rrt_star * ((math.log(n + 1) / (n + 1)) ** (1.0 / d))\n        radius = max(self.step_size * 2, min(self.max_radius, r_theory * 0.5 + scale * 0.02))\n        return [node for node in tree if self._dist(node.position, position) <= radius]\n\n    def _extend_and_rewire(self, tree, sample, obstacles, is_3d, nodes, edges, bounds):\n        nearest = self._nearest(tree, sample)\n        new_pos = self._steer(nearest.position, sample)\n        if self._in_obstacle(new_pos, obstacles, is_3d):\n            return None\n        if self._edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n            return None\n\n        neighbors = self._near_nodes(tree, new_pos, bounds)\n        min_cost = nearest.cost + self._dist(nearest.position, new_pos)\n        best_parent = nearest\n        for nb in neighbors:\n            if not self._edge_in_obstacle(nb.position, new_pos, obstacles, is_3d):\n                cost = nb.cost + self._dist(nb.position, new_pos)\n                if cost < min_cost:\n                    min_cost = cost\n                    best_parent = nb\n\n        new_node = Node(new_pos, cost=min_cost)\n        best_parent.add_child(new_node)\n        new_node.cost = min_cost\n        tree.append(new_node)\n        nodes.append(new_node)\n        edges.append((best_parent, new_node))\n\n        for nb in neighbors:\n            if nb == best_parent:\n                continue\n            if not self._edge_in_obstacle(new_node.position, nb.position, obstacles, is_3d):\n                updated_cost = new_node.cost + self._dist(new_node.position, nb.position)\n                if updated_cost < nb.cost:\n                    if nb.parent:\n                        try:\n                            edges.remove((nb.parent, nb))\n                        except ValueError:\n                            pass\n                        if nb in nb.parent.children:\n                            nb.parent.children.remove(nb)\n                    new_node.add_child(nb)\n                    nb.cost = updated_cost\n                    edges.append((new_node, nb))\n        return new_node\n\n    def _connect_and_rewire(self, tree, target_node, obstacles, is_3d, nodes, edges, bounds):\n        nearest = self._nearest(tree, target_node.position)\n        while True:\n            new_pos = self._steer(nearest.position, target_node.position)\n            if self._in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                return None\n\n            neighbors = self._near_nodes(tree, new_pos, bounds)\n            min_cost = nearest.cost + self._dist(nearest.position, new_pos)\n            best_parent = nearest\n            for nb in neighbors:\n                if not self._edge_in_obstacle(nb.position, new_pos, obstacles, is_3d):\n                    cost = nb.cost + self._dist(nb.position, new_pos)\n                    if cost < min_cost:\n                        min_cost = cost\n                        best_parent = nb\n\n            new_node = Node(new_pos, cost=min_cost)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            for nb in neighbors:\n                if nb == best_parent:\n                    continue\n                if not self._edge_in_obstacle(new_node.position, nb.position, obstacles, is_3d):\n                    updated_cost = new_node.cost + self._dist(new_node.position, nb.position)\n                    if updated_cost < nb.cost:\n                        if nb.parent:\n                            try:\n                                edges.remove((nb.parent, nb))\n                            except ValueError:\n                                pass\n                            if nb in nb.parent.children:\n                                nb.parent.children.remove(nb)\n                        new_node.add_child(nb)\n                        nb.cost = updated_cost\n                        edges.append((new_node, nb))\n\n            if self._dist(new_node.position, target_node.position) <= self.step_size:\n                if (not self._edge_in_obstacle(new_node.position, target_node.position, obstacles, is_3d)\n                   and not self._in_obstacle(target_node.position, obstacles, is_3d)):\n                    final_node = Node(target_node.position, cost=new_node.cost + self._dist(new_node.position, target_node.position))\n                    new_node.add_child(final_node)\n                    tree.append(final_node)\n                    nodes.append(final_node)\n                    edges.append((new_node, final_node))\n                    return final_node\n                else:\n                    return None\n            nearest = new_node\n\n    def _in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _edge_in_obstacle(self, p1, p2, obstacles, is_3d, resolution=1.0):\n        dist = self._dist(p1, p2)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(p1[d] + (p2[d] - p1[d]) * i / steps for d in range(len(p1)))\n            if self._in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _dist(self, a, b):\n        s = 0\n        for i in range(len(a)):\n            s += (a[i] - b[i]) ** 2\n        return s ** 0.5",
        "objective": -23.86958,
        "time_improvement": 56.0,
        "length_improvement": 11.0,
        "smoothness_improvement": 157.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.010033559799194337,
                "num_nodes_avg": 60.9,
                "path_length_avg": 164.20093510394682,
                "smoothness_avg": 0.01583828018408221,
                "success_improvement": 0.0,
                "time_improvement": 61.78101810606081,
                "length_improvement": 9.99886553920486,
                "smoothness_improvement": 147.90347825679143,
                "objective_score": 25.273142146625116
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.050237512588500975,
                "num_nodes_avg": 241.6,
                "path_length_avg": 264.8016597340139,
                "smoothness_avg": 0.010300759767330584,
                "success_improvement": 0.0,
                "time_improvement": 69.57884060795715,
                "length_improvement": 11.601584087618049,
                "smoothness_improvement": 165.04596815078446,
                "objective_score": 28.659832475711898
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.0325772762298584,
                "num_nodes_avg": 182.9,
                "path_length_avg": 134.71639352764254,
                "smoothness_avg": 0.020352271921149336,
                "success_improvement": 0.0,
                "time_improvement": 35.21565228605458,
                "length_improvement": 10.527785924243197,
                "smoothness_improvement": 158.87939658857192,
                "objective_score": 17.67576422330515
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "m3",
        "algorithm_description": "A simplified bidirectional RRT* algorithm that grows two trees from start and goal, samples uniformly with bias towards improving the solution, rewires locally to optimize paths, attempts direct connections between trees to find a path, and performs post-processing shortcutting to smooth and shorten the final path. It uses straightforward nearest neighbor search and basic collision checking to ensure valid paths while balancing computational cost and path quality.",
        "planning_mechanism": "The planner alternates growing start and goal trees towards sampled points inside the map bounds or within the informed ellipsoid if a solution exists. New nodes are linked and rewired locally to reduce path cost. It frequently attempts to connect the two trees directly upon proximity. Upon finding a path, it applies shortcutting to improve smoothness. The search halts on first valid path or after max iterations.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\nclass Planner:\n    def __init__(self, max_iter=3000, step_size=7.5, rewire_radius=15.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.rewire_radius = rewire_radius\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        edges = []\n        best_cost = float('inf')\n        best_path = []\n\n        def dist(a, b):\n            return sum((a[i]-b[i])**2 for i in range(dim))**0.5\n\n        def in_collision(p):\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d = obs\n                    if x <= p[0] <= x+w and y <= p[1] <= y+h and z <= p[2] <= z+d:\n                        return True\n                else:\n                    x,y,w,h = obs\n                    if x <= p[0] <= x+w and y <= p[1] <= y+h:\n                        return True\n            return False\n\n        def edge_collision(a, b, resolution=1.0):\n            d = dist(a,b)\n            steps = max(1, int(d/resolution))\n            for i in range(steps+1):\n                pt = tuple(a[j] + (b[j]-a[j]) * i/steps for j in range(dim))\n                if in_collision(pt):\n                    return True\n            return False\n\n        def steer(from_p, to_p, max_step):\n            d = dist(from_p, to_p)\n            if d <= max_step:\n                return to_p\n            ratio = max_step / d\n            return tuple(from_p[i] + (to_p[i]-from_p[i])*ratio for i in range(dim))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: dist(n.position, point))\n\n        def neighbors(tree, point, radius):\n            radius_sq = radius*radius\n            result = []\n            for n in tree:\n                if sum((n.position[i]-point[i])**2 for i in range(dim)) <= radius_sq:\n                    result.append(n)\n            return result\n\n        def extract_path(node_start, node_goal):\n            path_start = []\n            n = node_start\n            while n:\n                path_start.append(n.position)\n                n = n.parent\n            path_start.reverse()\n            path_goal = []\n            n = node_goal\n            while n:\n                path_goal.append(n.position)\n                n = n.parent\n            return path_start + path_goal\n\n        def sample_informed(c_best):\n            if c_best == float('inf'):\n                while True:\n                    p = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                    if not in_collision(p):\n                        return p\n            c_min = dist(start_pos, goal_pos)\n            if c_min == 0.0:\n                return goal_pos\n            center = tuple((start_pos[i]+goal_pos[i])/2 for i in range(dim))\n            a1 = [(goal_pos[i]-start_pos[i])/c_min for i in range(dim)]\n            L1 = c_best/2.0\n            L2 = ((c_best**2 - c_min**2)**0.5)/2.0\n            while True:\n                while True:\n                    sample = [random.uniform(-1,1) for _ in range(dim)]\n                    norm_s = sum(s*s for s in sample)**0.5\n                    if 0 < norm_s <= 1:\n                        break\n                unit_s = [s/norm_s for s in sample]\n                r = random.uniform(0,1)**(1/dim)\n                unit_ball = [r*us for us in unit_s]\n                ellipsoid_sample = [L1*unit_ball[0]] + [L2*unit_ball[i] for i in range(1,dim)]\n                # Rotate ellipsoid sample to align with a1 (only 2D/3D)\n                if dim == 2:\n                    theta = 0\n                    if abs(a1[0]) < 1.0:\n                        theta = math.acos(a1[0])\n                        if a1[1] < 0:\n                            theta = -theta\n                    x = ellipsoid_sample[0]*math.cos(theta) - ellipsoid_sample[1]*math.sin(theta)\n                    y = ellipsoid_sample[0]*math.sin(theta) + ellipsoid_sample[1]*math.cos(theta)\n                    p = (center[0]+x, center[1]+y)\n                elif dim == 3:\n                    # simple rotation aligning x-axis to a1 using Householder reflection\n                    x = a1\n                    I = [[1 if i==j else 0 for j in range(3)] for i in range(3)]\n                    v = [x[0]-1, x[1], x[2]]\n                    norm_v = sum(vi*vi for vi in v)**0.5\n                    if norm_v < 1e-10:\n                        R = I\n                    else:\n                        v = [vi/norm_v for vi in v]\n                        R = [[I[i][j] - 2*v[i]*v[j] for j in range(3)] for i in range(3)]\n                    rotated = tuple(sum(R[i][j]*ellipsoid_sample[j] for j in range(3)) for i in range(3))\n                    p = tuple(center[i] + rotated[i] for i in range(3))\n                else:\n                    p = tuple(center[i] + ellipsoid_sample[i] for i in range(dim))\n                if all(0 <= p[i] <= bounds[i] for i in range(dim)) and not in_collision(p):\n                    return p\n\n        def shortcut_path(path):\n            if len(path)<3:\n                return path\n            i = 0\n            while i < len(path)-2:\n                j = len(path)-1\n                while j > i+1:\n                    if not edge_collision(path[i], path[j]):\n                        path = path[:i+1]+path[j:]\n                        break\n                    j -=1\n                i +=1\n            return path\n\n        def rewire(tree, new_node):\n            nghs = neighbors(tree, new_node.position, self.rewire_radius)\n            for ngh in nghs:\n                if ngh == new_node.parent:\n                    continue\n                if edge_collision(new_node.position, ngh.position):\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, ngh.position)\n                if new_cost + 1e-7 < ngh.cost:\n                    if ngh.parent:\n                        try:\n                            ngh.parent.children.remove(ngh)\n                        except:\n                            pass\n                    ngh.parent = new_node\n                    ngh.cost = new_cost\n                    new_node.add_child(ngh)\n\n        for iteration in range(self.max_iter):\n            sample = sample_informed(best_cost)\n            for (tree_a, tree_b) in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nn = nearest(tree_a, sample)\n                new_pos = steer(nn.position, sample, self.step_size)\n                if in_collision(new_pos) or edge_collision(nn.position, new_pos):\n                    continue\n                new_cost = nn.cost + dist(nn.position, new_pos)\n                new_node = Node(new_pos, parent=nn, cost=new_cost)\n                nn.add_child(new_node)\n                tree_a.append(new_node)\n                edges.append((nn, new_node))\n\n                rewire(tree_a, new_node)\n\n                nearest_other = nearest(tree_b, new_pos)\n                dist_trees = dist(new_pos, nearest_other.position)\n                if dist_trees <= self.step_size*2 and not edge_collision(new_pos, nearest_other.position):\n                    connect_node = Node(nearest_other.position, parent=new_node, cost=new_node.cost + dist_trees)\n                    new_node.add_child(connect_node)\n                    tree_b.append(connect_node)\n                    edges.append((new_node, connect_node))\n\n                    path = extract_path(new_node, nearest_other)\n                    path = shortcut_path(path)\n\n                    cost_path = 0.0\n                    for k in range(len(path)-1):\n                        cost_path += dist(path[k], path[k+1])\n                    if cost_path < best_cost:\n                        best_cost = cost_path\n                        best_path = path\n            if best_path:\n                return PlannerResult(True, best_path, start_tree+goal_tree, edges)\n        return PlannerResult(False, [], start_tree+goal_tree, edges)",
        "objective": -7.96217,
        "time_improvement": -25.0,
        "length_improvement": 11.0,
        "smoothness_improvement": 1799.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.05618610382080078,
                "num_nodes_avg": 139.8,
                "path_length_avg": 185.25496856355855,
                "smoothness_avg": 0.04960682018479354,
                "success_improvement": 0.0,
                "time_improvement": -114.01932390840987,
                "length_improvement": -1.5411838225179815,
                "smoothness_improvement": 676.4544588262154,
                "objective_score": -31.748235171902678
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.037730622291564944,
                "num_nodes_avg": 170.8,
                "path_length_avg": 236.8253031039858,
                "smoothness_avg": 0.12587993282534443,
                "success_improvement": 0.0,
                "time_improvement": 77.15234661209345,
                "length_improvement": 20.94089718549847,
                "smoothness_improvement": 3138.9813392469123,
                "objective_score": 51.40514899116168
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.06945254802703857,
                "num_nodes_avg": 205.7,
                "path_length_avg": 131.1004396537589,
                "smoothness_avg": 0.13218220013348647,
                "success_improvement": 0.0,
                "time_improvement": -38.11584459228801,
                "length_improvement": 12.929330314056402,
                "smoothness_improvement": 1581.3478290228345,
                "objective_score": 4.22958395586161
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "m3",
        "algorithm_description": "A simplified and efficient bidirectional RRT* planner that incrementally grows two trees from start and goal, sampling free space with goal bias, extending one tree towards samples stepwise, choosing best parents within a radius, rewiring neighbors to reduce costs, and attempting connection between trees for fast solution. It ensures collision-free nodes and edges with minimal overhead and prioritized early stopping on solution discovery.",
        "planning_mechanism": "The planner alternates growing two trees toward random samples, connecting new nodes by selecting lowest cost parents in a neighborhood, rewires neighbors to optimize paths locally, and greedily connects trees incrementally. Planning stops on first found solution or max iterations.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        node, path = self, []\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=3000, step_size=4.0, gamma=50.0, max_radius=40.0, goal_sample_rate=0.05):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.gamma = gamma\n        self.max_radius = max_radius\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map):\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        tree_start = [Node(start_pos)]\n        tree_goal = [Node(goal_pos)]\n        nodes = tree_start + tree_goal\n        edges = []\n\n        def in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    px, py = pos\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def edge_collision(p1, p2, resolution=1.0):\n            dist = math.dist(p1, p2)\n            steps = max(1, int(dist / resolution))\n            for i in range(steps + 1):\n                interm = tuple(p1[d] + (p2[d] - p1[d]) * i / steps for d in range(dim))\n                if in_obstacle(interm):\n                    return True\n            return False\n\n        def sample_free():\n            if random.random() < self.goal_sample_rate:\n                return goal_pos\n            while True:\n                s = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not in_obstacle(s):\n                    return s\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: math.dist(n.position, point))\n\n        def steer(from_p, to_p):\n            dist = math.dist(from_p, to_p)\n            if dist <= self.step_size:\n                return to_p\n            ratio = self.step_size / dist\n            return tuple(from_p[d] + (to_p[d] - from_p[d]) * ratio for d in range(dim))\n\n        def neighbor_radius(n):\n            if n < 2:\n                return self.step_size * 2.0\n            r = self.gamma * ((math.log(n) / n) ** (1 / dim))\n            return min(max(self.step_size * 2, r), self.max_radius)\n\n        def near_nodes(tree, pos):\n            radius = neighbor_radius(len(tree))\n            return [n for n in tree if math.dist(n.position, pos) <= radius]\n\n        def can_connect(p1, p2):\n            return (not in_obstacle(p2) and not edge_collision(p1, p2))\n\n        def add_node(tree, new_pos):\n            near = near_nodes(tree, new_pos)\n            candidates = [n for n in near if can_connect(n.position, new_pos)]\n            if not candidates:\n                parent = nearest(tree, new_pos)\n                if not can_connect(parent.position, new_pos):\n                    return None\n                best_parent = parent\n                best_cost = parent.cost + math.dist(parent.position, new_pos)\n            else:\n                best_parent, best_cost = min(\n                    ((n, n.cost + math.dist(n.position, new_pos)) for n in candidates),\n                    key=lambda x: x[1]\n                )\n            new_node = Node(new_pos, parent=None, cost=best_cost)\n            best_parent.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n            return new_node\n\n        def rewire(new_node, neighbors):\n            for nb in neighbors:\n                if nb is new_node:\n                    continue\n                if can_connect(new_node.position, nb.position):\n                    new_cost = new_node.cost + math.dist(new_node.position, nb.position)\n                    if new_cost + 1e-12 < nb.cost:\n                        if nb.parent:\n                            try:\n                                edges.remove((nb.parent, nb))\n                            except ValueError:\n                                pass\n                            if nb in nb.parent.children:\n                                nb.parent.children.remove(nb)\n                        new_node.add_child(nb)\n                        nb.cost = new_cost\n                        edges.append((new_node, nb))\n\n        def extend(tree, target, other_tree):\n            nearest_node = nearest(tree, target)\n            new_pos = steer(nearest_node.position, target)\n            if not can_connect(nearest_node.position, new_pos):\n                return None\n            new_node = add_node(tree, new_pos)\n            if not new_node:\n                return None\n            near = near_nodes(tree, new_pos)\n            rewire(new_node, near)\n            connect_node = attempt_connect(other_tree, new_node)\n            if connect_node:\n                return new_node, connect_node\n            return new_node, None\n\n        def attempt_connect(tree, target_node):\n            nearest_node = nearest(tree, target_node.position)\n            current = nearest_node\n            while True:\n                new_pos = steer(current.position, target_node.position)\n                if not can_connect(current.position, new_pos):\n                    return None\n                new_node = add_node(tree, new_pos)\n                if not new_node:\n                    return None\n                near = near_nodes(tree, new_pos)\n                rewire(new_node, near)\n                current = new_node\n                if math.dist(current.position, target_node.position) <= self.step_size:\n                    if can_connect(current.position, target_node.position):\n                        final_node = Node(target_node.position, parent=None, cost=current.cost + math.dist(current.position, target_node.position))\n                        current.add_child(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((current, final_node))\n                        return final_node\n                    else:\n                        return None\n\n        best_path = []\n        found = False\n        for _ in range(self.max_iter):\n            sample = sample_free()\n            res = extend(tree_start, sample, tree_goal)\n            if res is None:\n                tree_start, tree_goal = tree_goal, tree_start\n                continue\n            new_node, connect_node = res\n            if connect_node:\n                path_start = new_node.path_from_root()\n                path_goal = connect_node.path_from_root()\n                if path_start[-1] == path_goal[-1]:\n                    path_goal = path_goal[:-1]\n                best_path = path_start + path_goal[::-1]\n                found = True\n                break\n            tree_start, tree_goal = tree_goal, tree_start\n\n        return PlannerResult(success=found, path=best_path, nodes=nodes, edges=edges)",
        "objective": -3.14348,
        "time_improvement": -23.0,
        "length_improvement": 15.0,
        "smoothness_improvement": 270.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.04289665222167969,
                "num_nodes_avg": 86.2,
                "path_length_avg": 154.80487257571312,
                "smoothness_avg": 0.029055568068706832,
                "success_improvement": 0.0,
                "time_improvement": -63.398276123557494,
                "length_improvement": 15.14899630106843,
                "smoothness_improvement": 354.7827354511964,
                "objective_score": -8.156171379170209
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.07331087589263915,
                "num_nodes_avg": 305.3,
                "path_length_avg": 256.0586439039306,
                "smoothness_avg": 0.012268278642848006,
                "success_improvement": 0.0,
                "time_improvement": 55.60684186400731,
                "length_improvement": 14.52025442545721,
                "smoothness_improvement": 215.67164596441225,
                "objective_score": 26.472563444298576
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.08116095066070557,
                "num_nodes_avg": 297.7,
                "path_length_avg": 129.65699918833218,
                "smoothness_avg": 0.02674729664510849,
                "success_improvement": 0.0,
                "time_improvement": -61.399596801723554,
                "length_improvement": 13.887994741944096,
                "smoothness_improvement": 240.22363904570852,
                "objective_score": -8.885964000122067
            }
        ],
        "success_rate": 1.0
    }
]