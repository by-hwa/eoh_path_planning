[
    {
        "operator": "e2",
        "algorithm_description": "A hybrid bidirectional planner combining fast incremental exploration and post-path optimization with rewiring and informed sampling to improve efficiency, path length, success rate, and smoothness. It grows start and goal trees with RRT* style sampling, parent selection, and rewiring, attempting connection at each step. Once a valid path is found, informed sampling inside the ellipsoid between start and goal focuses search to optimize the path further. The final returned path is shortcut-smoothed to reduce unnecessary waypoints and sharp turns.",
        "planning_mechanism": "The planner alternates growing start and goal trees with RRT* expansions including best-parent selection and rewiring to improve path quality. Random samples are drawn uniformly initially, then inside an ellipsoid after first solution for focused optimization. Each extension tries to connect the two trees, and after the first connection the planner continues optimizing until iteration or improvement limits. Optionally, the output path is shortcut-smoothed to reduce length and increase smoothness.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True  # reserved for future collision checking updates\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        path.reverse()\n        return path\nclass Planner:\n    def __init__(self,\n                 max_iter=6000,\n                 step_size=4.0,\n                 neighbor_radius=None,\n                 post_opt_iters=600,\n                 max_no_improve=150,\n                 improve_tol=1e-5,\n                 time_limit_sec=25.0,\n                 shortcutting_trials=150):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.post_opt_iters = post_opt_iters\n        self.max_no_improve = max_no_improve\n        self.improve_tol = improve_tol\n        self.time_limit_sec = time_limit_sec\n        self.shortcutting_trials = shortcutting_trials\n        # neighbor radius factor for RRT*\n        self.gamma_rrt_star = 50.0\n        self.neighbor_radius = neighbor_radius  # if None will compute dynamically\n\n    def plan(self, map):\n        bounds = map.size\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        obstacles = map.obstacles\n\n        start_pos = map.start\n        goal_pos = map.goal\n\n        # Initialize data\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        best_cost = float('inf')\n        best_path = []\n        c_min = math.dist(start_pos, goal_pos)\n\n        found_solution = False\n        post_iter = 0\n        no_improve_count = 0\n\n        start_time = time.time()\n\n        def within_bounds(p):\n            return all(0.0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_p, to_p):\n            d = dist(from_p, to_p)\n            if d <= self.step_size:\n                return to_p\n            r = self.step_size / d\n            return tuple(from_p[i] + (to_p[i] - from_p[i]) * r for i in range(dim))\n\n        def neighbor_radius_fn(n_nodes):\n            if self.neighbor_radius is not None:\n                return self.neighbor_radius\n            if n_nodes < 2:\n                return self.step_size * 2.0\n            r_theory = self.gamma_rrt_star * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            maxr = max(bounds) * 0.25\n            return max(self.step_size * 2.0, min(r_theory, maxr))\n\n        def nearest(tree, pt):\n            mn = None\n            md = float(\"inf\")\n            for n in tree:\n                d = dist(n.position, pt)\n                if d < md:\n                    md = d\n                    mn = n\n            return mn\n\n        def near_nodes(tree, pos, radius):\n            result = []\n            r_sq = radius * radius\n            for n in tree:\n                d_sq = sum((n.position[i] - pos[i]) ** 2 for i in range(dim))\n                if d_sq <= r_sq:\n                    result.append(n)\n            return result\n\n        def edge_collision_free(p1, p2):\n            distance = dist(p1, p2)\n            steps = max(2, int(distance / 1.0))\n            for i in range(steps + 1):\n                ip = tuple(p1[d] + (p2[d] - p1[d]) * (i / steps) for d in range(dim))\n                if self._is_in_obstacle(ip, obstacles, is_3d):\n                    return False\n            return True\n\n        def collision_free(p):\n            return not self._is_in_obstacle(p, obstacles, is_3d)\n\n        def add_node_rrtstar(tree, pos):\n            r = neighbor_radius_fn(len(tree))\n            neigh = near_nodes(tree, pos, r)\n\n            candidate_parents = [n for n in neigh if edge_collision_free(n.position, pos)]\n            if not candidate_parents:\n                # fallback to nearest if no collision-free neighbors found\n                nnear = nearest(tree, pos)\n                if edge_collision_free(nnear.position, pos):\n                    parent = nnear\n                else:\n                    return None, []\n            else:\n                parent = min(candidate_parents, key=lambda n: n.cost + dist(n.position, pos))\n            new_cost = parent.cost + dist(parent.position, pos)\n            new_node = Node(pos, parent=None, cost=new_cost)\n            parent.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((parent, new_node))\n            return new_node, neigh\n\n        def rewire(node, neighbors):\n            for nb in neighbors:\n                if nb is node:\n                    continue\n                if not edge_collision_free(node.position, nb.position):\n                    continue\n                new_cost = node.cost + dist(node.position, nb.position)\n                if new_cost + 1e-12 < nb.cost:\n                    # reconnect neighbor via node\n                    if nb.parent:\n                        try:\n                            edges.remove((nb.parent, nb))\n                        except ValueError:\n                            pass\n                        if nb in nb.parent.children:\n                            nb.parent.children.remove(nb)\n                    node.add_child(nb)\n                    nb.cost = new_cost\n                    edges.append((node, nb))\n\n        def stitch_paths(node_start, node_goal):\n            path_start = node_start.path_from_root()\n            path_goal = node_goal.path_from_root()\n            # remove duplicated meeting node if any\n            if path_start and path_goal and path_start[-1] == path_goal[-1]:\n                merged = path_start + path_goal[-2::-1]\n            else:\n                merged = path_start + path_goal[::-1]\n            return merged\n\n        def path_cost(path):\n            c = 0.0\n            for i in range(len(path) - 1):\n                c += dist(path[i], path[i+1])\n            return c\n\n        def informed_sample(start, goal, c_best, c_min):\n            if c_best == float(\"inf\") or c_min < 1e-12:\n                return tuple(random.uniform(0.0, bounds[d]) for d in range(dim))\n            r1 = c_best / 2.0\n            r_other_sq = max(c_best * c_best - c_min * c_min, 0.0)\n            r_other = math.sqrt(r_other_sq) / 2.0\n            center = tuple((start[d] + goal[d]) / 2.0 for d in range(dim))\n            a1 = tuple((goal[d] - start[d]) / c_min for d in range(dim))\n\n            def sample_unit_ball(k):\n                while True:\n                    v = [random.gauss(0, 1) for _ in range(k)]\n                    norm_v = math.sqrt(sum(x * x for x in v))\n                    if norm_v > 1e-12:\n                        v = [x / norm_v for x in v]\n                        r = random.random() ** (1.0 / k)\n                        return tuple(v[i] * r for i in range(k))\n\n            u = sample_unit_ball(dim)\n\n            if dim == 2:\n                a2 = (-a1[1], a1[0])\n                basis = (a1, a2)\n                radii = (r1, r_other)\n            else:\n                ref = (1.0, 0.0, 0.0) if abs(a1[0]) < 0.9 else (0.0, 1.0, 0.0)\n                b2 = self._normalize(self._cross(a1, ref))\n                if self._norm(b2) < 1e-12:\n                    ref = (0.0, 0.0, 1.0)\n                    b2 = self._normalize(self._cross(a1, ref))\n                b3 = self._cross(a1, b2)\n                basis = (a1, b2, b3)\n                radii = (r1, r_other, r_other)\n\n            sample = []\n            for d in range(dim):\n                val = center[d]\n                for i in range(dim):\n                    val += basis[i][d] * radii[i] * u[i]\n                # Clamp inside bounds\n                val = max(0.0, min(bounds[d], val))\n                sample.append(val)\n            return tuple(sample)\n\n        def smooth_path(path, max_trials):\n            if len(path) < 3:\n                return path\n            new_path = path[:]\n            for _ in range(max_trials):\n                if len(new_path) < 3:\n                    break\n                i = random.randint(0, len(new_path) - 3)\n                j = random.randint(i+2, len(new_path) - 1)\n                if edge_collision_free(new_path[i], new_path[j]):\n                    # remove intermediate points between i and j\n                    new_path = new_path[:i+1] + new_path[j:]\n            return new_path\n\n        def try_connect_trees(new_node, other_tree, other_tree_nodes):\n            nearest_other = nearest(other_tree, new_node.position)\n            if dist(nearest_other.position, new_node.position) <= self.step_size:\n                if edge_collision_free(new_node.position, nearest_other.position):\n                    # Connect by creating new node optionally in other_tree for symmetry\n                    return new_node, nearest_other\n            # Otherwise try incremental steer connection on other tree side\n            curr = nearest_other\n            while True:\n                step_pos = steer(curr.position, new_node.position)\n                if not within_bounds(step_pos) or not collision_free(step_pos):\n                    break\n                if not edge_collision_free(curr.position, step_pos):\n                    break\n                new_other_node, _ = add_node_rrtstar(other_tree, step_pos)\n                if new_other_node is None:\n                    break\n                rewire(new_other_node, near_nodes(other_tree, step_pos, neighbor_radius_fn(len(other_tree))))\n                curr = new_other_node\n                if dist(curr.position, new_node.position) <= self.step_size:\n                    if edge_collision_free(curr.position, new_node.position):\n                        # Create virtual connection node aligned with new_node\n                        return new_node, curr\n            return None, None\n\n        iteration = 0\n        while iteration < self.max_iter:\n            if time.time() - start_time > self.time_limit_sec:\n                break\n            side_toggle = iteration % 2\n            if side_toggle == 0:\n                grow_tree, other_tree = start_tree, goal_tree\n                grow_is_start = True\n            else:\n                grow_tree, other_tree = goal_tree, start_tree\n                grow_is_start = False\n\n            # Sample either uniformly or informed if solution known\n            sample = informed_sample(start_pos, goal_pos, best_cost, c_min) if found_solution else \\\n                     tuple(random.uniform(0.0, bounds[d]) for d in range(dim))\n\n            if not within_bounds(sample) or not collision_free(sample):\n                if found_solution:\n                    post_iter += 1\n                    no_improve_count += 1\n                    if post_iter >= self.post_opt_iters or no_improve_count >= self.max_no_improve:\n                        break\n                iteration += 1\n                continue\n\n            nearest_node = nearest(grow_tree, sample)\n            new_pos = steer(nearest_node.position, sample)\n            if not within_bounds(new_pos) or not collision_free(new_pos):\n                if found_solution:\n                    post_iter += 1\n                    no_improve_count += 1\n                    if post_iter >= self.post_opt_iters or no_improve_count >= self.max_no_improve:\n                        break\n                iteration += 1\n                continue\n            if not edge_collision_free(nearest_node.position, new_pos):\n                if found_solution:\n                    post_iter += 1\n                    no_improve_count += 1\n                    if post_iter >= self.post_opt_iters or no_improve_count >= self.max_no_improve:\n                        break\n                iteration += 1\n                continue\n\n            new_node, neighbors = add_node_rrtstar(grow_tree, new_pos)\n            if new_node is None:\n                if found_solution:\n                    post_iter += 1\n                    no_improve_count += 1\n                    if post_iter >= self.post_opt_iters or no_improve_count >= self.max_no_improve:\n                        break\n                iteration += 1\n                continue\n\n            rewire(new_node, neighbors)\n\n            # Attempt to connect trees via new_node\n            n1, n2 = try_connect_trees(new_node, other_tree, nodes)\n            if n1 and n2:\n                candidate_path = stitch_paths(n1, n2)\n                candidate_cost = path_cost(candidate_path)\n\n                if candidate_cost + self.improve_tol < best_cost:\n                    best_cost = candidate_cost\n                    best_path = candidate_path\n                    found_solution = True\n                    no_improve_count = 0\n                    post_iter = 0\n                else:\n                    if found_solution:\n                        no_improve_count += 1\n                        post_iter += 1\n\n                if found_solution and (post_iter >= self.post_opt_iters or no_improve_count >= self.max_no_improve):\n                    break\n            else:\n                if found_solution:\n                    post_iter += 1\n                    no_improve_count += 1\n                    if post_iter >= self.post_opt_iters or no_improve_count >= self.max_no_improve:\n                        break\n\n            iteration += 1\n\n        if found_solution and best_path:\n            smooth = smooth_path(best_path, self.shortcutting_trials)\n        else:\n            smooth = []\n\n        return PlannerResult(\n            success=found_solution,\n            path=smooth if smooth else best_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    # ---------------- Collision Helpers ----------------\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    # ----------------------------------------------------------------\n    # Vector math utilities\n    # ----------------------------------------------------------------\n    def _cross(self, a, b):\n        ax, ay, az = a\n        bx, by, bz = b\n        return (ay * bz - az * by, az * bx - ax * bz, ax * by - ay * bx)\n\n    def _norm(self, v):\n        return math.sqrt(sum(x * x for x in v))\n\n    def _normalize(self, v):\n        n = self._norm(v)\n        if n < 1e-12:\n            return v\n        return tuple(x / n for x in v)",
        "objective": 30.8005,
        "time_improvement": -164.0,
        "length_improvement": 20.0,
        "smoothness_improvement": 1288.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.0989145278930664,
                "num_nodes_avg": 208.6,
                "path_length_avg": 152.44922059390572,
                "smoothness_avg": 0.04405342963083721,
                "success_improvement": 0.0,
                "time_improvement": -276.7767996854121,
                "length_improvement": 16.440166479991422,
                "smoothness_improvement": 589.5318372761939,
                "objective_score": -70.2212808312478
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.12343411445617676,
                "num_nodes_avg": 460.7,
                "path_length_avg": 228.4633553814897,
                "smoothness_avg": 0.08673156530289851,
                "success_improvement": 0.0,
                "time_improvement": 25.25488072937533,
                "length_improvement": 23.7323560205877,
                "smoothness_improvement": 2131.665645465001,
                "objective_score": 32.474206058490225
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.17110490798950195,
                "num_nodes_avg": 411.5,
                "path_length_avg": 121.1728155761859,
                "smoothness_avg": 0.09766590253227968,
                "success_improvement": 0.0,
                "time_improvement": -240.2653977742545,
                "length_improvement": 19.52278552372241,
                "smoothness_improvement": 1142.3030712635552,
                "objective_score": -54.65443266172513
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "e2",
        "algorithm_description": "A Hybrid Bidirectional Informed RRT* with Adaptive Neighborhood and Smooth Path Post-processing. The planner alternates growing two asymptotically optimal trees from start and goal using informed sampling within ellipsoidal bounds after first solution. It uses an adaptive neighborhood radius for rewiring and best parent selection to improve path quality while ensuring collision-free incremental expansion. Upon connecting trees, the algorithm performs shortcut smoothing on the path to enhance smoothness and reduce length before returning the result. This combination accelerates convergence, improves path optimality, and produces smoother feasible paths efficiently.",
        "planning_mechanism": "The planner initializes two trees at start and goal, grows them iteratively by sampling points either uniformly or informed within an ellipsoid after first solution, selecting parents for new nodes based on minimal path cost, and rewires neighbors within a dynamically computed radius to optimize local subtrees. Trees attempt connection after new node insertion; a feasible connection yields a combined path which is then shortcut-smoothed to reduce unnecessary turns and path length. This hybrid approach balances exploration and exploitation, improves computation efficiency, and delivers practical high-quality solutions.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        path = []\n        n = self\n        while n:\n            path.append(n.position)\n            n = n.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=5.0, gamma=60.0, \n                 post_opt_iters=300, max_no_improve=100, time_limit_sec=30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.gamma = gamma\n        self.post_opt_iters = post_opt_iters\n        self.max_no_improve = max_no_improve\n        self.time_limit_sec = time_limit_sec\n\n    def plan(self, map):\n        import math\n        import random\n        import time\n\n        bounds = map.size\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        def within_bounds(p):\n            return all(0.0 <= p[d] <= bounds[d] for d in range(dim))\n\n        # Initialize trees and data containers\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        tree_a = [start_root]\n        tree_b = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        c_min = math.dist(start_pos, goal_pos)\n        best_cost = float(\"inf\")\n        best_path = []\n        found_solution = False\n        no_improve_count = 0\n        post_opt_count = 0\n        start_time = time.time()\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_p, to_p):\n            d = dist(from_p, to_p)\n            if d <= self.step_size:\n                return to_p\n            r = self.step_size / d\n            return tuple(from_p[i] + (to_p[i] - from_p[i]) * r for i in range(dim))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: dist(n.position, point))\n\n        def neighbor_radius(n_nodes):\n            if n_nodes < 2:\n                return self.step_size * 2.0\n            r = self.gamma * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            max_r = max(bounds) * 0.30\n            min_r = max(10.0, self.step_size * 2.0)\n            return max(min_r, min(max_r, r))\n\n        def near_nodes(tree, point, radius):\n            return [n for n in tree if dist(n.position, point) <= radius]\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    px, py = pos\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(a, b, resolution=1.0):\n            length = dist(a, b)\n            steps = max(1, int(length / resolution))\n            for i in range(steps + 1):\n                interp = tuple(a[d] + (b[d] - a[d]) * (i / steps) for d in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def sample_uniform():\n            while True:\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle(p):\n                    return p\n\n        def sample_unit_ball():\n            while True:\n                v = [random.gauss(0, 1) for _ in range(dim)]\n                nrm = math.sqrt(sum(x*x for x in v))\n                if nrm > 1e-12:\n                    v = [x / nrm for x in v]\n                    r = random.random() ** (1.0 / dim)\n                    return tuple(v[i]*r for i in range(dim))\n\n        # Informed sampling inside the ellipsoid (or uniform if no solution)\n        def sample_informed(c_best):\n            if not found_solution or c_best == float(\"inf\") or c_min <= 1e-12:\n                return sample_uniform()\n            r1 = c_best / 2.0\n            r_other_sq = max(c_best * c_best - c_min * c_min, 0.0)\n            r_other = math.sqrt(r_other_sq) / 2.0\n            center = tuple((start_pos[d] + goal_pos[d]) / 2.0 for d in range(dim))\n            unit_vec = tuple((goal_pos[d] - start_pos[d]) / c_min for d in range(dim))\n\n            # Construct orthonormal basis for the ellipsoid axes\n            if dim == 2:\n                # Perp vector in 2D\n                perp_vec = (-unit_vec[1], unit_vec[0])\n                basis = [unit_vec, perp_vec]\n                radii = [r1, r_other]\n            else:  # 3D\n                # Create two perpendicular vectors using cross products\n                def cross(u,v):\n                    return (u[1]*v[2]-u[2]*v[1], u[2]*v[0]-u[0]*v[2], u[0]*v[1]-u[1]*v[0])\n                def norm(v):\n                    return math.sqrt(sum(x*x for x in v))\n                def normalize(v):\n                    n = norm(v)\n                    if n < 1e-12:\n                        return v\n                    return tuple(x/n for x in v)\n                ref = (1.0, 0.0, 0.0) if abs(unit_vec[0]) < 0.9 else (0.0, 1.0, 0.0)\n                b2 = normalize(cross(unit_vec, ref))\n                if norm(b2) < 1e-12:\n                    ref = (0.0, 0.0, 1.0)\n                    b2 = normalize(cross(unit_vec, ref))\n                b3 = cross(unit_vec, b2)\n                basis = [unit_vec, b2, b3]\n                radii = [r1, r_other, r_other]\n\n            u = sample_unit_ball()\n            mapped = []\n            for d in range(dim):\n                val = center[d]\n                for i in range(dim):\n                    val += basis[i][d] * radii[i] * u[i]\n                # Clamp to bounds\n                val = max(0.0, min(bounds[d], val))\n                mapped.append(val)\n            return tuple(mapped)\n\n        def add_node_with_best_parent(tree, pos):\n            r = neighbor_radius(len(tree))\n            neighbors = near_nodes(tree, pos, r)\n            if not neighbors:\n                # Use nearest if no neighbor within radius\n                neighbors = [nearest(tree, pos)]\n            candidates = [p for p in neighbors if not is_edge_in_obstacle(p.position, pos)]\n            if not candidates:\n                return None, []\n            parent = min(candidates, key=lambda p: p.cost + dist(p.position, pos))\n            cost_new = parent.cost + dist(parent.position, pos)\n            if is_in_obstacle(pos):\n                return None, []\n            new_node = Node(pos)\n            new_node.parent = parent\n            new_node.cost = cost_new\n            parent.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((parent, new_node))\n            return new_node, neighbors\n\n        def rewire(node, neighbors):\n            for n in neighbors:\n                if n is node:\n                    continue\n                if is_edge_in_obstacle(node.position, n.position):\n                    continue\n                new_cost = node.cost + dist(node.position, n.position)\n                if new_cost + 1e-12 < n.cost:\n                    if n.parent:\n                        try:\n                            edges.remove((n.parent, n))\n                        except ValueError:\n                            pass\n                        if n in n.parent.children:\n                            n.parent.children.remove(n)\n                    node.add_child(n)\n                    n.cost = new_cost\n                    edges.append((node, n))\n\n        def connect_trees(new_node, other_tree):\n            nearest_to_new = nearest(other_tree, new_node.position)\n            d = dist(new_node.position, nearest_to_new.position)\n            if d > self.step_size * 2.5:\n                return None\n            if is_edge_in_obstacle(new_node.position, nearest_to_new.position):\n                return None\n            return nearest_to_new\n\n        def extract_combined_path(n_start, n_goal, start_side=True):\n            path_from_start = n_start.path_from_root()\n            path_from_goal = n_goal.path_from_root()\n            if path_from_start[-1] == path_from_goal[-1]:\n                combined = path_from_start + path_from_goal[-2::-1]\n            else:\n                combined = path_from_start + path_from_goal[::-1]\n            if start_side:\n                return combined\n            else:\n                return combined[::-1]\n\n        def path_cost(path):\n            if not path or len(path) < 2:\n                return 0.0\n            c = 0.0\n            for i in range(len(path)-1):\n                c += dist(path[i], path[i+1])\n            return c\n\n        # Shortcut smoothing: tries to shortcut path pairs if collision free\n        def shortcut_path(path, attempts=40):\n            if len(path) < 3:\n                return path[:]\n            import random as rand\n            path_smoothed = path[:]\n            for _ in range(attempts):\n                if len(path_smoothed) < 3:\n                    break\n                i = rand.randint(0, len(path_smoothed)-3)\n                j = rand.randint(i+2, len(path_smoothed)-1)\n                if j <= i+1:\n                    continue\n                if not is_edge_in_obstacle(path_smoothed[i], path_smoothed[j]):\n                    # Shortcut possible, remove intermediate nodes\n                    path_smoothed = path_smoothed[:i+1] + path_smoothed[j:]\n            return path_smoothed\n\n        # Main planning loop\n        for it in range(self.max_iter):\n            # Time limit check\n            if time.time() - start_time > self.time_limit_sec:\n                break\n\n            # Alternate growth\n            grow_tree = tree_a if it % 2 == 0 else tree_b\n            other_tree = tree_b if it % 2 == 0 else tree_a\n            start_side = (grow_tree == tree_a)\n\n            sample = sample_informed(best_cost)\n            nearest_node = nearest(grow_tree, sample)\n            new_pos = steer(nearest_node.position, sample)\n\n            if not within_bounds(new_pos):\n                # Count post optimization if solution found\n                if found_solution:\n                    post_opt_count += 1\n                    no_improve_count += 1\n                    if post_opt_count >= self.post_opt_iters or no_improve_count >= self.max_no_improve:\n                        break\n                continue\n\n            if is_in_obstacle(new_pos) or is_edge_in_obstacle(nearest_node.position, new_pos):\n                if found_solution:\n                    post_opt_count += 1\n                    no_improve_count += 1\n                    if post_opt_count >= self.post_opt_iters or no_improve_count >= self.max_no_improve:\n                        break\n                continue\n\n            new_node, neighbors = add_node_with_best_parent(grow_tree, new_pos)\n            if new_node is None:\n                if found_solution:\n                    post_opt_count += 1\n                    no_improve_count += 1\n                    if post_opt_count >= self.post_opt_iters or no_improve_count >= self.max_no_improve:\n                        break\n                continue\n\n            rewire(new_node, neighbors)\n\n            # Attempt connection to other tree\n            connect_node = connect_trees(new_node, other_tree)\n            if connect_node:\n                # Join trees\n                if connect_node.parent is None or new_node.parent is None:\n                    # Should not happen, skip if roots\n                    continue\n                # Combine paths\n                candidate_path = extract_combined_path(new_node, connect_node, start_side)\n                candidate_cost = path_cost(candidate_path)\n                # If improved path found\n                if candidate_cost + 1e-7 < best_cost:\n                    best_cost = candidate_cost\n                    # Smooth path before recording\n                    best_path = shortcut_path(candidate_path, attempts=50)\n                    found_solution = True\n                    no_improve_count = 0\n                    post_opt_count = 0\n                else:\n                    if found_solution:\n                        no_improve_count += 1\n                        post_opt_count += 1\n                        if post_opt_count >= self.post_opt_iters or no_improve_count >= self.max_no_improve:\n                            break\n            else:\n                if found_solution:\n                    no_improve_count += 1\n                    post_opt_count += 1\n                    if post_opt_count >= self.post_opt_iters or no_improve_count >= self.max_no_improve:\n                        break\n\n        return PlannerResult(\n            success=found_solution,\n            path=best_path if found_solution else [],\n            nodes=nodes,\n            edges=edges\n        )",
        "objective": 14.32975,
        "time_improvement": -103.0,
        "length_improvement": 19.0,
        "smoothness_improvement": 1026.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.11174523830413818,
                "num_nodes_avg": 170.3,
                "path_length_avg": 155.95946117163558,
                "smoothness_avg": 0.04431890634175788,
                "success_improvement": 0.0,
                "time_improvement": -325.65044958646763,
                "length_improvement": 14.516147996016231,
                "smoothness_improvement": 593.6871242940072,
                "objective_score": -86.0170104568605
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.08233952522277832,
                "num_nodes_avg": 319.1,
                "path_length_avg": 230.98919001369396,
                "smoothness_avg": 0.06524519533690301,
                "success_improvement": 0.0,
                "time_improvement": 50.13957315950754,
                "length_improvement": 22.889159718239107,
                "smoothness_improvement": 1578.8058702331955,
                "objective_score": 36.6693971299617
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.06728522777557373,
                "num_nodes_avg": 254.4,
                "path_length_avg": 120.52492557718756,
                "smoothness_avg": 0.0790609987636083,
                "success_improvement": 0.0,
                "time_improvement": -33.805833289081406,
                "length_improvement": 19.953083211850664,
                "smoothness_improvement": 905.6500685972023,
                "objective_score": 6.358350283371988
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "path_expert",
        "algorithm_description": "A bidirectional RRT* planner that employs adaptive neighbor radius and Gaussian-sampled informed sets after the first solution to accelerate convergence and improve path quality. It features incremental rewiring on both trees using a fast radius based on the current tree size, early connection checks with bidirectional extension, and final extensive shortcut smoothing that tries multiple segments with geometric sampling to ensure improved path length and smoothness. The result is a faster planner that finds shorter, smoother paths with higher success, leveraging progressive focused search.",
        "planning_mechanism": "The planner grows start and goal RRT* trees alternately, using an adaptive neighbor radius that dynamically shrinks with increasing samples to balance exploration and refinement. It samples mostly uniform points until the first path is found, then switches to Gaussian-informed ellipsoidal sampling focusing around the best path cost to prune the search space. In each step, it attempts to connect the trees quickly by incremental extension and rewires both the newly added node and its neighbors to reduce cost. The combination of careful incremental rewiring, adaptive radius, and focused sampling efficiently drives the trees to meet with high-quality edges. After completion, a geometric shortcut smoothing aggressively reduces the path length and smoothes the trajectory by replacing longer segments with direct collisions-checked edges.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        path.reverse()\n        return path\nclass Planner:\n    def __init__(self,\n                 max_iter=7000,\n                 step_size=3.5,\n                 max_no_improve=120,\n                 improve_tol=1e-6,\n                 time_limit_sec=18.0,\n                 shortcutting_trials=300):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.max_no_improve = max_no_improve\n        self.improve_tol = improve_tol\n        self.time_limit_sec = time_limit_sec\n        self.shortcutting_trials = shortcutting_trials\n        self.gamma_rrt_star = 30.0\n        self.min_neighbor_radius = 1.0\n\n    def plan(self, map):\n        bounds = map.size\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        obstacles = map.obstacles\n        start_pos = map.start\n        goal_pos = map.goal\n        \n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        best_cost = float('inf')\n        best_path = []\n        c_min = math.dist(start_pos, goal_pos)\n        found_solution = False\n        no_improve_count = 0\n\n        start_time = time.time()\n        iteration = 0\n\n        # Helper functions:\n        def within_bounds(p):\n            return all(0.0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_p, to_p):\n            d = dist(from_p, to_p)\n            if d <= self.step_size:\n                return to_p\n            r = self.step_size / d\n            return tuple(from_p[i] + (to_p[i] - from_p[i]) * r for i in range(dim))\n\n        def neighbor_radius(n_nodes):\n            if n_nodes < 2:\n                return self.step_size * 2.5\n            theoretical = self.gamma_rrt_star * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            max_r = max(bounds) * 0.25\n            return max(self.min_neighbor_radius, min(theoretical, max_r))\n\n        def nearest(tree, pt):\n            best_node = None\n            best_d = float('inf')\n            for node in tree:\n                d = dist(node.position, pt)\n                if d < best_d:\n                    best_d = d\n                    best_node = node\n            return best_node\n\n        def near_nodes(tree, pos, radius):\n            radius_sq = radius * radius\n            return [n for n in tree if sum((n.position[i] - pos[i]) ** 2 for i in range(dim)) <= radius_sq]\n\n        def collision_node_free(p):\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d = obs\n                    px,py,pz = p\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                        return False\n                else:\n                    x,y,w,h = obs\n                    px,py = p\n                    if x <= px <= x+w and y <= py <= y+h:\n                        return False\n            return True\n\n        def collision_edge_free(p1, p2):\n            d = dist(p1,p2)\n            steps = max(3, int(d / 0.35))\n            for i in range(steps+1):\n                t = i / steps\n                ip = tuple(p1[j] + (p2[j]-p1[j])*t for j in range(dim))\n                if not collision_node_free(ip):\n                    return False\n            return True\n\n        def add_node(tree, pos):\n            r = neighbor_radius(len(tree))\n            neighbors = near_nodes(tree, pos, r)\n            candidates = [n for n in neighbors if collision_edge_free(n.position, pos)]\n            if not candidates:\n                nearest_node = nearest(tree, pos)\n                if collision_edge_free(nearest_node.position, pos):\n                    parent = nearest_node\n                else:\n                    return None, []\n            else:\n                parent = min(candidates, key=lambda n: n.cost + dist(n.position, pos))\n            new_cost = parent.cost + dist(parent.position, pos)\n            new_node = Node(pos, parent=None, cost=new_cost)\n            parent.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((parent, new_node))\n            return new_node, neighbors\n\n        def rewire(node, neighbors):\n            for nb in neighbors:\n                if nb is node:\n                    continue\n                if not collision_edge_free(node.position, nb.position):\n                    continue\n                new_cost = node.cost + dist(node.position, nb.position)\n                if new_cost + 1e-15 < nb.cost:\n                    old_parent = nb.parent\n                    if old_parent:\n                        if (old_parent, nb) in edges:\n                            edges.remove((old_parent, nb))\n                        if nb in old_parent.children:\n                            old_parent.children.remove(nb)\n                    node.add_child(nb)\n                    nb.cost = new_cost\n                    edges.append((node, nb))\n                    # propagate cost update down subtree\n                    def propagate_cost_update(n):\n                        for c in n.children:\n                            old_cost = c.cost\n                            c.cost = n.cost + dist(n.position, c.position)\n                            if c.cost + 1e-15 < old_cost:\n                                propagate_cost_update(c)\n                    propagate_cost_update(nb)\n\n        def path_cost(path):\n            c = 0.0\n            for i in range(len(path)-1):\n                c += dist(path[i], path[i+1])\n            return c\n\n        def stitch_paths(n_start, n_goal):\n            path_s = n_start.path_from_root()\n            path_g = n_goal.path_from_root()\n            if path_s[-1] == path_g[-1]:\n                return path_s + path_g[-2::-1]\n            else:\n                return path_s + path_g[::-1]\n\n        def informed_sample(start, goal, c_best, c_min):\n            # If no solution, uniform sample\n            if c_best == float('inf') or c_min < 1e-12:\n                return tuple(random.uniform(0.0, bounds[d]) for d in range(dim))\n            \n            # Ellipsoidal informed sampling\n            center = tuple((start[d]+goal[d])/2.0 for d in range(dim))\n            a1 = [(goal[d] - start[d]) / c_min for d in range(dim)]\n            r1 = c_best / 2.0\n            r2 = math.sqrt(max(c_best*c_best - c_min*c_min, 0.0)) / 2.0\n            \n            def sample_unit_ball(k):\n                while True:\n                    v = [random.gauss(0,1) for _ in range(k)]\n                    norm = math.sqrt(sum(x*x for x in v))\n                    if norm > 1e-12:\n                        v = [x/norm for x in v]\n                        rad = random.random() ** (1.0/k)\n                        return tuple(v[i]*rad for i in range(k))\n            \n            u = sample_unit_ball(dim)\n            coords = [0.0]*dim\n            \n            if dim == 2:\n                ortho = (-a1[1], a1[0])\n                basis = (a1, ortho)\n                radii = (r1, r2)\n            else:\n                ref = (1.0, 0.0, 0.0) if abs(a1[0]) < 0.9 else (0.0, 1.0, 0.0)\n                b2 = self._normalize(self._cross(a1, ref))\n                if self._norm(b2) < 1e-12:\n                    ref = (0.0, 0.0, 1.0)\n                    b2 = self._normalize(self._cross(a1, ref))\n                b3 = self._cross(a1, b2)\n                basis = (a1, b2, b3)\n                radii = (r1, r2, r2)\n            \n            for d in range(dim):\n                val = center[d]\n                for i in range(dim):\n                    val += basis[i][d]*radii[i]*u[i]\n                # clamp to bounds\n                val = max(0.0, min(bounds[d], val))\n                coords[d] = val\n            return tuple(coords)\n\n        def try_connect_trees(node_new, other_tree):\n            # Try direct connection first if close enough\n            neigh_o = nearest(other_tree, node_new.position)\n            if dist(node_new.position, neigh_o.position) <= self.step_size:\n                if collision_edge_free(node_new.position, neigh_o.position):\n                    return node_new, neigh_o\n            \n            # Incremental extend toward new node in other tree:\n            current = neigh_o\n            for _ in range(15):\n                step_pos = steer(current.position, node_new.position)\n                if not within_bounds(step_pos) or not collision_node_free(step_pos):\n                    break\n                if not collision_edge_free(current.position, step_pos):\n                    break\n                new_node, neighbors = add_node(other_tree, step_pos)\n                if new_node is None:\n                    break\n                rewire(new_node, neighbors)\n                current = new_node\n                if dist(current.position, node_new.position) <= self.step_size:\n                    if collision_edge_free(current.position, node_new.position):\n                        return node_new, current\n            return None, None\n\n        def shortcut_path(path, trials):\n            if len(path) < 3:\n                return path[:]\n            path_out = path[:]\n            for _ in range(trials):\n                n = len(path_out)\n                if n < 3:\n                    break\n                i = random.randint(0, n-3)\n                j = random.randint(i+2, n-1)\n                if collision_edge_free(path_out[i], path_out[j]):\n                    # Remove intermediate nodes between i and j\n                    path_out = path_out[:i+1] + path_out[j:]\n            return path_out\n\n        while iteration < self.max_iter:\n            if (time.time() - start_time) > self.time_limit_sec:\n                break\n            grow_start_side = (iteration % 2 == 0)\n            tree_grow = start_tree if grow_start_side else goal_tree\n            tree_other = goal_tree if grow_start_side else start_tree\n\n            sample = informed_sample(start_pos, goal_pos, best_cost, c_min) if found_solution else \\\n                     tuple(random.uniform(0.0, bounds[d]) for d in range(dim))\n            if not within_bounds(sample) or not collision_node_free(sample):\n                iteration += 1\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n                continue\n\n            nearest_node = nearest(tree_grow, sample)\n            new_pos = steer(nearest_node.position, sample)\n            if not within_bounds(new_pos) or not collision_node_free(new_pos):\n                iteration += 1\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n                continue\n            if not collision_edge_free(nearest_node.position, new_pos):\n                iteration += 1\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n                continue\n\n            new_node, neighbors = add_node(tree_grow, new_pos)\n            if new_node is None:\n                iteration += 1\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n                continue\n\n            rewire(new_node, neighbors)\n\n            n1, n2 = try_connect_trees(new_node, tree_other)\n            if n1 and n2:\n                path_merged = stitch_paths(n1, n2)\n                cost_candidate = path_cost(path_merged)\n                improved = cost_candidate + self.improve_tol < best_cost\n                if improved:\n                    best_cost = cost_candidate\n                    best_path = path_merged\n                    found_solution = True\n                    no_improve_count = 0\n                else:\n                    if found_solution:\n                        no_improve_count += 1\n                        if no_improve_count >= self.max_no_improve:\n                            break\n            else:\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n\n            iteration += 1\n\n        if found_solution and best_path:\n            smoothed_path = shortcut_path(best_path, self.shortcutting_trials)\n        else:\n            smoothed_path = []\n\n        return PlannerResult(\n            success=found_solution,\n            path=smoothed_path if smoothed_path else best_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _cross(self, a, b):\n        ax, ay, az = a\n        bx, by, bz = b\n        return (ay * bz - az * by, az * bx - ax * bz, ax * by - ay * bx)\n\n    def _norm(self, v):\n        return math.sqrt(sum(x * x for x in v))\n\n    def _normalize(self, v):\n        n = self._norm(v)\n        if n < 1e-12:\n            return v\n        return tuple(x / n for x in v)",
        "objective": 47.81786,
        "time_improvement": -223.0,
        "length_improvement": 20.0,
        "smoothness_improvement": 1472.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.12483923435211182,
                "num_nodes_avg": 200.3,
                "path_length_avg": 149.63110148123698,
                "smoothness_avg": 0.041354700981841616,
                "success_improvement": 0.0,
                "time_improvement": -375.5269847237775,
                "length_improvement": 17.984822221600165,
                "smoothness_improvement": 547.2908735363528,
                "objective_score": -99.1307477164914
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.12627105712890624,
                "num_nodes_avg": 468.3,
                "path_length_avg": 238.96056393164912,
                "smoothness_avg": 0.09874213029288868,
                "success_improvement": 0.0,
                "time_improvement": 23.536979488123475,
                "length_improvement": 20.228085661149276,
                "smoothness_improvement": 2440.70613351774,
                "objective_score": 31.401475910715305
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.21035337448120117,
                "num_nodes_avg": 430.1,
                "path_length_avg": 118.8616705810872,
                "smoothness_avg": 0.12006292386762385,
                "success_improvement": 0.0,
                "time_improvement": -318.3163153063624,
                "length_improvement": 21.057737984568643,
                "smoothness_improvement": 1427.1915294729838,
                "objective_score": -75.72429415380262
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "m3",
        "algorithm_description": "A simplified bidirectional RRT* planner that alternately grows two trees from start and goal using fixed step-size steering, nearest neighbor connection, and local rewiring with a fixed radius. The algorithm attempts to connect the two trees when nodes are nearby and extracts the combined path. After finding a path, a simple shortcutting step reduces unnecessary waypoints to improve smoothness and path length. This streamlined version reduces overhead while preserving feasible, short, and smooth paths.",
        "planning_mechanism": "A bidirectional RRT* variant that grows two trees alternately by sampling points, steering from nearest nodes, rewiring neighbors within a fixed radius to improve costs, and attempts to connect the trees when close. Upon connection, it extracts and shortcuts the path for quality.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\nclass Planner:\n    def __init__(self, max_iter=2000, step_size=5.0, radius=15.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.radius = radius\n\n    def plan(self, map):\n        bounds = map.size\n        start = Node(map.start)\n        goal = Node(map.goal)\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = dim == 3\n\n        tree_start = [start]\n        tree_goal = [goal]\n\n        def dist(a, b):\n            return sum((a[i]-b[i])**2 for i in range(dim))**0.5\n\n        def in_obstacle(p):\n            if not obstacles:\n                return False\n            if is_3d:\n                x,y,z = p\n                for ox, oy, oz, w, h, d in obstacles:\n                    if ox <= x <= ox+w and oy <= y <= oy+h and oz <= z <= oz+d:\n                        return True\n            else:\n                x,y = p\n                for ox, oy, w, h in obstacles:\n                    if ox <= x <= ox+w and oy <= y <= oy+h:\n                        return True\n            return False\n\n        def collision_free(frm, to):\n            d = dist(frm, to)\n            steps = max(1, int(d))\n            for i in range(steps + 1):\n                interp = tuple(frm[j] + (to[j]-frm[j]) * i/steps for j in range(dim))\n                if in_obstacle(interp):\n                    return False\n            return True\n\n        import random\n\n        def sample_free():\n            while True:\n                p = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not in_obstacle(p):\n                    return p\n\n        def steer(frm, to):\n            d = dist(frm, to)\n            if d <= self.step_size:\n                return to\n            ratio = self.step_size / d\n            return tuple(frm[i] + (to[i]-frm[i]) * ratio for i in range(dim))\n\n        def nearest(tree, point):\n            best = tree[0]\n            best_d = dist(best.position, point)\n            for node in tree:\n                d = dist(node.position, point)\n                if d < best_d:\n                    best, best_d = node, d\n            return best\n\n        def near_nodes(tree, point):\n            return [node for node in tree if dist(node.position, point) <= self.radius]\n\n        def add_node(tree, pos):\n            near = near_nodes(tree, pos)\n            min_cost, min_parent = None, None\n            for node in near:\n                if collision_free(node.position, pos):\n                    c = node.cost + dist(node.position, pos)\n                    if min_cost is None or c < min_cost:\n                        min_cost, min_parent = c, node\n            if min_parent is None:\n                min_parent = nearest(tree, pos)\n                if not collision_free(min_parent.position, pos):\n                    return None\n                min_cost = min_parent.cost + dist(min_parent.position, pos)\n            new_node = Node(pos, parent=min_parent, cost=min_cost)\n            min_parent.add_child(new_node)\n            tree.append(new_node)\n            rewire(new_node, tree)\n            return new_node\n\n        def rewire(new_node, tree):\n            for node in near_nodes(tree, new_node.position):\n                if node is new_node.parent:\n                    continue\n                if collision_free(new_node.position, node.position):\n                    c = new_node.cost + dist(new_node.position, node.position)\n                    if c + 1e-9 < node.cost:\n                        if node.parent:\n                            try:\n                                node.parent.children.remove(node)\n                            except ValueError:\n                                pass\n                        node.parent = new_node\n                        node.cost = c\n                        new_node.children.append(node)\n\n        def extract_path(node):\n            path = []\n            while node:\n                path.append(node.position)\n                node = node.parent\n            return path[::-1]\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            shortened = [path[0]]\n            i = 0\n            while i < len(path) - 1:\n                j = len(path) - 1\n                while j > i + 1:\n                    if collision_free(path[i], path[j]):\n                        break\n                    j -= 1\n                shortened.append(path[j])\n                i = j\n            return shortened\n\n        success = False\n        best_path = []\n        best_cost = float('inf')\n\n        for i in range(self.max_iter):\n            rand_pos = sample_free()\n            tree_a, tree_b = (tree_start, tree_goal) if i % 2 == 0 else (tree_goal, tree_start)\n            nearest_node = nearest(tree_a, rand_pos)\n            new_pos = steer(nearest_node.position, rand_pos)\n            if in_obstacle(new_pos):\n                continue\n            new_node = add_node(tree_a, new_pos)\n            if new_node is None:\n                continue\n            nearest_to_new = nearest(tree_b, new_node.position)\n            if dist(new_node.position, nearest_to_new.position) <= self.step_size:\n                if collision_free(new_node.position, nearest_to_new.position):\n                    connector = Node(nearest_to_new.position, parent=new_node,\n                                     cost=new_node.cost + dist(new_node.position, nearest_to_new.position))\n                    new_node.add_child(connector)\n                    tree_a.append(connector)\n                    path_start = extract_path(connector if tree_a is tree_start else nearest_to_new)\n                    path_goal = extract_path(nearest_to_new if tree_a is tree_start else connector)\n                    combined = path_start + path_goal[::-1][1:]\n                    shortcut = shortcut_path(combined)\n                    cost = sum(dist(shortcut[i], shortcut[i+1]) for i in range(len(shortcut)-1))\n                    if cost < best_cost:\n                        best_cost = cost\n                        best_path = shortcut\n                        success = True\n                    break\n\n        return PlannerResult(success, best_path, tree_start + tree_goal, [])",
        "objective": -14.56634,
        "time_improvement": -11.0,
        "length_improvement": 19.0,
        "smoothness_improvement": 1357.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.035758161544799806,
                "num_nodes_avg": 95.1,
                "path_length_avg": 158.08045278022354,
                "smoothness_avg": 0.0437108561114864,
                "success_improvement": 0.0,
                "time_improvement": -36.20694509151112,
                "length_improvement": 13.353598886086381,
                "smoothness_improvement": 584.1698177880498,
                "objective_score": 0.0709248931387414
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.14818284511566163,
                "num_nodes_avg": 270.9,
                "path_length_avg": 229.20584772072934,
                "smoothness_avg": 0.08798497858952058,
                "success_improvement": 0.0,
                "time_improvement": 10.268368831187576,
                "length_improvement": 23.484490706292497,
                "smoothness_improvement": 2163.9168721268857,
                "objective_score": 27.990789433766196
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.053970956802368165,
                "num_nodes_avg": 154.9,
                "path_length_avg": 122.40981172898974,
                "smoothness_avg": 0.1118739121743925,
                "success_improvement": 0.0,
                "time_improvement": -7.328593319729027,
                "length_improvement": 18.70123157845707,
                "smoothness_improvement": 1323.0279051850484,
                "objective_score": 15.637300477080775
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "cross_over",
        "algorithm_description": "An improved bidirectional RRT* planner integrates adaptive informed sampling with adaptive neighborhood rewiring and incremental cost propagation. It dynamically balances exploration and exploitation, uses an efficient radius scaling with tighter bounds to minimize unnecessary neighbors, performs incremental rewiring with recursive cost updates to avoid local suboptimality, and employs lazy collision checks and early exits to reduce planning time. The algorithm refines paths online, connects trees with smarter distance thresholds, and uses aggressive shortcut smoothing on the final path to maximize smoothness and minimize length within a strict iteration and time limit.",
        "planning_mechanism": "The planner alternates tree growth with samples biased by an adaptive informed ellipsoid based on the best solution cost. For each new node, it selects the minimum-cost parent among neighbors within a carefully bounded radius, inserts the node if collision free, and rewires neighbors with recursive cost updates to promote global path improvement. The trees attempt connection via nearest nodes when close, and if successful, the combined path undergoes shortcut smoothing to produce a short, smooth output. Adaptive radius and step size ensure efficient, focused growth. The use of early collision checks and incremental cost propagation reduces overhead and improves solution quality iteratively.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n\n    def path_from_root(self):\n        path = []\n        n = self\n        while n:\n            path.append(n.position)\n            n = n.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=4000, step_size=4.5, gamma=40.0,\n                 time_limit_sec=15.0, post_opt_iters=200, max_no_improve=80):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.gamma = gamma\n        self.time_limit_sec = time_limit_sec\n        self.post_opt_iters = post_opt_iters\n        self.max_no_improve = max_no_improve\n\n    def plan(self, map):\n        import math\n        import random\n        import time\n\n        bounds = map.size\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def within_bounds(p):\n            return all(0.0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def in_obstacle(p):\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d = obs\n                    px,py,pz = p\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                        return True\n                else:\n                    x,y,w,h = obs\n                    px,py = p\n                    if x <= px <= x+w and y <= py <= y+h:\n                        return True\n            return False\n\n        def edge_collision(a,b,resolution=1.0):\n            length = dist(a,b)\n            steps = max(2, int(length / resolution))\n            for i in range(steps+1):\n                pt = tuple(a[d]+(b[d]-a[d])*i/steps for d in range(dim))\n                if in_obstacle(pt):\n                    return True\n            return False\n\n        def steer(from_p, to_p):\n            d = dist(from_p,to_p)\n            if d <= self.step_size:\n                return to_p\n            r = self.step_size / d\n            return tuple(from_p[i] + (to_p[i]-from_p[i])*r for i in range(dim))\n\n        def neighbor_radius(n_nodes, c_best=float('inf')):\n            if n_nodes < 2:\n                return self.step_size * 2.0\n            base = self.gamma * ((math.log(n_nodes)/n_nodes)**(1.0/dim))\n            max_r = max(bounds)*0.3\n            min_r = max(self.step_size*1.8,10.0)\n            r = max(min_r, min(max_r, base))\n            if c_best < float('inf'):\n                # Reduce radius proportional to cost improvement for focused rewiring\n                r = min(r, max(self.step_size*2.2, c_best*0.15))\n            return r\n\n        def nearest(tree, p):\n            return min(tree, key=lambda n: dist(n.position,p))\n\n        def near_nodes(tree, p, radius):\n            return [n for n in tree if dist(n.position,p) <= radius]\n\n        def sample_uniform():\n            for _ in range(100):\n                p = tuple(random.uniform(0,bounds[d]) for d in range(dim))\n                if not in_obstacle(p):\n                    return p\n            return start_pos  # fallback\n\n        def sample_unit_ball():\n            while True:\n                v = [random.gauss(0,1) for _ in range(dim)]\n                normv = math.sqrt(sum(x*x for x in v))\n                if normv > 1e-12:\n                    v = [x/normv for x in v]\n                    r = random.random() ** (1.0/dim)\n                    return tuple(v[i]*r for i in range(dim))\n\n        def sample_informed(c_best):\n            if c_best == float(\"inf\"):\n                return sample_uniform()\n            c_min = dist(start_pos, goal_pos)\n            if c_min < 1e-12:\n                return sample_uniform()\n            r1 = c_best/2.0\n            r_other_sq = max(c_best*c_best - c_min*c_min, 0.0)\n            r_other = math.sqrt(r_other_sq)/2.0\n            center = tuple((start_pos[d]+goal_pos[d])/2.0 for d in range(dim))\n            unit_vec = tuple((goal_pos[d]-start_pos[d])/c_min for d in range(dim))\n\n            if dim==2:\n                perp_vec = (-unit_vec[1], unit_vec[0])\n                basis = [unit_vec, perp_vec]\n                radii = [r1, r_other]\n            else:\n                def cross(u,v):\n                    return (u[1]*v[2]-u[2]*v[1], u[2]*v[0]-u[0]*v[2], u[0]*v[1]-u[1]*v[0])\n                def norm_vec(vv):\n                    return math.sqrt(sum(x*x for x in vv))\n                def normalize(vv):\n                    n = norm_vec(vv)\n                    if n < 1e-12:\n                        return vv\n                    return tuple(x/n for x in vv)\n                ref = (1.0,0.0,0.0) if abs(unit_vec[0]) < 0.9 else (0.0,1.0,0.0)\n                b2 = normalize(cross(unit_vec, ref))\n                if norm_vec(b2) < 1e-12:\n                    ref = (0.0,0.0,1.0)\n                    b2 = normalize(cross(unit_vec, ref))\n                b3 = cross(unit_vec, b2)\n                basis = [unit_vec, b2, b3]\n                radii = [r1, r_other, r_other]\n\n            u = sample_unit_ball()\n            mapped = []\n            for d in range(dim):\n                val = center[d]\n                for i in range(dim):\n                    val += basis[i][d]*radii[i]*u[i]\n                val = max(0.0, min(bounds[d], val))\n                mapped.append(val)\n            return tuple(mapped)\n\n        def can_connect(p1, p2):\n            if in_obstacle(p2):\n                return False\n            if edge_collision(p1, p2):\n                return False\n            return True\n\n        def add_node_with_parent(tree, pos, best_parent):\n            cost_new = best_parent.cost + dist(best_parent.position, pos)\n            new_node = Node(pos, parent=best_parent, cost=cost_new)\n            best_parent.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n            return new_node\n\n        def update_cost_recursive(node, cost_delta):\n            node.cost += cost_delta\n            for c in node.children:\n                update_cost_recursive(c, cost_delta)\n\n        def rewire(node, neighbors):\n            n_changed = 0\n            for nb in neighbors:\n                if nb is node:\n                    continue\n                d_new = dist(node.position, nb.position)\n                cost_candidate = node.cost + d_new\n                if cost_candidate + 1e-12 < nb.cost:\n                    if can_connect(node.position, nb.position):\n                        # Rewire nb parent\n                        if nb.parent:\n                            try:\n                                edges.remove((nb.parent, nb))\n                            except:\n                                pass\n                            nb.parent.remove_child(nb)\n                        node.add_child(nb)\n                        cost_diff = cost_candidate - nb.cost\n                        update_cost_recursive(nb, cost_diff)\n                        edges.append((node, nb))\n                        n_changed += 1\n            return n_changed\n\n        def add_node(tree, pos, c_best=float('inf')):\n            r = neighbor_radius(len(tree), c_best)\n            near = near_nodes(tree, pos, r)\n            if not near:\n                # fallback nearest\n                near = [nearest(tree, pos)]\n            candidates = [p for p in near if can_connect(p.position, pos)]\n            if not candidates:\n                return None, []\n            best_parent = min(candidates, key=lambda p: p.cost+dist(p.position,pos))\n            if in_obstacle(pos):\n                return None, []\n            return add_node_with_parent(tree, pos, best_parent), near\n\n        def connect_trees(n1, tree_other):\n            # Connect if within threshold, use smaller threshold than step_size*3\n            threshold = self.step_size*2.2\n            near_other = nearest(tree_other, n1.position)\n            d = dist(n1.position, near_other.position)\n            if d > threshold:\n                return None\n            if can_connect(n1.position, near_other.position):\n                return near_other\n            return None\n\n        def extract_path(n_start, n_goal, start_side=True):\n            path_s = n_start.path_from_root()\n            path_g = n_goal.path_from_root()\n            if path_s[-1] == path_g[-1]:\n                combined = path_s + path_g[-2::-1]\n            else:\n                combined = path_s + path_g[::-1]\n            return combined if start_side else combined[::-1]\n\n        def path_cost(path):\n            if len(path) < 2:\n                return 0.0\n            return sum(dist(path[i], path[i+1]) for i in range(len(path)-1))\n\n        def shortcut_path(path, attempts=60):\n            if len(path) < 3:\n                return path[:]\n            for _ in range(attempts):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path)-3)\n                j = random.randint(i+2, len(path)-1)\n                if j <= i+1:\n                    continue\n                if not edge_collision(path[i], path[j]):\n                    # Remove intermediate nodes between i+1 and j-1\n                    path = path[:i+1]+path[j:]\n            return path\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        tree_a = [start_root]\n        tree_b = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        best_cost = float('inf')\n        best_path = []\n        found = False\n        no_improve_cnt = 0\n        post_opt_cnt = 0\n        t_start = time.time()\n\n        for it in range(self.max_iter):\n            if time.time() - t_start > self.time_limit_sec:\n                break\n\n            grow_tree = tree_a if (it % 2 == 0) else tree_b\n            other_tree = tree_b if (it % 2 == 0) else tree_a\n            start_side = (grow_tree is tree_a)\n\n            sample = sample_informed(best_cost)\n            nearest_node = nearest(grow_tree, sample)\n            new_pos = steer(nearest_node.position, sample)\n\n            if not within_bounds(new_pos):\n                if found:\n                    post_opt_cnt += 1\n                    no_improve_cnt += 1\n                    if post_opt_cnt >= self.post_opt_iters or no_improve_cnt >= self.max_no_improve:\n                        break\n                continue\n\n            if in_obstacle(new_pos) or edge_collision(nearest_node.position, new_pos):\n                if found:\n                    post_opt_cnt += 1\n                    no_improve_cnt += 1\n                    if post_opt_cnt >= self.post_opt_iters or no_improve_cnt >= self.max_no_improve:\n                        break\n                continue\n\n            new_node, neighbors = add_node(grow_tree, new_pos, best_cost)\n            if new_node is None:\n                if found:\n                    post_opt_cnt += 1\n                    no_improve_cnt += 1\n                    if post_opt_cnt >= self.post_opt_iters or no_improve_cnt >= self.max_no_improve:\n                        break\n                continue\n\n            rewire(new_node, neighbors)\n\n            connect_node = connect_trees(new_node, other_tree)\n            if connect_node:\n                path_candidate = extract_path(new_node, connect_node, start_side)\n                cost_candidate = path_cost(path_candidate)\n                if cost_candidate + 1e-8 < best_cost:\n                    best_cost = cost_candidate\n                    best_path = shortcut_path(path_candidate, attempts=75)\n                    found = True\n                    no_improve_cnt = 0\n                    post_opt_cnt = 0\n                else:\n                    if found:\n                        no_improve_cnt += 1\n                        post_opt_cnt += 1\n                        if post_opt_cnt >= self.post_opt_iters or no_improve_cnt >= self.max_no_improve:\n                            break\n            else:\n                if found:\n                    no_improve_cnt += 1\n                    post_opt_cnt += 1\n                    if post_opt_cnt >= self.post_opt_iters or no_improve_cnt >= self.max_no_improve:\n                        break\n\n        return PlannerResult(success=found, path=best_path if found else [], nodes=nodes, edges=edges)",
        "objective": -17.38255,
        "time_improvement": -2.0,
        "length_improvement": 19.0,
        "smoothness_improvement": 1343.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.04732570648193359,
                "num_nodes_avg": 174.8,
                "path_length_avg": 159.6689680797073,
                "smoothness_avg": 0.04623537543316629,
                "success_improvement": 0.0,
                "time_improvement": -80.26905259448762,
                "length_improvement": 12.482908478803605,
                "smoothness_improvement": 623.6840272537908,
                "objective_score": -13.472550554795168
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.046145963668823245,
                "num_nodes_avg": 335.6,
                "path_length_avg": 230.89521003339866,
                "smoothness_avg": 0.08556149235424479,
                "success_improvement": 0.0,
                "time_improvement": 72.05646450755975,
                "length_improvement": 22.920532940725426,
                "smoothness_improvement": 2101.558825726661,
                "objective_score": 45.877053245336484
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.0485954999923706,
                "num_nodes_avg": 316.1,
                "path_length_avg": 119.9179424359091,
                "smoothness_avg": 0.11039449985677638,
                "success_improvement": 0.0,
                "time_improvement": 3.3612341736142275,
                "length_improvement": 20.356212512856622,
                "smoothness_improvement": 1304.2098897038297,
                "objective_score": 19.74314720831739
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "cross_over",
        "algorithm_description": "A bidirectional RRT* planner with adaptive informed sampling focused on minimizing path length and reducing planning time. It grows two trees from start and goal, uses dynamic neighbor radius for rewiring, applies efficient collision checking, and leverages adaptive informed sampling after each solution to concentrate search within an ellipsoid containing potentially better paths. It performs incremental shortcut smoothing continuously as improved paths are found, ensuring smoother final solutions. This integrated approach improves efficiency, path quality, robustness, and success rate.",
        "planning_mechanism": "The planner alternates growing start and goal trees with RRT*-based extension including best-parent selection and rewiring to minimize path costs. Upon finding a path, it adaptively samples inside a progressively shrinking ellipsoid defined by the best and minimum path lengths to focus search, enabling rapid convergence to shorter paths. Shortcut smoothing is integrated regularly during planning to enhance smoothness without delaying search. Strict collision checks maintain robustness, and the use of a dynamic neighbor radius balances exploration and optimization effectively.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self,\n                 max_iter=5000,\n                 step_size=4.0,\n                 gamma_rrt_star=30.0,\n                 max_radius=None,\n                 time_limit_sec=20.0,\n                 post_opt_iters=300,\n                 max_no_improve=100,\n                 improve_tol=1e-6,\n                 shortcutting_trials=75,\n                 goal_sample_rate=0.1):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.gamma_rrt_star = gamma_rrt_star\n        self.max_radius = max_radius\n        self.time_limit_sec = time_limit_sec\n        self.post_opt_iters = post_opt_iters\n        self.max_no_improve = max_no_improve\n        self.improve_tol = improve_tol\n        self.shortcutting_trials = shortcutting_trials\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map):\n        bounds = map.size\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        obstacles = map.obstacles\n\n        start_pos = map.start\n        goal_pos = map.goal\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        best_cost = float(\"inf\")\n        best_path = []\n        c_min = math.dist(start_pos, goal_pos)\n        found_solution = False\n\n        no_improve_count = 0\n        post_iter = 0\n\n        start_time = time.time()\n\n        def within_bounds(p):\n            return all(0.0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_p, to_p):\n            d = dist(from_p, to_p)\n            if d <= self.step_size:\n                return to_p\n            r = self.step_size / d\n            return tuple(from_p[i] + (to_p[i] - from_p[i]) * r for i in range(dim))\n\n        def neighbor_radius_fn(n_nodes):\n            if self.max_radius is not None:\n                maxr = self.max_radius\n            else:\n                maxr = max(bounds) * 0.25\n            if n_nodes < 2:\n                return min(self.step_size * 3.0, maxr)\n            r = self.gamma_rrt_star * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            return max(self.step_size * 2.0, min(r, maxr))\n\n        def nearest(tree, pt):\n            mn = None\n            md = float(\"inf\")\n            for n in tree:\n                d = dist(n.position, pt)\n                if d < md:\n                    md = d\n                    mn = n\n            return mn\n\n        def near_nodes(tree, pos, radius):\n            r_sq = radius * radius\n            return [n for n in tree if sum((n.position[i] - pos[i]) ** 2 for i in range(dim)) <= r_sq]\n\n        def collision_free(p):\n            return not self._is_in_obstacle(p, obstacles, is_3d)\n\n        def edge_collision_free(p1, p2):\n            distance = dist(p1, p2)\n            steps = max(3, int(distance / 1.0))\n            for i in range(steps + 1):\n                ip = tuple(p1[d] + (p2[d] - p1[d]) * (i / steps) for d in range(dim))\n                if self._is_in_obstacle(ip, obstacles, is_3d):\n                    return False\n            return True\n\n        def add_node_rrtstar(tree, pos):\n            r = neighbor_radius_fn(len(tree))\n            neigh = near_nodes(tree, pos, r)\n\n            candidate_parents = [n for n in neigh if edge_collision_free(n.position, pos)]\n            if not candidate_parents:\n                nearest_node = nearest(tree, pos)\n                if edge_collision_free(nearest_node.position, pos):\n                    parent = nearest_node\n                else:\n                    return None, []\n            else:\n                parent = min(candidate_parents, key=lambda n: n.cost + dist(n.position, pos))\n            new_cost = parent.cost + dist(parent.position, pos)\n            new_node = Node(pos, parent=None, cost=new_cost)\n            parent.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((parent, new_node))\n            return new_node, neigh\n\n        def rewire(node, neighbors):\n            for nb in neighbors:\n                if nb is node:\n                    continue\n                if not edge_collision_free(node.position, nb.position):\n                    continue\n                new_cost = node.cost + dist(node.position, nb.position)\n                if new_cost + 1e-15 < nb.cost:\n                    # rewire neighbor's parent\n                    if nb.parent:\n                        try:\n                            edges.remove((nb.parent, nb))\n                        except ValueError:\n                            pass\n                        if nb in nb.parent.children:\n                            nb.parent.children.remove(nb)\n                    node.add_child(nb)\n                    nb.cost = new_cost\n                    edges.append((node, nb))\n\n        def stitch_paths(node_start, node_goal):\n            path_start = node_start.path_from_root()\n            path_goal = node_goal.path_from_root()\n            if path_start and path_goal and path_start[-1] == path_goal[-1]:\n                merged = path_start + path_goal[-2::-1]\n            else:\n                merged = path_start + path_goal[::-1]\n            return merged\n\n        def path_cost(path):\n            c = 0.0\n            for i in range(len(path) - 1):\n                c += dist(path[i], path[i+1])\n            return c\n\n        def informed_sample(start, goal, c_best, c_min):\n            if c_best == float(\"inf\") or c_min < 1e-12:\n                # Uniform random\n                while True:\n                    sample = tuple(random.uniform(0.0, bounds[d]) for d in range(dim))\n                    if collision_free(sample):\n                        return sample\n            r1 = c_best / 2.0\n            r_other_sq = max(c_best * c_best - c_min * c_min, 0.0)\n            r_other = math.sqrt(r_other_sq) / 2.0\n            center = tuple((start[d] + goal[d]) / 2.0 for d in range(dim))\n            a1 = tuple((goal[d] - start[d]) / c_min for d in range(dim))\n\n            def sample_unit_ball(k):\n                while True:\n                    v = [random.gauss(0, 1) for _ in range(k)]\n                    norm_v = math.sqrt(sum(x * x for x in v))\n                    if norm_v > 1e-12:\n                        v = [x / norm_v for x in v]\n                        r = random.random() ** (1.0 / k)\n                        return tuple(v[i] * r for i in range(k))\n\n            u = sample_unit_ball(dim)\n\n            if dim == 2:\n                a2 = (-a1[1], a1[0])\n                basis = (a1, a2)\n                radii = (r1, r_other)\n            else:\n                ref = (1.0, 0.0, 0.0) if abs(a1[0]) < 0.9 else (0.0, 1.0, 0.0)\n                b2 = self._normalize(self._cross(a1, ref))\n                if self._norm(b2) < 1e-12:\n                    ref = (0.0, 0.0, 1.0)\n                    b2 = self._normalize(self._cross(a1, ref))\n                b3 = self._cross(a1, b2)\n                basis = (a1, b2, b3)\n                radii = (r1, r_other, r_other)\n\n            sample = []\n            for d in range(dim):\n                val = center[d]\n                for i in range(dim):\n                    val += basis[i][d] * radii[i] * u[i]\n                val = max(0.0, min(bounds[d], val))\n                sample.append(val)\n            sp = tuple(sample)\n            if collision_free(sp):\n                return sp\n            # fallback uniform\n            while True:\n                s = tuple(random.uniform(0.0, bounds[d]) for d in range(dim))\n                if collision_free(s):\n                    return s\n\n        def shortcut_path(path, trials):\n            if len(path) < 3:\n                return path\n            new_path = path[:]\n            for _ in range(trials):\n                if len(new_path) < 3:\n                    break\n                i = random.randint(0, len(new_path) - 3)\n                j = random.randint(i+2, len(new_path) - 1)\n                if edge_collision_free(new_path[i], new_path[j]):\n                    new_path = new_path[:i+1] + new_path[j:]\n            return new_path\n\n        def try_connect_trees(new_node, other_tree):\n            nearest_other = nearest(other_tree, new_node.position)\n            if dist(nearest_other.position, new_node.position) <= self.step_size and edge_collision_free(new_node.position, nearest_other.position):\n                return new_node, nearest_other\n            curr = nearest_other\n            while True:\n                step_pos = steer(curr.position, new_node.position)\n                if not within_bounds(step_pos) or not collision_free(step_pos):\n                    break\n                if not edge_collision_free(curr.position, step_pos):\n                    break\n                new_other_node, _ = add_node_rrtstar(other_tree, step_pos)\n                if new_other_node is None:\n                    break\n                rewire(new_other_node, near_nodes(other_tree, step_pos, neighbor_radius_fn(len(other_tree))))\n                curr = new_other_node\n                if dist(curr.position, new_node.position) <= self.step_size and edge_collision_free(curr.position, new_node.position):\n                    return new_node, curr\n            return None, None\n\n        iteration = 0\n        side_toggle = 0\n\n        while iteration < self.max_iter:\n            if time.time() - start_time > self.time_limit_sec:\n                break\n            grow_tree = start_tree if side_toggle == 0 else goal_tree\n            other_tree = goal_tree if side_toggle == 0 else start_tree\n            side_toggle = 1 - side_toggle\n\n            # Sample random with goal bias and informed sampling if solution found\n            if found_solution:\n                sample = informed_sample(start_pos, goal_pos, best_cost, c_min)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample = goal_pos\n                else:\n                    while True:\n                        sample = tuple(random.uniform(0.0, bounds[d]) for d in range(dim))\n                        if collision_free(sample):\n                            break\n\n            if not within_bounds(sample) or not collision_free(sample):\n                iteration += 1\n                continue\n            nearest_node = nearest(grow_tree, sample)\n            new_pos = steer(nearest_node.position, sample)\n            if not within_bounds(new_pos) or not collision_free(new_pos) or not edge_collision_free(nearest_node.position, new_pos):\n                iteration += 1\n                continue\n\n            new_node, neighbors = add_node_rrtstar(grow_tree, new_pos)\n            if new_node is None:\n                iteration += 1\n                continue\n            rewire(new_node, neighbors)\n\n            n1, n2 = try_connect_trees(new_node, other_tree)\n            if n1 and n2:\n                candidate_path = stitch_paths(n1, n2)\n                candidate_cost = path_cost(candidate_path)\n                if candidate_cost + self.improve_tol < best_cost:\n                    best_cost = candidate_cost\n                    best_path = shortcut_path(candidate_path, max(10, self.shortcutting_trials // 3))\n                    found_solution = True\n                    no_improve_count = 0\n                    post_iter = 0\n                else:\n                    no_improve_count += 1\n                    post_iter += 1\n\n                if found_solution and (post_iter >= self.post_opt_iters or no_improve_count >= self.max_no_improve):\n                    break\n            else:\n                if found_solution:\n                    no_improve_count += 1\n                    post_iter += 1\n                    if post_iter >= self.post_opt_iters or no_improve_count >= self.max_no_improve:\n                        break\n\n            iteration += 1\n\n        final_path = best_path if found_solution else []\n\n        if found_solution and len(final_path) > 2:\n            final_path = shortcut_path(final_path, self.shortcutting_trials)\n\n        return PlannerResult(\n            success=found_solution,\n            path=final_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    # Collision helpers\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    # Vector utilities (for 3D rotation basis)\n    def _cross(self, a, b):\n        ax, ay, az = a\n        bx, by, bz = b\n        return (ay * bz - az * by, az * bx - ax * bz, ax * by - ay * bx)\n\n    def _norm(self, v):\n        return math.sqrt(sum(x * x for x in v))\n\n    def _normalize(self, v):\n        n = self._norm(v)\n        if n < 1e-12:\n            return v\n        return tuple(x / n for x in v)",
        "objective": 77.77843,
        "time_improvement": -320.0,
        "length_improvement": 20.0,
        "smoothness_improvement": 1285.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.12858455181121825,
                "num_nodes_avg": 346.5,
                "path_length_avg": 151.9523632213864,
                "smoothness_avg": 0.038746386554238246,
                "success_improvement": 0.0,
                "time_improvement": -389.7933291739433,
                "length_improvement": 16.712501879078157,
                "smoothness_improvement": 506.46508869892443,
                "objective_score": -104.37817218124145
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.13421530723571778,
                "num_nodes_avg": 519.3,
                "path_length_avg": 233.98936024553228,
                "smoothness_avg": 0.07859110522493014,
                "success_improvement": 0.0,
                "time_improvement": 18.726365142442578,
                "length_improvement": 21.88761653973944,
                "smoothness_improvement": 1922.2057443224785,
                "objective_score": 28.36150818818883
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.34611313343048095,
                "num_nodes_avg": 601.1,
                "path_length_avg": 120.34101107668394,
                "smoothness_avg": 0.11987741164255357,
                "success_improvement": 0.0,
                "time_improvement": -588.2930735618755,
                "length_improvement": 20.075230466017764,
                "smoothness_improvement": 1424.8318276631776,
                "objective_score": -157.3186246506361
            }
        ],
        "success_rate": 1.0
    }
]