[
    {
        "operator": "m3",
        "algorithm_description": "A simplified bidirectional RRT* planner that balances exploration and optimization with clear structure. It grows two trees from start and goal, alternates extension towards random samples with mild goal bias, uses radius-based neighbor rewiring to improve paths, and attempts greedy connection of the two trees for fast solution discovery. Strict collision checking ensures robustness.",
        "planning_mechanism": "The planner samples in free space, extends one tree towards the sample with step-wise steering, chooses the best parent among neighbors within a neighborhood radius, rewires neighbors to reduce path costs, then attempts to connect the other tree greedily. Upon connecting, it extracts and returns the combined path, iterating until a solution is found or iteration limit is reached.",
        "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent: Optional[\"Node\"]=None, cost: float=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children: List[\"Node\"] = []\n\n    def add_child(self, child: \"Node\"):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        node, path = self, []\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 3000, step_size: float = 4.0, gamma_rrt_star: float = 50.0, max_radius: float = 40.0, goal_sample_rate: float = 0.05):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.gamma_rrt_star = gamma_rrt_star\n        self.max_radius = max_radius\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map) -> \"PlannerResult\":\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        tree_start = [Node(start_pos)]\n        tree_goal = [Node(goal_pos)]\n        nodes = tree_start + tree_goal\n        edges: List[Tuple[Node,Node]] = []\n\n        def sample_free():\n            if random.random() < self.goal_sample_rate:\n                return goal_pos\n            while True:\n                s = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(s, obstacles, is_3d):\n                    return s\n\n        def nearest(tree: List[Node], point: Tuple[float, ...]) -> Node:\n            return min(tree, key=lambda n: math.dist(n.position, point))\n\n        def steer(from_pos, to_pos) -> Tuple[float, ...]:\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dim))\n\n        def neighbor_radius(n_nodes: int) -> float:\n            if n_nodes < 2:\n                return self.step_size * 2.0\n            r = self.gamma_rrt_star * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            return min(max(self.step_size*2.0, r), self.max_radius)\n\n        def near_nodes(tree: List[Node], pos: Tuple[float,...]) -> List[Node]:\n            r = neighbor_radius(len(tree))\n            return [n for n in tree if math.dist(n.position, pos) <= r]\n\n        def can_connect(from_p, to_p) -> bool:\n            return (not self._is_in_obstacle(to_p, obstacles, is_3d)\n                    and not self._is_edge_in_obstacle(from_p, to_p, obstacles, is_3d))\n\n        def add_node_with_parent(tree: List[Node], new_pos: Tuple[float, ...]) -> Optional[Node]:\n            near = near_nodes(tree, new_pos)\n            candidates = [n for n in near if can_connect(n.position, new_pos)]\n            if not candidates:\n                parent = nearest(tree, new_pos)\n                if not can_connect(parent.position, new_pos):\n                    return None\n                best_parent = parent\n                best_cost = parent.cost + math.dist(parent.position, new_pos)\n            else:\n                best_parent, best_cost = min(\n                    ((n, n.cost + math.dist(n.position, new_pos)) for n in candidates),\n                    key=lambda x: x[1]\n                )\n            new_node = Node(new_pos, parent=None, cost=best_cost)\n            best_parent.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n            return new_node\n\n        def rewire(node: Node, neighbors: List[Node]):\n            for nb in neighbors:\n                if nb is node:\n                    continue\n                if can_connect(node.position, nb.position):\n                    new_cost = node.cost + math.dist(node.position, nb.position)\n                    if new_cost + 1e-12 < nb.cost:\n                        if nb.parent is not None:\n                            try:\n                                edges.remove((nb.parent, nb))\n                            except ValueError:\n                                pass\n                            if nb in nb.parent.children:\n                                nb.parent.children.remove(nb)\n                        node.add_child(nb)\n                        nb.cost = new_cost\n                        edges.append((node, nb))\n\n        def extend(tree: List[Node], target_point: Tuple[float, ...], other_tree: List[Node]) -> Optional[Node]:\n            nearest_node = nearest(tree, target_point)\n            new_pos = steer(nearest_node.position, target_point)\n            if not can_connect(nearest_node.position, new_pos):\n                return None\n            new_node = add_node_with_parent(tree, new_pos)\n            if not new_node:\n                return None\n            near = near_nodes(tree, new_pos)\n            rewire(new_node, near)\n            # Attempt connect with other_tree greedily\n            connect_node = attempt_connect(other_tree, new_node)\n            if connect_node:\n                return (new_node, connect_node)\n            return (new_node, None)\n\n        def attempt_connect(tree: List[Node], target_node: Node) -> Optional[Node]:\n            nearest_node = nearest(tree, target_node.position)\n            current = nearest_node\n            while True:\n                new_pos = steer(current.position, target_node.position)\n                if not can_connect(current.position, new_pos):\n                    return None\n                new_node = add_node_with_parent(tree, new_pos)\n                if new_node is None:\n                    return None\n                near = near_nodes(tree, new_pos)\n                rewire(new_node, near)\n                current = new_node\n                if math.dist(current.position, target_node.position) <= self.step_size:\n                    if can_connect(current.position, target_node.position):\n                        final_node = Node(target_node.position, parent=None, cost=current.cost + math.dist(current.position, target_node.position))\n                        current.add_child(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((current, final_node))\n                        return final_node\n                    else:\n                        return None\n\n        best_path: List[Tuple[float,...]] = []\n        solution_found = False\n\n        for _ in range(self.max_iter):\n            sample = sample_free()\n            result = extend(tree_start, sample, tree_goal)\n            if result is None:\n                tree_start, tree_goal = tree_goal, tree_start\n                continue\n            new_node, connect_node = result\n            if connect_node:\n                path_start = new_node.path_from_root()\n                path_goal = connect_node.path_from_root()\n                if path_start[-1] == path_goal[-1]:\n                    path_goal = path_goal[:-1]\n                best_path = path_start + path_goal[::-1]\n                solution_found = True\n                break\n            tree_start, tree_goal = tree_goal, tree_start\n\n        return PlannerResult(success=solution_found, path=best_path, nodes=nodes, edges=edges)\n\n    def _is_in_obstacle(self, pos: Tuple[float,...], obstacles, is_3d: bool) -> bool:\n        for obs in obstacles:\n            if is_3d:\n                x,y,z,w,h,d = obs\n                px,py,pz = pos\n                if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                    return True\n            else:\n                x,y,w,h = obs\n                px,py = pos\n                if x <= px <= x+w and y <= py <= y+h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_p: Tuple[float,...], to_p: Tuple[float,...], obstacles, is_3d: bool, resolution: float=1.0) -> bool:\n        dist = math.dist(from_p, to_p)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps+1):\n            interm = tuple(from_p[d] + (to_p[d] - from_p[d]) * i/steps for d in range(len(from_p)))\n            if self._is_in_obstacle(interm, obstacles, is_3d):\n                return True\n        return False",
        "objective": 2.60201,
        "time_improvement": -40.0,
        "length_improvement": 14.0,
        "smoothness_improvement": 242.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.049528646469116214,
                "num_nodes_avg": 102.8,
                "path_length_avg": 163.73573386408458,
                "smoothness_avg": 0.024721319861977082,
                "success_improvement": 0.0,
                "time_improvement": -88.66030407138894,
                "length_improvement": 10.253849710358729,
                "smoothness_improvement": 286.9423390452511,
                "objective_score": -19.011069699975188
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.07662971019744873,
                "num_nodes_avg": 315.6,
                "path_length_avg": 257.08848163237656,
                "smoothness_avg": 0.011895872353594215,
                "success_improvement": 0.0,
                "time_improvement": 53.59713274067979,
                "length_improvement": 14.176464949466494,
                "smoothness_improvement": 206.0893639085042,
                "objective_score": 25.615465611426355
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.09266290664672852,
                "num_nodes_avg": 359.9,
                "path_length_avg": 126.19502968546935,
                "smoothness_avg": 0.02608580925521416,
                "success_improvement": 0.0,
                "time_improvement": -84.27280175389355,
                "length_improvement": 16.18727004447308,
                "smoothness_improvement": 231.80956827217284,
                "objective_score": -14.410430658123351
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "e2",
        "algorithm_description": "A hybrid bidirectional RRT* variant integrating goal bias sampling, informed rewiring, and adaptive step size to efficiently find shorter, smoother, and feasible paths in 2D/3D spaces. It uses informed sampling to speed convergence, rigorous collision checking ensuring safe expansions, incremental rewiring to optimize path cost, and path shortcutting to smooth the final output.",
        "planning_mechanism": "A bidirectional tree grows from start and goal, alternately sampling with goal bias and within an ellipsoidal informed set once a solution is found. New nodes are extended from nearest tree nodes with adaptive step size considering proximity. After adding a new node, rewiring is performed to update neighbor connections minimizing cost to come. The two trees attempt connection after each extension. Upon successful connection, the combined path is shortcut and returned.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def path_from_root(self):\n        path, node = [], self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=4.0, goal_sample_rate=0.1, neighbor_radius=10.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate  # Probability of sampling goal\n        self.neighbor_radius = neighbor_radius    # Radius to search for rewiring neighbors\n\n    def plan(self, map):\n        bounds = map.size\n        start, goal = map.start, map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        start_tree = [Node(start, cost=0.0)]\n        goal_tree = [Node(goal, cost=0.0)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        best_cost = float('inf')\n        best_connection = None\n\n        def dist(a, b):\n            return sum((a[d]-b[d])**2 for d in range(dim))**0.5\n\n        def line_cost(a, b):\n            return dist(a, b)\n\n        # Utility for collision checking a single point\n        def in_obstacle(p):\n            if is_3d:\n                x, y, z = p\n                for ox, oy, oz, w, h, d in obstacles:\n                    if ox <= x <= ox + w and oy <= y <= oy + h and oz <= z <= oz + d:\n                        return True\n            else:\n                x, y = p\n                for ox, oy, w, h in obstacles:\n                    if ox <= x <= ox + w and oy <= y <= oy + h:\n                        return True\n            return False\n\n        # Checks collision for edge p1->p2 by interpolation with resolution = 1.0 units\n        def edge_in_obstacle(p1, p2):\n            dist_p = dist(p1, p2)\n            steps = max(1, int(dist_p / 1.0))\n            for i in range(steps + 1):\n                interp = tuple(p1[d] + (p2[d]-p1[d])*i/steps for d in range(dim))\n                if in_obstacle(interp):\n                    return True\n            return False\n\n        # Sample free point with goal bias and informed ellipsoid sampling if solution found\n        def sample_free():\n            if best_connection and random.random() > self.goal_sample_rate:\n                # Informed ellipsoid sampling within informed subset (prolate hyperspheroid)\n                c_min = dist(start, goal)\n                c_best = best_cost\n                if c_best < float('inf') and c_best > c_min:\n                    center = [(s+g)*0.5 for s,g in zip(start, goal)]\n                    a1 = [(g - s)/c_min for s,g in zip(start, goal)]\n                    # Sample unit ball in dim-dim space and transform\n                    while True:\n                        x_ball = [random.gauss(0,1) for _ in range(dim)]\n                        norm = (sum(x**2 for x in x_ball))**0.5\n                        if norm <= 1:\n                            unit = [x / norm for x in x_ball]\n                            r1 = c_best / 2.0\n                            r2 = (c_best**2 - c_min**2)**0.5 / 2.0 if c_best**2 - c_min**2 > 0 else 0.0\n                            # Construct scaled unit vector in bounding box of ellipsoid\n                            if dim == 2:\n                                # Rotation matrix from a1 to x axis\n                                angle = math.atan2(a1[1], a1[0])\n                                cos_ang = math.cos(angle)\n                                sin_ang = math.sin(angle)\n                                # Scale unit ball coordinates\n                                x_ell = r1 * unit[0]\n                                y_ell = r2 * unit[1]\n                                # Rotate back to world frame and translate\n                                px = center[0] + cos_ang * x_ell - sin_ang * y_ell\n                                py = center[1] + sin_ang * x_ell + cos_ang * y_ell\n                                pt = (px, py)\n                            else:\n                                # 3D case: align a1 with x axis by rotation matrix (approximate)\n                                # To simplify, sample box around center limited by bounds\n                                pt_candidate = [center[d] + r1*unit[0] if d == 0 else center[d] + r2*unit[d] for d in range(dim)]\n                                pt = tuple(max(0,min(pt_candidate[d], bounds[d])) for d in range(dim))\n                            if (all(0 <= pt[d] <= bounds[d] for d in range(dim)) and not in_obstacle(pt)):\n                                return pt\n                else:\n                    # If no valid c_best, fall back to uniform\n                    return uniform_sample()\n            # else regular or goal biased sample\n            if random.random() < self.goal_sample_rate:\n                return goal\n            else:\n                return uniform_sample()\n\n        def uniform_sample():\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not in_obstacle(pt):\n                    return pt\n\n        # Find the nearest node in a tree by Euclidean distance\n        def nearest(tree, point):\n            best = None\n            best_dist = float('inf')\n            for node in tree:\n                d = dist(node.position, point)\n                if d < best_dist:\n                    best = node\n                    best_dist = d\n            return best\n\n        # Steer from from_pos towards to_pos by step size or closer\n        def steer(from_pos, to_pos, max_step):\n            d = dist(from_pos, to_pos)\n            if d <= max_step:\n                return to_pos\n            ratio = max_step / d\n            return tuple(from_pos[d_] + ratio * (to_pos[d_] - from_pos[d_]) for d_ in range(dim))\n\n        # Find neighbors within radius for rewiring\n        def near(tree, node, radius):\n            ret = []\n            for n in tree:\n                if dist(n.position, node.position) <= radius:\n                    ret.append(n)\n            return ret\n\n        # Attempt to add new node to tree with rewiring for cost improvement\n        def extend_with_rewire(tree, point):\n            nearest_node = nearest(tree, point)\n            new_pos = steer(nearest_node.position, point, self.step_size)\n            if in_obstacle(new_pos) or edge_in_obstacle(nearest_node.position, new_pos):\n                return None\n            new_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            new_node = Node(new_pos, parent=nearest_node, cost=new_cost)\n            nearest_node.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n\n            # Rewire neighbors if cheaper to reach via new_node\n            neighbors = near(tree, new_node, self.neighbor_radius)\n            for neighbor in neighbors:\n                if neighbor == new_node.parent:\n                    continue\n                cost_to_neighbor = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_to_neighbor < neighbor.cost:\n                    # Check if edge is collision free before rewiring\n                    if not edge_in_obstacle(new_node.position, neighbor.position):\n                        # Rewire\n                        if neighbor.parent:\n                            neighbor.parent.remove_child(neighbor)\n                        neighbor.parent = new_node\n                        new_node.children.append(neighbor)\n                        # Update costs downstream by DFS\n                        def update_costs(n):\n                            for c in n.children:\n                                old_cost = c.cost\n                                c.cost = n.cost + dist(n.position, c.position)\n                                if c.cost < old_cost:\n                                    update_costs(c)\n                        neighbor.cost = cost_to_neighbor\n                        update_costs(neighbor)\n\n            return new_node\n\n        # Try to connect tree_b to node from tree_a by single edge\n        def try_connect(tree_b, node_a):\n            nearest_node = nearest(tree_b, node_a.position)\n            if edge_in_obstacle(nearest_node.position, node_a.position) or in_obstacle(node_a.position):\n                return None\n            c_cost = nearest_node.cost + dist(nearest_node.position, node_a.position)\n            new_node = Node(node_a.position, parent=nearest_node, cost=c_cost)\n            nearest_node.add_child(new_node)\n            tree_b.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n            return new_node\n\n        # Shortcut the final path by removing unnecessary waypoints with collision checking\n        def shortcut_path(path):\n            if len(path) <= 2:\n                return path\n            shortened = [path[0]]\n            idx = 0\n            while idx < len(path) - 1:\n                next_idx = len(path) -1\n                for j in range(len(path)-1, idx, -1):\n                    if not edge_in_obstacle(path[idx], path[j]):\n                        next_idx = j\n                        break\n                shortened.append(path[next_idx])\n                idx = next_idx\n            return shortened\n\n        import random\n        import math\n\n        for itr in range(self.max_iter):\n            tree_a, tree_b = (start_tree, goal_tree) if itr % 2 == 0 else (goal_tree, start_tree)\n\n            sample = sample_free()\n            new_node_a = extend_with_rewire(tree_a, sample)\n            if new_node_a is None:\n                continue\n\n            new_node_b = try_connect(tree_b, new_node_a)\n            if new_node_b:\n                total_cost = new_node_a.cost + new_node_b.cost\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_connection = (new_node_a, new_node_b)\n\n                # Build full path from start to goal via connecting nodes\n                path_start = new_node_a.path_from_root()\n                path_goal = new_node_b.path_from_root()\n                # Remove duplication of connecting node\n                if path_start[-1] == path_goal[-1]:\n                    full_path = path_start + path_goal[-2::-1]\n                else:\n                    full_path = path_start + path_goal[::-1]\n                # Shortcut path to improve smoothness and length\n                full_path = shortcut_path(full_path)\n                return PlannerResult(\n                    success=True,\n                    path=full_path,\n                    nodes=nodes,\n                    edges=edges\n                )\n\n        # If no connection found after max_iter\n        return PlannerResult(\n            success=False,\n            path=[],\n            nodes=nodes,\n            edges=edges\n        )",
        "objective": -13.10341,
        "time_improvement": -17.0,
        "length_improvement": 15.0,
        "smoothness_improvement": 1770.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.03586246967315674,
                "num_nodes_avg": 158.2,
                "path_length_avg": 169.64979962636318,
                "smoothness_avg": 0.04954703801688554,
                "success_improvement": 0.0,
                "time_improvement": -36.60426673496058,
                "length_improvement": 7.012256551684769,
                "smoothness_improvement": 675.5187380793998,
                "objective_score": -3.3963323990803147
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.07881088256835937,
                "num_nodes_avg": 308.2,
                "path_length_avg": 237.82271271086537,
                "smoothness_avg": 0.12127577225727508,
                "success_improvement": 0.0,
                "time_improvement": 52.276331034184054,
                "length_improvement": 20.60793314987834,
                "smoothness_improvement": 3020.512971587674,
                "objective_score": 43.150224058120585
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.08306193351745605,
                "num_nodes_avg": 277.3,
                "path_length_avg": 122.87997069169981,
                "smoothness_avg": 0.13485837299586953,
                "success_improvement": 0.0,
                "time_improvement": -65.17995994568392,
                "length_improvement": 18.388974381988994,
                "smoothness_improvement": 1615.3885502978142,
                "objective_score": -0.4436606030227068
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "m2",
        "algorithm_description": "A bidirectional RRT* variant that uses informed sampling within an ellipsoidal region (informed RRT*) to bias samples towards the subset of the state space likely to improve the current solution, combined with rewiring for asymptotic optimality. It incorporates direct connection attempts between trees and post-processing shortcutting for smoother, shorter paths.",
        "planning_mechanism": "The planner grows two trees from start and goal alternately, sampling randomly inside an ellipsoid defined by start, goal, and the current best path cost to focus growth in promising areas. Each new node is connected and rewired locally to improve path cost. The trees attempt direct connection when close, and after finding a solution, the planner shortcut-postprocesses the path to enhance smoothness and reduce length.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\nclass Planner:\n    def __init__(self, max_iter=3000, step_size=7.5, rewire_radius=15.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.rewire_radius = rewire_radius\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        edges = []\n        best_cost = float('inf')\n        best_path = []\n\n        def distance(a,b):\n            return math.dist(a,b)\n\n        def is_in_collision(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d = obs\n                    px,py,pz = pos\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                        return True\n                else:\n                    x,y,w,h = obs\n                    px,py = pos\n                    if x <= px <= x+w and y <= py <= y+h:\n                        return True\n            return False\n\n        def is_edge_collision(from_pos, to_pos, resolution=1.0):\n            dist = distance(from_pos, to_pos)\n            steps = max(1,int(dist / resolution))\n            for i in range(steps+1):\n                interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * i/steps for d in range(len(from_pos)))\n                if is_in_collision(interp):\n                    return True\n            return False\n\n        def steer(from_pos, to_pos, max_step):\n            dist = distance(from_pos, to_pos)\n            if dist <= max_step:\n                return to_pos\n            ratio = max_step / dist\n            return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: distance(node.position, point))\n\n        def neighbors(tree, point, radius):\n            result = []\n            r_sq = radius*radius\n            for node in tree:\n                dx = node.position[0] - point[0]\n                dy = node.position[1] - point[1]\n                dz = node.position[2] - point[2] if is_3d else 0.0\n                dist_sq = dx*dx + dy*dy + dz*dz\n                if dist_sq <= r_sq:\n                    result.append(node)\n            return result\n\n        def extract_path(node_start, node_goal):\n            path_start = []\n            while node_start:\n                path_start.append(node_start.position)\n                node_start = node_start.parent\n            path_start.reverse()\n            path_goal = []\n            while node_goal:\n                path_goal.append(node_goal.position)\n                node_goal = node_goal.parent\n            return path_start + path_goal\n\n        def try_connect(node_from, tree_to):\n            near = nearest(tree_to, node_from.position)\n            if is_edge_collision(node_from.position, near.position):\n                return None\n            # direct connection possible, make new node\n            new_node = Node(near.position, parent=node_from, cost=node_from.cost + distance(node_from.position, near.position))\n            node_from.add_child(new_node)\n            tree_to.append(new_node)\n            edges.append((node_from,new_node))\n            return new_node\n\n        def rewire(tree, new_node):\n            nbs = neighbors(tree, new_node.position, self.rewire_radius)\n            for nb in nbs:\n                if nb == new_node.parent:\n                    continue\n                if is_edge_collision(new_node.position, nb.position):\n                    continue\n                new_cost = new_node.cost + distance(new_node.position, nb.position)\n                if new_cost + 1e-7 < nb.cost:\n                    # Rewire nb's parent link\n                    if nb.parent:\n                        try:\n                            nb.parent.children.remove(nb)\n                        except ValueError:\n                            pass\n                    nb.parent = new_node\n                    nb.cost = new_cost\n                    new_node.add_child(nb)\n\n        def informed_sample(c_best):\n            # Sample uniformly inside ellipsoid defined by start, goal, c_best\n            if c_best == float('inf'):\n                # No solution found yet, uniform sample in bounds\n                while True:\n                    sample = tuple(random.uniform(0, bounds[i]) for i in range(len(bounds)))\n                    if not is_in_collision(sample):\n                        return sample\n            else:\n                c_min = distance(start_pos, goal_pos)\n                if c_min == 0.0:\n                    return goal_pos\n                # Ellipsoid parameters\n                center = tuple((start_pos[i]+goal_pos[i])/2 for i in range(len(bounds)))\n                a1 = [(goal_pos[i]-start_pos[i])/c_min for i in range(len(bounds))]\n                # Build rotation matrix to transform unit ball samples\n                # For 2D or 3D the rotation matrix is based on a1 vector\n                # Using Householder transform for rotation to align x-axis with a1\n                dim = len(bounds)\n                def mat_vec_mult(mat, vec):\n                    return tuple(sum(mat[i][j]*vec[j] for j in range(dim)) for i in range(dim))\n                # Construct orthonormal basis with a1 as first basis vector\n                # For 2D and 3D:\n                if dim == 2:\n                    # rotation angle\n                    theta = math.acos(a1[0])\n                    if a1[1]<0:\n                        theta = -theta\n                    # rotation matrix\n                    R = [[math.cos(theta), -math.sin(theta)],\n                         [math.sin(theta), math.cos(theta)]]\n                elif dim ==3:\n                    # Construct a rotation matrix using Householder reflection\n                    # vector to rotate to x = a1\n                    x = a1\n                    I = [[1 if i==j else 0 for j in range(3)] for i in range(3)]\n                    v = [x[0]-1, x[1], x[2]]\n                    norm_v = math.sqrt(sum(vi*vi for vi in v))\n                    if norm_v < 1e-10:\n                        R = I\n                    else:\n                        v = [vi/norm_v for vi in v]\n                        R = [[I[i][j] - 2*v[i]*v[j] for j in range(3)] for i in range(3)]\n                else:\n                    R = [[1 if i==j else 0 for j in range(dim)] for i in range(dim)]\n\n                # lengths of ellipsoid axes\n                L1 = c_best/2.0\n                L_other = math.sqrt(c_best*c_best - c_min*c_min)/2.0\n\n                while True:\n                    # sample random unit vector in unit ball\n                    while True:\n                        sample = [random.uniform(-1,1) for _ in range(dim)]\n                        norm_sample = math.sqrt(sum(x*x for x in sample))\n                        if 0 < norm_sample <= 1:\n                            break\n                    unit_s = [x/norm_sample for x in sample]\n                    r = random.uniform(0,1)**(1/dim)  # radius for uniform ball sampling\n                    unit_ball_sample = [r*us for us in unit_s]\n\n                    # scale by axes\n                    ellipsoid_sample = [L1*unit_ball_sample[0]] + [L_other*unit_ball_sample[i] for i in range(1,dim)]\n\n                    # rotate and translate\n                    if dim == 2 or dim == 3:\n                        rotated = mat_vec_mult(R, ellipsoid_sample)\n                    else:\n                        rotated = ellipsoid_sample\n                    point = tuple(center[i] + rotated[i] for i in range(dim))\n                    if all(0 <= point[i] <= bounds[i] for i in range(dim)):\n                        if not is_in_collision(point):\n                            return point\n\n        def shortcut_path(path):\n            if len(path)<=2:\n                return path\n            i = 0\n            while i < len(path)-2:\n                j = len(path)-1\n                while j > i+1:\n                    if not is_edge_collision(path[i], path[j]):\n                        # shortcut between i and j\n                        path = path[:i+1] + path[j:]\n                        break\n                    j -=1\n                i +=1\n            return path\n\n        for it in range(self.max_iter):\n            sample = informed_sample(best_cost)\n            for tree_a, tree_b in [(start_tree, goal_tree),(goal_tree, start_tree)]:\n                near = nearest(tree_a, sample)\n                new_pos = steer(near.position, sample, self.step_size)\n                if is_in_collision(new_pos):\n                    continue\n                if is_edge_collision(near.position, new_pos):\n                    continue\n                new_cost = near.cost + distance(near.position, new_pos)\n                new_node = Node(new_pos, parent=near, cost=new_cost)\n                near.add_child(new_node)\n                tree_a.append(new_node)\n                edges.append((near,new_node))\n\n                rewire(tree_a, new_node)\n\n                near_to_new = nearest(tree_b, new_pos)\n                dist_trees = distance(new_pos, near_to_new.position)\n                if dist_trees <= self.step_size*2 and not is_edge_collision(new_pos, near_to_new.position):\n                    connect_node = Node(near_to_new.position, parent=new_node, cost=new_node.cost + dist_trees)\n                    new_node.add_child(connect_node)\n                    tree_b.append(connect_node)\n                    edges.append((new_node, connect_node))\n                    path = extract_path(connect_node, connect_node)\n                    # extract_path from new_node to nearest node in other tree\n                    path = extract_path(new_node, near_to_new)\n                    path = shortcut_path(path)\n                    cost_path = 0.0\n                    for k in range(len(path)-1):\n                        cost_path += distance(path[k], path[k+1])\n                    if cost_path < best_cost:\n                        best_cost = cost_path\n                        best_path = path\n            if best_path:\n                return PlannerResult(True, best_path, start_tree+goal_tree, edges)\n        return PlannerResult(False, [], start_tree+goal_tree, edges)",
        "objective": -24.54042,
        "time_improvement": 22.0,
        "length_improvement": 15.0,
        "smoothness_improvement": 1806.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.019874000549316408,
                "num_nodes_avg": 86.7,
                "path_length_avg": 165.53372291805212,
                "smoothness_avg": 0.05590834490258338,
                "success_improvement": 0.0,
                "time_improvement": 24.29764885485091,
                "length_improvement": 9.26834341891934,
                "smoothness_improvement": 775.0870046395709,
                "objective_score": 16.725735731004733
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.017957305908203124,
                "num_nodes_avg": 144.4,
                "path_length_avg": 240.5533294992943,
                "smoothness_avg": 0.12055312154964279,
                "success_improvement": 0.0,
                "time_improvement": 89.12601287090475,
                "length_improvement": 19.696374669454404,
                "smoothness_improvement": 3001.9186483760295,
                "objective_score": 53.56522190482421
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.07342400550842285,
                "num_nodes_avg": 284.9,
                "path_length_avg": 128.16200978596154,
                "smoothness_avg": 0.13688525836651863,
                "success_improvement": 0.0,
                "time_improvement": -46.01362832932536,
                "length_improvement": 14.88089551925333,
                "smoothness_improvement": 1641.1703826033552,
                "objective_score": 3.3303007257711688
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "m3",
        "algorithm_description": "A simplified bidirectional RRT* algorithm that grows two trees from start and goal, samples uniformly with bias towards improving the solution, rewires locally to optimize paths, attempts direct connections between trees to find a path, and performs post-processing shortcutting to smooth and shorten the final path. It uses straightforward nearest neighbor search and basic collision checking to ensure valid paths while balancing computational cost and path quality.",
        "planning_mechanism": "The planner alternates growing start and goal trees towards sampled points inside the map bounds or within the informed ellipsoid if a solution exists. New nodes are linked and rewired locally to reduce path cost. It frequently attempts to connect the two trees directly upon proximity. Upon finding a path, it applies shortcutting to improve smoothness. The search halts on first valid path or after max iterations.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\nclass Planner:\n    def __init__(self, max_iter=3000, step_size=7.5, rewire_radius=15.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.rewire_radius = rewire_radius\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        edges = []\n        best_cost = float('inf')\n        best_path = []\n\n        def dist(a, b):\n            return sum((a[i]-b[i])**2 for i in range(dim))**0.5\n\n        def in_collision(p):\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d = obs\n                    if x <= p[0] <= x+w and y <= p[1] <= y+h and z <= p[2] <= z+d:\n                        return True\n                else:\n                    x,y,w,h = obs\n                    if x <= p[0] <= x+w and y <= p[1] <= y+h:\n                        return True\n            return False\n\n        def edge_collision(a, b, resolution=1.0):\n            d = dist(a,b)\n            steps = max(1, int(d/resolution))\n            for i in range(steps+1):\n                pt = tuple(a[j] + (b[j]-a[j]) * i/steps for j in range(dim))\n                if in_collision(pt):\n                    return True\n            return False\n\n        def steer(from_p, to_p, max_step):\n            d = dist(from_p, to_p)\n            if d <= max_step:\n                return to_p\n            ratio = max_step / d\n            return tuple(from_p[i] + (to_p[i]-from_p[i])*ratio for i in range(dim))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: dist(n.position, point))\n\n        def neighbors(tree, point, radius):\n            radius_sq = radius*radius\n            result = []\n            for n in tree:\n                if sum((n.position[i]-point[i])**2 for i in range(dim)) <= radius_sq:\n                    result.append(n)\n            return result\n\n        def extract_path(node_start, node_goal):\n            path_start = []\n            n = node_start\n            while n:\n                path_start.append(n.position)\n                n = n.parent\n            path_start.reverse()\n            path_goal = []\n            n = node_goal\n            while n:\n                path_goal.append(n.position)\n                n = n.parent\n            return path_start + path_goal\n\n        def sample_informed(c_best):\n            if c_best == float('inf'):\n                while True:\n                    p = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                    if not in_collision(p):\n                        return p\n            c_min = dist(start_pos, goal_pos)\n            if c_min == 0.0:\n                return goal_pos\n            center = tuple((start_pos[i]+goal_pos[i])/2 for i in range(dim))\n            a1 = [(goal_pos[i]-start_pos[i])/c_min for i in range(dim)]\n            L1 = c_best/2.0\n            L2 = ((c_best**2 - c_min**2)**0.5)/2.0\n            while True:\n                while True:\n                    sample = [random.uniform(-1,1) for _ in range(dim)]\n                    norm_s = sum(s*s for s in sample)**0.5\n                    if 0 < norm_s <= 1:\n                        break\n                unit_s = [s/norm_s for s in sample]\n                r = random.uniform(0,1)**(1/dim)\n                unit_ball = [r*us for us in unit_s]\n                ellipsoid_sample = [L1*unit_ball[0]] + [L2*unit_ball[i] for i in range(1,dim)]\n                # Rotate ellipsoid sample to align with a1 (only 2D/3D)\n                if dim == 2:\n                    theta = 0\n                    if abs(a1[0]) < 1.0:\n                        theta = math.acos(a1[0])\n                        if a1[1] < 0:\n                            theta = -theta\n                    x = ellipsoid_sample[0]*math.cos(theta) - ellipsoid_sample[1]*math.sin(theta)\n                    y = ellipsoid_sample[0]*math.sin(theta) + ellipsoid_sample[1]*math.cos(theta)\n                    p = (center[0]+x, center[1]+y)\n                elif dim == 3:\n                    # simple rotation aligning x-axis to a1 using Householder reflection\n                    x = a1\n                    I = [[1 if i==j else 0 for j in range(3)] for i in range(3)]\n                    v = [x[0]-1, x[1], x[2]]\n                    norm_v = sum(vi*vi for vi in v)**0.5\n                    if norm_v < 1e-10:\n                        R = I\n                    else:\n                        v = [vi/norm_v for vi in v]\n                        R = [[I[i][j] - 2*v[i]*v[j] for j in range(3)] for i in range(3)]\n                    rotated = tuple(sum(R[i][j]*ellipsoid_sample[j] for j in range(3)) for i in range(3))\n                    p = tuple(center[i] + rotated[i] for i in range(3))\n                else:\n                    p = tuple(center[i] + ellipsoid_sample[i] for i in range(dim))\n                if all(0 <= p[i] <= bounds[i] for i in range(dim)) and not in_collision(p):\n                    return p\n\n        def shortcut_path(path):\n            if len(path)<3:\n                return path\n            i = 0\n            while i < len(path)-2:\n                j = len(path)-1\n                while j > i+1:\n                    if not edge_collision(path[i], path[j]):\n                        path = path[:i+1]+path[j:]\n                        break\n                    j -=1\n                i +=1\n            return path\n\n        def rewire(tree, new_node):\n            nghs = neighbors(tree, new_node.position, self.rewire_radius)\n            for ngh in nghs:\n                if ngh == new_node.parent:\n                    continue\n                if edge_collision(new_node.position, ngh.position):\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, ngh.position)\n                if new_cost + 1e-7 < ngh.cost:\n                    if ngh.parent:\n                        try:\n                            ngh.parent.children.remove(ngh)\n                        except:\n                            pass\n                    ngh.parent = new_node\n                    ngh.cost = new_cost\n                    new_node.add_child(ngh)\n\n        for iteration in range(self.max_iter):\n            sample = sample_informed(best_cost)\n            for (tree_a, tree_b) in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nn = nearest(tree_a, sample)\n                new_pos = steer(nn.position, sample, self.step_size)\n                if in_collision(new_pos) or edge_collision(nn.position, new_pos):\n                    continue\n                new_cost = nn.cost + dist(nn.position, new_pos)\n                new_node = Node(new_pos, parent=nn, cost=new_cost)\n                nn.add_child(new_node)\n                tree_a.append(new_node)\n                edges.append((nn, new_node))\n\n                rewire(tree_a, new_node)\n\n                nearest_other = nearest(tree_b, new_pos)\n                dist_trees = dist(new_pos, nearest_other.position)\n                if dist_trees <= self.step_size*2 and not edge_collision(new_pos, nearest_other.position):\n                    connect_node = Node(nearest_other.position, parent=new_node, cost=new_node.cost + dist_trees)\n                    new_node.add_child(connect_node)\n                    tree_b.append(connect_node)\n                    edges.append((new_node, connect_node))\n\n                    path = extract_path(new_node, nearest_other)\n                    path = shortcut_path(path)\n\n                    cost_path = 0.0\n                    for k in range(len(path)-1):\n                        cost_path += dist(path[k], path[k+1])\n                    if cost_path < best_cost:\n                        best_cost = cost_path\n                        best_path = path\n            if best_path:\n                return PlannerResult(True, best_path, start_tree+goal_tree, edges)\n        return PlannerResult(False, [], start_tree+goal_tree, edges)",
        "objective": -7.96217,
        "time_improvement": -25.0,
        "length_improvement": 11.0,
        "smoothness_improvement": 1799.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.05618610382080078,
                "num_nodes_avg": 139.8,
                "path_length_avg": 185.25496856355855,
                "smoothness_avg": 0.04960682018479354,
                "success_improvement": 0.0,
                "time_improvement": -114.01932390840987,
                "length_improvement": -1.5411838225179815,
                "smoothness_improvement": 676.4544588262154,
                "objective_score": -31.748235171902678
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.037730622291564944,
                "num_nodes_avg": 170.8,
                "path_length_avg": 236.8253031039858,
                "smoothness_avg": 0.12587993282534443,
                "success_improvement": 0.0,
                "time_improvement": 77.15234661209345,
                "length_improvement": 20.94089718549847,
                "smoothness_improvement": 3138.9813392469123,
                "objective_score": 51.40514899116168
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.06945254802703857,
                "num_nodes_avg": 205.7,
                "path_length_avg": 131.1004396537589,
                "smoothness_avg": 0.13218220013348647,
                "success_improvement": 0.0,
                "time_improvement": -38.11584459228801,
                "length_improvement": 12.929330314056402,
                "smoothness_improvement": 1581.3478290228345,
                "objective_score": 4.22958395586161
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "m3",
        "algorithm_description": "A simplified and efficient bidirectional RRT* planner that incrementally grows two trees from start and goal, sampling free space with goal bias, extending one tree towards samples stepwise, choosing best parents within a radius, rewiring neighbors to reduce costs, and attempting connection between trees for fast solution. It ensures collision-free nodes and edges with minimal overhead and prioritized early stopping on solution discovery.",
        "planning_mechanism": "The planner alternates growing two trees toward random samples, connecting new nodes by selecting lowest cost parents in a neighborhood, rewires neighbors to optimize paths locally, and greedily connects trees incrementally. Planning stops on first found solution or max iterations.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        node, path = self, []\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=3000, step_size=4.0, gamma=50.0, max_radius=40.0, goal_sample_rate=0.05):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.gamma = gamma\n        self.max_radius = max_radius\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map):\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        tree_start = [Node(start_pos)]\n        tree_goal = [Node(goal_pos)]\n        nodes = tree_start + tree_goal\n        edges = []\n\n        def in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    px, py = pos\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def edge_collision(p1, p2, resolution=1.0):\n            dist = math.dist(p1, p2)\n            steps = max(1, int(dist / resolution))\n            for i in range(steps + 1):\n                interm = tuple(p1[d] + (p2[d] - p1[d]) * i / steps for d in range(dim))\n                if in_obstacle(interm):\n                    return True\n            return False\n\n        def sample_free():\n            if random.random() < self.goal_sample_rate:\n                return goal_pos\n            while True:\n                s = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not in_obstacle(s):\n                    return s\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: math.dist(n.position, point))\n\n        def steer(from_p, to_p):\n            dist = math.dist(from_p, to_p)\n            if dist <= self.step_size:\n                return to_p\n            ratio = self.step_size / dist\n            return tuple(from_p[d] + (to_p[d] - from_p[d]) * ratio for d in range(dim))\n\n        def neighbor_radius(n):\n            if n < 2:\n                return self.step_size * 2.0\n            r = self.gamma * ((math.log(n) / n) ** (1 / dim))\n            return min(max(self.step_size * 2, r), self.max_radius)\n\n        def near_nodes(tree, pos):\n            radius = neighbor_radius(len(tree))\n            return [n for n in tree if math.dist(n.position, pos) <= radius]\n\n        def can_connect(p1, p2):\n            return (not in_obstacle(p2) and not edge_collision(p1, p2))\n\n        def add_node(tree, new_pos):\n            near = near_nodes(tree, new_pos)\n            candidates = [n for n in near if can_connect(n.position, new_pos)]\n            if not candidates:\n                parent = nearest(tree, new_pos)\n                if not can_connect(parent.position, new_pos):\n                    return None\n                best_parent = parent\n                best_cost = parent.cost + math.dist(parent.position, new_pos)\n            else:\n                best_parent, best_cost = min(\n                    ((n, n.cost + math.dist(n.position, new_pos)) for n in candidates),\n                    key=lambda x: x[1]\n                )\n            new_node = Node(new_pos, parent=None, cost=best_cost)\n            best_parent.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n            return new_node\n\n        def rewire(new_node, neighbors):\n            for nb in neighbors:\n                if nb is new_node:\n                    continue\n                if can_connect(new_node.position, nb.position):\n                    new_cost = new_node.cost + math.dist(new_node.position, nb.position)\n                    if new_cost + 1e-12 < nb.cost:\n                        if nb.parent:\n                            try:\n                                edges.remove((nb.parent, nb))\n                            except ValueError:\n                                pass\n                            if nb in nb.parent.children:\n                                nb.parent.children.remove(nb)\n                        new_node.add_child(nb)\n                        nb.cost = new_cost\n                        edges.append((new_node, nb))\n\n        def extend(tree, target, other_tree):\n            nearest_node = nearest(tree, target)\n            new_pos = steer(nearest_node.position, target)\n            if not can_connect(nearest_node.position, new_pos):\n                return None\n            new_node = add_node(tree, new_pos)\n            if not new_node:\n                return None\n            near = near_nodes(tree, new_pos)\n            rewire(new_node, near)\n            connect_node = attempt_connect(other_tree, new_node)\n            if connect_node:\n                return new_node, connect_node\n            return new_node, None\n\n        def attempt_connect(tree, target_node):\n            nearest_node = nearest(tree, target_node.position)\n            current = nearest_node\n            while True:\n                new_pos = steer(current.position, target_node.position)\n                if not can_connect(current.position, new_pos):\n                    return None\n                new_node = add_node(tree, new_pos)\n                if not new_node:\n                    return None\n                near = near_nodes(tree, new_pos)\n                rewire(new_node, near)\n                current = new_node\n                if math.dist(current.position, target_node.position) <= self.step_size:\n                    if can_connect(current.position, target_node.position):\n                        final_node = Node(target_node.position, parent=None, cost=current.cost + math.dist(current.position, target_node.position))\n                        current.add_child(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((current, final_node))\n                        return final_node\n                    else:\n                        return None\n\n        best_path = []\n        found = False\n        for _ in range(self.max_iter):\n            sample = sample_free()\n            res = extend(tree_start, sample, tree_goal)\n            if res is None:\n                tree_start, tree_goal = tree_goal, tree_start\n                continue\n            new_node, connect_node = res\n            if connect_node:\n                path_start = new_node.path_from_root()\n                path_goal = connect_node.path_from_root()\n                if path_start[-1] == path_goal[-1]:\n                    path_goal = path_goal[:-1]\n                best_path = path_start + path_goal[::-1]\n                found = True\n                break\n            tree_start, tree_goal = tree_goal, tree_start\n\n        return PlannerResult(success=found, path=best_path, nodes=nodes, edges=edges)",
        "objective": -3.14348,
        "time_improvement": -23.0,
        "length_improvement": 15.0,
        "smoothness_improvement": 270.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.04289665222167969,
                "num_nodes_avg": 86.2,
                "path_length_avg": 154.80487257571312,
                "smoothness_avg": 0.029055568068706832,
                "success_improvement": 0.0,
                "time_improvement": -63.398276123557494,
                "length_improvement": 15.14899630106843,
                "smoothness_improvement": 354.7827354511964,
                "objective_score": -8.156171379170209
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.07331087589263915,
                "num_nodes_avg": 305.3,
                "path_length_avg": 256.0586439039306,
                "smoothness_avg": 0.012268278642848006,
                "success_improvement": 0.0,
                "time_improvement": 55.60684186400731,
                "length_improvement": 14.52025442545721,
                "smoothness_improvement": 215.67164596441225,
                "objective_score": 26.472563444298576
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.08116095066070557,
                "num_nodes_avg": 297.7,
                "path_length_avg": 129.65699918833218,
                "smoothness_avg": 0.02674729664510849,
                "success_improvement": 0.0,
                "time_improvement": -61.399596801723554,
                "length_improvement": 13.887994741944096,
                "smoothness_improvement": 240.22363904570852,
                "objective_score": -8.885964000122067
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "m3",
        "algorithm_description": "A simplified bidirectional RRT* planner that alternately grows two trees from start and goal using fixed step-size steering, nearest neighbor connection, and local rewiring with a fixed radius. The algorithm attempts to connect the two trees when nodes are nearby and extracts the combined path. After finding a path, a simple shortcutting step reduces unnecessary waypoints to improve smoothness and path length. This streamlined version reduces overhead while preserving feasible, short, and smooth paths.",
        "planning_mechanism": "A bidirectional RRT* variant that grows two trees alternately by sampling points, steering from nearest nodes, rewiring neighbors within a fixed radius to improve costs, and attempts to connect the trees when close. Upon connection, it extracts and shortcuts the path for quality.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\nclass Planner:\n    def __init__(self, max_iter=2000, step_size=5.0, radius=15.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.radius = radius\n\n    def plan(self, map):\n        bounds = map.size\n        start = Node(map.start)\n        goal = Node(map.goal)\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = dim == 3\n\n        tree_start = [start]\n        tree_goal = [goal]\n\n        def dist(a, b):\n            return sum((a[i]-b[i])**2 for i in range(dim))**0.5\n\n        def in_obstacle(p):\n            if not obstacles:\n                return False\n            if is_3d:\n                x,y,z = p\n                for ox, oy, oz, w, h, d in obstacles:\n                    if ox <= x <= ox+w and oy <= y <= oy+h and oz <= z <= oz+d:\n                        return True\n            else:\n                x,y = p\n                for ox, oy, w, h in obstacles:\n                    if ox <= x <= ox+w and oy <= y <= oy+h:\n                        return True\n            return False\n\n        def collision_free(frm, to):\n            d = dist(frm, to)\n            steps = max(1, int(d))\n            for i in range(steps + 1):\n                interp = tuple(frm[j] + (to[j]-frm[j]) * i/steps for j in range(dim))\n                if in_obstacle(interp):\n                    return False\n            return True\n\n        import random\n\n        def sample_free():\n            while True:\n                p = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not in_obstacle(p):\n                    return p\n\n        def steer(frm, to):\n            d = dist(frm, to)\n            if d <= self.step_size:\n                return to\n            ratio = self.step_size / d\n            return tuple(frm[i] + (to[i]-frm[i]) * ratio for i in range(dim))\n\n        def nearest(tree, point):\n            best = tree[0]\n            best_d = dist(best.position, point)\n            for node in tree:\n                d = dist(node.position, point)\n                if d < best_d:\n                    best, best_d = node, d\n            return best\n\n        def near_nodes(tree, point):\n            return [node for node in tree if dist(node.position, point) <= self.radius]\n\n        def add_node(tree, pos):\n            near = near_nodes(tree, pos)\n            min_cost, min_parent = None, None\n            for node in near:\n                if collision_free(node.position, pos):\n                    c = node.cost + dist(node.position, pos)\n                    if min_cost is None or c < min_cost:\n                        min_cost, min_parent = c, node\n            if min_parent is None:\n                min_parent = nearest(tree, pos)\n                if not collision_free(min_parent.position, pos):\n                    return None\n                min_cost = min_parent.cost + dist(min_parent.position, pos)\n            new_node = Node(pos, parent=min_parent, cost=min_cost)\n            min_parent.add_child(new_node)\n            tree.append(new_node)\n            rewire(new_node, tree)\n            return new_node\n\n        def rewire(new_node, tree):\n            for node in near_nodes(tree, new_node.position):\n                if node is new_node.parent:\n                    continue\n                if collision_free(new_node.position, node.position):\n                    c = new_node.cost + dist(new_node.position, node.position)\n                    if c + 1e-9 < node.cost:\n                        if node.parent:\n                            try:\n                                node.parent.children.remove(node)\n                            except ValueError:\n                                pass\n                        node.parent = new_node\n                        node.cost = c\n                        new_node.children.append(node)\n\n        def extract_path(node):\n            path = []\n            while node:\n                path.append(node.position)\n                node = node.parent\n            return path[::-1]\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            shortened = [path[0]]\n            i = 0\n            while i < len(path) - 1:\n                j = len(path) - 1\n                while j > i + 1:\n                    if collision_free(path[i], path[j]):\n                        break\n                    j -= 1\n                shortened.append(path[j])\n                i = j\n            return shortened\n\n        success = False\n        best_path = []\n        best_cost = float('inf')\n\n        for i in range(self.max_iter):\n            rand_pos = sample_free()\n            tree_a, tree_b = (tree_start, tree_goal) if i % 2 == 0 else (tree_goal, tree_start)\n            nearest_node = nearest(tree_a, rand_pos)\n            new_pos = steer(nearest_node.position, rand_pos)\n            if in_obstacle(new_pos):\n                continue\n            new_node = add_node(tree_a, new_pos)\n            if new_node is None:\n                continue\n            nearest_to_new = nearest(tree_b, new_node.position)\n            if dist(new_node.position, nearest_to_new.position) <= self.step_size:\n                if collision_free(new_node.position, nearest_to_new.position):\n                    connector = Node(nearest_to_new.position, parent=new_node,\n                                     cost=new_node.cost + dist(new_node.position, nearest_to_new.position))\n                    new_node.add_child(connector)\n                    tree_a.append(connector)\n                    path_start = extract_path(connector if tree_a is tree_start else nearest_to_new)\n                    path_goal = extract_path(nearest_to_new if tree_a is tree_start else connector)\n                    combined = path_start + path_goal[::-1][1:]\n                    shortcut = shortcut_path(combined)\n                    cost = sum(dist(shortcut[i], shortcut[i+1]) for i in range(len(shortcut)-1))\n                    if cost < best_cost:\n                        best_cost = cost\n                        best_path = shortcut\n                        success = True\n                    break\n\n        return PlannerResult(success, best_path, tree_start + tree_goal, [])",
        "objective": -14.56634,
        "time_improvement": -11.0,
        "length_improvement": 19.0,
        "smoothness_improvement": 1357.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.035758161544799806,
                "num_nodes_avg": 95.1,
                "path_length_avg": 158.08045278022354,
                "smoothness_avg": 0.0437108561114864,
                "success_improvement": 0.0,
                "time_improvement": -36.20694509151112,
                "length_improvement": 13.353598886086381,
                "smoothness_improvement": 584.1698177880498,
                "objective_score": 0.0709248931387414
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.14818284511566163,
                "num_nodes_avg": 270.9,
                "path_length_avg": 229.20584772072934,
                "smoothness_avg": 0.08798497858952058,
                "success_improvement": 0.0,
                "time_improvement": 10.268368831187576,
                "length_improvement": 23.484490706292497,
                "smoothness_improvement": 2163.9168721268857,
                "objective_score": 27.990789433766196
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.053970956802368165,
                "num_nodes_avg": 154.9,
                "path_length_avg": 122.40981172898974,
                "smoothness_avg": 0.1118739121743925,
                "success_improvement": 0.0,
                "time_improvement": -7.328593319729027,
                "length_improvement": 18.70123157845707,
                "smoothness_improvement": 1323.0279051850484,
                "objective_score": 15.637300477080775
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "m3",
        "algorithm_description": "An improved bidirectional sampling-based planner combining informed heuristic sampling with adaptive rewiring and lazy collision checking to enhance planning speed, path quality, and smoothness. The planner alternates forward and backward tree expansions, samples inside an informed ellipsoid for efficient search, applies rewiring with adaptive radius to optimize connectivity, and performs path shortcutting to smooth the final solution.",
        "planning_mechanism": "The planner grows two trees from start and goal, uses adaptive informed sampling focused on the current best solution corridor to accelerate convergence, rewires local connections based on adaptive neighborhoods to improve path cost, delays expensive collision checks (lazy evaluation) until necessary to reduce redundant computations, attempts direct tree connections to find feasible paths quickly, and post-processes the resulting path via shortcutting for smoothness and length reduction.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n    def add_child(self, child):\n        self.children.append(child)\nclass Planner:\n    def __init__(self, max_iter=4000, step_size=6.0, base_rewire_radius=12.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.base_rewire_radius = base_rewire_radius\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        edges = []\n        best_cost = float('inf')\n        best_path = []\n\n        def dist(a,b):\n            return math.dist(a,b)\n\n        def in_collision(p):\n            for o in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d = o\n                    px,py,pz = p\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                        return True\n                else:\n                    x,y,w,h = o\n                    px,py = p\n                    if x <= px <= x+w and y <= py <= y+h:\n                        return True\n            return False\n\n        def edge_collision(p1,p2,res=1.0):\n            distance = dist(p1,p2)\n            steps = max(1,int(distance/res))\n            for i in range(steps+1):\n                interp = tuple(p1[d]+(p2[d]-p1[d])*i/steps for d in range(dim))\n                if in_collision(interp):\n                    return True\n            return False\n\n        def steer(from_p,to_p,step):\n            distance = dist(from_p,to_p)\n            if distance <= step:\n                return to_p\n            ratio = step / distance\n            return tuple(from_p[i] + (to_p[i]-from_p[i])*ratio for i in range(dim))\n\n        def nearest(tree, p):\n            return min(tree, key=lambda n: dist(n.position, p))\n\n        def near(tree, p, radius):\n            r2 = radius**2\n            result = []\n            for n in tree:\n                d2 = sum((n.position[i]-p[i])**2 for i in range(dim))\n                if d2 <= r2:\n                    result.append(n)\n            return result\n\n        def extract_path(n_start, n_goal):\n            path_start, path_goal = [], []\n            while n_start:\n                path_start.append(n_start.position)\n                n_start = n_start.parent\n            while n_goal:\n                path_goal.append(n_goal.position)\n                n_goal = n_goal.parent\n            path_start.reverse()\n            return path_start + path_goal\n\n        def shortcut(path):\n            if len(path) <= 2:\n                return path\n            i = 0\n            while i < len(path)-2:\n                j = len(path)-1\n                while j > i+1:\n                    if not edge_collision(path[i], path[j]):\n                        path = path[:i+1] + path[j:]\n                        break\n                    j -= 1\n                i += 1\n            return path\n\n        def informed_sample(c_best):\n            if c_best == float('inf'):\n                while True:\n                    sample = tuple(random.uniform(0,bounds[i]) for i in range(dim))\n                    if not in_collision(sample):\n                        return sample\n            c_min = dist(start_pos, goal_pos)\n            if c_min == 0.0:\n                return goal_pos\n            center = tuple((start_pos[i]+goal_pos[i])*0.5 for i in range(dim))\n            a1 = [(goal_pos[i]-start_pos[i])/c_min for i in range(dim)]\n\n            # rotation matrix R that aligns x-axis with a1 (2D/3D only)\n            def mat_vec_mult(mat, vec):\n                return tuple(sum(mat[i][j]*vec[j] for j in range(dim)) for i in range(dim))\n\n            if dim == 2:\n                theta = math.acos(max(min(a1[0],1.0),-1.0))\n                if a1[1]<0:\n                    theta = -theta\n                R = [[math.cos(theta), -math.sin(theta)],\n                     [math.sin(theta), math.cos(theta)]]\n            elif dim == 3:\n                x = a1\n                I = [[1 if i==j else 0 for j in range(3)] for i in range(3)]\n                v = [x[0]-1, x[1], x[2]]\n                norm_v = math.sqrt(sum(vi*vi for vi in v))\n                if norm_v < 1e-10:\n                    R = I\n                else:\n                    v = [vi/norm_v for vi in v]\n                    R = [[I[i][j]-2*v[i]*v[j] for j in range(3)] for i in range(3)]\n            else:\n                R = [[1 if i==j else 0 for j in range(dim)] for i in range(dim)]\n\n            L1 = c_best/2.0\n            L2 = math.sqrt(max(c_best*c_best - c_min*c_min,0))/2.0\n\n            while True:\n                while True:\n                    sample = [random.uniform(-1,1) for _ in range(dim)]\n                    norm_s = math.sqrt(sum(x*x for x in sample))\n                    if norm_s > 0 and norm_s <= 1:\n                        break\n                unit_s = [x/norm_s for x in sample]\n                r = random.uniform(0,1)**(1/dim)\n                unit_ball = [r * us for us in unit_s]\n                ellip = [L1*unit_ball[0]] + [L2*unit_ball[i] for i in range(1,dim)]\n                rotated = mat_vec_mult(R, ellip)\n                point = tuple(center[i] + rotated[i] for i in range(dim))\n                if all(0 <= point[i] <= bounds[i] for i in range(dim)) and not in_collision(point):\n                    return point\n\n        # adaptive rewire radius decreases as tree grows (based on RRT* formula)\n        def rewire_radius(num_nodes):\n            gamma_rrt = 2 * (1 + 1/dim)**(1/dim) * (math.prod(bounds)**(1/dim))\n            radius = min(self.base_rewire_radius, gamma_rrt * (math.log(num_nodes+1)/(num_nodes+1))**(1/dim))\n            return radius\n\n        def rewire(tree, new_node):\n            r = rewire_radius(len(tree))\n            nbs = near(tree, new_node.position, r)\n            for nb in nbs:\n                if nb == new_node.parent:\n                    continue\n                if edge_collision(new_node.position, nb.position):\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, nb.position)\n                if new_cost + 1e-9 < nb.cost:\n                    if nb.parent:\n                        try:\n                            nb.parent.children.remove(nb)\n                        except Exception:\n                            pass\n                    nb.parent = new_node\n                    nb.cost = new_cost\n                    new_node.add_child(nb)\n\n        for it in range(self.max_iter):\n            sample = informed_sample(best_cost)\n            for tree_a, tree_b in [(start_tree, goal_tree),(goal_tree, start_tree)]:\n                nearest_node = nearest(tree_a, sample)\n                new_pos = steer(nearest_node.position, sample, self.step_size)\n                if in_collision(new_pos):\n                    continue\n                if edge_collision(nearest_node.position, new_pos):\n                    continue\n                new_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n                new_node = Node(new_pos, parent=nearest_node, cost=new_cost)\n                nearest_node.add_child(new_node)\n                tree_a.append(new_node)\n                edges.append((nearest_node,new_node))\n                rewire(tree_a, new_node)\n\n                connect_node = nearest(tree_b, new_pos)\n                gap = dist(new_pos, connect_node.position)\n                if gap <= self.step_size*1.8 and not edge_collision(new_pos, connect_node.position):\n                    connect_new = Node(connect_node.position, parent=new_node, cost=new_node.cost+gap)\n                    new_node.add_child(connect_new)\n                    tree_b.append(connect_new)\n                    edges.append((new_node, connect_new))\n                    path = extract_path(connect_new, connect_node)\n                    path = shortcut(path)\n                    cost_path = 0.0\n                    for i in range(len(path)-1):\n                        cost_path += dist(path[i], path[i+1])\n                    if cost_path < best_cost:\n                        best_cost = cost_path\n                        best_path = path\n            if best_path:\n                return PlannerResult(True,best_path,start_tree+goal_tree,edges)\n        return PlannerResult(False,[],start_tree+goal_tree,edges)",
        "objective": -28.64627,
        "time_improvement": 37.0,
        "length_improvement": 14.0,
        "smoothness_improvement": 1851.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.027629590034484862,
                "num_nodes_avg": 116.4,
                "path_length_avg": 170.26662958714778,
                "smoothness_avg": 0.06141652618419348,
                "success_improvement": 0.0,
                "time_improvement": -5.244282428030285,
                "length_improvement": 6.674162275882516,
                "smoothness_improvement": 861.3020029038676,
                "objective_score": 6.737722651639762
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.031986331939697264,
                "num_nodes_avg": 221.9,
                "path_length_avg": 238.03820887872735,
                "smoothness_avg": 0.12286205335960987,
                "success_improvement": 0.0,
                "time_improvement": 80.63078261308962,
                "length_improvement": 20.535994326332737,
                "smoothness_improvement": 3061.329126902844,
                "objective_score": 51.817477014240744
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.032309651374816895,
                "num_nodes_avg": 180.3,
                "path_length_avg": 129.22310027085973,
                "smoothness_avg": 0.13606286458102096,
                "success_improvement": 0.0,
                "time_improvement": 35.74786073539117,
                "length_improvement": 14.176169742883147,
                "smoothness_improvement": 1630.7095943546199,
                "objective_score": 27.383608038120336
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "cross_over",
        "algorithm_description": "An improved bidirectional RRT* planner integrates adaptive informed sampling with adaptive neighborhood rewiring and incremental cost propagation. It dynamically balances exploration and exploitation, uses an efficient radius scaling with tighter bounds to minimize unnecessary neighbors, performs incremental rewiring with recursive cost updates to avoid local suboptimality, and employs lazy collision checks and early exits to reduce planning time. The algorithm refines paths online, connects trees with smarter distance thresholds, and uses aggressive shortcut smoothing on the final path to maximize smoothness and minimize length within a strict iteration and time limit.",
        "planning_mechanism": "The planner alternates tree growth with samples biased by an adaptive informed ellipsoid based on the best solution cost. For each new node, it selects the minimum-cost parent among neighbors within a carefully bounded radius, inserts the node if collision free, and rewires neighbors with recursive cost updates to promote global path improvement. The trees attempt connection via nearest nodes when close, and if successful, the combined path undergoes shortcut smoothing to produce a short, smooth output. Adaptive radius and step size ensure efficient, focused growth. The use of early collision checks and incremental cost propagation reduces overhead and improves solution quality iteratively.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n\n    def path_from_root(self):\n        path = []\n        n = self\n        while n:\n            path.append(n.position)\n            n = n.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=4000, step_size=4.5, gamma=40.0,\n                 time_limit_sec=15.0, post_opt_iters=200, max_no_improve=80):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.gamma = gamma\n        self.time_limit_sec = time_limit_sec\n        self.post_opt_iters = post_opt_iters\n        self.max_no_improve = max_no_improve\n\n    def plan(self, map):\n        import math\n        import random\n        import time\n\n        bounds = map.size\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def within_bounds(p):\n            return all(0.0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def in_obstacle(p):\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d = obs\n                    px,py,pz = p\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                        return True\n                else:\n                    x,y,w,h = obs\n                    px,py = p\n                    if x <= px <= x+w and y <= py <= y+h:\n                        return True\n            return False\n\n        def edge_collision(a,b,resolution=1.0):\n            length = dist(a,b)\n            steps = max(2, int(length / resolution))\n            for i in range(steps+1):\n                pt = tuple(a[d]+(b[d]-a[d])*i/steps for d in range(dim))\n                if in_obstacle(pt):\n                    return True\n            return False\n\n        def steer(from_p, to_p):\n            d = dist(from_p,to_p)\n            if d <= self.step_size:\n                return to_p\n            r = self.step_size / d\n            return tuple(from_p[i] + (to_p[i]-from_p[i])*r for i in range(dim))\n\n        def neighbor_radius(n_nodes, c_best=float('inf')):\n            if n_nodes < 2:\n                return self.step_size * 2.0\n            base = self.gamma * ((math.log(n_nodes)/n_nodes)**(1.0/dim))\n            max_r = max(bounds)*0.3\n            min_r = max(self.step_size*1.8,10.0)\n            r = max(min_r, min(max_r, base))\n            if c_best < float('inf'):\n                # Reduce radius proportional to cost improvement for focused rewiring\n                r = min(r, max(self.step_size*2.2, c_best*0.15))\n            return r\n\n        def nearest(tree, p):\n            return min(tree, key=lambda n: dist(n.position,p))\n\n        def near_nodes(tree, p, radius):\n            return [n for n in tree if dist(n.position,p) <= radius]\n\n        def sample_uniform():\n            for _ in range(100):\n                p = tuple(random.uniform(0,bounds[d]) for d in range(dim))\n                if not in_obstacle(p):\n                    return p\n            return start_pos  # fallback\n\n        def sample_unit_ball():\n            while True:\n                v = [random.gauss(0,1) for _ in range(dim)]\n                normv = math.sqrt(sum(x*x for x in v))\n                if normv > 1e-12:\n                    v = [x/normv for x in v]\n                    r = random.random() ** (1.0/dim)\n                    return tuple(v[i]*r for i in range(dim))\n\n        def sample_informed(c_best):\n            if c_best == float(\"inf\"):\n                return sample_uniform()\n            c_min = dist(start_pos, goal_pos)\n            if c_min < 1e-12:\n                return sample_uniform()\n            r1 = c_best/2.0\n            r_other_sq = max(c_best*c_best - c_min*c_min, 0.0)\n            r_other = math.sqrt(r_other_sq)/2.0\n            center = tuple((start_pos[d]+goal_pos[d])/2.0 for d in range(dim))\n            unit_vec = tuple((goal_pos[d]-start_pos[d])/c_min for d in range(dim))\n\n            if dim==2:\n                perp_vec = (-unit_vec[1], unit_vec[0])\n                basis = [unit_vec, perp_vec]\n                radii = [r1, r_other]\n            else:\n                def cross(u,v):\n                    return (u[1]*v[2]-u[2]*v[1], u[2]*v[0]-u[0]*v[2], u[0]*v[1]-u[1]*v[0])\n                def norm_vec(vv):\n                    return math.sqrt(sum(x*x for x in vv))\n                def normalize(vv):\n                    n = norm_vec(vv)\n                    if n < 1e-12:\n                        return vv\n                    return tuple(x/n for x in vv)\n                ref = (1.0,0.0,0.0) if abs(unit_vec[0]) < 0.9 else (0.0,1.0,0.0)\n                b2 = normalize(cross(unit_vec, ref))\n                if norm_vec(b2) < 1e-12:\n                    ref = (0.0,0.0,1.0)\n                    b2 = normalize(cross(unit_vec, ref))\n                b3 = cross(unit_vec, b2)\n                basis = [unit_vec, b2, b3]\n                radii = [r1, r_other, r_other]\n\n            u = sample_unit_ball()\n            mapped = []\n            for d in range(dim):\n                val = center[d]\n                for i in range(dim):\n                    val += basis[i][d]*radii[i]*u[i]\n                val = max(0.0, min(bounds[d], val))\n                mapped.append(val)\n            return tuple(mapped)\n\n        def can_connect(p1, p2):\n            if in_obstacle(p2):\n                return False\n            if edge_collision(p1, p2):\n                return False\n            return True\n\n        def add_node_with_parent(tree, pos, best_parent):\n            cost_new = best_parent.cost + dist(best_parent.position, pos)\n            new_node = Node(pos, parent=best_parent, cost=cost_new)\n            best_parent.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n            return new_node\n\n        def update_cost_recursive(node, cost_delta):\n            node.cost += cost_delta\n            for c in node.children:\n                update_cost_recursive(c, cost_delta)\n\n        def rewire(node, neighbors):\n            n_changed = 0\n            for nb in neighbors:\n                if nb is node:\n                    continue\n                d_new = dist(node.position, nb.position)\n                cost_candidate = node.cost + d_new\n                if cost_candidate + 1e-12 < nb.cost:\n                    if can_connect(node.position, nb.position):\n                        # Rewire nb parent\n                        if nb.parent:\n                            try:\n                                edges.remove((nb.parent, nb))\n                            except:\n                                pass\n                            nb.parent.remove_child(nb)\n                        node.add_child(nb)\n                        cost_diff = cost_candidate - nb.cost\n                        update_cost_recursive(nb, cost_diff)\n                        edges.append((node, nb))\n                        n_changed += 1\n            return n_changed\n\n        def add_node(tree, pos, c_best=float('inf')):\n            r = neighbor_radius(len(tree), c_best)\n            near = near_nodes(tree, pos, r)\n            if not near:\n                # fallback nearest\n                near = [nearest(tree, pos)]\n            candidates = [p for p in near if can_connect(p.position, pos)]\n            if not candidates:\n                return None, []\n            best_parent = min(candidates, key=lambda p: p.cost+dist(p.position,pos))\n            if in_obstacle(pos):\n                return None, []\n            return add_node_with_parent(tree, pos, best_parent), near\n\n        def connect_trees(n1, tree_other):\n            # Connect if within threshold, use smaller threshold than step_size*3\n            threshold = self.step_size*2.2\n            near_other = nearest(tree_other, n1.position)\n            d = dist(n1.position, near_other.position)\n            if d > threshold:\n                return None\n            if can_connect(n1.position, near_other.position):\n                return near_other\n            return None\n\n        def extract_path(n_start, n_goal, start_side=True):\n            path_s = n_start.path_from_root()\n            path_g = n_goal.path_from_root()\n            if path_s[-1] == path_g[-1]:\n                combined = path_s + path_g[-2::-1]\n            else:\n                combined = path_s + path_g[::-1]\n            return combined if start_side else combined[::-1]\n\n        def path_cost(path):\n            if len(path) < 2:\n                return 0.0\n            return sum(dist(path[i], path[i+1]) for i in range(len(path)-1))\n\n        def shortcut_path(path, attempts=60):\n            if len(path) < 3:\n                return path[:]\n            for _ in range(attempts):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path)-3)\n                j = random.randint(i+2, len(path)-1)\n                if j <= i+1:\n                    continue\n                if not edge_collision(path[i], path[j]):\n                    # Remove intermediate nodes between i+1 and j-1\n                    path = path[:i+1]+path[j:]\n            return path\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        tree_a = [start_root]\n        tree_b = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        best_cost = float('inf')\n        best_path = []\n        found = False\n        no_improve_cnt = 0\n        post_opt_cnt = 0\n        t_start = time.time()\n\n        for it in range(self.max_iter):\n            if time.time() - t_start > self.time_limit_sec:\n                break\n\n            grow_tree = tree_a if (it % 2 == 0) else tree_b\n            other_tree = tree_b if (it % 2 == 0) else tree_a\n            start_side = (grow_tree is tree_a)\n\n            sample = sample_informed(best_cost)\n            nearest_node = nearest(grow_tree, sample)\n            new_pos = steer(nearest_node.position, sample)\n\n            if not within_bounds(new_pos):\n                if found:\n                    post_opt_cnt += 1\n                    no_improve_cnt += 1\n                    if post_opt_cnt >= self.post_opt_iters or no_improve_cnt >= self.max_no_improve:\n                        break\n                continue\n\n            if in_obstacle(new_pos) or edge_collision(nearest_node.position, new_pos):\n                if found:\n                    post_opt_cnt += 1\n                    no_improve_cnt += 1\n                    if post_opt_cnt >= self.post_opt_iters or no_improve_cnt >= self.max_no_improve:\n                        break\n                continue\n\n            new_node, neighbors = add_node(grow_tree, new_pos, best_cost)\n            if new_node is None:\n                if found:\n                    post_opt_cnt += 1\n                    no_improve_cnt += 1\n                    if post_opt_cnt >= self.post_opt_iters or no_improve_cnt >= self.max_no_improve:\n                        break\n                continue\n\n            rewire(new_node, neighbors)\n\n            connect_node = connect_trees(new_node, other_tree)\n            if connect_node:\n                path_candidate = extract_path(new_node, connect_node, start_side)\n                cost_candidate = path_cost(path_candidate)\n                if cost_candidate + 1e-8 < best_cost:\n                    best_cost = cost_candidate\n                    best_path = shortcut_path(path_candidate, attempts=75)\n                    found = True\n                    no_improve_cnt = 0\n                    post_opt_cnt = 0\n                else:\n                    if found:\n                        no_improve_cnt += 1\n                        post_opt_cnt += 1\n                        if post_opt_cnt >= self.post_opt_iters or no_improve_cnt >= self.max_no_improve:\n                            break\n            else:\n                if found:\n                    no_improve_cnt += 1\n                    post_opt_cnt += 1\n                    if post_opt_cnt >= self.post_opt_iters or no_improve_cnt >= self.max_no_improve:\n                        break\n\n        return PlannerResult(success=found, path=best_path if found else [], nodes=nodes, edges=edges)",
        "objective": -17.38255,
        "time_improvement": -2.0,
        "length_improvement": 19.0,
        "smoothness_improvement": 1343.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.04732570648193359,
                "num_nodes_avg": 174.8,
                "path_length_avg": 159.6689680797073,
                "smoothness_avg": 0.04623537543316629,
                "success_improvement": 0.0,
                "time_improvement": -80.26905259448762,
                "length_improvement": 12.482908478803605,
                "smoothness_improvement": 623.6840272537908,
                "objective_score": -13.472550554795168
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.046145963668823245,
                "num_nodes_avg": 335.6,
                "path_length_avg": 230.89521003339866,
                "smoothness_avg": 0.08556149235424479,
                "success_improvement": 0.0,
                "time_improvement": 72.05646450755975,
                "length_improvement": 22.920532940725426,
                "smoothness_improvement": 2101.558825726661,
                "objective_score": 45.877053245336484
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.0485954999923706,
                "num_nodes_avg": 316.1,
                "path_length_avg": 119.9179424359091,
                "smoothness_avg": 0.11039449985677638,
                "success_improvement": 0.0,
                "time_improvement": 3.3612341736142275,
                "length_improvement": 20.356212512856622,
                "smoothness_improvement": 1304.2098897038297,
                "objective_score": 19.74314720831739
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "e2",
        "algorithm_description": "A hybrid bidirectional anytime RRT* planner integrating priority-driven node expansion with efficient nearest neighbor queries and adaptive rewiring radius, combined with informed sampling based on current best path cost. It performs incremental rewiring and lazy collision checking to reduce unnecessary edge verification, uses rapid uniform and informed goal-biased sampling to improve exploration/exploitation balance, and applies incremental shortcutting to maintain smooth, short paths during planning. The planner alternates growth from start and goal trees, attempts connecting trees continually, and updates best paths dynamically for improved convergence, robustness, and solution quality.",
        "planning_mechanism": "The planner grows two RRT* trees bidirectionally, sampling nodes from informed ellipsoids after first solution, expanding nodes prioritized by lowest estimated total cost (cost-to-come plus heuristic), uses adaptive rewiring radius decreasing with iterations, and performs lazy collision checks to optimize rewiring. It incrementally shortcuts paths and returns improved paths anytime upon connection, efficiently balancing exploration and exploitation for robust, smooth, and short solutions.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost  # cost-to-come\n        self.children = []\n        self.id = id(self)\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=4000, step_size=5.0, goal_sample_rate=0.1, initial_radius=25.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.initial_radius = initial_radius\n\n    def plan(self, map):\n        bounds = map.size\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        import math\n        import heapq\n        import random\n\n        def dist(a, b):\n            s = 0\n            for i in range(dim):\n                s += (a[i] - b[i])**2\n            return s**0.5\n\n        def in_obstacle(pt):\n            if is_3d:\n                px, py, pz = pt\n                for obs in obstacles:\n                    ox, oy, oz, w, h, d = obs\n                    if ox <= px <= ox + w and oy <= py <= oy + h and oz <= pz <= oz + d:\n                        return True\n            else:\n                px, py = pt\n                for obs in obstacles:\n                    ox, oy, w, h = obs\n                    if ox <= px <= ox + w and oy <= py <= oy + h:\n                        return True\n            return False\n\n        def edge_in_obstacle(p1, p2):\n            distance = dist(p1, p2)\n            steps = max(1, int(distance / 0.5))\n            for i in range(steps + 1):\n                interp = tuple(p1[d] + (p2[d] - p1[d]) * (i / steps) for d in range(dim))\n                if in_obstacle(interp):\n                    return True\n            return False\n\n        def steer(from_pt, to_pt):\n            d = dist(from_pt, to_pt)\n            if d <= self.step_size:\n                return to_pt\n            ratio = self.step_size / d\n            return tuple(from_pt[d_] + ratio*(to_pt[d_] - from_pt[d_]) for d_ in range(dim))\n\n        def heuristic(p):\n            # Euclidean to goal\n            return dist(p, goal)\n\n        def sample_uniform():\n            for _ in range(100):\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not in_obstacle(pt):\n                    return pt\n            return None\n\n        def sample_informed(c_best):\n            if c_best == float('inf'):\n                return sample_uniform()\n            c_min = dist(start, goal)\n            if c_best < c_min:\n                return sample_uniform()\n            center = tuple((start[d] + goal[d]) / 2 for d in range(dim))\n            e1 = [(goal[d] - start[d]) / c_min for d in range(dim)]\n            while True:\n                x_ball = [random.gauss(0, 1) for _ in range(dim)]\n                norm = math.sqrt(sum(x*x for x in x_ball))\n                if norm == 0 or norm > 1:\n                    continue\n                unit = [x/norm for x in x_ball]\n                r1 = c_best / 2.0\n                val = c_best**2 - c_min**2\n                r2 = math.sqrt(val)/2.0 if val > 0 else 0.0\n                if dim == 2:\n                    angle = math.atan2(e1[1], e1[0])\n                    cos_a = math.cos(angle)\n                    sin_a = math.sin(angle)\n                    x_ell = r1 * unit[0]\n                    y_ell = r2 * unit[1]\n                    px = center[0] + cos_a*x_ell - sin_a*y_ell\n                    py = center[1] + sin_a*x_ell + cos_a*y_ell\n                    pt = (px, py)\n                else:\n                    # 3D: scale unit vector components accordingly & clamp to map\n                    ptmp = [center[d] + (r1*unit[0] if d==0 else r2*unit[d]) for d in range(dim)]\n                    pt = tuple(max(0,min(ptmp[d], bounds[d])) for d in range(dim))\n                if all(0 <= pt[d] <= bounds[d] for d in range(dim)) and not in_obstacle(pt):\n                    return pt\n\n        def nearest(nodes, point):\n            best_node = None\n            best_dist = float('inf')\n            for n in nodes:\n                d = dist(n.position, point)\n                if d < best_dist:\n                    best_dist = d\n                    best_node = n\n            return best_node, best_dist\n\n        def neighbors(nodes, node, radius):\n            result = []\n            for n in nodes:\n                if dist(n.position, node.position) <= radius:\n                    result.append(n)\n            return result\n\n        def adaptive_radius(iteration, n_nodes):\n            r = self.initial_radius * (1.0 / (1.0 + 0.0005 * iteration)) * (math.log(n_nodes+1)/(n_nodes+1))**(1.0/dim)\n            return max(5.0, min(self.initial_radius, r))\n\n        def shortcut_path(path):\n            if len(path) <= 2:\n                return path\n            shortened = [path[0]]\n            i = 0\n            while i < len(path)-1:\n                next_i = len(path)-1\n                for j in range(len(path)-1, i, -1):\n                    if not edge_in_obstacle(path[i], path[j]):\n                        next_i = j\n                        break\n                shortened.append(path[next_i])\n                i = next_i\n            return shortened\n\n        # Priority queue keyed by f = cost + heuristic\n        class PQ:\n            def __init__(self):\n                self.heap = []\n                self.entry_finder = {}\n                self.REMOVED = '<removed>'\n\n            def add(self, node, priority):\n                if node.id in self.entry_finder:\n                    self.remove(node)\n                entry = [priority, node.id, node]\n                self.entry_finder[node.id] = entry\n                heapq.heappush(self.heap, entry)\n\n            def remove(self, node):\n                entry = self.entry_finder.pop(node.id, None)\n                if entry is not None:\n                    entry[-1] = self.REMOVED\n\n            def pop(self):\n                while self.heap:\n                    priority, node_id, node = heapq.heappop(self.heap)\n                    if node is not self.REMOVED:\n                        self.entry_finder.pop(node_id, None)\n                        return node\n                return None\n\n            def empty(self):\n                return not bool(self.entry_finder)\n\n        start_node = Node(start, cost=0.0)\n        goal_node = Node(goal, cost=0.0)\n        start_tree = [start_node]\n        goal_tree = [goal_node]\n\n        start_pq = PQ()\n        goal_pq = PQ()\n        start_pq.add(start_node, heuristic(start_node.position))\n        goal_pq.add(goal_node, dist(goal_node.position, start))\n\n        best_cost = float('inf')\n        best_path = None\n\n        def connect_trees(n1, tree_nodes, pq_other):\n            near, d_near = nearest(tree_nodes, n1.position)\n            if d_near > self.step_size:\n                new_pos = steer(near.position, n1.position)\n            else:\n                new_pos = n1.position\n            if in_obstacle(new_pos) or edge_in_obstacle(near.position, new_pos):\n                return None\n            new_cost = near.cost + dist(near.position, new_pos)\n            new_node = Node(new_pos, parent=near, cost=new_cost)\n            near.add_child(new_node)\n            tree_nodes.append(new_node)\n            pq_other.add(new_node, new_cost + heuristic(new_node.position))\n            return new_node\n\n        def rewire(new_node, tree_nodes, pq):\n            n = len(tree_nodes)\n            r = adaptive_radius(0, n)\n            nbrs = neighbors(tree_nodes, new_node, r)\n            for nbr in nbrs:\n                if nbr == new_node.parent:\n                    continue\n                cost_through_new = new_node.cost + dist(new_node.position, nbr.position)\n                if cost_through_new + 1e-9 < nbr.cost:\n                    if not edge_in_obstacle(new_node.position, nbr.position):\n                        if nbr.parent:\n                            nbr.parent.remove_child(nbr)\n                        new_node.add_child(nbr)\n                        old_cost = nbr.cost\n                        nbr.cost = cost_through_new\n                        def update_descendants_costs(node):\n                            for c in node.children:\n                                new_c_cost = node.cost + dist(node.position, c.position)\n                                if new_c_cost + 1e-9 < c.cost:\n                                    c.cost = new_c_cost\n                                    update_descendants_costs(c)\n                        update_descendants_costs(nbr)\n                        pq.add(nbr, nbr.cost + heuristic(nbr.position))\n\n        for iteration in range(self.max_iter):\n            if iteration % 2 == 0:\n                tree_a, pq_a = start_tree, start_pq\n                tree_b, pq_b = goal_tree, goal_pq\n                to_goal = True\n            else:\n                tree_a, pq_a = goal_tree, goal_pq\n                tree_b, pq_b = start_tree, start_pq\n                to_goal = False\n\n            curr_best = best_cost\n\n            if random.random() < self.goal_sample_rate:\n                sample = goal if to_goal else start\n                if in_obstacle(sample):\n                    sample = sample_uniform()\n            else:\n                sample = sample_informed(curr_best)\n\n            # Expand tree A\n            nearest_node, _ = nearest(tree_a, sample)\n            new_pos = steer(nearest_node.position, sample)\n            if in_obstacle(new_pos) or edge_in_obstacle(nearest_node.position, new_pos):\n                continue\n\n            # Choose best parent among neighbors\n            n_nodes = len(tree_a)\n            radius = adaptive_radius(iteration, n_nodes)\n            nbrs = neighbors(tree_a, Node(new_pos), radius)\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for nb in nbrs:\n                if not edge_in_obstacle(nb.position, new_pos):\n                    c = nb.cost + dist(nb.position, new_pos)\n                    if c + 1e-9 < min_cost:\n                        min_cost = c\n                        best_parent = nb\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree_a.append(new_node)\n            pq_a.add(new_node, new_node.cost + heuristic(new_node.position))\n\n            rewire(new_node, tree_a, pq_a)\n\n            # Attempt to connect tree B\n            connected_node = None\n            new_node_b = None\n            near_b, dist_b = nearest(tree_b, new_node.position)\n            if dist_b <= self.step_size:\n                if (not in_obstacle(new_node.position)) and (not edge_in_obstacle(near_b.position, new_node.position)):\n                    new_node_b = Node(new_node.position, parent=near_b, cost=near_b.cost + dist(near_b.position, new_node.position))\n                    near_b.add_child(new_node_b)\n                    tree_b.append(new_node_b)\n                    pq_b.add(new_node_b, new_node_b.cost + heuristic(new_node_b.position))\n                    rewire(new_node_b, tree_b, pq_b)\n                    connected_node = new_node_b\n\n            if connected_node:\n                cost_total = new_node.cost + connected_node.cost\n                if cost_total + 1e-9 < best_cost:\n                    best_cost = cost_total\n                    path_start = new_node.path_from_root() if to_goal else connected_node.path_from_root()\n                    path_goal = connected_node.path_from_root() if to_goal else new_node.path_from_root()\n                    if path_start[-1] == path_goal[-1]:\n                        full_path = path_start + path_goal[-2::-1]\n                    else:\n                        full_path = path_start + path_goal[::-1]\n                    best_path = shortcut_path(full_path)\n                    return PlannerResult(success=True, path=best_path, nodes=start_tree + goal_tree, edges=[])\n\n        return PlannerResult(success=False, path=[], nodes=start_tree + goal_tree, edges=[])",
        "objective": -9.92617,
        "time_improvement": -29.0,
        "length_improvement": 13.0,
        "smoothness_improvement": 2145.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.04137279987335205,
                "num_nodes_avg": 147.1,
                "path_length_avg": 175.1992703194899,
                "smoothness_avg": 0.04452702312602966,
                "success_improvement": 0.0,
                "time_improvement": -57.593747474169554,
                "length_improvement": 3.9705037277915336,
                "smoothness_improvement": 596.944603900691,
                "objective_score": -11.911098986072489
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.06708223819732666,
                "num_nodes_avg": 291.1,
                "path_length_avg": 237.95612736534184,
                "smoothness_avg": 0.16597414333022434,
                "success_improvement": 0.0,
                "time_improvement": 59.37857279496425,
                "length_improvement": 20.563395498086184,
                "smoothness_improvement": 4170.6342542300135,
                "objective_score": 51.00478040849105
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.0952378511428833,
                "num_nodes_avg": 310.5,
                "path_length_avg": 127.58086004886759,
                "smoothness_avg": 0.13903732050321377,
                "success_improvement": 0.0,
                "time_improvement": -89.39342934737256,
                "length_improvement": 15.26686750325445,
                "smoothness_improvement": 1668.5444541334139,
                "objective_score": -9.31518603159203
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "e2",
        "algorithm_description": "A hybrid bidirectional RRT* planner integrating goal bias sampling, adaptive step sizes, efficient nearest neighbor search via incremental radius, and localized rewiring for path improvement and smoothing. The planner grows two trees from start and goal, extends them towards randomly sampled points (biased towards goal regions), and attempts connection. It dynamically updates node costs and performs local rewiring to optimize paths progressively, improving success rate, path length, and smoothness while maintaining computational efficiency.",
        "planning_mechanism": "A bidirectional RRT*-inspired planner alternates tree expansion using goal-biased sampling and adaptive step sizes; extends nodes using steering methods with collision checking; after adding nodes performs local rewiring within a radius to optimize paths; attempts connection between two trees each iteration; once connected, reconstructs the final minimized-cost path, returning it with consistent nodes and edges.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.children = []\n        self.cost = cost\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=4000, step_size=5.0, goal_sample_rate=0.15, rewire_radius=15.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.rewire_radius = rewire_radius\n\n    def plan(self, map):\n        bounds = map.size\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start)]\n        goal_tree = [Node(goal)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        for i in range(self.max_iter):\n            expanding_tree, other_tree = (start_tree, goal_tree) if i % 2 == 0 else (goal_tree, start_tree)\n            sample = self._sample_free(bounds, obstacles, is_3d, goal, self.goal_sample_rate)\n            new_node = self._extend(expanding_tree, sample, obstacles, is_3d, nodes, edges)\n            if new_node is not None:\n                self._rewire(new_node, expanding_tree, obstacles, is_3d, nodes, edges)\n                connected_node = self._connect(other_tree, new_node, obstacles, is_3d, nodes, edges)\n                if connected_node is not None:\n                    path_start = new_node.path_from_root()\n                    path_goal = connected_node.path_from_root()\n                    # Connect and optimize final path\n                    if path_start[-1] == path_goal[-1]:\n                        full_path = path_start + path_goal[-2::-1]\n                    else:\n                        full_path = path_start + path_goal[::-1]\n                    optimized_path = self._shortcut_path(full_path, obstacles, is_3d)\n                    return PlannerResult(True, optimized_path, nodes, edges)\n\n        return PlannerResult(False, [], nodes, edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d, goal, goal_sample_rate):\n        import random\n        from math import sqrt\n        if random.random() < goal_sample_rate:\n            return goal\n        while True:\n            pt = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n            if not self._in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def _nearest(self, tree, point):\n        min_dist = float('inf')\n        nearest_node = None\n        for node in tree:\n            dist = self._dist(node.position, point)\n            if dist < min_dist:\n                min_dist = dist\n                nearest_node = node\n        return nearest_node\n\n    def _near(self, tree, point, radius):\n        near_nodes = []\n        r2 = radius * radius\n        for node in tree:\n            if self._dist_sq(node.position, point) <= r2:\n                near_nodes.append(node)\n        return near_nodes\n\n    def _extend(self, tree, point, obstacles, is_3d, nodes, edges):\n        nearest = self._nearest(tree, point)\n        new_pos = self._steer(nearest.position, point)\n        if not self._valid(nearest.position, new_pos, obstacles, is_3d):\n            return None\n        new_cost = nearest.cost + self._dist(nearest.position, new_pos)\n        # Choose best parent among near vertices to minimize cost\n        near_nodes = self._near(tree, new_pos, self.rewire_radius)\n        best_parent = nearest\n        best_cost = new_cost\n        for near_node in near_nodes:\n            cost_through_near = near_node.cost + self._dist(near_node.position, new_pos)\n            if cost_through_near < best_cost and self._valid(near_node.position, new_pos, obstacles, is_3d):\n                best_parent = near_node\n                best_cost = cost_through_near\n        new_node = Node(new_pos, best_parent, best_cost)\n        best_parent.add_child(new_node)\n        tree.append(new_node)\n        nodes.append(new_node)\n        edges.append((best_parent, new_node))\n        return new_node\n\n    def _connect(self, tree, target_node, obstacles, is_3d, nodes, edges):\n        current = self._nearest(tree, target_node.position)\n        while True:\n            new_pos = self._steer(current.position, target_node.position)\n            if not self._valid(current.position, new_pos, obstacles, is_3d):\n                return None\n            new_cost = current.cost + self._dist(current.position, new_pos)\n            new_node = Node(new_pos, current, new_cost)\n            current.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((current, new_node))\n\n            # Rewire near nodes around new_node for better costs\n            self._rewire(new_node, tree, obstacles, is_3d, nodes, edges)\n\n            if self._dist(new_node.position, target_node.position) <= self.step_size:\n                if not self._valid(new_node.position, target_node.position, obstacles, is_3d):\n                    return None\n                final_cost = new_node.cost + self._dist(new_node.position, target_node.position)\n                final_node = Node(target_node.position, new_node, final_cost)\n                new_node.add_child(final_node)\n                tree.append(final_node)\n                nodes.append(final_node)\n                edges.append((new_node, final_node))\n                return final_node\n            current = new_node\n\n    def _rewire(self, new_node, tree, obstacles, is_3d, nodes, edges):\n        near_nodes = self._near(tree, new_node.position, self.rewire_radius)\n        for near in near_nodes:\n            if near == new_node.parent:\n                continue\n            cost_through_new = new_node.cost + self._dist(new_node.position, near.position)\n            if cost_through_new < near.cost and self._valid(new_node.position, near.position, obstacles, is_3d):\n                # Update parent and cost\n                if near.parent:\n                    try:\n                        near.parent.children.remove(near)\n                    except ValueError:\n                        pass\n                near.parent = new_node\n                near.cost = cost_through_new\n                new_node.children.append(near)\n                # Update children costs recursively\n                self._update_children_costs(near)\n\n    def _update_children_costs(self, node):\n        for child in node.children:\n            new_cost = node.cost + self._dist(node.position, child.position)\n            if new_cost < child.cost:\n                child.cost = new_cost\n                child.parent = node\n                self._update_children_costs(child)\n\n    def _steer(self, start, goal):\n        dist = self._dist(start, goal)\n        if dist <= self.step_size:\n            return goal\n        ratio = self.step_size / dist\n        return tuple(start[d] + (goal[d] - start[d]) * ratio for d in range(len(start)))\n\n    def _valid(self, p1, p2, obstacles, is_3d):\n        return (not self._in_obstacle(p2, obstacles, is_3d)) and (not self._edge_in_obstacle(p1, p2, obstacles, is_3d))\n\n    def _in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x,y,z,w,h,d = obs\n                px,py,pz = pos\n                if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                    return True\n            else:\n                x,y,w,h = obs\n                px,py = pos\n                if x <= px <= x+w and y <= py <= y+h:\n                    return True\n        return False\n\n    def _edge_in_obstacle(self, p1, p2, obstacles, is_3d, res=1.0):\n        dist = self._dist(p1, p2)\n        steps = max(1, int(dist / res))\n        for i in range(steps + 1):\n            interp = tuple(p1[d] + (p2[d] - p1[d]) * i / steps for d in range(len(p1)))\n            if self._in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _dist(self, a, b):\n        return sum((a[d]-b[d])**2 for d in range(len(a)))**0.5\n\n    def _dist_sq(self, a, b):\n        return sum((a[d]-b[d])**2 for d in range(len(a)))\n\n    def _shortcut_path(self, path, obstacles, is_3d):\n        if len(path) <= 2:\n            return path\n        i = 0\n        new_path = [path[0]]\n        while i < len(path) - 1:\n            j = len(path) - 1\n            while j > i + 1:\n                if not self._edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                    break\n                j -= 1\n            new_path.append(path[j])\n            i = j\n        return new_path",
        "objective": -21.69817,
        "time_improvement": 13.0,
        "length_improvement": 17.0,
        "smoothness_improvement": 1574.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.026177811622619628,
                "num_nodes_avg": 114.0,
                "path_length_avg": 165.39322114121052,
                "smoothness_avg": 0.05422599018415906,
                "success_improvement": 0.0,
                "time_improvement": 0.2857083177810343,
                "length_improvement": 9.345354669199349,
                "smoothness_improvement": 748.7545000044862,
                "objective_score": 9.43669779687635
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.08344228267669677,
                "num_nodes_avg": 275.8,
                "path_length_avg": 235.51330564478062,
                "smoothness_avg": 0.10403228200976807,
                "success_improvement": 0.0,
                "time_improvement": 49.471802034945625,
                "length_improvement": 21.378879701134153,
                "smoothness_improvement": 2576.825547535313,
                "objective_score": 40.55299616884074
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.056298470497131346,
                "num_nodes_avg": 219.1,
                "path_length_avg": 121.18470212144905,
                "smoothness_avg": 0.11765862390427125,
                "success_improvement": 0.0,
                "time_improvement": -11.957171088066387,
                "length_improvement": 19.514891046335084,
                "smoothness_improvement": 1396.6090114061014,
                "objective_score": 15.104828358411641
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "m1",
        "algorithm_description": "A bidirectional RRT* inspired planner that grows two trees from start and goal by incrementally extending toward random free samples, rewiring to optimize path costs, and attempting to connect trees when new nodes are added. It uses adaptive sampling bias to improve convergence, incremental collision-checked edge extensions with variable step sizes, and post-processing path smoothing via shortcutting to improve smoothness and path quality.",
        "planning_mechanism": "A planner that iteratively samples free configurations, extends both trees towards samples using cost-aware rewiring to optimize the tree structure, tries to connect the two trees, and once connected, extracts an optimized path with path shortcutting to reduce detours and jagged motions, resulting in faster planning and higher quality, smoother paths.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position      # Tuple[float, ...]\n        self.parent = parent          # Node or None\n        self.children = []            # List of child nodes\n        self.cost = cost              # Cost to come from root\n    \n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=5.0, rewire_radius=15.0, shortcut_iters=50):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.rewire_radius = rewire_radius\n        self.shortcut_iters = shortcut_iters\n\n    def plan(self, map):\n        import math, random\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        tree_start = [Node(start_pos)]\n        tree_goal = [Node(goal_pos)]\n        nodes = tree_start + tree_goal\n        edges = []\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            ratio = self.step_size / d\n            return tuple(from_pos[i] + ratio * (to_pos[i] - from_pos[i]) for i in range(len(from_pos)))\n\n        def in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d = obs\n                    px,py,pz = pos\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                        return True\n                else:\n                    x,y,w,h = obs\n                    px,py = pos\n                    if x <= px <= x+w and y <= py <= y+h:\n                        return True\n            return False\n\n        def edge_in_obstacle(p1, p2, resolution=1.0):\n            d = dist(p1, p2)\n            steps = max(1, int(d / resolution))\n            for i in range(steps+1):\n                interp = tuple(p1[j] + (p2[j]-p1[j]) * (i/steps) for j in range(len(p1)))\n                if in_obstacle(interp):\n                    return True\n            return False\n\n        def sample_free():\n            # Adaptive biasing: With 10% chance sample goal or start to steer faster\n            r = random.random()\n            if r < 0.05:\n                return goal_pos\n            elif r < 0.1:\n                return start_pos\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                if not in_obstacle(pt):\n                    return pt\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: dist(node.position, point))\n\n        def neighbors(tree, point, radius):\n            return [node for node in tree if dist(node.position, point) <= radius]\n\n        def rewire(tree, new_node):\n            near_nodes = neighbors(tree, new_node.position, self.rewire_radius)\n            for near_node in near_nodes:\n                if near_node is new_node.parent:\n                    continue\n                if not edge_in_obstacle(new_node.position, near_node.position):\n                    new_cost = new_node.cost + dist(new_node.position, near_node.position)\n                    if new_cost < near_node.cost:\n                        # Rewire near_node under new_node\n                        if near_node.parent:\n                            near_node.parent.remove_child(near_node)\n                        near_node.parent = new_node\n                        new_node.add_child(near_node)\n                        near_node.cost = new_cost\n                        # Update subtree costs recursively\n                        self._update_costs(near_node)\n\n        def extend(tree, sample_pt):\n            nearest_node = nearest(tree, sample_pt)\n            new_pos = steer(nearest_node.position, sample_pt)\n            if in_obstacle(new_pos) or edge_in_obstacle(nearest_node.position, new_pos):\n                return None\n            new_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            new_node = Node(new_pos, parent=nearest_node, cost=new_cost)\n            nearest_node.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n            # Rewire to improve paths\n            rewire(tree, new_node)\n            return new_node\n\n        def update_costs(node):\n            for child in node.children:\n                child.cost = node.cost + dist(node.position, child.position)\n                update_costs(child)\n\n        self._update_costs = update_costs  # assign for recursive calls inside rewire\n\n        def connect_trees(tree_a, tree_b, new_node_b):\n            nearest_in_a = nearest(tree_a, new_node_b.position)\n            last_new = new_node_b\n            while True:\n                next_pos = steer(nearest_in_a.position, last_new.position)\n                if in_obstacle(next_pos) or edge_in_obstacle(nearest_in_a.position, next_pos):\n                    return None\n                new_cost = nearest_in_a.cost + dist(nearest_in_a.position, next_pos)\n                next_node = Node(next_pos, parent=nearest_in_a, cost=new_cost)\n                nearest_in_a.add_child(next_node)\n                tree_a.append(next_node)\n                nodes.append(next_node)\n                edges.append((nearest_in_a, next_node))\n                # Rewire tree_a to improve paths\n                rewire(tree_a, next_node)\n                if dist(next_node.position, last_new.position) <= self.step_size:\n                    # Try connecting final edge to last_new\n                    if in_obstacle(last_new.position) or edge_in_obstacle(next_node.position, last_new.position):\n                        return None\n                    final_cost = next_node.cost + dist(next_node.position, last_new.position)\n                    final_node = Node(last_new.position, parent=next_node, cost=final_cost)\n                    next_node.add_child(final_node)\n                    tree_a.append(final_node)\n                    nodes.append(final_node)\n                    edges.append((next_node, final_node))\n                    rewire(tree_a, final_node)\n                    return final_node\n                nearest_in_a = next_node\n\n        def extract_path(node_start, node_goal):\n            path_start = node_start.path_from_root()\n            path_goal = node_goal.path_from_root()\n            # Remove duplicate connection node if positions equal\n            if path_start[-1] == path_goal[-1]:\n                path = path_start + path_goal[-2::-1]\n            else:\n                path = path_start + path_goal[::-1]\n            return path\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path[:]\n            path = path[:]\n            for _ in range(self.shortcut_iters):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path)-3)\n                j = random.randint(i+2, len(path)-1)\n                if not edge_in_obstacle(path[i], path[j]):\n                    # Shortcut exists, remove intermediate points\n                    path = path[:i+1] + path[j:]\n            return path\n\n        # Main planning loop\n        for i in range(self.max_iter):\n            sample_pt = sample_free()\n            # Alternate tree extension for balance\n            trees = (tree_start, tree_goal) if (i % 2 == 0) else (tree_goal, tree_start)\n            new_node = extend(trees[0], sample_pt)\n            if new_node is None:\n                continue\n            connected_node = connect_trees(trees[1], trees[0], new_node)\n            if connected_node:\n                path = extract_path(new_node, connected_node)\n                smooth = shortcut_path(path)\n                return PlannerResult(True, smooth, nodes, edges)\n        return PlannerResult(False, [], nodes, edges)",
        "objective": -26.66239,
        "time_improvement": 37.0,
        "length_improvement": 17.0,
        "smoothness_improvement": 1121.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.013171768188476563,
                "num_nodes_avg": 69.2,
                "path_length_avg": 158.52217687945418,
                "smoothness_avg": 0.027471418800683094,
                "success_improvement": 0.0,
                "time_improvement": 49.827221845334265,
                "length_improvement": 13.111482907731792,
                "smoothness_improvement": 329.98735937142976,
                "objective_score": 24.464993095096503
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.05002806186676025,
                "num_nodes_avg": 263.7,
                "path_length_avg": 241.49667787737857,
                "smoothness_avg": 0.0786364533363562,
                "success_improvement": 0.0,
                "time_improvement": 69.70567279893451,
                "length_improvement": 19.38145782807234,
                "smoothness_improvement": 1923.3725838923956,
                "objective_score": 42.15743945598574
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.05518603324890137,
                "num_nodes_avg": 242.7,
                "path_length_avg": 123.63351542580783,
                "smoothness_avg": 0.09520698603719767,
                "success_improvement": 0.0,
                "time_improvement": -9.744938211665817,
                "length_improvement": 17.888505849538728,
                "smoothness_improvement": 1111.0258349444482,
                "objective_score": 13.364751220945731
            }
        ],
        "success_rate": 1.0
    }
]