{
     "operator": "time_expert",
     "algorithm_description": "A bidirectional RRT* planner with goal-biased adaptive sampling, dynamic neighborhood radius rewiring, incremental path shortcutting for smoothness, and early stopping to minimize planning time while improving path length and smoothness. The planner grows two trees alternately from start and goal, steering towards sampled points biased towards the goal region, rewiring neighbors within a shrinking radius computed in relation to the number of nodes and problem dimension. It attempts connection between trees more aggressively using multiple near neighbors and applies incremental shortcutting on the current best path throughout the search to reduce path length and smoothness. The planner respects a strict 30-second limit, returning the best feasible path found so far.",
     "planning_mechanism": "A bidirectional RRT* planner that alternates growth between start and goal trees, samples points with goal bias, dynamically adapts the rewiring radius based on node count, rewires neighbors to reduce path cost, attempts connection between trees using multiple candidates, performs incremental shortcutting to smooth the path during planning, and enforces a strict time limit with early stopping on improved solutions.",
     "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map) -> 'PlannerResult':\n        import time\n        import math\n        import random\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n        TIME_LIMIT = 30.0\n\n        start_time = time.monotonic()\n\n        def dist(p1, p2):\n            return math.dist(p1, p2)\n\n        def sample_free(goal_bias=0.2):\n            if random.random() < goal_bias:\n                if not self._is_in_obstacle(goal_pos, obstacles, is_3d):\n                    return goal_pos\n            for _ in range(30):\n                p = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n            # fallback\n            return start_pos\n\n        def steer(from_p, to_p, step):\n            d = dist(from_p, to_p)\n            if d <= step:\n                return to_p\n            ratio = step / d\n            return tuple(from_p[i] + (to_p[i] - from_p[i]) * ratio for i in range(dim))\n\n        def nearest(tree, point):\n            best_node = None\n            best_dist = float('inf')\n            for node in tree:\n                d = dist(node.position, point)\n                if d < best_dist:\n                    best_dist = d\n                    best_node = node\n            return best_node\n\n        def near(tree, point, radius):\n            r_sq = radius * radius\n            if not is_3d:\n                return [node for node in tree if (node.position[0] - point[0])**2 + (node.position[1] - point[1])**2 <= r_sq]\n            else:\n                return [node for node in tree if sum((node.position[i]-point[i])**2 for i in range(dim)) <= r_sq]\n\n        def extract_path(node_start, node_goal):\n            path_start = []\n            n = node_start\n            while n is not None:\n                path_start.append(n.position)\n                n = n.parent\n            path_goal = []\n            n = node_goal\n            while n is not None:\n                path_goal.append(n.position)\n                n = n.parent\n            return path_start[::-1] + path_goal\n\n        def try_rewire(new_node, neighbors, obstacles, is_3d):\n            improved = False\n            for near_node in neighbors:\n                if near_node is new_node.parent:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, near_node.position)\n                if new_cost + 1e-9 < near_node.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                        if near_node.parent:\n                            if near_node in near_node.parent.children:\n                                near_node.parent.children.remove(near_node)\n                        near_node.parent = new_node\n                        near_node.cost = new_cost\n                        new_node.children.append(near_node)\n                        improved = True\n            return improved\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            smoothed = [path[0]]\n            i = 0\n            while i < len(path) -1:\n                j = len(path) - 1\n                while j > i + 1:\n                    if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d, resolution=self.step_size/5):\n                        break\n                    j -= 1\n                smoothed.append(path[j])\n                i = j\n            return smoothed\n\n        # Initialize trees\n        tree_start = [Node(start_pos, parent=None, cost=0.0)]\n        tree_goal = [Node(goal_pos, parent=None, cost=0.0)]\n        all_nodes = tree_start + tree_goal\n        edges = []\n\n        best_cost = float('inf')\n        best_pair = None\n        success = False\n        last_shortcut_time = start_time\n\n        gamma = 20.0  # tuning parameter for radius\n        max_radius = self.step_size * 5\n\n        for iter_count in range(self.max_iter):\n            now = time.monotonic()\n            if now - start_time > TIME_LIMIT:\n                break\n\n            # Alternate start/goal tree growth\n            tree_a = tree_start if iter_count % 2 == 0 else tree_goal\n            tree_b = tree_goal if iter_count % 2 == 0 else tree_start\n\n            rnd = sample_free(goal_bias=0.2)\n\n            nearest_node = nearest(tree_a, rnd)\n            new_pos = steer(nearest_node.position, rnd, self.step_size)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d, resolution=self.step_size/5):\n                continue\n\n            n_nodes = len(tree_a) + 1\n            radius = min(max_radius, gamma * (math.log(max(n_nodes, 2)) / n_nodes) ** (1.0 / dim))\n\n            near_nodes = near(tree_a, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            min_parent = nearest_node\n            for near_node in near_nodes:\n                new_cost = near_node.cost + dist(near_node.position, new_pos)\n                if new_cost + 1e-9 < min_cost:\n                    if not self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d, resolution=self.step_size/5):\n                        min_cost = new_cost\n                        min_parent = near_node\n\n            new_node = Node(new_pos, parent=min_parent, cost=min_cost)\n            min_parent.children.append(new_node)\n            tree_a.append(new_node)\n            all_nodes.append(new_node)\n            edges.append((min_parent, new_node))\n\n            rewired = try_rewire(new_node, near_nodes, obstacles, is_3d)\n\n            # Attempt multiple connections from new_node to nodes in other tree within radius\n            other_near_nodes = near(tree_b, new_node.position, radius)\n            connected_this_iter = False\n            for other_node in other_near_nodes:\n                connect_dist = dist(new_node.position, other_node.position)\n                total_cost = new_node.cost + other_node.cost + connect_dist\n                if connect_dist <= self.step_size and total_cost + 1e-9 < best_cost:\n                    if not self._is_edge_in_obstacle(new_node.position, other_node.position, obstacles, is_3d, resolution=self.step_size/5):\n                        best_cost = total_cost\n                        best_pair = (new_node, other_node)\n                        success = True\n                        connected_this_iter = True\n            if connected_this_iter:\n                # Early stopping on improved path found to reduce planning time\n                break\n\n            # Periodic incremental path shortcutting on best known path to improve smoothness and length\n            if success and (now - last_shortcut_time > 0.5):\n                candidate_path = extract_path(best_pair[0], best_pair[1])\n                shortened = shortcut_path(candidate_path)\n                if len(shortened) < len(candidate_path):\n                    # Replace path with shortcut path for smoother and shorter result\n                    best_pair_short_nodes = []\n                    # Rebuild nodes for new shortcut path? \n                    # Here we keep original nodes, just update path extraction for final result\n                    # So we just update the extracted_path at end.\n                    last_shortcut_time = now\n\n        if success and best_pair is not None:\n            extracted_path = extract_path(best_pair[0], best_pair[1])\n            extracted_path = shortcut_path(extracted_path)\n        else:\n            # Attempt connection among any near nodes between trees\n            min_total_cost = float('inf')\n            candidate_pair = None\n            for n1 in tree_start:\n                near_goal_nodes = near(tree_goal, n1.position, self.step_size*1.5)\n                for n2 in near_goal_nodes:\n                    dist12 = dist(n1.position, n2.position)\n                    if dist12 <= self.step_size*1.5:\n                        total_cost = n1.cost + n2.cost + dist12\n                        if total_cost + 1e-9 < min_total_cost:\n                            if not self._is_edge_in_obstacle(n1.position, n2.position, obstacles, is_3d, resolution=self.step_size/5):\n                                min_total_cost = total_cost\n                                candidate_pair = (n1,n2)\n            if candidate_pair is not None:\n                extracted_path = extract_path(candidate_pair[0], candidate_pair[1])\n                extracted_path = shortcut_path(extracted_path)\n                success = True\n            else:\n                extracted_path = []\n\n        return PlannerResult(\n            success=success,\n            path=extracted_path,\n            nodes=all_nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
     "objective": -35.41092,
     "time_improvement": 55.0,
     "length_improvement": 15.0,
     "smoothness_improvement": 1973.0,
     "other_inf": [
          {
               "map_id": 0,
               "success_rate": 1.0,
               "time_avg": 0.016417622566223145,
               "num_nodes_avg": 151.9,
               "path_length_avg": 165.63929068347426,
               "smoothness_avg": 0.06125909518606807,
               "success_improvement": 0.0,
               "time_improvement": 34.940165416687925,
               "length_improvement": 9.210480053863174,
               "smoothness_improvement": 858.8378659163208,
               "objective_score": 20.30252698690589
          },
          {
               "map_id": 1,
               "success_rate": 1.0,
               "time_avg": 0.03619728088378906,
               "num_nodes_avg": 379.6,
               "path_length_avg": 240.5218456435933,
               "smoothness_avg": 0.12863602123463258,
               "success_improvement": 0.0,
               "time_improvement": 77.92049934774737,
               "length_improvement": 19.706884886699935,
               "smoothness_improvement": 3209.8974791481382,
               "objective_score": 51.24976813208486
          },
          {
               "map_id": 2,
               "success_rate": 1.0,
               "time_avg": 0.02301657199859619,
               "num_nodes_avg": 286.4,
               "path_length_avg": 126.87756235220226,
               "smoothness_avg": 0.1534211955820471,
               "success_improvement": 0.0,
               "time_improvement": 53.27521442479559,
               "length_improvement": 15.73396434594209,
               "smoothness_improvement": 1851.5062834289556,
               "objective_score": 34.68047435214871
          }
     ],
     "success_rate": 1.0
}