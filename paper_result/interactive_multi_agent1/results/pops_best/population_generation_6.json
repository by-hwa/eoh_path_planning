{
     "operator": "cross_over",
     "algorithm_description": "This algorithm implements a bidirectional, goal-biased RRT* planner with adaptive neighborhood radius rewiring, multi-candidate bidirectional connection attempts, and incremental path shortcutting applied during planning and after completion. It enforces a strict 30-second time limit and dynamically adjusts rewiring radius based on tree size and dimension to balance exploration and refinement efficiency. The planner samples with goal bias for faster convergence, alternates expanding start and goal trees, and progressively shortcuts the best found path to minimize length and improve smoothness. Early stopping occurs upon finding a better path.",
     "planning_mechanism": "The planner grows two trees alternately from start and goal positions, samples random points with a goal bias, and extends the nearest node towards samples with a fixed step size while respecting collision constraints. It rewires nearby nodes within an adaptively shrinking radius to optimize path costs. Multiple candidates from the opposite tree are tested for connection on each new node added, enabling early termination when better paths are found. Progressive shortcutting improves path smoothness and length during planning as well as post-planning. The search halts immediately if the 30-second limit is exceeded, returning the best path found so far.",
     "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n    def add_child(self, child):\n        self.children.append(child)\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\nclass Planner:\n    def __init__(self, max_iter: int=5000, step_size: float=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.time_limit = 30.0\n        self.goal_sample_rate = 0.15  # probability to sample goal\n\n    def plan(self, map) -> 'PlannerResult':\n        import time\n        import math\n        import random\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        # Tree nodes and edges\n        start_tree = [Node(start_pos, cost=0.0)]\n        goal_tree = [Node(goal_pos, cost=0.0)]\n        nodes = start_tree[:] + goal_tree[:]\n        edges = []\n\n        best_connection = None\n        best_cost = float('inf')\n        success = False\n        extracted_path = []\n\n        step = self.step_size\n        gamma = 35.0  # radius multiplier for rewiring (RRT* theory)\n\n        start_time = time.monotonic()\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def sample_free():\n            # goal bias sampling\n            if random.random() < self.goal_sample_rate:\n                return goal_pos\n            for _ in range(100):\n                p = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n            return goal_pos  # fallback\n\n        def nearest(tree, point):\n            best_node = None\n            best_d = float('inf')\n            for node in tree:\n                d = dist(node.position, point)\n                if d < best_d:\n                    best_node = node\n                    best_d = d\n            return best_node\n\n        def near(tree, point, radius):\n            neighbors = [(dist(n.position, point), n) for n in tree if dist(n.position, point) <= radius]\n            neighbors.sort(key=lambda x: x[0])\n            return [n[1] for n in neighbors]\n\n        def steer(from_p, to_p, max_step):\n            d = dist(from_p, to_p)\n            if d <= max_step:\n                return to_p\n            ratio = max_step / d\n            return tuple(from_p[i] + (to_p[i] - from_p[i]) * ratio for i in range(dim))\n\n        def extract_path(node_start, node_goal):\n            path_start = []\n            cur = node_start\n            while cur:\n                path_start.append(cur.position)\n                cur = cur.parent\n            path_start.reverse()\n            path_goal = []\n            cur = node_goal\n            while cur:\n                path_goal.append(cur.position)\n                cur = cur.parent\n            if path_goal and path_start and path_start[-1] == path_goal[0]:\n                path_goal = path_goal[1:]\n            return path_start + path_goal\n\n        def shortcut_path(path, max_attempts=50):\n            if len(path) < 3:\n                return path\n            for _ in range(max_attempts):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution=max(step*0.2, 0.2)):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        def try_connect(new_node, other_tree):\n            radius = step*2.5\n            candidates = near(other_tree, new_node.position, radius)\n            best_cand = None\n            best_local_cost = float('inf')\n            for node in candidates:\n                d12 = dist(new_node.position, node.position)\n                if d12 <= radius and not self._is_edge_in_obstacle(new_node.position, node.position, obstacles, is_3d, resolution=max(step*0.2, 0.2)):\n                    c = new_node.cost + d12 + node.cost\n                    if c < best_local_cost:\n                        best_local_cost = c\n                        best_cand = node\n            return best_cand, best_local_cost\n\n        def rewire(tree, new_node, neighbors):\n            for nbr in neighbors:\n                if nbr is new_node.parent:\n                    continue\n                cost_through = new_node.cost + dist(new_node.position, nbr.position)\n                if cost_through + 1e-9 < nbr.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, nbr.position, obstacles, is_3d, resolution=max(step*0.2, 0.2)):\n                        if nbr.parent:\n                            try:\n                                edges.remove((nbr.parent, nbr))\n                            except Exception:\n                                pass\n                            nbr.parent.remove_child(nbr)\n                        nbr.parent = new_node\n                        nbr.cost = cost_through\n                        new_node.add_child(nbr)\n                        edges.append((new_node, nbr))\n\n        iter_since_last_shortcut = 0\n        shortcut_interval = 75\n\n        for it in range(self.max_iter):\n            if time.monotonic() - start_time > self.time_limit:\n                break\n\n            tree_a = start_tree if (it % 2 == 0) else goal_tree\n            tree_b = goal_tree if (it % 2 == 0) else start_tree\n\n            sample = sample_free()\n            nearest_node = nearest(tree_a, sample)\n            new_pos = steer(nearest_node.position, sample, step)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d, resolution=max(step*0.2, 0.2)):\n                continue\n\n            n_nodes = len(tree_a) + 1\n            radius = gamma * ((math.log(n_nodes)/n_nodes) ** (1/dim)) if n_nodes > 1 else step*5\n            radius = min(radius, step*5)\n            if radius < step:\n                radius = step\n\n            neighbors = near(tree_a, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            min_parent = nearest_node\n            for nb in neighbors:\n                cost_cand = nb.cost + dist(nb.position, new_pos)\n                if cost_cand + 1e-9 < min_cost:\n                    if not self._is_edge_in_obstacle(nb.position, new_pos, obstacles, is_3d, resolution=max(step*0.2, 0.2)):\n                        min_cost = cost_cand\n                        min_parent = nb\n\n            new_node = Node(new_pos, parent=min_parent, cost=min_cost)\n            min_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((min_parent, new_node))\n\n            rewire(tree_a, new_node, neighbors)\n\n            conn_node, conn_cost = try_connect(new_node, tree_b)\n            if conn_node is not None and conn_cost + 1e-9 < best_cost:\n                best_cost = conn_cost\n                # Maintain start_tree node first in best_connection\n                best_connection = (new_node, conn_node) if it % 2 == 0 else (conn_node, new_node)\n                success = True\n                # Early termination on improved path\n                break\n\n            iter_since_last_shortcut += 1\n            if iter_since_last_shortcut >= shortcut_interval and success:\n                path_cur = extract_path(best_connection[0], best_connection[1])\n                path_short = shortcut_path(path_cur, max_attempts=25)\n                if len(path_short) < len(path_cur):\n                    extracted_path = path_short\n                    iter_since_last_shortcut = 0\n\n        if success and best_connection is not None:\n            extracted_path = extract_path(best_connection[0], best_connection[1])\n            extracted_path = shortcut_path(extracted_path, max_attempts=75)\n        elif not success:\n            # Try partial best connection if no success\n            best_partial_cost = float('inf')\n            best_pair = None\n            search_radius = step * 3.0\n            for n1 in start_tree:\n                candidates = near(goal_tree, n1.position, search_radius)\n                for n2 in candidates:\n                    d12 = dist(n1.position, n2.position)\n                    if d12 <= search_radius:\n                        if not self._is_edge_in_obstacle(n1.position, n2.position, obstacles, is_3d, resolution=max(step*0.2, 0.2)):\n                            cost_sum = n1.cost + n2.cost + d12\n                            if cost_sum + 1e-9 < best_partial_cost:\n                                best_partial_cost = cost_sum\n                                best_pair = (n1, n2)\n            if best_pair:\n                success = True\n                extracted_path = extract_path(best_pair[0], best_pair[1])\n                extracted_path = shortcut_path(extracted_path, max_attempts=75)\n\n        return PlannerResult(\n            success=success,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
     "objective": -40.41506,
     "time_improvement": 74.0,
     "length_improvement": 17.0,
     "smoothness_improvement": 1612.0,
     "other_inf": [
          {
               "map_id": 0,
               "success_rate": 1.0,
               "time_avg": 0.010355472564697266,
               "num_nodes_avg": 88.3,
               "path_length_avg": 158.02445292325712,
               "smoothness_avg": 0.04068830742889877,
               "success_improvement": 0.0,
               "time_improvement": 58.963282937365015,
               "length_improvement": 13.384293295064195,
               "smoothness_improvement": 536.8603673360356,
               "objective_score": 28.403862694928197
          },
          {
               "map_id": 1,
               "success_rate": 1.0,
               "time_avg": 0.025506019592285156,
               "num_nodes_avg": 305.8,
               "path_length_avg": 239.66358035944714,
               "smoothness_avg": 0.11914932396717788,
               "success_improvement": 0.0,
               "time_improvement": 84.44192042954145,
               "length_improvement": 19.993398542344394,
               "smoothness_improvement": 2965.7979254646784,
               "objective_score": 52.15760488159246
          },
          {
               "map_id": 2,
               "success_rate": 1.0,
               "time_avg": 0.010851669311523437,
               "num_nodes_avg": 173.2,
               "path_length_avg": 123.90215675117983,
               "smoothness_avg": 0.11268141879062014,
               "success_improvement": 0.0,
               "time_improvement": 77.97057173653472,
               "length_improvement": 17.710087072551893,
               "smoothness_improvement": 1333.2993297395258,
               "objective_score": 40.683720413189185
          }
     ],
     "success_rate": 1.0
}