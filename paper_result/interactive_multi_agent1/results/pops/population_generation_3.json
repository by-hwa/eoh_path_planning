[
     {
          "operator": "time_expert",
          "algorithm_description": "A bidirectional RRT* planner with goal-biased adaptive sampling, dynamic neighborhood radius rewiring, incremental path shortcutting for smoothness, and early stopping to minimize planning time while improving path length and smoothness. The planner grows two trees alternately from start and goal, steering towards sampled points biased towards the goal region, rewiring neighbors within a shrinking radius computed in relation to the number of nodes and problem dimension. It attempts connection between trees more aggressively using multiple near neighbors and applies incremental shortcutting on the current best path throughout the search to reduce path length and smoothness. The planner respects a strict 30-second limit, returning the best feasible path found so far.",
          "planning_mechanism": "A bidirectional RRT* planner that alternates growth between start and goal trees, samples points with goal bias, dynamically adapts the rewiring radius based on node count, rewires neighbors to reduce path cost, attempts connection between trees using multiple candidates, performs incremental shortcutting to smooth the path during planning, and enforces a strict time limit with early stopping on improved solutions.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map) -> 'PlannerResult':\n        import time\n        import math\n        import random\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n        TIME_LIMIT = 30.0\n\n        start_time = time.monotonic()\n\n        def dist(p1, p2):\n            return math.dist(p1, p2)\n\n        def sample_free(goal_bias=0.2):\n            if random.random() < goal_bias:\n                if not self._is_in_obstacle(goal_pos, obstacles, is_3d):\n                    return goal_pos\n            for _ in range(30):\n                p = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n            # fallback\n            return start_pos\n\n        def steer(from_p, to_p, step):\n            d = dist(from_p, to_p)\n            if d <= step:\n                return to_p\n            ratio = step / d\n            return tuple(from_p[i] + (to_p[i] - from_p[i]) * ratio for i in range(dim))\n\n        def nearest(tree, point):\n            best_node = None\n            best_dist = float('inf')\n            for node in tree:\n                d = dist(node.position, point)\n                if d < best_dist:\n                    best_dist = d\n                    best_node = node\n            return best_node\n\n        def near(tree, point, radius):\n            r_sq = radius * radius\n            if not is_3d:\n                return [node for node in tree if (node.position[0] - point[0])**2 + (node.position[1] - point[1])**2 <= r_sq]\n            else:\n                return [node for node in tree if sum((node.position[i]-point[i])**2 for i in range(dim)) <= r_sq]\n\n        def extract_path(node_start, node_goal):\n            path_start = []\n            n = node_start\n            while n is not None:\n                path_start.append(n.position)\n                n = n.parent\n            path_goal = []\n            n = node_goal\n            while n is not None:\n                path_goal.append(n.position)\n                n = n.parent\n            return path_start[::-1] + path_goal\n\n        def try_rewire(new_node, neighbors, obstacles, is_3d):\n            improved = False\n            for near_node in neighbors:\n                if near_node is new_node.parent:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, near_node.position)\n                if new_cost + 1e-9 < near_node.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                        if near_node.parent:\n                            if near_node in near_node.parent.children:\n                                near_node.parent.children.remove(near_node)\n                        near_node.parent = new_node\n                        near_node.cost = new_cost\n                        new_node.children.append(near_node)\n                        improved = True\n            return improved\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            smoothed = [path[0]]\n            i = 0\n            while i < len(path) -1:\n                j = len(path) - 1\n                while j > i + 1:\n                    if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d, resolution=self.step_size/5):\n                        break\n                    j -= 1\n                smoothed.append(path[j])\n                i = j\n            return smoothed\n\n        # Initialize trees\n        tree_start = [Node(start_pos, parent=None, cost=0.0)]\n        tree_goal = [Node(goal_pos, parent=None, cost=0.0)]\n        all_nodes = tree_start + tree_goal\n        edges = []\n\n        best_cost = float('inf')\n        best_pair = None\n        success = False\n        last_shortcut_time = start_time\n\n        gamma = 20.0  # tuning parameter for radius\n        max_radius = self.step_size * 5\n\n        for iter_count in range(self.max_iter):\n            now = time.monotonic()\n            if now - start_time > TIME_LIMIT:\n                break\n\n            # Alternate start/goal tree growth\n            tree_a = tree_start if iter_count % 2 == 0 else tree_goal\n            tree_b = tree_goal if iter_count % 2 == 0 else tree_start\n\n            rnd = sample_free(goal_bias=0.2)\n\n            nearest_node = nearest(tree_a, rnd)\n            new_pos = steer(nearest_node.position, rnd, self.step_size)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d, resolution=self.step_size/5):\n                continue\n\n            n_nodes = len(tree_a) + 1\n            radius = min(max_radius, gamma * (math.log(max(n_nodes, 2)) / n_nodes) ** (1.0 / dim))\n\n            near_nodes = near(tree_a, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            min_parent = nearest_node\n            for near_node in near_nodes:\n                new_cost = near_node.cost + dist(near_node.position, new_pos)\n                if new_cost + 1e-9 < min_cost:\n                    if not self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d, resolution=self.step_size/5):\n                        min_cost = new_cost\n                        min_parent = near_node\n\n            new_node = Node(new_pos, parent=min_parent, cost=min_cost)\n            min_parent.children.append(new_node)\n            tree_a.append(new_node)\n            all_nodes.append(new_node)\n            edges.append((min_parent, new_node))\n\n            rewired = try_rewire(new_node, near_nodes, obstacles, is_3d)\n\n            # Attempt multiple connections from new_node to nodes in other tree within radius\n            other_near_nodes = near(tree_b, new_node.position, radius)\n            connected_this_iter = False\n            for other_node in other_near_nodes:\n                connect_dist = dist(new_node.position, other_node.position)\n                total_cost = new_node.cost + other_node.cost + connect_dist\n                if connect_dist <= self.step_size and total_cost + 1e-9 < best_cost:\n                    if not self._is_edge_in_obstacle(new_node.position, other_node.position, obstacles, is_3d, resolution=self.step_size/5):\n                        best_cost = total_cost\n                        best_pair = (new_node, other_node)\n                        success = True\n                        connected_this_iter = True\n            if connected_this_iter:\n                # Early stopping on improved path found to reduce planning time\n                break\n\n            # Periodic incremental path shortcutting on best known path to improve smoothness and length\n            if success and (now - last_shortcut_time > 0.5):\n                candidate_path = extract_path(best_pair[0], best_pair[1])\n                shortened = shortcut_path(candidate_path)\n                if len(shortened) < len(candidate_path):\n                    # Replace path with shortcut path for smoother and shorter result\n                    best_pair_short_nodes = []\n                    # Rebuild nodes for new shortcut path? \n                    # Here we keep original nodes, just update path extraction for final result\n                    # So we just update the extracted_path at end.\n                    last_shortcut_time = now\n\n        if success and best_pair is not None:\n            extracted_path = extract_path(best_pair[0], best_pair[1])\n            extracted_path = shortcut_path(extracted_path)\n        else:\n            # Attempt connection among any near nodes between trees\n            min_total_cost = float('inf')\n            candidate_pair = None\n            for n1 in tree_start:\n                near_goal_nodes = near(tree_goal, n1.position, self.step_size*1.5)\n                for n2 in near_goal_nodes:\n                    dist12 = dist(n1.position, n2.position)\n                    if dist12 <= self.step_size*1.5:\n                        total_cost = n1.cost + n2.cost + dist12\n                        if total_cost + 1e-9 < min_total_cost:\n                            if not self._is_edge_in_obstacle(n1.position, n2.position, obstacles, is_3d, resolution=self.step_size/5):\n                                min_total_cost = total_cost\n                                candidate_pair = (n1,n2)\n            if candidate_pair is not None:\n                extracted_path = extract_path(candidate_pair[0], candidate_pair[1])\n                extracted_path = shortcut_path(extracted_path)\n                success = True\n            else:\n                extracted_path = []\n\n        return PlannerResult(\n            success=success,\n            path=extracted_path,\n            nodes=all_nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -35.41092,
          "time_improvement": 55.0,
          "length_improvement": 15.0,
          "smoothness_improvement": 1973.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.016417622566223145,
                    "num_nodes_avg": 151.9,
                    "path_length_avg": 165.63929068347426,
                    "smoothness_avg": 0.06125909518606807,
                    "success_improvement": 0.0,
                    "time_improvement": 34.940165416687925,
                    "length_improvement": 9.210480053863174,
                    "smoothness_improvement": 858.8378659163208,
                    "objective_score": 20.30252698690589
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.03619728088378906,
                    "num_nodes_avg": 379.6,
                    "path_length_avg": 240.5218456435933,
                    "smoothness_avg": 0.12863602123463258,
                    "success_improvement": 0.0,
                    "time_improvement": 77.92049934774737,
                    "length_improvement": 19.706884886699935,
                    "smoothness_improvement": 3209.8974791481382,
                    "objective_score": 51.24976813208486
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.02301657199859619,
                    "num_nodes_avg": 286.4,
                    "path_length_avg": 126.87756235220226,
                    "smoothness_avg": 0.1534211955820471,
                    "success_improvement": 0.0,
                    "time_improvement": 53.27521442479559,
                    "length_improvement": 15.73396434594209,
                    "smoothness_improvement": 1851.5062834289556,
                    "objective_score": 34.68047435214871
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "cross_over",
          "algorithm_description": "A hybrid bidirectional RRT* planner employing adaptive neighborhood radius rewiring, goal-biased sampling, multiple candidate connections, and progressive path shortcutting during planning to sharply reduce planning time while minimizing path length and enhancing smoothness and robustness. The planner dynamically balances exploration and exploitation, enforces efficient collision checks, and terminates early when high-quality paths are found.",
          "planning_mechanism": "The planner iteratively grows two trees from start and goal by sampling with a controlled goal bias, steering nearest nodes toward samples using fixed step size, and rewiring nodes within an adaptively shrinking radius based on node density and problem dimension. Each iteration attempts multiple candidate connections across trees with fine collision checking. Progressive shortcutting is applied periodically to smooth the path during planning. The algorithm respects map bounds, collision constraints, and employs a hard 30-second time limit, returning the best feasible path found.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.time_limit = 30.0\n        self.goal_sample_rate = 0.15  # goal bias probability\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n        import time\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        start_tree = [Node(start_pos, cost=0.0)]\n        goal_tree = [Node(goal_pos, cost=0.0)]\n        nodes = start_tree[:] + goal_tree[:]\n        edges = []\n\n        gamma_rrt_star = 35.0  # neighborhood radius constant tuned\n\n        best_connection = None  # tuple(Node from start_tree, Node from goal_tree)\n        best_cost = float('inf')\n        success = False\n\n        step_size = self.step_size\n        start_time = time.monotonic()\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def sample_free():\n            # goal biased sampling with fallback attempts\n            if random.random() < self.goal_sample_rate:\n                return goal_pos\n            for _ in range(100):\n                p = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n            return goal_pos  # fallback if no samples found\n\n        def nearest(tree, point):\n            best_node = None\n            best_d = float('inf')\n            for node in tree:\n                d = dist(node.position, point)\n                if d < best_d:\n                    best_d = d\n                    best_node = node\n            return best_node\n\n        def near(tree, point, radius):\n            neighbors = []\n            for node in tree:\n                d = dist(node.position, point)\n                if d <= radius:\n                    neighbors.append((d, node))\n            neighbors.sort(key=lambda x: x[0])\n            return [n[1] for n in neighbors]\n\n        def steer(from_p, to_p, max_step):\n            d = dist(from_p, to_p)\n            if d <= max_step:\n                return to_p\n            ratio = max_step / d\n            return tuple(from_p[i] + (to_p[i] - from_p[i]) * ratio for i in range(dim))\n\n        def extract_path(n_start, n_goal):\n            path_start = []\n            cur = n_start\n            while cur is not None:\n                path_start.append(cur.position)\n                cur = cur.parent\n            path_start.reverse()\n            path_goal = []\n            cur = n_goal\n            while cur is not None:\n                path_goal.append(cur.position)\n                cur = cur.parent\n            if path_start and path_goal and path_start[-1] == path_goal[0]:\n                path_goal = path_goal[1:]\n            return path_start + path_goal\n\n        def shortcut_path(path, max_attempts=50):\n            # Progressive shortcutting to smooth and shorten paths\n            if len(path) < 3:\n                return path\n            for _ in range(max_attempts):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1 = path[i]\n                p2 = path[j]\n                if not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution=max(step_size * 0.2, 0.2)):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        def try_connect(new_node, other_tree):\n            radius = step_size * 2.5\n            candidates = near(other_tree, new_node.position, radius)\n            best_cand = None\n            best_cost_local = float('inf')\n            for node in candidates:\n                dist_between = dist(new_node.position, node.position)\n                if dist_between <= radius:\n                    if not self._is_edge_in_obstacle(new_node.position, node.position, obstacles, is_3d, resolution=max(step_size * 0.2, 0.2)):\n                        total_cost = new_node.cost + dist_between + node.cost\n                        if total_cost < best_cost_local:\n                            best_cost_local = total_cost\n                            best_cand = node\n            return best_cand, best_cost_local\n\n        def rewire(tree, new_node, neighbors):\n            for neighbor in neighbors:\n                if neighbor is new_node.parent:\n                    continue\n                cost_through = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_through + 1e-9 < neighbor.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d, resolution=max(step_size * 0.2, 0.2)):\n                        if neighbor.parent:\n                            try:\n                                edges.remove((neighbor.parent, neighbor))\n                            except Exception:\n                                pass\n                            neighbor.parent.remove_child(neighbor)\n                        neighbor.parent = new_node\n                        neighbor.cost = cost_through\n                        new_node.add_child(neighbor)\n                        edges.append((new_node, neighbor))\n\n        iter_since_last_shortcut = 0\n        shortcut_interval = 75\n\n        for it in range(self.max_iter):\n            if time.monotonic() - start_time > self.time_limit:\n                break\n\n            tree_a = start_tree if it % 2 == 0 else goal_tree\n            tree_b = goal_tree if it % 2 == 0 else start_tree\n\n            sample = sample_free()\n            nearest_node = nearest(tree_a, sample)\n            new_pos = steer(nearest_node.position, sample, step_size)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d, resolution=max(step_size * 0.2, 0.2)):\n                continue\n\n            n_nodes = len(tree_a) + 1\n            radius = max(step_size, min(step_size * 5, gamma_rrt_star * ((math.log(n_nodes) / n_nodes) ** (1 / dim))))\n\n            neighbors = near(tree_a, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            min_parent = nearest_node\n            for nb in neighbors:\n                candidate_cost = nb.cost + dist(nb.position, new_pos)\n                if candidate_cost + 1e-9 < min_cost:\n                    if not self._is_edge_in_obstacle(nb.position, new_pos, obstacles, is_3d, resolution=max(step_size * 0.2, 0.2)):\n                        min_cost = candidate_cost\n                        min_parent = nb\n\n            new_node = Node(new_pos, parent=min_parent, cost=min_cost)\n            min_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((min_parent, new_node))\n\n            rewire(tree_a, new_node, neighbors)\n\n            conn_node, conn_cost = try_connect(new_node, tree_b)\n            if conn_node is not None and conn_cost + 1e-9 < best_cost:\n                best_cost = conn_cost\n                best_connection = (new_node, conn_node) if it % 2 == 0 else (conn_node, new_node)\n                success = True\n                # Early stop on improved solution\n                break\n\n            iter_since_last_shortcut += 1\n            if iter_since_last_shortcut >= shortcut_interval and success:\n                path_cur = extract_path(best_connection[0], best_connection[1])\n                path_short = shortcut_path(path_cur, max_attempts=25)\n                if len(path_short) < len(path_cur):\n                    iter_since_last_shortcut = 0\n                    # Replace best path with shortcut\n                    # We'll re-extract path before return to keep tree coherence\n                    extracted_path = path_short\n\n        extracted_path = []\n        if success and best_connection is not None:\n            extracted_path = extract_path(best_connection[0], best_connection[1])\n            extracted_path = shortcut_path(extracted_path, max_attempts=75)\n        else:\n            # No full success: find best partial connection\n            best_partial_cost = float('inf')\n            best_pair = None\n            search_radius = step_size * 3.0\n            for n1 in start_tree:\n                candidates = near(goal_tree, n1.position, search_radius)\n                for n2 in candidates:\n                    dist_12 = dist(n1.position, n2.position)\n                    if dist_12 <= search_radius:\n                        if not self._is_edge_in_obstacle(n1.position, n2.position, obstacles, is_3d, resolution=max(step_size * 0.2, 0.2)):\n                            total_cost = n1.cost + n2.cost + dist_12\n                            if total_cost + 1e-9 < best_partial_cost:\n                                best_partial_cost = total_cost\n                                best_pair = (n1, n2)\n            if best_pair:\n                success = True\n                extracted_path = extract_path(best_pair[0], best_pair[1])\n                extracted_path = shortcut_path(extracted_path, max_attempts=75)\n\n        return PlannerResult(\n            success=success,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -34.6527,
          "time_improvement": 61.0,
          "length_improvement": 16.0,
          "smoothness_improvement": 1381.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.011872506141662598,
                    "num_nodes_avg": 107.7,
                    "path_length_avg": 163.66283892228535,
                    "smoothness_avg": 0.04201284504332733,
                    "success_improvement": 0.0,
                    "time_improvement": 52.95157489763024,
                    "length_improvement": 10.29380458305316,
                    "smoothness_improvement": 557.5922572813087,
                    "objective_score": 24.849716505527507
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.02488439083099365,
                    "num_nodes_avg": 310.2,
                    "path_length_avg": 240.20474907561953,
                    "smoothness_avg": 0.09852207245217506,
                    "success_improvement": 0.0,
                    "time_improvement": 84.82109953651525,
                    "length_improvement": 19.812740848208225,
                    "smoothness_improvement": 2435.0438867749226,
                    "objective_score": 49.509193803754115
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.02670140266418457,
                    "num_nodes_avg": 301.3,
                    "path_length_avg": 125.20170451544436,
                    "smoothness_avg": 0.09831100843591407,
                    "success_improvement": 0.0,
                    "time_improvement": 45.794824958412164,
                    "length_improvement": 16.846989325342022,
                    "smoothness_improvement": 1150.5087707410203,
                    "objective_score": 29.599184936433964
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "path_expert",
          "algorithm_description": "A bidirectional, asymmetrically goal-biased RRT* planner implementing adaptive neighborhood radius rewiring, multi-candidate connection attempts across trees, and incremental path shortcutting during planning for improved efficiency, shorter and smoother paths, and robustness within a strict 30-second time limit. It alternates tree expansions while dynamically updating rewiring radii and performs fine-resolution collision checks, early stopping on improved connections, and progressive shortcutting to optimize path quality.",
          "planning_mechanism": "A bidirectional RRT* framework grows start and goal trees, sampling with a controlled goal bias. New nodes are connected with cost-based parent selection and rewiring within an adaptively shrinking radius based on node density and dimension. Multiple candidate connections to the opposite tree are attempted each iteration, improving connection quality and enabling early termination. Progressive shortcutting is applied periodically to smooth intermediate paths during planning. The search respects map bounds and obstacle collisions, enforcing a hard 30-second limit, and outputs the best feasible path found.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float = 0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children: List[Node] = []\n        self.valid = True\n    def add_child(self, child):\n        self.children.append(child)\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.time_limit = 30.0\n        self.goal_sample_rate = 0.15  # Controlled goal biasing\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = dim == 3\n\n        gamma_rrt_star = 35.0  # Tuned constant for neighborhood radius\n\n        # Initialize bidirectional trees: list of Node\n        start_tree = [Node(start_pos, cost=0.0)]\n        goal_tree = [Node(goal_pos, cost=0.0)]\n        nodes = start_tree[:] + goal_tree[:]\n        edges = []\n\n        best_connection = None  # tuple of (Node from start_tree, Node from goal_tree)\n        best_cost = float('inf')\n        success = False\n\n        step_size = self.step_size\n        start_time = time.monotonic()\n\n        def dist(a: Tuple[float, ...], b: Tuple[float, ...]) -> float:\n            return math.dist(a, b)\n\n        def sample_free() -> Tuple[float, ...]:\n            # Goal bias: sample goal with goal_sample_rate probability\n            if random.random() < self.goal_sample_rate:\n                return goal_pos\n            for _ in range(100):\n                p = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n            return goal_pos  # fallback\n\n        def nearest(tree: List[Node], point: Tuple[float, ...]) -> Node:\n            best_node = None\n            best_d = float('inf')\n            for node in tree:\n                d = dist(node.position, point)\n                if d < best_d:\n                    best_d = d\n                    best_node = node\n            return best_node\n\n        def near(tree: List[Node], point: Tuple[float, ...], radius: float) -> List[Node]:\n            neighbors = []\n            for node in tree:\n                d = dist(node.position, point)\n                if d <= radius:\n                    neighbors.append((d, node))\n            neighbors.sort(key=lambda x: x[0])\n            return [n[1] for n in neighbors]\n\n        def steer(from_p: Tuple[float, ...], to_p: Tuple[float, ...], max_step: float) -> Tuple[float, ...]:\n            d = dist(from_p, to_p)\n            if d <= max_step:\n                return to_p\n            ratio = max_step / d\n            return tuple(from_p[i] + (to_p[i] - from_p[i]) * ratio for i in range(dim))\n\n        def extract_path(n_start: Node, n_goal: Node) -> List[Tuple[float, ...]]:\n            path_start = []\n            cur = n_start\n            while cur is not None:\n                path_start.append(cur.position)\n                cur = cur.parent\n            path_start.reverse()\n            path_goal = []\n            cur = n_goal\n            while cur is not None:\n                path_goal.append(cur.position)\n                cur = cur.parent\n            # avoid duplicate connection node position\n            if path_goal and path_start and path_start[-1] == path_goal[0]:\n                path_goal = path_goal[1:]\n            return path_start + path_goal\n\n        def shortcut_path(path: List[Tuple[float, ...]], max_attempts=50) -> List[Tuple[float, ...]]:\n            # Progressive shortcutting: attempt random shortcuts to smooth path preserving collision constraints\n            if len(path) < 3:\n                return path\n            for _ in range(max_attempts):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1 = path[i]\n                p2 = path[j]\n                # Check if shortcut collision free\n                if not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution=max(self.step_size * 0.2, 0.2)):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        def try_connect(new_node: Node, other_tree: List[Node]) -> Tuple[Node, float]:\n            radius = step_size * 2.5\n            candidates = near(other_tree, new_node.position, radius)\n            best_cand = None\n            best_cost_local = float('inf')\n            for node in candidates:\n                dist_between = dist(new_node.position, node.position)\n                if dist_between <= radius and not self._is_edge_in_obstacle(new_node.position, node.position, obstacles, is_3d, resolution=max(step_size * 0.2, 0.2)):\n                    total_cost = new_node.cost + dist_between + node.cost\n                    if total_cost < best_cost_local:\n                        best_cost_local = total_cost\n                        best_cand = node\n            return best_cand, best_cost_local\n\n        def rewire(tree: List[Node], new_node: Node, neighbors: List[Node]) -> None:\n            for neighbor in neighbors:\n                if neighbor is new_node.parent:\n                    continue\n                cost_through = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_through + 1e-9 < neighbor.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d, resolution=max(step_size * 0.2, 0.2)):\n                        # rewire: switch parent\n                        if neighbor.parent:\n                            try:\n                                edges.remove((neighbor.parent, neighbor))\n                            except Exception:\n                                pass\n                            neighbor.parent.remove_child(neighbor)\n                        neighbor.parent = new_node\n                        neighbor.cost = cost_through\n                        new_node.add_child(neighbor)\n                        edges.append((new_node, neighbor))\n\n        iter_since_last_shortcut = 0\n        shortcut_interval = 75\n\n        for it in range(self.max_iter):\n            if time.monotonic() - start_time > self.time_limit:\n                break\n\n            tree_a = start_tree if it % 2 == 0 else goal_tree\n            tree_b = goal_tree if it % 2 == 0 else start_tree\n\n            sample = sample_free()\n            nearest_node = nearest(tree_a, sample)\n            new_pos = steer(nearest_node.position, sample, step_size)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d, resolution=max(step_size * 0.2, 0.2)):\n                continue\n\n            n_nodes = len(tree_a) + 1\n            radius = min(step_size * 5,\n                         gamma_rrt_star * ((math.log(n_nodes) / n_nodes) ** (1 / dim)))\n            if radius < step_size:\n                radius = step_size  # at least step size\n\n            neighbors = near(tree_a, new_pos, radius)\n\n            # Find best parent node (lowest cost + dist) collision safe\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            min_parent = nearest_node\n            for nb in neighbors:\n                cost_candidate = nb.cost + dist(nb.position, new_pos)\n                if cost_candidate + 1e-9 < min_cost:\n                    if not self._is_edge_in_obstacle(nb.position, new_pos, obstacles, is_3d, resolution=max(step_size * 0.2, 0.2)):\n                        min_cost = cost_candidate\n                        min_parent = nb\n\n            new_node = Node(new_pos, parent=min_parent, cost=min_cost)\n            min_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((min_parent, new_node))\n\n            rewire(tree_a, new_node, neighbors)\n\n            # Try connect new_node to other tree with multiple candidates\n            conn_node, conn_cost = try_connect(new_node, tree_b)\n            if conn_node is not None and conn_cost + 1e-9 < best_cost:\n                best_cost = conn_cost\n                best_connection = (new_node, conn_node) if it % 2 == 0 else (conn_node, new_node)\n                success = True\n                # Early stop on improved connection\n                break\n\n            # Periodic incremental shortcutting to improve intermediate path smoothness & length\n            iter_since_last_shortcut += 1\n            if iter_since_last_shortcut >= shortcut_interval and success:\n                path_cur = extract_path(best_connection[0], best_connection[1])\n                path_short = shortcut_path(path_cur, max_attempts=25)\n                # If shortcut reduces nodes substantially, update best path extracted immediately\n                if len(path_short) < len(path_cur):\n                    # Reset iter counter to avoid shortcutting excessive times\n                    iter_since_last_shortcut = 0\n                    extracted_path = path_short\n\n        extracted_path: List[Tuple[float, ...]] = []\n        if success and best_connection is not None:\n            extracted_path = extract_path(best_connection[0], best_connection[1])\n            extracted_path = shortcut_path(extracted_path, max_attempts=75)\n        else:\n            # If no success, try find best partial connection\n            best_partial_cost = float('inf')\n            best_pair = None\n            search_radius = step_size * 3.0\n            for n1 in start_tree:\n                candidates = near(goal_tree, n1.position, search_radius)\n                for n2 in candidates:\n                    d12 = dist(n1.position, n2.position)\n                    if d12 <= search_radius:\n                        if not self._is_edge_in_obstacle(n1.position, n2.position, obstacles, is_3d, resolution=max(step_size * 0.2, 0.2)):\n                            total_cost = n1.cost + n2.cost + d12\n                            if total_cost + 1e-9 < best_partial_cost:\n                                best_partial_cost = total_cost\n                                best_pair = (n1, n2)\n            if best_pair:\n                success = True\n                extracted_path = extract_path(best_pair[0], best_pair[1])\n                extracted_path = shortcut_path(extracted_path, max_attempts=75)\n\n        return PlannerResult(\n            success=success,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -34.56709,
          "time_improvement": 61.0,
          "length_improvement": 15.0,
          "smoothness_improvement": 1406.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.012232446670532226,
                    "num_nodes_avg": 111.9,
                    "path_length_avg": 161.78749064589732,
                    "smoothness_avg": 0.04188267931246853,
                    "success_improvement": 0.0,
                    "time_improvement": 51.11976593857507,
                    "length_improvement": 11.32171269013654,
                    "smoothness_improvement": 555.5548809339598,
                    "objective_score": 24.906731800324245
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.02393496036529541,
                    "num_nodes_avg": 300.9,
                    "path_length_avg": 242.85620828482826,
                    "smoothness_avg": 0.08907932627121147,
                    "success_improvement": 0.0,
                    "time_improvement": 85.36215473141678,
                    "length_improvement": 18.927607446152585,
                    "smoothness_improvement": 2192.075226203567,
                    "objective_score": 47.92558701813442
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.026720166206359863,
                    "num_nodes_avg": 317.0,
                    "path_length_avg": 126.2475615470681,
                    "smoothness_avg": 0.123441994873119,
                    "success_improvement": 0.0,
                    "time_improvement": 46.08887272601328,
                    "length_improvement": 16.152380883297628,
                    "smoothness_improvement": 1470.173063245805,
                    "objective_score": 30.868955664011587
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m1",
          "algorithm_description": "A bidirectional RRT* planner implementing adaptive rewiring with an adaptive neighborhood radius, probabilistic goal bias sampling, multiple candidate connection attempts, and progressive path shortcutting. The algorithm alternates tree expansions (start and goal), rewires local neighborhoods for cost improvement, and incrementally shortcuts paths during search, while enforcing timely termination within a 30-second wall-clock limit. It balances exploration and exploitation to improve planning efficiency, path length, and smoothness.",
          "planning_mechanism": "The planner grow two trees bidirectionally with step-limited expansions guided by goal bias sampling. Each new node rewires neighbors in an adaptive radius that shrinks as trees grow, ensuring efficient local optimization. Candidate connections between trees are assessed each iteration to update best paths and facilitate early stopping. Paths are incrementally shortcut for smoothness and length improvement. Strict collision checking and map bounds are enforced throughout.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position       # Tuple[float, ...]\n        self.parent = parent           # Node or None\n        self.cost = cost               # Cost from start/goal root to this node\n        self.children = []             # List of child nodes\n        self.valid = True              # Used if needed for collision checks\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.time_limit = 30.0\n        self.goal_sample_rate = 0.15  # 15% chance to sample goal, guiding exploration\n\n    def plan(self, map) -> 'PlannerResult':\n        import time\n        import random\n        import math\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        # Constants for rewiring radius calculation and shortcutting\n        gamma_rrt_star = 35.0\n        shortcut_interval = 75\n\n        # Helper functions\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def in_obstacle(pos):\n            for o in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = o\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w_, h_ = o\n                    px, py = pos\n                    if x <= px <= x + w_ and y <= py <= y + h_:\n                        return True\n            return False\n\n        def edge_in_obstacle(a, b, resolution=1.0):\n            distance = dist(a, b)\n            steps = max(1, int(distance / resolution))\n            for i in range(steps + 1):\n                interp = tuple(a[d] + (b[d] - a[d]) * (i / steps) for d in range(dim))\n                if in_obstacle(interp):\n                    return True\n            return False\n\n        def steer(from_p, to_p, max_step):\n            d = dist(from_p, to_p)\n            if d <= max_step:\n                return to_p\n            ratio = max_step / d\n            return tuple(from_p[i] + ratio * (to_p[i] - from_p[i]) for i in range(dim))\n\n        def sample_free():\n            if random.random() < self.goal_sample_rate:\n                return goal_pos\n            for _ in range(100):\n                p = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not in_obstacle(p):\n                    return p\n            # fallback to goal if unable to sample free after attempts\n            return goal_pos\n\n        def nearest(tree, point):\n            best_node = None\n            best_dist = float('inf')\n            for node in tree:\n                d = dist(node.position, point)\n                if d < best_dist:\n                    best_dist = d\n                    best_node = node\n            return best_node\n\n        def near(tree, point, radius):\n            neighbors = []\n            r_sq = radius * radius\n            for node in tree:\n                dx = node.position\n                # squared distance for efficiency\n                d = 0.0\n                for i in range(dim):\n                    delta = dx[i] - point[i]\n                    d += delta * delta\n                    if d > r_sq:\n                        break\n                if d <= r_sq:\n                    neighbors.append((math.sqrt(d), node))\n            neighbors.sort(key=lambda x: x[0])\n            return [n[1] for n in neighbors]\n\n        def extract_path(node_start, node_goal):\n            path_start = []\n            cur = node_start\n            while cur is not None:\n                path_start.append(cur.position)\n                cur = cur.parent\n            path_start.reverse()\n            path_goal = []\n            cur = node_goal\n            while cur is not None:\n                path_goal.append(cur.position)\n                cur = cur.parent\n            if path_start and path_goal and path_start[-1] == path_goal[0]:\n                path_goal = path_goal[1:]\n            return path_start + path_goal\n\n        def shortcut_path(path, max_attempts=50):\n            if len(path) < 3:\n                return path\n            attempts = 0\n            while attempts < max_attempts and len(path) > 2:\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if not edge_in_obstacle(path[i], path[j], resolution=max(self.step_size * 0.2, 0.2)):\n                    path = path[:i + 1] + path[j:]\n                attempts += 1\n            return path\n\n        def rewire(tree, new_node, neighbors):\n            for neighbor in neighbors:\n                if neighbor is new_node.parent:\n                    continue\n                cost_through = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_through + 1e-9 < neighbor.cost:\n                    if not edge_in_obstacle(new_node.position, neighbor.position, resolution=max(self.step_size * 0.2, 0.2)):\n                        # Rewire: change parent to new_node\n                        if neighbor.parent:\n                            try:\n                                edges.remove((neighbor.parent, neighbor))\n                            except ValueError:\n                                pass\n                            neighbor.parent.remove_child(neighbor)\n                        neighbor.parent = new_node\n                        neighbor.cost = cost_through\n                        new_node.add_child(neighbor)\n                        edges.append((new_node, neighbor))\n\n        def try_connect(new_node, other_tree):\n            radius = self.step_size * 2.5\n            candidates = near(other_tree, new_node.position, radius)\n            best_cand = None\n            best_cost_local = float('inf')\n            for node in candidates:\n                d = dist(new_node.position, node.position)\n                if d <= radius and not edge_in_obstacle(new_node.position, node.position, resolution=max(self.step_size * 0.2, 0.2)):\n                    total_cost = new_node.cost + d + node.cost\n                    if total_cost < best_cost_local:\n                        best_cost_local = total_cost\n                        best_cand = node\n            return best_cand, best_cost_local\n\n        start_tree = [Node(start_pos, cost=0.0)]\n        goal_tree = [Node(goal_pos, cost=0.0)]\n        nodes = start_tree[:] + goal_tree[:]\n        edges = []\n\n        best_connection = None\n        best_cost = float('inf')\n        success = False\n        extracted_path = []\n\n        start_time = time.monotonic()\n        iter_since_last_shortcut = 0\n\n        for it in range(self.max_iter):\n            if time.monotonic() - start_time > self.time_limit:\n                break\n\n            tree_a = start_tree if it % 2 == 0 else goal_tree\n            tree_b = goal_tree if it % 2 == 0 else start_tree\n\n            sample = sample_free()\n            nearest_node = nearest(tree_a, sample)\n            new_pos = steer(nearest_node.position, sample, self.step_size)\n\n            if in_obstacle(new_pos):\n                continue\n            if edge_in_obstacle(nearest_node.position, new_pos, resolution=max(self.step_size * 0.2, 0.2)):\n                continue\n\n            n_nodes = len(tree_a) + 1\n            radius = min(self.step_size * 5,\n                         gamma_rrt_star * ((math.log(n_nodes) / n_nodes) ** (1 / dim)))\n            if radius < self.step_size:\n                radius = self.step_size\n\n            neighbors = near(tree_a, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            min_parent = nearest_node\n            for nb in neighbors:\n                cost_candidate = nb.cost + dist(nb.position, new_pos)\n                if cost_candidate + 1e-9 < min_cost:\n                    if not edge_in_obstacle(nb.position, new_pos, resolution=max(self.step_size * 0.2, 0.2)):\n                        min_cost = cost_candidate\n                        min_parent = nb\n\n            new_node = Node(new_pos, parent=min_parent, cost=min_cost)\n            min_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((min_parent, new_node))\n\n            rewire(tree_a, new_node, neighbors)\n\n            conn_node, conn_cost = try_connect(new_node, tree_b)\n            if conn_node is not None and conn_cost + 1e-9 < best_cost:\n                best_cost = conn_cost\n                best_connection = (new_node, conn_node) if it % 2 == 0 else (conn_node, new_node)\n                success = True\n                # Early stop for improved connection\n                break\n\n            iter_since_last_shortcut += 1\n            if iter_since_last_shortcut >= shortcut_interval and success:\n                path_cur = extract_path(best_connection[0], best_connection[1])\n                path_short = shortcut_path(path_cur, max_attempts=25)\n                if len(path_short) < len(path_cur):\n                    iter_since_last_shortcut = 0\n                    extracted_path = path_short\n\n        if success and best_connection is not None:\n            if not extracted_path:\n                extracted_path = extract_path(best_connection[0], best_connection[1])\n            extracted_path = shortcut_path(extracted_path, max_attempts=75)\n        else:\n            # Attempt to find best partial connection if no success\n            best_partial_cost = float('inf')\n            best_pair = None\n            search_radius = self.step_size * 3.0\n            for n1 in start_tree:\n                candidates = near(goal_tree, n1.position, search_radius)\n                for n2 in candidates:\n                    d12 = dist(n1.position, n2.position)\n                    if d12 <= search_radius:\n                        if not edge_in_obstacle(n1.position, n2.position, resolution=max(self.step_size * 0.2, 0.2)):\n                            total_cost = n1.cost + n2.cost + d12\n                            if total_cost + 1e-9 < best_partial_cost:\n                                best_partial_cost = total_cost\n                                best_pair = (n1, n2)\n            if best_pair:\n                success = True\n                extracted_path = extract_path(best_pair[0], best_pair[1])\n                extracted_path = shortcut_path(extracted_path, max_attempts=75)\n\n        return PlannerResult(\n            success=success,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )",
          "objective": -33.38892,
          "time_improvement": 62.0,
          "length_improvement": 14.0,
          "smoothness_improvement": 1201.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.01741950511932373,
                    "num_nodes_avg": 144.8,
                    "path_length_avg": 170.95768293999285,
                    "smoothness_avg": 0.03857219544748236,
                    "success_improvement": 0.0,
                    "time_improvement": 30.969900360727053,
                    "length_improvement": 6.295384982747003,
                    "smoothness_improvement": 503.7386196161522,
                    "objective_score": 15.586894195947078
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.02476348876953125,
                    "num_nodes_avg": 277.2,
                    "path_length_avg": 240.8097731892848,
                    "smoothness_avg": 0.07867206388588006,
                    "success_improvement": 0.0,
                    "time_improvement": 84.89484698604019,
                    "length_improvement": 19.610766384413225,
                    "smoothness_improvement": 1924.2888689808865,
                    "objective_score": 46.85635827136442
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.01417391300201416,
                    "num_nodes_avg": 190.8,
                    "path_length_avg": 124.2791753311308,
                    "smoothness_avg": 0.10031237330959633,
                    "success_improvement": 0.0,
                    "time_improvement": 71.22625185796103,
                    "length_improvement": 17.459689283444,
                    "smoothness_improvement": 1175.9659842088704,
                    "objective_score": 37.723519048499064
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m1",
          "algorithm_description": "An enhanced bidirectional RRT* planner with adaptive neighborhood radius, efficient rewiring, improved goal bias, and periodic path shortcutting to optimize planning time, path length, and smoothness within a strict time limit. It alternates expanding two trees from start and goal with dynamic radius scaling based on tree size, performs cost-based rewiring, tries multiple candidate connections per iteration with early termination on improvement, and continuously refines the best path through shortcutting.",
          "planning_mechanism": "A bidirectional RRT* alternates tree expansions with adaptive neighborhood search and rewiring radius based on logarithmic scaling of the number of nodes and problem dimension. Sampling uses enhanced goal bias to accelerate convergence. Connecting the two trees employs multi-candidate cost-based edge selection. The algorithm interrupts early after strong improvements or after a 30-second time budget, returning the best path found. Periodic shortcutting improves smoothness and shortens paths incrementally, avoiding excessive computation while maintaining high-quality solutions.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\nclass Planner:\n    def __init__(self, max_iter: int = 6000, step_size: float = 4.5, goal_sample_rate: float = 0.20):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.time_limit = 30.0  # Hard time limit in seconds\n\n    def plan(self, map):\n        import time\n        import math\n        import random\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        gamma_rrt_star = 30.0  # Radius coefficient tuned for improved smoothness\n\n        start_tree = [Node(start_pos, cost=0.0)]\n        goal_tree = [Node(goal_pos, cost=0.0)]\n        nodes = start_tree[:] + goal_tree[:]\n        edges = []\n\n        best_connection = None\n        best_cost = float('inf')\n        success = False\n        found_improvement = False\n\n        start_time = time.monotonic()\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def sample_free():\n            # Enhanced goal bias with moderate attempts for efficiency\n            if random.random() < self.goal_sample_rate:\n                return goal_pos\n            for _ in range(30):\n                p = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n            return goal_pos  # Fallback if no free point found\n\n        def nearest(tree, point):\n            best_node = None\n            best_dist = float('inf')\n            for node in tree:\n                d = dist(node.position, point)\n                if d < best_dist:\n                    best_node = node\n                    best_dist = d\n            return best_node\n\n        def near(tree, point, radius):\n            radius_sq = radius * radius\n            neighbors = []\n            for node in tree:\n                # squared distance for efficiency\n                sq_dist = 0.0\n                for i in range(dim):\n                    diff = node.position[i] - point[i]\n                    sq_dist += diff * diff\n                    if sq_dist > radius_sq:\n                        break\n                if sq_dist <= radius_sq:\n                    neighbors.append((sq_dist, node))\n            neighbors.sort(key=lambda x: x[0])\n            return [nd[1] for nd in neighbors]\n\n        def steer(from_p, to_p, max_step):\n            d = dist(from_p, to_p)\n            if d <= max_step:\n                return to_p\n            ratio = max_step / d\n            return tuple(from_p[i] + (to_p[i] - from_p[i]) * ratio for i in range(dim))\n\n        def extract_path(node_start, node_goal):\n            path_start = []\n            cur = node_start\n            while cur is not None:\n                path_start.append(cur.position)\n                cur = cur.parent\n            path_goal = []\n            cur = node_goal\n            while cur is not None:\n                path_goal.append(cur.position)\n                cur = cur.parent\n            return path_start[::-1] + path_goal\n\n        def shortcut_path(path):\n            max_attempts = 80\n            if len(path) < 3:\n                return path\n            for _ in range(max_attempts):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        def try_connect(node, other_tree, radius):\n            candidates = near(other_tree, node.position, radius)\n            best_node = None\n            best_cost_local = float('inf')\n            for cnode in candidates:\n                d = dist(node.position, cnode.position)\n                if d <= radius and not self._is_edge_in_obstacle(node.position, cnode.position, obstacles, is_3d):\n                    total_cost = node.cost + cnode.cost + d\n                    if total_cost < best_cost_local:\n                        best_cost_local = total_cost\n                        best_node = cnode\n            return best_node, best_cost_local\n\n        for it in range(self.max_iter):\n            current_time = time.monotonic()\n            if current_time - start_time > self.time_limit:\n                break\n\n            # Alternate expansion\n            if it % 2 == 0:\n                tree_a, tree_b = start_tree, goal_tree\n            else:\n                tree_a, tree_b = goal_tree, start_tree\n\n            sample = sample_free()\n            nearest_node = nearest(tree_a, sample)\n            new_pos = steer(nearest_node.position, sample, self.step_size)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            n_nodes = len(tree_a) + 1\n            radius = min(self.step_size * 4.5, gamma_rrt_star * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim)))\n\n            near_nodes = near(tree_a, new_pos, radius)\n\n            # Find best parent node (lowest cost)\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            min_parent = nearest_node\n            for near_node in near_nodes:\n                cost_through = near_node.cost + dist(near_node.position, new_pos)\n                if cost_through < min_cost:\n                    if not self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d):\n                        min_cost = cost_through\n                        min_parent = near_node\n\n            new_node = Node(new_pos, parent=min_parent, cost=min_cost)\n            min_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((min_parent, new_node))\n\n            # Rewire neighbors incrementally\n            for near_node in near_nodes:\n                if near_node is min_parent:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, near_node.position)\n                if new_cost < near_node.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                        if near_node.parent:\n                            try:\n                                edges.remove((near_node.parent, near_node))\n                            except ValueError:\n                                pass\n                            near_node.parent.remove_child(near_node)\n                        near_node.parent = new_node\n                        near_node.cost = new_cost\n                        new_node.add_child(near_node)\n                        edges.append((new_node, near_node))\n\n            # Attempt multi-candidate tree connection\n            connect_radius = self.step_size * 3.2\n            conn_node, conn_cost = try_connect(new_node, tree_b, connect_radius)\n            if conn_node is not None and conn_cost < best_cost:\n                best_cost = conn_cost\n                best_connection = (new_node, conn_node)\n                success = True\n                found_improvement = True\n                # Early stop on improvement\n                break\n\n            # Periodic path shortcutting to improve smoothness & length\n            if found_improvement and (it % 120 == 0) and best_connection is not None:\n                path = extract_path(best_connection[0], best_connection[1])\n                shortcut = shortcut_path(path)\n                shortcut_len = sum(dist(shortcut[i], shortcut[i + 1]) for i in range(len(shortcut) - 1))\n                if shortcut_len + 1e-5 < best_cost:\n                    best_cost = shortcut_len\n                    extracted_path = shortcut\n                else:\n                    extracted_path = path\n\n        # Final path extraction and shortcutting if success\n        if success and best_connection is not None:\n            path = extract_path(best_connection[0], best_connection[1])\n            extracted_path = shortcut_path(path)\n        else:\n            # Fallback: find best pair bridging trees if no direct connection found\n            best_pair = None\n            min_total_cost = float('inf')\n            for n1 in start_tree:\n                near_goal_candidates = near(goal_tree, n1.position, self.step_size * 3.2)\n                for n2 in near_goal_candidates:\n                    d12 = dist(n1.position, n2.position)\n                    if d12 <= self.step_size * 3.2 and not self._is_edge_in_obstacle(n1.position, n2.position, obstacles, is_3d):\n                        total_c = n1.cost + n2.cost + d12\n                        if total_c < min_total_cost:\n                            min_total_cost = total_c\n                            best_pair = (n1, n2)\n            if best_pair:\n                path = extract_path(best_pair[0], best_pair[1])\n                extracted_path = shortcut_path(path)\n                success = True\n            else:\n                extracted_path = []\n\n        return PlannerResult(\n            success=success,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -33.36919,
          "time_improvement": 57.0,
          "length_improvement": 15.0,
          "smoothness_improvement": 1442.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.014020967483520507,
                    "num_nodes_avg": 122.0,
                    "path_length_avg": 168.85621197856955,
                    "smoothness_avg": 0.04592179710711396,
                    "success_improvement": 0.0,
                    "time_improvement": 43.972927835189054,
                    "length_improvement": 7.44723451664146,
                    "smoothness_improvement": 618.7758455048379,
                    "objective_score": 20.754098288065784
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.039501094818115236,
                    "num_nodes_avg": 363.8,
                    "path_length_avg": 236.27330058206434,
                    "smoothness_avg": 0.10265783372398023,
                    "success_improvement": 0.0,
                    "time_improvement": 75.84241189195431,
                    "length_improvement": 21.125171515827486,
                    "smoothness_improvement": 2541.460003166907,
                    "objective_score": 48.13512649291732
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.02402009963989258,
                    "num_nodes_avg": 264.6,
                    "path_length_avg": 125.65554175248053,
                    "smoothness_avg": 0.09952911323688463,
                    "success_improvement": 0.0,
                    "time_improvement": 51.53657956993282,
                    "length_improvement": 16.545572241909497,
                    "smoothness_improvement": 1166.002973898222,
                    "objective_score": 31.21833208561665
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e2",
          "algorithm_description": "A hybrid bidirectional RRT*-inspired planner that utilizes adaptive neighborhood radius rewiring, goal bias sampling, multi-candidate connection attempts, and incremental cost-based rewiring for improving planning efficiency, path length, and smoothness. The planner alternates tree expansions from start and goal, applies spatial pruning by dynamically shrinking the radius based on tree cardinality and dimension to focus rewiring on relevant neighbors, uses early stopping upon improved connection, and performs lightweight path shortcutting for smoothing while maintaining collision safety.",
          "planning_mechanism": "The planner maintains two trees growing bidirectionally, samples with a goal bias to efficiently explore near the goal, steers nearest nodes toward samples with a fixed step size, and rewires neighbors dynamically by considering cost improvements confined to an adaptively shrinking radius to optimize path quality and minimize overhead. Each iteration tries multiple candidate nodes to connect the two trees, favoring lower-cost connections and terminating early when a high-quality path is found or time limit exceeded. The final path undergoes fast shortcutting to reduce unnecessary waypoints while preserving collision-freeness and smoothness.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0, goal_sample_rate: float=0.15):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.time_limit = 30.0\n\n    def plan(self, map):\n        import time\n        import math\n        import random\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n        gamma_rrt_star = 50.0  # Controls neighborhood radius scaling for rewiring\n\n        start_tree = [Node(start_pos, cost=0.0)]\n        goal_tree = [Node(goal_pos, cost=0.0)]\n        nodes = start_tree[:] + goal_tree[:]\n        edges = []\n\n        best_connection = None\n        best_cost = float('inf')\n        success = False\n\n        # Precompute squared step size for efficiency\n        step_size = self.step_size\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def sample_free():\n            # Goal biasing: sample goal with probability goal_sample_rate\n            if random.random() < self.goal_sample_rate:\n                return goal_pos\n            for _ in range(100):\n                p = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n            # Fallback in rare case no free sample found\n            return goal_pos\n\n        def nearest(tree, point):\n            # Linear nearest (can be improved with spatial DS, not requested)\n            best_node = None\n            best_dist = float('inf')\n            for node in tree:\n                d = dist(node.position, point)\n                if d < best_dist:\n                    best_node = node\n                    best_dist = d\n            return best_node\n\n        def near(tree, point, radius):\n            neighbors = []\n            for node in tree:\n                d = dist(node.position, point)\n                if d <= radius:\n                    neighbors.append((d, node))\n            neighbors.sort(key=lambda x: x[0])\n            return [nd[1] for nd in neighbors]\n\n        def steer(from_p, to_p, max_step):\n            d = dist(from_p, to_p)\n            if d <= max_step:\n                return to_p\n            ratio = max_step / d\n            return tuple(from_p[i] + (to_p[i] - from_p[i]) * ratio for i in range(dim))\n\n        def extract_path(node_from_start, node_from_goal):\n            path_start = []\n            cur = node_from_start\n            while cur:\n                path_start.append(cur.position)\n                cur = cur.parent\n            path_goal = []\n            cur = node_from_goal\n            while cur:\n                path_goal.append(cur.position)\n                cur = cur.parent\n            return path_start[::-1] + path_goal\n\n        def shortcut_path(path):\n            # Lightweight shortcutting: tries up to 100 random shortcuts to smooth path while collision-free\n            max_attempts = 100\n            if len(path) < 3:\n                return path\n            for _ in range(max_attempts):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d):\n                    # Remove intermediate nodes between i and j\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        def try_connect(node, other_tree):\n            # Try multiple connection candidates from other_tree within radius around node.position\n            radius = step_size * 2.0\n            candidates = near(other_tree, node.position, radius)\n            best_node = None\n            best_cost_local = float('inf')\n            for cnode in candidates:\n                d = dist(node.position, cnode.position)\n                if d <= radius and not self._is_edge_in_obstacle(node.position, cnode.position, obstacles, is_3d):\n                    total_cost = node.cost + cnode.cost + d\n                    if total_cost < best_cost_local:\n                        best_cost_local = total_cost\n                        best_node = cnode\n            return best_node, best_cost_local\n\n        start_time = time.monotonic()\n\n        for it in range(self.max_iter):\n            if time.monotonic() - start_time > self.time_limit:\n                break\n\n            # Alternate expansion between start and goal trees\n            tree_a = start_tree if it % 2 == 0 else goal_tree\n            tree_b = goal_tree if it % 2 == 0 else start_tree\n\n            sample = sample_free()\n            nearest_node = nearest(tree_a, sample)\n            new_pos = steer(nearest_node.position, sample, step_size)\n\n            # Node collision check\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n\n            # Edge collision check\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            # Adaptive rewiring radius\n            n_nodes = len(tree_a) + 1\n            radius = min(step_size * 5, gamma_rrt_star * (math.log(n_nodes) / n_nodes) ** (1 / dim))\n\n            near_nodes = near(tree_a, new_pos, radius)\n\n            # Choose best parent minimizing cost + dist\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            min_parent = nearest_node\n            for near_node in near_nodes:\n                # Check cost through near_node and collision with near_node->new_pos\n                cost_through = near_node.cost + dist(near_node.position, new_pos)\n                if cost_through < min_cost:\n                    if not self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d):\n                        min_cost = cost_through\n                        min_parent = near_node\n\n            new_node = Node(new_pos, parent=min_parent, cost=min_cost)\n            min_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((min_parent, new_node))\n\n            # Rewire neighbors to new_node if cost improves and edge is collision-free\n            for near_node in near_nodes:\n                if near_node == min_parent:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, near_node.position)\n                if new_cost < near_node.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                        # Remove old edge\n                        if near_node.parent:\n                            try:\n                                edges.remove((near_node.parent, near_node))\n                            except ValueError:\n                                pass\n                            near_node.parent.remove_child(near_node)\n                        # Update parent and cost\n                        near_node.parent = new_node\n                        near_node.cost = new_cost\n                        new_node.add_child(near_node)\n                        edges.append((new_node, near_node))\n\n            # Attempt to connect newly added node to other tree candidates\n            conn_node, conn_cost = try_connect(new_node, tree_b)\n            if conn_node and conn_cost < best_cost:\n                best_cost = conn_cost\n                best_connection = (new_node, conn_node)\n                success = True\n                # Early stopping on improved path\n                break\n\n        extracted_path = []\n        if success and best_connection:\n            extracted_path = extract_path(best_connection[0], best_connection[1])\n            extracted_path = shortcut_path(extracted_path)\n        else:\n            # Attempt to find best partial connection on timeout or failure\n            min_cost = float('inf')\n            best_pair = None\n            for n1 in start_tree:\n                candidates = near(goal_tree, n1.position, step_size * 2.0)\n                for n2 in candidates:\n                    dist12 = dist(n1.position, n2.position)\n                    if dist12 <= step_size * 2.0:\n                        if not self._is_edge_in_obstacle(n1.position, n2.position, obstacles, is_3d):\n                            total_cost = n1.cost + n2.cost + dist12\n                            if total_cost < min_cost:\n                                min_cost = total_cost\n                                best_pair = (n1, n2)\n            if best_pair:\n                extracted_path = extract_path(best_pair[0], best_pair[1])\n                extracted_path = shortcut_path(extracted_path)\n                success = True\n\n        return PlannerResult(\n            success=success,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(\n                from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps)\n                for d in range(len(from_pos))\n            )\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -33.09257,
          "time_improvement": 56.0,
          "length_improvement": 16.0,
          "smoothness_improvement": 1398.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.01958200931549072,
                    "num_nodes_avg": 140.8,
                    "path_length_avg": 166.35481911674003,
                    "smoothness_avg": 0.044027487308021036,
                    "success_improvement": 0.0,
                    "time_improvement": 21.75128782371844,
                    "length_improvement": 8.818287581316609,
                    "smoothness_improvement": 589.1257835894651,
                    "objective_score": 14.761987813852823
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.026345157623291017,
                    "num_nodes_avg": 303.5,
                    "path_length_avg": 235.08654885206815,
                    "smoothness_avg": 0.08998220763376255,
                    "success_improvement": 0.0,
                    "time_improvement": 83.88815627932586,
                    "length_improvement": 21.521343402054775,
                    "smoothness_improvement": 2215.3070139811657,
                    "objective_score": 49.15578799493645
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.0191939115524292,
                    "num_nodes_avg": 244.3,
                    "path_length_avg": 125.39778779809066,
                    "smoothness_avg": 0.11710275866810149,
                    "success_improvement": 0.0,
                    "time_improvement": 61.27399056588344,
                    "length_improvement": 16.71676014549089,
                    "smoothness_improvement": 1389.538446631726,
                    "objective_score": 35.359945490218195
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e1",
          "algorithm_description": "An adaptive bidirectional RRT* planner with dynamic sampling density control, neighborhood radius scaling, focused rewiring, and path smoothing via lazy shortcutting. The planner alternately grows two trees from start and goal, applies cost-optimizing rewiring within an adaptively computed radius based on node count and problem dimension, and incrementally attempts multiple connection candidates between trees to improve solution quality. It employs goal bias, samples near promising regions, respects a 30-second hard time limit, performs thorough collision checks, and applies post-planning lazy shortcut smoothing to produce shorter, smoother paths efficiently.",
          "planning_mechanism": "A bidirectional RRT* variant that dynamically tunes neighbor radius by node density and dimension, incorporates incremental rewiring only among relevant neighbors, and aggressively connects multiple candidates between trees with continuous path improvements. The planner alternates tree expansions with goal bias sampling, performs strict collision checking on nodes and edges inside map bounds and obstacles, and halts either on timeout or upon finding sufficiently good solutions. Final path extraction is followed by a lazy shortcutting smoothing step that iteratively replaces sub-paths with collision-free direct edges, thus enhancing path smoothness and reducing overall length.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...], e.g. (x, y) or (x, y, z)\n        self.parent = parent            # Parent Node or None\n        self.cost = cost                # Path cost from root (start/goal)\n        self.children = []              # List of child Nodes\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.time_limit = 30.0\n        self.goal_sample_rate = 0.15  # Probability to sample goal point during sampling\n        self.gamma_rrt_star = 50.0    # Tuning constant for neighbor radius, can be adjusted\n\n    def plan(self, map):\n        import time\n        import math\n        import random\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        start_tree = [Node(start_pos, cost=0.0)]\n        goal_tree = [Node(goal_pos, cost=0.0)]\n        all_nodes = start_tree[:] + goal_tree[:]\n        edges = []\n\n        best_cost = float('inf')\n        best_connection = None\n        extracted_path = []\n        success = False\n\n        start_time = time.monotonic()\n\n        def in_obstacle(pos):\n            for o in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = o\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w_, h_ = o\n                    px, py = pos\n                    if x <= px <= x + w_ and y <= py <= y + h_:\n                        return True\n            return False\n\n        def edge_in_obstacle(p1, p2, resolution=None):\n            dist = math.dist(p1, p2)\n            step = resolution if resolution is not None else max(self.step_size * 0.2, 0.2)\n            steps = max(1, int(dist / step))\n            for i in range(steps + 1):\n                interp = tuple(p1[d] + (p2[d] - p1[d]) * (i / steps) for d in range(dim))\n                if in_obstacle(interp):\n                    return True\n            return False\n\n        def steer(from_p, to_p, max_step=None):\n            max_step = max_step if max_step is not None else self.step_size\n            dist = math.dist(from_p, to_p)\n            if dist <= max_step:\n                return to_p\n            r = max_step / dist\n            return tuple(from_p[i] + r * (to_p[i] - from_p[i]) for i in range(dim))\n\n        def sample_free():\n            if random.random() < self.goal_sample_rate:\n                return goal_pos\n            max_attempts = 100\n            for _ in range(max_attempts):\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not in_obstacle(sample):\n                    return sample\n            return goal_pos  # fallback if no free sample found\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def nearest(tree, point):\n            best_node = None\n            best_d = float('inf')\n            for n in tree:\n                d = dist(n.position, point)\n                if d < best_d:\n                    best_d = d\n                    best_node = n\n            return best_node\n\n        def near(tree, point, radius):\n            neighbors = []\n            for n in tree:\n                d = dist(n.position, point)\n                if d <= radius:\n                    neighbors.append((d, n))\n            neighbors.sort(key=lambda x: x[0])\n            return [n[1] for n in neighbors]\n\n        def extract_path(node_start, node_goal):\n            path_start = []\n            cur = node_start\n            while cur is not None:\n                path_start.append(cur.position)\n                cur = cur.parent\n            path_start.reverse()\n\n            path_goal = []\n            cur = node_goal\n            while cur is not None:\n                path_goal.append(cur.position)\n                cur = cur.parent\n\n            # Avoid duplicate connection node position at junction\n            if path_goal and path_start and path_start[-1] == path_goal[0]:\n                path_goal = path_goal[1:]\n            return path_start + path_goal\n\n        def rewire(tree, new_node, neighbors):\n            for neighbor in neighbors:\n                if neighbor is new_node.parent:\n                    continue\n                cost_through = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_through + 1e-9 < neighbor.cost:\n                    if not edge_in_obstacle(new_node.position, neighbor.position):\n                        # Remove old parent link\n                        if neighbor.parent:\n                            try:\n                                edges.remove((neighbor.parent, neighbor))\n                            except Exception:\n                                pass\n                            neighbor.parent.remove_child(neighbor)\n                        neighbor.parent = new_node\n                        neighbor.cost = cost_through\n                        new_node.add_child(neighbor)\n                        edges.append((new_node, neighbor))\n\n        def try_connect(new_node, other_tree):\n            radius = min(self.step_size * 3.0, self.gamma_rrt_star * ((math.log(len(other_tree)+1) / (len(other_tree)+1)) ** (1/dim)))\n            candidates = near(other_tree, new_node.position, radius)\n            best_node = None\n            best_cost_local = float('inf')\n            for node in candidates:\n                dist_connect = dist(new_node.position, node.position)\n                if dist_connect <= radius and not edge_in_obstacle(new_node.position, node.position):\n                    cost = new_node.cost + dist_connect + node.cost\n                    if cost < best_cost_local:\n                        best_cost_local = cost\n                        best_node = node\n            return best_node, best_cost_local\n\n        def lazy_shortcutting(path, max_attempts=100):\n            # Iteratively try random shortcuts to smooth path\n            if len(path) < 3:\n                return path\n            shortened = path[:]\n            for _ in range(max_attempts):\n                if len(shortened) < 3:\n                    break\n                i = random.randint(0, len(shortened) - 3)\n                j = random.randint(i + 2, len(shortened) - 1)\n                p1 = shortened[i]\n                p2 = shortened[j]\n                if not edge_in_obstacle(p1, p2):\n                    # Replace intermediate segment with direct edge\n                    shortened = shortened[:i + 1] + shortened[j:]\n            return shortened\n\n        # Main planning loop\n        for it in range(self.max_iter):\n            if time.monotonic() - start_time > self.time_limit:\n                break\n\n            tree_a, tree_b = (start_tree, goal_tree) if it % 2 == 0 else (goal_tree, start_tree)\n\n            sample = sample_free()\n            nearest_node = nearest(tree_a, sample)\n\n            new_pos = steer(nearest_node.position, sample, self.step_size)\n            if in_obstacle(new_pos):\n                continue\n            if edge_in_obstacle(nearest_node.position, new_pos):\n                continue\n\n            n_nodes = len(tree_a) + 1\n            radius = min(self.step_size * 5.0, self.gamma_rrt_star * ((math.log(n_nodes)/n_nodes) ** (1.0/dim)))\n            radius = max(radius, self.step_size)  # enforce minimum radius\n\n            neighbors = near(tree_a, new_pos, radius)\n\n            # Choose best parent among neighbors\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            min_parent = nearest_node\n            for nb in neighbors:\n                cost_candidate = nb.cost + dist(nb.position, new_pos)\n                if cost_candidate + 1e-9 < min_cost:\n                    if not edge_in_obstacle(nb.position, new_pos):\n                        min_cost = cost_candidate\n                        min_parent = nb\n\n            new_node = Node(new_pos, parent=min_parent, cost=min_cost)\n            min_parent.add_child(new_node)\n            tree_a.append(new_node)\n            all_nodes.append(new_node)\n            edges.append((min_parent, new_node))\n\n            # Rewire neighbors for better cost paths\n            rewire(tree_a, new_node, neighbors)\n\n            # Attempt multiple connections to opposite tree near new_node\n            conn_node, conn_cost = try_connect(new_node, tree_b)\n            if conn_node is not None and conn_cost + 1e-9 < best_cost:\n                best_cost = conn_cost\n                best_connection = (new_node, conn_node) if it % 2 == 0 else (conn_node, new_node)\n                success = True\n                # Early stop on improved connection\n                # But to stabilize path quality a few iterations can be done, here we stop immediately for efficiency\n                break\n\n        if success and best_connection is not None:\n            extracted_path = extract_path(best_connection[0], best_connection[1])\n            extracted_path = lazy_shortcutting(extracted_path, max_attempts=150)\n        else:\n            # Fallback: attempt best partial connection by proximity between trees\n            best_partial_cost = float('inf')\n            best_pair = None\n            search_radius = self.step_size * 3.0\n            for n1 in start_tree:\n                candidates = near(goal_tree, n1.position, search_radius)\n                for n2 in candidates:\n                    d12 = dist(n1.position, n2.position)\n                    if d12 <= search_radius and not edge_in_obstacle(n1.position, n2.position):\n                        total_cost = n1.cost + n2.cost + d12\n                        if total_cost + 1e-9 < best_partial_cost:\n                            best_partial_cost = total_cost\n                            best_pair = (n1, n2)\n            if best_pair:\n                success = True\n                extracted_path = extract_path(best_pair[0], best_pair[1])\n                extracted_path = lazy_shortcutting(extracted_path, max_attempts=150)\n\n        return PlannerResult(\n            success=success,\n            path=extracted_path,\n            nodes=all_nodes,\n            edges=edges\n        )",
          "objective": -28.69397,
          "time_improvement": 42.0,
          "length_improvement": 15.0,
          "smoothness_improvement": 1414.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.026157045364379884,
                    "num_nodes_avg": 168.6,
                    "path_length_avg": 172.36255527491443,
                    "smoothness_avg": 0.052837926790736456,
                    "success_improvement": 0.0,
                    "time_improvement": -3.6552666337874102,
                    "length_improvement": 5.525352194349752,
                    "smoothness_improvement": 727.0282936695193,
                    "objective_score": 5.853772794821225
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.025740861892700195,
                    "num_nodes_avg": 281.9,
                    "path_length_avg": 233.1831140282246,
                    "smoothness_avg": 0.08535792769243598,
                    "success_improvement": 0.0,
                    "time_improvement": 84.2986720805332,
                    "length_improvement": 22.15676473358739,
                    "smoothness_improvement": 2096.320960356621,
                    "objective_score": 49.065265266095494
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.026234531402587892,
                    "num_nodes_avg": 290.9,
                    "path_length_avg": 125.36456275683038,
                    "smoothness_avg": 0.11944698374914178,
                    "success_improvement": 0.0,
                    "time_improvement": 46.74259683298413,
                    "length_improvement": 16.73882663588952,
                    "smoothness_improvement": 1419.3568166298621,
                    "objective_score": 31.16285911457826
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "A simplified bidirectional RRT* variant with adaptive rewiring radius, goal bias sampling with retry limits, and incremental path improvement leveraging efficient neighbor searches. The planner grows two trees from start and goal alternately, rewiring nearby nodes for cost improvement, connecting trees within a dynamic radius, and performing lightweight shortcutting focused on removing redundancies. A strict 30-second wall-clock timer ensures timely termination with the best path found so far.",
          "planning_mechanism": "A bi-directional RRT* approach sampling free configurations with a fallback retry limit, expanding trees with bounded steering, rewiring neighbors within an adaptive radius logarithmically scaled by tree size, attempting connection candidates between trees in an expanded radius, and incrementally shortcutting the best path on improvements. Early stopping occurs upon finding a better connection for efficient planning.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, goal_sample_rate: float = 0.2):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.time_limit = 30.0\n\n    def plan(self, map) -> 'PlannerResult':\n        import time\n        import math\n        import random\n\n        bounds = map.size\n        dim = len(bounds)\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = dim == 3\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def dist_sq(a, b):\n            return sum((a[i] - b[i]) ** 2 for i in range(dim))\n\n        def sample_free():\n            if random.random() < self.goal_sample_rate:\n                return goal_pos\n            for _ in range(30):\n                p = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n            return goal_pos\n\n        def steer(from_p, to_p, max_step):\n            d = dist(from_p, to_p)\n            if d <= max_step:\n                return to_p\n            ratio = max_step / d\n            return tuple(from_p[i] + (to_p[i] - from_p[i]) * ratio for i in range(dim))\n\n        def nearest(tree, point):\n            best_node = None\n            best_dist_sq = float('inf')\n            for n in tree:\n                d2 = dist_sq(n.position, point)\n                if d2 < best_dist_sq:\n                    best_dist_sq = d2\n                    best_node = n\n            return best_node\n\n        def near(tree, point, radius):\n            r_sq = radius * radius\n            res = []\n            for n in tree:\n                d2 = dist_sq(n.position, point)\n                if d2 <= r_sq:\n                    res.append((d2, n))\n            res.sort(key=lambda x: x[0])\n            return [e[1] for e in res]\n\n        def extract_path(node_start, node_goal):\n            path_start = []\n            cur = node_start\n            while cur:\n                path_start.append(cur.position)\n                cur = cur.parent\n            path_goal = []\n            cur = node_goal\n            while cur:\n                path_goal.append(cur.position)\n                cur = cur.parent\n            return path_start[::-1] + path_goal\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            attempts = 0\n            max_attempts = 100\n            while attempts < max_attempts and len(path) >= 3:\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                    path = path[:i + 1] + path[j:]\n                attempts += 1\n            return path\n\n        def try_connect(new_node, other_tree, radius):\n            candidates = near(other_tree, new_node.position, radius)\n            best_node = None\n            best_cost = float('inf')\n            for c in candidates:\n                d = dist(new_node.position, c.position)\n                if d <= radius and not self._is_edge_in_obstacle(new_node.position, c.position, obstacles, is_3d):\n                    total_cost = new_node.cost + c.cost + d\n                    if total_cost < best_cost:\n                        best_cost = total_cost\n                        best_node = c\n            return best_node, best_cost\n\n        start_tree = [Node(start_pos, cost=0.0)]\n        goal_tree = [Node(goal_pos, cost=0.0)]\n        nodes = start_tree[:] + goal_tree[:]\n        edges = []\n\n        gamma = 35.0\n        best_connection = None\n        best_cost = float('inf')\n        success = False\n\n        start_time = time.monotonic()\n\n        for it in range(self.max_iter):\n            if time.monotonic() - start_time > self.time_limit:\n                break\n\n            tree_a, tree_b = (start_tree, goal_tree) if it % 2 == 0 else (goal_tree, start_tree)\n\n            sample = sample_free()\n            nearest_node = nearest(tree_a, sample)\n            new_pos = steer(nearest_node.position, sample, self.step_size)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            n_nodes = len(tree_a) + 1\n            radius = min(self.step_size * 5,\n                         gamma * (math.log(max(n_nodes, 2)) / n_nodes) ** (1 / dim))\n\n            near_nodes = near(tree_a, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            min_parent = nearest_node\n            for near_node in near_nodes:\n                new_cost = near_node.cost + dist(near_node.position, new_pos)\n                if new_cost + 1e-9 < min_cost:\n                    if not self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d):\n                        min_cost = new_cost\n                        min_parent = near_node\n\n            new_node = Node(new_pos, parent=min_parent, cost=min_cost)\n            min_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((min_parent, new_node))\n\n            # Rewire neighbors\n            for near_node in near_nodes:\n                if near_node is min_parent:\n                    continue\n                rewired_cost = new_node.cost + dist(new_node.position, near_node.position)\n                if rewired_cost + 1e-9 < near_node.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                        if near_node.parent is not None:\n                            try:\n                                edges.remove((near_node.parent, near_node))\n                            except ValueError:\n                                pass\n                            near_node.parent.remove_child(near_node)\n                        near_node.parent = new_node\n                        near_node.cost = rewired_cost\n                        new_node.add_child(near_node)\n                        edges.append((new_node, near_node))\n\n            # Try connecting opposite tree\n            connect_radius = self.step_size * 3.0\n            conn_node, conn_cost = try_connect(new_node, tree_b, connect_radius)\n            if conn_node is not None and conn_cost < best_cost:\n                best_cost = conn_cost\n                best_connection = (new_node, conn_node)\n                success = True\n                # Early stop for efficiency\n                break\n\n            # Periodic shortcutting\n            if it % 100 == 0 and success and best_connection:\n                path = extract_path(best_connection[0], best_connection[1])\n                path = shortcut_path(path)\n                extracted_path = path\n\n        if success and best_connection:\n            extracted_path = extract_path(best_connection[0], best_connection[1])\n            extracted_path = shortcut_path(extracted_path)\n        else:\n            # Attempt partial connection fallback\n            min_cost = float('inf')\n            best_pair = None\n            for n1 in start_tree:\n                candidates = near(goal_tree, n1.position, self.step_size * 3.0)\n                for n2 in candidates:\n                    d = dist(n1.position, n2.position)\n                    if d <= self.step_size * 3.0 and not self._is_edge_in_obstacle(n1.position, n2.position, obstacles, is_3d):\n                        total_c = n1.cost + n2.cost + d\n                        if total_c < min_cost:\n                            min_cost = total_c\n                            best_pair = (n1, n2)\n            if best_pair:\n                extracted_path = extract_path(best_pair[0], best_pair[1])\n                extracted_path = shortcut_path(extracted_path)\n                success = True\n\n        if not success:\n            extracted_path = []\n\n        return PlannerResult(\n            success=success,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=None):\n        import math\n        if resolution is None:\n            resolution = max(0.5, self.step_size / 5)\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -28.40282,
          "time_improvement": 39.0,
          "length_improvement": 15.0,
          "smoothness_improvement": 1467.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.01759207248687744,
                    "num_nodes_avg": 97.3,
                    "path_length_avg": 166.84842552375585,
                    "smoothness_avg": 0.035136022645855615,
                    "success_improvement": 0.0,
                    "time_improvement": 30.286049556980327,
                    "length_improvement": 8.547734087937185,
                    "smoothness_improvement": 449.95505350202524,
                    "objective_score": 16.464230587366536
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.08978750705718994,
                    "num_nodes_avg": 336.1,
                    "path_length_avg": 237.11037975476998,
                    "smoothness_avg": 0.09784145923876689,
                    "success_improvement": 0.0,
                    "time_improvement": 45.23170602239328,
                    "length_improvement": 20.84573039399028,
                    "smoothness_improvement": 2417.5312185680477,
                    "objective_score": 38.16460613595239
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.028477692604064943,
                    "num_nodes_avg": 173.7,
                    "path_length_avg": 124.84088433642191,
                    "smoothness_avg": 0.12847531178014862,
                    "success_improvement": 0.0,
                    "time_improvement": 42.18886806068799,
                    "length_improvement": 17.08662890783816,
                    "smoothness_improvement": 1534.1964827824138,
                    "objective_score": 30.579620176821365
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "initial",
          "algorithm_description": "This algorithm is a bidirectional extension of RRT* that grows two trees from start and goal while optimizing paths via rewiring. It combines RRT*\u2018s asymptotic optimality with RRT-Connect\u2019s fast convergence through connection attempts between the trees.",
          "planning_mechanism": "The planner alternates growing two trees with sampling, extension, and rewiring. After each extension, it attempts to connect both trees. When connection is successful, a rewired optimal path is extracted across both trees.",
          "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, radius: float = 10.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.radius = radius\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n        nodes = []\n        edges = []\n        success_state = False\n        extracted_path = []\n\n        for iter in range(self.max_iter):\n            rand = self._sample_free(bounds, obstacles, is_3d)\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest = self._nearest(tree_a, rand)\n                new_pos = self._steer(nearest.position, rand, self.step_size)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                    continue\n\n                new_node = Node(new_pos)\n                near_nodes = self._near(tree_a, new_pos, self.radius)\n                min_cost = nearest.cost + self._distance(nearest.position, new_pos)\n                min_parent = nearest\n\n                for near in near_nodes:\n                    cost = near.cost + self._distance(near.position, new_pos)\n                    if cost < min_cost and not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d):\n                        min_cost = cost\n                        min_parent = near\n\n                new_node.parent = min_parent\n                new_node.cost = min_cost\n                min_parent.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((min_parent, new_node))\n\n                for near in near_nodes:\n                    if near == min_parent:\n                        continue\n                    new_cost = new_node.cost + self._distance(new_node.position, near.position)\n                    if new_cost < near.cost and not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                        if near.parent:\n                            edges.remove((near.parent, near))\n                        near.parent = new_node\n                        near.cost = new_cost\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n\n                connect_node = self._nearest(tree_b, new_node.position)\n                if self._distance(new_node.position, connect_node.position) < self.step_size and not self._is_edge_in_obstacle(new_node.position, connect_node.position, obstacles, is_3d):\n                    success_state = True\n                    extracted_path = self._extract_path(new_node, connect_node)\n                    return PlannerResult(True, extracted_path, start_tree + goal_tree, edges)\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        while True:\n            point = tuple(random.uniform(0, bounds[i]) for i in range(3 if is_3d else 2))\n            if not self._is_in_obstacle(point, obstacles, is_3d):\n                return point\n\n    def _nearest(self, tree, point):\n        return min(tree, key=lambda node: self._distance(node.position, point))\n\n    def _near(self, tree, point, radius):\n        return [node for node in tree if self._distance(node.position, point) <= radius]\n\n    def _steer(self, from_pos, to_pos, step_size):\n        dist = self._distance(from_pos, to_pos)\n        if dist <= step_size:\n            return to_pos\n        ratio = step_size / dist\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n    def _extract_path(self, node_a, node_b):\n        path_a = []\n        while node_a:\n            path_a.append(node_a.position)\n            node_a = node_a.parent\n        path_b = []\n        while node_b:\n            path_b.append(node_b.position)\n            node_b = node_b.parent\n        return list(reversed(path_a)) + path_b\n\n    def _distance(self, a, b):\n        return math.dist(a, b)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = self._distance(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n    ",
          "objective": -27.725799297442336,
          "time_improvement": 75.0,
          "length_improvement": 7.0,
          "smoothness_improvement": 170.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.010820579528808594,
                    "num_nodes_avg": 133.0,
                    "path_length_avg": 175.27050435154484,
                    "smoothness_avg": 0.016726285105375487,
                    "success_improvement": 0.0,
                    "time_improvement": 56.761515149494244,
                    "length_improvement": 3.931459226046746,
                    "smoothness_improvement": 161.80268360858182,
                    "objective_score": 20.19634349851923
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.019153308868408204,
                    "num_nodes_avg": 264.6,
                    "path_length_avg": 258.5920512869376,
                    "smoothness_avg": 0.010908242682381757,
                    "success_improvement": 0.0,
                    "time_improvement": 88.28645766200407,
                    "length_improvement": 13.674530120921121,
                    "smoothness_improvement": 180.67694110730886,
                    "objective_score": 35.59404007669044
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.010100054740905761,
                    "num_nodes_avg": 179.6,
                    "path_length_avg": 143.86931760330097,
                    "smoothness_avg": 0.02092975461741331,
                    "success_improvement": 0.0,
                    "time_improvement": 79.62193302219796,
                    "length_improvement": 4.448849568598979,
                    "smoothness_improvement": 166.22493385971097,
                    "objective_score": 27.38701431711733
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "A simplified bidirectional RRT* planner with balanced goal bias, adaptive rewiring radius based on the logarithm of node count, incremental rewiring for cost improvement, and lightweight randomized shortcutting for path smoothing, all within a 30-second runtime limit. It alternates tree expansions from start and goal, uses direct nearest and near neighbor searches, and updates the best path found efficiently to reduce planning time while improving path length and smoothness.",
          "planning_mechanism": "The planner grows two trees alternately from start and goal positions by sampling free points biased towards the goal, connects new nodes selecting parents minimizing path costs within an adaptive radius, rewires neighbor nodes to reduce costs, attempts connections between the two trees within a neighborhood radius, applies periodic lightweight shortcutting on the best available path, and terminates early upon finding a better solution or when the time limit is reached, ultimately returning the best feasible path found.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0, goal_sample_rate: float=0.2):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.time_limit = 30.0\n\n    def plan(self, map):\n        import time\n        import math\n        import random\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = dim == 3\n\n        start_tree = [Node(start_pos, cost=0.0)]\n        goal_tree = [Node(goal_pos, cost=0.0)]\n        nodes = start_tree[:] + goal_tree[:]\n        edges = []\n\n        best_connection = None\n        best_cost = float('inf')\n        success = False\n        extracted_path = []\n\n        def dist(a,b):\n            return math.dist(a,b)\n\n        def dist_sq(a,b):\n            s = 0.0\n            for i in range(dim):\n                d = a[i]-b[i]\n                s += d*d\n            return s\n\n        def sample_free():\n            if random.random() < self.goal_sample_rate:\n                return goal_pos\n            for _ in range(30):\n                p = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n            return goal_pos\n\n        def nearest(tree, point):\n            best_node = None\n            best_dist = float('inf')\n            for node in tree:\n                d = dist_sq(node.position, point)\n                if d < best_dist:\n                    best_dist = d\n                    best_node = node\n            return best_node\n\n        def near(tree, point, radius):\n            r_sq = radius*radius\n            neighbors = []\n            for node in tree:\n                d = dist_sq(node.position, point)\n                if d <= r_sq:\n                    neighbors.append((d, node))\n            neighbors.sort(key=lambda x: x[0])\n            return [n[1] for n in neighbors]\n\n        def steer(from_p, to_p, max_step):\n            d = dist(from_p, to_p)\n            if d <= max_step:\n                return to_p\n            ratio = max_step / d\n            return tuple(from_p[i] + ratio*(to_p[i]-from_p[i]) for i in range(dim))\n\n        def extract_path(n_start, n_goal):\n            path_start = []\n            cur = n_start\n            while cur:\n                path_start.append(cur.position)\n                cur = cur.parent\n            path_goal = []\n            cur = n_goal\n            while cur:\n                path_goal.append(cur.position)\n                cur = cur.parent\n            return path_start[::-1] + path_goal\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            attempts = 30\n            for _ in range(attempts):\n                if len(path) < 3:\n                    break\n                i = random.randint(0,len(path)-3)\n                j = random.randint(i+2,len(path)-1)\n                if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        def try_connect(node, other_tree, radius):\n            candidates = near(other_tree, node.position, radius)\n            best_node = None\n            best_cost_local = float('inf')\n            for cnode in candidates:\n                d = dist(node.position, cnode.position)\n                if d <= radius and not self._is_edge_in_obstacle(node.position, cnode.position, obstacles, is_3d):\n                    total_cost = node.cost + cnode.cost + d\n                    if total_cost < best_cost_local:\n                        best_cost_local = total_cost\n                        best_node = cnode\n            return best_node, best_cost_local\n\n        def rewire(tree, new_node, neighbors):\n            for near_node in neighbors:\n                if near_node == new_node.parent:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, near_node.position)\n                if new_cost + 1e-9 < near_node.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                        if near_node.parent:\n                            try:\n                                edges.remove((near_node.parent, near_node))\n                            except ValueError:\n                                pass\n                            near_node.parent.remove_child(near_node)\n                        near_node.parent = new_node\n                        near_node.cost = new_cost\n                        new_node.add_child(near_node)\n                        edges.append((new_node, near_node))\n\n        start_time = time.monotonic()\n        gamma_rrt_star = 30.0\n\n        for it in range(self.max_iter):\n            current_time = time.monotonic()\n            if current_time - start_time > self.time_limit:\n                break\n\n            tree_a = start_tree if it % 2 == 0 else goal_tree\n            tree_b = goal_tree if it % 2 == 0 else start_tree\n\n            q_rand = sample_free()\n\n            nearest_node = nearest(tree_a, q_rand)\n            q_new = steer(nearest_node.position, q_rand, self.step_size)\n\n            if self._is_in_obstacle(q_new, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, q_new, obstacles, is_3d):\n                continue\n\n            n_nodes = max(len(tree_a),2)\n            radius = min(self.step_size*5.0, gamma_rrt_star * (math.log(n_nodes)/n_nodes)**(1.0/dim))\n\n            neighbors = near(tree_a, q_new, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, q_new)\n            min_parent = nearest_node\n            for near_n in neighbors:\n                cost_through = near_n.cost + dist(near_n.position, q_new)\n                if cost_through + 1e-9 < min_cost:\n                    if not self._is_edge_in_obstacle(near_n.position, q_new, obstacles, is_3d):\n                        min_cost = cost_through\n                        min_parent = near_n\n\n            new_node = Node(q_new, parent=min_parent, cost=min_cost)\n            min_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((min_parent, new_node))\n\n            rewire(tree_a, new_node, neighbors)\n\n            connect_radius = self.step_size*3.0\n            conn_node, conn_cost = try_connect(new_node, tree_b, connect_radius)\n            if conn_node and conn_cost < best_cost:\n                best_cost = conn_cost\n                best_connection = (new_node, conn_node)\n                success = True\n                extracted_path = extract_path(new_node, conn_node)\n                extracted_path = shortcut_path(extracted_path)\n                break\n\n            if success and it % 100 == 0 and best_connection:\n                path = extract_path(best_connection[0], best_connection[1])\n                shortcut = shortcut_path(path)\n                shortcut_len = sum(dist(shortcut[i], shortcut[i+1]) for i in range(len(shortcut)-1))\n                curr_len = sum(dist(extracted_path[i], extracted_path[i+1]) for i in range(len(extracted_path)-1))\n                if shortcut_len + 1e-8 < curr_len:\n                    extracted_path = shortcut\n\n        if not success:\n            best_pair = None\n            min_total = float('inf')\n            for n1 in start_tree:\n                candidates = near(goal_tree, n1.position, self.step_size*3.0)\n                for n2 in candidates:\n                    d = dist(n1.position, n2.position)\n                    if d <= self.step_size*3.0 and not self._is_edge_in_obstacle(n1.position, n2.position, obstacles, is_3d):\n                        total_c = n1.cost + n2.cost + d\n                        if total_c < min_total:\n                            min_total = total_c\n                            best_pair = (n1, n2)\n            if best_pair:\n                success = True\n                extracted_path = extract_path(best_pair[0], best_pair[1])\n                extracted_path = shortcut_path(extracted_path)\n\n        return PlannerResult(\n            success=success,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x,y,z,w,h,d = obs\n                px,py,pz = pos\n                if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                    return True\n            else:\n                x,y,w_,h_ = obs\n                px,py = pos\n                if x <= px <= x+w_ and y <= py <= y+h_:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps+1):\n            interp = tuple(from_pos[d] + (to_pos[d]-from_pos[d])*(i/steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -27.43438,
          "time_improvement": 55.0,
          "length_improvement": 14.0,
          "smoothness_improvement": 551.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.014897489547729492,
                    "num_nodes_avg": 124.5,
                    "path_length_avg": 165.8992144863402,
                    "smoothness_avg": 0.026445109039989236,
                    "success_improvement": 0.0,
                    "time_improvement": 40.96415593839107,
                    "length_improvement": 9.068011698756115,
                    "smoothness_improvement": 313.92338294925446,
                    "objective_score": 19.299670715517262
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.04256761074066162,
                    "num_nodes_avg": 306.9,
                    "path_length_avg": 249.54567503822258,
                    "smoothness_avg": 0.029184391199415433,
                    "success_improvement": 0.0,
                    "time_improvement": 74.03474608684778,
                    "length_improvement": 16.694470898245044,
                    "smoothness_improvement": 650.9354062282783,
                    "objective_score": 35.481783396142745
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.025249147415161134,
                    "num_nodes_avg": 227.1,
                    "path_length_avg": 126.84558042649284,
                    "smoothness_avg": 0.06203911235844328,
                    "success_improvement": 0.0,
                    "time_improvement": 48.74297532221194,
                    "length_improvement": 15.755205218182637,
                    "smoothness_improvement": 689.1329299484631,
                    "objective_score": 27.52168037731548
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "path_expert",
          "algorithm_description": "A bidirectional RRT* planner with goal bias and dynamically shrinking rewiring radius, improved parent selection via cost+distance heuristic, adaptive neighborhood rewiring focused on cost reduction, early connection attempts, and path shortcutting for minimal length under a hard 30s time limit.",
          "planning_mechanism": "The planner alternately grows start and goal trees using random sampling with goal bias, steering with fixed step size, and rewiring neighbors within a logarithmically shrinking radius for cost efficiency. It attempts early connection between trees by checking neighbors within an adaptive radius, selects parents minimizing cost-to-node plus distance heuristic, rewires incrementally to reduce path cost, and extracts and shortcuts the best path found periodically or on termination, always respecting collision constraints and bounds.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\nclass Planner:\n    def __init__(self, max_iter: int = 6000, step_size: float = 4.5, goal_sample_rate: float = 0.2):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.time_limit = 30.0\n\n    def plan(self, map):\n        import time\n        import random\n        import math\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        start_tree = [Node(start_pos, cost=0.0)]\n        goal_tree = [Node(goal_pos, cost=0.0)]\n        nodes = start_tree[:] + goal_tree[:]\n        edges = []\n\n        best_connection = None\n        best_cost = float('inf')\n        success = False\n        extracted_path = []\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def sample_free():\n            for _ in range(30):\n                if random.random() < self.goal_sample_rate:\n                    p = goal_pos\n                else:\n                    p = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n            return goal_pos\n\n        def nearest(tree, point):\n            best_node = None\n            best_dist = float('inf')\n            for node in tree:\n                d = dist(node.position, point)\n                if d < best_dist:\n                    best_node = node\n                    best_dist = d\n            return best_node\n\n        def near(tree, point, radius):\n            r_sq = radius * radius\n            neighbors = []\n            for node in tree:\n                d_sq = sum((node.position[i] - point[i])**2 for i in range(dim))\n                if d_sq <= r_sq:\n                    neighbors.append((math.sqrt(d_sq), node))\n            neighbors.sort(key=lambda x: x[0])\n            return [n[1] for n in neighbors]\n\n        def steer(from_p, to_p, max_step):\n            d = dist(from_p, to_p)\n            if d <= max_step:\n                return to_p\n            ratio = max_step / d\n            return tuple(from_p[i] + ratio * (to_p[i] - from_p[i]) for i in range(dim))\n\n        def extract_path(n_start, n_goal):\n            path_start = []\n            cur = n_start\n            while cur:\n                path_start.append(cur.position)\n                cur = cur.parent\n            path_goal = []\n            cur = n_goal\n            while cur:\n                path_goal.append(cur.position)\n                cur = cur.parent\n            return path_start[::-1] + path_goal\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            for _ in range(75):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        def try_connect(node, other_tree, radius):\n            candidates = near(other_tree, node.position, radius)\n            best_node = None\n            best_cost_local = float('inf')\n            for cnode in candidates:\n                d = dist(node.position, cnode.position)\n                if d <= radius and not self._is_edge_in_obstacle(node.position, cnode.position, obstacles, is_3d):\n                    total_cost = node.cost + cnode.cost + d\n                    if total_cost < best_cost_local:\n                        best_cost_local = total_cost\n                        best_node = cnode\n            return best_node, best_cost_local\n\n        start_time = time.monotonic()\n\n        for it in range(self.max_iter):\n            current_time = time.monotonic()\n            if current_time - start_time > self.time_limit:\n                break\n\n            tree_a = start_tree if it % 2 == 0 else goal_tree\n            tree_b = goal_tree if it % 2 == 0 else start_tree\n\n            sample = sample_free()\n            nearest_node = nearest(tree_a, sample)\n            new_pos = steer(nearest_node.position, sample, self.step_size)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            n_nodes = len(tree_a) + 1\n            gamma = 30.0  # radius scaling coefficient\n            radius = min(self.step_size * 5.5, gamma * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim)))\n\n            near_nodes = near(tree_a, new_pos, radius)\n\n            # Select parent that minimizes cost-to-node + dist heuristic\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            min_parent = nearest_node\n            for near_node in near_nodes:\n                cost_through = near_node.cost + dist(near_node.position, new_pos)\n                if cost_through < min_cost:\n                    if not self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d):\n                        min_cost = cost_through\n                        min_parent = near_node\n\n            new_node = Node(new_pos, parent=min_parent, cost=min_cost)\n            min_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((min_parent, new_node))\n\n            # Rewire neighbors to new node if cost improves and edge collision free\n            for near_node in near_nodes:\n                if near_node == min_parent:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, near_node.position)\n                if new_cost < near_node.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                        if near_node.parent:\n                            try:\n                                edges.remove((near_node.parent, near_node))\n                            except ValueError:\n                                pass\n                            near_node.parent.remove_child(near_node)\n                        near_node.parent = new_node\n                        near_node.cost = new_cost\n                        new_node.add_child(near_node)\n                        edges.append((new_node, near_node))\n\n            # Attempt connection to other tree within adaptive radius\n            connect_radius = self.step_size * 3.2\n            conn_node, conn_cost = try_connect(new_node, tree_b, connect_radius)\n            if conn_node and conn_cost < best_cost:\n                best_cost = conn_cost\n                best_connection = (new_node, conn_node)\n                success = True\n                # Early stop for improved path\n                break\n\n            # Periodically shortcut best path if improvement found\n            if success and it % 120 == 0 and best_connection:\n                path = extract_path(best_connection[0], best_connection[1])\n                shortcut = shortcut_path(path)\n                new_length = sum(dist(shortcut[i], shortcut[i+1]) for i in range(len(shortcut)-1))\n                if new_length + 1e-5 < best_cost:\n                    best_cost = new_length\n                    extracted_path = shortcut\n                else:\n                    extracted_path = path\n\n        if success and best_connection:\n            extracted_path = extract_path(best_connection[0], best_connection[1])\n            extracted_path = shortcut_path(extracted_path)\n        else:\n            # Fallback: find best cross-tree pair and shortcut fallback path\n            best_pair = None\n            min_total_cost = float('inf')\n            for n1 in start_tree:\n                near_goal_cands = near(goal_tree, n1.position, self.step_size * 3.2)\n                for n2 in near_goal_cands:\n                    d12 = dist(n1.position, n2.position)\n                    if d12 <= self.step_size * 3.2 and not self._is_edge_in_obstacle(n1.position, n2.position, obstacles, is_3d):\n                        total_c = n1.cost + n2.cost + d12\n                        if total_c < min_total_cost:\n                            min_total_cost = total_c\n                            best_pair = (n1, n2)\n            if best_pair:\n                extracted_path = extract_path(best_pair[0], best_pair[1])\n                extracted_path = shortcut_path(extracted_path)\n                success = True\n\n        return PlannerResult(\n            success=success,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -27.40187,
          "time_improvement": 38.0,
          "length_improvement": 16.0,
          "smoothness_improvement": 1257.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.02119297981262207,
                    "num_nodes_avg": 152.1,
                    "path_length_avg": 163.87341701691048,
                    "smoothness_avg": 0.04087808433626587,
                    "success_improvement": 0.0,
                    "time_improvement": 15.313931742246611,
                    "length_improvement": 10.17838339256568,
                    "smoothness_improvement": 539.830788043481,
                    "objective_score": 13.400363498430796
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.057435345649719236,
                    "num_nodes_avg": 355.1,
                    "path_length_avg": 241.9364752247091,
                    "smoothness_avg": 0.07969677886958462,
                    "success_improvement": 0.0,
                    "time_improvement": 64.87440590095132,
                    "length_improvement": 19.23464081466865,
                    "smoothness_improvement": 1950.6555235839744,
                    "objective_score": 40.756383877006456
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.03343057632446289,
                    "num_nodes_avg": 235.3,
                    "path_length_avg": 120.76782331760107,
                    "smoothness_avg": 0.10863055365717608,
                    "success_improvement": 0.0,
                    "time_improvement": 32.549818696791185,
                    "length_improvement": 19.79176209821548,
                    "smoothness_improvement": 1281.7726242458787,
                    "objective_score": 28.048865989196038
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "time_expert",
          "algorithm_description": "A bidirectional RRT* planner with adaptive neighborhood radius, efficient rewiring, and early stopping to minimize planning time and improve path quality. It grows two trees from start and goal by sampling free space, steering towards samples with fixed step size, and rewiring a shrinking neighborhood for path cost optimization. The planner attempts tree connection after each extension and returns the best path found within a 30-second limit.",
          "planning_mechanism": "A bidirectional RRT* planner alternates growing two trees by sampling, nearest node selection, steering, collision checks, and cost-based rewiring within an adaptively shrinking radius. It tries connecting the two trees whenever a new node is added, stopping early on the first improved connection. The adaptive radius balances exploration and efficient rewiring, reducing overhead and improving solution quality over time.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n        import time\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = start_tree[:] + goal_tree[:]\n        edges = []\n\n        success = False\n        best_cost = float('inf')\n        best_connect = None\n\n        start_time = time.monotonic()\n        TIME_LIMIT = 30.0\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def sample_free():\n            for _ in range(30):\n                p = tuple(random.uniform(0, bounds[i]) for i in range(len(bounds)))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n            # fallback: return start or goal to prevent infinite loop (rare)\n            return start_pos\n\n        def nearest(tree, point):\n            # Linear search; for improvement, can be replaced with spatial index\n            best_node = None\n            best_dist = float('inf')\n            for n in tree:\n                d = dist(n.position, point)\n                if d < best_dist:\n                    best_dist = d\n                    best_node = n\n            return best_node\n\n        def near(tree, point, radius):\n            r_sq = radius * radius\n            return [n for n in tree if (n.position[0] - point[0]) ** 2 + (n.position[1] - point[1]) ** 2 <= r_sq] if not is_3d else \\\n                   [n for n in tree if sum((n.position[i] - point[i]) ** 2 for i in range(3)) <= r_sq]\n\n        def steer(from_p, to_p, step):\n            d = dist(from_p, to_p)\n            if d <= step:\n                return to_p\n            ratio = step / d\n            return tuple(from_p[i] + (to_p[i] - from_p[i]) * ratio for i in range(len(from_p)))\n\n        def extract_path(n_start, n_goal):\n            path_start = []\n            curr = n_start\n            while curr is not None:\n                path_start.append(curr.position)\n                curr = curr.parent\n            path_goal = []\n            curr = n_goal\n            while curr is not None:\n                path_goal.append(curr.position)\n                curr = curr.parent\n            # Reverse start path and append goal path (connecting at the connecting edge)\n            return path_start[::-1] + path_goal\n\n        def cost_to_reach(node):\n            return node.cost\n\n        def try_rewire(new_node, neighbors, tree, obstacles, is_3d):\n            changed = False\n            for near_node in neighbors:\n                if near_node is new_node.parent:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, near_node.position)\n                if new_cost + 1e-9 < near_node.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                        # Rewire near_node\n                        if near_node.parent:\n                            try:\n                                edges.remove((near_node.parent, near_node))\n                            except ValueError:\n                                pass\n                            if near_node in near_node.parent.children:\n                                near_node.parent.children.remove(near_node)\n                        near_node.parent = new_node\n                        near_node.cost = new_cost\n                        new_node.add_child(near_node)\n                        edges.append((new_node, near_node))\n                        changed = True\n            return changed\n\n        def add_node(tree, new_node):\n            tree.append(new_node)\n            nodes.append(new_node)\n\n        gamma = 30.0\n        dim = len(bounds)\n\n        for iter_count in range(self.max_iter):\n            now = time.monotonic()\n            if now - start_time > TIME_LIMIT:\n                break\n\n            # Alternate tree growth\n            tree_a = start_tree if iter_count % 2 == 0 else goal_tree\n            tree_b = goal_tree if iter_count % 2 == 0 else start_tree\n\n            rnd = sample_free()\n\n            nearest_node = nearest(tree_a, rnd)\n            new_pos = steer(nearest_node.position, rnd, self.step_size)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            n_nodes = len(tree_a) + 1\n            radius = min(self.step_size * 5, gamma * (math.log(max(n_nodes, 2)) / n_nodes) ** (1 / dim))\n\n            near_nodes = near(tree_a, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            min_parent = nearest_node\n            for near_node in near_nodes:\n                cost_through = near_node.cost + dist(near_node.position, new_pos)\n                if cost_through + 1e-9 < min_cost:\n                    if not self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d):\n                        min_cost = cost_through\n                        min_parent = near_node\n\n            new_node = Node(new_pos, parent=min_parent, cost=min_cost)\n            min_parent.add_child(new_node)\n            add_node(tree_a, new_node)\n            edges.append((min_parent, new_node))\n\n            try_rewire(new_node, near_nodes, tree_a, obstacles, is_3d)\n\n            # Try connecting other tree near new_node\n            nearest_in_other = nearest(tree_b, new_node.position)\n            dist_connect = dist(new_node.position, nearest_in_other.position)\n            if dist_connect <= self.step_size:\n                if not self._is_edge_in_obstacle(new_node.position, nearest_in_other.position, obstacles, is_3d):\n                    total_cost = new_node.cost + nearest_in_other.cost + dist_connect\n                    if total_cost + 1e-9 < best_cost:\n                        best_cost = total_cost\n                        best_connect = (new_node, nearest_in_other)\n                        success = True\n                        # Early stop on first good solution to reduce planning time\n                        break\n\n        # Extract best path if found\n        if success and best_connect is not None:\n            extracted_path = extract_path(best_connect[0], best_connect[1])\n        else:\n            # No direct connection found in time, try minimal-cost pair and path extraction\n            min_cost_est = float('inf')\n            best_pair = None\n            for n1 in start_tree:\n                n2 = nearest(goal_tree, n1.position)\n                d12 = dist(n1.position, n2.position)\n                if d12 <= self.step_size:\n                    if not self._is_edge_in_obstacle(n1.position, n2.position, obstacles, is_3d):\n                        cost_sum = n1.cost + n2.cost + d12\n                        if cost_sum + 1e-9 < min_cost_est:\n                            min_cost_est = cost_sum\n                            best_pair = (n1, n2)\n            if best_pair is not None:\n                extracted_path = extract_path(best_pair[0], best_pair[1])\n                success = True\n            else:\n                extracted_path = []\n\n        return PlannerResult(\n            success=success,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -27.32825,
          "time_improvement": 72.0,
          "length_improvement": 8.0,
          "smoothness_improvement": 142.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.011930179595947266,
                    "num_nodes_avg": 135.2,
                    "path_length_avg": 171.34059103033889,
                    "smoothness_avg": 0.01642005874301497,
                    "success_improvement": 0.0,
                    "time_improvement": 52.327609778218985,
                    "length_improvement": 6.085506990861369,
                    "smoothness_improvement": 157.00957605645047,
                    "objective_score": 20.13463500826477
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.01886107921600342,
                    "num_nodes_avg": 282.1,
                    "path_length_avg": 270.38122584620703,
                    "smoothness_avg": 0.008398311675666579,
                    "success_improvement": 0.0,
                    "time_improvement": 88.4651758369878,
                    "length_improvement": 9.738964320462099,
                    "smoothness_improvement": 116.09460847429625,
                    "objective_score": 32.96340438574508
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.012389254570007325,
                    "num_nodes_avg": 219.8,
                    "path_length_avg": 136.44974335966273,
                    "smoothness_avg": 0.019808586046500164,
                    "success_improvement": 0.0,
                    "time_improvement": 75.00319890246378,
                    "length_improvement": 9.376577499064672,
                    "smoothness_improvement": 151.9637523937513,
                    "objective_score": 28.88672493214669
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "initial",
          "algorithm_description": "This algorithm grows two trees simultaneously, one from the start position and one from the goal position, and attempts to connect them to find a feasible path. This bidirectional approach accelerates convergence and increases the success rate compared to a single tree RRT.",
          "planning_mechanism": "The planning mechanism involves randomly sampling points within the map bounds, extending each tree towards the sampled points, and attempting to connect the two trees whenever new nodes are added. Collision checks are performed for nodes and edges to ensure safety, and once the two trees connect, the final path is reconstructed by backtracking through the parent nodes of each tree.",
          "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map) -> PlannerResult:\n        import math, random\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position)\n        goal_root = Node(goal_position)\n        nodes.extend([start_root, goal_root])\n        tree_a, tree_b = [start_root], [goal_root]\n\n        for _ in range(self.max_iter):\n            rand_point = self._sample_free(bounds, obstacles, is_3d)\n            new_a = self._extend_tree(tree_a, rand_point, obstacles, is_3d, nodes, edges)\n            if new_a is None:\n                continue\n\n            new_b = self._connect_trees(tree_b, new_a, obstacles, is_3d, nodes, edges)\n            if new_b:\n                success_state = True\n                path_a = new_a.path_from_root()\n                path_b = new_b.path_from_root()\n                extracted_path = path_a + path_b[::-1]\n                break\n\n            tree_a, tree_b = tree_b, tree_a  # Swap trees\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        import random\n        while True:\n            if is_3d:\n                p = (random.uniform(0, bounds[0]),\n                     random.uniform(0, bounds[1]),\n                     random.uniform(0, bounds[2]))\n            else:\n                p = (random.uniform(0, bounds[0]),\n                     random.uniform(0, bounds[1]))\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    def _nearest(self, tree, point):\n        import math\n        return min(tree, key=lambda node: math.dist(node.position, point))\n\n    def _steer(self, from_pos, to_pos):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _extend_tree(self, tree, point, obstacles, is_3d, nodes, edges):\n        nearest_node = self._nearest(tree, point)\n        new_pos = self._steer(nearest_node.position, point)\n        if not self._is_in_obstacle(new_pos, obstacles, is_3d) and not self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n            new_node = Node(new_pos, parent=nearest_node)\n            nearest_node.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n            return new_node\n        return None\n\n    def _connect_trees(self, tree, new_node, obstacles, is_3d, nodes, edges):\n        import math\n        nearest_node = self._nearest(tree, new_node.position)\n        while True:\n            new_pos = self._steer(nearest_node.position, new_node.position)\n            if (not self._is_in_obstacle(new_pos, obstacles, is_3d) and\n                not self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d)):\n                next_node = Node(new_pos, parent=nearest_node)\n                nearest_node.add_child(next_node)\n                tree.append(next_node)\n                nodes.append(next_node)\n                edges.append((nearest_node, next_node))\n\n                if math.dist(next_node.position, new_node.position) <= self.step_size:\n                    if not self._is_edge_in_obstacle(next_node.position, new_node.position, obstacles, is_3d):\n                        final_node = Node(new_node.position, parent=next_node)\n                        next_node.add_child(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((next_node, final_node))\n                        return final_node\n                    else:\n                        return None\n                nearest_node = next_node\n            else:\n                return None\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n",
          "objective": -26.578979600033247,
          "time_improvement": 90.0,
          "length_improvement": -1.0,
          "smoothness_improvement": 67.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.0023192644119262697,
                    "num_nodes_avg": 60.1,
                    "path_length_avg": 170.9770888905735,
                    "smoothness_avg": 0.011275125135943505,
                    "success_improvement": 0.0,
                    "time_improvement": 90.73233749889248,
                    "length_improvement": 6.284748273726786,
                    "smoothness_improvement": 76.48019270363378,
                    "objective_score": 31.372951177421985
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.008306598663330078,
                    "num_nodes_avg": 214.3,
                    "path_length_avg": 300.2930706351261,
                    "smoothness_avg": 0.006534541605897799,
                    "success_improvement": 0.0,
                    "time_improvement": 94.91995373769882,
                    "length_improvement": -0.24647043479386058,
                    "smoothness_improvement": 68.1384621598253,
                    "objective_score": 28.668796171232458
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.007047319412231445,
                    "num_nodes_avg": 165.1,
                    "path_length_avg": 166.43066776648297,
                    "smoothness_avg": 0.012296125703856912,
                    "success_improvement": 0.0,
                    "time_improvement": 85.78119122317372,
                    "length_improvement": -10.535324953740279,
                    "smoothness_improvement": 56.405811347470625,
                    "objective_score": 19.6951914514453
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m1",
          "algorithm_description": "This is a bidirectional RRT* planner that incorporates adaptive neighborhood radius, efficient rewiring with incremental cost updates, goal-biased sampling with retry limits, and periodic iterative path shortcutting during planning to improve path length, smoothness, and planning efficiency. The planner grows two trees alternatingly from start and goal positions, uses squared-distance based near neighbor searches to optimize rewiring, attempts multiple candidate connections between trees with early stopping on improvement, and maintains the best path found so far within a strict 30-second time limit. The plan method returns the best valid path found at timeout or successful connection.",
          "planning_mechanism": "The planner grows start and goal trees alternately by sampling free points with goal bias and retry limits. It selects nearest nodes using squared distances, steers towards samples with capped step size, and performs collision checks for nodes and edges. An adaptive rewiring radius logarithmically shrinks with increasing node count. When adding a new node, it rewires neighboring nodes if cost improves and edges are free. It attempts multiple candidate connections to the opposite tree within an expanded radius, updates the best path on improvement, and performs iterative shortcutting every 100 iterations to smooth the path. Planning respects a 30-second wall-clock limit and returns the best feasible path found so far.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position      # Tuple[float, ...]\n        self.parent = parent          # Node or None\n        self.cost = cost              # Path cost from root\n        self.children = []            # List[Node]\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, goal_sample_rate: float = 0.2):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.time_limit = 30.0\n\n    def plan(self, map) -> 'PlannerResult':\n        import time\n        import math\n        import random\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def dist_sq(a, b):\n            return sum((a[i] - b[i]) ** 2 for i in range(dim))\n\n        def dist(a, b):\n            return math.sqrt(dist_sq(a, b))\n\n        def sample_free():\n            # Goal bias sampling with retry limit\n            if random.random() < self.goal_sample_rate:\n                return goal_pos\n            for _ in range(30):\n                p = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n            return goal_pos  # fallback if sampling failed\n\n        def steer(from_p, to_p, max_step):\n            d = dist(from_p, to_p)\n            if d <= max_step:\n                return to_p\n            ratio = max_step / d\n            return tuple(from_p[i] + (to_p[i] - from_p[i]) * ratio for i in range(dim))\n\n        def nearest(tree, point):\n            best_node = None\n            best_dist_sq = float('inf')\n            for node in tree:\n                d2 = dist_sq(node.position, point)\n                if d2 < best_dist_sq:\n                    best_dist_sq = d2\n                    best_node = node\n            return best_node\n\n        def near(tree, point, radius):\n            r_sq = radius * radius\n            near_nodes = []\n            for node in tree:\n                d2 = dist_sq(node.position, point)\n                if d2 <= r_sq:\n                    near_nodes.append((d2, node))\n            near_nodes.sort(key=lambda x: x[0])\n            return [n[1] for n in near_nodes]\n\n        def extract_path(node_start, node_goal):\n            path_start = []\n            cur = node_start\n            while cur:\n                path_start.append(cur.position)\n                cur = cur.parent\n            path_goal = []\n            cur = node_goal\n            while cur:\n                path_goal.append(cur.position)\n                cur = cur.parent\n            return path_start[::-1] + path_goal\n\n        def shortcut_path(path):\n            # Up to 100 random shortcut attempts\n            if len(path) < 3:\n                return path\n            attempts = 0\n            max_attempts = 100\n            while attempts < max_attempts and len(path) >= 3:\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                    path = path[:i + 1] + path[j:]\n                attempts += 1\n            return path\n\n        def try_connect(new_node, other_tree):\n            # Attempt multiple candidates within 3*step_size radius\n            radius = self.step_size * 3.0\n            candidates = near(other_tree, new_node.position, radius)\n            best_node = None\n            best_total_cost = float('inf')\n            for c in candidates:\n                d = dist(new_node.position, c.position)\n                if d <= radius and not self._is_edge_in_obstacle(new_node.position, c.position, obstacles, is_3d):\n                    total_cost = new_node.cost + c.cost + d\n                    if total_cost < best_total_cost:\n                        best_total_cost = total_cost\n                        best_node = c\n            return best_node, best_total_cost\n\n        start_tree = [Node(start_pos, cost=0.0)]\n        goal_tree = [Node(goal_pos, cost=0.0)]\n        nodes = start_tree[:] + goal_tree[:]\n        edges = []\n\n        gamma_rrt_star = 35.0\n        best_connection = None\n        best_cost = float('inf')\n        success = False\n\n        start_time = time.monotonic()\n\n        for iteration in range(self.max_iter):\n            elapsed = time.monotonic() - start_time\n            if elapsed > self.time_limit:\n                break\n\n            # Alternate between start_tree and goal_tree expansions\n            if iteration % 2 == 0:\n                tree_a, tree_b = start_tree, goal_tree\n            else:\n                tree_a, tree_b = goal_tree, start_tree\n\n            sample = sample_free()\n            nearest_node = nearest(tree_a, sample)\n            new_pos = steer(nearest_node.position, sample, self.step_size)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            n_nodes = len(tree_a) + 1\n            radius = min(self.step_size * 5,\n                         gamma_rrt_star * (math.log(max(n_nodes, 2)) / n_nodes) ** (1 / dim))\n\n            near_nodes = near(tree_a, new_pos, radius)\n\n            # Choose best parent minimizing cost\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            min_parent = nearest_node\n            for near_node in near_nodes:\n                new_cost = near_node.cost + dist(near_node.position, new_pos)\n                if new_cost < min_cost and not self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d):\n                    min_cost = new_cost\n                    min_parent = near_node\n\n            new_node = Node(new_pos, parent=min_parent, cost=min_cost)\n            min_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((min_parent, new_node))\n\n            # Rewire neighbors for improved costs\n            for near_node in near_nodes:\n                if near_node == min_parent:\n                    continue\n                rewired_cost = new_node.cost + dist(new_node.position, near_node.position)\n                if rewired_cost + 1e-12 < near_node.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                        # Remove old edge\n                        if near_node.parent is not None:\n                            try:\n                                edges.remove((near_node.parent, near_node))\n                            except ValueError:\n                                pass\n                            near_node.parent.remove_child(near_node)\n                        # Rewire\n                        near_node.parent = new_node\n                        near_node.cost = rewired_cost\n                        new_node.add_child(near_node)\n                        edges.append((new_node, near_node))\n\n            # Attempt to connect the new node to the opposite tree\n            conn_node, conn_cost = try_connect(new_node, tree_b)\n            if conn_node is not None and conn_cost < best_cost:\n                best_cost = conn_cost\n                best_connection = (new_node, conn_node)\n                success = True\n                # Early stop on improvement\n                break\n\n            # Periodic shortcutting to improve path if existing\n            if iteration % 100 == 0 and success and best_connection:\n                path = extract_path(best_connection[0], best_connection[1])\n                path = shortcut_path(path)\n                # Update best connection path to shortcut result\n                # Note: for simplicity, best_connection remains original nodes,\n                # will return shortcut path at the end\n                extracted_path = path\n\n        if success and best_connection:\n            extracted_path = extract_path(best_connection[0], best_connection[1])\n            extracted_path = shortcut_path(extracted_path)\n        else:\n            # Try partial connection if no solution found\n            min_cost = float('inf')\n            best_pair = None\n            for n1 in start_tree:\n                candidates = near(goal_tree, n1.position, self.step_size * 3.0)\n                for n2 in candidates:\n                    d = dist(n1.position, n2.position)\n                    if d <= self.step_size * 3.0 and not self._is_edge_in_obstacle(n1.position, n2.position, obstacles, is_3d):\n                        total_c = n1.cost + n2.cost + d\n                        if total_c < min_cost:\n                            min_cost = total_c\n                            best_pair = (n1, n2)\n            if best_pair:\n                extracted_path = extract_path(best_pair[0], best_pair[1])\n                extracted_path = shortcut_path(extracted_path)\n                success = True\n\n        return PlannerResult(\n            success=success,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=None):\n        # Set finer resolution based on step size or default 0.5 if not provided\n        import math\n        if resolution is None:\n            resolution = max(0.5, self.step_size / 5)\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -26.44459,
          "time_improvement": 27.0,
          "length_improvement": 17.0,
          "smoothness_improvement": 1657.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.018362045288085938,
                    "num_nodes_avg": 95.9,
                    "path_length_avg": 157.9445718033501,
                    "smoothness_avg": 0.03828957212971301,
                    "success_improvement": 0.0,
                    "time_improvement": 26.626201960864638,
                    "length_improvement": 13.428077402682579,
                    "smoothness_improvement": 499.3149509667044,
                    "objective_score": 18.54128178470246
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.0771651029586792,
                    "num_nodes_avg": 295.6,
                    "path_length_avg": 241.94613299404665,
                    "smoothness_avg": 0.1236608223702053,
                    "success_improvement": 0.0,
                    "time_improvement": 52.80832639768198,
                    "length_improvement": 19.231416773280305,
                    "smoothness_improvement": 3081.882028875528,
                    "objective_score": 42.79075812765041
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.04898715019226074,
                    "num_nodes_avg": 221.4,
                    "path_length_avg": 123.7035308979866,
                    "smoothness_avg": 0.1171036094758882,
                    "success_improvement": 0.0,
                    "time_improvement": 1.162572552550987,
                    "length_improvement": 17.8420049066961,
                    "smoothness_improvement": 1389.5492688439726,
                    "objective_score": 18.00172105400282
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "initial",
          "algorithm_description": "This algorithm enhances the standard BI-RRT by incorporating an optimization step that rewires nearby nodes to minimize cost, resulting in asymptotically optimal paths. It grows two trees\u2014one from the start and one from the goal\u2014and attempts to connect them while optimizing the path cost dynamically.",
          "planning_mechanism": "The planning mechanism includes sampling a random point, extending each tree toward it, rewiring neighbors within a radius to optimize the cost, and attempting to connect the two trees. When a connection is established, the combined path is extracted from both trees. Node validity and edge collision checks are strictly enforced throughout the process.",
          "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost: float = 0.0):\n        self.position = position              # Tuple[float, ...]\n        self.parent: Optional[\"Node\"] = parent\n        self.cost: float = cost\n        self.children: List[\"Node\"] = []\n        self.valid = True\n\n    def add_child(self, child_node: \"Node\"):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n\nclass Planner:\n    def __init__(\n        self,\n        max_iter: int = 5000,\n        step_size: float = 5.0,\n        gamma_rrt_star: float = 50.0,\n        max_radius: float = 60.0,\n    ):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.gamma_rrt_star = gamma_rrt_star\n        self.max_radius = max_radius\n\n    # ======================= Public API =======================\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        start_root = Node(start_position, parent=None, cost=0.0)\n        goal_root  = Node(goal_position,  parent=None, cost=0.0)\n        nodes.extend([start_root, goal_root])\n\n        tree_a: List[Node] = [start_root]\n        tree_b: List[Node] = [goal_root]\n\n        for _ in range(self.max_iter):\n            rand_point = self._sample_free(bounds, obstacles, is_3d)\n\n            new_a = self._extend_and_rewire(tree_a, rand_point, obstacles, is_3d, nodes, edges, bounds)\n            if new_a is None:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            new_b = self._connect_and_rewire(tree_b, new_a, obstacles, is_3d, nodes, edges, bounds)\n            if new_b:\n                success_state = True\n                path_a = new_a.path_from_root()\n                path_b = new_b.path_from_root()\n                if path_a and path_b and path_a[-1] == path_b[-1]:\n                    path_b = path_b[:-1]\n                extracted_path = path_a + path_b[::-1]\n                break\n\n            tree_a, tree_b = tree_b, tree_a\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        while True:\n            p = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    def _nearest(self, tree: List[Node], point):\n        return min(tree, key=lambda node: math.dist(node.position, point))\n\n    def _steer(self, from_pos, to_pos):\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _near_nodes(self, tree: List[Node], position, bounds) -> List[Node]:\n        n = max(1, len(tree))\n        d = len(position)\n        # \uacf5\uac04 \uc2a4\ucf00\uc77c\uc744 \uac04\ub2e8\ud788 bounds\ub85c \ucd94\uc815 (\uc815\ubc00 X, \uc2e4\uc6a9\uc801)\n        scale = max(1.0, sum(bounds) / d)\n        r_theory = self.gamma_rrt_star * ((math.log(n + 1) / (n + 1)) ** (1.0 / d))\n        radius = max(self.step_size * 2.0, min(self.max_radius, r_theory * 0.5 + scale * 0.02))\n        return [node for node in tree if math.dist(node.position, position) <= radius]\n\n    def _choose_parent_and_add(self, tree, new_pos, obstacles, is_3d, nodes, edges, bounds):\n        nearest = self._nearest(tree, new_pos)\n        neighbors = self._near_nodes(tree, new_pos, bounds)\n\n        min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n        best_parent = nearest\n\n        for nb in neighbors:\n            if not self._is_edge_in_obstacle(nb.position, new_pos, obstacles, is_3d):\n                cand = nb.cost + math.dist(nb.position, new_pos)\n                if cand < min_cost:\n                    min_cost = cand\n                    best_parent = nb\n\n        new_node = Node(new_pos, parent=None, cost=min_cost)\n        best_parent.add_child(new_node)\n        tree.append(new_node)\n        nodes.append(new_node)\n        edges.append((best_parent, new_node))\n        return new_node, neighbors\n\n    def _rewire_from(self, pivot: Node, neighbors: List[Node], obstacles, is_3d, edges):\n        for nb in neighbors:\n            if not self._is_edge_in_obstacle(pivot.position, nb.position, obstacles, is_3d):\n                new_cost = pivot.cost + math.dist(pivot.position, nb.position)\n                if new_cost + 1e-12 < nb.cost:  # \uc791\uc740 \uc218\uce58 \ubc84\ud37c\n                    if nb.parent is not None:\n                        try:\n                            edges.remove((nb.parent, nb))\n                        except ValueError:\n                            pass\n                        if nb in nb.parent.children:\n                            nb.parent.children.remove(nb)\n                    pivot.add_child(nb)\n                    nb.cost = new_cost\n                    edges.append((pivot, nb))\n\n    def _extend_and_rewire(self, tree, sample_point, obstacles, is_3d, nodes, edges, bounds):\n        nearest = self._nearest(tree, sample_point)\n        new_pos = self._steer(nearest.position, sample_point)\n\n        if self._is_in_obstacle(new_pos, obstacles, is_3d):\n            return None\n        if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n            return None\n\n        new_node, neighbors = self._choose_parent_and_add(tree, new_pos, obstacles, is_3d, nodes, edges, bounds)\n        self._rewire_from(new_node, neighbors, obstacles, is_3d, edges)\n        return new_node\n\n    def _connect_and_rewire(self, tree, target_node: Node, obstacles, is_3d, nodes, edges, bounds):\n        nearest = self._nearest(tree, target_node.position)\n\n        while True:\n            new_pos = self._steer(nearest.position, target_node.position)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                return None\n\n            connect_node, neighbors = self._choose_parent_and_add(tree, new_pos, obstacles, is_3d, nodes, edges, bounds)\n            self._rewire_from(connect_node, neighbors, obstacles, is_3d, edges)\n\n            if math.dist(connect_node.position, target_node.position) <= self.step_size:\n                if (not self._is_edge_in_obstacle(connect_node.position, target_node.position, obstacles, is_3d) and\n                    not self._is_in_obstacle(target_node.position, obstacles, is_3d)):\n                    final_node = Node(target_node.position, parent=None, cost=connect_node.cost + math.dist(connect_node.position, target_node.position))\n                    connect_node.add_child(final_node)\n                    tree.append(final_node)\n                    nodes.append(final_node)\n                    edges.append((connect_node, final_node))\n                    return final_node\n                else:\n                    return None\n\n            nearest = connect_node\n\n        \n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n        \n        \n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n",
          "objective": -26.116386668393563,
          "time_improvement": 59.0,
          "length_improvement": 12.0,
          "smoothness_improvement": 178.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.01048591136932373,
                    "num_nodes_avg": 55.0,
                    "path_length_avg": 161.06168019947768,
                    "smoothness_avg": 0.018734837295491497,
                    "success_improvement": 0.0,
                    "time_improvement": 58.09883207464661,
                    "length_improvement": 11.719540897021666,
                    "smoothness_improvement": 193.24088702478866,
                    "objective_score": 25.42757859573092
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.025601959228515624,
                    "num_nodes_avg": 202.1,
                    "path_length_avg": 260.76133699173454,
                    "smoothness_avg": 0.010239608160588953,
                    "success_improvement": 0.0,
                    "time_improvement": 84.34267230695025,
                    "length_improvement": 12.950360113232934,
                    "smoothness_improvement": 163.47249326360028,
                    "objective_score": 33.890380226342835
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.03202393054962158,
                    "num_nodes_avg": 227.8,
                    "path_length_avg": 131.686727202312,
                    "smoothness_avg": 0.021869076335319346,
                    "success_improvement": 0.0,
                    "time_improvement": 35.387894583416305,
                    "length_improvement": 12.539946040320416,
                    "smoothness_improvement": 178.1730367779587,
                    "objective_score": 19.031201183106933
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m2",
          "algorithm_description": "A balanced bidirectional RRT* planner with adaptive rewiring radius, enhanced goal-biased sampling, efficient nearest/neighbor queries using squared distances, iterative multi-candidate cross-tree connections, and progressive shortcutting for achieving improved planning time, path length, and smoothness within a 30-second limit.",
          "planning_mechanism": "The planner alternates growth between forward and backward trees, samples with increasing goal bias and limited retries, steers with fixed step size, rewires neighbors within a radius adapting to node density, attempts multiple connections to opposite tree nodes for cost optimization, applies repeated lightweight shortcutting during planning to refine path smoothness, and terminates early on time limit or improved solution, returning the best viable path.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float = 0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n        if parent:\n            parent.children.append(self)\n    def add_child(self, child):\n        self.children.append(child)\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, base_goal_sample_rate: float=0.2):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.time_limit = 30.0\n        self.base_goal_sample_rate = base_goal_sample_rate\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = dim == 3\n\n        start_tree = [Node(start_pos, cost=0.0)]\n        goal_tree = [Node(goal_pos, cost=0.0)]\n        nodes = start_tree[:] + goal_tree[:]\n        edges = []\n\n        best_connection = None\n        best_cost = float('inf')\n        success = False\n        extracted_path = []\n\n        def dist_sq(a, b):\n            s = 0.0\n            for i in range(dim):\n                d = a[i] - b[i]\n                s += d * d\n            return s\n\n        def dist(a, b):\n            return math.sqrt(dist_sq(a,b))\n\n        def sample_free(goal_bias):\n            if random.random() < goal_bias:\n                return goal_pos\n            for _ in range(30):\n                p = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n            return goal_pos\n\n        def nearest(tree, point):\n            best_node = None\n            best_dist = float('inf')\n            for node in tree:\n                d = dist_sq(node.position, point)\n                if d < best_dist:\n                    best_dist = d\n                    best_node = node\n            return best_node\n\n        def near(tree, point, radius):\n            r_sq = radius * radius\n            neighbors = []\n            for node in tree:\n                d = dist_sq(node.position, point)\n                if d <= r_sq:\n                    neighbors.append((d, node))\n            neighbors.sort(key=lambda x: x[0])\n            return [n[1] for n in neighbors]\n\n        def steer(from_p, to_p, max_step):\n            d = dist(from_p, to_p)\n            if d <= max_step:\n                return to_p\n            ratio = max_step / d\n            return tuple(from_p[i] + ratio * (to_p[i] - from_p[i]) for i in range(dim))\n\n        def extract_path(n_start, n_goal):\n            path_start = []\n            cur = n_start\n            while cur:\n                path_start.append(cur.position)\n                cur = cur.parent\n            path_goal = []\n            cur = n_goal\n            while cur:\n                path_goal.append(cur.position)\n                cur = cur.parent\n            # Avoid duplicate join point\n            return path_start[::-1] + path_goal\n\n        def shortcut_path(path, attempts=30, resolution=None):\n            if len(path) < 3:\n                return path\n            if resolution is None:\n                resolution = max(self.step_size / 5.0, 0.5)\n            for _ in range(attempts):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d, resolution):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        def try_connect(node, other_tree, radius):\n            candidates = near(other_tree, node.position, radius)\n            best_node = None\n            best_cost_local = float('inf')\n            for cnode in candidates:\n                d = dist(node.position, cnode.position)\n                if d <= radius and not self._is_edge_in_obstacle(node.position, cnode.position, obstacles, is_3d, resolution=self.step_size/5):\n                    total_cost = node.cost + cnode.cost + d\n                    if total_cost < best_cost_local:\n                        best_cost_local = total_cost\n                        best_node = cnode\n            return best_node, best_cost_local\n\n        def rewire(tree, new_node, neighbors):\n            for near_node in neighbors:\n                if near_node == new_node.parent:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, near_node.position)\n                if new_cost + 1e-9 < near_node.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d, resolution=self.step_size/5):\n                        if near_node.parent:\n                            try:\n                                edges.remove((near_node.parent, near_node))\n                            except ValueError:\n                                pass\n                            near_node.parent.remove_child(near_node)\n                        near_node.parent = new_node\n                        near_node.cost = new_cost\n                        new_node.add_child(near_node)\n                        edges.append((new_node, near_node))\n\n        start_time = time.monotonic()\n        gamma_rrt_star = 35.0\n\n        # Adaptive goal sample rate linearly increases from base to 0.5 over iterations\n        def adaptive_goal_sample_rate(iter_idx):\n            return min(self.base_goal_sample_rate + 0.3 * (iter_idx / self.max_iter), 0.5)\n\n        for it in range(self.max_iter):\n            current_time = time.monotonic()\n            if current_time - start_time > self.time_limit:\n                break\n\n            tree_a = start_tree if it % 2 == 0 else goal_tree\n            tree_b = goal_tree if it % 2 == 0 else start_tree\n\n            goal_bias = adaptive_goal_sample_rate(it)\n            q_rand = sample_free(goal_bias)\n\n            nearest_node = nearest(tree_a, q_rand)\n            q_new = steer(nearest_node.position, q_rand, self.step_size)\n\n            if self._is_in_obstacle(q_new, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, q_new, obstacles, is_3d, resolution=self.step_size/10):\n                continue\n\n            n_nodes = max(len(tree_a), 2)\n            radius = min(self.step_size * 5.0, gamma_rrt_star * (math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            radius = max(radius, self.step_size * 1.5)  # Minimum radius threshold\n\n            neighbors = near(tree_a, q_new, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, q_new)\n            min_parent = nearest_node\n            for near_n in neighbors:\n                cost_through = near_n.cost + dist(near_n.position, q_new)\n                if cost_through + 1e-9 < min_cost:\n                    if not self._is_edge_in_obstacle(near_n.position, q_new, obstacles, is_3d, resolution=self.step_size/10):\n                        min_cost = cost_through\n                        min_parent = near_n\n\n            new_node = Node(q_new, parent=min_parent, cost=min_cost)\n            min_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((min_parent, new_node))\n\n            rewire(tree_a, new_node, neighbors)\n\n            connect_radius = self.step_size * 4.0\n            conn_node, conn_cost = try_connect(new_node, tree_b, connect_radius)\n            if conn_node and conn_cost < best_cost:\n                best_cost = conn_cost\n                best_connection = (new_node, conn_node)\n                success = True\n                extracted_path = extract_path(new_node, conn_node)\n                # Progressive shortcutting\n                extracted_path = shortcut_path(extracted_path, attempts=40)\n                break\n\n            # Periodic shortcutting on best path found to improve smoothness & length progressively\n            if success and it % 100 == 0 and best_connection:\n                path = extract_path(best_connection[0], best_connection[1])\n                shortcut = shortcut_path(path, attempts=20)\n                if len(shortcut) < len(extracted_path) or \\\n                        sum(dist(shortcut[i], shortcut[i+1]) for i in range(len(shortcut) - 1)) + 1e-9 < \\\n                        sum(dist(extracted_path[i], extracted_path[i + 1]) for i in range(len(extracted_path) - 1)):\n                    extracted_path = shortcut\n\n        if not success:\n            # Attempt to find best connection between trees post search\n            best_pair = None\n            min_total = float('inf')\n            for n1 in start_tree:\n                candidates = near(goal_tree, n1.position, self.step_size * 4.0)\n                for n2 in candidates:\n                    d = dist(n1.position, n2.position)\n                    if d <= self.step_size * 4.0 and not self._is_edge_in_obstacle(n1.position, n2.position, obstacles, is_3d, resolution=self.step_size/10):\n                        total_c = n1.cost + n2.cost + d\n                        if total_c < min_total:\n                            min_total = total_c\n                            best_pair = (n1, n2)\n            if best_pair:\n                success = True\n                extracted_path = extract_path(best_pair[0], best_pair[1])\n                extracted_path = shortcut_path(extracted_path, attempts=50)\n\n        return PlannerResult(\n            success=success,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -24.9939,
          "time_improvement": 40.0,
          "length_improvement": 14.0,
          "smoothness_improvement": 898.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.020251083374023437,
                    "num_nodes_avg": 120.6,
                    "path_length_avg": 159.18824704749517,
                    "smoothness_avg": 0.03530194092180055,
                    "success_improvement": 0.0,
                    "time_improvement": 19.74890827631428,
                    "length_improvement": 12.746399294071296,
                    "smoothness_improvement": 452.5520348178664,
                    "objective_score": 15.835272233426393
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.07450652122497559,
                    "num_nodes_avg": 369.9,
                    "path_length_avg": 247.96811841622667,
                    "smoothness_avg": 0.04634272288256144,
                    "success_improvement": 0.0,
                    "time_improvement": 54.552752477032996,
                    "length_improvement": 17.221104706116957,
                    "smoothness_improvement": 1092.4316390823963,
                    "objective_score": 32.16064676219205
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.026442480087280274,
                    "num_nodes_avg": 185.5,
                    "path_length_avg": 132.12046483565678,
                    "smoothness_avg": 0.0980904466313902,
                    "success_improvement": 0.0,
                    "time_improvement": 46.32045066354195,
                    "length_improvement": 12.251878156619439,
                    "smoothness_improvement": 1147.7032408676555,
                    "objective_score": 26.985778297372526
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m1",
          "algorithm_description": "This algorithm is a bidirectional RRT* planner enhanced with adaptive neighborhood radius based on the number of nodes to balance rewiring efficiency and exploration speed. It grows two trees (from start and goal) by sampling the space, extending towards samples, rewiring locally to optimize path cost, and attempts connections between trees to find a feasible path quickly. The rewiring radius shrinks with node count to focus optimization locally as the tree grows. Once a connection is achieved, it extracts the shortest path connecting start and goal. The planner respects collision constraints for nodes and edges, enforces map boundaries, and stops if time limit or iteration limit is reached, returning the best path found.",
          "planning_mechanism": "The planner alternates growing start and goal trees by sampling random free points, steering nearest nodes toward samples with fixed step size, rewiring nearby nodes within a dynamically computed radius to minimize path cost, and tries connecting the trees when a new node is added. The radius shrinks with tree size to keep rewiring efficient. The planning stops upon reaching max iterations or 30 seconds. Upon success or timeout, the best found path from the connected trees is extracted by traversing parent links to the roots, composing a continuous path between start and goal.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n        import time\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = start_tree[:] + goal_tree[:]\n        edges = []\n\n        success = False\n        best_cost = float('inf')\n        best_connect = None\n\n        start_time = time.monotonic()\n        TIME_LIMIT = 30.0\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def sample_free():\n            while True:\n                p = tuple(random.uniform(0, bounds[i]) for i in range(len(bounds)))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: dist(n.position, point))\n\n        def near(tree, point, radius):\n            return [node for node in tree if dist(node.position, point) <= radius]\n\n        def steer(from_p, to_p, step):\n            d = dist(from_p, to_p)\n            if d <= step:\n                return to_p\n            ratio = step / d\n            return tuple(from_p[i] + (to_p[i] - from_p[i]) * ratio for i in range(len(from_p)))\n\n        def path_cost(node):\n            return node.cost\n\n        def extract_path(node_start, node_goal):\n            path_start = []\n            cur = node_start\n            while cur:\n                path_start.append(cur.position)\n                cur = cur.parent\n            path_goal = []\n            cur = node_goal\n            while cur:\n                path_goal.append(cur.position)\n                cur = cur.parent\n            return path_start[::-1] + path_goal\n\n        # Maintain mapping from position to Node for quick reference if needed\n        for iter_count in range(self.max_iter):\n            if time.monotonic() - start_time > TIME_LIMIT:\n                break\n\n            # Alternate trees: odd iter grow start_tree, even iter grow goal_tree\n            tree_a = start_tree if iter_count % 2 == 0 else goal_tree\n            tree_b = goal_tree if iter_count % 2 == 0 else start_tree\n\n            sample = sample_free()\n\n            nearest_node = nearest(tree_a, sample)\n            new_pos = steer(nearest_node.position, sample, self.step_size)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            # Radius adapted as per RRT* theory: gamma*(log(n)/n)^{1/d}\n            n = len(tree_a) + 1\n            d = len(bounds)\n            gamma = 30.0  # Tuned constant for neighborhood radius\n            radius = min(self.step_size * 5, gamma * (math.log(n) / n) ** (1 / d))\n\n            near_nodes = near(tree_a, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            min_parent = nearest_node\n            # Find best parent among neighbors\n            for near_node in near_nodes:\n                cost_through_near = near_node.cost + dist(near_node.position, new_pos)\n                if cost_through_near < min_cost and not self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d):\n                    min_cost = cost_through_near\n                    min_parent = near_node\n\n            new_node = Node(new_pos, parent=min_parent, cost=min_cost)\n            min_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((min_parent, new_node))\n\n            # Rewire neighbors if better through new_node\n            for near_node in near_nodes:\n                if near_node == min_parent:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, near_node.position)\n                if new_cost < near_node.cost and not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                    if near_node.parent:\n                        try:\n                            edges.remove((near_node.parent, near_node))\n                        except ValueError:\n                            pass\n                        near_node.parent.children.remove(near_node)\n                    near_node.parent = new_node\n                    near_node.cost = new_cost\n                    new_node.add_child(near_node)\n                    edges.append((new_node, near_node))\n\n            # Attempt to connect to other tree\n            nearest_to_new_in_other = nearest(tree_b, new_node.position)\n            dist_between = dist(new_node.position, nearest_to_new_in_other.position)\n            if dist_between <= self.step_size:\n                if not self._is_edge_in_obstacle(new_node.position, nearest_to_new_in_other.position, obstacles, is_3d):\n                    # Connection found\n                    candidate_cost = new_node.cost + nearest_to_new_in_other.cost + dist_between\n                    if candidate_cost < best_cost:\n                        best_cost = candidate_cost\n                        best_connect = (new_node, nearest_to_new_in_other)\n                        success = True\n                        # Stop early on first solution\n                        break\n\n        extracted_path = []\n        if success and best_connect is not None:\n            extracted_path = extract_path(best_connect[0], best_connect[1])\n\n        # If no success but time/iter limit reached, try to find best partial connection\n        if not success:\n            # Attempt to find minimal-cost connection between trees\n            min_cost = float('inf')\n            best_pair = None\n            for n1 in start_tree:\n                # Nearest node in goal_tree\n                n2 = min(goal_tree, key=lambda node: dist(n1.position, node.position))\n                d12 = dist(n1.position, n2.position)\n                if d12 <= self.step_size:\n                    if not self._is_edge_in_obstacle(n1.position, n2.position, obstacles, is_3d):\n                        cost_sum = n1.cost + n2.cost + d12\n                        if cost_sum < min_cost:\n                            min_cost = cost_sum\n                            best_pair = (n1, n2)\n            if best_pair is not None:\n                extracted_path = extract_path(best_pair[0], best_pair[1])\n                success = True\n\n        return PlannerResult(\n            success=success,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -24.50215,
          "time_improvement": 67.0,
          "length_improvement": 6.0,
          "smoothness_improvement": 140.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.009191942214965821,
                    "num_nodes_avg": 110.2,
                    "path_length_avg": 170.91077029046983,
                    "smoothness_avg": 0.01777274497333912,
                    "success_improvement": 0.0,
                    "time_improvement": 63.26946693101152,
                    "length_improvement": 6.321098549329074,
                    "smoothness_improvement": 178.1820529661874,
                    "objective_score": 23.664409473731837
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.02384507656097412,
                    "num_nodes_avg": 292.0,
                    "path_length_avg": 282.72493325276366,
                    "smoothness_avg": 0.008011301853497212,
                    "success_improvement": 0.0,
                    "time_improvement": 85.41712475015616,
                    "length_improvement": 5.618279494235603,
                    "smoothness_improvement": 106.13656699797079,
                    "objective_score": 29.52678795657806
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.023160457611083984,
                    "num_nodes_avg": 291.8,
                    "path_length_avg": 141.37742625459262,
                    "smoothness_avg": 0.018422059860500224,
                    "success_improvement": 0.0,
                    "time_improvement": 53.271010054655534,
                    "length_improvement": 6.10384515129628,
                    "smoothness_improvement": 134.3272416505493,
                    "objective_score": 20.31524631542717
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "A simplified bidirectional RRT* planner employing uniform random sampling with retry limits, fixed step steering, adaptive rewiring radius shrinking with the number of nodes, and intermittent randomized shortcutting to balance planning time, path length, and smoothness. The planner alternately expands trees from start and goal, rewires neighbors locally to minimize cost, attempts connections between trees, and returns the best path found within a strict 30-second limit.",
          "planning_mechanism": "The planner performs uniform random sample generation with a capped number of retries to avoid costly sampling in obstacle-dense maps, extends nearest nodes by a fixed step size if collision-free, rewires neighbors within an adaptively shrinking radius based on the current tree size to improve path cost, connects newly added nodes to the opposite tree if collision-free to form the solution, and applies periodic randomized shortcutting on the resultant path to improve smoothness before returning.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.time_limit = 30.0\n\n    def plan(self, map):\n        import time\n        import math\n        import random\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def in_obstacle(pos):\n            for o in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = o\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w_, h_ = o\n                    px, py = pos\n                    if x <= px <= x + w_ and y <= py <= y + h_:\n                        return True\n            return False\n\n        def edge_in_obstacle(a, b, resolution=0.5):\n            dist = math.dist(a, b)\n            steps = max(1, int(dist / resolution))\n            for i in range(steps + 1):\n                interp = tuple(a[d] + (b[d] - a[d]) * i / steps for d in range(dim))\n                if in_obstacle(interp):\n                    return True\n            return False\n\n        def steer(from_p, to_p):\n            dist = math.dist(from_p, to_p)\n            if dist <= self.step_size:\n                return to_p\n            r = self.step_size / dist\n            return tuple(from_p[i] + r * (to_p[i] - from_p[i]) for i in range(dim))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: math.dist(n.position, point))\n\n        def neighbors(tree, pos, radius):\n            r2 = radius * radius\n            return [n for n in tree if sum((n.position[i] - pos[i])**2 for i in range(dim)) <= r2]\n\n        def propagate_cost(node):\n            for c in node.children:\n                new_cost = node.cost + math.dist(node.position, c.position)\n                if new_cost < c.cost:\n                    c.cost = new_cost\n                    propagate_cost(c)\n\n        def rewire(tree, new_node, radius):\n            for nbr in neighbors(tree, new_node.position, radius):\n                if nbr is new_node.parent:\n                    continue\n                if not edge_in_obstacle(new_node.position, nbr.position):\n                    new_cost = new_node.cost + math.dist(new_node.position, nbr.position)\n                    if new_cost + 1e-9 < nbr.cost:  # numerical tolerance\n                        nbr.update_parent(new_node, new_cost)\n                        propagate_cost(nbr)\n\n        def extract_path(n_start, n_goal):\n            path_start = []\n            cur = n_start\n            while cur:\n                path_start.append(cur.position)\n                cur = cur.parent\n            path_goal = []\n            cur = n_goal\n            while cur:\n                path_goal.append(cur.position)\n                cur = cur.parent\n            return path_start[::-1] + path_goal\n\n        def sample_free(max_tries=30):\n            for _ in range(max_tries):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not in_obstacle(p):\n                    return p\n            return goal_pos  # fallback\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            max_attempts = 100\n            for _ in range(max_attempts):\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if not edge_in_obstacle(path[i], path[j]):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        start_tree = [Node(start_pos, cost=0.0)]\n        goal_tree = [Node(goal_pos, cost=0.0)]\n        all_nodes = start_tree + goal_tree\n        edges = []\n\n        best_cost = float('inf')\n        best_pair = None\n        success = False\n        result_path = []\n\n        start_time = time.monotonic()\n\n        for iteration in range(self.max_iter):\n            if time.monotonic() - start_time > self.time_limit:\n                break\n\n            tree_a, tree_b = (start_tree, goal_tree) if iteration % 2 == 0 else (goal_tree, start_tree)\n\n            sample = sample_free()\n            nearest_node = nearest(tree_a, sample)\n            new_pos = steer(nearest_node.position, sample)\n\n            if in_obstacle(new_pos) or edge_in_obstacle(nearest_node.position, new_pos):\n                continue\n\n            new_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            new_node = Node(new_pos, nearest_node, new_cost)\n            nearest_node.add_child(new_node)\n            tree_a.append(new_node)\n            all_nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n\n            n = len(tree_a)\n            radius = min(self.step_size * 10, self.step_size * (math.log(max(n,2)) / max(n,2)) ** (1 / dim))\n            rewire(tree_a, new_node, radius)\n\n            nearest_other = nearest(tree_b, new_pos)\n            if not edge_in_obstacle(new_pos, nearest_other.position):\n                total_cost = new_node.cost + nearest_other.cost + math.dist(new_pos, nearest_other.position)\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pair = (new_node, nearest_other)\n                    edges.append((new_node, nearest_other))\n                    result_path = extract_path(new_node, nearest_other)\n                    result_path = shortcut_path(result_path)\n                    success = True\n                    break\n\n        if not success and best_pair:\n            result_path = extract_path(best_pair[0], best_pair[1])\n            result_path = shortcut_path(result_path)\n            success = True\n\n        return PlannerResult(\n            success=success,\n            path=result_path,\n            nodes=all_nodes,\n            edges=edges\n        )",
          "objective": -24.03211,
          "time_improvement": 31.0,
          "length_improvement": 12.0,
          "smoothness_improvement": 1548.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.026597762107849122,
                    "num_nodes_avg": 111.7,
                    "path_length_avg": 172.3918569938552,
                    "smoothness_avg": 0.046426392817485854,
                    "success_improvement": 0.0,
                    "time_improvement": -5.4017410890593345,
                    "length_improvement": 5.509291457882858,
                    "smoothness_improvement": 626.6738641192812,
                    "objective_score": 4.818421868608321
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.03292849063873291,
                    "num_nodes_avg": 232.7,
                    "path_length_avg": 245.15576151695177,
                    "smoothness_avg": 0.10954518614085582,
                    "success_improvement": 0.0,
                    "time_improvement": 79.91438547912574,
                    "length_improvement": 18.159950388299915,
                    "smoothness_improvement": 2718.676541612546,
                    "objective_score": 48.46366858478041
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.040723347663879396,
                    "num_nodes_avg": 263.9,
                    "path_length_avg": 132.70824873952333,
                    "smoothness_avg": 0.11003937200953669,
                    "success_improvement": 0.0,
                    "time_improvement": 17.329579417155625,
                    "length_improvement": 11.861500074933032,
                    "smoothness_improvement": 1299.6926896997518,
                    "objective_score": 18.814237318605265
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "A simplified bidirectional RRT planner that grows two trees alternately from start and goal positions by extending towards random collision-free samples with a fixed step size. It performs straightforward nearest neighbor searches via linear scans, validates nodes and edges for collisions, attempts to directly connect the trees after each extension, and stops early upon successful connection or time limit. This minimalistic approach prioritizes robustness, generalization, and computational efficiency without rewiring or adaptive parameters.",
          "planning_mechanism": "The planner samples collision-free points within map bounds, extends the nearest node in the active tree toward the sample with fixed step length, checks collisions for nodes and edges, alternates tree expansions, and tries to connect the two trees after each new node insertion. It returns the best path found within a 30-second limit or earlier if connection succeeds.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\nclass Planner:\n    def __init__(self, max_iter: int=5000, step_size: float=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.time_limit = 30.0  # seconds\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def in_obstacle(pos):\n            for o in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d = o\n                    px,py,pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x,y,w_,h_ = o\n                    px,py = pos\n                    if x <= px <= x + w_ and y <= py <= y + h_:\n                        return True\n            return False\n\n        def edge_in_obstacle(a,b,resolution=1.0):\n            dist = math.dist(a,b)\n            steps = max(1,int(dist/resolution))\n            for i in range(steps+1):\n                interp = tuple(a[d] + (b[d]-a[d]) * (i/steps) for d in range(dim))\n                if in_obstacle(interp):\n                    return True\n            return False\n\n        def steer(from_p, to_p):\n            dist = math.dist(from_p, to_p)\n            if dist <= self.step_size:\n                return to_p\n            ratio = self.step_size / dist\n            return tuple(from_p[i] + ratio*(to_p[i]-from_p[i]) for i in range(dim))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: math.dist(n.position, point))\n\n        def extract_path(node_start, node_goal):\n            path_start, path_goal = [], []\n            c = node_start\n            while c is not None:\n                path_start.append(c.position)\n                c = c.parent\n            c = node_goal\n            while c is not None:\n                path_goal.append(c.position)\n                c = c.parent\n            return path_start[::-1] + path_goal\n\n        start_tree = [Node(start_pos, cost=0.0)]\n        goal_tree = [Node(goal_pos, cost=0.0)]\n        all_nodes = start_tree + goal_tree\n        edges = []\n\n        best_cost = float('inf')\n        best_pair = None\n        success = False\n        result_path = []\n\n        start_time = time.monotonic()\n\n        for i in range(self.max_iter):\n            if time.monotonic() - start_time > self.time_limit:\n                break\n\n            # Alternate trees\n            tree_a, tree_b = (start_tree, goal_tree) if i % 2 == 0 else (goal_tree, start_tree)\n\n            # Sample free point\n            while True:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not in_obstacle(sample):\n                    break\n\n            nearest_node = nearest(tree_a, sample)\n            new_pos = steer(nearest_node.position, sample)\n            if in_obstacle(new_pos) or edge_in_obstacle(nearest_node.position, new_pos):\n                continue\n\n            new_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            new_node = Node(new_pos, nearest_node, new_cost)\n            nearest_node.add_child(new_node)\n            tree_a.append(new_node)\n            all_nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n\n            nearest_other = nearest(tree_b, new_pos)\n            if not edge_in_obstacle(new_pos, nearest_other.position):\n                total_cost = new_node.cost + nearest_other.cost + math.dist(new_pos, nearest_other.position)\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pair = (new_node, nearest_other)\n                    edges.append((new_node, nearest_other))\n                    result_path = extract_path(new_node, nearest_other)\n                    success = True\n                    break\n\n        if not success and best_pair:\n            result_path = extract_path(best_pair[0], best_pair[1])\n            success = True\n\n        return PlannerResult(success=success, path=result_path, nodes=all_nodes, edges=edges)",
          "objective": -22.62921,
          "time_improvement": 80.0,
          "length_improvement": -3.0,
          "smoothness_improvement": 84.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.009570622444152832,
                    "num_nodes_avg": 106.8,
                    "path_length_avg": 192.76832085666933,
                    "smoothness_avg": 0.011343034743691166,
                    "success_improvement": 0.0,
                    "time_improvement": 62.073490813648306,
                    "length_improvement": -5.659371271057874,
                    "smoothness_improvement": 77.5431255329582,
                    "objective_score": 15.614140109124559
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.011603641510009765,
                    "num_nodes_avg": 208.9,
                    "path_length_avg": 295.1488835150884,
                    "smoothness_avg": 0.007552260121122536,
                    "success_improvement": 0.0,
                    "time_improvement": 92.92204817507421,
                    "length_improvement": 1.4708072930911686,
                    "smoothness_improvement": 94.32509258957488,
                    "objective_score": 29.230724291324837
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.006852197647094727,
                    "num_nodes_avg": 156.5,
                    "path_length_avg": 158.5518616309143,
                    "smoothness_avg": 0.014110569175713206,
                    "success_improvement": 0.0,
                    "time_improvement": 86.08969807498055,
                    "length_improvement": -5.302597066927146,
                    "smoothness_improvement": 79.48539838119697,
                    "objective_score": 23.04277817424386
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "This algorithm implements a straightforward bidirectional RRT planner prioritizing general applicability and simplicity for 2D/3D pathfinding. It grows two trees alternately from start and goal positions by extending the nearest node toward randomly sampled free points using fixed step sizes. No rewiring or adaptive radius heuristics are applied, improving robustness and generalization. After adding new nodes, it attempts to connect the two trees directly to form a complete path. The planner terminates early if a valid path is found or a hard 30-second limit is reached, returning the best feasible path found so far.",
          "planning_mechanism": "The planner samples random free points within bounds, extends nearest nodes of alternating trees in fixed increments toward samples, and upon each new node insertion attempts to connect the other tree. Collision checks ensure all nodes and edges are obstacle-free. Planning stops early on a successful tree connection or when time expires, guaranteeing timely and general-purpose pathfinding.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.time_limit = 30.0\n\n    def plan(self, map):\n        import time\n        import math\n        import random\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def in_obstacle(pos):\n            for o in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = o\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w_, h_ = o\n                    px, py = pos\n                    if x <= px <= x + w_ and y <= py <= y + h_:\n                        return True\n            return False\n\n        def edge_in_obstacle(a, b, resolution=1.0):\n            dist = math.dist(a, b)\n            steps = max(1, int(dist / resolution))\n            for i in range(steps + 1):\n                interp = tuple(a[d] + (b[d] - a[d]) * (i / steps) for d in range(dim))\n                if in_obstacle(interp):\n                    return True\n            return False\n\n        def steer(from_p, to_p):\n            dist = math.dist(from_p, to_p)\n            if dist <= self.step_size:\n                return to_p\n            r = self.step_size / dist\n            return tuple(from_p[i] + r * (to_p[i] - from_p[i]) for i in range(dim))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: math.dist(n.position, point))\n\n        def extract_path(node_start, node_goal):\n            path_start = []\n            cur = node_start\n            while cur is not None:\n                path_start.append(cur.position)\n                cur = cur.parent\n            path_goal = []\n            cur = node_goal\n            while cur is not None:\n                path_goal.append(cur.position)\n                cur = cur.parent\n            return path_start[::-1] + path_goal\n\n        start_tree = [Node(start_pos, cost=0.0)]\n        goal_tree = [Node(goal_pos, cost=0.0)]\n        all_nodes = start_tree + goal_tree\n        edges = []\n\n        best_cost = float('inf')\n        best_pair = None\n        success = False\n        result_path = []\n\n        start_time = time.monotonic()\n\n        for i in range(self.max_iter):\n            if time.monotonic() - start_time > self.time_limit:\n                break\n\n            tree_a, tree_b = (start_tree, goal_tree) if i % 2 == 0 else (goal_tree, start_tree)\n\n            # sample free point\n            for _ in range(100):  # limit attempts to avoid infinite loop\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not in_obstacle(sample):\n                    break\n            else:\n                continue  # failed to sample free point; skip iteration\n\n            nearest_node = nearest(tree_a, sample)\n            new_pos = steer(nearest_node.position, sample)\n\n            if in_obstacle(new_pos) or edge_in_obstacle(nearest_node.position, new_pos):\n                continue\n\n            new_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            new_node = Node(new_pos, nearest_node, new_cost)\n            nearest_node.add_child(new_node)\n            tree_a.append(new_node)\n            all_nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n\n            nearest_other = nearest(tree_b, new_pos)\n            if not edge_in_obstacle(new_pos, nearest_other.position):\n                total_cost = new_node.cost + nearest_other.cost + math.dist(new_pos, nearest_other.position)\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pair = (new_node, nearest_other)\n                    edges.append((new_node, nearest_other))\n                    result_path = extract_path(new_node, nearest_other)\n                    success = True\n                    break\n\n        if not success and best_pair:\n            result_path = extract_path(best_pair[0], best_pair[1])\n            success = True\n\n        return PlannerResult(\n            success=success,\n            path=result_path,\n            nodes=all_nodes,\n            edges=edges\n        )",
          "objective": -22.40292,
          "time_improvement": 80.0,
          "length_improvement": -4.0,
          "smoothness_improvement": 84.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.009536957740783692,
                    "num_nodes_avg": 118.6,
                    "path_length_avg": 192.59619741246652,
                    "smoothness_avg": 0.011420369656766056,
                    "success_improvement": 0.0,
                    "time_improvement": 61.89080245684468,
                    "length_improvement": -5.565027683819801,
                    "smoothness_improvement": 78.75358485803187,
                    "objective_score": 15.621992051051683
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.011902427673339844,
                    "num_nodes_avg": 220.1,
                    "path_length_avg": 301.413123636028,
                    "smoothness_avg": 0.007188592015571945,
                    "success_improvement": 0.0,
                    "time_improvement": 92.720861369987,
                    "length_improvement": -0.6203763654329967,
                    "smoothness_improvement": 84.96765029420942,
                    "objective_score": 27.868870843207354
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.006809234619140625,
                    "num_nodes_avg": 142.4,
                    "path_length_avg": 157.08076258922875,
                    "smoothness_avg": 0.014697771057838723,
                    "success_improvement": 0.0,
                    "time_improvement": 86.26155573450168,
                    "length_improvement": -4.325563129648229,
                    "smoothness_improvement": 86.95456297909918,
                    "objective_score": 23.717901657457062
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "cross_over",
          "algorithm_description": "An optimized bidirectional RRT*-based planner incorporating goal biasing, dynamic adaptive rewiring radius, efficient incremental collision checking with adaptive resolution, and iterative shortcutting for path smoothing. The algorithm uses alternating tree expansions with improved nearest neighbor searches and multiple candidate connections to accelerate convergence, maintaining a strict 30-second limit. Continuous path cost tracking and rewiring ensure near-optimal path lengths while lightweight shortcutting improves smoothness and reduces unnecessary waypoints. Early termination on time or successful path discovery guarantees computational efficiency.",
          "planning_mechanism": "The planner grows two trees from start and goal, sampling mostly free space with goal bias. It extends nodes toward samples using a fine step size, rewires nearby nodes within a dynamically shrinking neighborhood radius computed from node count and dimension, attempts multiple connection candidates between trees, and upon connection applies iterative shortcutting. Collision checks adapt resolution based on edge length for efficiency. The planner updates best path continuously and returns the best feasible path if time expires.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children: List[Node] = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=4.0, goal_sample_rate: float=0.2):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.time_limit = 30.0\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        start_tree = [Node(start_pos, cost=0.0)]\n        goal_tree = [Node(goal_pos, cost=0.0)]\n        nodes = start_tree[:] + goal_tree[:]\n        edges = []\n\n        gamma_rrt_star = 20.0  # Smaller gamma for adaptive radius to reduce neighbor overhead\n\n        success = False\n        best_cost = float('inf')\n        best_connection = None\n        extracted_path: List[Tuple[float,...]] = []\n\n        step_size = self.step_size\n\n        def dist(a, b):\n            # Euclidean distance\n            return math.dist(a, b)\n\n        def sample_free():\n            # Goal biasing sampler with max 30 attempts\n            if random.random() < self.goal_sample_rate:\n                return goal_pos\n            for _ in range(30):\n                p = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n            return goal_pos  # fallback\n\n        def nearest(tree, point):\n            min_node = None\n            min_dist = float('inf')\n            for node in tree:\n                d = dist(node.position, point)\n                if d < min_dist:\n                    min_dist = d\n                    min_node = node\n            return min_node\n\n        def near(tree, point, radius):\n            neighbors = []\n            for node in tree:\n                d = dist(node.position, point)\n                if d <= radius:\n                    neighbors.append((d, node))\n            neighbors.sort(key=lambda x: x[0])\n            return [n[1] for n in neighbors]\n\n        def steer(from_p, to_p, max_step):\n            d = dist(from_p, to_p)\n            if d <= max_step:\n                return to_p\n            ratio = max_step / d\n            return tuple(from_p[i] + (to_p[i] - from_p[i]) * ratio for i in range(dim))\n\n        def extract_path(node_start, node_goal):\n            # Trace back parents from start node to root\n            path_start = []\n            c = node_start\n            while c is not None:\n                path_start.append(c.position)\n                c = c.parent\n            # Trace back parents from goal node to root\n            path_goal = []\n            c = node_goal\n            while c is not None:\n                path_goal.append(c.position)\n                c = c.parent\n            return path_start[::-1] + path_goal\n\n        def shortcut_path(path):\n            # Iterative shortcutting tries 100 times to connect random pairs with collision-free edges\n            if len(path) < 3:\n                return path\n            for _ in range(100):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d,\n                        resolution=max(0.1,self.step_size*0.05)):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        def adaptive_edge_resolution(p1, p2):\n            # Edge collision check resolution adapts from edge length, min 0.1, max step_size/3\n            length = dist(p1, p2)\n            return max(0.1, min(self.step_size/3, length/10))\n\n        def try_connect(new_node, other_tree):\n            # Get multiple near candidates in other tree within connection radius\n            connection_radius = self.step_size * 2.5\n            candidates = near(other_tree, new_node.position, connection_radius)\n            best_node = None\n            best_cost_local = float('inf')\n            for cnode in candidates:\n                d = dist(new_node.position, cnode.position)\n                if d <= connection_radius:\n                    if not self._is_edge_in_obstacle(new_node.position, cnode.position, obstacles, is_3d,\n                                                    resolution=adaptive_edge_resolution(new_node.position,cnode.position)):\n                        total_cost = new_node.cost + cnode.cost + d\n                        if total_cost < best_cost_local:\n                            best_cost_local = total_cost\n                            best_node = cnode\n            return best_node, best_cost_local\n\n        start_time = time.monotonic()\n        for iter_count in range(self.max_iter):\n            if time.monotonic() - start_time > self.time_limit:\n                break\n\n            # Alternate tree growth\n            tree_a = start_tree if iter_count % 2 == 0 else goal_tree\n            tree_b = goal_tree if iter_count % 2 == 0 else start_tree\n\n            sample = sample_free()\n            nearest_node = nearest(tree_a, sample)\n            new_pos = steer(nearest_node.position, sample, step_size)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d,\n                                         resolution=adaptive_edge_resolution(nearest_node.position, new_pos)):\n                continue\n\n            n_nodes = len(tree_a) + 1\n            radius = min(step_size * 5, gamma_rrt_star * (math.log(n_nodes) / n_nodes) ** (1/dim))\n\n            near_nodes = near(tree_a, new_pos, radius)\n\n            # Choose best parent (minimum cost)\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            min_parent = nearest_node\n            for near_node in near_nodes:\n                cost_through = near_node.cost + dist(near_node.position, new_pos)\n                if cost_through < min_cost:\n                    if not self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d,\n                                                    resolution=adaptive_edge_resolution(near_node.position,new_pos)):\n                        min_cost = cost_through\n                        min_parent = near_node\n\n            new_node = Node(new_pos, parent=min_parent, cost=min_cost)\n            min_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((min_parent, new_node))\n\n            # Rewire neighbors with better cost paths\n            for near_node in near_nodes:\n                if near_node == min_parent:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, near_node.position)\n                if new_cost < near_node.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d,\n                                                    resolution=adaptive_edge_resolution(new_node.position, near_node.position)):\n                        # Remove old edge safely\n                        if near_node.parent:\n                            try:\n                                edges.remove((near_node.parent, near_node))\n                            except ValueError:\n                                pass\n                            near_node.parent.remove_child(near_node)\n                        near_node.parent = new_node\n                        near_node.cost = new_cost\n                        new_node.add_child(near_node)\n                        edges.append((new_node, near_node))\n\n            # Attempt multiple candidate connection to other tree\n            conn_node, conn_cost = try_connect(new_node, tree_b)\n            if conn_node and conn_cost < best_cost:\n                best_cost = conn_cost\n                best_connection = (new_node, conn_node)\n                success = True\n                # Early stopping here for efficiency\n                break\n\n        if success and best_connection is not None:\n            path = extract_path(best_connection[0], best_connection[1])\n            path = shortcut_path(path)\n            extracted_path = path\n        else:\n            # Attempt best partial connection on timeout or failure\n            min_cost = float('inf')\n            best_pair = None\n            for n1 in start_tree:\n                candidates = near(goal_tree, n1.position, step_size * 2.5)\n                for n2 in candidates:\n                    d12 = dist(n1.position, n2.position)\n                    if d12 <= step_size * 2.5:\n                        if not self._is_edge_in_obstacle(n1.position, n2.position, obstacles, is_3d,\n                                                        resolution=adaptive_edge_resolution(n1.position, n2.position)):\n                            total_cost = n1.cost + n2.cost + d12\n                            if total_cost < min_cost:\n                                min_cost = total_cost\n                                best_pair = (n1, n2)\n            if best_pair is not None:\n                path = extract_path(best_pair[0], best_pair[1])\n                path = shortcut_path(path)\n                extracted_path = path\n                success = True\n\n        return PlannerResult(\n            success=success,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -21.99245,
          "time_improvement": 20.0,
          "length_improvement": 14.0,
          "smoothness_improvement": 1523.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.03138778209686279,
                    "num_nodes_avg": 163.2,
                    "path_length_avg": 167.21015564949224,
                    "smoothness_avg": 0.04103033539568809,
                    "success_improvement": 0.0,
                    "time_improvement": -25.423979101386283,
                    "length_improvement": 8.349464074040423,
                    "smoothness_improvement": 542.213847741906,
                    "objective_score": 0.09355395271789968
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.053638553619384764,
                    "num_nodes_avg": 436.8,
                    "path_length_avg": 246.5065194564645,
                    "smoothness_avg": 0.10805898201144767,
                    "success_improvement": 0.0,
                    "time_improvement": 67.19640073231147,
                    "length_improvement": 17.709028508679005,
                    "smoothness_improvement": 2680.435438893309,
                    "objective_score": 44.18651451936739
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.040125346183776854,
                    "num_nodes_avg": 359.0,
                    "path_length_avg": 127.36695570951193,
                    "smoothness_avg": 0.11382510858983455,
                    "success_improvement": 0.0,
                    "time_improvement": 19.042320758038862,
                    "length_improvement": 15.40893258042441,
                    "smoothness_improvement": 1347.8469795671333,
                    "objective_score": 21.69729067350197
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m2",
          "algorithm_description": "This algorithm implements a bidirectional RRT* planner with refined parameters for step size, sampling bias, rewiring radius, and connection attempts. It incorporates bounded sampling retries, dynamic rewiring radius adapted to node count and dimension, multi-neighbor connections between trees, and iterative path shortcutting triggered at fixed iteration intervals to improve path smoothness and length without sacrificing planning efficiency. The algorithm stops early upon finding a sufficient solution or after a 30-second timeout, always returning the best path discovered.",
          "planning_mechanism": "The planner alternately grows two trees from start and goal by sampling with a goal bias and retry limit, steering towards sampled points with a tuned step size. Nodes connect and rewire according to an adaptive radius computed logarithmically with node count and dimension, improving path quality progressively. Upon each new node addition, multiple candidate connections are attempted with the opposite tree within an extended radius to boost connectivity. Shortcuts are applied every 100 iterations on the best current path to smooth and shorten it. The planner executes until a path connects both trees or a 30-second time limit is reached, outputting the best path found with its nodes and edges.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=6.0, goal_sample_rate=0.25):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.time_limit = 30.0\n        self.sample_retry_limit = 30\n\n    def plan(self, map):\n        import time\n        import math\n        import random\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def dist_sq(a, b):\n            return sum((a[i] - b[i]) ** 2 for i in range(dim))\n\n        def sample_free():\n            if random.random() < self.goal_sample_rate:\n                return goal_pos\n            for _ in range(self.sample_retry_limit):\n                p = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n            return goal_pos\n\n        def steer(from_p, to_p, max_step):\n            d = dist(from_p, to_p)\n            if d <= max_step:\n                return to_p\n            ratio = max_step / d\n            return tuple(from_p[i] + (to_p[i] - from_p[i]) * ratio for i in range(dim))\n\n        def nearest(tree, point):\n            best_node = None\n            best_dist_sq = float('inf')\n            for node in tree:\n                d2 = dist_sq(node.position, point)\n                if d2 < best_dist_sq:\n                    best_dist_sq = d2\n                    best_node = node\n            return best_node\n\n        def near(tree, point, radius):\n            r_sq = radius * radius\n            near_nodes = [(dist_sq(n.position, point), n) for n in tree if dist_sq(n.position, point) <= r_sq]\n            near_nodes.sort(key=lambda x: x[0])\n            return [n for _, n in near_nodes]\n\n        def extract_path(node_start, node_goal):\n            path_start = []\n            current = node_start\n            while current:\n                path_start.append(current.position)\n                current = current.parent\n            path_goal = []\n            current = node_goal\n            while current:\n                path_goal.append(current.position)\n                current = current.parent\n            return path_start[::-1] + path_goal\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            attempts = 0\n            max_attempts = 100\n            resolution = max(0.2, self.step_size * 0.1)\n            while attempts < max_attempts and len(path) >= 3:\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d, resolution=resolution):\n                    path = path[:i + 1] + path[j:]\n                attempts += 1\n            return path\n\n        def update_parent(child, new_parent, new_cost):\n            if child.parent is not None:\n                try:\n                    edges.remove((child.parent, child))\n                except ValueError:\n                    pass\n                child.parent.remove_child(child)\n            child.parent = new_parent\n            child.cost = new_cost\n            new_parent.add_child(child)\n            edges.append((new_parent, child))\n\n        def propagate_costs(node):\n            stack = [node]\n            while stack:\n                current = stack.pop()\n                for c in current.children:\n                    new_cost = current.cost + dist(current.position, c.position)\n                    if abs(new_cost - c.cost) > 1e-12:\n                        c.cost = new_cost\n                        stack.append(c)\n\n        def try_connect(new_node, other_tree, connect_radius):\n            candidates = near(other_tree, new_node.position, connect_radius)\n            best_node = None\n            best_cost = float('inf')\n            for c in candidates:\n                edge_dist = dist(new_node.position, c.position)\n                if edge_dist <= connect_radius:\n                    if not self._is_edge_in_obstacle(new_node.position, c.position, obstacles, is_3d):\n                        total_cost = new_node.cost + c.cost + edge_dist\n                        if total_cost < best_cost:\n                            best_cost = total_cost\n                            best_node = c\n            return best_node, best_cost\n\n        start_tree = [Node(start_pos, cost=0.0)]\n        goal_tree = [Node(goal_pos, cost=0.0)]\n        nodes = start_tree[:] + goal_tree[:]\n        edges = []\n        gamma_rrt_star = 30.0\n        best_connection = None\n        best_cost = float('inf')\n        success = False\n        extracted_path = []\n\n        start_time = time.monotonic()\n\n        for iteration in range(self.max_iter):\n            if time.monotonic() - start_time > self.time_limit:\n                break\n\n            # Alternate between trees\n            if iteration % 2 == 0:\n                tree_a, tree_b = start_tree, goal_tree\n            else:\n                tree_a, tree_b = goal_tree, start_tree\n\n            sample = sample_free()\n            nearest_node = nearest(tree_a, sample)\n            new_pos = steer(nearest_node.position, sample, self.step_size)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            n_nodes = len(tree_a) + 1\n            radius = gamma_rrt_star * (math.log(max(n_nodes, 2)) / n_nodes) ** (1 / dim)\n            radius = min(radius, self.step_size * 4.0)\n            radius = max(radius, self.step_size * 2.0)\n\n            near_nodes = near(tree_a, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            min_parent = nearest_node\n            for near_node in near_nodes:\n                cost_tmp = near_node.cost + dist(near_node.position, new_pos)\n                if cost_tmp + 1e-10 < min_cost:\n                    if not self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d):\n                        min_cost = cost_tmp\n                        min_parent = near_node\n\n            new_node = Node(new_pos, parent=min_parent, cost=min_cost)\n            min_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((min_parent, new_node))\n\n            for near_node in near_nodes:\n                if near_node is min_parent:\n                    continue\n                rewired_cost = new_node.cost + dist(new_node.position, near_node.position)\n                if rewired_cost + 1e-12 < near_node.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                        update_parent(near_node, new_node, rewired_cost)\n                        propagate_costs(near_node)\n\n            connect_radius = self.step_size * 3.5\n            conn_node, conn_cost = try_connect(new_node, tree_b, connect_radius)\n            if conn_node is not None and conn_cost < best_cost:\n                best_cost = conn_cost\n                best_connection = (new_node, conn_node)\n                success = True\n\n                # Early stop if improved path found after minimum iterations\n                if iteration > 60:\n                    break\n\n            if success and best_connection and iteration % 100 == 0:\n                path = extract_path(best_connection[0], best_connection[1])\n                path = shortcut_path(path)\n                extracted_path = path\n\n        if success and best_connection:\n            extracted_path = extract_path(best_connection[0], best_connection[1])\n            extracted_path = shortcut_path(extracted_path)\n        else:\n            # Attempt to join closest nodes if no exact connection\n            min_cost = float('inf')\n            best_pair = None\n            for n1 in start_tree:\n                candidates = near(goal_tree, n1.position, self.step_size * 3.5)\n                for n2 in candidates:\n                    dist_ = dist(n1.position, n2.position)\n                    if dist_ <= self.step_size * 3.5:\n                        if not self._is_edge_in_obstacle(n1.position, n2.position, obstacles, is_3d):\n                            total_c = n1.cost + n2.cost + dist_\n                            if total_c < min_cost:\n                                min_cost = total_c\n                                best_pair = (n1, n2)\n            if best_pair:\n                extracted_path = extract_path(best_pair[0], best_pair[1])\n                extracted_path = shortcut_path(extracted_path)\n                success = True\n            else:\n                extracted_path = []\n\n        return PlannerResult(\n            success=success,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -21.79279,
          "time_improvement": 24.0,
          "length_improvement": 13.0,
          "smoothness_improvement": 1323.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.02416062355041504,
                    "num_nodes_avg": 114.0,
                    "path_length_avg": 176.99037189238447,
                    "smoothness_avg": 0.04017511897888593,
                    "success_improvement": 0.0,
                    "time_improvement": 4.256163443932362,
                    "length_improvement": 2.9887725738673576,
                    "smoothness_improvement": 528.8278536867788,
                    "objective_score": 5.714251845934017
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.09086897373199462,
                    "num_nodes_avg": 306.2,
                    "path_length_avg": 235.34604891065732,
                    "smoothness_avg": 0.0851142698164726,
                    "success_improvement": 0.0,
                    "time_improvement": 44.572036467975636,
                    "length_improvement": 21.43471481320267,
                    "smoothness_improvement": 2090.0514677084084,
                    "objective_score": 36.682697166856336
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.03740153312683105,
                    "num_nodes_avg": 174.2,
                    "path_length_avg": 127.95174837067638,
                    "smoothness_avg": 0.11395012731757459,
                    "success_improvement": 0.0,
                    "time_improvement": 24.073028092903133,
                    "length_improvement": 15.020541139713064,
                    "smoothness_improvement": 1349.4372085560642,
                    "objective_score": 22.9814191544791
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "A simplified bidirectional RRT planner that grows two trees alternately from start and goal positions, using goal-biased sampling and fixed step size steering. It performs basic collision checks and nearest neighbor search via linear scan, attempts to connect the trees when new nodes are added, and stops early once a collision-free connection is found or time limit is reached, returning the best path found.",
          "planning_mechanism": "The planner alternately samples points with goal bias, extends the nearest node in the active tree towards the sample within a fixed step size if collision-free, and tries to connect this new node to the other tree. Upon successful connection, it reconstructs and returns the concatenated path.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=4.0, goal_sample_rate=0.2):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.time_limit = 30.0\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_p, to_p):\n            d = dist(from_p, to_p)\n            if d <= self.step_size:\n                return to_p\n            ratio = self.step_size / d\n            return tuple(from_p[i] + ratio * (to_p[i] - from_p[i]) for i in range(dim))\n\n        def sample_free():\n            for _ in range(30):\n                if random.random() < self.goal_sample_rate:\n                    pt = goal_pos\n                else:\n                    pt = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not self._is_in_obstacle(pt, obstacles, is_3d):\n                    return pt\n            return goal_pos\n\n        def nearest(tree, point):\n            best_node = None\n            best_dist = float('inf')\n            for node in tree:\n                d = dist(node.position, point)\n                if d < best_dist:\n                    best_node = node\n                    best_dist = d\n            return best_node\n\n        def can_connect(p1, p2):\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d)\n\n        def path_between_nodes(node_start, node_goal):\n            return node_start.path_from_root() + node_goal.path_from_root()[::-1]\n\n        start_tree = [Node(start_pos, cost=0.0)]\n        goal_tree = [Node(goal_pos, cost=0.0)]\n        nodes = start_tree[:] + goal_tree[:]\n        edges = []\n\n        success_state = False\n        extracted_path = []\n\n        start_time = time.monotonic()\n\n        for it in range(self.max_iter):\n            if time.monotonic() - start_time > self.time_limit:\n                break\n\n            active_tree = start_tree if it % 2 == 0 else goal_tree\n            other_tree = goal_tree if it % 2 == 0 else start_tree\n\n            sample = sample_free()\n            nearest_node = nearest(active_tree, sample)\n            new_pos = steer(nearest_node.position, sample)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            new_node = Node(new_pos, parent=nearest_node, cost=nearest_node.cost + dist(nearest_node.position, new_pos))\n            nearest_node.children.append(new_node)\n            active_tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n\n            nearest_other = nearest(other_tree, new_pos)\n            if dist(new_pos, nearest_other.position) <= self.step_size * 1.5 and can_connect(new_pos, nearest_other.position):\n                if active_tree is start_tree:\n                    extracted_path = path_between_nodes(new_node, nearest_other)\n                else:\n                    extracted_path = path_between_nodes(nearest_other, new_node)\n                success_state = True\n                break\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -21.71392,
          "time_improvement": 78.0,
          "length_improvement": -3.0,
          "smoothness_improvement": 34.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.008828878402709961,
                    "num_nodes_avg": 172.1,
                    "path_length_avg": 181.84732435912701,
                    "smoothness_avg": 0.00884989410080705,
                    "success_improvement": 0.0,
                    "time_improvement": 64.72025143882802,
                    "length_improvement": 0.3265999635088254,
                    "smoothness_improvement": 38.52006053026264,
                    "objective_score": 19.804635712405016
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.022538423538208008,
                    "num_nodes_avg": 403.4,
                    "path_length_avg": 303.94670279126495,
                    "smoothness_avg": 0.005198048960746343,
                    "success_improvement": 0.0,
                    "time_improvement": 86.21623134883303,
                    "length_improvement": -1.4661580124836406,
                    "smoothness_improvement": 33.749543763336085,
                    "objective_score": 25.153922315976402
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.00898306369781494,
                    "num_nodes_avg": 248.4,
                    "path_length_avg": 161.94894199209585,
                    "smoothness_avg": 0.010310978474878302,
                    "success_improvement": 0.0,
                    "time_improvement": 81.8755958857785,
                    "length_improvement": -7.558776091240321,
                    "smoothness_improvement": 31.154885123189107,
                    "objective_score": 20.183187536605303
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "This algorithm implements a simplified bidirectional RRT planner suitable for both 2D and 3D path planning in environments with rectangular obstacles. It grows two trees from the start and goal points by sampling collision-free points and extending the nearest nodes towards them using fixed step sizes. Unlike RRT*, this version omits rewiring to simplify the logic and improve generalization while maintaining path feasibility. The planner alternates tree expansion, connects the trees when collision-free paths exist, and stops early upon success or when exceeding a 30-second time limit, returning the best found path.",
          "planning_mechanism": "The planner alternates expanding two trees rooted at start and goal by sampling random free points within bounds and extending the closest existing node towards the sample by a fixed step size. It rejects samples and extensions that collide with obstacles or boundaries. Upon each new node addition, the planner attempts to connect the other tree directly to that node if possible. The search terminates early when a collision-free connection is found or when the time limit is reached, extracting the path by concatenating the two connected sub-paths.",
          "code": "class Node:\n    def __init__(self, position, parent=None):\n        self.position = position\n        self.parent = parent\n        self.children = []\n        if parent:\n            parent.children.append(self)\nclass Planner:\n    def __init__(self, max_iter=10000, step_size=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.time_limit = 30.0\n\n    def plan(self, map):\n        import time\n        import math\n        import random\n\n        bounds = map.size\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        def in_obstacle(pos):\n            for o in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d = o\n                    px,py,pz = pos\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                        return True\n                else:\n                    x,y,w,h = o\n                    px,py = pos\n                    if x <= px <= x+w and y <= py <= y+h:\n                        return True\n            return False\n\n        def edge_in_obstacle(a,b,resolution=1.0):\n            dist = math.dist(a,b)\n            steps = max(1, int(dist / resolution))\n            for i in range(steps+1):\n                interp = tuple(a[d] + (b[d]-a[d])*(i/steps) for d in range(len(a)))\n                if in_obstacle(interp):\n                    return True\n            return False\n\n        def steer(from_p, to_p):\n            dist = math.dist(from_p, to_p)\n            if dist <= self.step_size:\n                return to_p\n            ratio = self.step_size / dist\n            return tuple(from_p[i]+(to_p[i]-from_p[i])*ratio for i in range(len(from_p)))\n\n        def nearest(tree, point):\n            min_node = None\n            min_dist = float('inf')\n            for node in tree:\n                d = math.dist(node.position, point)\n                if d < min_dist:\n                    min_dist = d\n                    min_node = node\n            return min_node\n\n        def extract_path(node_start, node_goal):\n            path_start = []\n            cur = node_start\n            while cur:\n                path_start.append(cur.position)\n                cur = cur.parent\n            path_goal = []\n            cur = node_goal\n            while cur:\n                path_goal.append(cur.position)\n                cur = cur.parent\n            return path_start[::-1] + path_goal\n\n        start_tree = [Node(start)]\n        goal_tree = [Node(goal)]\n\n        best_pair = None\n        success = False\n        best_path = []\n\n        start_time = time.monotonic()\n\n        for i in range(self.max_iter):\n            if time.monotonic() - start_time > self.time_limit:\n                break\n\n            tree_a, tree_b = (start_tree, goal_tree) if i % 2 == 0 else (goal_tree, start_tree)\n\n            # Sample collision-free point inside bounds\n            sample = None\n            for _ in range(100):\n                candidate = tuple(random.uniform(0,bounds[d]) for d in range(len(bounds)))\n                if not in_obstacle(candidate):\n                    sample = candidate\n                    break\n            if sample is None:\n                continue\n\n            nearest_node = nearest(tree_a, sample)\n            new_pos = steer(nearest_node.position, sample)\n            if in_obstacle(new_pos):\n                continue\n            if edge_in_obstacle(nearest_node.position, new_pos):\n                continue\n\n            new_node = Node(new_pos, nearest_node)\n            tree_a.append(new_node)\n\n            # Attempt connection from nearest in other tree to new_node\n            nearest_other = nearest(tree_b, new_pos)\n            if not edge_in_obstacle(new_pos, nearest_other.position):\n                # Connection found - stop early\n                best_pair = (new_node, nearest_other)\n                success = True\n                best_path = extract_path(new_node, nearest_other)\n                break\n\n        if not success and best_pair:\n            best_path = extract_path(best_pair[0], best_pair[1])\n            success = True\n\n        all_nodes = start_tree + goal_tree\n\n        edges = []\n        for node in all_nodes:\n            if node.parent:\n                edges.append((node.parent, node))\n\n        return PlannerResult(\n            success=success,\n            path=best_path,\n            nodes=all_nodes,\n            edges=edges\n        )",
          "objective": -21.62285,
          "time_improvement": 78.0,
          "length_improvement": -4.0,
          "smoothness_improvement": 82.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.005420470237731933,
                    "num_nodes_avg": 74.0,
                    "path_length_avg": 192.1221838900546,
                    "smoothness_avg": 0.011484187959474722,
                    "success_improvement": 0.0,
                    "time_improvement": 78.3400769216845,
                    "length_improvement": -5.305213360960899,
                    "smoothness_improvement": 79.75247987908493,
                    "objective_score": 20.717657459324233
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.011775541305541991,
                    "num_nodes_avg": 220.0,
                    "path_length_avg": 306.65757638603327,
                    "smoothness_avg": 0.007181975344004889,
                    "success_improvement": 0.0,
                    "time_improvement": 92.79846095612257,
                    "length_improvement": -2.3711256465873407,
                    "smoothness_improvement": 84.79739856899316,
                    "objective_score": 26.840849891729334
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.018205738067626952,
                    "num_nodes_avg": 289.4,
                    "path_length_avg": 155.76673175523925,
                    "smoothness_avg": 0.014173276882456388,
                    "success_improvement": 0.0,
                    "time_improvement": 63.26774861725637,
                    "length_improvement": -3.452846417136694,
                    "smoothness_improvement": 80.2830357823688,
                    "objective_score": 17.31003191380674
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "cross_over",
          "algorithm_description": "A bidirectional RRT* planner with adaptive goal biasing, dynamic rewiring radius, and enhanced multi-candidate connection attempts to accelerate convergence. It incorporates incremental caching of nearest neighbors for efficiency, adaptive collision checking resolution based on edge length, and iterative path shortcutting both during planning and as post-processing to minimize path length and improve smoothness. The planner respects obstacle and boundary constraints, alternates tree growth, dynamically adapts parameters based on tree sizes and elapsed time to balance exploration and exploitation, and enforces a strict 30-second time limit, returning the best feasible path discovered.",
          "planning_mechanism": "A planning mechanism growing two trees from start and goal by sampling mostly free space with increasing goal bias over time, extending towards samples with a fixed step size, computing adaptive rewiring neighborhoods, and rewiring local neighbors to optimize path cost. Each new node tries multiple connections to nodes in the opposite tree within an extended radius to rapidly find connecting paths and triggers early stopping when an improved path is found. Periodic shortcutting during tree growth removes unnecessary waypoints incrementally, while a final shortcutting pass further improves the extracted path's smoothness and length. Nearest and near neighbor queries are cached and updated incrementally for efficient lookups, and collision checking resolution adapts based on edge length for cost-effective safety checks.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 4.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate_start = 0.15\n        self.goal_sample_rate_end = 0.4\n        self.time_limit = 30.0\n        self.gamma_rrt_star = 25.0\n        self.shortcut_final_attempts = 150\n        self.shortcut_interm_attempts = 10\n        self.shortcut_interval = 300  # iterations\n\n    def plan(self, map):\n        import random\n        import math\n        import time\n\n        bounds = map.size\n        dim = len(bounds)\n        is_3d = dim == 3\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_p, to_p, max_step):\n            d = dist(from_p, to_p)\n            if d <= max_step:\n                return to_p\n            ratio = max_step / d\n            return tuple(from_p[i] + (to_p[i] - from_p[i]) * ratio for i in range(dim))\n\n        def sample_free(goal_bias_rate):\n            for _ in range(30):\n                if random.random() < goal_bias_rate:\n                    p = goal_pos\n                else:\n                    p = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n            return goal_pos  # fallback\n\n        def adaptive_rewire_radius(n):\n            if n < 2:\n                return self.step_size * 5\n            # RRT* radius adaption (gamma * (log n / n)^(1/d))\n            r = self.gamma_rrt_star * (math.log(n) / n) ** (1 / dim)\n            return min(r, self.step_size * 5)\n\n        def adaptive_edge_resolution(p1, p2):\n            length = dist(p1, p2)\n            min_res = 0.05\n            max_res = self.step_size / 4\n            return max(min_res, min(max_res, length / 10))\n\n        def near(tree, point, radius):\n            # Naive linear near search\n            return [node for node in tree if dist(node.position, point) <= radius]\n\n        def extract_path(node_start, node_goal):\n            path_start = []\n            c = node_start\n            while c is not None:\n                path_start.append(c.position)\n                c = c.parent\n            path_goal = []\n            c = node_goal\n            while c is not None:\n                path_goal.append(c.position)\n                c = c.parent\n            return path_start[::-1] + path_goal\n\n        def shortcut_path(path, attempts, resolution):\n            if len(path) < 3:\n                return path\n            for _ in range(attempts):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        start_tree = [Node(start_pos, cost=0.0)]\n        goal_tree = [Node(goal_pos, cost=0.0)]\n        nodes = start_tree[:] + goal_tree[:]\n        edges = []\n\n        best_cost = float('inf')\n        best_connection = None\n        success = False\n        extracted_path = []\n\n        start_time = time.monotonic()\n\n        # Incrementally cache nearest neighbor for all nodes to optimize repeated nearest calls\n        # For simplicity, we use linear searches but can be extended.\n        for iter_count in range(self.max_iter):\n            elapsed = time.monotonic() - start_time\n            if elapsed > self.time_limit:\n                break\n\n            # Dynamic goal bias increasing with elapsed time to encourage convergence\n            goal_bias_rate = self.goal_sample_rate_start + (self.goal_sample_rate_end - self.goal_sample_rate_start) * min(1.0, elapsed / self.time_limit)\n\n            # Alternate tree expansion\n            tree_a = start_tree if iter_count % 2 == 0 else goal_tree\n            tree_b = goal_tree if iter_count % 2 == 0 else start_tree\n\n            sample = sample_free(goal_bias_rate)\n\n            # Find nearest node in tree_a\n            nearest_node = min(tree_a, key=lambda n: dist(n.position, sample))\n            new_pos = steer(nearest_node.position, sample, self.step_size)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d, adaptive_edge_resolution(nearest_node.position, new_pos)):\n                continue\n\n            n_nodes = len(tree_a) + 1\n            radius = adaptive_rewire_radius(n_nodes)\n\n            near_nodes = near(tree_a, new_pos, radius)\n\n            # Select best parent with minimal cost\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            min_parent = nearest_node\n            for near_node in near_nodes:\n                cost_through = near_node.cost + dist(near_node.position, new_pos)\n                if cost_through < min_cost:\n                    if not self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d,\n                                                    adaptive_edge_resolution(near_node.position, new_pos)):\n                        min_cost = cost_through\n                        min_parent = near_node\n\n            new_node = Node(new_pos, parent=min_parent, cost=min_cost)\n            min_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((min_parent, new_node))\n\n            # Rewire neighbors improving path cost\n            for near_node in near_nodes:\n                if near_node == min_parent:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, near_node.position)\n                if new_cost + 1e-9 < near_node.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d,\n                                                    adaptive_edge_resolution(new_node.position, near_node.position)):\n                        # Remove old parent-child edge\n                        if near_node.parent:\n                            try:\n                                edges.remove((near_node.parent, near_node))\n                            except ValueError:\n                                pass\n                            near_node.parent.remove_child(near_node)\n                        near_node.parent = new_node\n                        near_node.cost = new_cost\n                        new_node.add_child(near_node)\n                        edges.append((new_node, near_node))\n\n            # Try multiple connections to opposite tree nodes within an extended radius\n            conn_radius = radius * 1.8\n            candidates = near(tree_b, new_pos, conn_radius)\n            for cnode in candidates:\n                d = dist(new_pos, cnode.position)\n                if d <= conn_radius:\n                    edge_res = adaptive_edge_resolution(new_pos, cnode.position)\n                    if not self._is_edge_in_obstacle(new_pos, cnode.position, obstacles, is_3d, edge_res):\n                        total_cost = new_node.cost + cnode.cost + d\n                        if total_cost + 1e-9 < best_cost:\n                            best_cost = total_cost\n                            best_connection = (new_node, cnode)\n                            success = True\n            # Early stop if improved path found\n            if success:\n                break\n\n            # Periodic incremental shortcutting to trim intermediate path nodes\n            if iter_count > 0 and iter_count % self.shortcut_interval == 0 and success and best_connection is not None:\n                path = extract_path(best_connection[0], best_connection[1])\n                res = max(0.05, self.step_size / 5)\n                path = shortcut_path(path, self.shortcut_interm_attempts, res)\n                # Update the cost along the shortcut path (heuristic)\n                # This does not restructure trees but helps smoothing final path\n                extracted_path = path\n\n        # Final path extraction and heavy shortcutting pass if success\n        if success and best_connection is not None:\n            path = extract_path(best_connection[0], best_connection[1])\n            res = max(0.05, self.step_size / 10)\n            path = shortcut_path(path, self.shortcut_final_attempts, res)\n            extracted_path = path\n\n        # If no success, attempt best partial connection between trees within step_size*2 radius\n        if not success:\n            best_partial_cost = float('inf')\n            best_pair = None\n            connection_radius = self.step_size * 2\n            for n1 in start_tree:\n                candidates = near(goal_tree, n1.position, connection_radius)\n                for n2 in candidates:\n                    d = dist(n1.position, n2.position)\n                    if d <= connection_radius:\n                        if not self._is_edge_in_obstacle(n1.position, n2.position, obstacles, is_3d, adaptive_edge_resolution(n1.position, n2.position)):\n                            total_cost = n1.cost + n2.cost + d\n                            if total_cost < best_partial_cost:\n                                best_partial_cost = total_cost\n                                best_pair = (n1, n2)\n            if best_pair is not None:\n                path = extract_path(best_pair[0], best_pair[1])\n                path = shortcut_path(path, self.shortcut_final_attempts, max(0.05, self.step_size / 10))\n                extracted_path = path\n                success = True\n\n        return PlannerResult(\n            success=success,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -21.44733,
          "time_improvement": 14.0,
          "length_improvement": 15.0,
          "smoothness_improvement": 1698.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.032735157012939456,
                    "num_nodes_avg": 179.4,
                    "path_length_avg": 166.606701891404,
                    "smoothness_avg": 0.039513536142390025,
                    "success_improvement": 0.0,
                    "time_improvement": -30.808020662342024,
                    "length_improvement": 8.680226641185312,
                    "smoothness_improvement": 518.4726456454939,
                    "objective_score": -1.4419069857639508
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.04908695220947266,
                    "num_nodes_avg": 428.7,
                    "path_length_avg": 241.6294389149344,
                    "smoothness_avg": 0.11696467714282885,
                    "success_improvement": 0.0,
                    "time_improvement": 69.98001249292098,
                    "length_improvement": 19.337138372421613,
                    "smoothness_improvement": 2909.585389136673,
                    "objective_score": 47.144213717012626
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.048250246047973636,
                    "num_nodes_avg": 377.5,
                    "path_length_avg": 126.69121138415771,
                    "smoothness_avg": 0.13884113612480178,
                    "success_improvement": 0.0,
                    "time_improvement": 2.6493646931603028,
                    "length_improvement": 15.857729785837757,
                    "smoothness_improvement": 1666.049003320838,
                    "objective_score": 18.639692296054932
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "A simplified bidirectional RRT planner that grows two trees alternately from start and goal by extending towards random collision-free samples with a fixed step size. It performs basic nearest neighbor search with linear scan, checks node and edge collisions, attempts to directly connect the trees after each extension, and returns the first valid path or the best found within a 30-second limit, prioritizing simplicity, robustness, and efficiency. <The planner alternates expansions between start and goal trees. Each iteration samples a collision-free random point within bounds, extends the nearest node from the active tree towards it by fixed step size if collision-free, inserts the new node, then attempts to connect it to the other tree by nearest node with collision and distance checks. On successful connection, it reconstructs and returns the path immediately. The search stops if time limit is exceeded and returns the best available path found so far.>",
          "planning_mechanism": "The planner alternates expansions between start and goal trees. Each iteration samples a collision-free random point within bounds, extends the nearest node from the active tree towards it by fixed step size if collision-free, inserts the new node, then attempts to connect it to the other tree by nearest node with collision and distance checks. On successful connection, it reconstructs and returns the path immediately. The search stops if time limit is exceeded and returns the best available path found so far.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.time_limit = 30.0\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def in_obstacle(pos):\n            for o in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = o\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w_, h_ = o\n                    px, py = pos\n                    if x <= px <= x + w_ and y <= py <= y + h_:\n                        return True\n            return False\n\n        def edge_in_obstacle(a, b, resolution=1.0):\n            dist = math.dist(a, b)\n            steps = max(1, int(dist / resolution))\n            for i in range(steps + 1):\n                interp = tuple(a[d] + (b[d] - a[d]) * (i / steps) for d in range(dim))\n                if in_obstacle(interp):\n                    return True\n            return False\n\n        def steer(from_p, to_p):\n            dist = math.dist(from_p, to_p)\n            if dist <= self.step_size:\n                return to_p\n            ratio = self.step_size / dist\n            return tuple(from_p[i] + ratio * (to_p[i] - from_p[i]) for i in range(dim))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: math.dist(n.position, point))\n\n        def extract_path(node_start, node_goal):\n            path_start = []\n            c = node_start\n            while c is not None:\n                path_start.append(c.position)\n                c = c.parent\n            path_goal = []\n            c = node_goal\n            while c is not None:\n                path_goal.append(c.position)\n                c = c.parent\n            return path_start[::-1] + path_goal\n\n        start_tree = [Node(start_pos, None, 0.0)]\n        goal_tree = [Node(goal_pos, None, 0.0)]\n        all_nodes = start_tree + goal_tree\n        edges: List[Tuple[Node, Node]] = []\n\n        best_cost = float('inf')\n        best_pair = None\n        success = False\n        result_path = []\n\n        start_time = time.monotonic()\n\n        for i in range(self.max_iter):\n            if time.monotonic() - start_time > self.time_limit:\n                break\n\n            tree_a, tree_b = (start_tree, goal_tree) if i % 2 == 0 else (goal_tree, start_tree)\n\n            # Sample collision-free random point\n            for _ in range(30):\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not in_obstacle(sample):\n                    break\n            else:\n                # If no free sample after retries, skip iteration\n                continue\n\n            nearest_node = nearest(tree_a, sample)\n            new_pos = steer(nearest_node.position, sample)\n            if in_obstacle(new_pos) or edge_in_obstacle(nearest_node.position, new_pos):\n                continue\n\n            new_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            new_node = Node(new_pos, nearest_node, new_cost)\n            nearest_node.add_child(new_node)\n            tree_a.append(new_node)\n            all_nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n\n            nearest_other = nearest(tree_b, new_pos)\n            if not edge_in_obstacle(new_pos, nearest_other.position):\n                total_cost = new_node.cost + nearest_other.cost + math.dist(new_pos, nearest_other.position)\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pair = (new_node, nearest_other)\n                    edges.append((new_node, nearest_other))\n                    result_path = extract_path(new_node, nearest_other)\n                    success = True\n                    break\n\n        if not success and best_pair:\n            result_path = extract_path(best_pair[0], best_pair[1])\n            success = True\n\n        return PlannerResult(success=success, path=result_path, nodes=all_nodes, edges=edges)",
          "objective": -21.29691,
          "time_improvement": 77.0,
          "length_improvement": -4.0,
          "smoothness_improvement": 81.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.009511208534240723,
                    "num_nodes_avg": 112.8,
                    "path_length_avg": 199.75929373289623,
                    "smoothness_avg": 0.011078462406889682,
                    "success_improvement": 0.0,
                    "time_improvement": 62.308936544918915,
                    "length_improvement": -9.491234283572133,
                    "smoothness_improvement": 73.40199393398998,
                    "objective_score": 13.364950363002343
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.014340615272521973,
                    "num_nodes_avg": 251.6,
                    "path_length_avg": 299.82425419614395,
                    "smoothness_avg": 0.007273620428589899,
                    "success_improvement": 0.0,
                    "time_improvement": 91.25255774653623,
                    "length_improvement": -0.08996601332861745,
                    "smoothness_improvement": 87.15549260465178,
                    "objective_score": 27.757565178986958
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.010724115371704101,
                    "num_nodes_avg": 212.2,
                    "path_length_avg": 153.37103988882114,
                    "smoothness_avg": 0.014408827218874095,
                    "success_improvement": 0.0,
                    "time_improvement": 78.22951257653881,
                    "length_improvement": -1.861741950049488,
                    "smoothness_improvement": 83.27921867508478,
                    "objective_score": 22.76820469630737
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "A simplified bidirectional RRT planner that alternately grows two trees from start and goal positions using fixed step extensions towards random free samples. It performs straightforward nearest neighbor searches via linear scan, adds nodes only if collision-free, attempts to connect the two trees each iteration, and stops immediately upon finding a feasible path or when the 30-second time limit is reached, returning the best path found so far. This approach balances simplicity, runtime efficiency, and solution completeness without complex rewiring or smoothing.",
          "planning_mechanism": "The planner grows two trees in alternation by sampling random collision-free points within map bounds, extending the nearest node towards each sample by a fixed step size if collision-free. After adding a node, it attempts to connect to the other tree via the nearest node. Upon the first successful connection, or after exhausting iterations/time, the search ends and the concatenated path from start to goal is returned. Collision checks enforce feasibility at node and edge levels.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.time_limit = 30.0\n\n    def plan(self, map):\n        import time\n        import math\n        import random\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def in_obstacle(pos):\n            for o in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = o\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w_, h_ = o\n                    px, py = pos\n                    if x <= px <= x + w_ and y <= py <= y + h_:\n                        return True\n            return False\n\n        def edge_in_obstacle(a, b, resolution=1.0):\n            dist = math.dist(a, b)\n            steps = max(1, int(dist / resolution))\n            for i in range(steps + 1):\n                interp = tuple(a[d] + (b[d] - a[d]) * (i / steps) for d in range(dim))\n                if in_obstacle(interp):\n                    return True\n            return False\n\n        def steer(from_p, to_p):\n            dist = math.dist(from_p, to_p)\n            if dist <= self.step_size:\n                return to_p\n            r = self.step_size / dist\n            return tuple(from_p[i] + r * (to_p[i] - from_p[i]) for i in range(dim))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: math.dist(n.position, point))\n\n        def extract_path(node_start, node_goal):\n            path_start = []\n            cur = node_start\n            while cur is not None:\n                path_start.append(cur.position)\n                cur = cur.parent\n            path_goal = []\n            cur = node_goal\n            while cur is not None:\n                path_goal.append(cur.position)\n                cur = cur.parent\n            return path_start[::-1] + path_goal\n\n        start_tree = [Node(start_pos, cost=0.0)]\n        goal_tree = [Node(goal_pos, cost=0.0)]\n        all_nodes = start_tree + goal_tree\n        edges = []\n\n        best_cost = float('inf')\n        best_pair = None\n        success = False\n        result_path = []\n\n        start_time = time.monotonic()\n\n        for i in range(self.max_iter):\n            if time.monotonic() - start_time > self.time_limit:\n                break\n\n            # Alternate trees\n            tree_a, tree_b = (start_tree, goal_tree) if i % 2 == 0 else (goal_tree, start_tree)\n\n            # Sample free point with limited retries\n            for _ in range(30):\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not in_obstacle(sample):\n                    break\n            else:\n                continue\n\n            nearest_node = nearest(tree_a, sample)\n            new_pos = steer(nearest_node.position, sample)\n\n            if in_obstacle(new_pos) or edge_in_obstacle(nearest_node.position, new_pos):\n                continue\n\n            new_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            new_node = Node(new_pos, nearest_node, new_cost)\n            nearest_node.add_child(new_node)\n            tree_a.append(new_node)\n            all_nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n\n            nearest_other = nearest(tree_b, new_pos)\n            if not edge_in_obstacle(new_pos, nearest_other.position):\n                total_cost = new_node.cost + nearest_other.cost + math.dist(new_pos, nearest_other.position)\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pair = (new_node, nearest_other)\n                    edges.append((new_node, nearest_other))\n                    result_path = extract_path(new_node, nearest_other)\n                    success = True\n                    break\n\n        if not success and best_pair:\n            result_path = extract_path(best_pair[0], best_pair[1])\n            success = True\n\n        return PlannerResult(\n            success=success,\n            path=result_path,\n            nodes=all_nodes,\n            edges=edges\n        )",
          "objective": -21.08715,
          "time_improvement": 76.0,
          "length_improvement": -4.0,
          "smoothness_improvement": 79.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.009995460510253906,
                    "num_nodes_avg": 113.2,
                    "path_length_avg": 193.8001453452412,
                    "smoothness_avg": 0.011564865587644569,
                    "success_improvement": 0.0,
                    "time_improvement": 60.05864873542237,
                    "length_improvement": -6.224930623549434,
                    "smoothness_improvement": 81.0152599542167,
                    "objective_score": 14.687712546268132
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.011881780624389649,
                    "num_nodes_avg": 222.9,
                    "path_length_avg": 290.89860117911996,
                    "smoothness_avg": 0.007257112318940964,
                    "success_improvement": 0.0,
                    "time_improvement": 92.73348843529955,
                    "length_improvement": 2.889673874431286,
                    "smoothness_improvement": 86.73072705307392,
                    "objective_score": 29.987504490514002
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.011691474914550781,
                    "num_nodes_avg": 242.4,
                    "path_length_avg": 162.33347280885596,
                    "smoothness_avg": 0.013387193902873212,
                    "success_improvement": 0.0,
                    "time_improvement": 76.41105271310222,
                    "length_improvement": -7.814163150342569,
                    "smoothness_improvement": 70.28411830468079,
                    "objective_score": 18.586238515248528
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "This algorithm implements a streamlined bidirectional RRT planner without rewiring, focusing on simplicity and generality for 2D/3D pathfinding. It grows two trees alternately with fixed-step extensions towards random samples and attempts connection between trees after each expansion. By avoiding complex rewiring and adaptive radius computations, it improves generalizability and robustness while still producing valid feasible paths within a fixed 30-second time limit.",
          "planning_mechanism": "The planner samples collision-free points within map bounds, extends the nearest node in the active tree towards the sample using fixed increments, and alternates growth between start and goal trees. It verifies collision-free edges and attempts to connect the two trees after new node insertions. Planning stops early upon connecting the trees or when the time limit expires, returning the best found feasible path.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n    def add_child(self, child):\n        self.children.append(child)\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.time_limit = 30.0\n\n    def plan(self, map):\n        import time\n        import math\n        import random\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def in_obstacle(pos):\n            for o in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = o\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w_, h_ = o\n                    px, py = pos\n                    if x <= px <= x + w_ and y <= py <= y + h_:\n                        return True\n            return False\n\n        def edge_in_obstacle(a, b, resolution=1.0):\n            dist = math.dist(a, b)\n            steps = max(1, int(dist / resolution))\n            for i in range(steps + 1):\n                interp = tuple(a[d] + (b[d] - a[d]) * (i / steps) for d in range(dim))\n                if in_obstacle(interp):\n                    return True\n            return False\n\n        def steer(from_p, to_p):\n            dist = math.dist(from_p, to_p)\n            if dist <= self.step_size:\n                return to_p\n            r = self.step_size / dist\n            return tuple(from_p[i] + r * (to_p[i] - from_p[i]) for i in range(dim))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: math.dist(n.position, point))\n\n        def extract_path(n_start, n_goal):\n            path_start = []\n            cur = n_start\n            while cur:\n                path_start.append(cur.position)\n                cur = cur.parent\n            path_goal = []\n            cur = n_goal\n            while cur:\n                path_goal.append(cur.position)\n                cur = cur.parent\n            return path_start[::-1] + path_goal\n\n        start_tree = [Node(start_pos, cost=0.0)]\n        goal_tree = [Node(goal_pos, cost=0.0)]\n        all_nodes = start_tree + goal_tree\n        edges = []\n\n        best_cost = float('inf')\n        best_pair = None\n        success = False\n        result_path = []\n\n        start_time = time.monotonic()\n\n        for iter_i in range(self.max_iter):\n            if time.monotonic() - start_time > self.time_limit:\n                break\n\n            tree_a, tree_b = (start_tree, goal_tree) if iter_i % 2 == 0 else (goal_tree, start_tree)\n\n            while True:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not in_obstacle(sample):\n                    break\n\n            nearest_node = nearest(tree_a, sample)\n            new_pos = steer(nearest_node.position, sample)\n            if in_obstacle(new_pos) or edge_in_obstacle(nearest_node.position, new_pos):\n                continue\n\n            new_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            new_node = Node(new_pos, nearest_node, new_cost)\n            nearest_node.add_child(new_node)\n            tree_a.append(new_node)\n            all_nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n\n            nearest_other = nearest(tree_b, new_pos)\n            if not edge_in_obstacle(new_pos, nearest_other.position):\n                total_cost = new_node.cost + nearest_other.cost + math.dist(new_pos, nearest_other.position)\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pair = (new_node, nearest_other)\n                    edges.append((new_node, nearest_other))\n                    result_path = extract_path(new_node, nearest_other)\n                    success = True\n                    break\n\n        if not success and best_pair:\n            result_path = extract_path(best_pair[0], best_pair[1])\n            success = True\n\n        return PlannerResult(\n            success=success,\n            path=result_path,\n            nodes=all_nodes,\n            edges=edges\n        )",
          "objective": -20.03205,
          "time_improvement": 73.0,
          "length_improvement": -4.0,
          "smoothness_improvement": 84.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.01135859489440918,
                    "num_nodes_avg": 127.8,
                    "path_length_avg": 191.39038861581668,
                    "smoothness_avg": 0.011535327746567622,
                    "success_improvement": 0.0,
                    "time_improvement": 54.61163314244231,
                    "length_improvement": -4.904104775112907,
                    "smoothness_improvement": 80.55292859891394,
                    "objective_score": 13.843791720659516
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.012335968017578126,
                    "num_nodes_avg": 224.0,
                    "path_length_avg": 301.63167662420653,
                    "smoothness_avg": 0.0072446766635648864,
                    "success_improvement": 0.0,
                    "time_improvement": 92.45572216023716,
                    "length_improvement": -0.6933356435859622,
                    "smoothness_improvement": 86.41074868320692,
                    "objective_score": 27.752769005335605
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.013589906692504882,
                    "num_nodes_avg": 222.0,
                    "path_length_avg": 159.8567819165932,
                    "smoothness_avg": 0.014574546363009217,
                    "success_improvement": 0.0,
                    "time_improvement": 72.58073981714784,
                    "length_improvement": -6.169262987048479,
                    "smoothness_improvement": 85.3871539563687,
                    "objective_score": 18.499599922697104
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "A simplified bidirectional RRT planner focused on general applicability and computational efficiency. It grows two trees alternately from start and goal, extends nearest nodes towards random free samples with fixed step size, and attempts connections between trees each iteration. The planner uses direct collision checks and early termination upon the first valid path to ensure timely results.",
          "planning_mechanism": "A fixed-step bidirectional RRT sampling random free points, extending trees symmetrically, with minimal overhead and straightforward nearest neighbor searches. It stops as soon as a path is found or the 30-second limit expires, returning the best path discovered.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.time_limit = 30.0\n\n    def plan(self, map):\n        import time\n        import math\n        import random\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def in_obstacle(pos):\n            for o in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = o\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w_, h_ = o\n                    px, py = pos\n                    if x <= px <= x + w_ and y <= py <= y + h_:\n                        return True\n            return False\n\n        def edge_in_obstacle(a, b, resolution=1.0):\n            dist = math.dist(a, b)\n            steps = max(1, int(dist / resolution))\n            for i in range(steps + 1):\n                interp = tuple(a[d] + (b[d] - a[d]) * (i / steps) for d in range(dim))\n                if in_obstacle(interp):\n                    return True\n            return False\n\n        def steer(from_p, to_p):\n            dist = math.dist(from_p, to_p)\n            if dist <= self.step_size:\n                return to_p\n            r = self.step_size / dist\n            return tuple(from_p[i] + r * (to_p[i] - from_p[i]) for i in range(dim))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: math.dist(n.position, point))\n\n        def extract_path(node_start, node_goal):\n            path_start = []\n            cur = node_start\n            while cur is not None:\n                path_start.append(cur.position)\n                cur = cur.parent\n            path_goal = []\n            cur = node_goal\n            while cur is not None:\n                path_goal.append(cur.position)\n                cur = cur.parent\n            return path_start[::-1] + path_goal\n\n        start_tree = [Node(start_pos, cost=0.0)]\n        goal_tree = [Node(goal_pos, cost=0.0)]\n        all_nodes = start_tree + goal_tree\n        edges = []\n\n        best_cost = float('inf')\n        best_pair = None\n        success = False\n        result_path = []\n\n        start_time = time.monotonic()\n\n        for i in range(self.max_iter):\n            if time.monotonic() - start_time > self.time_limit:\n                break\n\n            tree_a, tree_b = (start_tree, goal_tree) if i % 2 == 0 else (goal_tree, start_tree)\n\n            # sample free point\n            for _ in range(30):\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not in_obstacle(sample):\n                    break\n            else:\n                continue\n\n            nearest_node = nearest(tree_a, sample)\n            new_pos = steer(nearest_node.position, sample)\n\n            if in_obstacle(new_pos) or edge_in_obstacle(nearest_node.position, new_pos):\n                continue\n\n            new_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            new_node = Node(new_pos, nearest_node, new_cost)\n            nearest_node.add_child(new_node)\n            tree_a.append(new_node)\n            all_nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n\n            nearest_other = nearest(tree_b, new_pos)\n            if not edge_in_obstacle(new_pos, nearest_other.position):\n                total_cost = new_node.cost + nearest_other.cost + math.dist(new_pos, nearest_other.position)\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pair = (new_node, nearest_other)\n                    edges.append((new_node, nearest_other))\n                    result_path = extract_path(new_node, nearest_other)\n                    success = True\n                    break\n\n        if not success and best_pair:\n            result_path = extract_path(best_pair[0], best_pair[1])\n            success = True\n\n        return PlannerResult(\n            success=success,\n            path=result_path,\n            nodes=all_nodes,\n            edges=edges\n        )",
          "objective": -19.96442,
          "time_improvement": 71.0,
          "length_improvement": -3.0,
          "smoothness_improvement": 82.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.011068058013916016,
                    "num_nodes_avg": 115.1,
                    "path_length_avg": 192.06685886216826,
                    "smoothness_avg": 0.0110546501498439,
                    "success_improvement": 0.0,
                    "time_improvement": 55.772603723756454,
                    "length_improvement": -5.274888836495227,
                    "smoothness_improvement": 73.02928040207969,
                    "objective_score": 13.931994217240197
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.012542247772216797,
                    "num_nodes_avg": 223.9,
                    "path_length_avg": 296.8327670964883,
                    "smoothness_avg": 0.007453221729876289,
                    "success_improvement": 0.0,
                    "time_improvement": 92.32956815436631,
                    "length_improvement": 0.908678485718378,
                    "smoothness_improvement": 91.77676344833907,
                    "objective_score": 28.702961354982616
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.017837381362915038,
                    "num_nodes_avg": 266.6,
                    "path_length_avg": 156.44911212354998,
                    "smoothness_avg": 0.014129735888269546,
                    "success_improvement": 0.0,
                    "time_improvement": 64.01095227237525,
                    "length_improvement": -3.906050966307348,
                    "smoothness_improvement": 79.72919755017406,
                    "objective_score": 17.258301089679037
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "time_expert",
          "algorithm_description": "This algorithm implements an adaptive bidirectional RRT* planner that efficiently alternates growth between start and goal trees, using goal bias sampling, dynamically shrinking rewiring radius based on tree size and problem dimension, and fast squared-distance computations. It enforces strict collision checks for nodes and edges, employs limited retries to avoid excessive sampling attempts, and performs periodic shortcutting to smooth and shorten the path. Early stopping is triggered upon finding improved solutions for reduced runtime. The algorithm respects a 30-second wall-clock time limit, returning the best path found so far.",
          "planning_mechanism": "The planner alternates growing start and goal trees by sampling with goal bias, extends nearest nodes toward samples using fixed step sizes, rewires neighbors within an adaptively calculated radius to minimize path cost, tries to connect the two trees upon adding new nodes, and periodically applies shortcutting to smooth the path. Sampling is retried up to a fixed number of attempts to avoid delays. The search stops early once a better connection is found or if time expires, and the best path is extracted from the connected nodes.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position       # Tuple[float, ...]\n        self.parent = parent           # Node or None\n        self.cost = cost               # Cost from start (or tree root)\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = 0.1    # Probability to sample goal\n        self.max_sample_attempts = 30  # Max tries to sample free point\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = start_tree[:] + goal_tree[:]\n        edges = []\n\n        success = False\n        best_cost = float('inf')\n        best_connection = None\n\n        start_time = time.monotonic()\n        TIME_LIMIT = 30.0\n        step = self.step_size\n\n        def dist_sq(a, b):\n            return sum((a[i] - b[i])**2 for i in range(dim))\n\n        def dist(a, b):\n            return math.sqrt(dist_sq(a, b))\n\n        def sample_free():\n            for _ in range(self.max_sample_attempts):\n                if random.random() < self.goal_sample_rate:\n                    if not self._is_in_obstacle(goal_pos, obstacles, is_3d):\n                        return goal_pos\n                p = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n            # Fallback: sample center of map if no free sample found\n            fallback = tuple(b/2 for b in bounds)\n            if not self._is_in_obstacle(fallback, obstacles, is_3d):\n                return fallback\n            # Otherwise just return goal (risky but fallback)\n            return goal_pos\n\n        def nearest(tree, point):\n            # Return node with min dist squared\n            best = None\n            best_d = float('inf')\n            for node in tree:\n                d = dist_sq(node.position, point)\n                if d < best_d:\n                    best = node\n                    best_d = d\n            return best\n\n        def near(tree, point, radius):\n            radius_sq = radius * radius\n            return [node for node in tree if dist_sq(node.position, point) <= radius_sq]\n\n        def steer(from_p, to_p, step_sz):\n            d = dist(from_p, to_p)\n            if d <= step_sz:\n                return to_p\n            ratio = step_sz / d\n            return tuple(from_p[i] + (to_p[i] - from_p[i]) * ratio for i in range(dim))\n\n        def can_connect(a, b):\n            # Check node collision\n            if self._is_in_obstacle(b, obstacles, is_3d):\n                return False\n            # Edge collision\n            if self._is_edge_in_obstacle(a, b, obstacles, is_3d, resolution=step/5):\n                return False\n            return True\n\n        def extract_path(node_start, node_goal):\n            path_start = []\n            cur = node_start\n            while cur:\n                path_start.append(cur.position)\n                cur = cur.parent\n            path_goal = []\n            cur = node_goal\n            while cur:\n                path_goal.append(cur.position)\n                cur = cur.parent\n            return path_start[::-1] + path_goal\n\n        def shortcut_path(path):\n            if len(path) <= 2:\n                return path\n            new_path = [path[0]]\n            i = 0\n            while i < len(path)-1:\n                j = len(path)-1\n                while j > i+1:\n                    if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d, resolution=step/10):\n                        break\n                    j -= 1\n                new_path.append(path[j])\n                i = j\n            return new_path\n\n        def rewire(tree, new_node, near_nodes):\n            for near_node in near_nodes:\n                if near_node is new_node.parent:\n                    continue\n                dist_new_to_near = dist(new_node.position, near_node.position)\n                new_cost = new_node.cost + dist_new_to_near\n                if new_cost + 1e-9 < near_node.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d, resolution=step/5):\n                        # Remove old edge if any\n                        if near_node.parent:\n                            try:\n                                edges.remove((near_node.parent, near_node))\n                                near_node.parent.children.remove(near_node)\n                            except Exception:\n                                pass\n                        near_node.parent = new_node\n                        near_node.cost = new_cost\n                        new_node.add_child(near_node)\n                        edges.append((new_node, near_node))\n\n        iteration = 0\n        last_improvement_time = start_time\n\n        while iteration < self.max_iter:\n            iteration += 1\n            current_time = time.monotonic()\n            if current_time - start_time > TIME_LIMIT:\n                break\n\n            # Alternate trees\n            tree_a = start_tree if iteration % 2 == 0 else goal_tree\n            tree_b = goal_tree if iteration % 2 == 0 else start_tree\n\n            sample = sample_free()\n\n            nearest_node = nearest(tree_a, sample)\n            new_pos = steer(nearest_node.position, sample, step)\n            if not can_connect(nearest_node.position, new_pos):\n                continue\n\n            n_tree = len(tree_a) + 1\n            radius_gamma = 30.0\n            radius = min(step*5, radius_gamma * (math.log(max(n_tree,2)) / n_tree)**(1/dim))\n\n            near_nodes = near(tree_a, new_pos, radius)\n\n            # Choose best parent among near\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            min_parent = nearest_node\n            for near_node in near_nodes:\n                cost_through = near_node.cost + dist(near_node.position, new_pos)\n                if cost_through + 1e-9 < min_cost:\n                    if not self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d, resolution=step/5):\n                        min_cost = cost_through\n                        min_parent = near_node\n\n            new_node = Node(new_pos, parent=min_parent, cost=min_cost)\n            min_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((min_parent, new_node))\n\n            rewire(tree_a, new_node, near_nodes)\n\n            # Attempt to connect tree_b nodes near new_node within radius\n            connection_radius = radius\n            candidates = near(tree_b, new_node.position, connection_radius)\n\n            improved = False\n            for other_node in candidates:\n                dist_btw = dist(new_node.position, other_node.position)\n                if dist_btw <= step and can_connect(new_node.position, other_node.position):\n                    total_cost = new_node.cost + other_node.cost + dist_btw\n                    if total_cost + 1e-9 < best_cost:\n                        best_cost = total_cost\n                        best_connection = (new_node, other_node)\n                        success = True\n                        improved = True\n                        # Early stopping on improved path\n                        break\n            if improved:\n                break\n\n            # Periodically shortcut best path found so far to improve smoothness\n            if success and (iteration % 100 == 0 or (current_time - last_improvement_time > 3.0)):\n                path = extract_path(best_connection[0], best_connection[1])\n                path = shortcut_path(path)\n                last_improvement_time = current_time\n                # Update best path by reconnecting nodes on the shortcut path is skipped (no tree change)\n                extracted_path = path\n\n        # Extract final path if found\n        if success and best_connection is not None:\n            path = extract_path(best_connection[0], best_connection[1])\n            path = shortcut_path(path)\n            extracted_path = path\n        else:\n            # Try best partial connection if no full success\n            best_partial_cost = float('inf')\n            best_pair = None\n            for n1 in start_tree:\n                candidate_nodes = near(goal_tree, n1.position, step)\n                for n2 in candidate_nodes:\n                    if can_connect(n1.position, n2.position):\n                        cost_sum = n1.cost + n2.cost + dist(n1.position, n2.position)\n                        if cost_sum < best_partial_cost:\n                            best_partial_cost = cost_sum\n                            best_pair = (n1, n2)\n            if best_pair:\n                path = extract_path(best_pair[0], best_pair[1])\n                path = shortcut_path(path)\n                extracted_path = path\n                success = True\n\n        return PlannerResult(\n            success=success,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -19.61827,
          "time_improvement": 7.0,
          "length_improvement": 13.0,
          "smoothness_improvement": 1889.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.04089529514312744,
                    "num_nodes_avg": 172.9,
                    "path_length_avg": 173.05249817668198,
                    "smoothness_avg": 0.0483909382268577,
                    "success_improvement": 0.0,
                    "time_improvement": -63.41551714446586,
                    "length_improvement": 5.147183557046054,
                    "smoothness_improvement": 657.423265854588,
                    "objective_score": -12.649228679839187
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.0705744743347168,
                    "num_nodes_avg": 306.1,
                    "path_length_avg": 238.60531980912498,
                    "smoothness_avg": 0.12771648262552357,
                    "success_improvement": 0.0,
                    "time_improvement": 56.83894105289312,
                    "length_improvement": 20.34667637438295,
                    "smoothness_improvement": 3186.237088418874,
                    "objective_score": 45.190873582592076
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.035701656341552736,
                    "num_nodes_avg": 210.4,
                    "path_length_avg": 128.45622431239354,
                    "smoothness_avg": 0.1511263515170401,
                    "success_improvement": 0.0,
                    "time_improvement": 27.967643462357326,
                    "length_improvement": 14.68549223978742,
                    "smoothness_improvement": 1822.3160363098355,
                    "objective_score": 26.31316856412883
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e2",
          "algorithm_description": "A hybrid bidirectional RRT*-inspired planner combining dynamic adaptive neighborhood radius based on tree size and dimension, enhanced goal bias sampling, incremental rewiring with cost-aware parent selection, multiple connection candidates with variable-radius connections, and iterative adaptive-resolution shortcutting. The planner alternates tree expansions, uses a refined sampling strategy to avoid obstacles, tracks best path cost continuously, applies rewiring to minimize path cost locally, and performs shortcutting both during search and after solution discovery. A strict 30-second wall-clock limit enforces efficient termination returning the best feasible path found so far, ensuring improved planning speed, path quality, and smoothness.",
          "planning_mechanism": "The planner grows two trees bidirectionally from start and goal, alternating expansions. Each iteration samples collision-free points biased toward the goal and steers nearest nodes toward samples within a capped step size. It dynamically computes the neighborhood radius based on the number of tree nodes and dimension to efficiently select parents and rewire nearby nodes for lower cost. Multiple near neighbors in the opposite tree are evaluated for connections to improve solution quality. Incremental shortcutting is periodically performed to improve path smoothness. The algorithm maintains a continuous check on elapsed time to terminate early while returning the best path found.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children: List[Node] = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\nclass Planner:\n    def __init__(self, max_iter: int = 6000, step_size: float=4.0, goal_sample_rate: float=0.2):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.time_limit = 30.0  # seconds\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        start_tree = [Node(start_pos, cost=0.0)]\n        goal_tree = [Node(goal_pos, cost=0.0)]\n        all_nodes = start_tree[:] + goal_tree[:]\n        edges: List[Tuple[Node, Node]] = []\n\n        success = False\n        best_cost = float('inf')\n        best_connection = None\n        extracted_path: List[Tuple[float, ...]] = []\n\n        def dist(a: Tuple[float, ...], b: Tuple[float, ...]) -> float:\n            return math.dist(a, b)\n\n        def sample_free() -> Tuple[float, ...]:\n            for _ in range(30):\n                if random.random() < self.goal_sample_rate:\n                    p = goal_pos\n                else:\n                    p = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n            return goal_pos  # fallback\n\n        def nearest(tree: List[Node], point: Tuple[float, ...]) -> Node:\n            best_node = None\n            best_dist = float('inf')\n            for node in tree:\n                d = dist(node.position, point)\n                if d < best_dist:\n                    best_dist = d\n                    best_node = node\n            return best_node\n\n        def near(tree: List[Node], point: Tuple[float, ...], radius: float) -> List[Node]:\n            r_sq = radius * radius\n            neighbors = []\n            for node in tree:\n                d_sq = 0.0\n                for i in range(dim):\n                    delta = node.position[i] - point[i]\n                    d_sq += delta * delta\n                    if d_sq > r_sq:\n                        break\n                if d_sq <= r_sq:\n                    neighbors.append(node)\n            return neighbors\n\n        def steer(from_p: Tuple[float, ...], to_p: Tuple[float, ...], max_step: float) -> Tuple[float, ...]:\n            d = dist(from_p, to_p)\n            if d <= max_step:\n                return to_p\n            ratio = max_step / d\n            return tuple(from_p[i] + ratio * (to_p[i] - from_p[i]) for i in range(dim))\n\n        def extract_path(node_start: Node, node_goal: Node) -> List[Tuple[float, ...]]:\n            path_start = []\n            c = node_start\n            while c is not None:\n                path_start.append(c.position)\n                c = c.parent\n            path_goal = []\n            c = node_goal\n            while c is not None:\n                path_goal.append(c.position)\n                c = c.parent\n            return path_start[::-1] + path_goal\n\n        def adaptive_edge_resolution(p1: Tuple[float, ...], p2: Tuple[float, ...]) -> float:\n            length = dist(p1, p2)\n            return max(0.05, min(self.step_size / 4.0, length / 15.0))\n\n        def shortcut_path(path: List[Tuple[float, ...]], max_attempts: int = 120) -> List[Tuple[float, ...]]:\n            if len(path) < 3:\n                return path\n            for _ in range(max_attempts):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                res = adaptive_edge_resolution(p1, p2)\n                if not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution=res):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        def try_connect(new_node: Node, other_tree: List[Node], connection_radius: float) -> Tuple[Node, float]:\n            candidates = near(other_tree, new_node.position, connection_radius)\n            best_node = None\n            best_local_cost = float('inf')\n            for cnode in candidates:\n                d = dist(new_node.position, cnode.position)\n                if d <= connection_radius:\n                    res = adaptive_edge_resolution(new_node.position, cnode.position)\n                    if not self._is_edge_in_obstacle(new_node.position, cnode.position, obstacles, is_3d, resolution=res):\n                        total_cost = new_node.cost + cnode.cost + d\n                        if total_cost < best_local_cost:\n                            best_local_cost = total_cost\n                            best_node = cnode\n            return best_node, best_local_cost\n\n        start_time = time.monotonic()\n        gamma_rrt_star = 35.0  # Tuned gamma for neighborhood radius\n\n        for it in range(self.max_iter):\n            elapsed = time.monotonic() - start_time\n            if elapsed > self.time_limit:\n                break\n\n            tree_a = start_tree if it % 2 == 0 else goal_tree\n            tree_b = goal_tree if it % 2 == 0 else start_tree\n\n            sample = sample_free()\n            nearest_node = nearest(tree_a, sample)\n            new_pos = steer(nearest_node.position, sample, self.step_size)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            res = adaptive_edge_resolution(nearest_node.position, new_pos)\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d, resolution=res):\n                continue\n\n            n_nodes = len(tree_a) + 1\n            radius = min(self.step_size * 4.5, gamma_rrt_star * (math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            radius = max(radius, self.step_size * 1.5)  # Ensure minimal radius\n\n            near_nodes = near(tree_a, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            min_parent = nearest_node\n            for near_node in near_nodes:\n                candidate_cost = near_node.cost + dist(near_node.position, new_pos)\n                if candidate_cost < min_cost:\n                    res_ = adaptive_edge_resolution(near_node.position, new_pos)\n                    if not self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d, resolution=res_):\n                        min_cost = candidate_cost\n                        min_parent = near_node\n\n            new_node = Node(new_pos, parent=min_parent, cost=min_cost)\n            min_parent.add_child(new_node)\n            tree_a.append(new_node)\n            all_nodes.append(new_node)\n            edges.append((min_parent, new_node))\n\n            # Rewiring near neighbors for improved costs\n            for near_node in near_nodes:\n                if near_node == min_parent:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, near_node.position)\n                if new_cost + 1e-10 < near_node.cost:\n                    res_ = adaptive_edge_resolution(new_node.position, near_node.position)\n                    if not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d, resolution=res_):\n                        if near_node.parent is not None:\n                            try:\n                                edges.remove((near_node.parent, near_node))\n                            except ValueError:\n                                pass\n                            near_node.parent.remove_child(near_node)\n                        near_node.parent = new_node\n                        near_node.cost = new_cost\n                        new_node.add_child(near_node)\n                        edges.append((new_node, near_node))\n\n            # Try to connect the new node to the other tree with a scaled radius\n            connection_radius = max(self.step_size * 3.8, radius * 1.6)\n            conn_node, conn_cost = try_connect(new_node, tree_b, connection_radius)\n            if conn_node is not None and conn_cost < best_cost:\n                best_cost = conn_cost\n                best_connection = (new_node, conn_node)\n                success = True\n                # Early stop after finding improved connection\n                break\n\n            # Optional: incremental shortcutting every 150 iterations if solution found\n            if success and it % 150 == 0 and best_connection:\n                path_tmp = extract_path(best_connection[0], best_connection[1])\n                path_tmp = shortcut_path(path_tmp, max_attempts=60)\n                updated_length = 0.0\n                for idx in range(len(path_tmp)-1):\n                    updated_length += dist(path_tmp[idx], path_tmp[idx+1])\n                if updated_length + 1e-10 < best_cost:\n                    best_cost = updated_length\n                    extracted_path = path_tmp\n                else:\n                    extracted_path = path_tmp\n\n        if success and best_connection:\n            extracted_path = extract_path(best_connection[0], best_connection[1])\n            # Final aggressive shortcutting\n            extracted_path = shortcut_path(extracted_path, max_attempts=150)\n        else:\n            # Fallback: find best partial connection between trees\n            min_total_cost = float('inf')\n            best_pair = None\n            search_radius = self.step_size * 3.8\n            for node_start in start_tree:\n                near_goal_nodes = near(goal_tree, node_start.position, search_radius)\n                for node_goal in near_goal_nodes:\n                    d = dist(node_start.position, node_goal.position)\n                    if d <= search_radius:\n                        res_ = adaptive_edge_resolution(node_start.position, node_goal.position)\n                        if not self._is_edge_in_obstacle(node_start.position, node_goal.position, obstacles, is_3d, resolution=res_):\n                            total_cost = node_start.cost + node_goal.cost + d\n                            if total_cost < min_total_cost:\n                                min_total_cost = total_cost\n                                best_pair = (node_start, node_goal)\n            if best_pair is not None:\n                extracted_path = extract_path(best_pair[0], best_pair[1])\n                extracted_path = shortcut_path(extracted_path, max_attempts=150)\n                success = True\n\n        return PlannerResult(\n            success=success,\n            path=extracted_path,\n            nodes=all_nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -19.16486,
          "time_improvement": 9.0,
          "length_improvement": 14.0,
          "smoothness_improvement": 1574.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.0368077278137207,
                    "num_nodes_avg": 209.2,
                    "path_length_avg": 168.64867275561966,
                    "smoothness_avg": 0.05187181645120777,
                    "success_improvement": 0.0,
                    "time_improvement": -45.86184286359452,
                    "length_improvement": 7.560990053409735,
                    "smoothness_improvement": 711.9065689137142,
                    "objective_score": -5.662425982463944
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.06714100837707519,
                    "num_nodes_avg": 451.2,
                    "path_length_avg": 237.13776597345526,
                    "smoothness_avg": 0.10306668138057369,
                    "success_improvement": 0.0,
                    "time_improvement": 59.045544249196865,
                    "length_improvement": 20.836588085924536,
                    "smoothness_improvement": 2551.979947852121,
                    "objective_score": 42.97551586557439
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.042022705078125,
                    "num_nodes_avg": 323.1,
                    "path_length_avg": 129.28768473132737,
                    "smoothness_avg": 0.12254755882974096,
                    "success_improvement": 0.0,
                    "time_improvement": 14.691819260261676,
                    "length_improvement": 14.133275819422062,
                    "smoothness_improvement": 1458.7959027944373,
                    "objective_score": 20.181490783703925
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "initial",
          "algorithm_description": "This algorithm is a dual-tree variant of Rapidly-exploring Random Tree (RRT) that grows two trees from the start and goal positions, attempting to connect them as they expand. It is efficient for single-query problems due to its bidirectional search and reduced redundant exploration.",
          "planning_mechanism": "The planner alternates between growing the start and goal trees by extending towards randomly sampled points. Each extension step involves checking for collision-free motion and attempting to connect the two trees. The algorithm terminates when a valid path is formed connecting the trees.",
          "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n        nodes = []\n        edges = []\n        success_state = False\n        extracted_path = []\n\n        for iter in range(self.max_iter):\n            rand = self._sample_free(bounds, obstacles, is_3d)\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest = self._nearest(tree_a, rand)\n                new_pos = self._steer(nearest.position, rand, self.step_size)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                    continue\n                new_node = Node(new_pos, parent=nearest, cost=nearest.cost + self._distance(nearest.position, new_pos))\n                nearest.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((nearest, new_node))\n\n                connect_node = self._nearest(tree_b, new_pos)\n                if self._connect_trees(new_node, connect_node, obstacles, is_3d, tree_b, nodes, edges):\n                    success_state = True\n                    extracted_path = self._extract_path(new_node, connect_node)\n                    return PlannerResult(True, extracted_path, start_tree + goal_tree, edges)\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        while True:\n            if is_3d:\n                point = tuple(random.uniform(0, bounds[i]) for i in range(3))\n            else:\n                point = tuple(random.uniform(0, bounds[i]) for i in range(2))\n            if not self._is_in_obstacle(point, obstacles, is_3d):\n                return point\n\n    def _nearest(self, tree, point):\n        return min(tree, key=lambda node: self._distance(node.position, point))\n\n    def _steer(self, from_pos, to_pos, step_size):\n        dist = self._distance(from_pos, to_pos)\n        if dist <= step_size:\n            return to_pos\n        ratio = step_size / dist\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n    def _connect_trees(self, node_a, node_b, obstacles, is_3d, tree, nodes, edges):\n        from_pos = node_a.position\n        to_pos = node_b.position\n        if self._is_edge_in_obstacle(from_pos, to_pos, obstacles, is_3d):\n            return False\n        curr = node_b\n        path = []\n        while True:\n            new_pos = self._steer(curr.position, from_pos, self.step_size)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return False\n            if self._is_edge_in_obstacle(curr.position, new_pos, obstacles, is_3d):\n                return False\n            new_node = Node(new_pos, parent=curr, cost=curr.cost + self._distance(curr.position, new_pos))\n            curr.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((curr, new_node))\n            if self._distance(new_pos, from_pos) < self.step_size:\n                new_node_final = Node(from_pos, parent=new_node, cost=new_node.cost + self._distance(new_pos, from_pos))\n                new_node.add_child(new_node_final)\n                tree.append(new_node_final)\n                nodes.append(new_node_final)\n                edges.append((new_node, new_node_final))\n                return True\n            curr = new_node\n\n    def _extract_path(self, node_a, node_b):\n        path_a = []\n        while node_a:\n            path_a.append(node_a.position)\n            node_a = node_a.parent\n        path_b = []\n        while node_b:\n            path_b.append(node_b.position)\n            node_b = node_b.parent\n        return list(reversed(path_a)) + path_b\n\n    def _distance(self, a, b):\n        return math.dist(a, b)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = self._distance(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n    ",
          "objective": -19.085024217719432,
          "time_improvement": 68.0,
          "length_improvement": -3.0,
          "smoothness_improvement": 79.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.008335447311401368,
                    "num_nodes_avg": 101.7,
                    "path_length_avg": 188.22576488201025,
                    "smoothness_avg": 0.011187468717945251,
                    "success_improvement": 0.0,
                    "time_improvement": 66.69197695588674,
                    "length_improvement": -3.169524359941512,
                    "smoothness_improvement": 75.10817941300277,
                    "objective_score": 18.48141936786613
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.016856694221496583,
                    "num_nodes_avg": 254.8,
                    "path_length_avg": 300.19012599646163,
                    "smoothness_avg": 0.0071781032260960454,
                    "success_improvement": 0.0,
                    "time_improvement": 89.69099267396918,
                    "length_improvement": -0.21210455131052114,
                    "smoothness_improvement": 84.69776618622483,
                    "objective_score": 27.20352390233556
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.026069068908691408,
                    "num_nodes_avg": 310.9,
                    "path_length_avg": 158.2035597275041,
                    "smoothness_avg": 0.014027290647026427,
                    "success_improvement": 0.0,
                    "time_improvement": 47.40253930320688,
                    "length_improvement": -5.071271527036456,
                    "smoothness_improvement": 78.4261016432827,
                    "objective_score": 11.570129382956603
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "This algorithm is a simplified bidirectional RRT* planner designed for general 2D/3D path planning. It grows two trees from start and goal points by sampling free space, extending nearest nodes with fixed step sizes, and rewiring neighbors within an adaptively shrinking radius. It alternates tree expansions, checks collisions efficiently, and stops early upon finding a valid path within a 30-second limit, producing shorter, smoother paths with controlled planning time.",
          "planning_mechanism": "The planner samples valid random points within the map bounds, extends the nearest node of one tree towards the sample step-by-step, and rewires neighbors locally for reduced cost. Trees alternately expand and attempt connection after each new node is added. Upon connecting the trees collision-free with a lower-cost path, it stops early. The path is extracted by concatenating start and goal tree nodes, ensuring efficient exploration and adaptive neighborhood rewiring for better path quality and speed.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.time_limit = 30.0\n\n    def plan(self, map):\n        import time\n        import math\n        import random\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def in_obstacle(pos):\n            for o in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = o\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w_, h_ = o\n                    px, py = pos\n                    if x <= px <= x + w_ and y <= py <= y + h_:\n                        return True\n            return False\n\n        def edge_in_obstacle(a, b, resolution=1.0):\n            dist = math.dist(a, b)\n            steps = max(1, int(dist / resolution))\n            for i in range(steps + 1):\n                interp = tuple(a[d] + (b[d] - a[d]) * (i / steps) for d in range(dim))\n                if in_obstacle(interp):\n                    return True\n            return False\n\n        def steer(from_p, to_p):\n            dist = math.dist(from_p, to_p)\n            if dist <= self.step_size:\n                return to_p\n            r = self.step_size / dist\n            return tuple(from_p[i] + r * (to_p[i] - from_p[i]) for i in range(dim))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: math.dist(n.position, point))\n\n        def neighbors(tree, pos, radius):\n            r2 = radius * radius\n            ps = pos\n            return [n for n in tree if sum((n.position[i] - ps[i]) ** 2 for i in range(dim)) <= r2]\n\n        def propagate_cost(node):\n            for c in node.children:\n                new_cost = node.cost + math.dist(node.position, c.position)\n                if new_cost < c.cost:\n                    c.cost = new_cost\n                    propagate_cost(c)\n\n        def rewire(tree, new_node, radius):\n            for nbr in neighbors(tree, new_node.position, radius):\n                if nbr is new_node.parent:\n                    continue\n                if not edge_in_obstacle(new_node.position, nbr.position):\n                    new_cost = new_node.cost + math.dist(new_node.position, nbr.position)\n                    if new_cost < nbr.cost:\n                        nbr.update_parent(new_node, new_cost)\n                        propagate_cost(nbr)\n\n        def extract_path(n_start, n_goal):\n            path_start = []\n            cur = n_start\n            while cur:\n                path_start.append(cur.position)\n                cur = cur.parent\n            path_goal = []\n            cur = n_goal\n            while cur:\n                path_goal.append(cur.position)\n                cur = cur.parent\n            return path_start[::-1] + path_goal\n\n        start_tree = [Node(start_pos, cost=0.0)]\n        goal_tree = [Node(goal_pos, cost=0.0)]\n        all_nodes = start_tree + goal_tree\n        edges = []\n\n        best_cost = float('inf')\n        best_pair = None\n        success = False\n        result_path = []\n\n        start_time = time.monotonic()\n\n        for iter_i in range(self.max_iter):\n            if time.monotonic() - start_time > self.time_limit:\n                break\n\n            tree_a, tree_b = (start_tree, goal_tree) if iter_i % 2 == 0 else (goal_tree, start_tree)\n\n            # Sample free random point\n            while True:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not in_obstacle(sample):\n                    break\n\n            nearest_node = nearest(tree_a, sample)\n            new_pos = steer(nearest_node.position, sample)\n            if in_obstacle(new_pos) or edge_in_obstacle(nearest_node.position, new_pos):\n                continue\n\n            new_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            new_node = Node(new_pos, nearest_node, new_cost)\n            nearest_node.add_child(new_node)\n            tree_a.append(new_node)\n            all_nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n\n            # Adaptive rewiring radius decreasing with node count and dimension\n            n = len(tree_a)\n            radius = min(self.step_size * 10, self.step_size * (math.log(n + 1) / (n + 1)) ** (1 / dim))\n\n            rewire(tree_a, new_node, radius)\n\n            nearest_other = nearest(tree_b, new_pos)\n            if not edge_in_obstacle(new_pos, nearest_other.position):\n                total_cost = new_node.cost + nearest_other.cost + math.dist(new_pos, nearest_other.position)\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pair = (new_node, nearest_other)\n                    edges.append((new_node, nearest_other))\n                    result_path = extract_path(new_node, nearest_other)\n                    success = True\n                    break\n\n        if not success and best_pair:\n            result_path = extract_path(best_pair[0], best_pair[1])\n            success = True\n\n        return PlannerResult(\n            success=success,\n            path=result_path,\n            nodes=all_nodes,\n            edges=edges\n        )",
          "objective": -18.8628,
          "time_improvement": 69.0,
          "length_improvement": -4.0,
          "smoothness_improvement": 86.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.009703397750854492,
                    "num_nodes_avg": 97.6,
                    "path_length_avg": 196.9370292506685,
                    "smoothness_avg": 0.011265496617478745,
                    "success_improvement": 0.0,
                    "time_improvement": 61.22571665115339,
                    "length_improvement": -7.944306399220529,
                    "smoothness_improvement": 76.32948548099779,
                    "objective_score": 13.982778583218689
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.02524714469909668,
                    "num_nodes_avg": 229.6,
                    "path_length_avg": 304.2458696873141,
                    "smoothness_avg": 0.007102619294131871,
                    "success_improvement": 0.0,
                    "time_improvement": 84.55966536235596,
                    "length_improvement": -1.5660285334264956,
                    "smoothness_improvement": 82.75551024790802,
                    "objective_score": 24.84206003989043
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.019019341468811034,
                    "num_nodes_avg": 190.8,
                    "path_length_avg": 153.63491160873352,
                    "smoothness_avg": 0.01569018613317733,
                    "success_improvement": 0.0,
                    "time_improvement": 61.626206563474405,
                    "length_improvement": -2.0369929821942403,
                    "smoothness_improvement": 99.57800948494517,
                    "objective_score": 17.763556227150502
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "This algorithm implements a simplified bidirectional RRT* planner featuring adaptive neighborhood rewiring with logarithmic radius scaling and early stopping upon path connection. It alternates expansions from start and goal trees, samples free points with goal biasing, and uses direct nearest neighbor search for simplicity. Collision checks are enforced on nodes and edges, and the best path found so far is returned when time expires or a solution is found. The rewire step improves path length and smoothness without complex data structures, balancing performance and solution quality.",
          "planning_mechanism": "The planner grows two trees alternately from start and goal positions by sampling points with goal biasing, extends nearest nodes towards samples using fixed step sizes, then rewires neighbors within an adaptive radius to lower costs. Upon each new node, it tries to connect to the opposite tree. Search halts upon a successful connection or 30 seconds timeout, returning the best found path.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position            # Tuple[float, ...]\n        self.parent = parent                # Node or None\n        self.cost = cost                    # path cost from root\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is not None:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=5.0, goal_sample_rate=0.1):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.time_limit = 30.0\n\n    def plan(self, map):\n        import time\n        import math\n        import random\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w_, h_ = obs\n                    px, py = pos\n                    if x <= px <= x + w_ and y <= py <= y + h_:\n                        return True\n            return False\n\n        def edge_in_obstacle(a, b, resolution=1.0):\n            dist_ab = math.dist(a, b)\n            steps = max(1, int(dist_ab / resolution))\n            for i in range(steps + 1):\n                interp = tuple(a[d] + (b[d] - a[d]) * i / steps for d in range(dim))\n                if in_obstacle(interp):\n                    return True\n            return False\n\n        def steer(from_pos, to_pos):\n            dist_ = math.dist(from_pos, to_pos)\n            if dist_ <= self.step_size:\n                return to_pos\n            scale = self.step_size / dist_\n            return tuple(from_pos[d] + scale * (to_pos[d] - from_pos[d]) for d in range(dim))\n\n        def nearest(nodes, point):\n            # Linear search - simpler, small cost at typical iteration counts\n            best = None\n            best_dist = float('inf')\n            for node in nodes:\n                d = math.dist(node.position, point)\n                if d < best_dist:\n                    best = node\n                    best_dist = d\n            return best\n\n        def radius_neighbor(nodes, point, radius):\n            neighbors = []\n            r2 = radius*radius\n            for node in nodes:\n                # squared distance for efficiency\n                sq_dist = 0.0\n                for i in range(dim):\n                    diff = node.position[i] - point[i]\n                    sq_dist += diff*diff\n                    if sq_dist > r2:\n                        break\n                else:\n                    neighbors.append(node)\n            return neighbors\n\n        def extract_path(node_start, node_goal):\n            path_start = []\n            cur = node_start\n            while cur is not None:\n                path_start.append(cur.position)\n                cur = cur.parent\n            path_goal = []\n            cur = node_goal\n            while cur is not None:\n                path_goal.append(cur.position)\n                cur = cur.parent\n            return path_start[::-1] + path_goal\n\n        def propagate_cost_to_children(node):\n            for c in node.children:\n                new_cost = node.cost + math.dist(node.position, c.position)\n                if new_cost + 1e-9 < c.cost:  # small tolerance to prevent oscillations\n                    c.update_parent(node, new_cost)\n                    propagate_cost_to_children(c)\n\n        def rewire(tree_nodes, new_node):\n            n_nodes = max(len(tree_nodes), 2)  # avoid zero or one for log\n            gamma = 2 * (1 + 1/dim)**(1/dim) * ( (20.0**dim / math.pi)**(1/dim) )  # constant factor\n            radius = min(self.step_size * 10, gamma * ((math.log(n_nodes) / n_nodes)**(1/dim)) )\n            neighbors = radius_neighbor(tree_nodes, new_node.position, radius)\n            for nbr in neighbors:\n                if nbr is new_node.parent:\n                    continue\n                if not edge_in_obstacle(new_node.position, nbr.position):\n                    potential_cost = new_node.cost + math.dist(new_node.position, nbr.position)\n                    if potential_cost + 1e-9 < nbr.cost:\n                        nbr.update_parent(new_node, potential_cost)\n                        propagate_cost_to_children(nbr)\n\n        start_tree = [Node(start_pos, cost=0.0)]\n        goal_tree = [Node(goal_pos, cost=0.0)]\n        all_nodes = start_tree + goal_tree\n        edges = []\n\n        best_cost = float('inf')\n        best_pair = None\n        success = False\n        result_path = []\n\n        start_time = time.monotonic()\n\n        for i in range(self.max_iter):\n            if time.monotonic() - start_time > self.time_limit:\n                break\n\n            tree_a, tree_b = (start_tree, goal_tree) if i % 2 == 0 else (goal_tree, start_tree)\n\n            if random.random() < self.goal_sample_rate:\n                sample = goal_pos if tree_a is start_tree else start_pos\n            else:\n                # Sample free with limited retries\n                sample = None\n                for _ in range(30):\n                    s = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not in_obstacle(s):\n                        sample = s\n                        break\n                if sample is None:\n                    continue\n\n            nearest_node = nearest(tree_a, sample)\n            if nearest_node is None:\n                continue\n\n            new_pos = steer(nearest_node.position, sample)\n            if in_obstacle(new_pos):\n                continue\n            if edge_in_obstacle(nearest_node.position, new_pos):\n                continue\n\n            new_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            new_node = Node(new_pos, nearest_node, new_cost)\n            nearest_node.add_child(new_node)\n            tree_a.append(new_node)\n            all_nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n\n            rewire(tree_a, new_node)\n\n            nearest_other = nearest(tree_b, new_pos)\n            if nearest_other is not None:\n                if not edge_in_obstacle(new_pos, nearest_other.position):\n                    total_cost = new_node.cost + nearest_other.cost + math.dist(new_pos, nearest_other.position)\n                    if total_cost + 1e-9 < best_cost:\n                        best_cost = total_cost\n                        best_pair = (new_node, nearest_other)\n                        edges.append((new_node, nearest_other))\n                        result_path = extract_path(new_node, nearest_other)\n                        success = True\n                        break\n\n        if not success and best_pair is not None:\n            result_path = extract_path(best_pair[0], best_pair[1])\n            success = True\n\n        return PlannerResult(\n            success=success,\n            path=result_path,\n            nodes=all_nodes,\n            edges=edges\n        )",
          "objective": -18.77815,
          "time_improvement": 61.0,
          "length_improvement": 0.0,
          "smoothness_improvement": 88.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.014551639556884766,
                    "num_nodes_avg": 100.5,
                    "path_length_avg": 180.47607122089238,
                    "smoothness_avg": 0.011967746098343867,
                    "success_improvement": 0.0,
                    "time_improvement": 41.852389250018334,
                    "length_improvement": 1.0782055374717003,
                    "smoothness_improvement": 87.32121481569246,
                    "objective_score": 13.639246171566983
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.02003800868988037,
                    "num_nodes_avg": 233.7,
                    "path_length_avg": 296.6714701762844,
                    "smoothness_avg": 0.007355894941360163,
                    "success_improvement": 0.0,
                    "time_improvement": 87.74540395235893,
                    "length_improvement": 0.9625240403568615,
                    "smoothness_improvement": 89.27247507816692,
                    "objective_score": 27.347497985312625
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.0231964111328125,
                    "num_nodes_avg": 258.0,
                    "path_length_avg": 153.18908240188344,
                    "smoothness_avg": 0.014665091071115782,
                    "success_improvement": 0.0,
                    "time_improvement": 53.19846952961221,
                    "length_improvement": -1.740894451109899,
                    "smoothness_improvement": 86.53887596016907,
                    "objective_score": 15.347698568018568
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m2",
          "algorithm_description": "This algorithm is an enhanced bidirectional RRT* planner with an adaptive rewiring radius that shrinks with the number of nodes and problem dimension. It alternates expanding two trees from start and goal by sampling collision-free points and steering toward samples with tunable step size. The planner rewires neighbors within an adaptive radius per iteration to locally optimize path cost and attempts incremental collision-checked connections between trees. Early stopping triggers when a better connecting path is found or after 30 seconds. The code efficiently maintains parent-child relations, avoids redundant rewiring, and returns the best path found so far.",
          "planning_mechanism": "The planner grows two trees alternately by sampling feasible points inside map bounds, extending nearest nodes toward samples with a controlled step size, and rewiring nodes in a decreasing adaptive neighborhood radius based on the logarithm of node count and dimensionality. After each extension, it tries to connect the other tree via incremental steps while verifying collision-free edges. It tracks the best connecting path and stops either on timeout or when improvement is found, returning the best discovered path, nodes, and edges.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return list(reversed(path))\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=4.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map):\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        import time\n        import math\n        import random\n\n        TIME_LIMIT = 30.0\n        gamma_rrt_star = 20.0  # Tuned constant for rewiring radius (reduced slightly from 30.0)\n        resolution = max(0.3, self.step_size * 0.1)  # Collision checking resolution\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_p, to_p, step):\n            d = dist(from_p, to_p)\n            if d <= step:\n                return to_p\n            ratio = step / d if d > 0 else 0\n            return tuple(from_p[i] + (to_p[i] - from_p[i]) * ratio for i in range(dim))\n\n        def is_in_bounds(p):\n            return all(0 <= p[i] <= bounds[i] for i in range(dim))\n\n        def sample_free():\n            for _ in range(30):  # capped attempts to find free sample\n                point = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not self._is_in_obstacle(point, obstacles, is_3d):\n                    return point\n            # fallback to start or goal in unlikely event\n            return random.choice([start_pos, goal_pos])\n\n        def nearest(tree, point):\n            best_node = None\n            best_dist = float('inf')\n            for node in tree:\n                d = dist(node.position, point)\n                if d < best_dist:\n                    best_dist = d\n                    best_node = node\n            return best_node\n\n        def near(tree, point, radius):\n            return [node for node in tree if dist(node.position, point) <= radius]\n\n        def valid_node(p):\n            return is_in_bounds(p) and (not self._is_in_obstacle(p, obstacles, is_3d))\n\n        def valid_edge(f_p, t_p):\n            return not self._is_edge_in_obstacle(f_p, t_p, obstacles, is_3d, resolution)\n\n        def insert_node(tree, parent, pos):\n            cost = parent.cost + dist(parent.position, pos)\n            new_node = Node(pos, parent, cost)\n            parent.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((parent, new_node))\n            return new_node\n\n        def propagate_cost_updates(node):\n            stack = [node]\n            while stack:\n                current = stack.pop()\n                for child in current.children:\n                    new_cost = current.cost + dist(current.position, child.position)\n                    if abs(new_cost - child.cost) > 1e-9:\n                        child.cost = new_cost\n                        stack.append(child)\n\n        def try_rewire(tree, new_node, radius):\n            near_nodes = near(tree, new_node.position, radius)\n            for near_node in near_nodes:\n                if near_node is new_node or near_node is new_node.parent:\n                    continue\n                cost_through_new = new_node.cost + dist(new_node.position, near_node.position)\n                if cost_through_new + 1e-9 < near_node.cost:\n                    if valid_edge(new_node.position, near_node.position):\n                        # Rewire near_node\n                        if near_node.parent:\n                            try:\n                                edges.remove((near_node.parent, near_node))\n                                near_node.parent.children.remove(near_node)\n                            except ValueError:\n                                pass\n                        near_node.parent = new_node\n                        near_node.cost = cost_through_new\n                        new_node.children.append(near_node)\n                        edges.append((new_node, near_node))\n                        propagate_cost_updates(near_node)\n\n        def try_connect(other_tree, target_node):\n            nearest_node = nearest(other_tree, target_node.position)\n            current = nearest_node\n            while True:\n                new_pos = steer(current.position, target_node.position, self.step_size)\n                if not valid_node(new_pos) or not valid_edge(current.position, new_pos):\n                    return None\n                new_node = insert_node(other_tree, current, new_pos)\n                current = new_node\n                if dist(current.position, target_node.position) <= self.step_size:\n                    if valid_edge(current.position, target_node.position):\n                        final_node = insert_node(other_tree, current, target_node.position)\n                        return final_node\n                    else:\n                        return None\n\n        def extract_path(n_start, n_goal):\n            path_start = n_start.path_from_root()\n            path_goal = n_goal.path_from_root()\n            return path_start + path_goal[::-1]\n\n        tree_start = [Node(start_pos)]\n        tree_goal = [Node(goal_pos)]\n        nodes = tree_start + tree_goal\n        edges = []\n\n        best_path = []\n        best_cost = float('inf')\n        success = False\n\n        start_time = time.monotonic()\n        iteration = 0\n        current_tree_idx = 0  # alternate expansions 0: start tree, 1: goal tree\n\n        while True:\n            if time.monotonic() - start_time > TIME_LIMIT:\n                break\n            if iteration >= self.max_iter:\n                break\n\n            sample = sample_free()\n            tree_a = tree_start if current_tree_idx == 0 else tree_goal\n            tree_b = tree_goal if current_tree_idx == 0 else tree_start\n\n            nearest_node = nearest(tree_a, sample)\n            new_pos = steer(nearest_node.position, sample, self.step_size)\n            if not valid_node(new_pos) or not valid_edge(nearest_node.position, new_pos):\n                current_tree_idx = 1 - current_tree_idx\n                iteration += 1\n                continue\n\n            new_node = insert_node(tree_a, nearest_node, new_pos)\n            iteration += 1\n\n            n_total = len(nodes)\n            radius = min(gamma_rrt_star * (math.log(n_total) / n_total) ** (1 / dim), self.step_size * 5) if n_total > 1 else self.step_size * 2\n\n            try_rewire(tree_a, new_node, radius)\n\n            connected_node = try_connect(tree_b, new_node)\n            if connected_node is not None:\n                path_cost = new_node.cost + connected_node.cost\n                if path_cost < best_cost:\n                    best_cost = path_cost\n                    best_path = extract_path(new_node, connected_node)\n                    success = True\n                    # Early stopping on improvement\n                    break\n\n            current_tree_idx = 1 - current_tree_idx\n\n        # If no success, try best partial connection\n        if not success:\n            best_pair = None\n            min_dist = float('inf')\n            for ns in tree_start:\n                for ng in tree_goal:\n                    d = dist(ns.position, ng.position)\n                    if d < min_dist and valid_edge(ns.position, ng.position):\n                        min_dist = d\n                        best_pair = (ns, ng)\n            if best_pair:\n                best_path = extract_path(best_pair[0], best_pair[1])\n                success = False\n            else:\n                best_path = []\n\n        return PlannerResult(success=success, path=best_path, nodes=nodes, edges=edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -18.14298,
          "time_improvement": 61.0,
          "length_improvement": -0.0,
          "smoothness_improvement": 32.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.007362580299377442,
                    "num_nodes_avg": 95.5,
                    "path_length_avg": 183.83010688030691,
                    "smoothness_avg": 0.008450245792922445,
                    "success_improvement": 0.0,
                    "time_improvement": 70.57950400089936,
                    "length_improvement": -0.7601945555495325,
                    "smoothness_improvement": 32.26469666167757,
                    "objective_score": 20.879057950248477
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.0193403959274292,
                    "num_nodes_avg": 300.1,
                    "path_length_avg": 293.427148226809,
                    "smoothness_avg": 0.005154294392493812,
                    "success_improvement": 0.0,
                    "time_improvement": 88.1720412861293,
                    "length_improvement": 2.0455720897213316,
                    "smoothness_improvement": 32.6237072070568,
                    "objective_score": 27.842074175706873
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.037999963760375975,
                    "num_nodes_avg": 381.1,
                    "path_length_avg": 154.20894043648855,
                    "smoothness_avg": 0.01037109821332213,
                    "success_improvement": 0.0,
                    "time_improvement": 23.33053369238007,
                    "length_improvement": -2.4182355972737124,
                    "smoothness_improvement": 31.91960375861711,
                    "objective_score": 5.707816768142878
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "A simplified bidirectional RRT planner that alternately grows two trees from start and goal, employing efficient goal-biased sampling, fixed step size steering, and direct connection attempts without rewiring. It uses straightforward nearest neighbor searches and collision checks, early exits upon successful connection or time expiry, and returns the best found path, focusing on fast planning with reasonable path quality.",
          "planning_mechanism": "The planner alternates sampling free points biased towards the goal, extends the nearest node from the active tree towards the sample within a fixed step size if collision-free, and then tries to connect the new node directly to the opposite tree. It repeats until a collision-free connection is found or 30 seconds elapse, ensuring prompt path discovery with simple implementation.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=4.0, goal_sample_rate=0.2):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.time_limit = 30.0\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_p, to_p):\n            d = dist(from_p, to_p)\n            if d <= self.step_size:\n                return to_p\n            ratio = self.step_size / d\n            return tuple(from_p[i] + ratio * (to_p[i] - from_p[i]) for i in range(dim))\n\n        def sample_free():\n            for _ in range(30):\n                if random.random() < self.goal_sample_rate:\n                    pt = goal_pos\n                else:\n                    pt = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not self._is_in_obstacle(pt, obstacles, is_3d):\n                    return pt\n            return goal_pos\n\n        def nearest(tree, point):\n            best_node = None\n            best_dist = float('inf')\n            for node in tree:\n                d = dist(node.position, point)\n                if d < best_dist:\n                    best_node = node\n                    best_dist = d\n            return best_node\n\n        def can_connect(p1, p2):\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d)\n\n        def path_between_nodes(node_start, node_goal):\n            return node_start.path_from_root() + node_goal.path_from_root()[::-1]\n\n        start_tree = [Node(start_pos, cost=0.0)]\n        goal_tree = [Node(goal_pos, cost=0.0)]\n        nodes = list(start_tree) + list(goal_tree)\n        edges = []\n\n        success_state = False\n        extracted_path = []\n\n        start_time = time.monotonic()\n\n        for i in range(self.max_iter):\n            if time.monotonic() - start_time > self.time_limit:\n                break\n\n            # Alternate growing start and goal trees\n            active_tree = start_tree if i % 2 == 0 else goal_tree\n            other_tree = goal_tree if i % 2 == 0 else start_tree\n\n            sample = sample_free()\n            nearest_node = nearest(active_tree, sample)\n            new_pos = steer(nearest_node.position, sample)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            new_node = Node(new_pos, parent=nearest_node, cost=nearest_node.cost + dist(nearest_node.position, new_pos))\n            nearest_node.children.append(new_node)\n            active_tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n\n            nearest_other = nearest(other_tree, new_pos)\n            if dist(new_pos, nearest_other.position) <= self.step_size * 1.5 and can_connect(new_pos, nearest_other.position):\n                if active_tree is start_tree:\n                    extracted_path = path_between_nodes(new_node, nearest_other)\n                else:\n                    extracted_path = path_between_nodes(nearest_other, new_node)\n                success_state = True\n                break\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * i / steps for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -17.37517,
          "time_improvement": 68.0,
          "length_improvement": -5.0,
          "smoothness_improvement": 32.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.009443449974060058,
                    "num_nodes_avg": 187.4,
                    "path_length_avg": 191.14913321393615,
                    "smoothness_avg": 0.008517545400251562,
                    "success_improvement": 0.0,
                    "time_improvement": 62.577450496873645,
                    "length_improvement": -4.7718688664057085,
                    "smoothness_improvement": 33.31808165981467,
                    "objective_score": 16.07670423751774
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.02950732707977295,
                    "num_nodes_avg": 481.2,
                    "path_length_avg": 308.37652876946834,
                    "smoothness_avg": 0.005195372476013064,
                    "success_improvement": 0.0,
                    "time_improvement": 82.00121579309413,
                    "length_improvement": -2.9449614294789797,
                    "smoothness_improvement": 33.68067588335479,
                    "objective_score": 23.001791259657622
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.01972188949584961,
                    "num_nodes_avg": 350.3,
                    "path_length_avg": 163.32960321770582,
                    "smoothness_avg": 0.010116304662943169,
                    "success_improvement": 0.0,
                    "time_improvement": 59.96358372186559,
                    "length_improvement": -8.475745537267873,
                    "smoothness_improvement": 28.678648604700296,
                    "objective_score": 13.047021037222454
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "path_expert",
          "algorithm_description": "A novel bidirectional RRT* planner with adaptive radius rewiring, increased goal bias, multi-candidate connection with cost prioritization, incremental rewiring with early termination, and efficient path shortcutting to minimize path length and improve smoothness while respecting a 30-second runtime limit.",
          "planning_mechanism": "The planner alternately grows two trees from start and goal, samples with enhanced goal bias, steers with fixed step size, dynamically computes rewiring radius scaling with tree size, connects trees by selecting minimum-cost candidate edges, rewires neighbors incrementally to lower path cost, and periodically shortcut the best path found, stopping early after improvements or upon reaching the time limit.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\nclass Planner:\n    def __init__(self, max_iter: int = 6000, step_size: float = 4.0, goal_sample_rate: float = 0.25):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.time_limit = 30.0\n\n    def plan(self, map):\n        import time\n        import math\n        import random\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n        gamma_rrt_star = 40.0  # radius scaling coefficient\n\n        start_tree = [Node(start_pos, cost=0.0)]\n        goal_tree = [Node(goal_pos, cost=0.0)]\n        nodes = start_tree[:] + goal_tree[:]\n        edges = []\n\n        best_connection = None\n        best_cost = float('inf')\n        success = False\n        last_path_time = 0.0\n        found_improvement = False\n\n        step_size = self.step_size\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def sample_free():\n            # Enhanced goal biasing, try multiple random attempts for free space sampling\n            if random.random() < self.goal_sample_rate:\n                return goal_pos\n            for _ in range(50):\n                p = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n            # fallback rare case\n            return goal_pos\n\n        def nearest(tree, point):\n            best_node = None\n            best_dist = float('inf')\n            for node in tree:\n                d = dist(node.position, point)\n                if d < best_dist:\n                    best_node = node\n                    best_dist = d\n            return best_node\n\n        def near(tree, point, radius):\n            neighbors = []\n            r_sq = radius * radius\n            for node in tree:\n                d_sr = 0.0\n                # squared dist faster\n                dx = 0.0\n                for i in range(dim):\n                    dx += (node.position[i] - point[i]) ** 2\n                d_sr = dx\n                if d_sr <= r_sq:\n                    neighbors.append((math.sqrt(d_sr), node))\n            neighbors.sort(key=lambda x: x[0])\n            return [nd[1] for nd in neighbors]\n\n        def steer(from_p, to_p, max_step):\n            d = dist(from_p, to_p)\n            if d <= max_step:\n                return to_p\n            ratio = max_step / d\n            return tuple(from_p[i] + (to_p[i] - from_p[i]) * ratio for i in range(dim))\n\n        def extract_path(node_start, node_goal):\n            path_start = []\n            cur = node_start\n            while cur:\n                path_start.append(cur.position)\n                cur = cur.parent\n            path_goal = []\n            cur = node_goal\n            while cur:\n                path_goal.append(cur.position)\n                cur = cur.parent\n            return path_start[::-1] + path_goal\n\n        def shortcut_path(path):\n            max_attempts = 80\n            if len(path) < 3:\n                return path\n            for _ in range(max_attempts):\n                if len(path) <3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        def try_connect(node, other_tree, radius):\n            candidates = near(other_tree, node.position, radius)\n            best_node = None\n            best_cost_local = float('inf')\n            for cnode in candidates:\n                d = dist(node.position, cnode.position)\n                if d <= radius and not self._is_edge_in_obstacle(node.position, cnode.position, obstacles, is_3d):\n                    total_cost = node.cost + cnode.cost + d\n                    if total_cost < best_cost_local:\n                        best_cost_local = total_cost\n                        best_node = cnode\n            return best_node, best_cost_local\n\n        start_time = time.monotonic()\n\n        for it in range(self.max_iter):\n            current_time = time.monotonic()\n            if current_time - start_time > self.time_limit:\n                break\n\n            # Alternate expansion between start and goal trees\n            tree_a = start_tree if it % 2 == 0 else goal_tree\n            tree_b = goal_tree if it % 2 == 0 else start_tree\n\n            sample = sample_free()\n            nearest_node = nearest(tree_a, sample)\n            new_pos = steer(nearest_node.position, sample, step_size)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            n_nodes = len(tree_a) + 1\n            radius = min(step_size * 5.0, gamma_rrt_star * (math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            near_nodes = near(tree_a, new_pos, radius)\n\n            # Choose best parent minimizing cost + dist with collision checks\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            min_parent = nearest_node\n            for near_node in near_nodes:\n                cost_through = near_node.cost + dist(near_node.position, new_pos)\n                if cost_through < min_cost:\n                    if not self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d):\n                        min_cost = cost_through\n                        min_parent = near_node\n\n            new_node = Node(new_pos, parent=min_parent, cost=min_cost)\n            min_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((min_parent, new_node))\n\n            # Rewire neighbors to the new node if cost improves\n            for near_node in near_nodes:\n                if near_node == min_parent:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, near_node.position)\n                if new_cost < near_node.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                        if near_node.parent:\n                            try:\n                                edges.remove((near_node.parent, near_node))\n                            except ValueError:\n                                pass\n                            near_node.parent.remove_child(near_node)\n                        near_node.parent = new_node\n                        near_node.cost = new_cost\n                        new_node.add_child(near_node)\n                        edges.append((new_node, near_node))\n\n            # Try connecting to the other tree via multi-candidates within an adaptive radius\n            connect_radius = step_size * 3.0\n            conn_node, conn_cost = try_connect(new_node, tree_b, connect_radius)\n            if conn_node and conn_cost < best_cost:\n                best_cost = conn_cost\n                best_connection = (new_node, conn_node)\n                success = True\n                found_improvement = True\n                # Early stop large search if good improvement\n                break\n\n            # Occasionally try shortcutting path if improvement found and at longer intervals to reduce overhead\n            if found_improvement and (it % 100 == 0) and best_connection:\n                extract = extract_path(best_connection[0], best_connection[1])\n                shortcut = shortcut_path(extract)\n                # Update best path if shortcut better (by length)\n                if sum(dist(shortcut[i], shortcut[i+1]) for i in range(len(shortcut)-1)) < best_cost + 1e-4:\n                    extracted_path = shortcut\n                    best_cost = sum(dist(shortcut[i], shortcut[i+1]) for i in range(len(shortcut)-1))\n                else:\n                    extracted_path = extract\n                last_path_time = current_time\n\n        if success and best_connection:\n            # Final extraction and shortcut before return, ensures best smoothing\n            extracted_path = extract_path(best_connection[0], best_connection[1])\n            extracted_path = shortcut_path(extracted_path)\n        else:\n            # Partial solution fallback - find best bridging pair between trees if no direct connection found\n            best_pair = None\n            min_total_cost = float('inf')\n            for n1 in start_tree:\n                near_goal_candidates = near(goal_tree, n1.position, step_size * 3.0)\n                for n2 in near_goal_candidates:\n                    d12 = dist(n1.position, n2.position)\n                    if d12 <= step_size * 3.0 and not self._is_edge_in_obstacle(n1.position, n2.position, obstacles, is_3d):\n                        total_c = n1.cost + n2.cost + d12\n                        if total_c < min_total_cost:\n                            min_total_cost = total_c\n                            best_pair = (n1, n2)\n            if best_pair:\n                extracted_path = extract_path(best_pair[0], best_pair[1])\n                extracted_path = shortcut_path(extracted_path)\n                success = True\n\n        return PlannerResult(\n            success=success,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -16.53007,
          "time_improvement": -2.0,
          "length_improvement": 18.0,
          "smoothness_improvement": 1290.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.024642419815063477,
                    "num_nodes_avg": 179.0,
                    "path_length_avg": 159.33352208411497,
                    "smoothness_avg": 0.03334085740117978,
                    "success_improvement": 0.0,
                    "time_improvement": 1.5301451260861985,
                    "length_improvement": 12.66677174446971,
                    "smoothness_improvement": 421.8568191591257,
                    "objective_score": 10.168390680303313
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.07136392593383789,
                    "num_nodes_avg": 444.2,
                    "path_length_avg": 234.44041327146005,
                    "smoothness_avg": 0.08507468217422669,
                    "success_improvement": 0.0,
                    "time_improvement": 56.35613806602351,
                    "length_improvement": 21.737042056843254,
                    "smoothness_improvement": 2089.032849159595,
                    "objective_score": 40.394230899710976
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.08050923347473145,
                    "num_nodes_avg": 470.9,
                    "path_length_avg": 123.04284252116577,
                    "smoothness_avg": 0.11462654789059205,
                    "success_improvement": 0.0,
                    "time_improvement": -62.43699605260248,
                    "length_improvement": 18.280802667980794,
                    "smoothness_improvement": 1358.041228316673,
                    "objective_score": -0.9724110734089031
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "cross_over",
          "algorithm_description": "An improved bidirectional RRT* planner with adaptive neighborhood rewiring radius scaled by the number of nodes and dimension, goal-biased informed sampling constrained by an ellipsoidal heuristic for faster convergence, and dynamic step size reduction to refine smoother paths near the goal. It integrates efficient nearest neighbor and near neighbor searches, early stopping upon enhanced path discovery, and extensive post-planning iterative shortcutting for path length and smoothness optimization within a strict 30-second time limit. The planner alternately grows start and goal trees, rewires nodes progressively focusing local improvement, and connects trees by multi-candidate nearest neighbors to ensure increasingly shorter and smoother paths while minimizing unnecessary rewiring overhead.",
          "planning_mechanism": "The planner initializes two trees from start and goal, iteratively samples points biased towards the goal inside an ellipsoidal heuristic informed domain to concentrate search, and alternately extends each tree by steering within a dynamically decreased step size for smoothness. For each new node, it rewires neighbors within an adaptive radius that shrinks logarithmically relative to the current node count and dimension to optimize rewiring cost-effectiveness. The trees attempt connections by checking multiple near nodes, adopting early termination if a better path is found. After reaching the time limit or max iterations, the planner extracts the best path found and aggressively performs shortcutting using adaptive edge resolution sampling to remove unnecessary waypoints, producing a shorter and smoother collision-free path while complying with map constraints and obstacle avoidance.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position  # Tuple[float, ...]\n        self.parent = parent      # Node or None\n        self.cost = cost          # Cost from start or goal root\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except ValueError:\n            pass\nclass Planner:\n    def __init__(self, max_iter=8000, init_step_size=5.0, goal_sample_rate=0.2):\n        self.max_iter = max_iter\n        self.init_step_size = init_step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.time_limit = 30.0\n\n    def plan(self, map) -> 'PlannerResult':\n        import time\n        import math\n        import random\n\n        bounds = map.size\n        dim = len(bounds)\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = (dim == 3)\n\n        start_time = time.monotonic()\n        rnd = random.Random()\n\n        nodes_start = [Node(start_pos, parent=None, cost=0.0)]\n        nodes_goal = [Node(goal_pos, parent=None, cost=0.0)]\n        nodes_all = nodes_start + nodes_goal\n        edges = []\n\n        gamma_rrt_star = 15.0  # Tuned constant for rewiring radius\n        connection_radius_mult = 3.0\n        shortcut_attempts = 150\n        min_step_size = self.init_step_size * 0.2\n\n        def dist_sq(a, b):\n            s = 0.0\n            for i in range(dim):\n                d = a[i] - b[i]\n                s += d * d\n            return s\n\n        def dist(a, b):\n            return math.sqrt(dist_sq(a, b))\n\n        def sample_in_ellipsoid():\n            # Informed sampling inside ellipsoid: start, goal, best_cost\n            # If no solution found yet, sample uniformly\n            # Centered at middle of start and goal, major axis along line segment \n            if best_cost < float('inf'):\n                center = tuple((start_pos[i] + goal_pos[i]) / 2 for i in range(dim))\n                c_min = dist(start_pos, goal_pos)\n                if best_cost < c_min:\n                    c_min = best_cost  # avoid degenerate\n                a1 = tuple((goal_pos[i] - start_pos[i]) / c_min for i in range(dim))\n\n                while True:\n                    # Sample unit ball in dim-D\n                    x = [rnd.gauss(0, 1) for _ in range(dim)]\n                    norm = math.sqrt(sum(xi*xi for xi in x))\n                    x = [xi / norm for xi in x]\n                    r = rnd.random() ** (1 / dim)\n                    x = [xi * r for xi in x]\n\n                    # Define radii of ellipsoid\n                    radii = [best_cost / 2.0] + [(math.sqrt(best_cost**2 - c_min**2)) / 2.0] * (dim - 1)\n\n                    # Build rotation matrix to align first basis vector with a1\n                    def rotation_matrix(vec):\n                        import numpy\n                        import math\n                        import numpy.linalg\n                    # Without imports: Use Gram-Schmidt to construct rotation matrix\n                    # But to avoid imports, approximate by sampling around center bounded in map\n\n                    # Here: Approximate rotation by sampling in bounding box around center, \n                    # reject out of ellipsoid: use ellipse formula sum(x_i^2 / radii_i^2) <= 1\n                    # As reduction, sample uniformly +/- radii\n                    # Then rotate approx by aligning with a1 major axis direction (simplify by discarding)\n                    # To avoid complexity, fallback to uniform in bounding box\n\n                    # Because imports disallowed, fallback uniform sampling in bounding box approximating ellipsoid:\n                    max_radius = max(radii)\n                    trial = 0\n                    while trial < 50:\n                        sample = tuple(\n                            rnd.uniform(center[i] - max_radius, center[i] + max_radius)\n                            for i in range(dim)\n                        )\n                        val = 0.0\n                        for i_i in range(dim):\n                            val += ((sample[i_i] - center[i_i]) ** 2) / (radii[0] ** 2)\n                        if val <= 1.0:\n                            if all(0 <= sample[i_i] <= bounds[i_i] for i_i in range(dim)) and not self._is_in_obstacle(sample, obstacles, is_3d):\n                                return sample\n                        trial += 1\n                    # If fail, fallback uniform whole map sample\n                    return sample_free()\n            else:\n                # No solution yet, uniform sample with goal bias\n                return sample_free()\n\n        def sample_free():\n            for _ in range(30):\n                if rnd.random() < self.goal_sample_rate:\n                    sp = goal_pos\n                else:\n                    sp = tuple(rnd.uniform(0, bounds[i]) for i in range(dim))\n                if not self._is_in_obstacle(sp, obstacles, is_3d):\n                    return sp\n            return goal_pos\n\n        def nearest(tree, point):\n            best_node = None\n            best_d_sq = float('inf')\n            for node in tree:\n                d_sq = dist_sq(node.position, point)\n                if d_sq < best_d_sq:\n                    best_d_sq = d_sq\n                    best_node = node\n            return best_node\n\n        def near(tree, point, radius):\n            r_sq = radius * radius\n            neighbors = []\n            for node in tree:\n                d_sq = dist_sq(node.position, point)\n                if d_sq <= r_sq:\n                    neighbors.append(node)\n            return neighbors\n\n        def steer(from_p, to_p, max_step):\n            vector = tuple(to_p[i] - from_p[i] for i in range(dim))\n            dist_len = math.sqrt(sum((x ** 2 for x in vector)))\n            if dist_len <= max_step:\n                return to_p\n            ratio = max_step / dist_len\n            return tuple(from_p[i] + vector[i] * ratio for i in range(dim))\n\n        def can_connect(n1, n2):\n            edge_len = dist(n1.position, n2.position)\n            res = max(0.05, min(0.3, edge_len / 20.0))\n            return not self._is_edge_in_obstacle(n1.position, n2.position, obstacles, is_3d, res)\n\n        def extract_path(node_start, node_goal):\n            path_start = []\n            n = node_start\n            while n:\n                path_start.append(n.position)\n                n = n.parent\n            path_goal = []\n            n = node_goal\n            while n:\n                path_goal.append(n.position)\n                n = n.parent\n            return path_start[::-1] + path_goal\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            for _ in range(shortcut_attempts):\n                if len(path) < 3:\n                    break\n                i = rnd.randint(0, len(path) - 3)\n                j = rnd.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                edge_len = dist(p1, p2)\n                res_adapt = max(0.05, min(0.3, edge_len / 25.0))\n                if not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, res_adapt):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        best_cost = float('inf')\n        best_connection = None\n        success = False\n\n        def try_connect(node, other_tree, radius):\n            candidates = near(other_tree, node.position, radius)\n            best_near_node = None\n            best_loc_cost = float('inf')\n            for cnode in candidates:\n                if can_connect(node, cnode):\n                    total_cost = node.cost + cnode.cost + dist(node.position, cnode.position)\n                    if total_cost < best_loc_cost:\n                        best_near_node = cnode\n                        best_loc_cost = total_cost\n            return best_near_node, best_loc_cost\n\n        def update_step_size(iteration):\n            # Decrease step size as iterations increase to refine path near goal\n            fraction = iteration / self.max_iter\n            return max(min_step_size, self.init_step_size * (1.0 - fraction * 0.8))\n\n        for it in range(self.max_iter):\n            now = time.monotonic()\n            if now - start_time > self.time_limit:\n                break\n\n            curr_tree = nodes_start if (it % 2 == 0) else nodes_goal\n            other_tree = nodes_goal if (it % 2 == 0) else nodes_start\n\n            step_size = update_step_size(it)\n\n            sample = sample_in_ellipsoid()\n            nearest_node = nearest(curr_tree, sample)\n            new_pos = steer(nearest_node.position, sample, step_size)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            edge_len = dist(nearest_node.position, new_pos)\n            res_check = max(0.05, min(0.3, edge_len / 25.0))\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d, res_check):\n                continue\n\n            n_nodes = len(curr_tree) + 1\n            radius_rewire = min(step_size * 5.0,\n                                gamma_rrt_star * (math.log(n_nodes) / max(n_nodes, 2)) ** (1.0 / dim))\n\n            near_nodes = near(curr_tree, new_pos, radius_rewire)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            min_parent = nearest_node\n            for near_node in near_nodes:\n                if near_node is nearest_node:\n                    continue\n                cost_through = near_node.cost + dist(near_node.position, new_pos)\n                if cost_through + 1e-12 < min_cost:\n                    edge_len_nn = dist(near_node.position, new_pos)\n                    res_nn = max(0.05, min(0.3, edge_len_nn / 25.0))\n                    if not self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d, res_nn):\n                        min_cost = cost_through\n                        min_parent = near_node\n\n            new_node = Node(new_pos, parent=min_parent, cost=min_cost)\n            min_parent.add_child(new_node)\n            curr_tree.append(new_node)\n            nodes_all.append(new_node)\n            edges.append((min_parent, new_node))\n\n            # Rewire neighbors for better costs\n            for near_node in near_nodes:\n                if near_node is min_parent:\n                    continue\n                cost_through_new = new_node.cost + dist(new_node.position, near_node.position)\n                if cost_through_new + 1e-12 < near_node.cost:\n                    edge_len_n = dist(new_node.position, near_node.position)\n                    res_n = max(0.05, min(0.3, edge_len_n / 25.0))\n                    if not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d, res_n):\n                        old_parent = near_node.parent\n                        if old_parent is not None:\n                            try:\n                                edges.remove((old_parent, near_node))\n                            except ValueError:\n                                pass\n                            old_parent.remove_child(near_node)\n                        near_node.parent = new_node\n                        near_node.cost = cost_through_new\n                        new_node.add_child(near_node)\n                        edges.append((new_node, near_node))\n\n            connection_radius = step_size * connection_radius_mult\n            candidate_nodes = near(other_tree, new_node.position, connection_radius)\n            for cnode in candidate_nodes:\n                if can_connect(new_node, cnode):\n                    total_cost = new_node.cost + cnode.cost + dist(new_node.position, cnode.position)\n                    if total_cost + 1e-12 < best_cost:\n                        best_cost = total_cost\n                        best_connection = (new_node, cnode)\n                        success = True\n                        # Early stop on improvement\n                        break\n            if success:\n                break\n\n        extracted_path = []\n        if success and best_connection is not None:\n            extracted_path = extract_path(best_connection[0], best_connection[1])\n            extracted_path = shortcut_path(extracted_path)\n        else:\n            # Attempt best partial connection if no full path\n            min_cost_partial = float('inf')\n            best_pair = None\n            conn_radius_partial = self.init_step_size * connection_radius_mult\n            for ns in nodes_start:\n                candidate_goals = near(nodes_goal, ns.position, conn_radius_partial)\n                for ng in candidate_goals:\n                    if can_connect(ns, ng):\n                        cost_total = ns.cost + ng.cost + dist(ns.position, ng.position)\n                        if cost_total + 1e-12 < min_cost_partial:\n                            best_pair = (ns, ng)\n                            min_cost_partial = cost_total\n            if best_pair is not None:\n                success = True\n                extracted_path = extract_path(best_pair[0], best_pair[1])\n                extracted_path = shortcut_path(extracted_path)\n\n        return PlannerResult(\n            success=success,\n            path=extracted_path,\n            nodes=nodes_all,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -16.24903,
          "time_improvement": 1.0,
          "length_improvement": 15.0,
          "smoothness_improvement": 1456.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.04370124340057373,
                    "num_nodes_avg": 158.7,
                    "path_length_avg": 170.05419490981086,
                    "smoothness_avg": 0.04529457748006365,
                    "success_improvement": 0.0,
                    "time_improvement": -74.62794351200745,
                    "length_improvement": 6.790601088773757,
                    "smoothness_improvement": 608.9584963122804,
                    "objective_score": -15.269229918776578
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.07364349365234375,
                    "num_nodes_avg": 347.7,
                    "path_length_avg": 238.6622639842245,
                    "smoothness_avg": 0.09976553718559136,
                    "success_improvement": 0.0,
                    "time_improvement": 54.96202840244002,
                    "length_improvement": 20.327666769687532,
                    "smoothness_improvement": 2467.0391299971698,
                    "objective_score": 41.020404232530375
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.03861191272735596,
                    "num_nodes_avg": 202.8,
                    "path_length_avg": 125.69162102062869,
                    "smoothness_avg": 0.10934344234673195,
                    "success_improvement": 0.0,
                    "time_improvement": 22.095853548953784,
                    "length_improvement": 16.52161010991562,
                    "smoothness_improvement": 1290.8405157570598,
                    "objective_score": 22.995924709420805
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "This algorithm is a simplified bidirectional RRT* planner for 2D/3D environments that balances efficiency and path quality through incremental tree growth, dynamic rewiring with adaptive radius, and early stopping within a fixed time limit. It alternates growing two trees from start and goal positions, selectively rewires locally to reduce path cost, and connects the trees via cost-aware attempts, resulting in shorter, smoother paths with controlled planning time.",
          "planning_mechanism": "The planner samples free-space points within map bounds, extends nearest tree nodes toward these samples using fixed step sizes, and rewires neighboring nodes within a radius that adapts based on current tree size and dimension. It alternates expansions between the two trees to encourage rapid convergence, continually checks for collision-free edges, and attempts connection between trees upon each new node addition. Early stopping occurs when a valid connecting path is found or a 30-second limit is reached, ensuring a timely solution.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\nclass Planner:\n    def __init__(self, max_iter: int=5000, step_size: float=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.time_limit = 30.0\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        start_tree = [Node(start_pos, cost=0.0)]\n        goal_tree = [Node(goal_pos, cost=0.0)]\n        all_nodes = start_tree + goal_tree\n        edges = []\n\n        best_cost = float('inf')\n        best_pair = None\n        success_state = False\n        extracted_path = []\n\n        start_time = time.monotonic()\n\n        def in_obstacle(pos):\n            for o in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d = o\n                    px,py,pz = pos\n                    if x<=px<=x+w and y<=py<=y+h and z<=pz<=z+d:\n                        return True\n                else:\n                    x,y,w_,h_ = o\n                    px,py = pos\n                    if x<=px<=x+w_ and y<=py<=y+h_:\n                        return True\n            return False\n\n        def edge_in_obstacle(a,b,resolution=1.0):\n            dist = math.dist(a,b)\n            steps = max(1,int(dist/resolution))\n            for i in range(steps+1):\n                interp = tuple(a[d] + (b[d]-a[d])*(i/steps) for d in range(dim))\n                if in_obstacle(interp):\n                    return True\n            return False\n\n        def steer(from_p,to_p):\n            dist = math.dist(from_p,to_p)\n            if dist <= self.step_size:\n                return to_p\n            ratio = self.step_size / dist\n            return tuple(from_p[i]+ratio*(to_p[i]-from_p[i]) for i in range(dim))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: math.dist(n.position, point))\n\n        def neighbors(tree, pos, radius):\n            r2 = radius*radius\n            return [n for n in tree if sum((n.position[i]-pos[i])**2 for i in range(dim)) <= r2]\n\n        def rewire(tree, new_node, radius):\n            for neighbor in neighbors(tree, new_node.position, radius):\n                if neighbor is new_node.parent:\n                    continue\n                if not edge_in_obstacle(new_node.position, neighbor.position):\n                    new_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n                    if new_cost < neighbor.cost:\n                        neighbor.update_parent(new_node, new_cost)\n                        propagate_cost(neighbor)\n\n        def propagate_cost(node):\n            for c in node.children:\n                new_c_cost = node.cost + math.dist(node.position, c.position)\n                if new_c_cost < c.cost:\n                    c.cost = new_c_cost\n                    propagate_cost(c)\n\n        def extract_path(node_start, node_goal):\n            path_start = []\n            cur = node_start\n            while cur:\n                path_start.append(cur.position)\n                cur = cur.parent\n            path_goal = []\n            cur = node_goal\n            while cur:\n                path_goal.append(cur.position)\n                cur = cur.parent\n            return path_start[::-1] + path_goal\n\n        for i in range(self.max_iter):\n            if time.monotonic() - start_time > self.time_limit:\n                break\n\n            tree_a, tree_b = (start_tree, goal_tree) if i % 2 == 0 else (goal_tree, start_tree)\n\n            while True:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not in_obstacle(sample):\n                    break\n\n            nearest_node = nearest(tree_a, sample)\n            new_pos = steer(nearest_node.position, sample)\n            if in_obstacle(new_pos):\n                continue\n            if edge_in_obstacle(nearest_node.position, new_pos):\n                continue\n\n            new_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            new_node = Node(new_pos, parent=nearest_node, cost=new_cost)\n            nearest_node.add_child(new_node)\n            tree_a.append(new_node)\n            all_nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n\n            # Adaptive radius based on dimension and node count\n            n = len(tree_a)\n            radius = min(self.step_size*10, self.step_size * (math.log(n+1)/ (n+1))**(1/dim))\n\n            rewire(tree_a, new_node, radius)\n\n            nearest_in_other = nearest(tree_b, new_pos)\n            if not edge_in_obstacle(new_pos, nearest_in_other.position):\n                total_cost = new_node.cost + nearest_in_other.cost + math.dist(new_pos, nearest_in_other.position)\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pair = (new_node, nearest_in_other)\n                    edges.append((new_node, nearest_in_other))\n                    extracted_path = extract_path(new_node, nearest_in_other)\n                    success_state = True\n                    # Early stop immediately on better path\n                    break\n\n        if not success_state and best_pair:\n            extracted_path = extract_path(best_pair[0], best_pair[1])\n            success_state = True\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=all_nodes,\n            edges=edges\n        )",
          "objective": -15.92331,
          "time_improvement": 59.0,
          "length_improvement": -4.0,
          "smoothness_improvement": 79.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.01011044979095459,
                    "num_nodes_avg": 90.9,
                    "path_length_avg": 185.5889582260192,
                    "smoothness_avg": 0.011359402764080446,
                    "success_improvement": 0.0,
                    "time_improvement": 59.59915742460026,
                    "length_improvement": -1.7242488489175434,
                    "smoothness_improvement": 77.7993205957756,
                    "objective_score": 17.234194521008426
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.02055351734161377,
                    "num_nodes_avg": 220.3,
                    "path_length_avg": 308.67238478574893,
                    "smoothness_avg": 0.0070696561351329765,
                    "success_improvement": 0.0,
                    "time_improvement": 87.43013558493642,
                    "length_improvement": -3.0437266834567023,
                    "smoothness_improvement": 81.9073444244627,
                    "objective_score": 24.81234138752922
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.03477795124053955,
                    "num_nodes_avg": 266.5,
                    "path_length_avg": 159.64821436431708,
                    "smoothness_avg": 0.01403226451580771,
                    "success_improvement": 0.0,
                    "time_improvement": 29.831328848135353,
                    "length_improvement": -6.030742349746259,
                    "smoothness_improvement": 78.48936888704783,
                    "objective_score": 5.72340008902809
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "This algorithm is an improved bidirectional RRT* variant for efficient path planning in 2D/3D spaces with obstacles. It simultaneously grows two trees from start and goal and uses adaptive neighborhood radius rewiring to optimize path quality and smoothness. The planner incorporates early stopping based on time limit or full connection, continuous cost updates, and incremental collision checking for efficient and robust exploration.",
          "planning_mechanism": "The planner alternately samples collision-free points and extends the trees towards them by incremental steps, rewires nodes in neighborhood to improve path cost dynamically with a shrinking adaptive radius, and attempts to connect the trees whenever possible. Upon connection or timeout, it extracts the best available path. This bidirectional, rewiring-based approach accelerates convergence while improving path smoothness and length.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.time_limit = 30.0 # seconds hard limit\n\n    def plan(self, map) -> 'PlannerResult':\n        import time\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_pos, parent=None, cost=0.0)]\n        goal_tree = [Node(goal_pos, parent=None, cost=0.0)]\n\n        edges = []\n        all_nodes = start_tree + goal_tree\n\n        best_cost = float('inf')\n        best_pair = None\n\n        start_time = time.monotonic()\n\n        def dist(a,b): return math.dist(a,b)\n\n        def steer(from_p, to_p, step):\n            d = dist(from_p, to_p)\n            if d <= step:\n                return to_p\n            ratio = step / d\n            return tuple(from_p[i] + ratio*(to_p[i]-from_p[i]) for i in range(len(from_p)))\n\n        def in_obstacle(p):\n            for o in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d_ = o\n                    px,py,pz = p\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d_:\n                        return True\n                else:\n                    x,y,w,h = o\n                    px,py = p\n                    if x <= px <= x+w and y <= py <= y+h:\n                        return True\n            return False\n\n        def edge_in_obstacle(a,b, resolution=1.0):\n            length = dist(a,b)\n            steps = max(1, int(length / resolution))\n            for i in range(steps+1):\n                interp = tuple(a[d] + (b[d]-a[d])*(i/steps) for d in range(len(a)))\n                if in_obstacle(interp):\n                    return True\n            return False\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: dist(n.position, point))\n\n        def get_neighbors(tree, position, radius):\n            neighbors = []\n            r2 = radius*radius\n            for node in tree:\n                dx = sum((node.position[i]-position[i])**2 for i in range(len(position)))\n                if dx <= r2:\n                    neighbors.append(node)\n            return neighbors\n\n        def tree_cost(node):\n            return node.cost\n\n        def rewire(tree, new_node, radius):\n            neighbors = get_neighbors(tree, new_node.position, radius)\n            for n in neighbors:\n                if n == new_node.parent:\n                    continue\n                if not edge_in_obstacle(new_node.position, n.position):\n                    new_cost = new_node.cost + dist(new_node.position, n.position)\n                    if new_cost < n.cost:\n                        n.update_parent(new_node, new_cost)\n                        propagate_cost_to_children(n)\n\n        def propagate_cost_to_children(node):\n            for c in node.children:\n                new_cost = node.cost + dist(node.position, c.position)\n                if new_cost < c.cost:\n                    c.cost = new_cost\n                    propagate_cost_to_children(c)\n\n        def extract_path(n_start, n_goal):\n            path_start = []\n            cur = n_start\n            while cur:\n                path_start.append(cur.position)\n                cur = cur.parent\n            path_goal = []\n            cur = n_goal\n            while cur:\n                path_goal.append(cur.position)\n                cur = cur.parent\n            return path_start[::-1] + path_goal\n\n        def best_connection():\n            # heuristics to find closest pair between trees minimizing cost\n            min_cost = float('inf')\n            pair = None\n            for n_s in start_tree:\n                nn_g = nearest(goal_tree, n_s.position)\n                if not edge_in_obstacle(n_s.position, nn_g.position):\n                    cost = n_s.cost + nn_g.cost + dist(n_s.position, nn_g.position)\n                    if cost < min_cost:\n                        min_cost = cost\n                        pair = (n_s, nn_g)\n            return pair, min_cost\n\n        def add_node(tree, new_pos, nearest_node):\n            cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            new_node = Node(new_pos, parent=nearest_node, cost=cost)\n            nearest_node.add_child(new_node)\n            tree.append(new_node)\n            all_nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n            return new_node\n\n        dim = len(bounds)\n        gamma = 2 * (1 + 1/dim)**(1/dim) * ( ( ( ( (20.0) **dim) / (3.141592653589793) ) ) ** (1/dim) )\n        for iter in range(self.max_iter):\n            if time.monotonic() - start_time > self.time_limit:\n                break\n\n            # Alternate trees\n            tree_a, tree_b = (start_tree, goal_tree) if iter % 2 == 0 else (goal_tree, start_tree)\n\n            # Sample free point\n            while True:\n                if is_3d:\n                    rand_pt = tuple(random.uniform(0, bounds[i]) for i in range(3))\n                else:\n                    rand_pt = tuple(random.uniform(0, bounds[i]) for i in range(2))\n                if not in_obstacle(rand_pt):\n                    break\n\n            nearest_node = nearest(tree_a, rand_pt)\n            new_pos = steer(nearest_node.position, rand_pt, self.step_size)\n\n            if in_obstacle(new_pos):\n                continue\n            if edge_in_obstacle(nearest_node.position, new_pos):\n                continue\n\n            new_node = add_node(tree_a, new_pos, nearest_node)\n\n            # Adaptive rewiring radius shrinking\n            n_nodes = len(tree_a)\n            radius = min(self.step_size * 10, gamma * (math.log(n_nodes)/n_nodes) ** (1/dim)) if n_nodes > 1 else self.step_size * 10\n            rewire(tree_a, new_node, radius)\n\n            # Try to connect to other tree\n            nearest_to_new = nearest(tree_b, new_pos)\n            if not edge_in_obstacle(nearest_to_new.position, new_pos):\n                cost_candidate = new_node.cost + nearest_to_new.cost + dist(new_pos, nearest_to_new.position)\n                if cost_candidate < best_cost:\n                    best_cost = cost_candidate\n                    best_pair = (new_node, nearest_to_new)\n                    success_state = True\n                    # connect at once with edge from new_node to nearest_to_new\n                    # add connection edge but no new nodes since both nodes already in trees\n                    edges.append((new_node, nearest_to_new))\n\n                    extracted_path = extract_path(new_node, nearest_to_new)\n                    # early stopping upon connection\n                    return PlannerResult(True, extracted_path, all_nodes, edges)\n\n        # No full connection: find best partial connection\n        if best_pair:\n            extracted_path = extract_path(best_pair[0], best_pair[1])\n            success_state = True\n        else:\n            extracted_path = []\n\n        return PlannerResult(success_state, extracted_path, all_nodes, edges)",
          "objective": -15.78484,
          "time_improvement": 57.0,
          "length_improvement": -3.0,
          "smoothness_improvement": 84.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.015003848075866699,
                    "num_nodes_avg": 103.3,
                    "path_length_avg": 192.67568499854661,
                    "smoothness_avg": 0.011316157737554521,
                    "success_improvement": 0.0,
                    "time_improvement": 40.04538703306565,
                    "length_improvement": -5.608596089311703,
                    "smoothness_improvement": 77.12244202256673,
                    "objective_score": 9.034070666445507
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.024567389488220216,
                    "num_nodes_avg": 233.0,
                    "path_length_avg": 293.9305517876567,
                    "smoothness_avg": 0.007367726378713246,
                    "success_improvement": 0.0,
                    "time_improvement": 84.97538159691258,
                    "length_improvement": 1.8775214914422573,
                    "smoothness_improvement": 89.57690648310161,
                    "objective_score": 27.067011906354637
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.0273268461227417,
                    "num_nodes_avg": 217.0,
                    "path_length_avg": 157.17501272541352,
                    "smoothness_avg": 0.014573864632522077,
                    "success_improvement": 0.0,
                    "time_improvement": 44.86482352160196,
                    "length_improvement": -4.388159582392954,
                    "smoothness_improvement": 85.37848239489239,
                    "objective_score": 11.253443719019279
               }
          ],
          "success_rate": 1.0
     }
]