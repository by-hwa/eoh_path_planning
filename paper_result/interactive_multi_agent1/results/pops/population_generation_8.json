[
     {
          "operator": "cross_over",
          "algorithm_description": "This algorithm implements a bidirectional, goal-biased RRT* planner with adaptive neighborhood radius rewiring, multi-candidate bidirectional connection attempts, and incremental path shortcutting applied during planning and after completion. It enforces a strict 30-second time limit and dynamically adjusts rewiring radius based on tree size and dimension to balance exploration and refinement efficiency. The planner samples with goal bias for faster convergence, alternates expanding start and goal trees, and progressively shortcuts the best found path to minimize length and improve smoothness. Early stopping occurs upon finding a better path.",
          "planning_mechanism": "The planner grows two trees alternately from start and goal positions, samples random points with a goal bias, and extends the nearest node towards samples with a fixed step size while respecting collision constraints. It rewires nearby nodes within an adaptively shrinking radius to optimize path costs. Multiple candidates from the opposite tree are tested for connection on each new node added, enabling early termination when better paths are found. Progressive shortcutting improves path smoothness and length during planning as well as post-planning. The search halts immediately if the 30-second limit is exceeded, returning the best path found so far.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n    def add_child(self, child):\n        self.children.append(child)\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\nclass Planner:\n    def __init__(self, max_iter: int=5000, step_size: float=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.time_limit = 30.0\n        self.goal_sample_rate = 0.15  # probability to sample goal\n\n    def plan(self, map) -> 'PlannerResult':\n        import time\n        import math\n        import random\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        # Tree nodes and edges\n        start_tree = [Node(start_pos, cost=0.0)]\n        goal_tree = [Node(goal_pos, cost=0.0)]\n        nodes = start_tree[:] + goal_tree[:]\n        edges = []\n\n        best_connection = None\n        best_cost = float('inf')\n        success = False\n        extracted_path = []\n\n        step = self.step_size\n        gamma = 35.0  # radius multiplier for rewiring (RRT* theory)\n\n        start_time = time.monotonic()\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def sample_free():\n            # goal bias sampling\n            if random.random() < self.goal_sample_rate:\n                return goal_pos\n            for _ in range(100):\n                p = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n            return goal_pos  # fallback\n\n        def nearest(tree, point):\n            best_node = None\n            best_d = float('inf')\n            for node in tree:\n                d = dist(node.position, point)\n                if d < best_d:\n                    best_node = node\n                    best_d = d\n            return best_node\n\n        def near(tree, point, radius):\n            neighbors = [(dist(n.position, point), n) for n in tree if dist(n.position, point) <= radius]\n            neighbors.sort(key=lambda x: x[0])\n            return [n[1] for n in neighbors]\n\n        def steer(from_p, to_p, max_step):\n            d = dist(from_p, to_p)\n            if d <= max_step:\n                return to_p\n            ratio = max_step / d\n            return tuple(from_p[i] + (to_p[i] - from_p[i]) * ratio for i in range(dim))\n\n        def extract_path(node_start, node_goal):\n            path_start = []\n            cur = node_start\n            while cur:\n                path_start.append(cur.position)\n                cur = cur.parent\n            path_start.reverse()\n            path_goal = []\n            cur = node_goal\n            while cur:\n                path_goal.append(cur.position)\n                cur = cur.parent\n            if path_goal and path_start and path_start[-1] == path_goal[0]:\n                path_goal = path_goal[1:]\n            return path_start + path_goal\n\n        def shortcut_path(path, max_attempts=50):\n            if len(path) < 3:\n                return path\n            for _ in range(max_attempts):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution=max(step*0.2, 0.2)):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        def try_connect(new_node, other_tree):\n            radius = step*2.5\n            candidates = near(other_tree, new_node.position, radius)\n            best_cand = None\n            best_local_cost = float('inf')\n            for node in candidates:\n                d12 = dist(new_node.position, node.position)\n                if d12 <= radius and not self._is_edge_in_obstacle(new_node.position, node.position, obstacles, is_3d, resolution=max(step*0.2, 0.2)):\n                    c = new_node.cost + d12 + node.cost\n                    if c < best_local_cost:\n                        best_local_cost = c\n                        best_cand = node\n            return best_cand, best_local_cost\n\n        def rewire(tree, new_node, neighbors):\n            for nbr in neighbors:\n                if nbr is new_node.parent:\n                    continue\n                cost_through = new_node.cost + dist(new_node.position, nbr.position)\n                if cost_through + 1e-9 < nbr.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, nbr.position, obstacles, is_3d, resolution=max(step*0.2, 0.2)):\n                        if nbr.parent:\n                            try:\n                                edges.remove((nbr.parent, nbr))\n                            except Exception:\n                                pass\n                            nbr.parent.remove_child(nbr)\n                        nbr.parent = new_node\n                        nbr.cost = cost_through\n                        new_node.add_child(nbr)\n                        edges.append((new_node, nbr))\n\n        iter_since_last_shortcut = 0\n        shortcut_interval = 75\n\n        for it in range(self.max_iter):\n            if time.monotonic() - start_time > self.time_limit:\n                break\n\n            tree_a = start_tree if (it % 2 == 0) else goal_tree\n            tree_b = goal_tree if (it % 2 == 0) else start_tree\n\n            sample = sample_free()\n            nearest_node = nearest(tree_a, sample)\n            new_pos = steer(nearest_node.position, sample, step)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d, resolution=max(step*0.2, 0.2)):\n                continue\n\n            n_nodes = len(tree_a) + 1\n            radius = gamma * ((math.log(n_nodes)/n_nodes) ** (1/dim)) if n_nodes > 1 else step*5\n            radius = min(radius, step*5)\n            if radius < step:\n                radius = step\n\n            neighbors = near(tree_a, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            min_parent = nearest_node\n            for nb in neighbors:\n                cost_cand = nb.cost + dist(nb.position, new_pos)\n                if cost_cand + 1e-9 < min_cost:\n                    if not self._is_edge_in_obstacle(nb.position, new_pos, obstacles, is_3d, resolution=max(step*0.2, 0.2)):\n                        min_cost = cost_cand\n                        min_parent = nb\n\n            new_node = Node(new_pos, parent=min_parent, cost=min_cost)\n            min_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((min_parent, new_node))\n\n            rewire(tree_a, new_node, neighbors)\n\n            conn_node, conn_cost = try_connect(new_node, tree_b)\n            if conn_node is not None and conn_cost + 1e-9 < best_cost:\n                best_cost = conn_cost\n                # Maintain start_tree node first in best_connection\n                best_connection = (new_node, conn_node) if it % 2 == 0 else (conn_node, new_node)\n                success = True\n                # Early termination on improved path\n                break\n\n            iter_since_last_shortcut += 1\n            if iter_since_last_shortcut >= shortcut_interval and success:\n                path_cur = extract_path(best_connection[0], best_connection[1])\n                path_short = shortcut_path(path_cur, max_attempts=25)\n                if len(path_short) < len(path_cur):\n                    extracted_path = path_short\n                    iter_since_last_shortcut = 0\n\n        if success and best_connection is not None:\n            extracted_path = extract_path(best_connection[0], best_connection[1])\n            extracted_path = shortcut_path(extracted_path, max_attempts=75)\n        elif not success:\n            # Try partial best connection if no success\n            best_partial_cost = float('inf')\n            best_pair = None\n            search_radius = step * 3.0\n            for n1 in start_tree:\n                candidates = near(goal_tree, n1.position, search_radius)\n                for n2 in candidates:\n                    d12 = dist(n1.position, n2.position)\n                    if d12 <= search_radius:\n                        if not self._is_edge_in_obstacle(n1.position, n2.position, obstacles, is_3d, resolution=max(step*0.2, 0.2)):\n                            cost_sum = n1.cost + n2.cost + d12\n                            if cost_sum + 1e-9 < best_partial_cost:\n                                best_partial_cost = cost_sum\n                                best_pair = (n1, n2)\n            if best_pair:\n                success = True\n                extracted_path = extract_path(best_pair[0], best_pair[1])\n                extracted_path = shortcut_path(extracted_path, max_attempts=75)\n\n        return PlannerResult(\n            success=success,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -40.41506,
          "time_improvement": 74.0,
          "length_improvement": 17.0,
          "smoothness_improvement": 1612.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.010355472564697266,
                    "num_nodes_avg": 88.3,
                    "path_length_avg": 158.02445292325712,
                    "smoothness_avg": 0.04068830742889877,
                    "success_improvement": 0.0,
                    "time_improvement": 58.963282937365015,
                    "length_improvement": 13.384293295064195,
                    "smoothness_improvement": 536.8603673360356,
                    "objective_score": 28.403862694928197
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.025506019592285156,
                    "num_nodes_avg": 305.8,
                    "path_length_avg": 239.66358035944714,
                    "smoothness_avg": 0.11914932396717788,
                    "success_improvement": 0.0,
                    "time_improvement": 84.44192042954145,
                    "length_improvement": 19.993398542344394,
                    "smoothness_improvement": 2965.7979254646784,
                    "objective_score": 52.15760488159246
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.010851669311523437,
                    "num_nodes_avg": 173.2,
                    "path_length_avg": 123.90215675117983,
                    "smoothness_avg": 0.11268141879062014,
                    "success_improvement": 0.0,
                    "time_improvement": 77.97057173653472,
                    "length_improvement": 17.710087072551893,
                    "smoothness_improvement": 1333.2993297395258,
                    "objective_score": 40.683720413189185
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e2",
          "algorithm_description": "A hybrid bidirectional RRT* planner integrating adaptive neighborhood radius scaling, goal-biased sampling, alternating tree expansion, multi-candidate bidirectional connection attempts, and incremental path shortcutting applied periodically during planning as well as at the end, designed to yield efficient planning within a 30-second time limit while improving path length and smoothness. <The planner grows two trees alternately from start and goal with a fixed step size and goal-biased sampling, dynamically adapts the rewiring radius based on the current number of nodes and problem dimension, and after each node addition attempts multiple feasible connections to the opposite tree to enhance path quality. Incremental path shortcutting occurs periodically during planning to progressively smooth and shorten the path if found, and final shortcutting further improves the solution before returning. Collision checks for both nodes and edges are enforced strictly. The planner respects map bounds and obstacles, and terminates early if the time budget is exhausted, returning the best path found.>",
          "planning_mechanism": "The planner grows two trees alternately from start and goal with a fixed step size and goal-biased sampling, dynamically adapts the rewiring radius based on the current number of nodes and problem dimension, and after each node addition attempts multiple feasible connections to the opposite tree to enhance path quality. Incremental path shortcutting occurs periodically during planning to progressively smooth and shorten the path if found, and final shortcutting further improves the solution before returning. Collision checks for both nodes and edges are enforced strictly. The planner respects map bounds and obstacles, and terminates early if the time budget is exhausted, returning the best path found.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position  # Tuple[float, ...]\n        self.parent = parent      # Node or None\n        self.cost = cost          # cost from root\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, goal_sample_rate: float = 0.15):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.time_limit = 30.0  # seconds\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = dim == 3\n\n        # Constants\n        gamma_rrt_star = 35.0  # tuning parameter for neighborhood radius\n        max_near_radius = self.step_size * 5.0\n        shortcut_every = 100  # iterations between incremental shortcutting\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def sample_free():\n            # goal bias sampling with fallback attempts to sample free\n            if random.random() < self.goal_sample_rate:\n                return goal_pos\n            for _ in range(100):\n                p = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n            # fallback to goal if stuck\n            return goal_pos\n\n        def steer(from_p, to_p, max_step):\n            d = dist(from_p, to_p)\n            if d <= max_step:\n                return to_p\n            ratio = max_step / d\n            return tuple(from_p[i] + (to_p[i] - from_p[i]) * ratio for i in range(dim))\n\n        def nearest(tree, point):\n            best_node = None\n            best_dist = float('inf')\n            for node in tree:\n                d = dist(node.position, point)\n                if d < best_dist:\n                    best_node = node\n                    best_dist = d\n            return best_node\n\n        def near(tree, point, radius):\n            neighbors = []\n            sq_radius = radius * radius\n            for node in tree:\n                d = dist(node.position, point)\n                if d <= radius:\n                    neighbors.append((d, node))\n            neighbors.sort(key=lambda x: x[0])\n            return [n[1] for n in neighbors]\n\n        def path_from_root(node):\n            path = []\n            cur = node\n            while cur is not None:\n                path.append(cur.position)\n                cur = cur.parent\n            return path[::-1]\n\n        def extract_path(node_start, node_goal):\n            path_start = path_from_root(node_start)\n            path_goal = path_from_root(node_goal)\n            path_goal.reverse()\n            return path_start + path_goal\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            max_attempts = 200\n            for _ in range(max_attempts):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution=self.step_size/5.0):\n                    # shortcut the path by removing intermediate nodes between i and j\n                    path = path[:i+1] + path[j:]\n            return path\n\n        # Initialization\n        start_tree = [Node(start_pos, cost=0.0)]\n        goal_tree = [Node(goal_pos, cost=0.0)]\n        nodes = start_tree[:] + goal_tree[:]\n        edges = []\n        best_connection = None\n        best_cost = float('inf')\n        success = False\n\n        start_time = time.monotonic()\n\n        for it in range(self.max_iter):\n            if time.monotonic() - start_time > self.time_limit:\n                break\n\n            # Alternate trees\n            tree_a = start_tree if it % 2 == 0 else goal_tree\n            tree_b = goal_tree if it % 2 == 0 else start_tree\n\n            sample = sample_free()\n            nearest_node = nearest(tree_a, sample)\n            new_pos = steer(nearest_node.position, sample, self.step_size)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            n_nodes = len(tree_a) + 1\n            radius = min(max_near_radius, \n                         gamma_rrt_star * ((math.log(n_nodes) / n_nodes) ** (1 / dim)) if n_nodes > 1 else max_near_radius)\n            radius = max(radius, self.step_size)  # enforce minimum radius for rewiring\n\n            near_nodes = near(tree_a, new_pos, radius)\n\n            # Choose best parent for new_node among near_nodes\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            min_parent = nearest_node\n            for near_node in near_nodes:\n                cost_through = near_node.cost + dist(near_node.position, new_pos)\n                if cost_through < min_cost:\n                    if not self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d):\n                        min_cost = cost_through\n                        min_parent = near_node\n\n            new_node = Node(new_pos, parent=min_parent, cost=min_cost)\n            min_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((min_parent, new_node))\n\n            # Rewire neighbors through new_node if improves cost\n            for near_node in near_nodes:\n                if near_node is min_parent:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, near_node.position)\n                if new_cost < near_node.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                        if near_node.parent:\n                            try:\n                                edges.remove((near_node.parent, near_node))\n                            except ValueError:\n                                pass\n                            near_node.parent.remove_child(near_node)\n                        near_node.parent = new_node\n                        near_node.cost = new_cost\n                        new_node.add_child(near_node)\n                        edges.append((new_node, near_node))\n\n            # Attempt multiple candidate connections to tree_b within radius\n            candidates = near(tree_b, new_node.position, radius)\n            for cnode in candidates:\n                d = dist(new_node.position, cnode.position)\n                if d <= radius:\n                    if not self._is_edge_in_obstacle(new_node.position, cnode.position, obstacles, is_3d):\n                        total_cost = new_node.cost + d + cnode.cost\n                        if total_cost < best_cost:\n                            best_cost = total_cost\n                            best_connection = (new_node, cnode) if it % 2 == 0 else (cnode, new_node)\n                            success = True\n            # If found an improved connection, apply shortcutting incrementally\n            if success and (it % shortcut_every == 0):\n                path_candidate = extract_path(best_connection[0], best_connection[1])\n                path_candidate = shortcut_path(path_candidate)\n                # Update best connection path cost estimate\n                # (Note: shortcutting can only make path shorter)\n                path_length = 0.0\n                for i in range(len(path_candidate) - 1):\n                    path_length += dist(path_candidate[i], path_candidate[i+1])\n                if path_length < best_cost:\n                    best_cost = path_length\n                    extracted_path = path_candidate\n                else:\n                    extracted_path = extract_path(best_connection[0], best_connection[1])\n\n            if success and best_cost < float('inf'):\n                # Early stopping on sufficiently good connection\n                break\n\n        extracted_path = []\n        if success and best_connection is not None:\n            extracted_path = extract_path(best_connection[0], best_connection[1])\n            # Final shortcutting to smooth and shorten path\n            extracted_path = shortcut_path(extracted_path)\n        else:\n            # Attempt best partial connection after termination if none found earlier\n            partial_best_cost = float('inf')\n            best_pair = None\n            search_radius = self.step_size * 3.0\n            for n1 in start_tree:\n                candidates = near(goal_tree, n1.position, search_radius)\n                for n2 in candidates:\n                    dist12 = dist(n1.position, n2.position)\n                    if dist12 <= search_radius:\n                        if not self._is_edge_in_obstacle(n1.position, n2.position, obstacles, is_3d):\n                            total = n1.cost + dist12 + n2.cost\n                            if total < partial_best_cost:\n                                partial_best_cost = total\n                                best_pair = (n1, n2)\n            if best_pair:\n                extracted_path = extract_path(best_pair[0], best_pair[1])\n                extracted_path = shortcut_path(extracted_path)\n                success = True\n\n        return PlannerResult(\n            success=success,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=None):\n        if resolution is None:\n            resolution = self.step_size / 5.0\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -36.80587,
          "time_improvement": 62.0,
          "length_improvement": 17.0,
          "smoothness_improvement": 1583.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.016263508796691896,
                    "num_nodes_avg": 111.6,
                    "path_length_avg": 163.03107142148443,
                    "smoothness_avg": 0.04614157048396194,
                    "success_improvement": 0.0,
                    "time_improvement": 35.55088821240757,
                    "length_improvement": 10.640086361238826,
                    "smoothness_improvement": 622.2157760980351,
                    "objective_score": 20.160397160955743
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.0258897066116333,
                    "num_nodes_avg": 291.5,
                    "path_length_avg": 235.73601228675426,
                    "smoothness_avg": 0.10602997430682533,
                    "success_improvement": 0.0,
                    "time_improvement": 84.20788025892321,
                    "length_improvement": 21.30453381378809,
                    "smoothness_improvement": 2628.2276092181983,
                    "objective_score": 51.18622241204081
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.016156387329101563,
                    "num_nodes_avg": 226.7,
                    "path_length_avg": 121.90765436384295,
                    "smoothness_avg": 0.125623879476531,
                    "success_improvement": 0.0,
                    "time_improvement": 67.20173040241342,
                    "length_improvement": 19.03474059022342,
                    "smoothness_improvement": 1497.926474351237,
                    "objective_score": 39.07099584661427
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m1",
          "algorithm_description": "An enhanced bidirectional RRT* planner with adaptive neighborhood radius, goal-biased sampling, multi-candidate connection attempts, incremental path shortcutting both during and after planning, and efficient early-stopping to optimize planning time, path length, and smoothness within a strict time limit. The planner dynamically balances exploration and refinement by adaptively rewiring, sampling near the goal, and performing progressive shortcutting to deliver high-quality, smooth paths efficiently.",
          "planning_mechanism": "The planner grows two trees from start and goal, alternately sampling points with a goal bias and connecting new nodes using cost-minimizing parent selection within an adaptive neighborhood radius. It attempts multiple connections between the trees each iteration to find better connections early and uses incremental shortcutting every few iterations to smooth the best path found so far. The search respects collision and boundary constraints, halts immediately on time limit or upon a sufficiently good path, and returns the shortest, smoothest feasible path discovered.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.time_limit = 30.0\n        self.goal_sample_rate = 0.15  # 15% goal bias sampling\n\n    def plan(self, map) -> 'PlannerResult':\n        import time\n        import math\n        import random\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        # Data structures for two trees and all nodes/edges\n        start_tree = [Node(start_pos, cost=0.0)]\n        goal_tree = [Node(goal_pos, cost=0.0)]\n        nodes = start_tree[:] + goal_tree[:]\n        edges = []\n\n        gamma = 35.0  # Constant for adaptive radius\n\n        best_connection = None  # Tuple(Node_start, Node_goal)\n        best_cost = float('inf')\n        success = False\n        extracted_path = []\n\n        start_time = time.monotonic()\n        iter_since_last_shortcut = 0\n        shortcut_interval = 75\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def sample_free():\n            if random.random() < self.goal_sample_rate:\n                return goal_pos\n            for _ in range(100):\n                p = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n            return goal_pos\n\n        def nearest(tree, point):\n            best_node = None\n            best_d = float('inf')\n            for node in tree:\n                d = dist(node.position, point)\n                if d < best_d:\n                    best_node = node\n                    best_d = d\n            return best_node\n\n        def near(tree, point, radius):\n            neighbors = []\n            for node in tree:\n                d = dist(node.position, point)\n                if d <= radius:\n                    neighbors.append((d, node))\n            neighbors.sort(key=lambda x: x[0])\n            return [n[1] for n in neighbors]\n\n        def steer(from_p, to_p, max_step):\n            d = dist(from_p, to_p)\n            if d <= max_step:\n                return to_p\n            ratio = max_step / d\n            return tuple(from_p[i] + (to_p[i] - from_p[i]) * ratio for i in range(dim))\n\n        def extract_path(n_start, n_goal):\n            path_start = []\n            cur = n_start\n            while cur is not None:\n                path_start.append(cur.position)\n                cur = cur.parent\n            path_start.reverse()\n            path_goal = []\n            cur = n_goal\n            while cur is not None:\n                path_goal.append(cur.position)\n                cur = cur.parent\n            if path_goal and path_start and path_start[-1] == path_goal[0]:\n                path_goal = path_goal[1:]\n            return path_start + path_goal\n\n        def shortcut_path(path, max_attempts=50):\n            if len(path) < 3:\n                return path\n            for _ in range(max_attempts):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution=max(self.step_size * 0.2, 0.2)):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        def try_connect(new_node, other_tree):\n            radius = self.step_size * 2.5\n            candidates = near(other_tree, new_node.position, radius)\n            best_cand = None\n            best_cost_local = float('inf')\n            for node in candidates:\n                dist_between = dist(new_node.position, node.position)\n                if dist_between <= radius:\n                    if not self._is_edge_in_obstacle(new_node.position, node.position, obstacles, is_3d, resolution=max(self.step_size * 0.2, 0.2)):\n                        total_cost = new_node.cost + dist_between + node.cost\n                        if total_cost < best_cost_local:\n                            best_cost_local = total_cost\n                            best_cand = node\n            return best_cand, best_cost_local\n\n        def rewire(tree, new_node, neighbors):\n            for neighbor in neighbors:\n                if neighbor is new_node.parent:\n                    continue\n                cost_through = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_through + 1e-9 < neighbor.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d, resolution=max(self.step_size * 0.2, 0.2)):\n                        if neighbor.parent:\n                            try:\n                                edges.remove((neighbor.parent, neighbor))\n                            except Exception:\n                                pass\n                            neighbor.parent.remove_child(neighbor)\n                        neighbor.parent = new_node\n                        neighbor.cost = cost_through\n                        new_node.add_child(neighbor)\n                        edges.append((new_node, neighbor))\n\n        for it in range(self.max_iter):\n            elapsed = time.monotonic() - start_time\n            if elapsed > self.time_limit:\n                # Time limit reached: return best path found so far\n                break\n\n            tree_a = start_tree if it % 2 == 0 else goal_tree\n            tree_b = goal_tree if it % 2 == 0 else start_tree\n\n            sample = sample_free()\n\n            nearest_node = nearest(tree_a, sample)\n            new_pos = steer(nearest_node.position, sample, self.step_size)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d, resolution=max(self.step_size * 0.2,0.2)):\n                continue\n\n            n_nodes = len(tree_a) + 1\n            radius = gamma * ((math.log(n_nodes) / n_nodes) ** (1 / dim)) if n_nodes > 1 else self.step_size * 5\n            radius = min(max(radius, self.step_size), self.step_size * 5)\n\n            neighbors = near(tree_a, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            min_parent = nearest_node\n            for nb in neighbors:\n                cost_cand = nb.cost + dist(nb.position, new_pos)\n                if cost_cand + 1e-9 < min_cost:\n                    if not self._is_edge_in_obstacle(nb.position, new_pos, obstacles, is_3d, resolution=max(self.step_size * 0.2, 0.2)):\n                        min_cost = cost_cand\n                        min_parent = nb\n\n            new_node = Node(new_pos, parent=min_parent, cost=min_cost)\n            min_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((min_parent, new_node))\n\n            rewire(tree_a, new_node, neighbors)\n\n            conn_node, conn_cost = try_connect(new_node, tree_b)\n            if conn_node is not None and conn_cost + 1e-9 < best_cost:\n                best_cost = conn_cost\n                best_connection = (new_node, conn_node) if it % 2 == 0 else (conn_node, new_node)\n                success = True\n                # Early stopping on improved connection found\n                break\n\n            iter_since_last_shortcut += 1\n            if iter_since_last_shortcut >= shortcut_interval and success:\n                path_current = extract_path(best_connection[0], best_connection[1])\n                path_short = shortcut_path(path_current, max_attempts=25)\n                if len(path_short) < len(path_current):\n                    extracted_path = path_short\n                iter_since_last_shortcut = 0\n\n        if success and best_connection is not None:\n            extracted_path = extract_path(best_connection[0], best_connection[1])\n            extracted_path = shortcut_path(extracted_path, max_attempts=75)\n        else:\n            # Try best partial connection if no success\n            best_partial_cost = float('inf')\n            best_pair = None\n            search_radius = self.step_size * 3.0\n            for n1 in start_tree:\n                candidates = near(goal_tree, n1.position, search_radius)\n                for n2 in candidates:\n                    d12 = dist(n1.position, n2.position)\n                    if d12 <= search_radius:\n                        if not self._is_edge_in_obstacle(n1.position, n2.position, obstacles, is_3d, resolution=max(self.step_size*0.2, 0.2)):\n                            total = n1.cost + n2.cost + d12\n                            if total + 1e-9 < best_partial_cost:\n                                best_partial_cost = total\n                                best_pair = (n1, n2)\n            if best_pair:\n                success = True\n                extracted_path = extract_path(best_pair[0], best_pair[1])\n                extracted_path = shortcut_path(extracted_path, max_attempts=75)\n\n        return PlannerResult(\n            success=success,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -36.21566,
          "time_improvement": 64.0,
          "length_improvement": 17.0,
          "smoothness_improvement": 1312.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.01371605396270752,
                    "num_nodes_avg": 123.7,
                    "path_length_avg": 163.99128041682283,
                    "smoothness_avg": 0.04212353639054065,
                    "success_improvement": 0.0,
                    "time_improvement": 45.64595462284277,
                    "length_improvement": 10.113780595408633,
                    "smoothness_improvement": 559.3248172353049,
                    "objective_score": 22.558678830274538
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.023627471923828126,
                    "num_nodes_avg": 299.7,
                    "path_length_avg": 236.12524923847695,
                    "smoothness_avg": 0.0863515940484725,
                    "success_improvement": 0.0,
                    "time_improvement": 85.58779087777062,
                    "length_improvement": 21.1745953157386,
                    "smoothness_improvement": 2121.8887114063873,
                    "objective_score": 48.99053800980628
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.018808627128601076,
                    "num_nodes_avg": 242.3,
                    "path_length_avg": 119.77321559967584,
                    "smoothness_avg": 0.10662168036197177,
                    "success_improvement": 0.0,
                    "time_improvement": 61.81755173613783,
                    "length_improvement": 20.45233318633139,
                    "smoothness_improvement": 1256.2199042104821,
                    "objective_score": 37.09776495369259
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "time_expert",
          "algorithm_description": "A bidirectional RRT* planner with goal-biased adaptive sampling, dynamic neighborhood radius rewiring, incremental path shortcutting for smoothness, and early stopping to minimize planning time while improving path length and smoothness. The planner grows two trees alternately from start and goal, steering towards sampled points biased towards the goal region, rewiring neighbors within a shrinking radius computed in relation to the number of nodes and problem dimension. It attempts connection between trees more aggressively using multiple near neighbors and applies incremental shortcutting on the current best path throughout the search to reduce path length and smoothness. The planner respects a strict 30-second limit, returning the best feasible path found so far.",
          "planning_mechanism": "A bidirectional RRT* planner that alternates growth between start and goal trees, samples points with goal bias, dynamically adapts the rewiring radius based on node count, rewires neighbors to reduce path cost, attempts connection between trees using multiple candidates, performs incremental shortcutting to smooth the path during planning, and enforces a strict time limit with early stopping on improved solutions.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map) -> 'PlannerResult':\n        import time\n        import math\n        import random\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n        TIME_LIMIT = 30.0\n\n        start_time = time.monotonic()\n\n        def dist(p1, p2):\n            return math.dist(p1, p2)\n\n        def sample_free(goal_bias=0.2):\n            if random.random() < goal_bias:\n                if not self._is_in_obstacle(goal_pos, obstacles, is_3d):\n                    return goal_pos\n            for _ in range(30):\n                p = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n            # fallback\n            return start_pos\n\n        def steer(from_p, to_p, step):\n            d = dist(from_p, to_p)\n            if d <= step:\n                return to_p\n            ratio = step / d\n            return tuple(from_p[i] + (to_p[i] - from_p[i]) * ratio for i in range(dim))\n\n        def nearest(tree, point):\n            best_node = None\n            best_dist = float('inf')\n            for node in tree:\n                d = dist(node.position, point)\n                if d < best_dist:\n                    best_dist = d\n                    best_node = node\n            return best_node\n\n        def near(tree, point, radius):\n            r_sq = radius * radius\n            if not is_3d:\n                return [node for node in tree if (node.position[0] - point[0])**2 + (node.position[1] - point[1])**2 <= r_sq]\n            else:\n                return [node for node in tree if sum((node.position[i]-point[i])**2 for i in range(dim)) <= r_sq]\n\n        def extract_path(node_start, node_goal):\n            path_start = []\n            n = node_start\n            while n is not None:\n                path_start.append(n.position)\n                n = n.parent\n            path_goal = []\n            n = node_goal\n            while n is not None:\n                path_goal.append(n.position)\n                n = n.parent\n            return path_start[::-1] + path_goal\n\n        def try_rewire(new_node, neighbors, obstacles, is_3d):\n            improved = False\n            for near_node in neighbors:\n                if near_node is new_node.parent:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, near_node.position)\n                if new_cost + 1e-9 < near_node.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                        if near_node.parent:\n                            if near_node in near_node.parent.children:\n                                near_node.parent.children.remove(near_node)\n                        near_node.parent = new_node\n                        near_node.cost = new_cost\n                        new_node.children.append(near_node)\n                        improved = True\n            return improved\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            smoothed = [path[0]]\n            i = 0\n            while i < len(path) -1:\n                j = len(path) - 1\n                while j > i + 1:\n                    if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d, resolution=self.step_size/5):\n                        break\n                    j -= 1\n                smoothed.append(path[j])\n                i = j\n            return smoothed\n\n        # Initialize trees\n        tree_start = [Node(start_pos, parent=None, cost=0.0)]\n        tree_goal = [Node(goal_pos, parent=None, cost=0.0)]\n        all_nodes = tree_start + tree_goal\n        edges = []\n\n        best_cost = float('inf')\n        best_pair = None\n        success = False\n        last_shortcut_time = start_time\n\n        gamma = 20.0  # tuning parameter for radius\n        max_radius = self.step_size * 5\n\n        for iter_count in range(self.max_iter):\n            now = time.monotonic()\n            if now - start_time > TIME_LIMIT:\n                break\n\n            # Alternate start/goal tree growth\n            tree_a = tree_start if iter_count % 2 == 0 else tree_goal\n            tree_b = tree_goal if iter_count % 2 == 0 else tree_start\n\n            rnd = sample_free(goal_bias=0.2)\n\n            nearest_node = nearest(tree_a, rnd)\n            new_pos = steer(nearest_node.position, rnd, self.step_size)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d, resolution=self.step_size/5):\n                continue\n\n            n_nodes = len(tree_a) + 1\n            radius = min(max_radius, gamma * (math.log(max(n_nodes, 2)) / n_nodes) ** (1.0 / dim))\n\n            near_nodes = near(tree_a, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            min_parent = nearest_node\n            for near_node in near_nodes:\n                new_cost = near_node.cost + dist(near_node.position, new_pos)\n                if new_cost + 1e-9 < min_cost:\n                    if not self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d, resolution=self.step_size/5):\n                        min_cost = new_cost\n                        min_parent = near_node\n\n            new_node = Node(new_pos, parent=min_parent, cost=min_cost)\n            min_parent.children.append(new_node)\n            tree_a.append(new_node)\n            all_nodes.append(new_node)\n            edges.append((min_parent, new_node))\n\n            rewired = try_rewire(new_node, near_nodes, obstacles, is_3d)\n\n            # Attempt multiple connections from new_node to nodes in other tree within radius\n            other_near_nodes = near(tree_b, new_node.position, radius)\n            connected_this_iter = False\n            for other_node in other_near_nodes:\n                connect_dist = dist(new_node.position, other_node.position)\n                total_cost = new_node.cost + other_node.cost + connect_dist\n                if connect_dist <= self.step_size and total_cost + 1e-9 < best_cost:\n                    if not self._is_edge_in_obstacle(new_node.position, other_node.position, obstacles, is_3d, resolution=self.step_size/5):\n                        best_cost = total_cost\n                        best_pair = (new_node, other_node)\n                        success = True\n                        connected_this_iter = True\n            if connected_this_iter:\n                # Early stopping on improved path found to reduce planning time\n                break\n\n            # Periodic incremental path shortcutting on best known path to improve smoothness and length\n            if success and (now - last_shortcut_time > 0.5):\n                candidate_path = extract_path(best_pair[0], best_pair[1])\n                shortened = shortcut_path(candidate_path)\n                if len(shortened) < len(candidate_path):\n                    # Replace path with shortcut path for smoother and shorter result\n                    best_pair_short_nodes = []\n                    # Rebuild nodes for new shortcut path? \n                    # Here we keep original nodes, just update path extraction for final result\n                    # So we just update the extracted_path at end.\n                    last_shortcut_time = now\n\n        if success and best_pair is not None:\n            extracted_path = extract_path(best_pair[0], best_pair[1])\n            extracted_path = shortcut_path(extracted_path)\n        else:\n            # Attempt connection among any near nodes between trees\n            min_total_cost = float('inf')\n            candidate_pair = None\n            for n1 in tree_start:\n                near_goal_nodes = near(tree_goal, n1.position, self.step_size*1.5)\n                for n2 in near_goal_nodes:\n                    dist12 = dist(n1.position, n2.position)\n                    if dist12 <= self.step_size*1.5:\n                        total_cost = n1.cost + n2.cost + dist12\n                        if total_cost + 1e-9 < min_total_cost:\n                            if not self._is_edge_in_obstacle(n1.position, n2.position, obstacles, is_3d, resolution=self.step_size/5):\n                                min_total_cost = total_cost\n                                candidate_pair = (n1,n2)\n            if candidate_pair is not None:\n                extracted_path = extract_path(candidate_pair[0], candidate_pair[1])\n                extracted_path = shortcut_path(extracted_path)\n                success = True\n            else:\n                extracted_path = []\n\n        return PlannerResult(\n            success=success,\n            path=extracted_path,\n            nodes=all_nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -35.41092,
          "time_improvement": 55.0,
          "length_improvement": 15.0,
          "smoothness_improvement": 1973.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.016417622566223145,
                    "num_nodes_avg": 151.9,
                    "path_length_avg": 165.63929068347426,
                    "smoothness_avg": 0.06125909518606807,
                    "success_improvement": 0.0,
                    "time_improvement": 34.940165416687925,
                    "length_improvement": 9.210480053863174,
                    "smoothness_improvement": 858.8378659163208,
                    "objective_score": 20.30252698690589
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.03619728088378906,
                    "num_nodes_avg": 379.6,
                    "path_length_avg": 240.5218456435933,
                    "smoothness_avg": 0.12863602123463258,
                    "success_improvement": 0.0,
                    "time_improvement": 77.92049934774737,
                    "length_improvement": 19.706884886699935,
                    "smoothness_improvement": 3209.8974791481382,
                    "objective_score": 51.24976813208486
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.02301657199859619,
                    "num_nodes_avg": 286.4,
                    "path_length_avg": 126.87756235220226,
                    "smoothness_avg": 0.1534211955820471,
                    "success_improvement": 0.0,
                    "time_improvement": 53.27521442479559,
                    "length_improvement": 15.73396434594209,
                    "smoothness_improvement": 1851.5062834289556,
                    "objective_score": 34.68047435214871
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e2",
          "algorithm_description": "A hybrid bidirectional RRT* planner combining adaptive rewiring radius, goal bias, multi-candidate connectivity between trees each iteration, and progressive shortcutting both during and after planning. The planner alternately grows trees from start and goal, uses an adaptive radius based on the current tree size and dimension for neighborhood searches, attempts multiple connections for early improved path detection, and dynamically shortcuts the current best path to enhance smoothness and path length while enforcing strict collision constraints and a hard 30-second timeout.",
          "planning_mechanism": "A bidirectional, goal-biased RRT* planner expanding two trees alternately with adaptive neighbor radius rewiring, multiple candidate connections between trees each iteration, incremental path shortcutting during planning to enhance path quality, and early termination when improved paths are found, guaranteeing collision-free sampling and edges within map bounds, maximizing planning efficiency and path optimality.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.time_limit = 30.0\n        self.goal_sample_rate = 0.2  # Probability to bias sampling towards goal\n        self.gamma_rrt_star = 35.0  # Multiplier for adaptive radius\n        self.shortcut_interval = 75  # Iterations between incremental shortcut attempts\n\n    def plan(self, map) -> 'PlannerResult':\n        import time\n        import math\n        import random\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = dim == 3\n\n        # Initialization\n        start_tree = [Node(start_pos, cost=0.0)]\n        goal_tree = [Node(goal_pos, cost=0.0)]\n        nodes = start_tree[:] + goal_tree[:]\n        edges = []\n\n        best_connection = None\n        best_cost = float('inf')\n        success = False\n        extracted_path = []\n\n        start_time = time.monotonic()\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def sample_free():\n            # Goal biased sampling\n            if random.random() < self.goal_sample_rate:\n                return goal_pos\n            for _ in range(100):\n                p = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n            return goal_pos  # fallback if no free sample found\n\n        def nearest(tree, point):\n            best_node = None\n            best_dist = float('inf')\n            for node in tree:\n                d = dist(node.position, point)\n                if d < best_dist:\n                    best_node = node\n                    best_dist = d\n            return best_node\n\n        def near(tree, point, radius):\n            neighbors = []\n            for node in tree:\n                d = dist(node.position, point)\n                if d <= radius:\n                    neighbors.append((d, node))\n            neighbors.sort(key=lambda x: x[0])\n            return [n[1] for n in neighbors]\n\n        def steer(from_p, to_p, max_step):\n            d = dist(from_p, to_p)\n            if d <= max_step:\n                return to_p\n            ratio = max_step / d\n            return tuple(from_p[i] + (to_p[i] - from_p[i]) * ratio for i in range(dim))\n\n        def extract_path(node_start, node_goal):\n            path_start = []\n            cur = node_start\n            while cur:\n                path_start.append(cur.position)\n                cur = cur.parent\n            path_start.reverse()\n            path_goal = []\n            cur = node_goal\n            while cur:\n                path_goal.append(cur.position)\n                cur = cur.parent\n            if path_goal and path_start and path_start[-1] == path_goal[0]:\n                path_goal = path_goal[1:]\n            return path_start + path_goal\n\n        def shortcut_path(path, max_attempts=50):\n            if len(path) < 3:\n                return path\n            for _ in range(max_attempts):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution=max(self.step_size * 0.2, 0.2)):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        def rewire(tree, new_node, neighbors):\n            for nbr in neighbors:\n                if nbr is new_node.parent:\n                    continue\n                cost_through = new_node.cost + dist(new_node.position, nbr.position)\n                if cost_through + 1e-9 < nbr.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, nbr.position, obstacles, is_3d, resolution=max(self.step_size * 0.2, 0.2)):\n                        if nbr.parent:\n                            try:\n                                edges.remove((nbr.parent, nbr))\n                            except Exception:\n                                pass\n                            nbr.parent.remove_child(nbr)\n                        nbr.parent = new_node\n                        nbr.cost = cost_through\n                        new_node.add_child(nbr)\n                        edges.append((new_node, nbr))\n\n        def try_connect(new_node, other_tree):\n            radius = self.step_size * 2.5\n            candidates = near(other_tree, new_node.position, radius)\n            best_cand = None\n            best_local_cost = float('inf')\n            for node in candidates:\n                d12 = dist(new_node.position, node.position)\n                if d12 <= radius:\n                    if not self._is_edge_in_obstacle(new_node.position, node.position, obstacles, is_3d, resolution=max(self.step_size * 0.2, 0.2)):\n                        c = new_node.cost + d12 + node.cost\n                        if c < best_local_cost:\n                            best_local_cost = c\n                            best_cand = node\n            return best_cand, best_local_cost\n\n        iter_since_last_shortcut = 0\n\n        for it in range(self.max_iter):\n            if time.monotonic() - start_time > self.time_limit:\n                break\n\n            tree_a = start_tree if (it % 2 == 0) else goal_tree\n            tree_b = goal_tree if (it % 2 == 0) else start_tree\n\n            sample = sample_free()\n            nearest_node = nearest(tree_a, sample)\n            new_pos = steer(nearest_node.position, sample, self.step_size)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d, resolution=max(self.step_size * 0.2, 0.2)):\n                continue\n\n            n_nodes = len(tree_a) + 1\n            radius = self.gamma_rrt_star * ((math.log(n_nodes) / n_nodes) ** (1 / dim)) if n_nodes > 1 else self.step_size * 5\n            radius = max(min(radius, self.step_size * 5), self.step_size)\n\n            neighbors = near(tree_a, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            min_parent = nearest_node\n            for nb in neighbors:\n                cand_cost = nb.cost + dist(nb.position, new_pos)\n                if cand_cost + 1e-9 < min_cost:\n                    if not self._is_edge_in_obstacle(nb.position, new_pos, obstacles, is_3d, resolution=max(self.step_size * 0.2, 0.2)):\n                        min_cost = cand_cost\n                        min_parent = nb\n\n            new_node = Node(new_pos, parent=min_parent, cost=min_cost)\n            min_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((min_parent, new_node))\n\n            rewire(tree_a, new_node, neighbors)\n\n            conn_node, conn_cost = try_connect(new_node, tree_b)\n            if conn_node is not None and conn_cost + 1e-9 < best_cost:\n                best_cost = conn_cost\n                # Keep start_tree node first in best_connection\n                best_connection = (new_node, conn_node) if it % 2 == 0 else (conn_node, new_node)\n                success = True\n                # Early stop for improved path found\n                break\n\n            iter_since_last_shortcut += 1\n            if iter_since_last_shortcut >= self.shortcut_interval and success:\n                current_path = extract_path(best_connection[0], best_connection[1])\n                shortened = shortcut_path(current_path, max_attempts=25)\n                if len(shortened) < len(current_path):\n                    extracted_path = shortened\n                    iter_since_last_shortcut = 0\n\n        if success and best_connection is not None:\n            extracted_path = extract_path(best_connection[0], best_connection[1])\n            extracted_path = shortcut_path(extracted_path, max_attempts=75)\n        elif not success:\n            # Attempt partial best connection if no full success\n            best_partial_cost = float('inf')\n            best_pair = None\n            search_radius = self.step_size * 3.0\n            for n1 in start_tree:\n                candidates = near(goal_tree, n1.position, search_radius)\n                for n2 in candidates:\n                    d12 = dist(n1.position, n2.position)\n                    if d12 <= search_radius:\n                        if not self._is_edge_in_obstacle(n1.position, n2.position, obstacles, is_3d, resolution=max(self.step_size * 0.2, 0.2)):\n                            cost_sum = n1.cost + n2.cost + d12\n                            if cost_sum + 1e-9 < best_partial_cost:\n                                best_partial_cost = cost_sum\n                                best_pair = (n1, n2)\n            if best_pair:\n                success = True\n                extracted_path = extract_path(best_pair[0], best_pair[1])\n                extracted_path = shortcut_path(extracted_path, max_attempts=75)\n\n        return PlannerResult(\n            success=success,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -35.33628,
          "time_improvement": 62.0,
          "length_improvement": 16.0,
          "smoothness_improvement": 1443.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.012826061248779297,
                    "num_nodes_avg": 119.9,
                    "path_length_avg": 166.2253590778505,
                    "smoothness_avg": 0.03994349193242207,
                    "success_improvement": 0.0,
                    "time_improvement": 49.17282207974543,
                    "length_improvement": 8.889246680057553,
                    "smoothness_improvement": 525.2023874234374,
                    "objective_score": 22.711406569075347
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.031331658363342285,
                    "num_nodes_avg": 352.8,
                    "path_length_avg": 237.6735433615076,
                    "smoothness_avg": 0.09937583806217681,
                    "success_improvement": 0.0,
                    "time_improvement": 80.8884160804634,
                    "length_improvement": 20.65773017229562,
                    "smoothness_improvement": 2457.01189086278,
                    "objective_score": 48.94622238183029
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.021689653396606445,
                    "num_nodes_avg": 282.4,
                    "path_length_avg": 123.38229733148862,
                    "smoothness_avg": 0.1136377273219493,
                    "success_improvement": 0.0,
                    "time_improvement": 55.96892516319323,
                    "length_improvement": 18.055352946065405,
                    "smoothness_improvement": 1345.4635036706793,
                    "objective_score": 34.3512068349506
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "A simplified bidirectional RRT* planner with uniform sampling, fixed rewiring radius, single nearest-neighbor connection attempts between trees, and post-planning path shortcutting for improved generalization and clarity. The planner alternates growing start and goal trees by extending towards random samples within map bounds, rewires neighbors within a fixed radius to reduce path costs, and attempts a single connection between trees each iteration. Collision checks ensure feasibility, and the search terminates on success or after a 30-second time limit. Final shortcutting smooths the discovered path for better quality.",
          "planning_mechanism": "A bidirectional RRT* planner alternately extends start and goal trees by sampling uniformly, steering toward samples with fixed step size, rewiring neighbors within fixed radius, attempting one connection to the other tree per new node, and applying final path shortcutting; the planner enforces collision constraints, stops early if trees connect, and respects a strict 30-second time limit.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child: 'Node'):\n        self.children.append(child)\n\n    def remove_child(self, child: 'Node'):\n        if child in self.children:\n            self.children.remove(child)\nclass Planner:\n    def __init__(self, max_iter: int=5000, step_size: float=5.0, radius: float=15.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.radius = radius\n        self.time_limit = 30.0\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def sample_free():\n            for _ in range(100):\n                p = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n            return goal_pos\n\n        def nearest(tree: List[Node], point: Tuple[float, ...]) -> Node:\n            best_node = None\n            best_dist = float('inf')\n            for node in tree:\n                d = dist(node.position, point)\n                if d < best_dist:\n                    best_node = node\n                    best_dist = d\n            return best_node\n\n        def near(tree: List[Node], point: Tuple[float, ...], radius: float) -> List[Node]:\n            return [node for node in tree if dist(node.position, point) <= radius]\n\n        def steer(from_p: Tuple[float, ...], to_p: Tuple[float, ...], max_step: float) -> Tuple[float, ...]:\n            d = dist(from_p, to_p)\n            if d <= max_step:\n                return to_p\n            ratio = max_step / d\n            return tuple(from_p[i] + (to_p[i] - from_p[i]) * ratio for i in range(dim))\n\n        def path_from_root(node: Node) -> List[Tuple[float, ...]]:\n            path = []\n            cur = node\n            while cur:\n                path.append(cur.position)\n                cur = cur.parent\n            return path[::-1]\n\n        def extract_path(node_start: Node, node_goal: Node) -> List[Tuple[float, ...]]:\n            return path_from_root(node_start) + path_from_root(node_goal)[::-1]\n\n        def shortcut_path(path: List[Tuple[float, ...]]) -> List[Tuple[float, ...]]:\n            if len(path) < 3:\n                return path\n            attempts = 50\n            for _ in range(attempts):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        def can_connect(node: Node, other_tree: List[Node]) -> Node:\n            nn = nearest(other_tree, node.position)\n            if nn is None:\n                return None\n            d = dist(node.position, nn.position)\n            if d <= self.step_size * 2:\n                if not self._is_edge_in_obstacle(node.position, nn.position, obstacles, is_3d):\n                    return nn\n            return None\n\n        start_tree = [Node(start_pos, cost=0.0)]\n        goal_tree = [Node(goal_pos, cost=0.0)]\n        nodes = start_tree[:] + goal_tree[:]\n        edges = []\n\n        success = False\n        best_connection = None\n\n        start_time = time.monotonic()\n\n        for it in range(self.max_iter):\n            if (time.monotonic() - start_time) > self.time_limit:\n                break\n\n            tree_a = start_tree if it % 2 == 0 else goal_tree\n            tree_b = goal_tree if it % 2 == 0 else start_tree\n\n            q_rand = sample_free()\n            nearest_node = nearest(tree_a, q_rand)\n            q_new_pos = steer(nearest_node.position, q_rand, self.step_size)\n\n            if self._is_in_obstacle(q_new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, q_new_pos, obstacles, is_3d):\n                continue\n\n            near_nodes = near(tree_a, q_new_pos, self.radius)\n            min_cost = nearest_node.cost + dist(nearest_node.position, q_new_pos)\n            min_parent = nearest_node\n            for node_near in near_nodes:\n                tentative_cost = node_near.cost + dist(node_near.position, q_new_pos)\n                if tentative_cost < min_cost:\n                    if not self._is_edge_in_obstacle(node_near.position, q_new_pos, obstacles, is_3d):\n                        min_cost = tentative_cost\n                        min_parent = node_near\n\n            new_node = Node(q_new_pos, parent=min_parent, cost=min_cost)\n            min_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((min_parent, new_node))\n\n            for node_near in near_nodes:\n                if node_near is min_parent:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, node_near.position)\n                if new_cost < node_near.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, node_near.position, obstacles, is_3d):\n                        if node_near.parent:\n                            try:\n                                edges.remove((node_near.parent, node_near))\n                            except ValueError:\n                                pass\n                            node_near.parent.remove_child(node_near)\n                        node_near.parent = new_node\n                        node_near.cost = new_cost\n                        new_node.add_child(node_near)\n                        edges.append((new_node, node_near))\n\n            connect_node = can_connect(new_node, tree_b)\n            if connect_node:\n                success = True\n                best_connection = (new_node, connect_node)\n                break\n\n        extracted_path = []\n        if success and best_connection:\n            extracted_path = extract_path(best_connection[0], best_connection[1])\n            extracted_path = shortcut_path(extracted_path)\n\n        return PlannerResult(\n            success=success,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos: Tuple[float, ...], obstacles: List[Tuple], is_3d: bool) -> bool:\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos: Tuple[float, ...], to_pos: Tuple[float, ...], obstacles: List[Tuple], is_3d: bool, resolution: float=None) -> bool:\n        if resolution is None:\n            resolution = self.step_size / 5.0\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -35.04945,
          "time_improvement": 61.0,
          "length_improvement": 18.0,
          "smoothness_improvement": 1114.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.013187146186828614,
                    "num_nodes_avg": 97.7,
                    "path_length_avg": 161.50114946183643,
                    "smoothness_avg": 0.03788262590551579,
                    "success_improvement": 0.0,
                    "time_improvement": 47.74191293043013,
                    "length_improvement": 11.478660830486733,
                    "smoothness_improvement": 492.9453588601479,
                    "objective_score": 23.674497171721818
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.019653701782226564,
                    "num_nodes_avg": 242.1,
                    "path_length_avg": 231.69187084197614,
                    "smoothness_avg": 0.07171647151821622,
                    "success_improvement": 0.0,
                    "time_improvement": 88.01169837278601,
                    "length_improvement": 22.65458463221231,
                    "smoothness_improvement": 1745.3164674502154,
                    "objective_score": 48.72284262841427
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.0253204345703125,
                    "num_nodes_avg": 276.4,
                    "path_length_avg": 118.81386101626404,
                    "smoothness_avg": 0.09462052625609715,
                    "success_improvement": 0.0,
                    "time_improvement": 48.59825885275171,
                    "length_improvement": 21.08949082107735,
                    "smoothness_improvement": 1103.5661098168082,
                    "objective_score": 32.75100269755596
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "A simplified bidirectional RRT* planner emphasizing adaptive neighborhood radius, goal-biased sampling, and efficient rewiring. The planner alternates between growing two trees from start and goal positions, uses an adaptive radius that shrinks as the trees grow to limit rewiring scope, selectively rewires neighbors to improve path cost, attempts multiple connections to the opposite tree for early path discovery, and performs final path shortcutting to enhance smoothness. Time is strictly limited to 30 seconds with early termination upon finding a high-quality path.",
          "planning_mechanism": "A bidirectional RRT* algorithm that grows two trees alternately towards random samples biased towards the goal, uses adaptive radius calculations for neighbor search and rewiring proportional to tree size and problem dimension, selects parents and rewires neighbors based on path cost improvements, attempts multiple connection candidates between the two trees each iteration for improved convergence, and applies shortcutting after path extraction to smooth the final path. The planner enforces collision checks on nodes and edges and respects a hard 30-second time limit for planning.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=5.0, goal_sample_rate=0.15):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.time_limit = 30.0\n\n    def plan(self, map):\n        import time\n        import math\n        import random\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = dim == 3\n\n        gamma_rrt_star = 50.0  # neighborhood radius constant\n        max_radius_factor = self.step_size * 5.0\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        # Samples a point free of obstacles, with goal bias\n        def sample_free():\n            if random.random() < self.goal_sample_rate:\n                return goal_pos\n            for _ in range(100):\n                p = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n            return goal_pos\n\n        # Find nearest node in tree to point (linear search)\n        def nearest(tree, point):\n            best_node = None\n            best_dist = float('inf')\n            for node in tree:\n                d = dist(node.position, point)\n                if d < best_dist:\n                    best_node = node\n                    best_dist = d\n            return best_node\n\n        # Find neighbors within radius\n        def near(tree, point, radius):\n            results = []\n            for node in tree:\n                d = dist(node.position, point)\n                if d <= radius:\n                    results.append((d, node))\n            results.sort(key=lambda x: x[0])\n            return [n[1] for n in results]\n\n        # Steer towards point by step_size\n        def steer(from_p, to_p, max_step):\n            d = dist(from_p, to_p)\n            if d <= max_step:\n                return to_p\n            ratio = max_step / d\n            return tuple(from_p[i] + (to_p[i] - from_p[i]) * ratio for i in range(dim))\n\n        # Extract path by traversing from node up to root\n        def path_from_start(node):\n            p = []\n            cur = node\n            while cur:\n                p.append(cur.position)\n                cur = cur.parent\n            return p[::-1]\n\n        # Combine two paths at connection nodes\n        def extract_path(node_start, node_goal):\n            return path_from_start(node_start) + path_from_start(node_goal)[::-1]\n\n        # Shortcut path by randomly connecting non-adjacent nodes if collision free\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            max_attempts = 100\n            for _ in range(max_attempts):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        # Attempt multiple connections to other tree within radius\n        def try_connect(node, other_tree, radius):\n            candidates = near(other_tree, node.position, radius)\n            best_node = None\n            best_cost = float('inf')\n            for cnode in candidates:\n                d = dist(node.position, cnode.position)\n                if d <= radius:\n                    if not self._is_edge_in_obstacle(node.position, cnode.position, obstacles, is_3d):\n                        cost = node.cost + d + cnode.cost\n                        if cost < best_cost:\n                            best_cost = cost\n                            best_node = cnode\n            return best_node, best_cost\n\n        start_tree = [Node(start_pos, cost=0.0)]\n        goal_tree = [Node(goal_pos, cost=0.0)]\n        nodes = start_tree[:] + goal_tree[:]\n        edges = []\n\n        best_connection = None\n        best_cost = float('inf')\n        success = False\n\n        start_time = time.monotonic()\n\n        for it in range(self.max_iter):\n            if time.monotonic() - start_time > self.time_limit:\n                break\n\n            tree_a = start_tree if it % 2 == 0 else goal_tree\n            tree_b = goal_tree if it % 2 == 0 else start_tree\n\n            sample = sample_free()\n            nearest_node = nearest(tree_a, sample)\n            new_pos = steer(nearest_node.position, sample, self.step_size)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            n_nodes = len(tree_a) + 1\n            radius = min(max_radius_factor, gamma_rrt_star * (math.log(n_nodes) / n_nodes) ** (1 / dim))\n\n            near_nodes = near(tree_a, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            min_parent = nearest_node\n            for near_node in near_nodes:\n                cost_through = near_node.cost + dist(near_node.position, new_pos)\n                if cost_through < min_cost:\n                    if not self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d):\n                        min_cost = cost_through\n                        min_parent = near_node\n\n            new_node = Node(new_pos, parent=min_parent, cost=min_cost)\n            min_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((min_parent, new_node))\n\n            for near_node in near_nodes:\n                if near_node is min_parent:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, near_node.position)\n                if new_cost < near_node.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                        if near_node.parent:\n                            try:\n                                edges.remove((near_node.parent, near_node))\n                            except ValueError:\n                                pass\n                            near_node.parent.remove_child(near_node)\n                        near_node.parent = new_node\n                        near_node.cost = new_cost\n                        new_node.add_child(near_node)\n                        edges.append((new_node, near_node))\n\n            candidate_node, candidate_cost = try_connect(new_node, tree_b, radius)\n            if candidate_node and candidate_cost < best_cost:\n                best_cost = candidate_cost\n                best_connection = (new_node, candidate_node)\n                success = True\n                break\n\n        extracted_path = []\n        if success and best_connection:\n            extracted_path = extract_path(best_connection[0], best_connection[1])\n            extracted_path = shortcut_path(extracted_path)\n        else:\n            # Try to find best partial connection after time or iteration limit\n            min_cost = float('inf')\n            best_pair = None\n            for n1 in start_tree:\n                candidates = near(goal_tree, n1.position, self.step_size * 2.0)\n                for n2 in candidates:\n                    dist12 = dist(n1.position, n2.position)\n                    if dist12 <= self.step_size * 2.0:\n                        if not self._is_edge_in_obstacle(n1.position, n2.position, obstacles, is_3d):\n                            total_cost = n1.cost + n2.cost + dist12\n                            if total_cost < min_cost:\n                                min_cost = total_cost\n                                best_pair = (n1, n2)\n            if best_pair:\n                extracted_path = extract_path(best_pair[0], best_pair[1])\n                extracted_path = shortcut_path(extracted_path)\n                success = True\n\n        return PlannerResult(\n            success=success,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=None):\n        import math\n        if resolution is None:\n            resolution = self.step_size / 5.0\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -35.02465,
          "time_improvement": 62.0,
          "length_improvement": 16.0,
          "smoothness_improvement": 1338.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.014973735809326172,
                    "num_nodes_avg": 100.0,
                    "path_length_avg": 164.06931857874386,
                    "smoothness_avg": 0.0462349451248111,
                    "success_improvement": 0.0,
                    "time_improvement": 40.66200688196913,
                    "length_improvement": 10.071006642265907,
                    "smoothness_improvement": 623.6772919936026,
                    "objective_score": 21.359592509918294
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.02514317035675049,
                    "num_nodes_avg": 295.6,
                    "path_length_avg": 233.50230248538378,
                    "smoothness_avg": 0.0900000244936007,
                    "success_improvement": 0.0,
                    "time_improvement": 84.66325003599387,
                    "length_improvement": 22.050210439257324,
                    "smoothness_improvement": 2215.765454617767,
                    "objective_score": 49.70792854744139
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.01985325813293457,
                    "num_nodes_avg": 219.8,
                    "path_length_avg": 124.90025967338326,
                    "smoothness_avg": 0.1001426301281518,
                    "success_improvement": 0.0,
                    "time_improvement": 59.696898856739885,
                    "length_improvement": 17.047194636178148,
                    "smoothness_improvement": 1173.8068634700342,
                    "objective_score": 34.006420756079024
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "A simplified bidirectional RRT* planner with adaptive neighborhood radius, goal-biased sampling, alternating tree growth, selective rewiring, and post-planning shortcutting to enhance planning efficiency, path quality, and smoothness within a strict 30-second time limit.",
          "planning_mechanism": "The planner grows two trees alternately from start and goal positions by sampling points biased towards the goal, steering nearest nodes with a fixed step size, rewiring nearby nodes within an adaptively computed radius based on tree size and dimension to improve path costs, attempting multiple candidate connections between the trees each iteration, enforcing collision avoidance checks for nodes and edges, and performing post-planning shortcutting to smooth the extracted path. Early termination occurs once a sufficiently optimal connection is found or upon reaching the time limit.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=5.0, goal_sample_rate=0.15):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.time_limit = 30.0\n\n    def plan(self, map):\n        import time\n        import random\n        import math\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = dim == 3\n\n        gamma_rrt_star = 40.0\n        max_radius = self.step_size * 5.0\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def sample_free():\n            if random.random() < self.goal_sample_rate:\n                return goal_pos\n            for _ in range(100):\n                p = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n            return goal_pos\n\n        def nearest(tree, point):\n            best_node = None\n            best_dist = float('inf')\n            for node in tree:\n                d = dist(node.position, point)\n                if d < best_dist:\n                    best_node = node\n                    best_dist = d\n            return best_node\n\n        def near(tree, point, radius):\n            neighbors = []\n            for node in tree:\n                d = dist(node.position, point)\n                if d <= radius:\n                    neighbors.append((d, node))\n            neighbors.sort(key=lambda x: x[0])\n            return [n[1] for n in neighbors]\n\n        def steer(from_p, to_p, max_step):\n            d = dist(from_p, to_p)\n            if d <= max_step:\n                return to_p\n            ratio = max_step / d\n            return tuple(from_p[i] + (to_p[i] - from_p[i]) * ratio for i in range(dim))\n\n        def path_from_root(node):\n            path = []\n            current = node\n            while current is not None:\n                path.append(current.position)\n                current = current.parent\n            return path[::-1]\n\n        def extract_path(node_start, node_goal):\n            path_start = path_from_root(node_start)\n            path_goal = path_from_root(node_goal)\n            path_goal.reverse()\n            return path_start + path_goal\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            max_attempts = 100\n            for _ in range(max_attempts):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1 = path[i]\n                p2 = path[j]\n                if not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        def try_connect(new_node, other_tree, radius):\n            candidates = near(other_tree, new_node.position, radius)\n            best_node = None\n            best_cost = float('inf')\n            for cnode in candidates:\n                d = dist(new_node.position, cnode.position)\n                if d <= radius:\n                    if not self._is_edge_in_obstacle(new_node.position, cnode.position, obstacles, is_3d):\n                        cost = new_node.cost + d + cnode.cost\n                        if cost < best_cost:\n                            best_cost = cost\n                            best_node = cnode\n            return best_node, best_cost\n\n        start_tree = [Node(start_pos, cost=0.0)]\n        goal_tree = [Node(goal_pos, cost=0.0)]\n        nodes = start_tree[:] + goal_tree[:]\n        edges = []\n\n        best_connection = None\n        best_cost = float('inf')\n        success = False\n\n        start_time = time.monotonic()\n\n        for it in range(self.max_iter):\n            if time.monotonic() - start_time > self.time_limit:\n                break\n\n            tree_a = start_tree if it % 2 == 0 else goal_tree\n            tree_b = goal_tree if it % 2 == 0 else start_tree\n\n            sample = sample_free()\n            nearest_node = nearest(tree_a, sample)\n            new_pos = steer(nearest_node.position, sample, self.step_size)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            n_nodes = len(tree_a) + 1\n            radius = min(max_radius, gamma_rrt_star * ((math.log(n_nodes) / n_nodes) ** (1 / dim)))\n\n            near_nodes = near(tree_a, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            min_parent = nearest_node\n            for near_node in near_nodes:\n                cost_through = near_node.cost + dist(near_node.position, new_pos)\n                if cost_through < min_cost:\n                    if not self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d):\n                        min_cost = cost_through\n                        min_parent = near_node\n\n            new_node = Node(new_pos, parent=min_parent, cost=min_cost)\n            min_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((min_parent, new_node))\n\n            for near_node in near_nodes:\n                if near_node is min_parent:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, near_node.position)\n                if new_cost < near_node.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                        if near_node.parent:\n                            try:\n                                edges.remove((near_node.parent, near_node))\n                            except Exception:\n                                pass\n                            near_node.parent.remove_child(near_node)\n                        near_node.parent = new_node\n                        near_node.cost = new_cost\n                        new_node.add_child(near_node)\n                        edges.append((new_node, near_node))\n\n            candidate_node, candidate_cost = try_connect(new_node, tree_b, radius)\n            if candidate_node and candidate_cost < best_cost:\n                best_cost = candidate_cost\n                best_connection = (new_node, candidate_node) if it % 2 == 0 else (candidate_node, new_node)\n                success = True\n                break\n\n        extracted_path = []\n        if success and best_connection is not None:\n            extracted_path = extract_path(best_connection[0], best_connection[1])\n            extracted_path = shortcut_path(extracted_path)\n        else:\n            # Attempt best partial connection after termination\n            partial_best_cost = float('inf')\n            best_pair = None\n            search_radius = self.step_size * 2.5\n            for n1 in start_tree:\n                candidates = near(goal_tree, n1.position, search_radius)\n                for n2 in candidates:\n                    dist12 = dist(n1.position, n2.position)\n                    if dist12 <= search_radius:\n                        if not self._is_edge_in_obstacle(n1.position, n2.position, obstacles, is_3d):\n                            total = n1.cost + n2.cost + dist12\n                            if total < partial_best_cost:\n                                partial_best_cost = total\n                                best_pair = (n1, n2)\n            if best_pair:\n                extracted_path = extract_path(best_pair[0], best_pair[1])\n                extracted_path = shortcut_path(extracted_path)\n                success = True\n\n        return PlannerResult(\n            success=success,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=None):\n        import math\n        if resolution is None:\n            resolution = self.step_size / 5.0\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -34.94716,
          "time_improvement": 61.0,
          "length_improvement": 17.0,
          "smoothness_improvement": 1345.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.017592668533325195,
                    "num_nodes_avg": 146.3,
                    "path_length_avg": 164.63788397352135,
                    "smoothness_avg": 0.041535622096488645,
                    "success_improvement": 0.0,
                    "time_improvement": 30.283687541217176,
                    "length_improvement": 9.759366939893138,
                    "smoothness_improvement": 550.1226818570675,
                    "objective_score": 17.691339835586376
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.023112845420837403,
                    "num_nodes_avg": 289.1,
                    "path_length_avg": 234.77030563840145,
                    "smoothness_avg": 0.08860271576206454,
                    "success_improvement": 0.0,
                    "time_improvement": 85.9017010923232,
                    "length_improvement": 21.62691448933292,
                    "smoothness_improvement": 2179.8116945145425,
                    "objective_score": 49.64571749386942
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.01650681495666504,
                    "num_nodes_avg": 220.5,
                    "path_length_avg": 122.87503542709001,
                    "smoothness_avg": 0.11040898180568644,
                    "success_improvement": 0.0,
                    "time_improvement": 66.49034489467883,
                    "length_improvement": 18.392252149750774,
                    "smoothness_improvement": 1304.3940990250192,
                    "objective_score": 37.50442525337921
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "cross_over",
          "algorithm_description": "A hybrid bidirectional RRT* planner employing adaptive neighborhood radius rewiring, goal-biased sampling, multiple candidate connections, and progressive path shortcutting during planning to sharply reduce planning time while minimizing path length and enhancing smoothness and robustness. The planner dynamically balances exploration and exploitation, enforces efficient collision checks, and terminates early when high-quality paths are found.",
          "planning_mechanism": "The planner iteratively grows two trees from start and goal by sampling with a controlled goal bias, steering nearest nodes toward samples using fixed step size, and rewiring nodes within an adaptively shrinking radius based on node density and problem dimension. Each iteration attempts multiple candidate connections across trees with fine collision checking. Progressive shortcutting is applied periodically to smooth the path during planning. The algorithm respects map bounds, collision constraints, and employs a hard 30-second time limit, returning the best feasible path found.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.time_limit = 30.0\n        self.goal_sample_rate = 0.15  # goal bias probability\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n        import time\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        start_tree = [Node(start_pos, cost=0.0)]\n        goal_tree = [Node(goal_pos, cost=0.0)]\n        nodes = start_tree[:] + goal_tree[:]\n        edges = []\n\n        gamma_rrt_star = 35.0  # neighborhood radius constant tuned\n\n        best_connection = None  # tuple(Node from start_tree, Node from goal_tree)\n        best_cost = float('inf')\n        success = False\n\n        step_size = self.step_size\n        start_time = time.monotonic()\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def sample_free():\n            # goal biased sampling with fallback attempts\n            if random.random() < self.goal_sample_rate:\n                return goal_pos\n            for _ in range(100):\n                p = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n            return goal_pos  # fallback if no samples found\n\n        def nearest(tree, point):\n            best_node = None\n            best_d = float('inf')\n            for node in tree:\n                d = dist(node.position, point)\n                if d < best_d:\n                    best_d = d\n                    best_node = node\n            return best_node\n\n        def near(tree, point, radius):\n            neighbors = []\n            for node in tree:\n                d = dist(node.position, point)\n                if d <= radius:\n                    neighbors.append((d, node))\n            neighbors.sort(key=lambda x: x[0])\n            return [n[1] for n in neighbors]\n\n        def steer(from_p, to_p, max_step):\n            d = dist(from_p, to_p)\n            if d <= max_step:\n                return to_p\n            ratio = max_step / d\n            return tuple(from_p[i] + (to_p[i] - from_p[i]) * ratio for i in range(dim))\n\n        def extract_path(n_start, n_goal):\n            path_start = []\n            cur = n_start\n            while cur is not None:\n                path_start.append(cur.position)\n                cur = cur.parent\n            path_start.reverse()\n            path_goal = []\n            cur = n_goal\n            while cur is not None:\n                path_goal.append(cur.position)\n                cur = cur.parent\n            if path_start and path_goal and path_start[-1] == path_goal[0]:\n                path_goal = path_goal[1:]\n            return path_start + path_goal\n\n        def shortcut_path(path, max_attempts=50):\n            # Progressive shortcutting to smooth and shorten paths\n            if len(path) < 3:\n                return path\n            for _ in range(max_attempts):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1 = path[i]\n                p2 = path[j]\n                if not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution=max(step_size * 0.2, 0.2)):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        def try_connect(new_node, other_tree):\n            radius = step_size * 2.5\n            candidates = near(other_tree, new_node.position, radius)\n            best_cand = None\n            best_cost_local = float('inf')\n            for node in candidates:\n                dist_between = dist(new_node.position, node.position)\n                if dist_between <= radius:\n                    if not self._is_edge_in_obstacle(new_node.position, node.position, obstacles, is_3d, resolution=max(step_size * 0.2, 0.2)):\n                        total_cost = new_node.cost + dist_between + node.cost\n                        if total_cost < best_cost_local:\n                            best_cost_local = total_cost\n                            best_cand = node\n            return best_cand, best_cost_local\n\n        def rewire(tree, new_node, neighbors):\n            for neighbor in neighbors:\n                if neighbor is new_node.parent:\n                    continue\n                cost_through = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_through + 1e-9 < neighbor.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d, resolution=max(step_size * 0.2, 0.2)):\n                        if neighbor.parent:\n                            try:\n                                edges.remove((neighbor.parent, neighbor))\n                            except Exception:\n                                pass\n                            neighbor.parent.remove_child(neighbor)\n                        neighbor.parent = new_node\n                        neighbor.cost = cost_through\n                        new_node.add_child(neighbor)\n                        edges.append((new_node, neighbor))\n\n        iter_since_last_shortcut = 0\n        shortcut_interval = 75\n\n        for it in range(self.max_iter):\n            if time.monotonic() - start_time > self.time_limit:\n                break\n\n            tree_a = start_tree if it % 2 == 0 else goal_tree\n            tree_b = goal_tree if it % 2 == 0 else start_tree\n\n            sample = sample_free()\n            nearest_node = nearest(tree_a, sample)\n            new_pos = steer(nearest_node.position, sample, step_size)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d, resolution=max(step_size * 0.2, 0.2)):\n                continue\n\n            n_nodes = len(tree_a) + 1\n            radius = max(step_size, min(step_size * 5, gamma_rrt_star * ((math.log(n_nodes) / n_nodes) ** (1 / dim))))\n\n            neighbors = near(tree_a, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            min_parent = nearest_node\n            for nb in neighbors:\n                candidate_cost = nb.cost + dist(nb.position, new_pos)\n                if candidate_cost + 1e-9 < min_cost:\n                    if not self._is_edge_in_obstacle(nb.position, new_pos, obstacles, is_3d, resolution=max(step_size * 0.2, 0.2)):\n                        min_cost = candidate_cost\n                        min_parent = nb\n\n            new_node = Node(new_pos, parent=min_parent, cost=min_cost)\n            min_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((min_parent, new_node))\n\n            rewire(tree_a, new_node, neighbors)\n\n            conn_node, conn_cost = try_connect(new_node, tree_b)\n            if conn_node is not None and conn_cost + 1e-9 < best_cost:\n                best_cost = conn_cost\n                best_connection = (new_node, conn_node) if it % 2 == 0 else (conn_node, new_node)\n                success = True\n                # Early stop on improved solution\n                break\n\n            iter_since_last_shortcut += 1\n            if iter_since_last_shortcut >= shortcut_interval and success:\n                path_cur = extract_path(best_connection[0], best_connection[1])\n                path_short = shortcut_path(path_cur, max_attempts=25)\n                if len(path_short) < len(path_cur):\n                    iter_since_last_shortcut = 0\n                    # Replace best path with shortcut\n                    # We'll re-extract path before return to keep tree coherence\n                    extracted_path = path_short\n\n        extracted_path = []\n        if success and best_connection is not None:\n            extracted_path = extract_path(best_connection[0], best_connection[1])\n            extracted_path = shortcut_path(extracted_path, max_attempts=75)\n        else:\n            # No full success: find best partial connection\n            best_partial_cost = float('inf')\n            best_pair = None\n            search_radius = step_size * 3.0\n            for n1 in start_tree:\n                candidates = near(goal_tree, n1.position, search_radius)\n                for n2 in candidates:\n                    dist_12 = dist(n1.position, n2.position)\n                    if dist_12 <= search_radius:\n                        if not self._is_edge_in_obstacle(n1.position, n2.position, obstacles, is_3d, resolution=max(step_size * 0.2, 0.2)):\n                            total_cost = n1.cost + n2.cost + dist_12\n                            if total_cost + 1e-9 < best_partial_cost:\n                                best_partial_cost = total_cost\n                                best_pair = (n1, n2)\n            if best_pair:\n                success = True\n                extracted_path = extract_path(best_pair[0], best_pair[1])\n                extracted_path = shortcut_path(extracted_path, max_attempts=75)\n\n        return PlannerResult(\n            success=success,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -34.6527,
          "time_improvement": 61.0,
          "length_improvement": 16.0,
          "smoothness_improvement": 1381.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.011872506141662598,
                    "num_nodes_avg": 107.7,
                    "path_length_avg": 163.66283892228535,
                    "smoothness_avg": 0.04201284504332733,
                    "success_improvement": 0.0,
                    "time_improvement": 52.95157489763024,
                    "length_improvement": 10.29380458305316,
                    "smoothness_improvement": 557.5922572813087,
                    "objective_score": 24.849716505527507
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.02488439083099365,
                    "num_nodes_avg": 310.2,
                    "path_length_avg": 240.20474907561953,
                    "smoothness_avg": 0.09852207245217506,
                    "success_improvement": 0.0,
                    "time_improvement": 84.82109953651525,
                    "length_improvement": 19.812740848208225,
                    "smoothness_improvement": 2435.0438867749226,
                    "objective_score": 49.509193803754115
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.02670140266418457,
                    "num_nodes_avg": 301.3,
                    "path_length_avg": 125.20170451544436,
                    "smoothness_avg": 0.09831100843591407,
                    "success_improvement": 0.0,
                    "time_improvement": 45.794824958412164,
                    "length_improvement": 16.846989325342022,
                    "smoothness_improvement": 1150.5087707410203,
                    "objective_score": 29.599184936433964
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "path_expert",
          "algorithm_description": "A bidirectional, asymmetrically goal-biased RRT* planner implementing adaptive neighborhood radius rewiring, multi-candidate connection attempts across trees, and incremental path shortcutting during planning for improved efficiency, shorter and smoother paths, and robustness within a strict 30-second time limit. It alternates tree expansions while dynamically updating rewiring radii and performs fine-resolution collision checks, early stopping on improved connections, and progressive shortcutting to optimize path quality.",
          "planning_mechanism": "A bidirectional RRT* framework grows start and goal trees, sampling with a controlled goal bias. New nodes are connected with cost-based parent selection and rewiring within an adaptively shrinking radius based on node density and dimension. Multiple candidate connections to the opposite tree are attempted each iteration, improving connection quality and enabling early termination. Progressive shortcutting is applied periodically to smooth intermediate paths during planning. The search respects map bounds and obstacle collisions, enforcing a hard 30-second limit, and outputs the best feasible path found.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float = 0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children: List[Node] = []\n        self.valid = True\n    def add_child(self, child):\n        self.children.append(child)\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.time_limit = 30.0\n        self.goal_sample_rate = 0.15  # Controlled goal biasing\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = dim == 3\n\n        gamma_rrt_star = 35.0  # Tuned constant for neighborhood radius\n\n        # Initialize bidirectional trees: list of Node\n        start_tree = [Node(start_pos, cost=0.0)]\n        goal_tree = [Node(goal_pos, cost=0.0)]\n        nodes = start_tree[:] + goal_tree[:]\n        edges = []\n\n        best_connection = None  # tuple of (Node from start_tree, Node from goal_tree)\n        best_cost = float('inf')\n        success = False\n\n        step_size = self.step_size\n        start_time = time.monotonic()\n\n        def dist(a: Tuple[float, ...], b: Tuple[float, ...]) -> float:\n            return math.dist(a, b)\n\n        def sample_free() -> Tuple[float, ...]:\n            # Goal bias: sample goal with goal_sample_rate probability\n            if random.random() < self.goal_sample_rate:\n                return goal_pos\n            for _ in range(100):\n                p = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n            return goal_pos  # fallback\n\n        def nearest(tree: List[Node], point: Tuple[float, ...]) -> Node:\n            best_node = None\n            best_d = float('inf')\n            for node in tree:\n                d = dist(node.position, point)\n                if d < best_d:\n                    best_d = d\n                    best_node = node\n            return best_node\n\n        def near(tree: List[Node], point: Tuple[float, ...], radius: float) -> List[Node]:\n            neighbors = []\n            for node in tree:\n                d = dist(node.position, point)\n                if d <= radius:\n                    neighbors.append((d, node))\n            neighbors.sort(key=lambda x: x[0])\n            return [n[1] for n in neighbors]\n\n        def steer(from_p: Tuple[float, ...], to_p: Tuple[float, ...], max_step: float) -> Tuple[float, ...]:\n            d = dist(from_p, to_p)\n            if d <= max_step:\n                return to_p\n            ratio = max_step / d\n            return tuple(from_p[i] + (to_p[i] - from_p[i]) * ratio for i in range(dim))\n\n        def extract_path(n_start: Node, n_goal: Node) -> List[Tuple[float, ...]]:\n            path_start = []\n            cur = n_start\n            while cur is not None:\n                path_start.append(cur.position)\n                cur = cur.parent\n            path_start.reverse()\n            path_goal = []\n            cur = n_goal\n            while cur is not None:\n                path_goal.append(cur.position)\n                cur = cur.parent\n            # avoid duplicate connection node position\n            if path_goal and path_start and path_start[-1] == path_goal[0]:\n                path_goal = path_goal[1:]\n            return path_start + path_goal\n\n        def shortcut_path(path: List[Tuple[float, ...]], max_attempts=50) -> List[Tuple[float, ...]]:\n            # Progressive shortcutting: attempt random shortcuts to smooth path preserving collision constraints\n            if len(path) < 3:\n                return path\n            for _ in range(max_attempts):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1 = path[i]\n                p2 = path[j]\n                # Check if shortcut collision free\n                if not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution=max(self.step_size * 0.2, 0.2)):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        def try_connect(new_node: Node, other_tree: List[Node]) -> Tuple[Node, float]:\n            radius = step_size * 2.5\n            candidates = near(other_tree, new_node.position, radius)\n            best_cand = None\n            best_cost_local = float('inf')\n            for node in candidates:\n                dist_between = dist(new_node.position, node.position)\n                if dist_between <= radius and not self._is_edge_in_obstacle(new_node.position, node.position, obstacles, is_3d, resolution=max(step_size * 0.2, 0.2)):\n                    total_cost = new_node.cost + dist_between + node.cost\n                    if total_cost < best_cost_local:\n                        best_cost_local = total_cost\n                        best_cand = node\n            return best_cand, best_cost_local\n\n        def rewire(tree: List[Node], new_node: Node, neighbors: List[Node]) -> None:\n            for neighbor in neighbors:\n                if neighbor is new_node.parent:\n                    continue\n                cost_through = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_through + 1e-9 < neighbor.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d, resolution=max(step_size * 0.2, 0.2)):\n                        # rewire: switch parent\n                        if neighbor.parent:\n                            try:\n                                edges.remove((neighbor.parent, neighbor))\n                            except Exception:\n                                pass\n                            neighbor.parent.remove_child(neighbor)\n                        neighbor.parent = new_node\n                        neighbor.cost = cost_through\n                        new_node.add_child(neighbor)\n                        edges.append((new_node, neighbor))\n\n        iter_since_last_shortcut = 0\n        shortcut_interval = 75\n\n        for it in range(self.max_iter):\n            if time.monotonic() - start_time > self.time_limit:\n                break\n\n            tree_a = start_tree if it % 2 == 0 else goal_tree\n            tree_b = goal_tree if it % 2 == 0 else start_tree\n\n            sample = sample_free()\n            nearest_node = nearest(tree_a, sample)\n            new_pos = steer(nearest_node.position, sample, step_size)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d, resolution=max(step_size * 0.2, 0.2)):\n                continue\n\n            n_nodes = len(tree_a) + 1\n            radius = min(step_size * 5,\n                         gamma_rrt_star * ((math.log(n_nodes) / n_nodes) ** (1 / dim)))\n            if radius < step_size:\n                radius = step_size  # at least step size\n\n            neighbors = near(tree_a, new_pos, radius)\n\n            # Find best parent node (lowest cost + dist) collision safe\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            min_parent = nearest_node\n            for nb in neighbors:\n                cost_candidate = nb.cost + dist(nb.position, new_pos)\n                if cost_candidate + 1e-9 < min_cost:\n                    if not self._is_edge_in_obstacle(nb.position, new_pos, obstacles, is_3d, resolution=max(step_size * 0.2, 0.2)):\n                        min_cost = cost_candidate\n                        min_parent = nb\n\n            new_node = Node(new_pos, parent=min_parent, cost=min_cost)\n            min_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((min_parent, new_node))\n\n            rewire(tree_a, new_node, neighbors)\n\n            # Try connect new_node to other tree with multiple candidates\n            conn_node, conn_cost = try_connect(new_node, tree_b)\n            if conn_node is not None and conn_cost + 1e-9 < best_cost:\n                best_cost = conn_cost\n                best_connection = (new_node, conn_node) if it % 2 == 0 else (conn_node, new_node)\n                success = True\n                # Early stop on improved connection\n                break\n\n            # Periodic incremental shortcutting to improve intermediate path smoothness & length\n            iter_since_last_shortcut += 1\n            if iter_since_last_shortcut >= shortcut_interval and success:\n                path_cur = extract_path(best_connection[0], best_connection[1])\n                path_short = shortcut_path(path_cur, max_attempts=25)\n                # If shortcut reduces nodes substantially, update best path extracted immediately\n                if len(path_short) < len(path_cur):\n                    # Reset iter counter to avoid shortcutting excessive times\n                    iter_since_last_shortcut = 0\n                    extracted_path = path_short\n\n        extracted_path: List[Tuple[float, ...]] = []\n        if success and best_connection is not None:\n            extracted_path = extract_path(best_connection[0], best_connection[1])\n            extracted_path = shortcut_path(extracted_path, max_attempts=75)\n        else:\n            # If no success, try find best partial connection\n            best_partial_cost = float('inf')\n            best_pair = None\n            search_radius = step_size * 3.0\n            for n1 in start_tree:\n                candidates = near(goal_tree, n1.position, search_radius)\n                for n2 in candidates:\n                    d12 = dist(n1.position, n2.position)\n                    if d12 <= search_radius:\n                        if not self._is_edge_in_obstacle(n1.position, n2.position, obstacles, is_3d, resolution=max(step_size * 0.2, 0.2)):\n                            total_cost = n1.cost + n2.cost + d12\n                            if total_cost + 1e-9 < best_partial_cost:\n                                best_partial_cost = total_cost\n                                best_pair = (n1, n2)\n            if best_pair:\n                success = True\n                extracted_path = extract_path(best_pair[0], best_pair[1])\n                extracted_path = shortcut_path(extracted_path, max_attempts=75)\n\n        return PlannerResult(\n            success=success,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -34.56709,
          "time_improvement": 61.0,
          "length_improvement": 15.0,
          "smoothness_improvement": 1406.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.012232446670532226,
                    "num_nodes_avg": 111.9,
                    "path_length_avg": 161.78749064589732,
                    "smoothness_avg": 0.04188267931246853,
                    "success_improvement": 0.0,
                    "time_improvement": 51.11976593857507,
                    "length_improvement": 11.32171269013654,
                    "smoothness_improvement": 555.5548809339598,
                    "objective_score": 24.906731800324245
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.02393496036529541,
                    "num_nodes_avg": 300.9,
                    "path_length_avg": 242.85620828482826,
                    "smoothness_avg": 0.08907932627121147,
                    "success_improvement": 0.0,
                    "time_improvement": 85.36215473141678,
                    "length_improvement": 18.927607446152585,
                    "smoothness_improvement": 2192.075226203567,
                    "objective_score": 47.92558701813442
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.026720166206359863,
                    "num_nodes_avg": 317.0,
                    "path_length_avg": 126.2475615470681,
                    "smoothness_avg": 0.123441994873119,
                    "success_improvement": 0.0,
                    "time_improvement": 46.08887272601328,
                    "length_improvement": 16.152380883297628,
                    "smoothness_improvement": 1470.173063245805,
                    "objective_score": 30.868955664011587
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "path_expert",
          "algorithm_description": "A bidirectional RRT* planner with adaptive rewiring radius based on node density and problem dimension, enhanced goal biased sampling with retry limit to ensure valid samples, multiple candidate connections between the two trees for improved path quality, and incremental shortcutting applied periodically during planning to progressively minimize path length and improve smoothness. The planner performs fine-resolution collision checking, prioritizes cost-optimized rewiring, and terminates early upon finding improved connections or reaching a strict 30-second time limit, returning the best feasible path found.",
          "planning_mechanism": "The planner grows start and goal trees alternately, sampling with controlled goal bias and a retry limit to avoid invalid samples. It connects new nodes to neighbors within an adaptive radius using cost-based parent selection and rewiring, then attempts multiple connections to the opposite tree to find better paths early. Periodic incremental shortcutting improves intermediate path quality, and the search respects map bounds and obstacles with rigorous collision checks, enforcing a hard 30-second wall-clock limit.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float = 0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children: List['Node'] = []\n        self.valid = True\n    def add_child(self, child: 'Node'):\n        self.children.append(child)\n    def remove_child(self, child: 'Node'):\n        if child in self.children:\n            self.children.remove(child)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.time_limit = 30.0\n        self.goal_sample_rate = 0.15\n        self.sample_retry_limit = 30\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        gamma_rrt_star = 35.0\n\n        start_tree: List[Node] = [Node(start_pos, cost=0.0)]\n        goal_tree: List[Node] = [Node(goal_pos, cost=0.0)]\n        nodes = start_tree[:] + goal_tree[:]\n        edges: List[Tuple[Node, Node]] = []\n\n        best_connection = None\n        best_cost = float('inf')\n        success = False\n\n        step_size = self.step_size\n        start_time = time.monotonic()\n\n        def dist(a: Tuple[float, ...], b: Tuple[float, ...]) -> float:\n            # Euclidean distance\n            return math.dist(a, b)\n\n        def sample_free() -> Tuple[float, ...]:\n            # With controlled goal bias and retry limit for free samples\n            if random.random() < self.goal_sample_rate:\n                if not self._is_in_obstacle(goal_pos, obstacles, is_3d):\n                    return goal_pos\n            for _ in range(self.sample_retry_limit):\n                p = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n            # Fallback to goal if no free sample found after retries\n            return goal_pos\n\n        def nearest(tree: List[Node], point: Tuple[float, ...]) -> Node:\n            best_node = None\n            best_dist = float('inf')\n            for node in tree:\n                d = dist(node.position, point)\n                if d < best_dist:\n                    best_dist = d\n                    best_node = node\n            return best_node\n\n        def near(tree: List[Node], point: Tuple[float, ...], radius: float) -> List[Node]:\n            neighbors = []\n            for node in tree:\n                d = dist(node.position, point)\n                if d <= radius:\n                    neighbors.append((d, node))\n            neighbors.sort(key=lambda x: x[0])\n            return [n[1] for n in neighbors]\n\n        def steer(from_p: Tuple[float, ...], to_p: Tuple[float, ...], max_step: float) -> Tuple[float, ...]:\n            d = dist(from_p, to_p)\n            if d <= max_step:\n                return to_p\n            ratio = max_step / d\n            return tuple(from_p[i] + (to_p[i] - from_p[i]) * ratio for i in range(dim))\n\n        def extract_path(n_start: Node, n_goal: Node) -> List[Tuple[float, ...]]:\n            path_start = []\n            cur = n_start\n            while cur is not None:\n                path_start.append(cur.position)\n                cur = cur.parent\n            path_start.reverse()\n            path_goal = []\n            cur = n_goal\n            while cur is not None:\n                path_goal.append(cur.position)\n                cur = cur.parent\n            if path_goal and path_start and path_start[-1] == path_goal[0]:\n                path_goal = path_goal[1:]\n            return path_start + path_goal\n\n        def shortcut_path(path: List[Tuple[float, ...]], max_attempts=50) -> List[Tuple[float, ...]]:\n            if len(path) < 3:\n                return path\n            for _ in range(max_attempts):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1 = path[i]\n                p2 = path[j]\n                if not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution=max(step_size * 0.2, 0.2)):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        def rewire(tree: List[Node], new_node: Node, neighbors: List[Node]) -> None:\n            for neighbor in neighbors:\n                if neighbor is new_node.parent:\n                    continue\n                cost_through_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_through_new + 1e-9 < neighbor.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d, resolution=max(step_size * 0.2,0.2)):\n                        # Rewire\n                        if neighbor.parent is not None:\n                            try:\n                                edges.remove((neighbor.parent, neighbor))\n                            except Exception:\n                                pass\n                            neighbor.parent.remove_child(neighbor)\n                        neighbor.parent = new_node\n                        neighbor.cost = cost_through_new\n                        new_node.add_child(neighbor)\n                        edges.append((new_node, neighbor))\n\n        def try_connect(new_node: Node, other_tree: List[Node]) -> Tuple[Node, float]:\n            radius = step_size * 2.5\n            candidates = near(other_tree, new_node.position, radius)\n            best_cand = None\n            best_cost_local = float('inf')\n            for node in candidates:\n                dist_between = dist(new_node.position, node.position)\n                if dist_between <= radius and not self._is_edge_in_obstacle(new_node.position, node.position, obstacles, is_3d, resolution=max(step_size * 0.2, 0.2)):\n                    total_cost = new_node.cost + dist_between + node.cost\n                    if total_cost < best_cost_local:\n                        best_cost_local = total_cost\n                        best_cand = node\n            return best_cand, best_cost_local\n\n        iter_since_last_shortcut = 0\n        shortcut_interval = 75\n\n        for it in range(self.max_iter):\n            current_time = time.monotonic()\n            if current_time - start_time > self.time_limit:\n                break\n\n            tree_a = start_tree if it % 2 == 0 else goal_tree\n            tree_b = goal_tree if it % 2 == 0 else start_tree\n\n            sample = sample_free()\n            nearest_node = nearest(tree_a, sample)\n            new_pos = steer(nearest_node.position, sample, step_size)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d, resolution=max(step_size * 0.2, 0.2)):\n                continue\n\n            n_nodes = len(tree_a) + 1\n            radius = min(step_size * 5,\n                         gamma_rrt_star * ((math.log(n_nodes) / n_nodes) ** (1 / dim)) if n_nodes > 1 else step_size*5)\n            if radius < step_size:\n                radius = step_size\n\n            neighbors = near(tree_a, new_pos, radius)\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            min_parent = nearest_node\n            for nb in neighbors:\n                cost_candidate = nb.cost + dist(nb.position, new_pos)\n                if cost_candidate + 1e-9 < min_cost:\n                    if not self._is_edge_in_obstacle(nb.position, new_pos, obstacles, is_3d, resolution=max(step_size * 0.2, 0.2)):\n                        min_cost = cost_candidate\n                        min_parent = nb\n\n            new_node = Node(new_pos, parent=min_parent, cost=min_cost)\n            min_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((min_parent, new_node))\n\n            rewire(tree_a, new_node, neighbors)\n\n            conn_node, conn_cost = try_connect(new_node, tree_b)\n            if conn_node is not None and conn_cost + 1e-9 < best_cost:\n                best_cost = conn_cost\n                best_connection = (new_node, conn_node) if (it % 2 == 0) else (conn_node, new_node)\n                success = True\n                # Early exit on improved path connection\n                break\n\n            iter_since_last_shortcut += 1\n            if iter_since_last_shortcut >= shortcut_interval and success:\n                path_cur = extract_path(best_connection[0], best_connection[1])\n                path_short = shortcut_path(path_cur, max_attempts=25)\n                if len(path_short) < len(path_cur):\n                    iter_since_last_shortcut = 0\n\n        extracted_path: List[Tuple[float, ...]] = []\n        if success and best_connection is not None:\n            extracted_path = extract_path(best_connection[0], best_connection[1])\n            extracted_path = shortcut_path(extracted_path, max_attempts=75)\n        else:\n            # Attempt to find partial best connection if no full success\n            best_partial_cost = float('inf')\n            best_pair = None\n            search_radius = step_size * 3.0\n            for n1 in start_tree:\n                candidates = near(goal_tree, n1.position, search_radius)\n                for n2 in candidates:\n                    d12 = dist(n1.position, n2.position)\n                    if d12 <= search_radius:\n                        if not self._is_edge_in_obstacle(n1.position, n2.position, obstacles, is_3d, resolution=max(step_size * 0.2, 0.2)):\n                            total_cost = n1.cost + n2.cost + d12\n                            if total_cost + 1e-9 < best_partial_cost:\n                                best_partial_cost = total_cost\n                                best_pair = (n1, n2)\n            if best_pair is not None:\n                success = True\n                extracted_path = extract_path(best_pair[0], best_pair[1])\n                extracted_path = shortcut_path(extracted_path, max_attempts=75)\n\n        return PlannerResult(\n            success=success,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -34.46238,
          "time_improvement": 60.0,
          "length_improvement": 16.0,
          "smoothness_improvement": 1392.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.01586735248565674,
                    "num_nodes_avg": 142.3,
                    "path_length_avg": 162.9862401408219,
                    "smoothness_avg": 0.04259725412071574,
                    "success_improvement": 0.0,
                    "time_improvement": 37.12077836922653,
                    "length_improvement": 10.664659096567057,
                    "smoothness_improvement": 566.7395284070609,
                    "objective_score": 20.368726610743497
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.025417375564575195,
                    "num_nodes_avg": 310.8,
                    "path_length_avg": 240.6615370940523,
                    "smoothness_avg": 0.09436149443348987,
                    "success_improvement": 0.0,
                    "time_improvement": 84.49599122767472,
                    "length_improvement": 19.66025185974126,
                    "smoothness_improvement": 2327.989217610935,
                    "objective_score": 48.78489457220185
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.019857573509216308,
                    "num_nodes_avg": 271.0,
                    "path_length_avg": 125.6783781844882,
                    "smoothness_avg": 0.1086299600547175,
                    "success_improvement": 0.0,
                    "time_improvement": 59.68813842832106,
                    "length_improvement": 16.530405371124044,
                    "smoothness_improvement": 1281.765073666421,
                    "objective_score": 34.233510119502846
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e2",
          "algorithm_description": "A hybrid bidirectional RRT* planner combining adaptive neighborhood radius tuning, goal bias sampling with controlled retries, focused rewiring with efficient incremental cost updates, multiple candidate connections with early improvement stopping, and progressive in-loop path smoothing via lazy shortcutting. It alternates growth between start and goal trees, uses spatially adaptive radii to select neighbors, performs thorough collision checking with resolution scaled to step size, and respects a hard 30-second time limit, returning the best feasible path found.",
          "planning_mechanism": "The planner grows two trees from start and goal locations alternately. It samples points with goal bias and retry limits to efficiently explore free space. For each new sample, it steers from the nearest tree node with a capped step size and ensures no collisions for nodes and edges. It chooses the best parent from neighbors inside an adaptively computed radius based on tree density and dimension to minimize path cost and rewires neighbors for incremental improvements. Multiple candidate connections to the opposite tree are tried to find the best new connection, enabling early stopping upon improvement. The planner performs periodic lazy shortcutting during the run and after finishing to refine path smoothness and shorten path length. It limits total runtime to 30 seconds, returning the shortest collision-free path found so far.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] (2D or 3D)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Cost from root to this node\n        self.children = []\n        self.valid = True               # Flag for validity if needed\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.time_limit = 30.0\n        self.goal_sample_rate = 0.15  # Probability to sample goal directly\n        self.gamma_rrt_star = 45.0    # Radius tuning constant for rewiring\n\n    def plan(self, map):\n        import time\n        import math\n        import random\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        # Helper function: node in obstacle\n        def in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d = obs\n                    px,py,pz = pos\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                        return True\n                else:\n                    x,y,w_,h_ = obs\n                    px,py = pos\n                    if x <= px <= x+w_ and y <= py <= y+h_:\n                        return True\n            return False\n\n        # Helper function: edge intersects any obstacle\n        def edge_in_obstacle(p1, p2, resolution=None):\n            # Resolution scaled with step size for balance\n            res = resolution if resolution is not None else max(self.step_size * 0.2, 0.2)\n            dist = math.dist(p1, p2)\n            steps = max(1,int(dist / res))\n            for i in range(steps+1):\n                interp = tuple(p1[d] + (p2[d]-p1[d])*(i/steps) for d in range(dim))\n                if in_obstacle(interp):\n                    return True\n            return False\n\n        # Steering towards target with max step size\n        def steer(from_p, to_p, max_step=None):\n            max_step = max_step if max_step is not None else self.step_size\n            dist = math.dist(from_p, to_p)\n            if dist <= max_step:\n                return to_p\n            r = max_step / dist\n            return tuple(from_p[i] + r*(to_p[i]-from_p[i]) for i in range(dim))\n\n        # Sampling with goal bias and limited retries\n        def sample_free():\n            if random.random() < self.goal_sample_rate:\n                return goal_pos\n            for _ in range(30):\n                s = tuple(random.uniform(0,bounds[d]) for d in range(dim))\n                if not in_obstacle(s):\n                    return s\n            return goal_pos  # fallback if all fail\n\n        # Euclidean distance\n        def dist(a, b):\n            return math.dist(a, b)\n\n        # Nearest node search\n        def nearest(tree, point):\n            best_node = None\n            best_dist = float('inf')\n            for n in tree:\n                d = dist(n.position, point)\n                if d < best_dist:\n                    best_dist = d\n                    best_node = n\n            return best_node\n\n        # Near nodes within radius\n        def near(tree, point, radius):\n            result = []\n            r_sq = radius*radius\n            for n in tree:\n                d = dist(n.position, point)\n                if d <= radius:\n                    result.append((d,n))\n            result.sort(key=lambda x: x[0])\n            return [n for (_,n) in result]\n\n        # Extract path from start node to goal node by traversing parents\n        def extract_path(node_start, node_goal):\n            path_start = []\n            cur = node_start\n            while cur is not None:\n                path_start.append(cur.position)\n                cur = cur.parent\n            path_start.reverse()\n            path_goal = []\n            cur = node_goal\n            while cur is not None:\n                path_goal.append(cur.position)\n                cur = cur.parent\n            # Remove duplicate connection point at junction to avoid repetition\n            if path_start and path_goal and path_start[-1] == path_goal[0]:\n                path_goal = path_goal[1:]\n            return path_start + path_goal\n\n        # Lazy shortcutting to progressively smooth path by removing intermediate waypoints\n        def lazy_shortcut(path, max_attempts=120):\n            if len(path) < 3:\n                return path[:]\n            shortened = path[:]\n            for _ in range(max_attempts):\n                if len(shortened) < 3:\n                    break\n                i = random.randint(0, len(shortened)-3)\n                j = random.randint(i+2, len(shortened)-1)\n                p1, p2 = shortened[i], shortened[j]\n                if not edge_in_obstacle(p1, p2):\n                    shortened = shortened[:i+1] + shortened[j:]\n            return shortened\n\n        # Rewire neighbors around new_node for better cost if possible\n        def rewire(tree, new_node, neighbors):\n            for neighbor in neighbors:\n                if neighbor is new_node.parent:\n                    continue\n                cost_through = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_through + 1e-9 < neighbor.cost:\n                    if not edge_in_obstacle(new_node.position, neighbor.position):\n                        # Remove old edge if present\n                        if neighbor.parent is not None:\n                            try:\n                                edges.remove((neighbor.parent, neighbor))\n                            except Exception:\n                                pass\n                            neighbor.parent.remove_child(neighbor)\n                        neighbor.parent = new_node\n                        neighbor.cost = cost_through\n                        new_node.add_child(neighbor)\n                        edges.append((new_node, neighbor))\n\n        # Attempt multi-candidate connections to other tree with adaptive radius\n        def try_connect(new_node, other_tree):\n            n_other = len(other_tree)\n            radius = min(self.step_size * 3.0, self.gamma_rrt_star * ((math.log(n_other+1) / (n_other+1)) ** (1.0/dim)))\n            radius = max(radius, self.step_size)\n            candidates = near(other_tree, new_node.position, radius)\n            best_node = None\n            best_cost = float('inf')\n            for c in candidates:\n                d_connect = dist(new_node.position, c.position)\n                if d_connect <= radius and not edge_in_obstacle(new_node.position, c.position):\n                    total_cost = new_node.cost + d_connect + c.cost\n                    if total_cost < best_cost:\n                        best_cost = total_cost\n                        best_node = c\n            return best_node, best_cost\n\n        # Initialize trees\n        start_tree = [Node(start_pos, parent=None, cost=0.0)]\n        goal_tree = [Node(goal_pos, parent=None, cost=0.0)]\n        all_nodes = start_tree[:] + goal_tree[:]\n        edges = []\n\n        best_connection = None\n        best_cost = float('inf')\n        success = False\n        extracted_path = []\n\n        start_time = time.monotonic()\n\n        for iter_i in range(self.max_iter):\n            elapsed = time.monotonic() - start_time\n            if elapsed > self.time_limit:\n                break\n\n            # Alternate tree expansions\n            tree_a, tree_b = (start_tree, goal_tree) if (iter_i % 2 == 0) else (goal_tree, start_tree)\n\n            sample = sample_free()\n            nearest_node = nearest(tree_a, sample)\n            new_pos = steer(nearest_node.position, sample, self.step_size)\n\n            # Reject if node in obstacle or edge in obstacle\n            if in_obstacle(new_pos):\n                continue\n            if edge_in_obstacle(nearest_node.position, new_pos):\n                continue\n\n            # Adaptive rewiring radius\n            n_nodes = len(tree_a) + 1\n            radius = min(self.step_size*5.0, self.gamma_rrt_star * ((math.log(n_nodes)/n_nodes) ** (1.0/dim)))\n            radius = max(radius, self.step_size)  # enforce minimum\n\n            neighbors = near(tree_a, new_pos, radius)\n\n            # Choose best parent minimizing cost + collision check\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            min_parent = nearest_node\n            for nb in neighbors:\n                cost_cand = nb.cost + dist(nb.position, new_pos)\n                if cost_cand + 1e-9 < min_cost:\n                    if not edge_in_obstacle(nb.position, new_pos):\n                        min_cost = cost_cand\n                        min_parent = nb\n\n            new_node = Node(new_pos, parent=min_parent, cost=min_cost)\n            min_parent.add_child(new_node)\n            tree_a.append(new_node)\n            all_nodes.append(new_node)\n            edges.append((min_parent, new_node))\n\n            # Rewire neighbors to potentially improve their costs\n            rewire(tree_a, new_node, neighbors)\n\n            # Attempt to connect new_node to other_tree\n            conn_node, conn_cost = try_connect(new_node, tree_b)\n            if conn_node is not None and conn_cost + 1e-9 < best_cost:\n                best_cost = conn_cost\n                if iter_i % 2 == 0:\n                    best_connection = (new_node, conn_node)\n                else:\n                    best_connection = (conn_node, new_node)\n                success = True\n                # Early stopping on improvement\n                break\n\n            # Progressive in-loop lazy shortcutting every 100 iterations if a solution found\n            if iter_i % 100 == 0 and success and best_connection is not None:\n                path = extract_path(best_connection[0], best_connection[1])\n                path = lazy_shortcut(path, max_attempts=80)\n                extracted_path = path\n\n        # Finalize path extraction and smoothing\n        if success and best_connection is not None:\n            path = extract_path(best_connection[0], best_connection[1])\n            extracted_path = lazy_shortcut(path, max_attempts=150)\n        else:\n            # Fallback: try partial best connection between trees by proximity\n            best_partial_cost = float('inf')\n            best_pair = None\n            search_radius = self.step_size * 3.0\n            for n1 in start_tree:\n                candidates = near(goal_tree, n1.position, search_radius)\n                for n2 in candidates:\n                    d12 = dist(n1.position, n2.position)\n                    if d12 <= search_radius and not edge_in_obstacle(n1.position, n2.position):\n                        total_c = n1.cost + n2.cost + d12\n                        if total_c + 1e-9 < best_partial_cost:\n                            best_partial_cost = total_c\n                            best_pair = (n1, n2)\n            if best_pair is not None:\n                success = True\n                extracted_path = extract_path(best_pair[0], best_pair[1])\n                extracted_path = lazy_shortcut(extracted_path, max_attempts=150)\n\n        return PlannerResult(\n            success=success,\n            path=extracted_path,\n            nodes=all_nodes,\n            edges=edges\n        )",
          "objective": -34.26356,
          "time_improvement": 55.0,
          "length_improvement": 16.0,
          "smoothness_improvement": 1596.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.019848036766052245,
                    "num_nodes_avg": 136.0,
                    "path_length_avg": 163.5557384155029,
                    "smoothness_avg": 0.04759996377744885,
                    "success_improvement": 0.0,
                    "time_improvement": 21.346103335355224,
                    "length_improvement": 10.35250806793675,
                    "smoothness_improvement": 645.0427980928309,
                    "objective_score": 15.84054983183277
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.027589631080627442,
                    "num_nodes_avg": 306.9,
                    "path_length_avg": 236.86846694979894,
                    "smoothness_avg": 0.10941583967919169,
                    "success_improvement": 0.0,
                    "time_improvement": 83.17096581381787,
                    "length_improvement": 20.926487851363625,
                    "smoothness_improvement": 2715.3483639894375,
                    "objective_score": 51.08392427491072
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.019978594779968262,
                    "num_nodes_avg": 233.2,
                    "path_length_avg": 123.20908528617367,
                    "smoothness_avg": 0.11998873209668244,
                    "success_improvement": 0.0,
                    "time_improvement": 59.44245923133774,
                    "length_improvement": 18.170392139092332,
                    "smoothness_improvement": 1426.2478156228758,
                    "objective_score": 35.8662121309711
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "A simplified bidirectional RRT* planner that alternates growth between start and goal trees, uses goal-biased sampling with a retry limit, connects nodes using an adaptive radius for rewiring, performs collision checking with moderate resolution, and applies incremental path shortcutting periodically to improve path length and smoothness. The planner enforces a 30-second hard time limit and returns the best feasible path found, balancing planning efficiency and path quality.",
          "planning_mechanism": "The planner grows two trees from start and goal by sampling free points biased toward the goal, steering toward samples with fixed step size, choosing parents and rewiring neighbors within an adaptively scaled radius, attempts multiple connections across trees each iteration, and incrementally shortcuts the current best path to optimize path length and smoothness before early termination or timeout.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = 0.15\n        self.time_limit = 30.0\n        self.gamma_rrt_star = 30.0\n        self.shortcut_interval = 75\n        self.shortcut_attempts = 25\n        self.collision_resolution_factor = 0.2\n\n    def plan(self, map):\n        import time\n        import math\n        import random\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        start_tree = [Node(start_pos, cost=0.0)]\n        goal_tree = [Node(goal_pos, cost=0.0)]\n        nodes = start_tree[:] + goal_tree[:]\n        edges = []\n\n        best_connection = None\n        best_cost = float('inf')\n        success = False\n\n        start_time = time.monotonic()\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def sample_free():\n            for _ in range(30):\n                if random.random() < self.goal_sample_rate:\n                    p = goal_pos\n                else:\n                    p = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n            return goal_pos\n\n        def nearest(tree, point):\n            best_node = None\n            best_dist = float('inf')\n            for node in tree:\n                d = dist(node.position, point)\n                if d < best_dist:\n                    best_dist = d\n                    best_node = node\n            return best_node\n\n        def near(tree, point, radius):\n            neighbors = []\n            r2 = radius * radius\n            for node in tree:\n                if (dist(node.position, point) ** 2) <= r2:\n                    neighbors.append(node)\n            return neighbors\n\n        def steer(from_p, to_p, max_step):\n            d = dist(from_p, to_p)\n            if d <= max_step:\n                return to_p\n            ratio = max_step / d\n            return tuple(from_p[i] + (to_p[i] - from_p[i]) * ratio for i in range(dim))\n\n        def extract_path(n_start, n_goal):\n            path_start, cur = [], n_start\n            while cur:\n                path_start.append(cur.position)\n                cur = cur.parent\n            path_start.reverse()\n            path_goal, cur = [], n_goal\n            while cur:\n                path_goal.append(cur.position)\n                cur = cur.parent\n            if path_goal and path_start and path_start[-1] == path_goal[0]:\n                path_goal = path_goal[1:]\n            return path_start + path_goal\n\n        def shortcut_path(path, max_attempts):\n            if len(path) < 3:\n                return path\n            res = max(self.step_size * self.collision_resolution_factor, 0.2)\n            for _ in range(max_attempts):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution=res):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        def rewire(tree, new_node, neighbors):\n            for neighbor in neighbors:\n                if neighbor is new_node.parent:\n                    continue\n                cost_through = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_through + 1e-9 < neighbor.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d,\n                                                    resolution=max(self.step_size * self.collision_resolution_factor, 0.2)):\n                        if neighbor.parent:\n                            try:\n                                edges.remove((neighbor.parent, neighbor))\n                            except ValueError:\n                                pass\n                            neighbor.parent.remove_child(neighbor)\n                        neighbor.parent = new_node\n                        neighbor.cost = cost_through\n                        new_node.add_child(neighbor)\n                        edges.append((new_node, neighbor))\n\n        def try_connect(new_node, other_tree):\n            radius = self.step_size * 2.5\n            candidates = near(other_tree, new_node.position, radius)\n            best_node = None\n            best_local_cost = float('inf')\n            for node in candidates:\n                d = dist(new_node.position, node.position)\n                if d <= radius:\n                    if not self._is_edge_in_obstacle(new_node.position, node.position, obstacles, is_3d,\n                                                    resolution=max(self.step_size * self.collision_resolution_factor, 0.2)):\n                        total_cost = new_node.cost + d + node.cost\n                        if total_cost < best_local_cost:\n                            best_local_cost = total_cost\n                            best_node = node\n            return best_node, best_local_cost\n\n        iter_since_last_shortcut = 0\n\n        for it in range(self.max_iter):\n            if time.monotonic() - start_time > self.time_limit:\n                break\n\n            tree_a = start_tree if it % 2 == 0 else goal_tree\n            tree_b = goal_tree if it % 2 == 0 else start_tree\n\n            sample = sample_free()\n            nearest_node = nearest(tree_a, sample)\n            new_pos = steer(nearest_node.position, sample, self.step_size)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d,\n                                        resolution=max(self.step_size * self.collision_resolution_factor, 0.2)):\n                continue\n\n            n_nodes = max(len(tree_a), 2)\n            radius = min(self.step_size * 4.0,\n                         self.gamma_rrt_star * (math.log(n_nodes) / n_nodes) ** (1 / dim))\n            if radius < self.step_size:\n                radius = self.step_size\n\n            neighbors = near(tree_a, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            min_parent = nearest_node\n\n            for nb in neighbors:\n                cost_candidate = nb.cost + dist(nb.position, new_pos)\n                if cost_candidate + 1e-9 < min_cost:\n                    if not self._is_edge_in_obstacle(nb.position, new_pos, obstacles, is_3d,\n                                                    resolution=max(self.step_size * self.collision_resolution_factor, 0.2)):\n                        min_cost = cost_candidate\n                        min_parent = nb\n\n            new_node = Node(new_pos, parent=min_parent, cost=min_cost)\n            min_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((min_parent, new_node))\n\n            rewire(tree_a, new_node, neighbors)\n\n            conn_node, conn_cost = try_connect(new_node, tree_b)\n            if conn_node is not None and conn_cost + 1e-9 < best_cost:\n                best_cost = conn_cost\n                best_connection = (new_node, conn_node) if (it % 2 == 0) else (conn_node, new_node)\n                success = True\n                break  # Early stopping on improved path\n\n            iter_since_last_shortcut += 1\n            if iter_since_last_shortcut >= self.shortcut_interval and success and best_connection:\n                path_cur = extract_path(best_connection[0], best_connection[1])\n                path_short = shortcut_path(path_cur, self.shortcut_attempts)\n                if len(path_short) < len(path_cur):\n                    iter_since_last_shortcut = 0\n\n        extracted_path = []\n        if success and best_connection is not None:\n            extracted_path = extract_path(best_connection[0], best_connection[1])\n            extracted_path = shortcut_path(extracted_path, max_attempts=75)\n        else:\n            # Attempt partial best connection if full connection not found\n            best_partial_cost = float('inf')\n            best_pair = None\n            search_radius = self.step_size * 3.0\n            for n1 in start_tree:\n                candidates = near(goal_tree, n1.position, search_radius)\n                for n2 in candidates:\n                    d12 = dist(n1.position, n2.position)\n                    if d12 <= search_radius:\n                        if not self._is_edge_in_obstacle(n1.position, n2.position, obstacles, is_3d,\n                                                        resolution=max(self.step_size * self.collision_resolution_factor, 0.2)):\n                            total_c = n1.cost + n2.cost + d12\n                            if total_c + 1e-9 < best_partial_cost:\n                                best_partial_cost = total_c\n                                best_pair = (n1, n2)\n            if best_pair is not None:\n                success = True\n                extracted_path = extract_path(best_pair[0], best_pair[1])\n                extracted_path = shortcut_path(extracted_path, max_attempts=75)\n\n        return PlannerResult(\n            success=success,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -33.6586,
          "time_improvement": 60.0,
          "length_improvement": 14.0,
          "smoothness_improvement": 1426.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.014527106285095214,
                    "num_nodes_avg": 140.8,
                    "path_length_avg": 166.50419452053524,
                    "smoothness_avg": 0.03473835363440112,
                    "success_improvement": 0.0,
                    "time_improvement": 42.43191253361149,
                    "length_improvement": 8.736412555491711,
                    "smoothness_improvement": 443.7306699206824,
                    "objective_score": 20.190074642981884
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.03096117973327637,
                    "num_nodes_avg": 345.4,
                    "path_length_avg": 237.53739493419107,
                    "smoothness_avg": 0.09491578420828131,
                    "success_improvement": 0.0,
                    "time_improvement": 81.11439944038615,
                    "length_improvement": 20.703180436149072,
                    "smoothness_improvement": 2342.2514927551065,
                    "objective_score": 48.46748555758082
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.021823620796203612,
                    "num_nodes_avg": 272.3,
                    "path_length_avg": 130.12893003889835,
                    "smoothness_avg": 0.125227351368938,
                    "success_improvement": 0.0,
                    "time_improvement": 55.69696468095343,
                    "length_improvement": 13.574560741930236,
                    "smoothness_improvement": 1492.8826660913144,
                    "objective_score": 32.31823917990074
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "A simplified bidirectional RRT* planner with fixed rewiring radius, goal bias sampling, and post-planning shortcutting for smooth, short paths within a 30-second time limit. The planner alternately grows trees from start and goal, extends towards random samples, rewires neighbors in a fixed radius, attempts connections between trees, and extracts the best found path, applying shortcutting once at the end to improve smoothness and length. It balances simplicity and effectiveness for general use.",
          "planning_mechanism": "The planner expands two trees alternately from start and goal positions by sampling with goal bias, steering towards samples with a fixed step size, rewiring nodes within a constant radius to improve local costs, and checking for connections between trees within a fixed radius. Upon successful connection or time expiration (30s), it extracts the path from both trees and performs shortcutting for path improvement. Collision checks and map bounds are enforced throughout.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\nclass Planner:\n    def __init__(self, max_iter: int=5000, step_size: float=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.time_limit = 30.0\n        self.goal_sample_rate = 0.15  # 15% goal bias\n\n    def plan(self, map) -> 'PlannerResult':\n        import time\n        import math\n        import random\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def in_obstacle(p):\n            for o in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = o\n                    px, py, pz = p\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w_, h_ = o\n                    px, py = p\n                    if x <= px <= x + w_ and y <= py <= y + h_:\n                        return True\n            return False\n\n        def edge_in_obstacle(a, b, resolution=1.0):\n            distance = dist(a, b)\n            steps = max(1, int(distance / resolution))\n            for i in range(steps+1):\n                interp = tuple(a[d] + (b[d]-a[d]) * (i / steps) for d in range(dim))\n                if in_obstacle(interp):\n                    return True\n            return False\n\n        def sample_free():\n            if random.random() < self.goal_sample_rate:\n                return goal_pos\n            for _ in range(30):\n                p = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not in_obstacle(p):\n                    return p\n            return goal_pos\n\n        def steer(from_p, to_p, max_step):\n            d = dist(from_p, to_p)\n            if d <= max_step:\n                return to_p\n            ratio = max_step / d\n            return tuple(from_p[i] + ratio * (to_p[i] - from_p[i]) for i in range(dim))\n\n        def nearest(tree, point):\n            best_node = None\n            best_dist = float('inf')\n            for node in tree:\n                d = dist(node.position, point)\n                if d < best_dist:\n                    best_dist = d\n                    best_node = node\n            return best_node\n\n        def near(tree, point, radius):\n            r_sq = radius*radius\n            neighbors = []\n            for node in tree:\n                d_sq = 0.0\n                for i in range(dim):\n                    diff = node.position[i] - point[i]\n                    d_sq += diff*diff\n                    if d_sq > r_sq:\n                        break\n                else:\n                    neighbors.append(node)\n            return neighbors\n\n        def rewire(tree, new_node, neighbors):\n            for nb in neighbors:\n                if nb is new_node.parent:\n                    continue\n                cost_through = new_node.cost + dist(new_node.position, nb.position)\n                if cost_through + 1e-9 < nb.cost:\n                    if not edge_in_obstacle(new_node.position, nb.position, resolution=max(self.step_size*0.2,0.2)):\n                        if nb.parent:\n                            nb.parent.remove_child(nb)\n                        nb.parent = new_node\n                        nb.cost = cost_through\n                        new_node.add_child(nb)\n\n        def try_connect(new_node, other_tree, connect_radius):\n            candidates = near(other_tree, new_node.position, connect_radius)\n            best_node = None\n            best_cost = float('inf')\n            for node in candidates:\n                d = dist(new_node.position, node.position)\n                if d <= connect_radius:\n                    if not edge_in_obstacle(new_node.position, node.position, resolution=max(self.step_size*0.2,0.2)):\n                        total_cost = new_node.cost + d + node.cost\n                        if total_cost < best_cost:\n                            best_cost = total_cost\n                            best_node = node\n            return best_node, best_cost\n\n        def extract_path(node_start, node_goal):\n            path_start = []\n            cur = node_start\n            while cur is not None:\n                path_start.append(cur.position)\n                cur = cur.parent\n            path_start.reverse()\n            path_goal = []\n            cur = node_goal\n            while cur is not None:\n                path_goal.append(cur.position)\n                cur = cur.parent\n            if path_start and path_goal and path_start[-1] == path_goal[0]:\n                path_goal = path_goal[1:]\n            return path_start + path_goal\n\n        def shortcut_path(path, max_attempts=50):\n            if len(path) < 3:\n                return path\n            attempts = 0\n            while attempts < max_attempts and len(path) > 2:\n                i = random.randint(0, len(path)-3)\n                j = random.randint(i+2, len(path)-1)\n                if not edge_in_obstacle(path[i], path[j], resolution=max(self.step_size*0.2,0.2)):\n                    path = path[:i+1] + path[j:]\n                attempts += 1\n            return path\n\n        start_tree = [Node(start_pos, cost=0.0)]\n        goal_tree = [Node(goal_pos, cost=0.0)]\n        nodes = start_tree[:] + goal_tree[:]\n\n        best_connection = None\n        best_cost = float('inf')\n        success = False\n        extracted_path = []\n\n        connect_radius = self.step_size * 3.0\n        rewire_radius = self.step_size * 3.0\n\n        start_time = time.monotonic()\n\n        for it in range(self.max_iter):\n            if time.monotonic() - start_time > self.time_limit:\n                break\n\n            tree_a = start_tree if it % 2 == 0 else goal_tree\n            tree_b = goal_tree if it % 2 == 0 else start_tree\n\n            sample = sample_free()\n            nearest_node = nearest(tree_a, sample)\n            new_pos = steer(nearest_node.position, sample, self.step_size)\n\n            if in_obstacle(new_pos):\n                continue\n            if edge_in_obstacle(nearest_node.position, new_pos, resolution=max(self.step_size*0.2,0.2)):\n                continue\n\n            neighbors = near(tree_a, new_pos, rewire_radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            min_parent = nearest_node\n            for nb in neighbors:\n                cost_cand = nb.cost + dist(nb.position, new_pos)\n                if cost_cand + 1e-9 < min_cost:\n                    if not edge_in_obstacle(nb.position, new_pos, resolution=max(self.step_size*0.2,0.2)):\n                        min_cost = cost_cand\n                        min_parent = nb\n\n            new_node = Node(new_pos, parent=min_parent, cost=min_cost)\n            min_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n\n            rewire(tree_a, new_node, neighbors)\n\n            conn_node, conn_cost = try_connect(new_node, tree_b, connect_radius)\n            if conn_node is not None and conn_cost + 1e-9 < best_cost:\n                best_cost = conn_cost\n                best_connection = (new_node, conn_node) if it % 2 == 0 else (conn_node, new_node)\n                success = True\n                break\n\n        if success and best_connection is not None:\n            extracted_path = extract_path(best_connection[0], best_connection[1])\n            extracted_path = shortcut_path(extracted_path, max_attempts=75)\n\n        return PlannerResult(\n            success=success,\n            path=extracted_path,\n            nodes=nodes,\n            edges=[(n.parent, n) for n in nodes if n.parent is not None]\n        )",
          "objective": -33.45177,
          "time_improvement": 56.0,
          "length_improvement": 17.0,
          "smoothness_improvement": 1285.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.014529967308044433,
                    "num_nodes_avg": 111.6,
                    "path_length_avg": 161.03706260477483,
                    "smoothness_avg": 0.04081567112250817,
                    "success_improvement": 0.0,
                    "time_improvement": 42.420574857948374,
                    "length_improvement": 11.733034190769047,
                    "smoothness_improvement": 538.85388571571,
                    "objective_score": 22.46026240042449
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.035787129402160646,
                    "num_nodes_avg": 320.8,
                    "path_length_avg": 233.2255343702081,
                    "smoothness_avg": 0.08695873713709827,
                    "success_improvement": 0.0,
                    "time_improvement": 78.17068222571577,
                    "length_improvement": 22.142603602431457,
                    "smoothness_improvement": 2137.5109403842193,
                    "objective_score": 47.424321531094705
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.026593804359436035,
                    "num_nodes_avg": 245.0,
                    "path_length_avg": 123.5306087091216,
                    "smoothness_avg": 0.10051367153899285,
                    "success_improvement": 0.0,
                    "time_improvement": 46.013254866998786,
                    "length_improvement": 17.95685159087046,
                    "smoothness_improvement": 1178.5264828285044,
                    "objective_score": 30.470719828764434
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "A simplified bidirectional RRT* planner with uniform sampling, fixed rewiring radius, and single candidate connection attempts for faster generalization and easier implementation. The planner alternates growing two trees from start and goal, connects new samples through nearest nodes, rewires neighbors within a fixed radius to improve local paths, and performs a single connection attempt between trees each iteration. The algorithm enforces collision checking and terminates after a 30-second hard time limit or upon connecting the trees. Final path shortcutting is applied for path smoothing.",
          "planning_mechanism": "A bidirectional RRT* method using uniform random sampling, fixed neighborhood radius for rewiring, and single connection attempts between trees. The planner alternately expands start and goal trees by sampling, steering with fixed step size, rewiring neighbors within a set radius, attempts one connection to the opposite tree per iteration, and applies shortcutting post-planning. Collision checks ensure feasibility, and planning stops when trees connect or time limit is reached.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=5.0, radius=15.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.radius = radius\n        self.time_limit = 30.0\n\n    def plan(self, map):\n        import time\n        import math\n        import random\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = dim == 3\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def sample_free():\n            for _ in range(100):\n                p = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n            return goal_pos\n\n        def nearest(tree, point):\n            best_node = None\n            best_dist = float('inf')\n            for node in tree:\n                d = dist(node.position, point)\n                if d < best_dist:\n                    best_node = node\n                    best_dist = d\n            return best_node\n\n        def near(tree, point, radius):\n            result = []\n            for node in tree:\n                if dist(node.position, point) <= radius:\n                    result.append(node)\n            return result\n\n        def steer(from_p, to_p, max_step):\n            d = dist(from_p, to_p)\n            if d <= max_step:\n                return to_p\n            ratio = max_step / d\n            return tuple(from_p[i] + (to_p[i] - from_p[i]) * ratio for i in range(dim))\n\n        def path_from_root(node):\n            p = []\n            cur = node\n            while cur:\n                p.append(cur.position)\n                cur = cur.parent\n            return p[::-1]\n\n        def extract_path(node_start, node_goal):\n            return path_from_root(node_start) + path_from_root(node_goal)[::-1]\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            max_attempts = 50\n            for _ in range(max_attempts):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        def can_connect(node, other_tree):\n            # Try single nearest neighbor connection\n            nn = nearest(other_tree, node.position)\n            d = dist(node.position, nn.position)\n            if d <= self.step_size * 2:\n                if not self._is_edge_in_obstacle(node.position, nn.position, obstacles, is_3d):\n                    return nn\n            return None\n\n        start_tree = [Node(start_pos, cost=0.0)]\n        goal_tree = [Node(goal_pos, cost=0.0)]\n        nodes = start_tree[:] + goal_tree[:]\n        edges = []\n\n        success = False\n        best_connection = None\n\n        start_time = time.monotonic()\n\n        for it in range(self.max_iter):\n            if time.monotonic() - start_time > self.time_limit:\n                break\n\n            tree_a = start_tree if it % 2 == 0 else goal_tree\n            tree_b = goal_tree if it % 2 == 0 else start_tree\n\n            q_rand = sample_free()\n            nearest_node = nearest(tree_a, q_rand)\n            q_new_pos = steer(nearest_node.position, q_rand, self.step_size)\n\n            if self._is_in_obstacle(q_new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, q_new_pos, obstacles, is_3d):\n                continue\n\n            near_nodes = near(tree_a, q_new_pos, self.radius)\n            min_cost = nearest_node.cost + dist(nearest_node.position, q_new_pos)\n            min_parent = nearest_node\n            for node_near in near_nodes:\n                tentative_cost = node_near.cost + dist(node_near.position, q_new_pos)\n                if tentative_cost < min_cost:\n                    if not self._is_edge_in_obstacle(node_near.position, q_new_pos, obstacles, is_3d):\n                        min_cost = tentative_cost\n                        min_parent = node_near\n\n            new_node = Node(q_new_pos, parent=min_parent, cost=min_cost)\n            min_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((min_parent, new_node))\n\n            for node_near in near_nodes:\n                if node_near is min_parent:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, node_near.position)\n                if new_cost < node_near.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, node_near.position, obstacles, is_3d):\n                        if node_near.parent:\n                            try:\n                                edges.remove((node_near.parent, node_near))\n                            except ValueError:\n                                pass\n                            node_near.parent.remove_child(node_near)\n                        node_near.parent = new_node\n                        node_near.cost = new_cost\n                        new_node.add_child(node_near)\n                        edges.append((new_node, node_near))\n\n            connect_node = can_connect(new_node, tree_b)\n            if connect_node:\n                success = True\n                best_connection = (new_node, connect_node)\n                break\n\n        extracted_path = []\n        if success and best_connection:\n            extracted_path = extract_path(best_connection[0], best_connection[1])\n            extracted_path = shortcut_path(extracted_path)\n\n        return PlannerResult(\n            success=success,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=None):\n        import math\n        if resolution is None:\n            resolution = self.step_size / 5.0\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -33.44837,
          "time_improvement": 60.0,
          "length_improvement": 16.0,
          "smoothness_improvement": 1127.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.017261242866516112,
                    "num_nodes_avg": 125.1,
                    "path_length_avg": 169.26443026978103,
                    "smoothness_avg": 0.03777728873980467,
                    "success_improvement": 0.0,
                    "time_improvement": 31.59706278615822,
                    "length_improvement": 7.223483602595675,
                    "smoothness_improvement": 491.29660347345225,
                    "objective_score": 16.269692014772133
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.02262437343597412,
                    "num_nodes_avg": 263.3,
                    "path_length_avg": 230.0918053948804,
                    "smoothness_avg": 0.06918445773371493,
                    "success_improvement": 0.0,
                    "time_improvement": 86.19965765826035,
                    "length_improvement": 23.188732533783156,
                    "smoothness_improvement": 1680.1659290391842,
                    "objective_score": 48.173966462943916
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.017999649047851562,
                    "num_nodes_avg": 221.6,
                    "path_length_avg": 123.41943787675473,
                    "smoothness_avg": 0.1029110691665013,
                    "success_improvement": 0.0,
                    "time_improvement": 63.45981746364785,
                    "length_improvement": 18.030685964342368,
                    "smoothness_improvement": 1209.0212036929265,
                    "objective_score": 35.90146283616441
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m1",
          "algorithm_description": "A bidirectional RRT* planner implementing adaptive rewiring with an adaptive neighborhood radius, probabilistic goal bias sampling, multiple candidate connection attempts, and progressive path shortcutting. The algorithm alternates tree expansions (start and goal), rewires local neighborhoods for cost improvement, and incrementally shortcuts paths during search, while enforcing timely termination within a 30-second wall-clock limit. It balances exploration and exploitation to improve planning efficiency, path length, and smoothness.",
          "planning_mechanism": "The planner grow two trees bidirectionally with step-limited expansions guided by goal bias sampling. Each new node rewires neighbors in an adaptive radius that shrinks as trees grow, ensuring efficient local optimization. Candidate connections between trees are assessed each iteration to update best paths and facilitate early stopping. Paths are incrementally shortcut for smoothness and length improvement. Strict collision checking and map bounds are enforced throughout.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position       # Tuple[float, ...]\n        self.parent = parent           # Node or None\n        self.cost = cost               # Cost from start/goal root to this node\n        self.children = []             # List of child nodes\n        self.valid = True              # Used if needed for collision checks\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.time_limit = 30.0\n        self.goal_sample_rate = 0.15  # 15% chance to sample goal, guiding exploration\n\n    def plan(self, map) -> 'PlannerResult':\n        import time\n        import random\n        import math\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        # Constants for rewiring radius calculation and shortcutting\n        gamma_rrt_star = 35.0\n        shortcut_interval = 75\n\n        # Helper functions\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def in_obstacle(pos):\n            for o in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = o\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w_, h_ = o\n                    px, py = pos\n                    if x <= px <= x + w_ and y <= py <= y + h_:\n                        return True\n            return False\n\n        def edge_in_obstacle(a, b, resolution=1.0):\n            distance = dist(a, b)\n            steps = max(1, int(distance / resolution))\n            for i in range(steps + 1):\n                interp = tuple(a[d] + (b[d] - a[d]) * (i / steps) for d in range(dim))\n                if in_obstacle(interp):\n                    return True\n            return False\n\n        def steer(from_p, to_p, max_step):\n            d = dist(from_p, to_p)\n            if d <= max_step:\n                return to_p\n            ratio = max_step / d\n            return tuple(from_p[i] + ratio * (to_p[i] - from_p[i]) for i in range(dim))\n\n        def sample_free():\n            if random.random() < self.goal_sample_rate:\n                return goal_pos\n            for _ in range(100):\n                p = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not in_obstacle(p):\n                    return p\n            # fallback to goal if unable to sample free after attempts\n            return goal_pos\n\n        def nearest(tree, point):\n            best_node = None\n            best_dist = float('inf')\n            for node in tree:\n                d = dist(node.position, point)\n                if d < best_dist:\n                    best_dist = d\n                    best_node = node\n            return best_node\n\n        def near(tree, point, radius):\n            neighbors = []\n            r_sq = radius * radius\n            for node in tree:\n                dx = node.position\n                # squared distance for efficiency\n                d = 0.0\n                for i in range(dim):\n                    delta = dx[i] - point[i]\n                    d += delta * delta\n                    if d > r_sq:\n                        break\n                if d <= r_sq:\n                    neighbors.append((math.sqrt(d), node))\n            neighbors.sort(key=lambda x: x[0])\n            return [n[1] for n in neighbors]\n\n        def extract_path(node_start, node_goal):\n            path_start = []\n            cur = node_start\n            while cur is not None:\n                path_start.append(cur.position)\n                cur = cur.parent\n            path_start.reverse()\n            path_goal = []\n            cur = node_goal\n            while cur is not None:\n                path_goal.append(cur.position)\n                cur = cur.parent\n            if path_start and path_goal and path_start[-1] == path_goal[0]:\n                path_goal = path_goal[1:]\n            return path_start + path_goal\n\n        def shortcut_path(path, max_attempts=50):\n            if len(path) < 3:\n                return path\n            attempts = 0\n            while attempts < max_attempts and len(path) > 2:\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if not edge_in_obstacle(path[i], path[j], resolution=max(self.step_size * 0.2, 0.2)):\n                    path = path[:i + 1] + path[j:]\n                attempts += 1\n            return path\n\n        def rewire(tree, new_node, neighbors):\n            for neighbor in neighbors:\n                if neighbor is new_node.parent:\n                    continue\n                cost_through = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_through + 1e-9 < neighbor.cost:\n                    if not edge_in_obstacle(new_node.position, neighbor.position, resolution=max(self.step_size * 0.2, 0.2)):\n                        # Rewire: change parent to new_node\n                        if neighbor.parent:\n                            try:\n                                edges.remove((neighbor.parent, neighbor))\n                            except ValueError:\n                                pass\n                            neighbor.parent.remove_child(neighbor)\n                        neighbor.parent = new_node\n                        neighbor.cost = cost_through\n                        new_node.add_child(neighbor)\n                        edges.append((new_node, neighbor))\n\n        def try_connect(new_node, other_tree):\n            radius = self.step_size * 2.5\n            candidates = near(other_tree, new_node.position, radius)\n            best_cand = None\n            best_cost_local = float('inf')\n            for node in candidates:\n                d = dist(new_node.position, node.position)\n                if d <= radius and not edge_in_obstacle(new_node.position, node.position, resolution=max(self.step_size * 0.2, 0.2)):\n                    total_cost = new_node.cost + d + node.cost\n                    if total_cost < best_cost_local:\n                        best_cost_local = total_cost\n                        best_cand = node\n            return best_cand, best_cost_local\n\n        start_tree = [Node(start_pos, cost=0.0)]\n        goal_tree = [Node(goal_pos, cost=0.0)]\n        nodes = start_tree[:] + goal_tree[:]\n        edges = []\n\n        best_connection = None\n        best_cost = float('inf')\n        success = False\n        extracted_path = []\n\n        start_time = time.monotonic()\n        iter_since_last_shortcut = 0\n\n        for it in range(self.max_iter):\n            if time.monotonic() - start_time > self.time_limit:\n                break\n\n            tree_a = start_tree if it % 2 == 0 else goal_tree\n            tree_b = goal_tree if it % 2 == 0 else start_tree\n\n            sample = sample_free()\n            nearest_node = nearest(tree_a, sample)\n            new_pos = steer(nearest_node.position, sample, self.step_size)\n\n            if in_obstacle(new_pos):\n                continue\n            if edge_in_obstacle(nearest_node.position, new_pos, resolution=max(self.step_size * 0.2, 0.2)):\n                continue\n\n            n_nodes = len(tree_a) + 1\n            radius = min(self.step_size * 5,\n                         gamma_rrt_star * ((math.log(n_nodes) / n_nodes) ** (1 / dim)))\n            if radius < self.step_size:\n                radius = self.step_size\n\n            neighbors = near(tree_a, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            min_parent = nearest_node\n            for nb in neighbors:\n                cost_candidate = nb.cost + dist(nb.position, new_pos)\n                if cost_candidate + 1e-9 < min_cost:\n                    if not edge_in_obstacle(nb.position, new_pos, resolution=max(self.step_size * 0.2, 0.2)):\n                        min_cost = cost_candidate\n                        min_parent = nb\n\n            new_node = Node(new_pos, parent=min_parent, cost=min_cost)\n            min_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((min_parent, new_node))\n\n            rewire(tree_a, new_node, neighbors)\n\n            conn_node, conn_cost = try_connect(new_node, tree_b)\n            if conn_node is not None and conn_cost + 1e-9 < best_cost:\n                best_cost = conn_cost\n                best_connection = (new_node, conn_node) if it % 2 == 0 else (conn_node, new_node)\n                success = True\n                # Early stop for improved connection\n                break\n\n            iter_since_last_shortcut += 1\n            if iter_since_last_shortcut >= shortcut_interval and success:\n                path_cur = extract_path(best_connection[0], best_connection[1])\n                path_short = shortcut_path(path_cur, max_attempts=25)\n                if len(path_short) < len(path_cur):\n                    iter_since_last_shortcut = 0\n                    extracted_path = path_short\n\n        if success and best_connection is not None:\n            if not extracted_path:\n                extracted_path = extract_path(best_connection[0], best_connection[1])\n            extracted_path = shortcut_path(extracted_path, max_attempts=75)\n        else:\n            # Attempt to find best partial connection if no success\n            best_partial_cost = float('inf')\n            best_pair = None\n            search_radius = self.step_size * 3.0\n            for n1 in start_tree:\n                candidates = near(goal_tree, n1.position, search_radius)\n                for n2 in candidates:\n                    d12 = dist(n1.position, n2.position)\n                    if d12 <= search_radius:\n                        if not edge_in_obstacle(n1.position, n2.position, resolution=max(self.step_size * 0.2, 0.2)):\n                            total_cost = n1.cost + n2.cost + d12\n                            if total_cost + 1e-9 < best_partial_cost:\n                                best_partial_cost = total_cost\n                                best_pair = (n1, n2)\n            if best_pair:\n                success = True\n                extracted_path = extract_path(best_pair[0], best_pair[1])\n                extracted_path = shortcut_path(extracted_path, max_attempts=75)\n\n        return PlannerResult(\n            success=success,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )",
          "objective": -33.38892,
          "time_improvement": 62.0,
          "length_improvement": 14.0,
          "smoothness_improvement": 1201.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.01741950511932373,
                    "num_nodes_avg": 144.8,
                    "path_length_avg": 170.95768293999285,
                    "smoothness_avg": 0.03857219544748236,
                    "success_improvement": 0.0,
                    "time_improvement": 30.969900360727053,
                    "length_improvement": 6.295384982747003,
                    "smoothness_improvement": 503.7386196161522,
                    "objective_score": 15.586894195947078
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.02476348876953125,
                    "num_nodes_avg": 277.2,
                    "path_length_avg": 240.8097731892848,
                    "smoothness_avg": 0.07867206388588006,
                    "success_improvement": 0.0,
                    "time_improvement": 84.89484698604019,
                    "length_improvement": 19.610766384413225,
                    "smoothness_improvement": 1924.2888689808865,
                    "objective_score": 46.85635827136442
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.01417391300201416,
                    "num_nodes_avg": 190.8,
                    "path_length_avg": 124.2791753311308,
                    "smoothness_avg": 0.10031237330959633,
                    "success_improvement": 0.0,
                    "time_improvement": 71.22625185796103,
                    "length_improvement": 17.459689283444,
                    "smoothness_improvement": 1175.9659842088704,
                    "objective_score": 37.723519048499064
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m1",
          "algorithm_description": "An enhanced bidirectional RRT* planner with adaptive neighborhood radius, efficient rewiring, improved goal bias, and periodic path shortcutting to optimize planning time, path length, and smoothness within a strict time limit. It alternates expanding two trees from start and goal with dynamic radius scaling based on tree size, performs cost-based rewiring, tries multiple candidate connections per iteration with early termination on improvement, and continuously refines the best path through shortcutting.",
          "planning_mechanism": "A bidirectional RRT* alternates tree expansions with adaptive neighborhood search and rewiring radius based on logarithmic scaling of the number of nodes and problem dimension. Sampling uses enhanced goal bias to accelerate convergence. Connecting the two trees employs multi-candidate cost-based edge selection. The algorithm interrupts early after strong improvements or after a 30-second time budget, returning the best path found. Periodic shortcutting improves smoothness and shortens paths incrementally, avoiding excessive computation while maintaining high-quality solutions.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\nclass Planner:\n    def __init__(self, max_iter: int = 6000, step_size: float = 4.5, goal_sample_rate: float = 0.20):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.time_limit = 30.0  # Hard time limit in seconds\n\n    def plan(self, map):\n        import time\n        import math\n        import random\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        gamma_rrt_star = 30.0  # Radius coefficient tuned for improved smoothness\n\n        start_tree = [Node(start_pos, cost=0.0)]\n        goal_tree = [Node(goal_pos, cost=0.0)]\n        nodes = start_tree[:] + goal_tree[:]\n        edges = []\n\n        best_connection = None\n        best_cost = float('inf')\n        success = False\n        found_improvement = False\n\n        start_time = time.monotonic()\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def sample_free():\n            # Enhanced goal bias with moderate attempts for efficiency\n            if random.random() < self.goal_sample_rate:\n                return goal_pos\n            for _ in range(30):\n                p = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n            return goal_pos  # Fallback if no free point found\n\n        def nearest(tree, point):\n            best_node = None\n            best_dist = float('inf')\n            for node in tree:\n                d = dist(node.position, point)\n                if d < best_dist:\n                    best_node = node\n                    best_dist = d\n            return best_node\n\n        def near(tree, point, radius):\n            radius_sq = radius * radius\n            neighbors = []\n            for node in tree:\n                # squared distance for efficiency\n                sq_dist = 0.0\n                for i in range(dim):\n                    diff = node.position[i] - point[i]\n                    sq_dist += diff * diff\n                    if sq_dist > radius_sq:\n                        break\n                if sq_dist <= radius_sq:\n                    neighbors.append((sq_dist, node))\n            neighbors.sort(key=lambda x: x[0])\n            return [nd[1] for nd in neighbors]\n\n        def steer(from_p, to_p, max_step):\n            d = dist(from_p, to_p)\n            if d <= max_step:\n                return to_p\n            ratio = max_step / d\n            return tuple(from_p[i] + (to_p[i] - from_p[i]) * ratio for i in range(dim))\n\n        def extract_path(node_start, node_goal):\n            path_start = []\n            cur = node_start\n            while cur is not None:\n                path_start.append(cur.position)\n                cur = cur.parent\n            path_goal = []\n            cur = node_goal\n            while cur is not None:\n                path_goal.append(cur.position)\n                cur = cur.parent\n            return path_start[::-1] + path_goal\n\n        def shortcut_path(path):\n            max_attempts = 80\n            if len(path) < 3:\n                return path\n            for _ in range(max_attempts):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        def try_connect(node, other_tree, radius):\n            candidates = near(other_tree, node.position, radius)\n            best_node = None\n            best_cost_local = float('inf')\n            for cnode in candidates:\n                d = dist(node.position, cnode.position)\n                if d <= radius and not self._is_edge_in_obstacle(node.position, cnode.position, obstacles, is_3d):\n                    total_cost = node.cost + cnode.cost + d\n                    if total_cost < best_cost_local:\n                        best_cost_local = total_cost\n                        best_node = cnode\n            return best_node, best_cost_local\n\n        for it in range(self.max_iter):\n            current_time = time.monotonic()\n            if current_time - start_time > self.time_limit:\n                break\n\n            # Alternate expansion\n            if it % 2 == 0:\n                tree_a, tree_b = start_tree, goal_tree\n            else:\n                tree_a, tree_b = goal_tree, start_tree\n\n            sample = sample_free()\n            nearest_node = nearest(tree_a, sample)\n            new_pos = steer(nearest_node.position, sample, self.step_size)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            n_nodes = len(tree_a) + 1\n            radius = min(self.step_size * 4.5, gamma_rrt_star * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim)))\n\n            near_nodes = near(tree_a, new_pos, radius)\n\n            # Find best parent node (lowest cost)\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            min_parent = nearest_node\n            for near_node in near_nodes:\n                cost_through = near_node.cost + dist(near_node.position, new_pos)\n                if cost_through < min_cost:\n                    if not self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d):\n                        min_cost = cost_through\n                        min_parent = near_node\n\n            new_node = Node(new_pos, parent=min_parent, cost=min_cost)\n            min_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((min_parent, new_node))\n\n            # Rewire neighbors incrementally\n            for near_node in near_nodes:\n                if near_node is min_parent:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, near_node.position)\n                if new_cost < near_node.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                        if near_node.parent:\n                            try:\n                                edges.remove((near_node.parent, near_node))\n                            except ValueError:\n                                pass\n                            near_node.parent.remove_child(near_node)\n                        near_node.parent = new_node\n                        near_node.cost = new_cost\n                        new_node.add_child(near_node)\n                        edges.append((new_node, near_node))\n\n            # Attempt multi-candidate tree connection\n            connect_radius = self.step_size * 3.2\n            conn_node, conn_cost = try_connect(new_node, tree_b, connect_radius)\n            if conn_node is not None and conn_cost < best_cost:\n                best_cost = conn_cost\n                best_connection = (new_node, conn_node)\n                success = True\n                found_improvement = True\n                # Early stop on improvement\n                break\n\n            # Periodic path shortcutting to improve smoothness & length\n            if found_improvement and (it % 120 == 0) and best_connection is not None:\n                path = extract_path(best_connection[0], best_connection[1])\n                shortcut = shortcut_path(path)\n                shortcut_len = sum(dist(shortcut[i], shortcut[i + 1]) for i in range(len(shortcut) - 1))\n                if shortcut_len + 1e-5 < best_cost:\n                    best_cost = shortcut_len\n                    extracted_path = shortcut\n                else:\n                    extracted_path = path\n\n        # Final path extraction and shortcutting if success\n        if success and best_connection is not None:\n            path = extract_path(best_connection[0], best_connection[1])\n            extracted_path = shortcut_path(path)\n        else:\n            # Fallback: find best pair bridging trees if no direct connection found\n            best_pair = None\n            min_total_cost = float('inf')\n            for n1 in start_tree:\n                near_goal_candidates = near(goal_tree, n1.position, self.step_size * 3.2)\n                for n2 in near_goal_candidates:\n                    d12 = dist(n1.position, n2.position)\n                    if d12 <= self.step_size * 3.2 and not self._is_edge_in_obstacle(n1.position, n2.position, obstacles, is_3d):\n                        total_c = n1.cost + n2.cost + d12\n                        if total_c < min_total_cost:\n                            min_total_cost = total_c\n                            best_pair = (n1, n2)\n            if best_pair:\n                path = extract_path(best_pair[0], best_pair[1])\n                extracted_path = shortcut_path(path)\n                success = True\n            else:\n                extracted_path = []\n\n        return PlannerResult(\n            success=success,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -33.36919,
          "time_improvement": 57.0,
          "length_improvement": 15.0,
          "smoothness_improvement": 1442.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.014020967483520507,
                    "num_nodes_avg": 122.0,
                    "path_length_avg": 168.85621197856955,
                    "smoothness_avg": 0.04592179710711396,
                    "success_improvement": 0.0,
                    "time_improvement": 43.972927835189054,
                    "length_improvement": 7.44723451664146,
                    "smoothness_improvement": 618.7758455048379,
                    "objective_score": 20.754098288065784
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.039501094818115236,
                    "num_nodes_avg": 363.8,
                    "path_length_avg": 236.27330058206434,
                    "smoothness_avg": 0.10265783372398023,
                    "success_improvement": 0.0,
                    "time_improvement": 75.84241189195431,
                    "length_improvement": 21.125171515827486,
                    "smoothness_improvement": 2541.460003166907,
                    "objective_score": 48.13512649291732
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.02402009963989258,
                    "num_nodes_avg": 264.6,
                    "path_length_avg": 125.65554175248053,
                    "smoothness_avg": 0.09952911323688463,
                    "success_improvement": 0.0,
                    "time_improvement": 51.53657956993282,
                    "length_improvement": 16.545572241909497,
                    "smoothness_improvement": 1166.002973898222,
                    "objective_score": 31.21833208561665
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m1",
          "algorithm_description": "A bidirectional, adaptive radius RRT* planner with goal bias sampling, multi-candidate tree connection attempts, incremental path shortcutting during planning, and refined collision checking resolution for improved planning efficiency, path length, and smoothness. It alternates extensios from start and goal trees, dynamically adapts rewiring radius based on tree growth and dimension, maintains consistent parent-child relations with careful rewiring, leverages multiple connection candidates for earlier, better path discoveries, and periodically shortcuts the current best path for smoother trajectories. A strict 30-second time limit halts the search early and returns the best path found so far.",
          "planning_mechanism": "The planner grows two trees from start and goal alternatively, samples points with a goal bias, connects nodes via steering and adaptive nearby rewiring, attempts multiple bridge connections each iteration, updates the best path on improvement, shortcuts paths incrementally, and terminates either on timeout or early if a better path is found, thus balancing search speed and solution quality effectively.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Cost from start (or respective root)\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.time_limit = 30.0\n        self.goal_sample_rate = 0.15   # Goal bias 15%\n        self.gamma_rrt_star = 35.0     # Radius multiplier for rewiring\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def dist(a,b):\n            return math.dist(a,b)\n\n        # Sample with goal bias and limited retries\n        def sample_free():\n            if random.random() < self.goal_sample_rate:\n                return goal_position\n            for _ in range(100):\n                p = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n            return goal_position\n\n        def nearest(tree, point):\n            best_node = None\n            best_d = float('inf')\n            for node in tree:\n                d = dist(node.position, point)\n                if d < best_d:\n                    best_node = node\n                    best_d = d\n            return best_node\n\n        def near(tree, point, radius):\n            return [node for node in tree if dist(node.position, point) <= radius]\n\n        def steer(from_p, to_p, max_step):\n            d = dist(from_p, to_p)\n            if d <= max_step:\n                return to_p\n            ratio = max_step / d\n            return tuple(from_p[i] + (to_p[i] - from_p[i]) * ratio for i in range(dim))\n\n        def extract_path(node_start, node_goal):\n            path_start = []\n            cur = node_start\n            while cur:\n                path_start.append(cur.position)\n                cur = cur.parent\n            path_start.reverse()\n            path_goal = []\n            cur = node_goal\n            while cur:\n                path_goal.append(cur.position)\n                cur = cur.parent\n            # Avoid duplicate node at connection\n            if path_goal and path_start and path_start[-1] == path_goal[0]:\n                path_goal = path_goal[1:]\n            return path_start + path_goal\n\n        def shortcut_path(path, max_attempts=30):\n            if len(path) < 3:\n                return path\n            for _ in range(max_attempts):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                # Use finer collision check resolution (step_size * 0.2 or min 0.2)\n                res = max(self.step_size * 0.2, 0.2)\n                if not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution=res):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        def rewire(tree, new_node, neighbors):\n            for nbr in neighbors:\n                if nbr is new_node.parent:\n                    continue\n                c_through = new_node.cost + dist(new_node.position, nbr.position)\n                if c_through + 1e-12 < nbr.cost:\n                    res = max(self.step_size * 0.2, 0.2)\n                    if not self._is_edge_in_obstacle(new_node.position, nbr.position, obstacles, is_3d, resolution=res):\n                        # Remove old edge\n                        if nbr.parent:\n                            try:\n                                edges.remove((nbr.parent, nbr))\n                            except Exception:\n                                pass\n                            nbr.parent.remove_child(nbr)\n                        # Attach to new parent\n                        nbr.parent = new_node\n                        nbr.cost = c_through\n                        new_node.add_child(nbr)\n                        edges.append((new_node, nbr))\n\n        def try_connect(new_node, other_tree):\n            radius = self.step_size * 2.5\n            candidates = near(other_tree, new_node.position, radius)\n            best_cand = None\n            best_cost = float('inf')\n            for node in candidates:\n                d12 = dist(new_node.position, node.position)\n                if d12 <= radius:\n                    res = max(self.step_size * 0.2, 0.2)\n                    if not self._is_edge_in_obstacle(new_node.position, node.position, obstacles, is_3d, resolution=res):\n                        cost = new_node.cost + d12 + node.cost\n                        if cost + 1e-12 < best_cost:\n                            best_cost = cost\n                            best_cand = node\n            return best_cand, best_cost\n\n        start_tree = [Node(start_position, cost=0.0)]\n        goal_tree = [Node(goal_position, cost=0.0)]\n        nodes = start_tree[:] + goal_tree[:]\n        edges: List[Tuple[Node,Node]] = []\n\n        best_connection = None\n        best_cost = float('inf')\n        success = False\n        extracted_path: List[Tuple[float,...]] = []\n\n        start_time = time.monotonic()\n        shortcut_counter = 0\n        shortcut_interval = 60\n\n        for it in range(self.max_iter):\n            elapsed = time.monotonic() - start_time\n            if elapsed > self.time_limit:\n                break\n\n            tree_a = start_tree if it % 2 == 0 else goal_tree\n            tree_b = goal_tree if it % 2 == 0 else start_tree\n\n            sample = sample_free()\n            nearest_node = nearest(tree_a, sample)\n            new_pos = steer(nearest_node.position, sample, self.step_size)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            res = max(self.step_size * 0.2, 0.2)\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d, resolution=res):\n                continue\n\n            n_nodes = len(tree_a) + 1\n            radius = self.gamma_rrt_star * ((math.log(n_nodes)/n_nodes)**(1/dim)) if n_nodes > 1 else self.step_size * 5\n            radius = min(max(radius, self.step_size), self.step_size * 5)\n\n            neighbors = near(tree_a, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            min_parent = nearest_node\n            for nb in neighbors:\n                candidate_cost = nb.cost + dist(nb.position, new_pos)\n                if candidate_cost + 1e-12 < min_cost:\n                    if not self._is_edge_in_obstacle(nb.position, new_pos, obstacles, is_3d, resolution=res):\n                        min_cost = candidate_cost\n                        min_parent = nb\n\n            new_node = Node(new_pos, parent=min_parent, cost=min_cost)\n            min_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((min_parent, new_node))\n\n            rewire(tree_a, new_node, neighbors)\n\n            conn_node, conn_cost = try_connect(new_node, tree_b)\n            if conn_node is not None and conn_cost + 1e-12 < best_cost:\n                best_cost = conn_cost\n                best_connection = (new_node, conn_node) if it % 2 == 0 else (conn_node, new_node)\n                success = True\n                # Early stopping on quality improvement\n                break\n\n            shortcut_counter += 1\n            if shortcut_counter >= shortcut_interval and success:\n                path_cur = extract_path(best_connection[0], best_connection[1])\n                path_short = shortcut_path(path_cur, max_attempts=20)\n                if len(path_short) < len(path_cur):\n                    extracted_path = path_short\n                shortcut_counter = 0\n\n        if success and best_connection is not None:\n            extracted_path = extract_path(best_connection[0], best_connection[1])\n            extracted_path = shortcut_path(extracted_path, max_attempts=50)\n        else:\n            # Attempt best partial connection\n            best_partial = float('inf')\n            best_pair = None\n            search_r = self.step_size * 3.0\n            for n1 in start_tree:\n                candidates = near(goal_tree, n1.position, search_r)\n                for n2 in candidates:\n                    d12 = dist(n1.position, n2.position)\n                    if d12 <= search_r:\n                        res = max(self.step_size * 0.2, 0.2)\n                        if not self._is_edge_in_obstacle(n1.position, n2.position, obstacles, is_3d, resolution=res):\n                            cost_sum = n1.cost + n2.cost + d12\n                            if cost_sum + 1e-12 < best_partial:\n                                best_partial = cost_sum\n                                best_pair = (n1, n2)\n            if best_pair:\n                success = True\n                extracted_path = extract_path(best_pair[0], best_pair[1])\n                extracted_path = shortcut_path(extracted_path, max_attempts=50)\n\n        return PlannerResult(success=success, path=extracted_path, nodes=nodes, edges=edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -33.27399,
          "time_improvement": 64.0,
          "length_improvement": 14.0,
          "smoothness_improvement": 1206.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.011754417419433593,
                    "num_nodes_avg": 126.9,
                    "path_length_avg": 174.91718825193033,
                    "smoothness_avg": 0.03793544847825864,
                    "success_improvement": 0.0,
                    "time_improvement": 53.4195374606252,
                    "length_improvement": 4.125117378897335,
                    "smoothness_improvement": 493.77214682962614,
                    "objective_score": 20.96979239967409
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.025002145767211915,
                    "num_nodes_avg": 312.3,
                    "path_length_avg": 243.015764712475,
                    "smoothness_avg": 0.0863227481504948,
                    "success_improvement": 0.0,
                    "time_improvement": 84.74927176029679,
                    "length_improvement": 18.874342918026972,
                    "smoothness_improvement": 2121.1464856745606,
                    "objective_score": 47.35511970727802
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.023228383064270018,
                    "num_nodes_avg": 294.9,
                    "path_length_avg": 123.9155785977955,
                    "smoothness_avg": 0.0868368257099966,
                    "success_improvement": 0.0,
                    "time_improvement": 52.845227429917784,
                    "length_improvement": 17.70117292110942,
                    "smoothness_improvement": 1004.5580134034196,
                    "objective_score": 31.497062048658087
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e2",
          "algorithm_description": "A hybrid bidirectional RRT*-inspired planner that utilizes adaptive neighborhood radius rewiring, goal bias sampling, multi-candidate connection attempts, and incremental cost-based rewiring for improving planning efficiency, path length, and smoothness. The planner alternates tree expansions from start and goal, applies spatial pruning by dynamically shrinking the radius based on tree cardinality and dimension to focus rewiring on relevant neighbors, uses early stopping upon improved connection, and performs lightweight path shortcutting for smoothing while maintaining collision safety.",
          "planning_mechanism": "The planner maintains two trees growing bidirectionally, samples with a goal bias to efficiently explore near the goal, steers nearest nodes toward samples with a fixed step size, and rewires neighbors dynamically by considering cost improvements confined to an adaptively shrinking radius to optimize path quality and minimize overhead. Each iteration tries multiple candidate nodes to connect the two trees, favoring lower-cost connections and terminating early when a high-quality path is found or time limit exceeded. The final path undergoes fast shortcutting to reduce unnecessary waypoints while preserving collision-freeness and smoothness.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0, goal_sample_rate: float=0.15):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.time_limit = 30.0\n\n    def plan(self, map):\n        import time\n        import math\n        import random\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n        gamma_rrt_star = 50.0  # Controls neighborhood radius scaling for rewiring\n\n        start_tree = [Node(start_pos, cost=0.0)]\n        goal_tree = [Node(goal_pos, cost=0.0)]\n        nodes = start_tree[:] + goal_tree[:]\n        edges = []\n\n        best_connection = None\n        best_cost = float('inf')\n        success = False\n\n        # Precompute squared step size for efficiency\n        step_size = self.step_size\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def sample_free():\n            # Goal biasing: sample goal with probability goal_sample_rate\n            if random.random() < self.goal_sample_rate:\n                return goal_pos\n            for _ in range(100):\n                p = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n            # Fallback in rare case no free sample found\n            return goal_pos\n\n        def nearest(tree, point):\n            # Linear nearest (can be improved with spatial DS, not requested)\n            best_node = None\n            best_dist = float('inf')\n            for node in tree:\n                d = dist(node.position, point)\n                if d < best_dist:\n                    best_node = node\n                    best_dist = d\n            return best_node\n\n        def near(tree, point, radius):\n            neighbors = []\n            for node in tree:\n                d = dist(node.position, point)\n                if d <= radius:\n                    neighbors.append((d, node))\n            neighbors.sort(key=lambda x: x[0])\n            return [nd[1] for nd in neighbors]\n\n        def steer(from_p, to_p, max_step):\n            d = dist(from_p, to_p)\n            if d <= max_step:\n                return to_p\n            ratio = max_step / d\n            return tuple(from_p[i] + (to_p[i] - from_p[i]) * ratio for i in range(dim))\n\n        def extract_path(node_from_start, node_from_goal):\n            path_start = []\n            cur = node_from_start\n            while cur:\n                path_start.append(cur.position)\n                cur = cur.parent\n            path_goal = []\n            cur = node_from_goal\n            while cur:\n                path_goal.append(cur.position)\n                cur = cur.parent\n            return path_start[::-1] + path_goal\n\n        def shortcut_path(path):\n            # Lightweight shortcutting: tries up to 100 random shortcuts to smooth path while collision-free\n            max_attempts = 100\n            if len(path) < 3:\n                return path\n            for _ in range(max_attempts):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d):\n                    # Remove intermediate nodes between i and j\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        def try_connect(node, other_tree):\n            # Try multiple connection candidates from other_tree within radius around node.position\n            radius = step_size * 2.0\n            candidates = near(other_tree, node.position, radius)\n            best_node = None\n            best_cost_local = float('inf')\n            for cnode in candidates:\n                d = dist(node.position, cnode.position)\n                if d <= radius and not self._is_edge_in_obstacle(node.position, cnode.position, obstacles, is_3d):\n                    total_cost = node.cost + cnode.cost + d\n                    if total_cost < best_cost_local:\n                        best_cost_local = total_cost\n                        best_node = cnode\n            return best_node, best_cost_local\n\n        start_time = time.monotonic()\n\n        for it in range(self.max_iter):\n            if time.monotonic() - start_time > self.time_limit:\n                break\n\n            # Alternate expansion between start and goal trees\n            tree_a = start_tree if it % 2 == 0 else goal_tree\n            tree_b = goal_tree if it % 2 == 0 else start_tree\n\n            sample = sample_free()\n            nearest_node = nearest(tree_a, sample)\n            new_pos = steer(nearest_node.position, sample, step_size)\n\n            # Node collision check\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n\n            # Edge collision check\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            # Adaptive rewiring radius\n            n_nodes = len(tree_a) + 1\n            radius = min(step_size * 5, gamma_rrt_star * (math.log(n_nodes) / n_nodes) ** (1 / dim))\n\n            near_nodes = near(tree_a, new_pos, radius)\n\n            # Choose best parent minimizing cost + dist\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            min_parent = nearest_node\n            for near_node in near_nodes:\n                # Check cost through near_node and collision with near_node->new_pos\n                cost_through = near_node.cost + dist(near_node.position, new_pos)\n                if cost_through < min_cost:\n                    if not self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d):\n                        min_cost = cost_through\n                        min_parent = near_node\n\n            new_node = Node(new_pos, parent=min_parent, cost=min_cost)\n            min_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((min_parent, new_node))\n\n            # Rewire neighbors to new_node if cost improves and edge is collision-free\n            for near_node in near_nodes:\n                if near_node == min_parent:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, near_node.position)\n                if new_cost < near_node.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                        # Remove old edge\n                        if near_node.parent:\n                            try:\n                                edges.remove((near_node.parent, near_node))\n                            except ValueError:\n                                pass\n                            near_node.parent.remove_child(near_node)\n                        # Update parent and cost\n                        near_node.parent = new_node\n                        near_node.cost = new_cost\n                        new_node.add_child(near_node)\n                        edges.append((new_node, near_node))\n\n            # Attempt to connect newly added node to other tree candidates\n            conn_node, conn_cost = try_connect(new_node, tree_b)\n            if conn_node and conn_cost < best_cost:\n                best_cost = conn_cost\n                best_connection = (new_node, conn_node)\n                success = True\n                # Early stopping on improved path\n                break\n\n        extracted_path = []\n        if success and best_connection:\n            extracted_path = extract_path(best_connection[0], best_connection[1])\n            extracted_path = shortcut_path(extracted_path)\n        else:\n            # Attempt to find best partial connection on timeout or failure\n            min_cost = float('inf')\n            best_pair = None\n            for n1 in start_tree:\n                candidates = near(goal_tree, n1.position, step_size * 2.0)\n                for n2 in candidates:\n                    dist12 = dist(n1.position, n2.position)\n                    if dist12 <= step_size * 2.0:\n                        if not self._is_edge_in_obstacle(n1.position, n2.position, obstacles, is_3d):\n                            total_cost = n1.cost + n2.cost + dist12\n                            if total_cost < min_cost:\n                                min_cost = total_cost\n                                best_pair = (n1, n2)\n            if best_pair:\n                extracted_path = extract_path(best_pair[0], best_pair[1])\n                extracted_path = shortcut_path(extracted_path)\n                success = True\n\n        return PlannerResult(\n            success=success,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(\n                from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps)\n                for d in range(len(from_pos))\n            )\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -33.09257,
          "time_improvement": 56.0,
          "length_improvement": 16.0,
          "smoothness_improvement": 1398.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.01958200931549072,
                    "num_nodes_avg": 140.8,
                    "path_length_avg": 166.35481911674003,
                    "smoothness_avg": 0.044027487308021036,
                    "success_improvement": 0.0,
                    "time_improvement": 21.75128782371844,
                    "length_improvement": 8.818287581316609,
                    "smoothness_improvement": 589.1257835894651,
                    "objective_score": 14.761987813852823
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.026345157623291017,
                    "num_nodes_avg": 303.5,
                    "path_length_avg": 235.08654885206815,
                    "smoothness_avg": 0.08998220763376255,
                    "success_improvement": 0.0,
                    "time_improvement": 83.88815627932586,
                    "length_improvement": 21.521343402054775,
                    "smoothness_improvement": 2215.3070139811657,
                    "objective_score": 49.15578799493645
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.0191939115524292,
                    "num_nodes_avg": 244.3,
                    "path_length_avg": 125.39778779809066,
                    "smoothness_avg": 0.11710275866810149,
                    "success_improvement": 0.0,
                    "time_improvement": 61.27399056588344,
                    "length_improvement": 16.71676014549089,
                    "smoothness_improvement": 1389.538446631726,
                    "objective_score": 35.359945490218195
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "A simplified bidirectional RRT* planner leveraging goal bias sampling, adaptive neighborhood rewiring, incremental path shortcutting, and efficient collision checking. It balances exploration and exploitation by alternating tree expansions from start and goal, connecting nodes with cost-aware rewiring in a shrinking neighborhood radius, and progressively refines the path during planning while enforcing a strict 30-second limit. Early path connections accelerate termination and incremental shortcutting improves path length and smoothness with low overhead.",
          "planning_mechanism": "The planner grows two trees from start and goal alternately using goal biased sampling. New samples are connected to the best parent in an adaptive neighborhood radius shrinking as trees grow. Rewiring locally improves subtree costs. After each iteration, the planner attempts connections between trees and applies shortcutting periodically to smooth the path. The search stops upon a valid path found or time limit reached, returning the best path. All nodes and edges maintain collision-free guarantees.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.time_limit = 30.0\n        self.goal_sample_rate = 0.15\n\n    def plan(self, map) -> 'PlannerResult':\n        import time\n        import random\n        import math\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def in_obstacle(pos):\n            for o in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = o\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w_, h_ = o\n                    px, py = pos\n                    if x <= px <= x + w_ and y <= py <= y + h_:\n                        return True\n            return False\n\n        def edge_in_obstacle(a, b, resolution=0.5):\n            distance = dist(a, b)\n            steps = max(1, int(distance / resolution))\n            for i in range(steps + 1):\n                interp = tuple(a[d] + (b[d] - a[d]) * (i / steps) for d in range(dim))\n                if in_obstacle(interp):\n                    return True\n            return False\n\n        def steer(from_p, to_p, max_step):\n            d = dist(from_p, to_p)\n            if d <= max_step:\n                return to_p\n            ratio = max_step / d\n            return tuple(from_p[i] + ratio * (to_p[i] - from_p[i]) for i in range(dim))\n\n        def sample_free():\n            if random.random() < self.goal_sample_rate:\n                if not in_obstacle(goal_pos):\n                    return goal_pos\n            for _ in range(30):\n                p = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not in_obstacle(p):\n                    return p\n            return goal_pos\n\n        def nearest(tree, point):\n            best_node = None\n            best_dist = float('inf')\n            for node in tree:\n                d = dist(node.position, point)\n                if d < best_dist:\n                    best_dist = d\n                    best_node = node\n            return best_node\n\n        def near(tree, point, radius):\n            neighbors = []\n            r_sq = radius * radius\n            for node in tree:\n                d_sq = sum((node.position[i] - point[i])**2 for i in range(dim))\n                if d_sq <= r_sq:\n                    neighbors.append((math.sqrt(d_sq), node))\n            neighbors.sort(key=lambda x: x[0])\n            return [n[1] for n in neighbors]\n\n        def extract_path(node_start, node_goal):\n            path_start = []\n            cur = node_start\n            while cur is not None:\n                path_start.append(cur.position)\n                cur = cur.parent\n            path_start.reverse()\n            path_goal = []\n            cur = node_goal\n            while cur is not None:\n                path_goal.append(cur.position)\n                cur = cur.parent\n            if path_start and path_goal and path_start[-1] == path_goal[0]:\n                path_goal = path_goal[1:]\n            return path_start + path_goal\n\n        def shortcut_path(path, max_attempts=30):\n            if len(path) < 3:\n                return path\n            attempts = 0\n            while attempts < max_attempts and len(path) > 2:\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if not edge_in_obstacle(path[i], path[j], resolution=max(self.step_size * 0.2, 0.2)):\n                    path = path[:i+1] + path[j:]\n                attempts += 1\n            return path\n\n        def rewire(tree, new_node, neighbors):\n            for neighbor in neighbors:\n                if neighbor is new_node.parent:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, neighbor.position)\n                if new_cost + 1e-9 < neighbor.cost:\n                    if not edge_in_obstacle(new_node.position, neighbor.position, resolution=max(self.step_size * 0.2, 0.2)):\n                        if neighbor.parent:\n                            try:\n                                edges.remove((neighbor.parent, neighbor))\n                            except ValueError:\n                                pass\n                            neighbor.parent.remove_child(neighbor)\n                        neighbor.parent = new_node\n                        neighbor.cost = new_cost\n                        new_node.add_child(neighbor)\n                        edges.append((new_node, neighbor))\n\n        def try_connect(new_node, other_tree):\n            radius = self.step_size * 3.0\n            candidates = near(other_tree, new_node.position, radius)\n            best_node = None\n            best_cost = float('inf')\n            for node in candidates:\n                d = dist(new_node.position, node.position)\n                if d <= radius and not edge_in_obstacle(new_node.position, node.position, resolution=max(self.step_size * 0.2, 0.2)):\n                    total_cost = new_node.cost + d + node.cost\n                    if total_cost < best_cost:\n                        best_cost = total_cost\n                        best_node = node\n            return best_node, best_cost\n\n        start_tree = [Node(start_pos, cost=0.0)]\n        goal_tree = [Node(goal_pos, cost=0.0)]\n        nodes = start_tree[:] + goal_tree[:]\n        edges = []\n\n        best_connection = None\n        best_cost = float('inf')\n        success = False\n        extracted_path = []\n\n        start_time = time.monotonic()\n        shortcut_counter = 0\n        shortcut_interval = 50\n\n        for iteration in range(self.max_iter):\n            if time.monotonic() - start_time > self.time_limit:\n                break\n\n            tree_a = start_tree if iteration % 2 == 0 else goal_tree\n            tree_b = goal_tree if iteration % 2 == 0 else start_tree\n\n            sample = sample_free()\n            nearest_node = nearest(tree_a, sample)\n            new_pos = steer(nearest_node.position, sample, self.step_size)\n            if in_obstacle(new_pos):\n                continue\n            if edge_in_obstacle(nearest_node.position, new_pos, resolution=max(self.step_size * 0.2, 0.2)):\n                continue\n\n            n_nodes = len(tree_a) + 1\n            gamma = 30.0\n            radius = gamma * ((math.log(max(n_nodes,2)) / n_nodes) ** (1/dim))\n            radius = max(radius, self.step_size)\n\n            neighbors = near(tree_a, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            min_parent = nearest_node\n            for nb in neighbors:\n                cost_candidate = nb.cost + dist(nb.position, new_pos)\n                if cost_candidate + 1e-9 < min_cost:\n                    if not edge_in_obstacle(nb.position, new_pos, resolution=max(self.step_size * 0.2, 0.2)):\n                        min_cost = cost_candidate\n                        min_parent = nb\n\n            new_node = Node(new_pos, parent=min_parent, cost=min_cost)\n            min_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((min_parent, new_node))\n\n            rewire(tree_a, new_node, neighbors)\n\n            conn_node, conn_cost = try_connect(new_node, tree_b)\n            if conn_node and conn_cost + 1e-9 < best_cost:\n                best_cost = conn_cost\n                best_connection = (new_node, conn_node) if iteration % 2 == 0 else (conn_node, new_node)\n                success = True\n                # Early stop on improvement\n                break\n\n            shortcut_counter += 1\n            if shortcut_counter >= shortcut_interval and success:\n                path_cur = extract_path(best_connection[0], best_connection[1])\n                path_short = shortcut_path(path_cur, max_attempts=20)\n                if len(path_short) < len(path_cur):\n                    extracted_path = path_short\n                    shortcut_counter = 0\n\n        if success and best_connection:\n            if not extracted_path:\n                extracted_path = extract_path(best_connection[0], best_connection[1])\n            extracted_path = shortcut_path(extracted_path, max_attempts=50)\n        else:\n            best_partial_cost = float('inf')\n            best_pair = None\n            search_radius = self.step_size * 3.0\n            for node_s in start_tree:\n                candidates = near(goal_tree, node_s.position, search_radius)\n                for node_g in candidates:\n                    d = dist(node_s.position, node_g.position)\n                    if d <= search_radius and not edge_in_obstacle(node_s.position, node_g.position, resolution=max(self.step_size * 0.2, 0.2)):\n                        total_c = node_s.cost + node_g.cost + d\n                        if total_c + 1e-9 < best_partial_cost:\n                            best_partial_cost = total_c\n                            best_pair = (node_s, node_g)\n            if best_pair:\n                success = True\n                extracted_path = extract_path(best_pair[0], best_pair[1])\n                extracted_path = shortcut_path(extracted_path, max_attempts=50)\n            else:\n                extracted_path = []\n\n        return PlannerResult(\n            success=success,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -32.97933,
          "time_improvement": 57.0,
          "length_improvement": 15.0,
          "smoothness_improvement": 1398.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.01585543155670166,
                    "num_nodes_avg": 124.0,
                    "path_length_avg": 166.83473196275344,
                    "smoothness_avg": 0.03680283544081307,
                    "success_improvement": 0.0,
                    "time_improvement": 37.168018684489496,
                    "length_improvement": 8.555239745710967,
                    "smoothness_improvement": 476.0442932850264,
                    "objective_score": 18.663770919198562
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.03920238018035889,
                    "num_nodes_avg": 284.6,
                    "path_length_avg": 237.48604655145664,
                    "smoothness_avg": 0.09819100572051757,
                    "success_improvement": 0.0,
                    "time_improvement": 76.08745857068688,
                    "length_improvement": 20.720322004287073,
                    "smoothness_improvement": 2426.525301311647,
                    "objective_score": 47.39105728033654
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.021207523345947266,
                    "num_nodes_avg": 192.2,
                    "path_length_avg": 127.10856004421139,
                    "smoothness_avg": 0.10928590980034451,
                    "success_improvement": 0.0,
                    "time_improvement": 56.94767313825165,
                    "length_improvement": 15.580546677837685,
                    "smoothness_improvement": 1290.1087060136226,
                    "objective_score": 32.88317347824622
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "cross_over",
          "algorithm_description": "This algorithm implements an efficient bidirectional RRT* planner enhanced with balanced goal bias and adaptive informed sampling, a dynamic rewiring radius based on tree size and dimension, and integrated online path shortcutting to reduce path length and improve smoothness. It alternately grows trees from start and goal positions, using efficient nearest neighbor searches and collision checks with adaptive resolution. When a connection between trees is found, it updates the best path and continues to refine connections and rewiring until the 30-second hard time limit is reached, returning the best feasible path found so far.",
          "planning_mechanism": "The planner alternately expands two trees with goal-biased sampling prior to an initial solution and then uses informed ellipsoid sampling to focus on improving the existing path. Each new sample is connected optimally by choosing the parent minimizing cost within a dynamically calculated neighborhood radius, and rewiring applies to neighbor nodes for local cost improvement. Connection attempts between the two trees update the best path and enable incremental shortcutting to reduce detours, improving path length and smoothness. The process is time-limited and returns as soon as the best valid path under the constraints is identified.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position    # Tuple[float, ...]\n        self.parent = parent        # Node or None\n        self.cost = cost            # Cost from root to this node\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=5.0, goal_sample_rate=0.15):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.time_limit = 30.0\n\n    def plan(self, map):\n        import time\n        import math\n        import random\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        start_tree = [Node(start_pos, cost=0.0)]\n        goal_tree = [Node(goal_pos, cost=0.0)]\n        nodes = start_tree[:] + goal_tree[:]\n        edges = []\n\n        best_connection = None\n        best_cost = float('inf')\n        success = False\n        best_path = []\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def squared_dist(a, b):\n            return sum((a[i] - b[i]) ** 2 for i in range(dim))\n\n        def sample_free():\n            # Biased sampling: before solution, goal bias; after solution, ellipsoidal informed\n            if not success and random.random() < self.goal_sample_rate:\n                # Direct sample to goal to bias tree growth\n                return goal_pos\n            if not success:\n                # Uniform random sampling within bounds and free space\n                for _ in range(30):\n                    sample = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                    if not self._is_in_obstacle(sample, obstacles, is_3d):\n                        return sample\n                return start_pos  # fallback\n\n            # Informed ellipsoidal sampling focused on cost reduction\n            c_best = best_cost\n            c_min = dist(start_pos, goal_pos)\n            if c_best < float('inf'):\n                c_best = max(c_best, c_min)\n            else:\n                c_best = c_min * 1.5\n\n            center = tuple((start_pos[i] + goal_pos[i]) * 0.5 for i in range(dim))\n            e1 = tuple((goal_pos[i] - start_pos[i]) / c_min if c_min > 1e-10 else 0 for i in range(dim))\n\n            # Orthonormal basis (U) construction\n            def normalize(v):\n                norm = math.sqrt(sum(x * x for x in v))\n                if norm < 1e-10:\n                    return tuple(0.0 for _ in v)\n                return tuple(x / norm for x in v)\n\n            def cross_vec(u, v):\n                return (u[1]*v[2] - u[2]*v[1],\n                        u[2]*v[0] - u[0]*v[2],\n                        u[0]*v[1] - u[1]*v[0])\n\n            if dim == 2:\n                norm_e1 = math.sqrt(e1[0]*e1[0] + e1[1]*e1[1])\n                if norm_e1 < 1e-10:\n                    U = [(1,0), (0,1)]\n                else:\n                    e1n = (e1[0]/norm_e1, e1[1]/norm_e1)\n                    U = [e1n, (-e1n[1], e1n[0])]  # perpendicular in 2D\n            elif dim == 3:\n                e1n = normalize(e1)\n                # choose arbitrary vector not parallel to e1n\n                tmp = (1,0,0)\n                dot = sum(e1n[i]*tmp[i] for i in range(3))\n                if abs(dot) > 0.9:\n                    tmp = (0,1,0)\n                e2 = cross_vec(e1n, tmp)\n                e2 = normalize(e2)\n                e3 = cross_vec(e1n, e2)\n                U = [e1n, e2, e3]\n            else:\n                # fallback identity basis of size dim if needed\n                U = [tuple(1 if i==j else 0 for i in range(dim)) for j in range(dim)]\n\n            # Ellipsoid radii\n            a = c_best / 2.0\n            b = math.sqrt(max(c_best**2 - c_min**2, 0)) / 2.0\n\n            for _ in range(100):\n                if dim == 2:\n                    # sample in unit circle for 2D\n                    while True:\n                        x_ball = (random.uniform(-1,1), random.uniform(-1,1))\n                        if x_ball[0]*x_ball[0] + x_ball[1]*x_ball[1] <= 1:\n                            break\n                    sample = (\n                        center[0] + a*U[0][0]*x_ball[0] + b*U[1][0]*x_ball[1],\n                        center[1] + a*U[0][1]*x_ball[0] + b*U[1][1]*x_ball[1]\n                    )\n                elif dim == 3:\n                    while True:\n                        x_ball = (random.uniform(-1,1), random.uniform(-1,1), random.uniform(-1,1))\n                        norm_x = math.sqrt(sum(x*x for x in x_ball))\n                        if norm_x <= 1 and norm_x > 1e-10:\n                            x_ball = tuple(x / norm_x for x in x_ball)\n                            break\n                    sample = (\n                        center[0] + a*U[0][0]*x_ball[0] + b*U[1][0]*x_ball[1] + b*U[2][0]*x_ball[2],\n                        center[1] + a*U[0][1]*x_ball[0] + b*U[1][1]*x_ball[1] + b*U[2][1]*x_ball[2],\n                        center[2] + a*U[0][2]*x_ball[0] + b*U[1][2]*x_ball[1] + b*U[2][2]*x_ball[2]\n                    )\n                else:\n                    # fallback random sample in bounds\n                    sample = tuple(random.uniform(0,bounds[i]) for i in range(dim))\n\n                if all(0 <= sample[i] <= bounds[i] for i in range(dim)):\n                    if not self._is_in_obstacle(sample, obstacles, is_3d):\n                        return sample\n\n            # fallback random\n            for _ in range(20):\n                sample = tuple(random.uniform(0,bounds[i]) for i in range(dim))\n                if not self._is_in_obstacle(sample, obstacles, is_3d):\n                    return sample\n            return start_pos\n\n        def nearest(tree, point):\n            best_node = None\n            best_dist = float('inf')\n            for node in tree:\n                d = dist(node.position, point)\n                if d < best_dist:\n                    best_node = node\n                    best_dist = d\n            return best_node\n\n        def near(tree, point, radius):\n            r2 = radius*radius\n            neighbors = []\n            for node in tree:\n                d2 = squared_dist(node.position, point)\n                if d2 <= r2:\n                    neighbors.append((d2, node))\n            neighbors.sort(key=lambda x: x[0])\n            return [n[1] for n in neighbors]\n\n        def steer(from_p, to_p, max_step):\n            d = dist(from_p, to_p)\n            if d <= max_step:\n                return to_p\n            ratio = max_step / d\n            return tuple(from_p[i] + ratio*(to_p[i]-from_p[i]) for i in range(dim))\n\n        def extract_path(node_start, node_goal):\n            path_s = []\n            n = node_start\n            while n is not None:\n                path_s.append(n.position)\n                n = n.parent\n            path_s.reverse()\n            path_g = []\n            n = node_goal\n            while n is not None:\n                path_g.append(n.position)\n                n = n.parent\n            return path_s + path_g\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            for _ in range(100):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path)-3)\n                j = random.randint(i+2, len(path)-1)\n                p1 = path[i]\n                p2 = path[j]\n                if not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution=self.step_size/5):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        def try_connect_nodes(node, other_tree, radius):\n            candidates = near(other_tree, node.position, radius)\n            best_cnode = None\n            best_cost = float('inf')\n            for c in candidates:\n                dist_edge = dist(node.position, c.position)\n                if dist_edge <= radius and not self._is_edge_in_obstacle(node.position, c.position, obstacles, is_3d, resolution=self.step_size/5):\n                    total_cost = node.cost + dist_edge + c.cost\n                    if total_cost < best_cost:\n                        best_cost = total_cost\n                        best_cnode = c\n            return best_cnode, best_cost\n\n        start_time = time.monotonic()\n        gamma_rrt_star = 20.0\n\n        for it in range(self.max_iter):\n            if time.monotonic() - start_time > self.time_limit:\n                break\n\n            # Alternate tree growth [0\u2192start,1\u2192goal]\n            tree_primary = start_tree if it % 2 == 0 else goal_tree\n            tree_secondary = goal_tree if it % 2 == 0 else start_tree\n\n            sample = sample_free()\n            nearest_node = nearest(tree_primary, sample)\n            new_pos = steer(nearest_node.position, sample, self.step_size)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n\n            edge_check_res = max(0.2, self.step_size/5)\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d, resolution=edge_check_res):\n                continue\n\n            n_nodes = len(tree_primary) + 1\n            radius = min(self.step_size * 5.0,\n                         gamma_rrt_star * ((math.log(max(n_nodes,2)) / n_nodes) ** (1.0/dim)))\n\n            near_nodes = near(tree_primary, new_pos, radius)\n\n            # Choose the best parent for new node minimizing cost\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            min_parent = nearest_node\n            for near_node in near_nodes:\n                c_through = near_node.cost + dist(near_node.position, new_pos)\n                if c_through < min_cost:\n                    if not self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d, resolution=edge_check_res):\n                        min_cost = c_through\n                        min_parent = near_node\n\n            new_node = Node(new_pos, parent=min_parent, cost=min_cost)\n            min_parent.add_child(new_node)\n            tree_primary.append(new_node)\n            nodes.append(new_node)\n            edges.append((min_parent, new_node))\n\n            # Rewire neighbors if beneficial\n            for near_node in near_nodes:\n                if near_node == min_parent:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, near_node.position)\n                if new_cost + 1e-10 < near_node.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d, resolution=edge_check_res):\n                        # Update connections\n                        if near_node.parent:\n                            try:\n                                edges.remove((near_node.parent, near_node))\n                            except Exception:\n                                pass\n                            near_node.parent.remove_child(near_node)\n                        near_node.parent = new_node\n                        near_node.cost = new_cost\n                        new_node.add_child(near_node)\n                        edges.append((new_node, near_node))\n\n            # Try to connect to the other tree within connection radius\n            connect_radius = self.step_size * 3.5\n            conn_node, conn_cost = try_connect_nodes(new_node, tree_secondary, connect_radius)\n            if conn_node and conn_cost < best_cost:\n                best_cost = conn_cost\n                best_connection = (new_node, conn_node)\n                success = True\n                # Early exit with improved path found\n                break\n\n            # Periodic incremental shortcutting to improve path quality\n            if success and it % 150 == 0 and best_connection is not None:\n                path_tmp = extract_path(best_connection[0], best_connection[1])\n                improved = shortcut_path(path_tmp)\n                length_improved = sum(dist(improved[i], improved[i+1]) for i in range(len(improved)-1))\n                if length_improved + 1e-10 < best_cost:\n                    best_cost = length_improved\n                    best_path = improved\n                else:\n                    best_path = path_tmp\n\n        # Final extraction and shortcutting of best path\n        if success and best_connection:\n            if not best_path:\n                best_path = extract_path(best_connection[0], best_connection[1])\n            best_path = shortcut_path(best_path)\n        else:\n            # No connection found: fallback try to find best cross-tree pairs\n            min_total = float('inf')\n            best_pair = None\n            for ns in start_tree:\n                near_goals = near(goal_tree, ns.position, self.step_size * 3.5)\n                for ng in near_goals:\n                    dist_sep = dist(ns.position, ng.position)\n                    if dist_sep <= self.step_size * 3.5:\n                        if not self._is_edge_in_obstacle(ns.position, ng.position, obstacles, is_3d, resolution=self.step_size/5):\n                            total_c = ns.cost + ng.cost + dist_sep\n                            if total_c < min_total:\n                                min_total = total_c\n                                best_pair = (ns, ng)\n            if best_pair:\n                best_path = extract_path(best_pair[0], best_pair[1])\n                best_path = shortcut_path(best_path)\n                success = True\n                best_cost = min_total\n\n        return PlannerResult(\n            success=success,\n            path=best_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -32.84905,
          "time_improvement": 59.0,
          "length_improvement": 13.0,
          "smoothness_improvement": 1490.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.014084696769714355,
                    "num_nodes_avg": 108.4,
                    "path_length_avg": 172.32621392249897,
                    "smoothness_avg": 0.03581197820480585,
                    "success_improvement": 0.0,
                    "time_improvement": 44.18509511365075,
                    "length_improvement": 5.545271465474247,
                    "smoothness_improvement": 460.53522586058654,
                    "objective_score": 18.885367542682708
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.05784697532653808,
                    "num_nodes_avg": 342.1,
                    "path_length_avg": 240.78053289684686,
                    "smoothness_avg": 0.10631135801169111,
                    "success_improvement": 0.0,
                    "time_improvement": 64.71468855482048,
                    "length_improvement": 19.620527635664164,
                    "smoothness_improvement": 2635.4678146168853,
                    "objective_score": 44.364062220929064
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.016234874725341797,
                    "num_nodes_avg": 151.7,
                    "path_length_avg": 129.71704705575976,
                    "smoothness_avg": 0.11597769108558495,
                    "success_improvement": 0.0,
                    "time_improvement": 67.04239708553614,
                    "length_improvement": 13.848113807570869,
                    "smoothness_improvement": 1375.2276700259663,
                    "objective_score": 35.29772576033319
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "This simplified bidirectional RRT* planner balances efficiency and path quality by adaptively adjusting the rewiring radius based on current tree size and dimension, incorporating a fixed goal bias for faster convergence, alternating expansions between start and goal trees, and applying incremental shortcutting during planning and post-processing. It enforces a strict 30-second time limit with early stopping upon finding improved paths. The planner includes thorough collision checks on samples and edges, maintains coherent parent-child relations and path costs, and returns the best path found so far.",
          "planning_mechanism": "The planner alternately grows two trees from start and goal, samples random points with goal bias, steers towards samples within a fixed step size respecting collision constraints, rewires nearby nodes within adaptively computed radius to optimize paths, tries multiple connections between trees each iteration, incrementally shortcuts the current best path at fixed intervals for smoother and shorter paths, and halts if time limit is exceeded or a sufficiently good path is found.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.time_limit = 30.0\n        self.goal_sample_rate = 0.15  # probability to sample goal\n\n    def plan(self, map) -> 'PlannerResult':\n        import time\n        import math\n        import random\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def sample_free():\n            if random.random() < self.goal_sample_rate:\n                return goal_pos\n            for _ in range(100):\n                p = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n            return goal_pos\n\n        def nearest(tree, point):\n            best_node = None\n            best_d = float('inf')\n            for node in tree:\n                d = dist(node.position, point)\n                if d < best_d:\n                    best_node = node\n                    best_d = d\n            return best_node\n\n        def near(tree, point, radius):\n            result = [node for node in tree if dist(node.position, point) <= radius]\n            return result\n\n        def steer(from_p, to_p, max_step):\n            d = dist(from_p, to_p)\n            if d <= max_step:\n                return to_p\n            ratio = max_step / d\n            return tuple(from_p[i] + (to_p[i] - from_p[i]) * ratio for i in range(dim))\n\n        def extract_path(node_start, node_goal):\n            path_start = []\n            cur = node_start\n            while cur:\n                path_start.append(cur.position)\n                cur = cur.parent\n            path_start.reverse()\n            path_goal = []\n            cur = node_goal\n            while cur:\n                path_goal.append(cur.position)\n                cur = cur.parent\n            if path_goal and path_start and path_start[-1] == path_goal[0]:\n                path_goal = path_goal[1:]\n            return path_start + path_goal\n\n        def shortcut_path(path, max_attempts=30):\n            if len(path) < 3:\n                return path\n            for _ in range(max_attempts):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution=max(self.step_size * 0.2, 0.2)):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        def try_connect(new_node, other_tree):\n            radius = self.step_size * 2.5\n            candidates = near(other_tree, new_node.position, radius)\n            best_cand = None\n            best_cost = float('inf')\n            for node in candidates:\n                d12 = dist(new_node.position, node.position)\n                if d12 <= radius and not self._is_edge_in_obstacle(new_node.position, node.position, obstacles, is_3d, resolution=max(self.step_size * 0.2, 0.2)):\n                    cost = new_node.cost + d12 + node.cost\n                    if cost < best_cost:\n                        best_cost = cost\n                        best_cand = node\n            return best_cand, best_cost\n\n        def rewire(tree, new_node, neighbors):\n            for nbr in neighbors:\n                if nbr is new_node.parent:\n                    continue\n                cost_through = new_node.cost + dist(new_node.position, nbr.position)\n                if cost_through + 1e-9 < nbr.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, nbr.position, obstacles, is_3d, resolution=max(self.step_size * 0.2, 0.2)):\n                        if nbr.parent:\n                            try:\n                                edges.remove((nbr.parent, nbr))\n                            except Exception:\n                                pass\n                            nbr.parent.remove_child(nbr)\n                        nbr.parent = new_node\n                        nbr.cost = cost_through\n                        new_node.add_child(nbr)\n                        edges.append((new_node, nbr))\n\n        start_tree = [Node(start_pos, cost=0.0)]\n        goal_tree = [Node(goal_pos, cost=0.0)]\n        nodes = start_tree[:] + goal_tree[:]\n        edges = []\n\n        best_connection = None\n        best_cost = float('inf')\n        success = False\n        extracted_path = []\n\n        gamma = 35.0  # radius multiplier for rewiring per RRT* theory\n\n        start_time = time.monotonic()\n        shortcut_counter = 0\n        shortcut_interval = 60\n\n        for it in range(self.max_iter):\n            if time.monotonic() - start_time > self.time_limit:\n                break\n\n            tree_a = start_tree if it % 2 == 0 else goal_tree\n            tree_b = goal_tree if it % 2 == 0 else start_tree\n\n            sample = sample_free()\n            nearest_node = nearest(tree_a, sample)\n            new_pos = steer(nearest_node.position, sample, self.step_size)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d, resolution=max(self.step_size * 0.2, 0.2)):\n                continue\n\n            n_nodes = len(tree_a) + 1\n            radius = gamma * ((math.log(n_nodes) / n_nodes) ** (1 / dim)) if n_nodes > 1 else self.step_size * 5\n            radius = min(max(radius, self.step_size), self.step_size * 5)\n\n            neighbors = near(tree_a, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            min_parent = nearest_node\n            for nb in neighbors:\n                cost_cand = nb.cost + dist(nb.position, new_pos)\n                if cost_cand + 1e-9 < min_cost:\n                    if not self._is_edge_in_obstacle(nb.position, new_pos, obstacles, is_3d, resolution=max(self.step_size * 0.2, 0.2)):\n                        min_cost = cost_cand\n                        min_parent = nb\n\n            new_node = Node(new_pos, parent=min_parent, cost=min_cost)\n            min_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((min_parent, new_node))\n\n            rewire(tree_a, new_node, neighbors)\n\n            conn_node, conn_cost = try_connect(new_node, tree_b)\n            if conn_node is not None and conn_cost + 1e-9 < best_cost:\n                best_cost = conn_cost\n                best_connection = (new_node, conn_node) if it % 2 == 0 else (conn_node, new_node)\n                success = True\n                # Early break on better path found\n                break\n\n            shortcut_counter += 1\n            if shortcut_counter >= shortcut_interval and success:\n                path_cur = extract_path(best_connection[0], best_connection[1])\n                path_short = shortcut_path(path_cur, max_attempts=20)\n                if len(path_short) < len(path_cur):\n                    extracted_path = path_short\n                shortcut_counter = 0\n\n        if success and best_connection is not None:\n            extracted_path = extract_path(best_connection[0], best_connection[1])\n            extracted_path = shortcut_path(extracted_path, max_attempts=50)\n        elif not success:\n            # Attempt best partial connection\n            best_partial_cost = float('inf')\n            best_pair = None\n            search_radius = self.step_size * 3.0\n            for n1 in start_tree:\n                candidates = near(goal_tree, n1.position, search_radius)\n                for n2 in candidates:\n                    d12 = dist(n1.position, n2.position)\n                    if d12 <= search_radius:\n                        if not self._is_edge_in_obstacle(n1.position, n2.position, obstacles, is_3d, resolution=max(self.step_size * 0.2, 0.2)):\n                            cost_sum = n1.cost + n2.cost + d12\n                            if cost_sum + 1e-9 < best_partial_cost:\n                                best_partial_cost = cost_sum\n                                best_pair = (n1, n2)\n            if best_pair:\n                success = True\n                extracted_path = extract_path(best_pair[0], best_pair[1])\n                extracted_path = shortcut_path(extracted_path, max_attempts=50)\n\n        return PlannerResult(\n            success=success,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -32.76205,
          "time_improvement": 61.0,
          "length_improvement": 15.0,
          "smoothness_improvement": 1123.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.016430091857910157,
                    "num_nodes_avg": 163.0,
                    "path_length_avg": 172.81089589460353,
                    "smoothness_avg": 0.03468492508654275,
                    "success_improvement": 0.0,
                    "time_improvement": 34.890752046922856,
                    "length_improvement": 5.279609596286402,
                    "smoothness_improvement": 442.89439712475024,
                    "objective_score": 15.849463357472448
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.02345263957977295,
                    "num_nodes_avg": 309.0,
                    "path_length_avg": 239.40253195439405,
                    "smoothness_avg": 0.07112925701302283,
                    "success_improvement": 0.0,
                    "time_improvement": 85.69443454713888,
                    "length_improvement": 20.080544013812837,
                    "smoothness_improvement": 1730.2070152780775,
                    "objective_score": 46.40769184881975
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.01798379421234131,
                    "num_nodes_avg": 259.3,
                    "path_length_avg": 122.94666122879876,
                    "smoothness_avg": 0.1018023317720868,
                    "success_improvement": 0.0,
                    "time_improvement": 63.49200356805957,
                    "length_improvement": 18.344681702709988,
                    "smoothness_improvement": 1194.9181458744551,
                    "objective_score": 36.02900082141614
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "cross_over",
          "algorithm_description": "A bidirectional RRT* planner with adaptive dynamic radius, goal-bias enhanced sampling, multi-candidate tree connection evaluation, and incremental path shortcutting to minimize path length and planning time under a strict 30-second time limit. The algorithm grows two trees alternately from start and goal, steering towards samples with fixed step sizes while rewiring nearby nodes within a shrinking adaptive radius. Connections between trees are attempted with multiple candidates to find early lower-cost paths. Periodic incremental shortcutting refines path smoothness and length. The best path is returned immediately if found or upon timeout with up-to-date best solution.",
          "planning_mechanism": "The planner alternates expansions between start and goal trees using goal-biased random samples. It steers nearest nodes towards samples and locally rewires neighbors based on cost and collision checks within an adaptive radius that shrinks with tree size. Multiple candidate connections between the two trees are evaluated each iteration to select the best connection for early stopping. Incremental shortcutting is performed periodically on the best path to improve smoothness and reduce unnecessary detours. Collision detection is enforced for both nodes and edges with adaptive resolution. Planning halts after 30 seconds or max iterations returning the best path found.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position  # Tuple of floats (2D or 3D)\n        self.parent = parent      # Parent Node or None\n        self.cost = cost          # Cost-to-come from root\n        self.children = []\n        self.valid = True         # For collision checks etc.\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\nclass Planner:\n    def __init__(self, max_iter: int = 6000, step_size: float = 4.5, goal_sample_rate: float = 0.20):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.time_limit = 30.0  # Hard time limit in seconds\n\n    def plan(self, map):\n        import time\n        import math\n        import random\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = dim == 3\n\n        gamma_rrt_star = 30.0  # Coefficient for adaptive radius\n\n        start_tree = [Node(start_pos, cost=0.0)]\n        goal_tree = [Node(goal_pos, cost=0.0)]\n        nodes = start_tree[:] + goal_tree[:]\n        edges = []\n\n        best_connection = None\n        best_cost = float('inf')\n        success = False\n\n        start_time = time.monotonic()\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def sample_free():\n            # Goal bias sampling with retry capped\n            if random.random() < self.goal_sample_rate:\n                return goal_pos\n            for _ in range(30):\n                sample = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not self._is_in_obstacle(sample, obstacles, is_3d):\n                    return sample\n            return goal_pos  # fallback if no free found\n\n        def nearest(tree, point):\n            best_node = None\n            best_dist = float('inf')\n            for node in tree:\n                d = dist(node.position, point)\n                if d < best_dist:\n                    best_node = node\n                    best_dist = d\n            return best_node\n\n        def near(tree, point, radius):\n            radius_sq = radius * radius\n            neighbors = []\n            for node in tree:\n                sqdist = 0.0\n                for i in range(dim):\n                    diff = node.position[i] - point[i]\n                    sqdist += diff * diff\n                    if sqdist > radius_sq:\n                        break\n                if sqdist <= radius_sq:\n                    neighbors.append((sqdist, node))\n            neighbors.sort(key=lambda x: x[0])\n            return [nd[1] for nd in neighbors]\n\n        def steer(from_p, to_p, max_step):\n            d = dist(from_p, to_p)\n            if d <= max_step:\n                return to_p\n            ratio = max_step / d\n            return tuple(from_p[i] + (to_p[i] - from_p[i]) * ratio for i in range(dim))\n\n        def extract_path(node_start, node_goal):\n            path_start = []\n            cur = node_start\n            while cur is not None:\n                path_start.append(cur.position)\n                cur = cur.parent\n            path_goal = []\n            cur = node_goal\n            while cur is not None:\n                path_goal.append(cur.position)\n                cur = cur.parent\n            return path_start[::-1] + path_goal\n\n        def shortcut_path(path):\n            max_attempts = 80\n            if len(path) < 3:\n                return path\n            for _ in range(max_attempts):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        def try_connect(node, other_tree, radius):\n            candidates = near(other_tree, node.position, radius)\n            best_node = None\n            best_cost_local = float('inf')\n            for cnode in candidates:\n                d = dist(node.position, cnode.position)\n                if d <= radius and not self._is_edge_in_obstacle(node.position, cnode.position, obstacles, is_3d):\n                    total_cost = node.cost + cnode.cost + d\n                    if total_cost < best_cost_local:\n                        best_cost_local = total_cost\n                        best_node = cnode\n            return best_node, best_cost_local\n\n        extracted_path = []\n        found_improvement = False\n\n        for it in range(self.max_iter):\n            current_time = time.monotonic()\n            if current_time - start_time > self.time_limit:\n                break\n\n            # Alternate expansions between start and goal trees\n            if it % 2 == 0:\n                tree_a, tree_b = start_tree, goal_tree\n            else:\n                tree_a, tree_b = goal_tree, start_tree\n\n            sample = sample_free()\n            nearest_node = nearest(tree_a, sample)\n            new_pos = steer(nearest_node.position, sample, self.step_size)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            n_nodes = len(tree_a) + 1\n            radius = min(self.step_size * 4.5, gamma_rrt_star * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim)))\n\n            near_nodes = near(tree_a, new_pos, radius)\n\n            # Identify best parent with lowest cost + collision-free edge\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            min_parent = nearest_node\n            for near_node in near_nodes:\n                cost_through = near_node.cost + dist(near_node.position, new_pos)\n                if cost_through < min_cost and not self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d):\n                    min_cost = cost_through\n                    min_parent = near_node\n\n            new_node = Node(new_pos, parent=min_parent, cost=min_cost)\n            min_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((min_parent, new_node))\n\n            # Rewire nearby nodes if cheaper via new_node without collisions\n            for near_node in near_nodes:\n                if near_node is min_parent:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, near_node.position)\n                if new_cost < near_node.cost and not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                    if near_node.parent:\n                        try:\n                            edges.remove((near_node.parent, near_node))\n                        except ValueError:\n                            pass\n                        near_node.parent.remove_child(near_node)\n                    near_node.parent = new_node\n                    near_node.cost = new_cost\n                    new_node.add_child(near_node)\n                    edges.append((new_node, near_node))\n\n            # Attempt multiple candidate connections to other tree for best cost\n            connect_radius = self.step_size * 3.2\n            conn_node, conn_cost = try_connect(new_node, tree_b, connect_radius)\n            if conn_node is not None and conn_cost < best_cost:\n                best_cost = conn_cost\n                best_connection = (new_node, conn_node)\n                success = True\n                found_improvement = True\n                # Early termination on improvement\n                break\n\n            # Periodic incremental shortcutting to improve path quality\n            if found_improvement and (it % 120 == 0) and best_connection is not None:\n                path = extract_path(best_connection[0], best_connection[1])\n                shortcut = shortcut_path(path)\n                shortcut_len = sum(dist(shortcut[i], shortcut[i + 1]) for i in range(len(shortcut) - 1))\n                if shortcut_len + 1e-5 < best_cost:\n                    best_cost = shortcut_len\n                    extracted_path = shortcut\n                else:\n                    extracted_path = path\n\n        # Finalize path extraction or fallback if no direct connection found\n        if success and best_connection is not None:\n            path = extract_path(best_connection[0], best_connection[1])\n            extracted_path = shortcut_path(path)\n        else:\n            # Attempt best partial connection between trees within connect radius\n            best_pair = None\n            min_total_cost = float('inf')\n            for n1 in start_tree:\n                near_goal_candidates = near(goal_tree, n1.position, self.step_size * 3.2)\n                for n2 in near_goal_candidates:\n                    d12 = dist(n1.position, n2.position)\n                    if d12 <= self.step_size * 3.2 and not self._is_edge_in_obstacle(n1.position, n2.position, obstacles, is_3d):\n                        total_c = n1.cost + n2.cost + d12\n                        if total_c < min_total_cost:\n                            min_total_cost = total_c\n                            best_pair = (n1, n2)\n            if best_pair:\n                path = extract_path(best_pair[0], best_pair[1])\n                extracted_path = shortcut_path(path)\n                success = True\n            else:\n                extracted_path = []\n\n        return PlannerResult(\n            success=success,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -32.14549,
          "time_improvement": 55.0,
          "length_improvement": 15.0,
          "smoothness_improvement": 1352.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.01823000907897949,
                    "num_nodes_avg": 159.3,
                    "path_length_avg": 166.68606489804506,
                    "smoothness_avg": 0.03600692626925854,
                    "success_improvement": 0.0,
                    "time_improvement": 27.758031325997862,
                    "length_improvement": 8.636726519658023,
                    "smoothness_improvement": 463.58658640576886,
                    "objective_score": 15.827378241623018
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.032488322257995604,
                    "num_nodes_avg": 326.8,
                    "path_length_avg": 235.21169916755744,
                    "smoothness_avg": 0.08933891125866616,
                    "success_improvement": 0.0,
                    "time_improvement": 80.18287796840391,
                    "length_improvement": 21.47956462449235,
                    "smoothness_improvement": 2198.7545349022857,
                    "objective_score": 47.93637483972802
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.02102477550506592,
                    "num_nodes_avg": 251.2,
                    "path_length_avg": 129.2318232365425,
                    "smoothness_avg": 0.11753050832113565,
                    "success_improvement": 0.0,
                    "time_improvement": 57.31866034173415,
                    "length_improvement": 14.170376364419635,
                    "smoothness_improvement": 1394.9793906451255,
                    "objective_score": 32.672720874397655
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "A streamlined bidirectional RRT* planner that grows two trees from start and goal by alternating expansions. It samples points biased toward the goal, extends trees with fixed step size, omits rewiring for simplicity, and attempts connection between trees within a radius. The planner stops upon first valid connection or when the 30-second limit is reached, then performs final shortcutting on the path to improve quality.",
          "planning_mechanism": "The planner maintains two trees and iteratively samples free points with goal bias, extending the nearest node toward each sample. It connects the trees when nodes from opposite trees are within a threshold and the connecting edge is obstacle-free. The path is extracted from linked nodes and shortcut to reduce length and improve smoothness before returning. Timing checks enforce a hard stop with the best found path.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\nclass Planner:\n    def __init__(self, max_iter: int=5000, step_size: float=5.0, goal_sample_rate: float=0.1):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.time_limit = 30.0\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def sample_free():\n            if random.random() < self.goal_sample_rate and not self._is_in_obstacle(goal_pos, obstacles, is_3d):\n                return goal_pos\n            for _ in range(30):\n                p = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n            return goal_pos\n\n        def steer(source, target, max_step):\n            d = dist(source, target)\n            if d <= max_step:\n                return target\n            ratio = max_step / d\n            return tuple(source[i] + ratio * (target[i] - source[i]) for i in range(dim))\n\n        def nearest(tree, point):\n            best_node = None\n            best_dist2 = float('inf')\n            for node in tree:\n                d2 = sum((node.position[i] - point[i])**2 for i in range(dim))\n                if d2 < best_dist2:\n                    best_dist2 = d2\n                    best_node = node\n            return best_node\n\n        def extract_path(node_start, node_goal):\n            path1 = []\n            cur = node_start\n            while cur:\n                path1.append(cur.position)\n                cur = cur.parent\n            path1.reverse()\n            path2 = []\n            cur = node_goal\n            while cur:\n                path2.append(cur.position)\n                cur = cur.parent\n            if path1[-1] == path2[0]:\n                path2 = path2[1:]\n            return path1 + path2\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            max_attempts = 100\n            attempts = 0\n            resolution = max(0.2, self.step_size * 0.2)\n            while attempts < max_attempts and len(path) >= 3:\n                i = random.randint(0, len(path)-3)\n                j = random.randint(i+2, len(path)-1)\n                if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d, resolution):\n                    path = path[:i+1] + path[j:]\n                attempts += 1\n            return path\n\n        # Initialize trees\n        start_tree = [Node(start_pos, cost=0.0)]\n        goal_tree = [Node(goal_pos, cost=0.0)]\n        all_nodes = start_tree[:] + goal_tree[:]\n        edges = []\n\n        connect_radius = self.step_size * 3.0\n        best_connection = None\n        success = False\n        start_time = time.monotonic()\n\n        for i in range(self.max_iter):\n            if time.monotonic() - start_time > self.time_limit:\n                break\n\n            tree_a, tree_b = (start_tree, goal_tree) if i % 2 == 0 else (goal_tree, start_tree)\n\n            rnd_point = sample_free()\n            nearest_node = nearest(tree_a, rnd_point)\n            new_pos = steer(nearest_node.position, rnd_point, self.step_size)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            new_node = Node(new_pos, parent=nearest_node, cost=nearest_node.cost + dist(nearest_node.position, new_pos))\n            nearest_node.add_child(new_node)\n            tree_a.append(new_node)\n            all_nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n\n            # Try to connect the other tree\n            for other_node in tree_b:\n                if dist(new_node.position, other_node.position) <= connect_radius:\n                    if not self._is_edge_in_obstacle(new_node.position, other_node.position, obstacles, is_3d):\n                        best_connection = (new_node, other_node) if i % 2 == 0 else (other_node, new_node)\n                        success = True\n                        break\n            if success:\n                break\n\n        if success and best_connection:\n            path = extract_path(best_connection[0], best_connection[1])\n            path = shortcut_path(path)\n        else:\n            # No connection found, return best partial path (closest nodes)\n            best_pair = None\n            best_dist = float('inf')\n            for n1 in start_tree:\n                for n2 in goal_tree:\n                    d = dist(n1.position, n2.position)\n                    if d < best_dist and not self._is_edge_in_obstacle(n1.position, n2.position, obstacles, is_3d):\n                        best_dist = d\n                        best_pair = (n1, n2)\n            if best_pair:\n                path = extract_path(best_pair[0], best_pair[1])\n                path = shortcut_path(path)\n                success = True\n            else:\n                path = []\n\n        return PlannerResult(success=success, path=path, nodes=all_nodes, edges=edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x,y,z,w,h,d = obs\n                px,py,pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x,y,w,h = obs\n                px,py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        dist_ = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist_ / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * i / steps for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -31.8201,
          "time_improvement": 56.0,
          "length_improvement": 13.0,
          "smoothness_improvement": 1459.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.01702723503112793,
                    "num_nodes_avg": 138.1,
                    "path_length_avg": 172.81109872520534,
                    "smoothness_avg": 0.03629004994249553,
                    "success_improvement": 0.0,
                    "time_improvement": 32.52439017477028,
                    "length_improvement": 5.279498421619495,
                    "smoothness_improvement": 468.01808670482467,
                    "objective_score": 15.265106538926904
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.046280741691589355,
                    "num_nodes_avg": 325.4,
                    "path_length_avg": 243.72635504631822,
                    "smoothness_avg": 0.0923722647338338,
                    "success_improvement": 0.0,
                    "time_improvement": 71.76982244476213,
                    "length_improvement": 18.637127411381407,
                    "smoothness_improvement": 2276.8049046545448,
                    "objective_score": 44.097247703530215
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.017569994926452635,
                    "num_nodes_avg": 193.7,
                    "path_length_avg": 128.8815652689511,
                    "smoothness_avg": 0.13611001513807486,
                    "success_improvement": 0.0,
                    "time_improvement": 64.33203669312704,
                    "length_improvement": 14.40300102900173,
                    "smoothness_improvement": 1631.309345960053,
                    "objective_score": 36.09795835513941
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "time_expert",
          "algorithm_description": "This algorithm is a bidirectional RRT* planner enhanced with goal-biased sampling, adaptive rewiring radius that dynamically shrinks based on the number of nodes and problem dimension, and multiple connection attempts between trees within an adaptive connection radius. It performs alternate tree expansions with incremental path shortcutting to smooth and shorten paths progressively during planning. Collision checking resolution is dynamically adjusted proportional to step size for efficiency. Early stopping is applied upon finding a valid path or when the 30-second time limit is reached, returning the best path found so far.",
          "planning_mechanism": "The planning alternates growing two RRT* trees from start and goal by sampling randomly with a goal bias, steering nearest nodes toward the samples using a fixed step size, rewiring neighbors within an adaptively computed radius to reduce cost, and attempting multiple candidate connections between trees within a scaled connection radius. It interleaves incremental shortcutting to smooth paths during planning and terminates early on success or timeout.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True  # can be used for lazy collision checking or pruning\n\n    def add_child(self, child):\n        self.children.append(child)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = 0.15  # 15% goal bias\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        # Initialize two trees: start_tree and goal_tree\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        all_nodes = start_tree[:] + goal_tree[:]\n        edges = []\n\n        success = False\n        best_cost = float('inf')\n        best_connection = None\n\n        start_time = time.monotonic()\n        TIME_LIMIT = 30.0\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def sample_free():\n            # Goal biased sampling\n            if random.random() < self.goal_sample_rate:\n                return goal_pos\n            else:\n                while True:\n                    p = tuple(random.uniform(0.0, bounds[i]) for i in range(dim))\n                    if not self._is_in_obstacle(p, obstacles, is_3d):\n                        return p\n\n        def nearest(tree: List[Node], point: Tuple[float, ...]) -> Node:\n            return min(tree, key=lambda n: dist(n.position, point))\n\n        def near(tree: List[Node], point: Tuple[float, ...], radius: float) -> List[Node]:\n            return [node for node in tree if dist(node.position, point) <= radius]\n\n        def steer(from_p: Tuple[float, ...], to_p: Tuple[float, ...], step: float) -> Tuple[float, ...]:\n            d = dist(from_p, to_p)\n            if d <= step:\n                return to_p\n            ratio = step / d\n            return tuple(from_p[i] + (to_p[i] - from_p[i]) * ratio for i in range(dim))\n\n        def extract_path(node_start: Node, node_goal: Node) -> List[Tuple[float, ...]]:\n            path_start = []\n            cur = node_start\n            while cur:\n                path_start.append(cur.position)\n                cur = cur.parent\n            path_goal = []\n            cur = node_goal\n            while cur:\n                path_goal.append(cur.position)\n                cur = cur.parent\n            return path_start[::-1] + path_goal\n\n        def shortcut_path(path: List[Tuple[float, ...]], max_attempts=15):\n            # Attempt to shortcut path by connecting random pairs directly if collision-free\n            for _ in range(max_attempts):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d, resolution=self.step_size/5):\n                    # Remove intermediate points between i and j\n                    del path[i+1:j]\n            return path\n\n        # Adaptive radius parameters\n        gamma_rrt_star = 25.0  # tuned constant for rewiring radius\n        min_radius = self.step_size  # minimum radius\n\n        def calc_rewire_radius(n):\n            if n <= 1:\n                return min_radius\n            return max(min_radius, gamma_rrt_star * (math.log(n) / n) ** (1.0 / dim))\n\n        def calc_connection_radius(n):\n            # Larger radius than rewiring to allow earlier connection attempts\n            return max(2 * min_radius, 2 * calc_rewire_radius(n))\n\n        def update_best_path(node_a: Node, node_b: Node):\n            nonlocal best_cost, best_connection, success\n            connect_dist = dist(node_a.position, node_b.position)\n            candidate_cost = node_a.cost + node_b.cost + connect_dist\n            if candidate_cost < best_cost:\n                best_cost = candidate_cost\n                best_connection = (node_a, node_b)\n                success = True\n\n        def incremental_shortcutting():\n            # If we have found a path, try to improve it incrementally\n            if not success or best_connection is None:\n                return\n            path = extract_path(best_connection[0], best_connection[1])\n            shortened = shortcut_path(path)\n            return shortened\n\n        for iter_count in range(self.max_iter):\n            if time.monotonic() - start_time > TIME_LIMIT:\n                break\n\n            # Alternate between trees (even-expands start_tree, odd-expands goal_tree)\n            if iter_count % 2 == 0:\n                tree_a = start_tree\n                tree_b = goal_tree\n            else:\n                tree_a = goal_tree\n                tree_b = start_tree\n\n            sample = sample_free()\n            nearest_node = nearest(tree_a, sample)\n            new_pos = steer(nearest_node.position, sample, self.step_size)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d, resolution=self.step_size/5):\n                continue\n\n            n = len(tree_a) + 1\n            radius = calc_rewire_radius(n)\n            near_nodes = near(tree_a, new_pos, radius)\n\n            # Choose parent minimizing cost + collision free\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            min_parent = nearest_node\n            for near_node in near_nodes:\n                tmp_cost = near_node.cost + dist(near_node.position, new_pos)\n                if tmp_cost < min_cost:\n                    if not self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d, resolution=self.step_size/5):\n                        min_cost = tmp_cost\n                        min_parent = near_node\n\n            new_node = Node(new_pos, parent=min_parent, cost=min_cost)\n            min_parent.add_child(new_node)\n            tree_a.append(new_node)\n            all_nodes.append(new_node)\n            edges.append((min_parent, new_node))\n\n            # Rewire nodes in radius\n            for near_node in near_nodes:\n                if near_node is min_parent:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, near_node.position)\n                if new_cost < near_node.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d, resolution=self.step_size/5):\n                        # Rewire\n                        if near_node.parent:\n                            try:\n                                edges.remove((near_node.parent, near_node))\n                            except ValueError:\n                                pass\n                            near_node.parent.children.remove(near_node)\n                        near_node.parent = new_node\n                        near_node.cost = new_cost\n                        new_node.add_child(near_node)\n                        edges.append((new_node, near_node))\n\n            # Attempt multiple connections to the other tree within connection radius\n            n_other = len(tree_b)\n            connection_radius = calc_connection_radius(n_other)\n            candidate_nodes = near(tree_b, new_node.position, connection_radius)\n\n            for other_node in candidate_nodes:\n                d = dist(new_node.position, other_node.position)\n                if d <= connection_radius:\n                    if not self._is_edge_in_obstacle(new_node.position, other_node.position, obstacles, is_3d, resolution=self.step_size/5):\n                        update_best_path(new_node, other_node)\n                        # Early stopping if found, break to speed up\n                        if success and best_cost < math.inf:\n                            break\n            if success and best_cost < math.inf:\n                # One may optionally continue to improve path or break; here we break for speed\n                break\n\n            # Incrementally improve best path if exists every 50 iterations\n            if iter_count % 50 == 0 and success:\n                new_path = incremental_shortcutting()\n                if new_path is not None:\n                    extracted_path = new_path\n\n        # After termination, extract best path or empty if none\n        if success and best_connection is not None:\n            extracted_path = extract_path(best_connection[0], best_connection[1])\n            # Do final shortcutting\n            extracted_path = shortcut_path(extracted_path, max_attempts=50)\n        else:\n            # Attempt to find best partial connection if no full connection found\n            min_cost_partial = float('inf')\n            partial_connect = None\n            for node_a in start_tree:\n                for node_b in near(goal_tree, node_a.position, self.step_size * 2):\n                    if not self._is_edge_in_obstacle(node_a.position, node_b.position, obstacles, is_3d, resolution=self.step_size/5):\n                        cost_sum = node_a.cost + node_b.cost + dist(node_a.position, node_b.position)\n                        if cost_sum < min_cost_partial:\n                            min_cost_partial = cost_sum\n                            partial_connect = (node_a, node_b)\n            if partial_connect:\n                extracted_path = extract_path(partial_connect[0], partial_connect[1])\n                extracted_path = shortcut_path(extracted_path, max_attempts=50)\n                success = True\n\n        return PlannerResult(\n            success=success,\n            path=extracted_path if success else [],\n            nodes=all_nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -31.47041,
          "time_improvement": 56.0,
          "length_improvement": 15.0,
          "smoothness_improvement": 1127.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.01355283260345459,
                    "num_nodes_avg": 153.1,
                    "path_length_avg": 162.63358009285122,
                    "smoothness_avg": 0.035107855865488743,
                    "success_improvement": 0.0,
                    "time_improvement": 46.29276901942333,
                    "length_improvement": 10.85795765711586,
                    "smoothness_improvement": 449.5141822241411,
                    "objective_score": 22.65017621121722
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.022315669059753417,
                    "num_nodes_avg": 306.7,
                    "path_length_avg": 244.89338594029292,
                    "smoothness_avg": 0.05961419260673036,
                    "success_improvement": 0.0,
                    "time_improvement": 86.38796015805312,
                    "length_improvement": 18.24753890785088,
                    "smoothness_improvement": 1433.916114138525,
                    "objective_score": 44.03449196281909
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.03161730766296387,
                    "num_nodes_avg": 310.6,
                    "path_length_avg": 126.73576785346297,
                    "smoothness_avg": 0.12555229832901488,
                    "success_improvement": 0.0,
                    "time_improvement": 35.81529338481174,
                    "length_improvement": 15.82813750047627,
                    "smoothness_improvement": 1497.0159674384024,
                    "objective_score": 27.726550352921294
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "A simplified bidirectional RRT* planner that grows two trees alternately from start and goal positions by sampling free space with goal bias, steering towards samples by fixed step size, and rewiring neighbors within an adaptively shrinking radius to improve path cost progressively. The planner attempts to connect both trees repeatedly and performs periodic path shortcutting to smooth the path, all under a strict 30-second time limit to ensure efficiency. Collision checks for nodes and edges enforce safety, and early stopping occurs once a valid path is found.",
          "planning_mechanism": "The algorithm alternates between expanding start and goal trees, sampling with goal bias to expedite connection, steering nearest nodes towards samples, rewiring neighbors within a calculated radius based on node count to optimize path cost, attempting to connect the two trees via multiple candidates, and performing iterative shortcutting to smooth and shorten the path before termination either when time limit or a valid solution is found.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.time_limit = 30.0\n        self.goal_sample_rate = 0.15  # Probability to sample goal to bias search\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n        import time\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        start_tree = [Node(start_pos, cost=0.0)]\n        goal_tree = [Node(goal_pos, cost=0.0)]\n        nodes = start_tree[:] + goal_tree[:]\n        edges = []\n\n        gamma_rrt_star = 30.0  # Tuned constant for neighborhood radius\n        best_connection = None\n        best_cost = float('inf')\n        success = False\n\n        start_time = time.monotonic()\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def sample_free():\n            if random.random() < self.goal_sample_rate:\n                return goal_pos\n            for _ in range(30):\n                p = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n            return goal_pos  # Fallback if no free sample found in limited retries\n\n        def nearest(tree, point):\n            best_node = None\n            best_d = float('inf')\n            for node in tree:\n                d = dist(node.position, point)\n                if d < best_d:\n                    best_d = d\n                    best_node = node\n            return best_node\n\n        def near(tree, point, radius):\n            neighbors = []\n            r2 = radius * radius\n            for node in tree:\n                d = 0.0\n                for i in range(dim):\n                    diff = node.position[i] - point[i]\n                    d += diff*diff\n                    if d > r2:\n                        break\n                if d <= r2:\n                    neighbors.append(node)\n            return neighbors\n\n        def steer(from_p, to_p, max_step):\n            d = dist(from_p, to_p)\n            if d <= max_step:\n                return to_p\n            ratio = max_step / d\n            return tuple(from_p[i] + (to_p[i] - from_p[i]) * ratio for i in range(dim))\n\n        def extract_path(n_start, n_goal):\n            path_start = []\n            cur = n_start\n            while cur is not None:\n                path_start.append(cur.position)\n                cur = cur.parent\n            path_start.reverse()\n            path_goal = []\n            cur = n_goal\n            while cur is not None:\n                path_goal.append(cur.position)\n                cur = cur.parent\n            if path_start and path_goal and path_start[-1] == path_goal[0]:\n                path_goal = path_goal[1:]\n            return path_start + path_goal\n\n        def shortcut_path(path, max_attempts=50):\n            if len(path) < 3:\n                return path\n            for _ in range(max_attempts):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1 = path[i]\n                p2 = path[j]\n                if not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, \n                                               resolution=max(self.step_size * 0.2, 0.2)):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        def rewire(tree, new_node, neighbors):\n            for neighbor in neighbors:\n                if neighbor is new_node.parent:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, neighbor.position)\n                if new_cost + 1e-9 < neighbor.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d, \n                                                    resolution=max(self.step_size * 0.2, 0.2)):\n                        if neighbor.parent:\n                            try:\n                                edges.remove((neighbor.parent, neighbor))\n                            except Exception:\n                                pass\n                            neighbor.parent.remove_child(neighbor)\n                        neighbor.parent = new_node\n                        neighbor.cost = new_cost\n                        new_node.add_child(neighbor)\n                        edges.append((new_node, neighbor))\n\n        def attempt_connection(new_node, other_tree):\n            radius = self.step_size * 2.5\n            candidates = near(other_tree, new_node.position, radius)\n            best_cand = None\n            best_cand_cost = float('inf')\n            for node in candidates:\n                dist_between = dist(new_node.position, node.position)\n                if dist_between <= radius:\n                    if not self._is_edge_in_obstacle(new_node.position, node.position, obstacles, is_3d,\n                                                    resolution=max(self.step_size * 0.2, 0.2)):\n                        total_cost = new_node.cost + dist_between + node.cost\n                        if total_cost + 1e-9 < best_cand_cost:\n                            best_cand_cost = total_cost\n                            best_cand = node\n            return best_cand, best_cand_cost\n\n        iter_since_last_shortcut = 0\n        shortcut_interval = 75\n\n        for it in range(self.max_iter):\n            if time.monotonic() - start_time > self.time_limit:\n                break\n\n            tree_a = start_tree if it % 2 == 0 else goal_tree\n            tree_b = goal_tree if it % 2 == 0 else start_tree\n\n            sample = sample_free()\n            nearest_node = nearest(tree_a, sample)\n            new_pos = steer(nearest_node.position, sample, self.step_size)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d,\n                                        resolution=max(self.step_size * 0.2, 0.2)):\n                continue\n\n            n_nodes = max(len(tree_a) + 1, 2)\n            radius = min(self.step_size * 5, gamma_rrt_star * ((math.log(n_nodes) / n_nodes) ** (1 / dim)))\n\n            neighbors = near(tree_a, new_pos, radius)\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            min_parent = nearest_node\n\n            for nb in neighbors:\n                cand_cost = nb.cost + dist(nb.position, new_pos)\n                if cand_cost + 1e-9 < min_cost:\n                    if not self._is_edge_in_obstacle(nb.position, new_pos, obstacles, is_3d,\n                                                    resolution=max(self.step_size * 0.2, 0.2)):\n                        min_cost = cand_cost\n                        min_parent = nb\n\n            new_node = Node(new_pos, parent=min_parent, cost=min_cost)\n            min_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((min_parent, new_node))\n\n            rewire(tree_a, new_node, neighbors)\n\n            conn_node, conn_cost = attempt_connection(new_node, tree_b)\n            if conn_node is not None and conn_cost + 1e-9 < best_cost:\n                best_cost = conn_cost\n                best_connection = (new_node, conn_node) if it % 2 == 0 else (conn_node, new_node)\n                success = True\n                break  # Early stop on improved solution\n\n            iter_since_last_shortcut += 1\n            if iter_since_last_shortcut >= shortcut_interval and success:\n                cur_path = extract_path(best_connection[0], best_connection[1])\n                short_path = shortcut_path(cur_path, max_attempts=25)\n                if len(short_path) < len(cur_path):\n                    iter_since_last_shortcut = 0\n\n        extracted_path = []\n        if success and best_connection is not None:\n            extracted_path = extract_path(best_connection[0], best_connection[1])\n            extracted_path = shortcut_path(extracted_path, max_attempts=75)\n        else:\n            # Attempt fallback to best partial connection\n            best_partial_cost = float('inf')\n            best_pair = None\n            search_radius = self.step_size * 3.0\n            for n1 in start_tree:\n                candidates = near(goal_tree, n1.position, search_radius)\n                for n2 in candidates:\n                    dist_12 = dist(n1.position, n2.position)\n                    if dist_12 <= search_radius:\n                        if not self._is_edge_in_obstacle(n1.position, n2.position, obstacles, is_3d,\n                                                        resolution=max(self.step_size * 0.2, 0.2)):\n                            total_cost = n1.cost + n2.cost + dist_12\n                            if total_cost + 1e-9 < best_partial_cost:\n                                best_partial_cost = total_cost\n                                best_pair = (n1, n2)\n            if best_pair:\n                success = True\n                extracted_path = extract_path(best_pair[0], best_pair[1])\n                extracted_path = shortcut_path(extracted_path, max_attempts=75)\n\n        return PlannerResult(\n            success=success,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -31.39487,
          "time_improvement": 50.0,
          "length_improvement": 16.0,
          "smoothness_improvement": 1325.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.011085057258605957,
                    "num_nodes_avg": 100.8,
                    "path_length_avg": 165.54946406884443,
                    "smoothness_avg": 0.03798296007342679,
                    "success_improvement": 0.0,
                    "time_improvement": 56.07208116264085,
                    "length_improvement": 9.259715444735578,
                    "smoothness_improvement": 494.5158064670879,
                    "objective_score": 24.85003264796904
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.03302719593048096,
                    "num_nodes_avg": 334.1,
                    "path_length_avg": 232.4980564980827,
                    "smoothness_avg": 0.08999984717844736,
                    "success_improvement": 0.0,
                    "time_improvement": 79.85417754360348,
                    "length_improvement": 22.385456655436457,
                    "smoothness_improvement": 2215.7608921711562,
                    "objective_score": 48.4663317171987
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.04247584342956543,
                    "num_nodes_avg": 369.5,
                    "path_length_avg": 124.42236173924557,
                    "smoothness_avg": 0.10720066533601189,
                    "success_improvement": 0.0,
                    "time_improvement": 13.771925876127536,
                    "length_improvement": 17.364591688978223,
                    "smoothness_improvement": 1263.5845503440473,
                    "objective_score": 20.86825552794543
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "cross_over",
          "algorithm_description": "A goal-biased bidirectional RRT* planner with adaptive neighborhood radius rewiring, multi-candidate bridging attempts, and iterative path shortcutting for improved efficiency, shorter and smoother paths under a strict 30-second time limit. The planner alternates expansions from start and goal, samples mostly uniformly but occasionally biasing toward the goal, selects minimal cost parents for new nodes, rewires neighbors within an adaptive radius, and tries multiple connections to the other tree to find lower-cost paths early. Incremental shortcutting improves path smoothness progressively during search.",
          "planning_mechanism": "A bidirectional RRT* expands start and goal trees alternately by sampling free points with a fixed goal bias. Each new node connects to the lowest-cost nearby parent within an adaptively computed radius, followed by rewiring neighboring nodes to reduce global path cost. Multiple connection attempts between new nodes and the opposite tree within a radius allow improved bridging paths. Early stopping occurs upon improved connection. Incremental shortcutting of the best path occurs regularly during planning, and a final shortcutting step refines the extracted path before returning results. All samples and edges are rigorously collision-checked using a step-size scaled resolution. A 30-second hard timeout interrupts planning, returning the best path found so far.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent: Optional[\"Node\"]=None, cost: float=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children: List[\"Node\"] = []\n        self.valid = True\n    def add_child(self, child: \"Node\"):\n        self.children.append(child)\n    def remove_child(self, child: \"Node\"):\n        try:\n            self.children.remove(child)\n        except ValueError:\n            pass\nclass Planner:\n    def __init__(self, max_iter: int=5000, step_size: float=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.time_limit = 30.0\n        self.goal_sample_rate = 0.15\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        gamma_rrt_star = 35.0\n\n        # Helper funcs\n        def dist(a: Tuple[float, ...], b: Tuple[float, ...]) -> float:\n            return math.dist(a, b)\n\n        def in_obstacle(pos):\n            for o in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d = o\n                    px,py,pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x,y,w_,h_ = o\n                    px,py = pos\n                    if x <= px <= x + w_ and y <= py <= y + h_:\n                        return True\n            return False\n\n        def edge_in_obstacle(a, b, resolution=1.0):\n            dist_ab = dist(a,b)\n            steps = max(1, int(dist_ab / resolution))\n            for i in range(steps+1):\n                interp = tuple(a[d] + (b[d]-a[d])*(i/steps) for d in range(dim))\n                if in_obstacle(interp):\n                    return True\n            return False\n\n        def sample_free():\n            if random.random() < self.goal_sample_rate:\n                if not in_obstacle(goal_pos):\n                    return goal_pos\n            for _ in range(100):\n                sample = tuple(random.uniform(0,bounds[d]) for d in range(dim))\n                if not in_obstacle(sample):\n                    return sample\n            return goal_pos\n\n        def steer(from_p, to_p, max_step):\n            d = dist(from_p,to_p)\n            if d <= max_step:\n                return to_p\n            ratio = max_step / d\n            return tuple(from_p[i] + (to_p[i]-from_p[i])*ratio for i in range(dim))\n\n        def nearest(tree, point):\n            best_n = None\n            best_d = float('inf')\n            for node in tree:\n                d = dist(node.position, point)\n                if d < best_d:\n                    best_d = d\n                    best_n = node\n            return best_n\n\n        def near(tree, point, radius):\n            neighbors = []\n            r2 = radius*radius\n            for node in tree:\n                # squared distance for efficiency\n                dd = sum((node.position[d]-point[d])**2 for d in range(dim))\n                if dd <= r2:\n                    neighbors.append((dd,node))\n            neighbors.sort(key=lambda x: x[0])\n            return [n[1] for n in neighbors]\n\n        def extract_path(n_start: Node, n_goal: Node) -> List[Tuple[float,...]]:\n            path_start = []\n            cur = n_start\n            while cur is not None:\n                path_start.append(cur.position)\n                cur = cur.parent\n            path_start.reverse()\n\n            path_goal = []\n            cur = n_goal\n            while cur is not None:\n                path_goal.append(cur.position)\n                cur = cur.parent\n            # omit duplicate connecting node pos from goal side\n            if path_goal and path_start and path_start[-1] == path_goal[0]:\n                path_goal = path_goal[1:]\n            return path_start + path_goal\n\n        def shortcut_path(path: List[Tuple[float,...]], max_attempts=50) -> List[Tuple[float,...]]:\n            if len(path)<3:\n                return path\n            for _ in range(max_attempts):\n                if len(path)<3:\n                    break\n                i = random.randint(0,len(path)-3)\n                j = random.randint(i+2,len(path)-1)\n                p1,p2 = path[i], path[j]\n                if not edge_in_obstacle(p1,p2,resolution=max(self.step_size*0.2, 0.2)):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        def rewire(tree, new_node, neighbors):\n            for nb in neighbors:\n                if nb is new_node.parent:\n                    continue\n                c_new = new_node.cost + dist(new_node.position, nb.position)\n                if c_new +1e-9 < nb.cost:\n                    if not edge_in_obstacle(new_node.position, nb.position, resolution=max(self.step_size*0.2, 0.2)):\n                        # rewire nb to new_node\n                        if nb.parent:\n                            try:\n                                edges.remove((nb.parent, nb))\n                            except Exception:\n                                pass\n                            nb.parent.remove_child(nb)\n                        nb.parent = new_node\n                        nb.cost = c_new\n                        new_node.add_child(nb)\n                        edges.append((new_node, nb))\n\n        # Trees init\n        start_tree = [Node(start_pos, cost=0.0)]\n        goal_tree = [Node(goal_pos, cost=0.0)]\n        nodes = start_tree[:] + goal_tree[:]\n        edges: List[Tuple[Node,Node]] = []\n\n        best_connection = None\n        best_cost = float('inf')\n        success = False\n\n        iter_since_last_shortcut = 0\n        shortcut_interval = 75\n\n        start_time = time.monotonic()\n\n        for it in range(self.max_iter):\n            if time.monotonic() - start_time > self.time_limit:\n                break\n\n            tree_a = start_tree if it % 2 == 0 else goal_tree\n            tree_b = goal_tree if it % 2 == 0 else start_tree\n\n            sample = sample_free()\n            nearest_node = nearest(tree_a, sample)\n            new_pos = steer(nearest_node.position, sample, self.step_size)\n\n            if in_obstacle(new_pos):\n                continue\n            if edge_in_obstacle(nearest_node.position, new_pos, resolution=max(self.step_size*0.2, 0.2)):\n                continue\n\n            n_nodes = len(tree_a)+1\n            radius = gamma_rrt_star * ((math.log(n_nodes)/n_nodes)**(1/dim))\n            radius = min(radius, self.step_size*5.0)\n            radius = max(radius, self.step_size)\n\n            neighbors = near(tree_a, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position,new_pos)\n            min_parent = nearest_node\n            for nb in neighbors:\n                c_cand = nb.cost + dist(nb.position,new_pos)\n                if c_cand +1e-9 < min_cost:\n                    if not edge_in_obstacle(nb.position,new_pos,resolution=max(self.step_size*0.2, 0.2)):\n                        min_cost = c_cand\n                        min_parent = nb\n\n            new_node = Node(new_pos, parent=min_parent, cost=min_cost)\n            min_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((min_parent,new_node))\n\n            rewire(tree_a, new_node, neighbors)\n\n            # multi candidate connections to other tree\n            conn_radius = self.step_size*2.5\n            candidates = near(tree_b, new_pos, conn_radius)\n            for cand in candidates:\n                dist_bt = dist(new_pos, cand.position)\n                cost_tot = new_node.cost + dist_bt + cand.cost\n                if dist_bt <= conn_radius and not edge_in_obstacle(new_pos, cand.position, resolution=max(self.step_size*0.2,0.2)):\n                    if cost_tot +1e-9 < best_cost:\n                        best_cost = cost_tot\n                        best_connection = (new_node, cand) if it%2==0 else (cand, new_node)\n                        success = True\n                        # early stopping on improved connection\n                        break\n\n            if success:\n                break\n\n            iter_since_last_shortcut += 1\n            if iter_since_last_shortcut >= shortcut_interval and success:\n                path_cur = extract_path(best_connection[0], best_connection[1])\n                path_short = shortcut_path(path_cur, max_attempts=25)\n                if len(path_short) < len(path_cur):\n                    iter_since_last_shortcut = 0\n                    best_connection = (\n                        self._node_from_pos(tree_a, path_short[0]),\n                        self._node_from_pos(tree_b, path_short[-1])\n                    )\n                # else: keep old path\n\n        extracted_path: List[Tuple[float,...]] = []\n        if success and best_connection is not None:\n            extracted_path = extract_path(best_connection[0], best_connection[1])\n            extracted_path = shortcut_path(extracted_path, max_attempts=75)\n        else:\n            # attempt best partial connection\n            partial_best_cost = float('inf')\n            partial_best_pair = None\n            search_radius = self.step_size * 3.0\n            for n1 in start_tree:\n                candidates = near(goal_tree, n1.position, search_radius)\n                for n2 in candidates:\n                    d12 = dist(n1.position, n2.position)\n                    if d12 <= search_radius and not edge_in_obstacle(n1.position, n2.position, resolution=max(self.step_size*0.2, 0.2)):\n                        total_c = n1.cost + d12 + n2.cost\n                        if total_c +1e-9 < partial_best_cost:\n                            partial_best_cost = total_c\n                            partial_best_pair = (n1, n2)\n            if partial_best_pair:\n                success = True\n                extracted_path = extract_path(partial_best_pair[0], partial_best_pair[1])\n                extracted_path = shortcut_path(extracted_path, max_attempts=75)\n\n        return PlannerResult(\n            success=success,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _node_from_pos(self, tree, pos):\n        # Helper: find node in tree with position pos (assumes unique)\n        for n in tree:\n            if n.position == pos:\n                return n\n        return None",
          "objective": -31.33248,
          "time_improvement": 56.0,
          "length_improvement": 15.0,
          "smoothness_improvement": 1169.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.011849260330200196,
                    "num_nodes_avg": 102.2,
                    "path_length_avg": 171.47944500563713,
                    "smoothness_avg": 0.03622260469512261,
                    "success_improvement": 0.0,
                    "time_improvement": 53.04369351239302,
                    "length_improvement": 6.009398926718358,
                    "smoothness_improvement": 466.9624221237396,
                    "objective_score": 21.853559520367618
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.043631362915039065,
                    "num_nodes_avg": 304.7,
                    "path_length_avg": 239.59308421149603,
                    "smoothness_avg": 0.06645301735773035,
                    "success_improvement": 0.0,
                    "time_improvement": 73.38588196626901,
                    "length_improvement": 20.016932185649583,
                    "smoothness_improvement": 1609.8840007881201,
                    "objective_score": 42.07534390521106
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.029008769989013673,
                    "num_nodes_avg": 237.9,
                    "path_length_avg": 124.02161549375981,
                    "smoothness_avg": 0.12039178847213117,
                    "success_improvement": 0.0,
                    "time_improvement": 41.1107545632878,
                    "length_improvement": 17.630748263744316,
                    "smoothness_improvement": 1431.3746629680568,
                    "objective_score": 30.06854864207321
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e2",
          "algorithm_description": "A hybrid bidirectional RRT* planner blending adaptive rewiring with logarithmic radius scaling, probabilistic goal bias sampling, multi-candidate tree connection attempts, and incremental path shortcutting during planning. The planner enforces a strict 30-second time limit, dynamically balances exploration-exploitation, and maintains efficient and coherent node-edge structures to output high-quality, smooth, and short paths robustly.",
          "planning_mechanism": "The planner alternates tree expansions from start and goal, sampling near goal with probability to speed convergence. It adaptively computes neighborhood radii based on tree size and dimension for rewiring local neighbors to reduce costs. Multiple connection candidates between trees are attempted to find better pathways early for safe early termination. Path shortcuts occur incrementally during planning to improve smoothness and path length progressively. Rigorous collision checks keep path validity enforced within map bounds and obstacle constraints.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.time_limit = 30.0\n        self.goal_sample_rate = 0.15  # 15% chance to sample goal\n\n    def plan(self, map):\n        import time\n        import math\n        import random\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        gamma_rrt_star = 35.0\n        shortcut_interval = 75\n\n        def dist(a, b):\n            s = 0.0\n            for i in range(dim):\n                d = a[i] - b[i]\n                s += d * d\n            return math.sqrt(s)\n\n        def in_obstacle(pos):\n            for o in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = o\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w_, h_ = o\n                    px, py = pos\n                    if x <= px <= x + w_ and y <= py <= y + h_:\n                        return True\n            return False\n\n        def edge_in_obstacle(a, b, resolution=None):\n            # resolution scaled by step size\n            if resolution is None:\n                resolution = max(self.step_size * 0.2, 0.2)\n            distance = dist(a, b)\n            steps = max(1, int(distance / resolution))\n            for i in range(steps + 1):\n                interp = tuple(a[d] + (b[d] - a[d]) * (i / steps) for d in range(dim))\n                if in_obstacle(interp):\n                    return True\n            return False\n\n        def steer(from_p, to_p, max_step):\n            d = dist(from_p, to_p)\n            if d <= max_step:\n                return to_p\n            ratio = max_step / d\n            return tuple(from_p[i] + (to_p[i] - from_p[i]) * ratio for i in range(dim))\n\n        def sample_free():\n            if random.random() < self.goal_sample_rate:\n                return goal_pos\n            for _ in range(100):\n                p = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not in_obstacle(p):\n                    return p\n            return goal_pos\n\n        def nearest(tree, point):\n            best_node = None\n            best_dist = float('inf')\n            for node in tree:\n                dd = 0.0\n                for i in range(dim):\n                    d = node.position[i] - point[i]\n                    dd += d*d\n                    if dd > best_dist*best_dist:\n                        break\n                if dd < best_dist*best_dist:\n                    best_dist = math.sqrt(dd)\n                    best_node = node\n            return best_node\n\n        def near(tree, point, radius):\n            r_sq = radius*radius\n            neighbors = []\n            for node in tree:\n                dd = 0.0\n                for i in range(dim):\n                    d = node.position[i] - point[i]\n                    dd += d*d\n                    if dd > r_sq:\n                        break\n                if dd <= r_sq:\n                    neighbors.append((math.sqrt(dd), node))\n            neighbors.sort(key=lambda x: x[0])\n            return [x[1] for x in neighbors]\n\n        def extract_path(node_start, node_goal):\n            path_start = []\n            cur = node_start\n            while cur is not None:\n                path_start.append(cur.position)\n                cur = cur.parent\n            path_start.reverse()\n            path_goal = []\n            cur = node_goal\n            while cur is not None:\n                path_goal.append(cur.position)\n                cur = cur.parent\n            if path_start and path_goal and path_start[-1] == path_goal[0]:\n                path_goal = path_goal[1:]\n            return path_start + path_goal\n\n        def shortcut_path(path, max_attempts=50):\n            if len(path) < 3:\n                return path\n            attempts = 0\n            while attempts < max_attempts and len(path) > 2:\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if not edge_in_obstacle(path[i], path[j], resolution=max(self.step_size * 0.2, 0.2)):\n                    path = path[:i + 1] + path[j:]\n                attempts += 1\n            return path\n\n        def rewire(tree, new_node, neighbors):\n            for nb in neighbors:\n                if nb is new_node.parent:\n                    continue\n                cost_through = new_node.cost + dist(new_node.position, nb.position)\n                if cost_through + 1e-10 < nb.cost:\n                    if not edge_in_obstacle(new_node.position, nb.position, resolution=max(self.step_size * 0.2, 0.2)):\n                        if nb.parent:\n                            try:\n                                edges.remove((nb.parent, nb))\n                            except ValueError:\n                                pass\n                            nb.parent.remove_child(nb)\n                        nb.parent = new_node\n                        nb.cost = cost_through\n                        new_node.add_child(nb)\n                        edges.append((new_node, nb))\n\n        def try_connect(new_node, other_tree, radius):\n            candidates = near(other_tree, new_node.position, radius)\n            best_cand = None\n            best_cost_local = float('inf')\n            for node in candidates:\n                d = dist(new_node.position, node.position)\n                if d <= radius and not edge_in_obstacle(new_node.position, node.position, resolution=max(self.step_size * 0.2, 0.2)):\n                    total_cost = new_node.cost + d + node.cost\n                    if total_cost < best_cost_local:\n                        best_cost_local = total_cost\n                        best_cand = node\n            return best_cand, best_cost_local\n\n        start_tree = [Node(start_pos, cost=0.0)]\n        goal_tree = [Node(goal_pos, cost=0.0)]\n        nodes = start_tree[:] + goal_tree[:]\n        edges = []\n\n        best_connection = None\n        best_cost = float('inf')\n        success = False\n        extracted_path = []\n\n        start_time = time.monotonic()\n        iter_since_last_shortcut = 0\n\n        for it in range(self.max_iter):\n            if time.monotonic() - start_time > self.time_limit:\n                break\n\n            tree_a = start_tree if it % 2 == 0 else goal_tree\n            tree_b = goal_tree if it % 2 == 0 else start_tree\n\n            sample = sample_free()\n            nearest_node = nearest(tree_a, sample)\n            new_pos = steer(nearest_node.position, sample, self.step_size)\n\n            if in_obstacle(new_pos):\n                continue\n            if edge_in_obstacle(nearest_node.position, new_pos, resolution=max(self.step_size * 0.2, 0.2)):\n                continue\n\n            n_nodes = len(tree_a) + 1\n            radius = max(self.step_size,\n                         min(self.step_size * 5,\n                             gamma_rrt_star * ((math.log(n_nodes) / n_nodes) ** (1 / dim))))\n\n            neighbors = near(tree_a, new_pos, radius)\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            min_parent = nearest_node\n\n            for nb in neighbors:\n                candidate_cost = nb.cost + dist(nb.position, new_pos)\n                if candidate_cost + 1e-10 < min_cost:\n                    if not edge_in_obstacle(nb.position, new_pos, resolution=max(self.step_size * 0.2, 0.2)):\n                        min_cost = candidate_cost\n                        min_parent = nb\n\n            new_node = Node(new_pos, parent=min_parent, cost=min_cost)\n            min_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((min_parent, new_node))\n\n            rewire(tree_a, new_node, neighbors)\n\n            conn_radius = self.step_size * 3.0\n            conn_node, conn_cost = try_connect(new_node, tree_b, conn_radius)\n            if conn_node is not None and conn_cost + 1e-10 < best_cost:\n                if it % 2 == 0:\n                    best_connection = (new_node, conn_node)\n                else:\n                    best_connection = (conn_node, new_node)\n                best_cost = conn_cost\n                success = True\n                # Early stop upon improved path\n                break\n\n            iter_since_last_shortcut += 1\n            if success and iter_since_last_shortcut >= shortcut_interval:\n                current_path = extract_path(best_connection[0], best_connection[1])\n                shortcut_path_candidate = shortcut_path(current_path, max_attempts=25)\n                if len(shortcut_path_candidate) < len(current_path):\n                    extracted_path = shortcut_path_candidate\n                    iter_since_last_shortcut = 0\n\n        if success and best_connection is not None:\n            if not extracted_path:\n                extracted_path = extract_path(best_connection[0], best_connection[1])\n            extracted_path = shortcut_path(extracted_path, max_attempts=75)\n        else:\n            # Try for partial best connection fallback\n            best_partial_cost = float('inf')\n            best_pair = None\n            search_radius = self.step_size * 3.0\n            for n1 in start_tree:\n                candidates = near(goal_tree, n1.position, search_radius)\n                for n2 in candidates:\n                    d12 = dist(n1.position, n2.position)\n                    if d12 <= search_radius:\n                        if not edge_in_obstacle(n1.position, n2.position, resolution=max(self.step_size * 0.2, 0.2)):\n                            total_cost = n1.cost + n2.cost + d12\n                            if total_cost + 1e-10 < best_partial_cost:\n                                best_partial_cost = total_cost\n                                best_pair = (n1, n2)\n            if best_pair:\n                success = True\n                extracted_path = extract_path(best_pair[0], best_pair[1])\n                extracted_path = shortcut_path(extracted_path, max_attempts=75)\n            else:\n                extracted_path = []\n\n        return PlannerResult(\n            success=success,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -30.58805,
          "time_improvement": 44.0,
          "length_improvement": 16.0,
          "smoothness_improvement": 1546.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.015506672859191894,
                    "num_nodes_avg": 110.5,
                    "path_length_avg": 165.32360698687205,
                    "smoothness_avg": 0.042682353416855265,
                    "success_improvement": 0.0,
                    "time_improvement": 38.55008134782289,
                    "length_improvement": 9.38351129029913,
                    "smoothness_improvement": 568.0715171877238,
                    "objective_score": 20.035488764464965
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.04029386043548584,
                    "num_nodes_avg": 304.0,
                    "path_length_avg": 237.0827913871054,
                    "smoothness_avg": 0.1095315761296289,
                    "success_improvement": 0.0,
                    "time_improvement": 75.42168096483944,
                    "length_improvement": 20.85494018520385,
                    "smoothness_improvement": 2718.3263462207824,
                    "objective_score": 48.73110013167805
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.041114401817321775,
                    "num_nodes_avg": 276.5,
                    "path_length_avg": 122.26557895183328,
                    "smoothness_avg": 0.11413022365431473,
                    "success_improvement": 0.0,
                    "time_improvement": 16.53572004187582,
                    "length_improvement": 18.797024121417593,
                    "smoothness_improvement": 1351.7280206660696,
                    "objective_score": 22.99757058874365
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "time_expert",
          "algorithm_description": "A bidirectional RRT* planner with goal bias sampling, adaptive rewiring radius based on tree size, and dynamic step size for faster exploration. It alternates expanding from start and goal trees using efficient nearest neighbor lookups with radius proportional to tree growth, performs cost-based rewiring, incrementally tries connecting the two trees, and applies shortcutting smoothing on the final path to improve smoothness and reduce length. Early stopping is enforced with a hard 30-second timeout to reduce planning time while maintaining path quality and robustness.",
          "planning_mechanism": "A 2D/3D bidirectional RRT* planning method that grows two trees toward random samples biased towards the goal. Each extension selects the best parent from neighbors and rewires nearby nodes within an adaptively shrinking neighborhood radius. After each extension, it attempts to connect the two trees directly. If a better path connection is found, it updates the best known path. It also shortcuts the resulting path for smoothness improvement before returning the best path found within the time limit.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = 0.2  # 20% goal bias\n        self.max_shortcuts = 100     # Number of shortcut attempts after planning\n        self.connection_radius_factor = 30.0  # gamma coefficient\n        self.connection_radius_multiplier = 5.0\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        nodes_start = [Node(start_pos)]\n        nodes_goal = [Node(goal_pos)]\n        edges = []\n        all_nodes = nodes_start + nodes_goal\n\n        success = False\n        best_cost = float('inf')\n        best_connection = None\n\n        start_time = time.monotonic()\n        TIME_LIMIT = 30.0\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def sample_free():\n            for _ in range(30):\n                if random.random() < self.goal_sample_rate:\n                    p = goal_pos\n                else:\n                    p = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n            return start_pos\n\n        def nearest(tree, point):\n            # Linear search for nearest node\n            best_node = None\n            best_dist = float('inf')\n            px2 = point[0]**2 if not is_3d else None  # Precalc for speed not critical\n            for n in tree:\n                d = dist(n.position, point)\n                if d < best_dist:\n                    best_dist = d\n                    best_node = n\n            return best_node\n\n        def near(tree, point, radius):\n            r_sq = radius * radius\n            if not is_3d:\n                return [n for n in tree if (n.position[0]-point[0])**2 + (n.position[1]-point[1])**2 <= r_sq]\n            else:\n                return [n for n in tree if sum((n.position[i]-point[i])**2 for i in range(3)) <= r_sq]\n\n        def steer(from_p, to_p, step):\n            d = dist(from_p, to_p)\n            if d <= step:\n                return to_p\n            ratio = step / d\n            return tuple(from_p[i] + (to_p[i]-from_p[i]) * ratio for i in range(len(from_p)))\n\n        def extract_path(n_start, n_goal):\n            path_start = []\n            node = n_start\n            while node is not None:\n                path_start.append(node.position)\n                node = node.parent\n            path_goal = []\n            node = n_goal\n            while node is not None:\n                path_goal.append(node.position)\n                node = node.parent\n            return path_start[::-1] + path_goal\n\n        def try_rewire(new_node, near_nodes, tree):\n            changed = False\n            for near_node in near_nodes:\n                if near_node is new_node.parent:\n                    continue\n                dist_new_near = dist(new_node.position, near_node.position)\n                new_cost = new_node.cost + dist_new_near\n                if new_cost + 1e-9 < near_node.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                        # Rewire near_node\n                        if near_node.parent:\n                            if (near_node.parent, near_node) in edges:\n                                edges.remove((near_node.parent, near_node))\n                            near_node.parent.remove_child(near_node)\n                        near_node.parent = new_node\n                        near_node.cost = new_cost\n                        new_node.add_child(near_node)\n                        edges.append((new_node, near_node))\n                        changed = True\n            return changed\n\n        def add_node(tree, new_node):\n            tree.append(new_node)\n            all_nodes.append(new_node)\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.max_shortcuts):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i+2, len(path) - 1)\n                p_i = path[i]\n                p_j = path[j]\n                if not self._is_edge_in_obstacle(p_i, p_j, obstacles, is_3d):\n                    # Remove intermediate points between i and j\n                    path = path[:i+1] + path[j:]\n            return path\n\n        gamma = self.connection_radius_factor\n\n        for itr in range(self.max_iter):\n            now = time.monotonic()\n            if now - start_time > TIME_LIMIT:\n                break\n\n            # Alternate tree expansions\n            tree_a = nodes_start if itr % 2 == 0 else nodes_goal\n            tree_b = nodes_goal if itr % 2 == 0 else nodes_start\n\n            rnd = sample_free()\n            nearest_node = nearest(tree_a, rnd)\n            new_pos = steer(nearest_node.position, rnd, self.step_size)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            n_nodes = len(tree_a) + 1\n            radius = min(self.connection_radius_multiplier * self.step_size,\n                         gamma * (math.log(max(n_nodes, 2)) / n_nodes) ** (1/dim))\n            near_nodes = near(tree_a, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            min_parent = nearest_node\n            for near_node in near_nodes:\n                cost_thru = near_node.cost + dist(near_node.position, new_pos)\n                if cost_thru + 1e-9 < min_cost:\n                    if not self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d):\n                        min_cost = cost_thru\n                        min_parent = near_node\n\n            new_node = Node(new_pos, parent=min_parent, cost=min_cost)\n            min_parent.add_child(new_node)\n            add_node(tree_a, new_node)\n            edges.append((min_parent, new_node))\n\n            try_rewire(new_node, near_nodes, tree_a)\n\n            # Try connection to other tree\n            nearest_in_other = nearest(tree_b, new_node.position)\n            dist_conn = dist(new_node.position, nearest_in_other.position)\n            if dist_conn <= self.step_size * 1.2:\n                if not self._is_edge_in_obstacle(new_node.position, nearest_in_other.position, obstacles, is_3d):\n                    total_cost = new_node.cost + nearest_in_other.cost + dist_conn\n                    if total_cost + 1e-9 < best_cost:\n                        best_cost = total_cost\n                        best_connection = (new_node, nearest_in_other)\n                        success = True\n                        # Early stop on improved connection to save time\n                        break\n\n        if success and best_connection is not None:\n            path = extract_path(best_connection[0], best_connection[1])\n            path = shortcut_path(path)\n            return PlannerResult(success=True, path=path, nodes=all_nodes, edges=edges)\n        else:\n            # Try best possible connection at termination\n            min_est_cost = float('inf')\n            best_pair = None\n            for node_start in nodes_start:\n                near_goal = nearest(nodes_goal, node_start.position)\n                d = dist(node_start.position, near_goal.position)\n                if d <= self.step_size * 1.2:\n                    if not self._is_edge_in_obstacle(node_start.position, near_goal.position, obstacles, is_3d):\n                        est_cost = node_start.cost + near_goal.cost + d\n                        if est_cost + 1e-9 < min_est_cost:\n                            min_est_cost = est_cost\n                            best_pair = (node_start, near_goal)\n            if best_pair:\n                path = extract_path(best_pair[0], best_pair[1])\n                path = shortcut_path(path)\n                return PlannerResult(success=True, path=path, nodes=all_nodes, edges=edges)\n\n        return PlannerResult(success=False, path=[], nodes=all_nodes, edges=edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x,y,z,w,h,d = obs\n                px,py,pz = pos\n                if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                    return True\n            else:\n                x,y,w,h = obs\n                px,py = pos\n                if x <= px <= x+w and y <= py <= y+h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -29.68817,
          "time_improvement": 48.0,
          "length_improvement": 15.0,
          "smoothness_improvement": 1307.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.014809727668762207,
                    "num_nodes_avg": 135.4,
                    "path_length_avg": 170.66544462396834,
                    "smoothness_avg": 0.04089497366305359,
                    "success_improvement": 0.0,
                    "time_improvement": 41.31193913935704,
                    "length_improvement": 6.455565434572493,
                    "smoothness_improvement": 540.095142683469,
                    "objective_score": 18.96739671596795
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.036438727378845216,
                    "num_nodes_avg": 383.1,
                    "path_length_avg": 238.75090905172993,
                    "smoothness_avg": 0.08266881742076103,
                    "success_improvement": 0.0,
                    "time_improvement": 77.77322259339138,
                    "length_improvement": 20.29807449464742,
                    "smoothness_improvement": 2027.1282161785853,
                    "objective_score": 45.64645255569879
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.037070393562316895,
                    "num_nodes_avg": 368.9,
                    "path_length_avg": 124.82276282249741,
                    "smoothness_avg": 0.11427581459840219,
                    "success_improvement": 0.0,
                    "time_improvement": 24.74525787361654,
                    "length_improvement": 17.098664354533046,
                    "smoothness_improvement": 1353.579926728457,
                    "objective_score": 24.45067560844707
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m1",
          "algorithm_description": "A bidirectional RRT* planner with adaptive neighborhood radius shrinking, dynamic goal biasing increasing over time, efficient multi-candidate connection attempts between trees, and incremental progressive shortcutting integrated within planning. It enforces a 30-second time limit with early stopping on path improvement, leverages adaptive collision checking resolution scaled by step size, and maintains the best path found for prompt return. This design balances exploration and refinement to yield faster planning, shorter and smoother paths with robust obstacle avoidance.",
          "planning_mechanism": "The planner grows two trees from start and goal alternately using a goal bias that increases over time, and adapts the rewiring radius based on current tree size and dimension. Upon adding new nodes, it selects the lowest-cost parent from nearby nodes with collision checks and rewires neighbors for optimal costs. Multiple candidates from the opposite tree are attempted for connection to discover better paths early with early termination. Periodic incremental shortcutting reduces path length and smoothness during search, while final intensive shortcutting refines the resulting path. The search aborts if the 30-second time limit is exceeded, returning the best path found so far.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 4.5):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.time_limit = 30.0\n        self.gamma_rrt_star = 30.0  # adaptive radius coefficient\n        self.goal_sample_start = 0.15\n        self.goal_sample_end = 0.4\n        self.shortcut_interval = 250\n        self.shortcut_progressive_attempts = 15\n        self.shortcut_final_attempts = 120\n\n    def plan(self, map):\n        import math\n        import random\n        import time\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_p, to_p, max_step):\n            d = dist(from_p, to_p)\n            if d <= max_step:\n                return to_p\n            ratio = max_step / d\n            return tuple(from_p[i] + (to_p[i] - from_p[i]) * ratio for i in range(dim))\n\n        def sample_free(goal_bias):\n            for _ in range(30):\n                if random.random() < goal_bias:\n                    p = goal_pos\n                else:\n                    p = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n            # fallback\n            return goal_pos\n\n        def adaptive_rewire_radius(n):\n            if n < 2:\n                return self.step_size * 5\n            r = self.gamma_rrt_star * (math.log(n) / n) ** (1 / dim)\n            return max(self.step_size, min(r, self.step_size * 5))\n\n        def adaptive_edge_res(p1, p2):\n            length = dist(p1, p2)\n            min_res = 0.05\n            max_res = self.step_size / 4\n            return max(min_res, min(max_res, length / 10))\n\n        def near_nodes(tree, point, radius):\n            return [node for node in tree if dist(node.position, point) <= radius]\n\n        def extract_path(node_start, node_goal):\n            path_start = []\n            cur = node_start\n            while cur:\n                path_start.append(cur.position)\n                cur = cur.parent\n            path_start.reverse()\n            path_goal = []\n            cur = node_goal\n            while cur:\n                path_goal.append(cur.position)\n                cur = cur.parent\n            if path_goal and path_start and path_start[-1] == path_goal[0]:\n                path_goal = path_goal[1:]\n            return path_start + path_goal\n\n        def shortcut_path(path, attempts, resolution):\n            if len(path) < 3:\n                return path\n            for _ in range(attempts):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        start_tree = [Node(start_pos, cost=0.0)]\n        goal_tree = [Node(goal_pos, cost=0.0)]\n        nodes = start_tree[:] + goal_tree[:]\n        edges = []\n\n        best_cost = float('inf')\n        best_pair = None\n        success = False\n        path = []\n\n        start_time = time.monotonic()\n        iter_since_last_shortcut = 0\n\n        for it in range(self.max_iter):\n            elapsed = time.monotonic() - start_time\n            if elapsed > self.time_limit:\n                break\n\n            # Goal bias linearly increasing with time\n            goal_bias = self.goal_sample_start + (self.goal_sample_end - self.goal_sample_start) * min(elapsed / self.time_limit, 1.0)\n\n            # Alternate trees\n            tree_a = start_tree if it % 2 == 0 else goal_tree\n            tree_b = goal_tree if it % 2 == 0 else start_tree\n\n            sample = sample_free(goal_bias)\n            nearest = min(tree_a, key=lambda n: dist(n.position, sample))\n            new_pos = steer(nearest.position, sample, self.step_size)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d, adaptive_edge_res(nearest.position, new_pos)):\n                continue\n\n            n_nodes = len(tree_a) + 1\n            radius = adaptive_rewire_radius(n_nodes)\n            nearlist = near_nodes(tree_a, new_pos, radius)\n\n            # Choose best parent\n            min_cost = nearest.cost + dist(nearest.position, new_pos)\n            min_parent = nearest\n            for nb in nearlist:\n                cost_cand = nb.cost + dist(nb.position, new_pos)\n                if cost_cand + 1e-9 < min_cost:\n                    if not self._is_edge_in_obstacle(nb.position, new_pos, obstacles, is_3d, adaptive_edge_res(nb.position, new_pos)):\n                        min_cost = cost_cand\n                        min_parent = nb\n\n            new_node = Node(new_pos, parent=min_parent, cost=min_cost)\n            min_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((min_parent, new_node))\n\n            # Rewire neighbors\n            for nb in nearlist:\n                if nb is min_parent:\n                    continue\n                cost_through = new_node.cost + dist(new_node.position, nb.position)\n                if cost_through + 1e-9 < nb.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, nb.position, obstacles, is_3d, adaptive_edge_res(new_node.position, nb.position)):\n                        if nb.parent:\n                            try:\n                                edges.remove((nb.parent, nb))\n                            except ValueError:\n                                pass\n                            nb.parent.remove_child(nb)\n                        nb.parent = new_node\n                        nb.cost = cost_through\n                        new_node.add_child(nb)\n                        edges.append((new_node, nb))\n\n            # Multi-candidate connection attempts to other tree\n            conn_radius = radius * 1.8\n            candidates = near_nodes(tree_b, new_pos, conn_radius)\n            for cnode in candidates:\n                d12 = dist(new_pos, cnode.position)\n                if d12 <= conn_radius:\n                    if not self._is_edge_in_obstacle(new_pos, cnode.position, obstacles, is_3d, adaptive_edge_res(new_pos, cnode.position)):\n                        total_cost = new_node.cost + cnode.cost + d12\n                        if total_cost + 1e-9 < best_cost:\n                            best_cost = total_cost\n                            best_pair = (new_node, cnode) if it % 2 == 0 else (cnode, new_node)\n                            success = True\n\n            # Early stopping on better path\n            if success:\n                break\n\n            # Incremental shortcutting periodically during planning after success\n            iter_since_last_shortcut += 1\n            if success and iter_since_last_shortcut >= self.shortcut_interval and best_pair is not None:\n                cur_path = extract_path(best_pair[0], best_pair[1])\n                short_res = max(0.05, self.step_size / 5)\n                cur_path = shortcut_path(cur_path, self.shortcut_progressive_attempts, short_res)\n                path = cur_path\n                iter_since_last_shortcut = 0\n\n        # Post-processing shortcutting if success\n        if success and best_pair is not None:\n            path = extract_path(best_pair[0], best_pair[1])\n            short_res = max(0.05, self.step_size / 10)\n            path = shortcut_path(path, self.shortcut_final_attempts, short_res)\n        else:\n            # Attempt partial connection between trees if no success\n            search_radius = self.step_size * 3.0\n            best_partial_cost = float('inf')\n            best_partial_pair = None\n            for n1 in start_tree:\n                near_goal = near_nodes(goal_tree, n1.position, search_radius)\n                for n2 in near_goal:\n                    d12 = dist(n1.position, n2.position)\n                    if d12 <= search_radius:\n                        if not self._is_edge_in_obstacle(n1.position, n2.position, obstacles, is_3d, adaptive_edge_res(n1.position, n2.position)):\n                            cost_sum = n1.cost + n2.cost + d12\n                            if cost_sum + 1e-9 < best_partial_cost:\n                                best_partial_cost = cost_sum\n                                best_partial_pair = (n1, n2)\n            if best_partial_pair is not None:\n                success = True\n                path = extract_path(best_partial_pair[0], best_partial_pair[1])\n                path = shortcut_path(path, self.shortcut_final_attempts, max(0.05, self.step_size / 10))\n\n        return PlannerResult(\n            success=success,\n            path=path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -28.91096,
          "time_improvement": 41.0,
          "length_improvement": 16.0,
          "smoothness_improvement": 1410.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.02704923152923584,
                    "num_nodes_avg": 161.1,
                    "path_length_avg": 167.16795819752886,
                    "smoothness_avg": 0.049727147083846845,
                    "success_improvement": 0.0,
                    "time_improvement": -7.190826308698448,
                    "length_improvement": 8.372593166122966,
                    "smoothness_improvement": 678.3378360904431,
                    "objective_score": 6.2579971875164615
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.0385840892791748,
                    "num_nodes_avg": 356.7,
                    "path_length_avg": 235.6008659632249,
                    "smoothness_avg": 0.08609279085280898,
                    "success_improvement": 0.0,
                    "time_improvement": 76.4646016605174,
                    "length_improvement": 21.34964954655343,
                    "smoothness_improvement": 2115.229518773558,
                    "objective_score": 46.325317819955075
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.022399067878723145,
                    "num_nodes_avg": 238.3,
                    "path_length_avg": 123.93775350108095,
                    "smoothness_avg": 0.12074084692788052,
                    "success_improvement": 0.0,
                    "time_improvement": 54.52877849135742,
                    "length_improvement": 17.68644540620265,
                    "smoothness_improvement": 1435.8146607603733,
                    "objective_score": 34.149574094930685
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e1",
          "algorithm_description": "An adaptive bidirectional RRT* planner with dynamic sampling density control, neighborhood radius scaling, focused rewiring, and path smoothing via lazy shortcutting. The planner alternately grows two trees from start and goal, applies cost-optimizing rewiring within an adaptively computed radius based on node count and problem dimension, and incrementally attempts multiple connection candidates between trees to improve solution quality. It employs goal bias, samples near promising regions, respects a 30-second hard time limit, performs thorough collision checks, and applies post-planning lazy shortcut smoothing to produce shorter, smoother paths efficiently.",
          "planning_mechanism": "A bidirectional RRT* variant that dynamically tunes neighbor radius by node density and dimension, incorporates incremental rewiring only among relevant neighbors, and aggressively connects multiple candidates between trees with continuous path improvements. The planner alternates tree expansions with goal bias sampling, performs strict collision checking on nodes and edges inside map bounds and obstacles, and halts either on timeout or upon finding sufficiently good solutions. Final path extraction is followed by a lazy shortcutting smoothing step that iteratively replaces sub-paths with collision-free direct edges, thus enhancing path smoothness and reducing overall length.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...], e.g. (x, y) or (x, y, z)\n        self.parent = parent            # Parent Node or None\n        self.cost = cost                # Path cost from root (start/goal)\n        self.children = []              # List of child Nodes\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.time_limit = 30.0\n        self.goal_sample_rate = 0.15  # Probability to sample goal point during sampling\n        self.gamma_rrt_star = 50.0    # Tuning constant for neighbor radius, can be adjusted\n\n    def plan(self, map):\n        import time\n        import math\n        import random\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        start_tree = [Node(start_pos, cost=0.0)]\n        goal_tree = [Node(goal_pos, cost=0.0)]\n        all_nodes = start_tree[:] + goal_tree[:]\n        edges = []\n\n        best_cost = float('inf')\n        best_connection = None\n        extracted_path = []\n        success = False\n\n        start_time = time.monotonic()\n\n        def in_obstacle(pos):\n            for o in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = o\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w_, h_ = o\n                    px, py = pos\n                    if x <= px <= x + w_ and y <= py <= y + h_:\n                        return True\n            return False\n\n        def edge_in_obstacle(p1, p2, resolution=None):\n            dist = math.dist(p1, p2)\n            step = resolution if resolution is not None else max(self.step_size * 0.2, 0.2)\n            steps = max(1, int(dist / step))\n            for i in range(steps + 1):\n                interp = tuple(p1[d] + (p2[d] - p1[d]) * (i / steps) for d in range(dim))\n                if in_obstacle(interp):\n                    return True\n            return False\n\n        def steer(from_p, to_p, max_step=None):\n            max_step = max_step if max_step is not None else self.step_size\n            dist = math.dist(from_p, to_p)\n            if dist <= max_step:\n                return to_p\n            r = max_step / dist\n            return tuple(from_p[i] + r * (to_p[i] - from_p[i]) for i in range(dim))\n\n        def sample_free():\n            if random.random() < self.goal_sample_rate:\n                return goal_pos\n            max_attempts = 100\n            for _ in range(max_attempts):\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not in_obstacle(sample):\n                    return sample\n            return goal_pos  # fallback if no free sample found\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def nearest(tree, point):\n            best_node = None\n            best_d = float('inf')\n            for n in tree:\n                d = dist(n.position, point)\n                if d < best_d:\n                    best_d = d\n                    best_node = n\n            return best_node\n\n        def near(tree, point, radius):\n            neighbors = []\n            for n in tree:\n                d = dist(n.position, point)\n                if d <= radius:\n                    neighbors.append((d, n))\n            neighbors.sort(key=lambda x: x[0])\n            return [n[1] for n in neighbors]\n\n        def extract_path(node_start, node_goal):\n            path_start = []\n            cur = node_start\n            while cur is not None:\n                path_start.append(cur.position)\n                cur = cur.parent\n            path_start.reverse()\n\n            path_goal = []\n            cur = node_goal\n            while cur is not None:\n                path_goal.append(cur.position)\n                cur = cur.parent\n\n            # Avoid duplicate connection node position at junction\n            if path_goal and path_start and path_start[-1] == path_goal[0]:\n                path_goal = path_goal[1:]\n            return path_start + path_goal\n\n        def rewire(tree, new_node, neighbors):\n            for neighbor in neighbors:\n                if neighbor is new_node.parent:\n                    continue\n                cost_through = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_through + 1e-9 < neighbor.cost:\n                    if not edge_in_obstacle(new_node.position, neighbor.position):\n                        # Remove old parent link\n                        if neighbor.parent:\n                            try:\n                                edges.remove((neighbor.parent, neighbor))\n                            except Exception:\n                                pass\n                            neighbor.parent.remove_child(neighbor)\n                        neighbor.parent = new_node\n                        neighbor.cost = cost_through\n                        new_node.add_child(neighbor)\n                        edges.append((new_node, neighbor))\n\n        def try_connect(new_node, other_tree):\n            radius = min(self.step_size * 3.0, self.gamma_rrt_star * ((math.log(len(other_tree)+1) / (len(other_tree)+1)) ** (1/dim)))\n            candidates = near(other_tree, new_node.position, radius)\n            best_node = None\n            best_cost_local = float('inf')\n            for node in candidates:\n                dist_connect = dist(new_node.position, node.position)\n                if dist_connect <= radius and not edge_in_obstacle(new_node.position, node.position):\n                    cost = new_node.cost + dist_connect + node.cost\n                    if cost < best_cost_local:\n                        best_cost_local = cost\n                        best_node = node\n            return best_node, best_cost_local\n\n        def lazy_shortcutting(path, max_attempts=100):\n            # Iteratively try random shortcuts to smooth path\n            if len(path) < 3:\n                return path\n            shortened = path[:]\n            for _ in range(max_attempts):\n                if len(shortened) < 3:\n                    break\n                i = random.randint(0, len(shortened) - 3)\n                j = random.randint(i + 2, len(shortened) - 1)\n                p1 = shortened[i]\n                p2 = shortened[j]\n                if not edge_in_obstacle(p1, p2):\n                    # Replace intermediate segment with direct edge\n                    shortened = shortened[:i + 1] + shortened[j:]\n            return shortened\n\n        # Main planning loop\n        for it in range(self.max_iter):\n            if time.monotonic() - start_time > self.time_limit:\n                break\n\n            tree_a, tree_b = (start_tree, goal_tree) if it % 2 == 0 else (goal_tree, start_tree)\n\n            sample = sample_free()\n            nearest_node = nearest(tree_a, sample)\n\n            new_pos = steer(nearest_node.position, sample, self.step_size)\n            if in_obstacle(new_pos):\n                continue\n            if edge_in_obstacle(nearest_node.position, new_pos):\n                continue\n\n            n_nodes = len(tree_a) + 1\n            radius = min(self.step_size * 5.0, self.gamma_rrt_star * ((math.log(n_nodes)/n_nodes) ** (1.0/dim)))\n            radius = max(radius, self.step_size)  # enforce minimum radius\n\n            neighbors = near(tree_a, new_pos, radius)\n\n            # Choose best parent among neighbors\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            min_parent = nearest_node\n            for nb in neighbors:\n                cost_candidate = nb.cost + dist(nb.position, new_pos)\n                if cost_candidate + 1e-9 < min_cost:\n                    if not edge_in_obstacle(nb.position, new_pos):\n                        min_cost = cost_candidate\n                        min_parent = nb\n\n            new_node = Node(new_pos, parent=min_parent, cost=min_cost)\n            min_parent.add_child(new_node)\n            tree_a.append(new_node)\n            all_nodes.append(new_node)\n            edges.append((min_parent, new_node))\n\n            # Rewire neighbors for better cost paths\n            rewire(tree_a, new_node, neighbors)\n\n            # Attempt multiple connections to opposite tree near new_node\n            conn_node, conn_cost = try_connect(new_node, tree_b)\n            if conn_node is not None and conn_cost + 1e-9 < best_cost:\n                best_cost = conn_cost\n                best_connection = (new_node, conn_node) if it % 2 == 0 else (conn_node, new_node)\n                success = True\n                # Early stop on improved connection\n                # But to stabilize path quality a few iterations can be done, here we stop immediately for efficiency\n                break\n\n        if success and best_connection is not None:\n            extracted_path = extract_path(best_connection[0], best_connection[1])\n            extracted_path = lazy_shortcutting(extracted_path, max_attempts=150)\n        else:\n            # Fallback: attempt best partial connection by proximity between trees\n            best_partial_cost = float('inf')\n            best_pair = None\n            search_radius = self.step_size * 3.0\n            for n1 in start_tree:\n                candidates = near(goal_tree, n1.position, search_radius)\n                for n2 in candidates:\n                    d12 = dist(n1.position, n2.position)\n                    if d12 <= search_radius and not edge_in_obstacle(n1.position, n2.position):\n                        total_cost = n1.cost + n2.cost + d12\n                        if total_cost + 1e-9 < best_partial_cost:\n                            best_partial_cost = total_cost\n                            best_pair = (n1, n2)\n            if best_pair:\n                success = True\n                extracted_path = extract_path(best_pair[0], best_pair[1])\n                extracted_path = lazy_shortcutting(extracted_path, max_attempts=150)\n\n        return PlannerResult(\n            success=success,\n            path=extracted_path,\n            nodes=all_nodes,\n            edges=edges\n        )",
          "objective": -28.69397,
          "time_improvement": 42.0,
          "length_improvement": 15.0,
          "smoothness_improvement": 1414.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.026157045364379884,
                    "num_nodes_avg": 168.6,
                    "path_length_avg": 172.36255527491443,
                    "smoothness_avg": 0.052837926790736456,
                    "success_improvement": 0.0,
                    "time_improvement": -3.6552666337874102,
                    "length_improvement": 5.525352194349752,
                    "smoothness_improvement": 727.0282936695193,
                    "objective_score": 5.853772794821225
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.025740861892700195,
                    "num_nodes_avg": 281.9,
                    "path_length_avg": 233.1831140282246,
                    "smoothness_avg": 0.08535792769243598,
                    "success_improvement": 0.0,
                    "time_improvement": 84.2986720805332,
                    "length_improvement": 22.15676473358739,
                    "smoothness_improvement": 2096.320960356621,
                    "objective_score": 49.065265266095494
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.026234531402587892,
                    "num_nodes_avg": 290.9,
                    "path_length_avg": 125.36456275683038,
                    "smoothness_avg": 0.11944698374914178,
                    "success_improvement": 0.0,
                    "time_improvement": 46.74259683298413,
                    "length_improvement": 16.73882663588952,
                    "smoothness_improvement": 1419.3568166298621,
                    "objective_score": 31.16285911457826
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "A simplified bidirectional RRT* planner with adaptive neighborhood radius, goal-biased sampling, and a single final shortcutting phase. It alternately grows start and goal trees by sampling free space with a fixed goal bias, extends nearest nodes toward samples by a fixed step size, rewires neighbors within an adaptive radius, and attempts to connect trees each iteration. It respects map bounds and avoids obstacles for nodes and edges. The algorithm stops when time limit is reached or upon finding a path, returning the best path found. A final shortcutting pass improves path quality.",
          "planning_mechanism": "The planner alternates expansions between two trees growing from start and goal. It samples points with a fixed goal bias, extends nearest tree nodes toward sampled points up to a fixed step size, and rewires nearby nodes within an adaptive radius based on tree size and dimension. In each iteration, it tries to connect the newly added node to the other tree within a connection radius and updates the best path if connected. The search halts if time expires or a solution is found. The final path is shortcut once for smoothing and length improvement.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        if parent:\n            parent.children.append(self)\n    def add_child(self, child):\n        self.children.append(child)\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=5.0, goal_sample_rate=0.15):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.time_limit = 30.0\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map):\n        import time\n        import math\n        import random\n\n        bounds = map.size\n        dim = len(bounds)\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = (dim == 3)\n\n        def dist_sq(a, b):\n            s = 0.0\n            for i in range(dim):\n                d = a[i] - b[i]\n                s += d * d\n            return s\n\n        def dist(a, b):\n            return math.sqrt(dist_sq(a,b))\n\n        def sample_free():\n            if random.random() < self.goal_sample_rate:\n                return goal_pos\n            for _ in range(30):\n                p = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n            # fallback rare case\n            return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n\n        def steer(from_p, to_p, max_step):\n            d = dist(from_p, to_p)\n            if d <= max_step:\n                return to_p\n            ratio = max_step / d\n            return tuple(from_p[i] + (to_p[i] - from_p[i]) * ratio for i in range(dim))\n\n        def nearest(tree, point):\n            best = None\n            best_d = float('inf')\n            for node in tree:\n                d = dist_sq(node.position, point)\n                if d < best_d:\n                    best = node\n                    best_d = d\n            return best\n\n        def near(tree, point, radius):\n            r_sq = radius * radius\n            result = []\n            for node in tree:\n                if dist_sq(node.position, point) <= r_sq:\n                    result.append(node)\n            return result\n\n        def extract_path(node_from_start, node_from_goal):\n            path_start = []\n            cur = node_from_start\n            while cur:\n                path_start.append(cur.position)\n                cur = cur.parent\n            path_start.reverse()\n            path_goal = []\n            cur = node_from_goal\n            while cur:\n                path_goal.append(cur.position)\n                cur = cur.parent\n            if path_start[-1] == path_goal[0]:\n                path_goal = path_goal[1:]\n            return path_start + path_goal\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            attempts = 0\n            max_attempts = 100\n            res = max(self.step_size / 5.0, 0.2)\n            while attempts < max_attempts and len(path) >= 3:\n                i = random.randint(0, len(path)-3)\n                j = random.randint(i+2, len(path)-1)\n                if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d, resolution=res):\n                    path = path[:i+1] + path[j:]\n                attempts += 1\n            return path\n\n        start_tree = [Node(start_pos, cost=0.0)]\n        goal_tree = [Node(goal_pos, cost=0.0)]\n        nodes = start_tree[:] + goal_tree[:]\n        edges = []\n\n        gamma = 35.0  # adaptive radius constant\n        best_connection = None\n        best_cost = float('inf')\n        found_solution = False\n\n        time_start = time.monotonic()\n\n        for iter_count in range(self.max_iter):\n            if time.monotonic() - time_start > self.time_limit:\n                break\n\n            # Alternate trees\n            tree_a = start_tree if iter_count % 2 == 0 else goal_tree\n            tree_b = goal_tree if iter_count % 2 == 0 else start_tree\n\n            q_rand = sample_free()\n            nearest_a = nearest(tree_a, q_rand)\n            q_new_pos = steer(nearest_a.position, q_rand, self.step_size)\n\n            if self._is_in_obstacle(q_new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_a.position, q_new_pos, obstacles, is_3d, resolution=self.step_size/10):\n                continue\n\n            n = max(len(tree_a), 2)\n            radius = min(self.step_size * 5.0, gamma * (math.log(n) / n) ** (1/dim))\n            radius = max(radius, self.step_size * 1.5)  # ensure minimum radius for rewiring\n\n            neighbors = near(tree_a, q_new_pos, radius)\n\n            min_cost = nearest_a.cost + dist(nearest_a.position, q_new_pos)\n            min_parent = nearest_a\n            for near_n in neighbors:\n                cost_to_new = near_n.cost + dist(near_n.position, q_new_pos)\n                if cost_to_new + 1e-9 < min_cost:\n                    if not self._is_edge_in_obstacle(near_n.position, q_new_pos, obstacles, is_3d, resolution=self.step_size/10):\n                        min_cost = cost_to_new\n                        min_parent = near_n\n\n            new_node = Node(q_new_pos, parent=min_parent, cost=min_cost)\n            min_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((min_parent, new_node))\n\n            # Rewire neighbors\n            for near_n in neighbors:\n                if near_n is min_parent:\n                    continue\n                cost_through_new = new_node.cost + dist(new_node.position, near_n.position)\n                if cost_through_new + 1e-9 < near_n.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near_n.position, obstacles, is_3d, resolution=self.step_size/10):\n                        if near_n.parent:\n                            try:\n                                edges.remove((near_n.parent, near_n))\n                            except ValueError:\n                                pass\n                            near_n.parent.remove_child(near_n)\n                        near_n.parent = new_node\n                        near_n.cost = cost_through_new\n                        new_node.add_child(near_n)\n                        edges.append((new_node, near_n))\n\n            # Try connect to other tree\n            connect_radius = self.step_size * 4.0\n            candidates = near(tree_b, new_node.position, connect_radius)\n            for c in candidates:\n                d = dist(new_node.position, c.position)\n                if d <= connect_radius:\n                    if not self._is_edge_in_obstacle(new_node.position, c.position, obstacles, is_3d, resolution=self.step_size/10):\n                        total_cost = new_node.cost + c.cost + d\n                        if total_cost < best_cost:\n                            best_cost = total_cost\n                            best_connection = (new_node, c)\n                            found_solution = True\n\n            if found_solution:\n                break\n\n        if found_solution and best_connection:\n            extracted_path = extract_path(best_connection[0], best_connection[1])\n            extracted_path = shortcut_path(extracted_path)\n        else:\n            # Fallback partial connection if no full path found\n            min_cost_partial = float('inf')\n            best_pair_partial = None\n            search_radius = self.step_size * 4.0\n            for n1 in start_tree:\n                candidates = near(goal_tree, n1.position, search_radius)\n                for n2 in candidates:\n                    if not self._is_edge_in_obstacle(n1.position, n2.position, obstacles, is_3d, resolution=self.step_size/10):\n                        cost_ = n1.cost + n2.cost + dist(n1.position, n2.position)\n                        if cost_ < min_cost_partial:\n                            min_cost_partial = cost_\n                            best_pair_partial = (n1, n2)\n            if best_pair_partial:\n                extracted_path = extract_path(best_pair_partial[0], best_pair_partial[1])\n                extracted_path = shortcut_path(extracted_path)\n                found_solution = True\n            else:\n                extracted_path = []\n\n        return PlannerResult(\n            success=found_solution,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -28.687,
          "time_improvement": 39.0,
          "length_improvement": 15.0,
          "smoothness_improvement": 1654.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.022521281242370607,
                    "num_nodes_avg": 116.4,
                    "path_length_avg": 169.51336511904668,
                    "smoothness_avg": 0.03893990446828376,
                    "success_improvement": 0.0,
                    "time_improvement": 10.75255711826518,
                    "length_improvement": 7.087038467088057,
                    "smoothness_improvement": 509.4940642846131,
                    "objective_score": 10.025460537155453
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.04739372730255127,
                    "num_nodes_avg": 283.9,
                    "path_length_avg": 237.0595338731959,
                    "smoothness_avg": 0.12088341385225838,
                    "success_improvement": 0.0,
                    "time_improvement": 71.09092707132022,
                    "length_improvement": 20.862704212777263,
                    "smoothness_improvement": 3010.4173072222584,
                    "objective_score": 48.896987185173714
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.03233258724212647,
                    "num_nodes_avg": 197.6,
                    "path_length_avg": 126.4366397151005,
                    "smoothness_avg": 0.12128219869438872,
                    "success_improvement": 0.0,
                    "time_improvement": 34.36324027435144,
                    "length_improvement": 16.026804167025343,
                    "smoothness_improvement": 1442.7006152719268,
                    "objective_score": 27.138557658880273
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "A simplified bidirectional RRT* variant with adaptive rewiring radius, goal bias sampling with retry limits, and incremental path improvement leveraging efficient neighbor searches. The planner grows two trees from start and goal alternately, rewiring nearby nodes for cost improvement, connecting trees within a dynamic radius, and performing lightweight shortcutting focused on removing redundancies. A strict 30-second wall-clock timer ensures timely termination with the best path found so far.",
          "planning_mechanism": "A bi-directional RRT* approach sampling free configurations with a fallback retry limit, expanding trees with bounded steering, rewiring neighbors within an adaptive radius logarithmically scaled by tree size, attempting connection candidates between trees in an expanded radius, and incrementally shortcutting the best path on improvements. Early stopping occurs upon finding a better connection for efficient planning.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, goal_sample_rate: float = 0.2):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.time_limit = 30.0\n\n    def plan(self, map) -> 'PlannerResult':\n        import time\n        import math\n        import random\n\n        bounds = map.size\n        dim = len(bounds)\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = dim == 3\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def dist_sq(a, b):\n            return sum((a[i] - b[i]) ** 2 for i in range(dim))\n\n        def sample_free():\n            if random.random() < self.goal_sample_rate:\n                return goal_pos\n            for _ in range(30):\n                p = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n            return goal_pos\n\n        def steer(from_p, to_p, max_step):\n            d = dist(from_p, to_p)\n            if d <= max_step:\n                return to_p\n            ratio = max_step / d\n            return tuple(from_p[i] + (to_p[i] - from_p[i]) * ratio for i in range(dim))\n\n        def nearest(tree, point):\n            best_node = None\n            best_dist_sq = float('inf')\n            for n in tree:\n                d2 = dist_sq(n.position, point)\n                if d2 < best_dist_sq:\n                    best_dist_sq = d2\n                    best_node = n\n            return best_node\n\n        def near(tree, point, radius):\n            r_sq = radius * radius\n            res = []\n            for n in tree:\n                d2 = dist_sq(n.position, point)\n                if d2 <= r_sq:\n                    res.append((d2, n))\n            res.sort(key=lambda x: x[0])\n            return [e[1] for e in res]\n\n        def extract_path(node_start, node_goal):\n            path_start = []\n            cur = node_start\n            while cur:\n                path_start.append(cur.position)\n                cur = cur.parent\n            path_goal = []\n            cur = node_goal\n            while cur:\n                path_goal.append(cur.position)\n                cur = cur.parent\n            return path_start[::-1] + path_goal\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            attempts = 0\n            max_attempts = 100\n            while attempts < max_attempts and len(path) >= 3:\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                    path = path[:i + 1] + path[j:]\n                attempts += 1\n            return path\n\n        def try_connect(new_node, other_tree, radius):\n            candidates = near(other_tree, new_node.position, radius)\n            best_node = None\n            best_cost = float('inf')\n            for c in candidates:\n                d = dist(new_node.position, c.position)\n                if d <= radius and not self._is_edge_in_obstacle(new_node.position, c.position, obstacles, is_3d):\n                    total_cost = new_node.cost + c.cost + d\n                    if total_cost < best_cost:\n                        best_cost = total_cost\n                        best_node = c\n            return best_node, best_cost\n\n        start_tree = [Node(start_pos, cost=0.0)]\n        goal_tree = [Node(goal_pos, cost=0.0)]\n        nodes = start_tree[:] + goal_tree[:]\n        edges = []\n\n        gamma = 35.0\n        best_connection = None\n        best_cost = float('inf')\n        success = False\n\n        start_time = time.monotonic()\n\n        for it in range(self.max_iter):\n            if time.monotonic() - start_time > self.time_limit:\n                break\n\n            tree_a, tree_b = (start_tree, goal_tree) if it % 2 == 0 else (goal_tree, start_tree)\n\n            sample = sample_free()\n            nearest_node = nearest(tree_a, sample)\n            new_pos = steer(nearest_node.position, sample, self.step_size)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            n_nodes = len(tree_a) + 1\n            radius = min(self.step_size * 5,\n                         gamma * (math.log(max(n_nodes, 2)) / n_nodes) ** (1 / dim))\n\n            near_nodes = near(tree_a, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            min_parent = nearest_node\n            for near_node in near_nodes:\n                new_cost = near_node.cost + dist(near_node.position, new_pos)\n                if new_cost + 1e-9 < min_cost:\n                    if not self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d):\n                        min_cost = new_cost\n                        min_parent = near_node\n\n            new_node = Node(new_pos, parent=min_parent, cost=min_cost)\n            min_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((min_parent, new_node))\n\n            # Rewire neighbors\n            for near_node in near_nodes:\n                if near_node is min_parent:\n                    continue\n                rewired_cost = new_node.cost + dist(new_node.position, near_node.position)\n                if rewired_cost + 1e-9 < near_node.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                        if near_node.parent is not None:\n                            try:\n                                edges.remove((near_node.parent, near_node))\n                            except ValueError:\n                                pass\n                            near_node.parent.remove_child(near_node)\n                        near_node.parent = new_node\n                        near_node.cost = rewired_cost\n                        new_node.add_child(near_node)\n                        edges.append((new_node, near_node))\n\n            # Try connecting opposite tree\n            connect_radius = self.step_size * 3.0\n            conn_node, conn_cost = try_connect(new_node, tree_b, connect_radius)\n            if conn_node is not None and conn_cost < best_cost:\n                best_cost = conn_cost\n                best_connection = (new_node, conn_node)\n                success = True\n                # Early stop for efficiency\n                break\n\n            # Periodic shortcutting\n            if it % 100 == 0 and success and best_connection:\n                path = extract_path(best_connection[0], best_connection[1])\n                path = shortcut_path(path)\n                extracted_path = path\n\n        if success and best_connection:\n            extracted_path = extract_path(best_connection[0], best_connection[1])\n            extracted_path = shortcut_path(extracted_path)\n        else:\n            # Attempt partial connection fallback\n            min_cost = float('inf')\n            best_pair = None\n            for n1 in start_tree:\n                candidates = near(goal_tree, n1.position, self.step_size * 3.0)\n                for n2 in candidates:\n                    d = dist(n1.position, n2.position)\n                    if d <= self.step_size * 3.0 and not self._is_edge_in_obstacle(n1.position, n2.position, obstacles, is_3d):\n                        total_c = n1.cost + n2.cost + d\n                        if total_c < min_cost:\n                            min_cost = total_c\n                            best_pair = (n1, n2)\n            if best_pair:\n                extracted_path = extract_path(best_pair[0], best_pair[1])\n                extracted_path = shortcut_path(extracted_path)\n                success = True\n\n        if not success:\n            extracted_path = []\n\n        return PlannerResult(\n            success=success,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=None):\n        import math\n        if resolution is None:\n            resolution = max(0.5, self.step_size / 5)\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -28.40282,
          "time_improvement": 39.0,
          "length_improvement": 15.0,
          "smoothness_improvement": 1467.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.01759207248687744,
                    "num_nodes_avg": 97.3,
                    "path_length_avg": 166.84842552375585,
                    "smoothness_avg": 0.035136022645855615,
                    "success_improvement": 0.0,
                    "time_improvement": 30.286049556980327,
                    "length_improvement": 8.547734087937185,
                    "smoothness_improvement": 449.95505350202524,
                    "objective_score": 16.464230587366536
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.08978750705718994,
                    "num_nodes_avg": 336.1,
                    "path_length_avg": 237.11037975476998,
                    "smoothness_avg": 0.09784145923876689,
                    "success_improvement": 0.0,
                    "time_improvement": 45.23170602239328,
                    "length_improvement": 20.84573039399028,
                    "smoothness_improvement": 2417.5312185680477,
                    "objective_score": 38.16460613595239
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.028477692604064943,
                    "num_nodes_avg": 173.7,
                    "path_length_avg": 124.84088433642191,
                    "smoothness_avg": 0.12847531178014862,
                    "success_improvement": 0.0,
                    "time_improvement": 42.18886806068799,
                    "length_improvement": 17.08662890783816,
                    "smoothness_improvement": 1534.1964827824138,
                    "objective_score": 30.579620176821365
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m1",
          "algorithm_description": "A bidirectional RRT* planner with adaptive rewiring radius and iterative incremental shortcutting, enhanced via goal-biased sampling and multiple progressive connection attempts across trees. The planner incorporates efficient parent selection and rewiring based on cost, uses dynamically computed neighborhoods that scale logarithmically with the number of nodes to optimize exploration-exploitation tradeoff, and applies frequent path shortcutting throughout the planning to improve path smoothness and length. It enforces a strict 30-second time limit, early terminates on improved solutions, and maintains consistent collision checking tailored to step size.",
          "planning_mechanism": "A bidirectional RRT* framework alternately grows two trees from start and goal, sampling with a fixed goal bias. Each new sampled point is extended from the nearest node with a fixed step size, with parent selection and rewiring performed among adaptively computed neighbors to improve path cost. Multiple candidate nodes from the opposite tree within a connection radius are attempted to connect new nodes, allowing earlier discovery of feasible low-cost paths. An incremental shortcutting routine is run periodically and at the end to smooth and shorten the best found path. The planner tracks and returns the best solution found within a 30-second wall-clock limit, or partial path if no full path is found.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent: Optional[\"Node\"]=None, cost: float=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children: List[\"Node\"] = []\n        self.valid = True\n\n    def add_child(self, child: \"Node\"):\n        self.children.append(child)\n\n    def remove_child(self, child: \"Node\"):\n        if child in self.children:\n            self.children.remove(child)\nclass Planner:\n    def __init__(self, max_iter: int=5000, step_size: float=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.time_limit = 30.0\n        self.goal_sample_rate = 0.15  # 15% samples from goal to bias sampling\n        self.gamma = 30.0  # rewiring radius multiplier\n        self.shortcut_interval = 50  # iterations between shortcut runs\n        self.max_shortcut_attempts = 40\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        start_tree: List[Node] = [Node(start_pos, cost=0.0)]\n        goal_tree: List[Node] = [Node(goal_pos, cost=0.0)]\n        nodes: List[Node] = start_tree[:] + goal_tree[:]\n        edges: List[Tuple[Node, Node]] = []\n\n        best_cost = float('inf')\n        best_connection: Optional[Tuple[Node, Node]] = None\n        success = False\n        extracted_path: List[Tuple[float, ...]] = []\n\n        start_time = time.monotonic()\n        iter_since_shortcut = 0\n\n        def dist(a: Tuple[float, ...], b: Tuple[float, ...]) -> float:\n            return math.dist(a, b)\n\n        def sample_free():\n            if random.random() < self.goal_sample_rate:\n                return goal_pos\n            for _ in range(100):\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(sample, obstacles, is_3d):\n                    return sample\n            return goal_pos  # fallback if no free sample found\n\n        def nearest(tree: List[Node], pt: Tuple[float, ...]) -> Node:\n            best_node = None\n            best_dist = float('inf')\n            for node in tree:\n                d = dist(node.position, pt)\n                if d < best_dist:\n                    best_node = node\n                    best_dist = d\n            return best_node\n\n        def near(tree: List[Node], pt: Tuple[float, ...], radius: float) -> List[Node]:\n            def dist_node(n: Node):\n                return dist(n.position, pt)\n            neighbors = [n for n in tree if dist(n.position, pt) <= radius]\n            neighbors.sort(key=dist_node)\n            return neighbors\n\n        def steer(from_p: Tuple[float, ...], to_p: Tuple[float, ...], max_step: float) -> Tuple[float, ...]:\n            d = dist(from_p, to_p)\n            if d <= max_step:\n                return to_p\n            ratio = max_step / d\n            return tuple(from_p[i] + (to_p[i] - from_p[i]) * ratio for i in range(dim))\n\n        def extract_path(node_start: Node, node_goal: Node) -> List[Tuple[float, ...]]:\n            path_start = []\n            cur = node_start\n            while cur is not None:\n                path_start.append(cur.position)\n                cur = cur.parent\n            path_start.reverse()\n\n            path_goal = []\n            cur = node_goal\n            while cur is not None:\n                path_goal.append(cur.position)\n                cur = cur.parent\n            if path_start and path_goal and path_start[-1] == path_goal[0]:\n                path_goal = path_goal[1:]\n            return path_start + path_goal\n\n        def shortcut_path(path: List[Tuple[float, ...]], max_attempts: int) -> List[Tuple[float, ...]]:\n            if len(path) < 3:\n                return path\n            for _ in range(max_attempts):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution=max(self.step_size*0.2, 0.2)):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        def try_connect(new_node: Node, other_tree: List[Node], radius: float) -> Tuple[Optional[Node], float]:\n            candidates = near(other_tree, new_node.position, radius)\n            best_cand = None\n            best_local_cost = float('inf')\n            for node in candidates:\n                d12 = dist(new_node.position, node.position)\n                if d12 <= radius and not self._is_edge_in_obstacle(new_node.position, node.position, obstacles, is_3d, resolution=max(self.step_size*0.2, 0.2)):\n                    cost_sum = new_node.cost + d12 + node.cost\n                    if cost_sum < best_local_cost:\n                        best_local_cost = cost_sum\n                        best_cand = node\n            return best_cand, best_local_cost\n\n        def rewire(tree: List[Node], new_node: Node, neighbors: List[Node]):\n            for nbr in neighbors:\n                if nbr is new_node.parent:\n                    continue\n                cost_through_new = new_node.cost + dist(new_node.position, nbr.position)\n                if cost_through_new + 1e-9 < nbr.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, nbr.position, obstacles, is_3d, resolution=max(self.step_size*0.2, 0.2)):\n                        # Remove old edge\n                        if nbr.parent:\n                            try:\n                                edges.remove((nbr.parent, nbr))\n                            except ValueError:\n                                pass\n                            nbr.parent.remove_child(nbr)\n                        # Reassign parent and cost\n                        nbr.parent = new_node\n                        nbr.cost = cost_through_new\n                        new_node.add_child(nbr)\n                        edges.append((new_node, nbr))\n\n        for it in range(self.max_iter):\n            if time.monotonic() - start_time > self.time_limit:\n                break\n\n            tree_a = start_tree if (it % 2 == 0) else goal_tree\n            tree_b = goal_tree if (it % 2 == 0) else start_tree\n\n            sample = sample_free()\n            nearest_node = nearest(tree_a, sample)\n            new_pos = steer(nearest_node.position, sample, self.step_size)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d, resolution=max(self.step_size*0.2, 0.2)):\n                continue\n\n            n_nodes = len(tree_a) + 1\n            radius = self.gamma * ((math.log(n_nodes)/n_nodes) ** (1/dim)) if n_nodes > 1 else self.step_size*5\n            radius = min(radius, self.step_size*5)\n            radius = max(radius, self.step_size)\n\n            neighbors = near(tree_a, new_pos, radius)\n\n            # Select parent with minimal cost\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            min_parent = nearest_node\n            for nb in neighbors:\n                if not self._is_edge_in_obstacle(nb.position, new_pos, obstacles, is_3d, resolution=max(self.step_size*0.2, 0.2)):\n                    cost_cand = nb.cost + dist(nb.position, new_pos)\n                    if cost_cand + 1e-9 < min_cost:\n                        min_cost = cost_cand\n                        min_parent = nb\n\n            new_node = Node(new_pos, parent=min_parent, cost=min_cost)\n            min_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((min_parent, new_node))\n\n            rewire(tree_a, new_node, neighbors)\n\n            conn_node, conn_cost = try_connect(new_node, tree_b, radius*1.2)\n            if conn_node is not None and conn_cost + 1e-9 < best_cost:\n                success = True\n                best_cost = conn_cost\n                best_connection = (new_node, conn_node) if it % 2 == 0 else (conn_node, new_node)\n                # Early termination on improvement\n                break\n\n            iter_since_shortcut += 1\n            if iter_since_shortcut >= self.shortcut_interval and success and best_connection is not None:\n                current_path = extract_path(best_connection[0], best_connection[1])\n                shortened = shortcut_path(current_path, max_attempts=self.max_shortcut_attempts)\n                if len(shortened) < len(current_path):\n                    extracted_path = shortened\n                iter_since_shortcut = 0\n\n        if success and best_connection is not None:\n            extracted_path = extract_path(best_connection[0], best_connection[1])\n            extracted_path = shortcut_path(extracted_path, max_attempts=self.max_shortcut_attempts*2)\n        else:\n            # Try partial connection fallback\n            best_partial_cost = float('inf')\n            best_pair = None\n            search_radius = self.step_size * 3\n            for n_start in start_tree:\n                candidates = near(goal_tree, n_start.position, search_radius)\n                for n_goal in candidates:\n                    d12 = dist(n_start.position, n_goal.position)\n                    if d12 <= search_radius:\n                        if not self._is_edge_in_obstacle(n_start.position, n_goal.position, obstacles, is_3d, resolution=max(self.step_size*0.2, 0.2)):\n                            cost_sum = n_start.cost + d12 + n_goal.cost\n                            if cost_sum < best_partial_cost:\n                                best_partial_cost = cost_sum\n                                best_pair = (n_start, n_goal)\n            if best_pair:\n                success = True\n                extracted_path = extract_path(best_pair[0], best_pair[1])\n                extracted_path = shortcut_path(extracted_path, max_attempts=self.max_shortcut_attempts*2)\n\n        return PlannerResult(\n            success=success,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos: Tuple[float, ...], obstacles, is_3d: bool) -> bool:\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos: Tuple[float, ...], to_pos: Tuple[float, ...], obstacles, is_3d: bool, resolution=1.0) -> bool:\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -28.23296,
          "time_improvement": 40.0,
          "length_improvement": 15.0,
          "smoothness_improvement": 1447.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.02250080108642578,
                    "num_nodes_avg": 133.2,
                    "path_length_avg": 174.10583657328837,
                    "smoothness_avg": 0.03533155704968899,
                    "success_improvement": 0.0,
                    "time_improvement": 10.833715979886968,
                    "length_improvement": 4.569832090651076,
                    "smoothness_improvement": 453.0155915317716,
                    "objective_score": 8.257092006015593
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.048084449768066403,
                    "num_nodes_avg": 365.9,
                    "path_length_avg": 238.06975876056944,
                    "smoothness_avg": 0.09827401173992896,
                    "success_improvement": 0.0,
                    "time_improvement": 70.66960240948086,
                    "length_improvement": 20.52546206766085,
                    "smoothness_improvement": 2428.661105977921,
                    "objective_score": 45.65946349333038
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.029903388023376463,
                    "num_nodes_avg": 270.1,
                    "path_length_avg": 121.21919591756429,
                    "smoothness_avg": 0.12262243997404691,
                    "success_improvement": 0.0,
                    "time_improvement": 39.29463547179747,
                    "length_improvement": 19.4919819093734,
                    "smoothness_improvement": 1459.748385422858,
                    "objective_score": 30.782321714277572
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "A simplified yet robust bidirectional RRT* planner emphasizing straightforward uniform sampling with fixed goal bias, fixed step size steering, adaptive neighborhood radius for rewiring, and straightforward balanced tree growth. The algorithm performs rewiring based on local neighborhoods using efficient squared distance checks, employs early stopping upon first improved connection, and applies iterative path shortcutting after planning to improve smoothness and length. It respects a strict 30-second time limit and consistently checks for node and edge collisions within given map bounds and obstacles.",
          "planning_mechanism": "A bidirectional RRT* grows two trees from start and goal alternately by sampling free points with a fixed goal bias. For each iteration, it selects the nearest node, steers within a fixed step, validates collision-free placement, chooses minimal cost parent from neighbors within an adaptive radius, rewires neighbors, and attempts connections to the opposite tree for potentially shorter paths. Once a connection is found, it stops early. The extracted path is shortcut iteratively to smooth and shorten before returning.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n        if parent is not None:\n            parent.children.append(self)\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\nclass Planner:\n    def __init__(self, max_iter: int=5000, step_size: float=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.time_limit = 30.0\n        self.goal_sample_rate = 0.2  # Fixed moderate goal bias\n\n    def plan(self, map) -> \"PlannerResult\":\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        nodes_start = [Node(start_pos, cost=0.0)]\n        nodes_goal = [Node(goal_pos, cost=0.0)]\n        all_nodes = nodes_start[:] + nodes_goal[:]\n        edges = []\n\n        best_connection = None\n        best_cost = float('inf')\n        success = False\n        extracted_path = []\n\n        gamma = 20.0  # adaptive neighbor radius constant\n\n        import time\n        import random\n        import math\n\n        def dist_sq(a, b):\n            s = 0.0\n            for i in range(dim):\n                d = a[i] - b[i]\n                s += d * d\n            return s\n\n        def dist(a, b):\n            return math.sqrt(dist_sq(a, b))\n\n        def in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d = obs\n                    px,py,pz = pos\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                        return True\n                else:\n                    x,y,w_,h_ = obs\n                    px,py = pos\n                    if x <= px <= x+w_ and y <= py <= y+h_:\n                        return True\n            return False\n\n        def edge_in_obstacle(a,b,resolution=1.0):\n            length = dist(a,b)\n            steps = max(1, int(length / resolution))\n            for i in range(steps + 1):\n                interp = tuple(a[d] + (b[d] - a[d]) * i / steps for d in range(dim))\n                if in_obstacle(interp):\n                    return True\n            return False\n\n        def sample_free():\n            if random.random() < self.goal_sample_rate and not in_obstacle(goal_pos):\n                return goal_pos\n            for _ in range(30):  # limited retries to find free point\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not in_obstacle(sample):\n                    return sample\n            return goal_pos  # fallback\n\n        def steer(from_p, to_p, max_step):\n            d = dist(from_p, to_p)\n            if d <= max_step:\n                return to_p\n            ratio = max_step / d\n            return tuple(from_p[i] + ratio*(to_p[i] - from_p[i]) for i in range(dim))\n\n        def nearest(tree, point):\n            best_node = None\n            best_dist = float('inf')\n            for node in tree:\n                d = dist_sq(node.position, point)\n                if d < best_dist:\n                    best_dist = d\n                    best_node = node\n            return best_node\n\n        def near(tree, point, radius):\n            r_sq = radius * radius\n            neighbors = []\n            for node in tree:\n                d = dist_sq(node.position, point)\n                if d <= r_sq:\n                    neighbors.append((d, node))\n            neighbors.sort(key=lambda x: x[0])\n            return [n[1] for n in neighbors]\n\n        def extract_path(node_start, node_goal):\n            path_start = []\n            cur = node_start\n            while cur is not None:\n                path_start.append(cur.position)\n                cur = cur.parent\n            path_start.reverse()\n\n            path_goal = []\n            cur = node_goal\n            while cur is not None:\n                path_goal.append(cur.position)\n                cur = cur.parent\n\n            # Avoid duplicate at connection point\n            if path_start and path_goal and path_start[-1] == path_goal[0]:\n                path_goal = path_goal[1:]\n\n            return path_start + path_goal\n\n        def shortcut_path(path, max_attempts=50):\n            if len(path) < 3:\n                return path\n            resolution = max(self.step_size*0.2, 0.2)\n            for _ in range(max_attempts):\n                if len(path)<3:\n                    break\n                i = random.randint(0,len(path)-3)\n                j = random.randint(i+2, len(path)-1)\n                p1, p2 = path[i], path[j]\n                if not edge_in_obstacle(p1, p2, resolution=resolution):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        def rewire(tree, new_node, neighbors):\n            for nb in neighbors:\n                if nb is new_node.parent:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, nb.position)\n                if new_cost + 1e-9 < nb.cost:\n                    if not edge_in_obstacle(new_node.position, nb.position, resolution=max(self.step_size*0.2, 0.2)):\n                        # Remove old edge\n                        if nb.parent:\n                            try:\n                                edges.remove((nb.parent, nb))\n                            except Exception:\n                                pass\n                            nb.parent.remove_child(nb)\n                        nb.parent = new_node\n                        nb.cost = new_cost\n                        new_node.add_child(nb)\n                        edges.append((new_node, nb))\n\n        start_time = time.monotonic()\n\n        for it in range(self.max_iter):\n            if time.monotonic() - start_time > self.time_limit:\n                break\n\n            tree_a = nodes_start if it % 2 == 0 else nodes_goal\n            tree_b = nodes_goal if it % 2 == 0 else nodes_start\n\n            q_rand = sample_free()\n            nearest_node = nearest(tree_a, q_rand)\n            q_new = steer(nearest_node.position, q_rand, self.step_size)\n\n            if in_obstacle(q_new):\n                continue\n            if edge_in_obstacle(nearest_node.position, q_new, resolution=max(self.step_size*0.2, 0.2)):\n                continue\n\n            n_nodes = max(len(tree_a), 2)\n            radius = gamma * (math.log(n_nodes) / n_nodes) ** (1/dim)\n            radius = min(radius, self.step_size * 5.0)\n            radius = max(radius, self.step_size)\n\n            neighbors = near(tree_a, q_new, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, q_new)\n            min_parent = nearest_node\n            for nb in neighbors:\n                cost_candidate = nb.cost + dist(nb.position, q_new)\n                if cost_candidate + 1e-9 < min_cost:\n                    if not edge_in_obstacle(nb.position, q_new, resolution=max(self.step_size*0.2, 0.2)):\n                        min_cost = cost_candidate\n                        min_parent = nb\n\n            new_node = Node(q_new, parent=min_parent, cost=min_cost)\n            min_parent.add_child(new_node)\n            tree_a.append(new_node)\n            all_nodes.append(new_node)\n            edges.append((min_parent, new_node))\n\n            rewire(tree_a, new_node, neighbors)\n\n            # Try connecting new node to opposite tree within connection radius\n            conn_radius = self.step_size * 3.0\n            candidates = near(tree_b, q_new, conn_radius)\n            for cand in candidates:\n                d = dist(q_new, cand.position)\n                total_cost = new_node.cost + d + cand.cost\n                if d <= conn_radius:\n                    if not edge_in_obstacle(q_new, cand.position, resolution=max(self.step_size*0.2, 0.2)):\n                        if total_cost + 1e-9 < best_cost:\n                            best_cost = total_cost\n                            best_connection = (new_node, cand) if it % 2 == 0 else (cand, new_node)\n                            success = True\n                            break\n            if success:\n                break\n\n        if success and best_connection:\n            extracted_path = extract_path(best_connection[0], best_connection[1])\n            extracted_path = shortcut_path(extracted_path, max_attempts=75)\n        else:\n            # Attempt best partial connection if none found during planning\n            partial_best_cost = float('inf')\n            partial_best_pair = None\n            search_radius = self.step_size * 3.0\n            for n1 in nodes_start:\n                candidates = near(nodes_goal, n1.position, search_radius)\n                for n2 in candidates:\n                    d = dist(n1.position, n2.position)\n                    if d <= search_radius:\n                        if not edge_in_obstacle(n1.position, n2.position, resolution=max(self.step_size*0.2, 0.2)):\n                            total_c = n1.cost + d + n2.cost\n                            if total_c + 1e-9 < partial_best_cost:\n                                partial_best_cost = total_c\n                                partial_best_pair = (n1, n2)\n            if partial_best_pair:\n                success = True\n                extracted_path = extract_path(partial_best_pair[0], partial_best_pair[1])\n                extracted_path = shortcut_path(extracted_path, max_attempts=75)\n\n        return PlannerResult(\n            success=success,\n            path=extracted_path,\n            nodes=all_nodes,\n            edges=edges\n        )",
          "objective": -27.83376,
          "time_improvement": 48.0,
          "length_improvement": 11.0,
          "smoothness_improvement": 1324.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.01609756946563721,
                    "num_nodes_avg": 135.5,
                    "path_length_avg": 184.8332243491587,
                    "smoothness_avg": 0.03086306725261622,
                    "success_improvement": 0.0,
                    "time_improvement": 36.20847340086809,
                    "length_improvement": -1.3100191356406912,
                    "smoothness_improvement": 383.0740227266788,
                    "objective_score": 11.991900652509404
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.04894397258758545,
                    "num_nodes_avg": 319.8,
                    "path_length_avg": 237.90478476222106,
                    "smoothness_avg": 0.09262523432178901,
                    "success_improvement": 0.0,
                    "time_improvement": 70.14531345211068,
                    "length_improvement": 20.580535136822796,
                    "smoothness_improvement": 2283.313994359262,
                    "objective_score": 44.80848508952319
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.030251622200012207,
                    "num_nodes_avg": 246.1,
                    "path_length_avg": 128.9811592554924,
                    "smoothness_avg": 0.11041682931190652,
                    "success_improvement": 0.0,
                    "time_improvement": 38.58770277850781,
                    "length_improvement": 14.336855445297012,
                    "smoothness_improvement": 1304.4939187248963,
                    "objective_score": 26.70089369435503
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "A streamlined bidirectional RRT* planner that grows two trees from start and goal points by iterative sampling with goal bias, adaptive neighborhood radius rewiring based on tree size, and collision-checked extensions. It attempts connections between trees with an extended radius and performs lightweight path shortcutting only after path discovery. The planner enforces a hard 30-second limit and returns the best found path with improved efficiency, shorter length, and smoother trajectories.",
          "planning_mechanism": "The planner alternately samples free configurations biased toward the goal, extends the current tree toward samples using a fixed step size, rewires neighbors within an adaptive radius computed from the number of nodes and dimension, and tries connecting to the opposite tree within a radius. Upon finding a valid connection, it stores the best path and applies path shortcutting only once after planning completes or time expires, ensuring rapid convergence and improved path quality.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=5.0, goal_sample_rate=0.15):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.time_limit = 30.0\n\n    def plan(self, map):\n        import time\n        import math\n        import random\n\n        bounds = map.size\n        dim = len(bounds)\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = (dim == 3)\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def sample_free():\n            if random.random() < self.goal_sample_rate:\n                return goal_pos\n            for _ in range(30):\n                p = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n            return goal_pos\n\n        def steer(from_p, to_p, max_step):\n            d = dist(from_p, to_p)\n            if d <= max_step:\n                return to_p\n            ratio = max_step / d\n            return tuple(from_p[i] + (to_p[i] - from_p[i]) * ratio for i in range(dim))\n\n        def nearest(tree, point):\n            best_node = None\n            best_dist_sq = float('inf')\n            for n in tree:\n                d_sq = sum((n.position[i] - point[i]) ** 2 for i in range(dim))\n                if d_sq < best_dist_sq:\n                    best_dist_sq = d_sq\n                    best_node = n\n            return best_node\n\n        def near(tree, point, radius):\n            rsq = radius * radius\n            neighbors = []\n            for n in tree:\n                d_sq = sum((n.position[i] - point[i]) ** 2 for i in range(dim))\n                if d_sq <= rsq:\n                    neighbors.append((d_sq, n))\n            neighbors.sort(key=lambda x: x[0])\n            return [n[1] for n in neighbors]\n\n        def extract_path(n_start, n_goal):\n            path_start = []\n            cur = n_start\n            while cur:\n                path_start.append(cur.position)\n                cur = cur.parent\n            path_start.reverse()\n            path_goal = []\n            cur = n_goal\n            while cur:\n                path_goal.append(cur.position)\n                cur = cur.parent\n            if path_start[-1] == path_goal[0]:\n                path_goal = path_goal[1:]\n            return path_start + path_goal\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            attempts = 0\n            max_attempts = 100\n            while attempts < max_attempts and len(path) >= 3:\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                    path = path[:i + 1] + path[j:]\n                attempts += 1\n            return path\n\n        def try_connect(new_node, other_tree, radius):\n            candidates = near(other_tree, new_node.position, radius)\n            best_cand = None\n            best_cost = float('inf')\n            for c in candidates:\n                d = dist(new_node.position, c.position)\n                if d <= radius and not self._is_edge_in_obstacle(new_node.position, c.position, obstacles, is_3d):\n                    cost = new_node.cost + c.cost + d\n                    if cost < best_cost:\n                        best_cost = cost\n                        best_cand = c\n            return best_cand, best_cost\n\n        start_tree = [Node(start_pos, cost=0.0)]\n        goal_tree = [Node(goal_pos, cost=0.0)]\n        nodes = start_tree[:] + goal_tree[:]\n        edges = []\n\n        gamma = 35.0\n        best_connection = None\n        best_cost = float('inf')\n        success = False\n\n        start_time = time.monotonic()\n\n        for it in range(self.max_iter):\n            if time.monotonic() - start_time > self.time_limit:\n                break\n\n            tree_a, tree_b = (start_tree, goal_tree) if it % 2 == 0 else (goal_tree, start_tree)\n\n            sample = sample_free()\n            nearest_node = nearest(tree_a, sample)\n            new_pos = steer(nearest_node.position, sample, self.step_size)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            n = len(tree_a) + 1\n            radius = min(self.step_size * 5,\n                         gamma * (math.log(max(n, 2)) / n) ** (1 / dim))\n\n            near_nodes = near(tree_a, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            min_parent = nearest_node\n            for near_node in near_nodes:\n                new_cost = near_node.cost + dist(near_node.position, new_pos)\n                if new_cost < min_cost:\n                    if not self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d):\n                        min_cost = new_cost\n                        min_parent = near_node\n\n            new_node = Node(new_pos, parent=min_parent, cost=min_cost)\n            min_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((min_parent, new_node))\n\n            for near_node in near_nodes:\n                if near_node is min_parent:\n                    continue\n                rewired_cost = new_node.cost + dist(new_node.position, near_node.position)\n                if rewired_cost < near_node.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                        if near_node.parent:\n                            try:\n                                edges.remove((near_node.parent, near_node))\n                            except ValueError:\n                                pass\n                            near_node.parent.remove_child(near_node)\n                        near_node.parent = new_node\n                        near_node.cost = rewired_cost\n                        new_node.add_child(near_node)\n                        edges.append((new_node, near_node))\n\n            conn_node, conn_cost = try_connect(new_node, tree_b, self.step_size * 3.0)\n            if conn_node and conn_cost < best_cost:\n                best_cost = conn_cost\n                best_connection = (new_node, conn_node)\n                success = True\n                # Early stopping for efficiency\n                break\n\n        if success and best_connection:\n            path = extract_path(best_connection[0], best_connection[1])\n            path = shortcut_path(path)\n        else:\n            # Partial connection fallback\n            min_cost = float('inf')\n            best_pair = None\n            for n1 in start_tree:\n                candidates = near(goal_tree, n1.position, self.step_size * 3.0)\n                for n2 in candidates:\n                    d = dist(n1.position, n2.position)\n                    if d <= self.step_size * 3.0 and not self._is_edge_in_obstacle(n1.position, n2.position, obstacles, is_3d):\n                        cost = n1.cost + n2.cost + d\n                        if cost < min_cost:\n                            min_cost = cost\n                            best_pair = (n1, n2)\n            if best_pair:\n                path = extract_path(best_pair[0], best_pair[1])\n                path = shortcut_path(path)\n                success = True\n            else:\n                path = []\n\n        return PlannerResult(\n            success=success,\n            path=path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=None):\n        import math\n        if resolution is None:\n            resolution = max(0.5, self.step_size / 5)\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -27.74825,
          "time_improvement": 40.0,
          "length_improvement": 15.0,
          "smoothness_improvement": 1335.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.019061350822448732,
                    "num_nodes_avg": 114.5,
                    "path_length_avg": 170.6394137840905,
                    "smoothness_avg": 0.04178132687174441,
                    "success_improvement": 0.0,
                    "time_improvement": 24.463586220188997,
                    "length_improvement": 6.4698333503945955,
                    "smoothness_improvement": 553.9684951462797,
                    "objective_score": 13.990818352024853
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.07259199619293213,
                    "num_nodes_avg": 321.5,
                    "path_length_avg": 239.4914611910675,
                    "smoothness_avg": 0.08843483732520492,
                    "success_improvement": 0.0,
                    "time_improvement": 55.72056828147064,
                    "length_improvement": 20.050856874925092,
                    "smoothness_improvement": 2175.4920614161942,
                    "objective_score": 39.62414491647722
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.02925105094909668,
                    "num_nodes_avg": 195.0,
                    "path_length_avg": 122.79799507744235,
                    "smoothness_avg": 0.10814640237504218,
                    "success_improvement": 0.0,
                    "time_improvement": 40.61891216775107,
                    "length_improvement": 18.443418681719525,
                    "smoothness_improvement": 1275.6142556734658,
                    "objective_score": 29.629796137724362
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "initial",
          "algorithm_description": "This algorithm is a bidirectional extension of RRT* that grows two trees from start and goal while optimizing paths via rewiring. It combines RRT*\u2018s asymptotic optimality with RRT-Connect\u2019s fast convergence through connection attempts between the trees.",
          "planning_mechanism": "The planner alternates growing two trees with sampling, extension, and rewiring. After each extension, it attempts to connect both trees. When connection is successful, a rewired optimal path is extracted across both trees.",
          "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, radius: float = 10.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.radius = radius\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n        nodes = []\n        edges = []\n        success_state = False\n        extracted_path = []\n\n        for iter in range(self.max_iter):\n            rand = self._sample_free(bounds, obstacles, is_3d)\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest = self._nearest(tree_a, rand)\n                new_pos = self._steer(nearest.position, rand, self.step_size)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                    continue\n\n                new_node = Node(new_pos)\n                near_nodes = self._near(tree_a, new_pos, self.radius)\n                min_cost = nearest.cost + self._distance(nearest.position, new_pos)\n                min_parent = nearest\n\n                for near in near_nodes:\n                    cost = near.cost + self._distance(near.position, new_pos)\n                    if cost < min_cost and not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d):\n                        min_cost = cost\n                        min_parent = near\n\n                new_node.parent = min_parent\n                new_node.cost = min_cost\n                min_parent.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((min_parent, new_node))\n\n                for near in near_nodes:\n                    if near == min_parent:\n                        continue\n                    new_cost = new_node.cost + self._distance(new_node.position, near.position)\n                    if new_cost < near.cost and not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                        if near.parent:\n                            edges.remove((near.parent, near))\n                        near.parent = new_node\n                        near.cost = new_cost\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n\n                connect_node = self._nearest(tree_b, new_node.position)\n                if self._distance(new_node.position, connect_node.position) < self.step_size and not self._is_edge_in_obstacle(new_node.position, connect_node.position, obstacles, is_3d):\n                    success_state = True\n                    extracted_path = self._extract_path(new_node, connect_node)\n                    return PlannerResult(True, extracted_path, start_tree + goal_tree, edges)\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        while True:\n            point = tuple(random.uniform(0, bounds[i]) for i in range(3 if is_3d else 2))\n            if not self._is_in_obstacle(point, obstacles, is_3d):\n                return point\n\n    def _nearest(self, tree, point):\n        return min(tree, key=lambda node: self._distance(node.position, point))\n\n    def _near(self, tree, point, radius):\n        return [node for node in tree if self._distance(node.position, point) <= radius]\n\n    def _steer(self, from_pos, to_pos, step_size):\n        dist = self._distance(from_pos, to_pos)\n        if dist <= step_size:\n            return to_pos\n        ratio = step_size / dist\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n    def _extract_path(self, node_a, node_b):\n        path_a = []\n        while node_a:\n            path_a.append(node_a.position)\n            node_a = node_a.parent\n        path_b = []\n        while node_b:\n            path_b.append(node_b.position)\n            node_b = node_b.parent\n        return list(reversed(path_a)) + path_b\n\n    def _distance(self, a, b):\n        return math.dist(a, b)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = self._distance(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n    ",
          "objective": -27.725799297442336,
          "time_improvement": 75.0,
          "length_improvement": 7.0,
          "smoothness_improvement": 170.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.010820579528808594,
                    "num_nodes_avg": 133.0,
                    "path_length_avg": 175.27050435154484,
                    "smoothness_avg": 0.016726285105375487,
                    "success_improvement": 0.0,
                    "time_improvement": 56.761515149494244,
                    "length_improvement": 3.931459226046746,
                    "smoothness_improvement": 161.80268360858182,
                    "objective_score": 20.19634349851923
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.019153308868408204,
                    "num_nodes_avg": 264.6,
                    "path_length_avg": 258.5920512869376,
                    "smoothness_avg": 0.010908242682381757,
                    "success_improvement": 0.0,
                    "time_improvement": 88.28645766200407,
                    "length_improvement": 13.674530120921121,
                    "smoothness_improvement": 180.67694110730886,
                    "objective_score": 35.59404007669044
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.010100054740905761,
                    "num_nodes_avg": 179.6,
                    "path_length_avg": 143.86931760330097,
                    "smoothness_avg": 0.02092975461741331,
                    "success_improvement": 0.0,
                    "time_improvement": 79.62193302219796,
                    "length_improvement": 4.448849568598979,
                    "smoothness_improvement": 166.22493385971097,
                    "objective_score": 27.38701431711733
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "A simplified, efficient bidirectional RRT* variant with adaptive rewiring radius, goal-biased sampling with retry limit, early stopping on first valid connection, and post-planning path shortcutting for improved path quality and smoothness within a 30-second limit. The planner grows two trees from start and goal alternately, connects them upon the first feasible low-cost connection, and returns the best found path or partial connection if time expires.",
          "planning_mechanism": "The planner alternately grows two trees by sampling free points biased toward the goal with limited retries, extends each tree toward sampled points using fixed step size, rewires neighbors within an adaptive radius calculated from node count and dimension, and attempts to connect the two trees within an extended radius after each extension. Upon the first valid connection, the planner halts expansion early. If time expires without connection, it attempts partial path extraction. Finally, path shortcutting is applied once for improved path length and smoothness before returning results.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=5.0, goal_sample_rate=0.15):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.time_limit = 30.0\n\n    def plan(self, map):\n        import time\n        import math\n        import random\n\n        bounds = map.size\n        dim = len(bounds)\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = (dim == 3)\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def sample_free():\n            if random.random() < self.goal_sample_rate and not self._is_in_obstacle(goal_pos, obstacles, is_3d):\n                return goal_pos\n            for _ in range(30):\n                p = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n            return goal_pos\n\n        def steer(src, dest, max_step):\n            d = dist(src, dest)\n            if d <= max_step:\n                return dest\n            ratio = max_step / d\n            return tuple(src[i] + (dest[i] - src[i]) * ratio for i in range(dim))\n\n        def nearest(tree, point):\n            best_node = None\n            best_d_sq = float('inf')\n            for n in tree:\n                d_sq = sum((n.position[i] - point[i]) ** 2 for i in range(dim))\n                if d_sq < best_d_sq:\n                    best_d_sq = d_sq\n                    best_node = n\n            return best_node\n\n        def near(tree, point, radius):\n            r_sq = radius * radius\n            neighbors = []\n            for n in tree:\n                d_sq = sum((n.position[i] - point[i]) ** 2 for i in range(dim))\n                if d_sq <= r_sq:\n                    neighbors.append((d_sq, n))\n            neighbors.sort(key=lambda x: x[0])\n            return [n for (_, n) in neighbors]\n\n        def extract_path(n_start, n_goal):\n            path_start, cur = [], n_start\n            while cur:\n                path_start.append(cur.position)\n                cur = cur.parent\n            path_start.reverse()\n            path_goal, cur = [], n_goal\n            while cur:\n                path_goal.append(cur.position)\n                cur = cur.parent\n            if path_start[-1] == path_goal[0]:\n                path_goal = path_goal[1:]\n            return path_start + path_goal\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            attempts = 0\n            max_attempts = 100\n            resolution = max(0.2, self.step_size * 0.2)\n            while attempts < max_attempts and len(path) >= 3:\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d, resolution):\n                    path = path[:i + 1] + path[j:]\n                attempts += 1\n            return path\n\n        start_tree = [Node(start_pos, cost=0.0)]\n        goal_tree = [Node(goal_pos, cost=0.0)]\n        nodes = start_tree[:] + goal_tree[:]\n        edges = []\n\n        gamma = 35.0\n        best_connection = None\n        best_cost = float('inf')\n        success = False\n\n        start_time = time.monotonic()\n\n        for it in range(self.max_iter):\n            if time.monotonic() - start_time > self.time_limit:\n                break\n\n            tree_a, tree_b = (start_tree, goal_tree) if it % 2 == 0 else (goal_tree, start_tree)\n\n            sample = sample_free()\n            nearest_node = nearest(tree_a, sample)\n            new_pos = steer(nearest_node.position, sample, self.step_size)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            n = len(tree_a) + 1\n            radius = min(self.step_size * 5, gamma * (math.log(max(n, 2)) / n) ** (1 / dim))\n\n            near_nodes = near(tree_a, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            min_parent = nearest_node\n            for near_node in near_nodes:\n                candidate_cost = near_node.cost + dist(near_node.position, new_pos)\n                if candidate_cost < min_cost:\n                    if not self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d):\n                        min_cost = candidate_cost\n                        min_parent = near_node\n\n            new_node = Node(new_pos, parent=min_parent, cost=min_cost)\n            min_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((min_parent, new_node))\n\n            # Rewiring neighbors\n            for near_node in near_nodes:\n                if near_node is min_parent:\n                    continue\n                cost_through_new = new_node.cost + dist(new_node.position, near_node.position)\n                if cost_through_new < near_node.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                        if near_node.parent:\n                            try:\n                                edges.remove((near_node.parent, near_node))\n                            except ValueError:\n                                pass\n                            near_node.parent.remove_child(near_node)\n                        near_node.parent = new_node\n                        near_node.cost = cost_through_new\n                        new_node.add_child(near_node)\n                        edges.append((new_node, near_node))\n\n            # Try to connect trees\n            connect_radius = self.step_size * 3.0\n            candidates = near(tree_b, new_node.position, connect_radius)\n            for c in candidates:\n                d = dist(new_node.position, c.position)\n                if d <= connect_radius and not self._is_edge_in_obstacle(new_node.position, c.position, obstacles, is_3d):\n                    total_cost = new_node.cost + c.cost + d\n                    if total_cost < best_cost:\n                        best_cost = total_cost\n                        best_connection = (new_node, c) if it % 2 == 0 else (c, new_node)\n                        success = True\n                        break\n            if success:\n                break\n\n        if success and best_connection:\n            path = extract_path(best_connection[0], best_connection[1])\n            path = shortcut_path(path)\n        else:\n            # Attempt partial connecting fallback\n            min_cost = float('inf')\n            best_pair = None\n            search_radius = self.step_size * 3.0\n            for n1 in start_tree:\n                candidates = near(goal_tree, n1.position, search_radius)\n                for n2 in candidates:\n                    d = dist(n1.position, n2.position)\n                    if d <= search_radius and not self._is_edge_in_obstacle(n1.position, n2.position, obstacles, is_3d):\n                        total_c = n1.cost + n2.cost + d\n                        if total_c < min_cost:\n                            min_cost = total_c\n                            best_pair = (n1, n2)\n            if best_pair:\n                path = extract_path(best_pair[0], best_pair[1])\n                path = shortcut_path(path)\n                success = True\n            else:\n                path = []\n\n        return PlannerResult(\n            success=success,\n            path=path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=None):\n        import math\n        if resolution is None:\n            resolution = max(0.5, self.step_size / 5)\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -27.673,
          "time_improvement": 34.0,
          "length_improvement": 16.0,
          "smoothness_improvement": 1552.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.01821610927581787,
                    "num_nodes_avg": 101.9,
                    "path_length_avg": 161.1036488171135,
                    "smoothness_avg": 0.04979800847643047,
                    "success_improvement": 0.0,
                    "time_improvement": 27.813113533594485,
                    "length_improvement": 11.696537232660162,
                    "smoothness_improvement": 679.4469707623538,
                    "objective_score": 18.75909125348621
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.06483819484710693,
                    "num_nodes_avg": 292.3,
                    "path_length_avg": 235.67213905046736,
                    "smoothness_avg": 0.10173143073419029,
                    "success_improvement": 0.0,
                    "time_improvement": 60.45020701931454,
                    "length_improvement": 21.32585653854982,
                    "smoothness_improvement": 2517.622986978509,
                    "objective_score": 43.518690963816795
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.04266898632049561,
                    "num_nodes_avg": 226.4,
                    "path_length_avg": 126.9154652694069,
                    "smoothness_avg": 0.12267339999471052,
                    "success_improvement": 0.0,
                    "time_improvement": 13.379836204188639,
                    "length_improvement": 15.708791033077734,
                    "smoothness_improvement": 1460.396593124222,
                    "objective_score": 20.741208446724343
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "cross_over",
          "algorithm_description": "A goal-biased bidirectional RRT* planner employing an adaptive rewiring radius that decreases logarithmically with growing tree size, informed sampling with goal bias, optimized cost-based parent selection and rewiring, multi-candidate bridge connections between trees, and incremental path shortcutting to minimize path length and improve smoothness while enforcing a strict 30-second time limit. Early stopping is triggered on improved path discovery. The planner uses rigorous collision checks and maintains coherent tree data structures to ensure efficient, feasible, and high-quality solutions.",
          "planning_mechanism": "The planner builds two trees from start and goal positions, alternately expanding them by steering towards goal-biased samples. For each new node, it selects the parent with minimal cumulative cost within a dynamically shrinking radius and rewires neighbors to reduce path costs. It attempts multiple connections to the opposite tree within a connecting radius, updating the best path found and performing incremental shortcutting frequently. The plan stops early when a better path is found or after 30 seconds, returning the shortest smooth collision-free path discovered.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\nclass Planner:\n    def __init__(self, max_iter: int = 6000, step_size: float = 4.5, goal_sample_rate: float = 0.2):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.time_limit = 30.0\n\n    def plan(self, map):\n        import time\n        import random\n        import math\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        start_tree = [Node(start_pos, cost=0.0)]\n        goal_tree = [Node(goal_pos, cost=0.0)]\n        nodes = start_tree[:] + goal_tree[:]\n        edges = []\n\n        best_connection = None\n        best_cost = float('inf')\n        success = False\n        extracted_path = []\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def sample_free():\n            # Attempt goal-biased sampling with fallback uniform\n            for _ in range(30):\n                if random.random() < self.goal_sample_rate:\n                    p = goal_pos\n                else:\n                    p = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n            # If stuck, return goal_pos forcibly (checked in loop)\n            return goal_pos\n\n        def nearest(tree, point):\n            best_node = None\n            best_dist = float('inf')\n            for node in tree:\n                d = dist(node.position, point)\n                if d < best_dist:\n                    best_node = node\n                    best_dist = d\n            return best_node\n\n        def near(tree, point, radius):\n            r_sq = radius * radius\n            neighbors = []\n            for node in tree:\n                d_sq = sum((node.position[i] - point[i]) ** 2 for i in range(dim))\n                if d_sq <= r_sq:\n                    neighbors.append((math.sqrt(d_sq), node))\n            neighbors.sort(key=lambda x: x[0])\n            return [n[1] for n in neighbors]\n\n        def steer(from_p, to_p, max_step):\n            d = dist(from_p, to_p)\n            if d <= max_step:\n                return to_p\n            ratio = max_step / d\n            return tuple(from_p[i] + ratio * (to_p[i] - from_p[i]) for i in range(dim))\n\n        def extract_path(n_start, n_goal):\n            path_start = []\n            cur = n_start\n            while cur:\n                path_start.append(cur.position)\n                cur = cur.parent\n            path_goal = []\n            cur = n_goal\n            while cur:\n                path_goal.append(cur.position)\n                cur = cur.parent\n            return path_start[::-1] + path_goal\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            for _ in range(75):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        def try_connect(node, other_tree, radius):\n            candidates = near(other_tree, node.position, radius)\n            best_node = None\n            best_cost_local = float('inf')\n            for cnode in candidates:\n                d = dist(node.position, cnode.position)\n                if d <= radius and not self._is_edge_in_obstacle(node.position, cnode.position, obstacles, is_3d):\n                    total_cost = node.cost + cnode.cost + d\n                    if total_cost < best_cost_local:\n                        best_cost_local = total_cost\n                        best_node = cnode\n            return best_node, best_cost_local\n\n        start_time = time.monotonic()\n\n        for it in range(self.max_iter):\n            current_time = time.monotonic()\n            if current_time - start_time > self.time_limit:\n                break\n\n            tree_a = start_tree if it % 2 == 0 else goal_tree\n            tree_b = goal_tree if it % 2 == 0 else start_tree\n\n            sample = sample_free()\n            nearest_node = nearest(tree_a, sample)\n            new_pos = steer(nearest_node.position, sample, self.step_size)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            n_nodes = len(tree_a) + 1\n            gamma = 35.0  # Tuned constant for better performance balance\n            radius = min(self.step_size * 5, gamma * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim)))\n\n            near_nodes = near(tree_a, new_pos, radius)\n\n            # Select parent minimizing cost-to-node\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            min_parent = nearest_node\n            for near_node in near_nodes:\n                cost_through = near_node.cost + dist(near_node.position, new_pos)\n                if cost_through < min_cost:\n                    if not self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d):\n                        min_cost = cost_through\n                        min_parent = near_node\n\n            new_node = Node(new_pos, parent=min_parent, cost=min_cost)\n            min_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((min_parent, new_node))\n\n            # Rewire neighbors if cost improves\n            for near_node in near_nodes:\n                if near_node == min_parent:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, near_node.position)\n                if new_cost < near_node.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                        if near_node.parent:\n                            try:\n                                edges.remove((near_node.parent, near_node))\n                            except ValueError:\n                                pass\n                            near_node.parent.remove_child(near_node)\n                        near_node.parent = new_node\n                        near_node.cost = new_cost\n                        new_node.add_child(near_node)\n                        edges.append((new_node, near_node))\n\n            # Attempt multiple connection attempts to opposite tree inside a connection radius\n            connect_radius = self.step_size * 3.5\n            connect_candidates = near(tree_b, new_node.position, connect_radius)\n            improved_path_found = False\n            for conn_node in connect_candidates:\n                d = dist(new_node.position, conn_node.position)\n                if d <= connect_radius and not self._is_edge_in_obstacle(new_node.position, conn_node.position, obstacles, is_3d):\n                    candidate_cost = new_node.cost + conn_node.cost + d\n                    if candidate_cost < best_cost:\n                        best_cost = candidate_cost\n                        best_connection = (new_node, conn_node)\n                        success = True\n                        improved_path_found = True\n            # Early stop if improved path found\n            if improved_path_found:\n                # Incrementally shortcut best path\n                path = extract_path(best_connection[0], best_connection[1])\n                shortcut = shortcut_path(path)\n                shortcut_len = sum(dist(shortcut[i], shortcut[i + 1]) for i in range(len(shortcut) - 1))\n                if shortcut_len + 1e-5 < best_cost:\n                    best_cost = shortcut_len\n                    extracted_path = shortcut\n                else:\n                    extracted_path = path\n                break\n\n            # Periodically shortcut current best path\n            if success and it % 150 == 0 and best_connection:\n                path = extract_path(best_connection[0], best_connection[1])\n                shortcut = shortcut_path(path)\n                shortcut_len = sum(dist(shortcut[i], shortcut[i + 1]) for i in range(len(shortcut) - 1))\n                if shortcut_len + 1e-5 < best_cost:\n                    best_cost = shortcut_len\n                    extracted_path = shortcut\n                else:\n                    extracted_path = path\n\n        if success and best_connection and not extracted_path:\n            extracted_path = extract_path(best_connection[0], best_connection[1])\n            extracted_path = shortcut_path(extracted_path)\n        elif not success:\n            # Fallback: find best cross-tree pair and shortcut\n            best_pair = None\n            min_total_cost = float('inf')\n            for n1 in start_tree:\n                near_goal_cands = near(goal_tree, n1.position, self.step_size * 3.5)\n                for n2 in near_goal_cands:\n                    d12 = dist(n1.position, n2.position)\n                    if d12 <= self.step_size * 3.5 and not self._is_edge_in_obstacle(n1.position, n2.position, obstacles, is_3d):\n                        total_c = n1.cost + n2.cost + d12\n                        if total_c < min_total_cost:\n                            min_total_cost = total_c\n                            best_pair = (n1, n2)\n            if best_pair:\n                extracted_path = extract_path(best_pair[0], best_pair[1])\n                extracted_path = shortcut_path(extracted_path)\n                success = True\n\n        return PlannerResult(\n            success=success,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -27.59476,
          "time_improvement": 37.0,
          "length_improvement": 18.0,
          "smoothness_improvement": 1152.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.016472363471984865,
                    "num_nodes_avg": 118.4,
                    "path_length_avg": 153.42080973336516,
                    "smoothness_avg": 0.0424227019832782,
                    "success_improvement": 0.0,
                    "time_improvement": 34.72323788900037,
                    "length_improvement": 15.907623076838567,
                    "smoothness_improvement": 564.0074084101302,
                    "objective_score": 22.7815822548539
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.06589515209197998,
                    "num_nodes_avg": 374.4,
                    "path_length_avg": 233.2540153111043,
                    "smoothness_avg": 0.06640784804961106,
                    "success_improvement": 0.0,
                    "time_improvement": 59.80548764792029,
                    "length_improvement": 22.133095844581874,
                    "smoothness_improvement": 1608.7217619560734,
                    "objective_score": 39.265112610905575
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.041630911827087405,
                    "num_nodes_avg": 259.3,
                    "path_length_avg": 126.29125029932531,
                    "smoothness_avg": 0.1087651876253088,
                    "success_improvement": 0.0,
                    "time_improvement": 15.4871790404088,
                    "length_improvement": 16.123364894283213,
                    "smoothness_improvement": 1283.485158382881,
                    "objective_score": 20.737598440606973
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "A simplified bidirectional RRT* planner with balanced goal bias, adaptive rewiring radius based on the logarithm of node count, incremental rewiring for cost improvement, and lightweight randomized shortcutting for path smoothing, all within a 30-second runtime limit. It alternates tree expansions from start and goal, uses direct nearest and near neighbor searches, and updates the best path found efficiently to reduce planning time while improving path length and smoothness.",
          "planning_mechanism": "The planner grows two trees alternately from start and goal positions by sampling free points biased towards the goal, connects new nodes selecting parents minimizing path costs within an adaptive radius, rewires neighbor nodes to reduce costs, attempts connections between the two trees within a neighborhood radius, applies periodic lightweight shortcutting on the best available path, and terminates early upon finding a better solution or when the time limit is reached, ultimately returning the best feasible path found.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0, goal_sample_rate: float=0.2):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.time_limit = 30.0\n\n    def plan(self, map):\n        import time\n        import math\n        import random\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = dim == 3\n\n        start_tree = [Node(start_pos, cost=0.0)]\n        goal_tree = [Node(goal_pos, cost=0.0)]\n        nodes = start_tree[:] + goal_tree[:]\n        edges = []\n\n        best_connection = None\n        best_cost = float('inf')\n        success = False\n        extracted_path = []\n\n        def dist(a,b):\n            return math.dist(a,b)\n\n        def dist_sq(a,b):\n            s = 0.0\n            for i in range(dim):\n                d = a[i]-b[i]\n                s += d*d\n            return s\n\n        def sample_free():\n            if random.random() < self.goal_sample_rate:\n                return goal_pos\n            for _ in range(30):\n                p = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n            return goal_pos\n\n        def nearest(tree, point):\n            best_node = None\n            best_dist = float('inf')\n            for node in tree:\n                d = dist_sq(node.position, point)\n                if d < best_dist:\n                    best_dist = d\n                    best_node = node\n            return best_node\n\n        def near(tree, point, radius):\n            r_sq = radius*radius\n            neighbors = []\n            for node in tree:\n                d = dist_sq(node.position, point)\n                if d <= r_sq:\n                    neighbors.append((d, node))\n            neighbors.sort(key=lambda x: x[0])\n            return [n[1] for n in neighbors]\n\n        def steer(from_p, to_p, max_step):\n            d = dist(from_p, to_p)\n            if d <= max_step:\n                return to_p\n            ratio = max_step / d\n            return tuple(from_p[i] + ratio*(to_p[i]-from_p[i]) for i in range(dim))\n\n        def extract_path(n_start, n_goal):\n            path_start = []\n            cur = n_start\n            while cur:\n                path_start.append(cur.position)\n                cur = cur.parent\n            path_goal = []\n            cur = n_goal\n            while cur:\n                path_goal.append(cur.position)\n                cur = cur.parent\n            return path_start[::-1] + path_goal\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            attempts = 30\n            for _ in range(attempts):\n                if len(path) < 3:\n                    break\n                i = random.randint(0,len(path)-3)\n                j = random.randint(i+2,len(path)-1)\n                if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        def try_connect(node, other_tree, radius):\n            candidates = near(other_tree, node.position, radius)\n            best_node = None\n            best_cost_local = float('inf')\n            for cnode in candidates:\n                d = dist(node.position, cnode.position)\n                if d <= radius and not self._is_edge_in_obstacle(node.position, cnode.position, obstacles, is_3d):\n                    total_cost = node.cost + cnode.cost + d\n                    if total_cost < best_cost_local:\n                        best_cost_local = total_cost\n                        best_node = cnode\n            return best_node, best_cost_local\n\n        def rewire(tree, new_node, neighbors):\n            for near_node in neighbors:\n                if near_node == new_node.parent:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, near_node.position)\n                if new_cost + 1e-9 < near_node.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                        if near_node.parent:\n                            try:\n                                edges.remove((near_node.parent, near_node))\n                            except ValueError:\n                                pass\n                            near_node.parent.remove_child(near_node)\n                        near_node.parent = new_node\n                        near_node.cost = new_cost\n                        new_node.add_child(near_node)\n                        edges.append((new_node, near_node))\n\n        start_time = time.monotonic()\n        gamma_rrt_star = 30.0\n\n        for it in range(self.max_iter):\n            current_time = time.monotonic()\n            if current_time - start_time > self.time_limit:\n                break\n\n            tree_a = start_tree if it % 2 == 0 else goal_tree\n            tree_b = goal_tree if it % 2 == 0 else start_tree\n\n            q_rand = sample_free()\n\n            nearest_node = nearest(tree_a, q_rand)\n            q_new = steer(nearest_node.position, q_rand, self.step_size)\n\n            if self._is_in_obstacle(q_new, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, q_new, obstacles, is_3d):\n                continue\n\n            n_nodes = max(len(tree_a),2)\n            radius = min(self.step_size*5.0, gamma_rrt_star * (math.log(n_nodes)/n_nodes)**(1.0/dim))\n\n            neighbors = near(tree_a, q_new, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, q_new)\n            min_parent = nearest_node\n            for near_n in neighbors:\n                cost_through = near_n.cost + dist(near_n.position, q_new)\n                if cost_through + 1e-9 < min_cost:\n                    if not self._is_edge_in_obstacle(near_n.position, q_new, obstacles, is_3d):\n                        min_cost = cost_through\n                        min_parent = near_n\n\n            new_node = Node(q_new, parent=min_parent, cost=min_cost)\n            min_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((min_parent, new_node))\n\n            rewire(tree_a, new_node, neighbors)\n\n            connect_radius = self.step_size*3.0\n            conn_node, conn_cost = try_connect(new_node, tree_b, connect_radius)\n            if conn_node and conn_cost < best_cost:\n                best_cost = conn_cost\n                best_connection = (new_node, conn_node)\n                success = True\n                extracted_path = extract_path(new_node, conn_node)\n                extracted_path = shortcut_path(extracted_path)\n                break\n\n            if success and it % 100 == 0 and best_connection:\n                path = extract_path(best_connection[0], best_connection[1])\n                shortcut = shortcut_path(path)\n                shortcut_len = sum(dist(shortcut[i], shortcut[i+1]) for i in range(len(shortcut)-1))\n                curr_len = sum(dist(extracted_path[i], extracted_path[i+1]) for i in range(len(extracted_path)-1))\n                if shortcut_len + 1e-8 < curr_len:\n                    extracted_path = shortcut\n\n        if not success:\n            best_pair = None\n            min_total = float('inf')\n            for n1 in start_tree:\n                candidates = near(goal_tree, n1.position, self.step_size*3.0)\n                for n2 in candidates:\n                    d = dist(n1.position, n2.position)\n                    if d <= self.step_size*3.0 and not self._is_edge_in_obstacle(n1.position, n2.position, obstacles, is_3d):\n                        total_c = n1.cost + n2.cost + d\n                        if total_c < min_total:\n                            min_total = total_c\n                            best_pair = (n1, n2)\n            if best_pair:\n                success = True\n                extracted_path = extract_path(best_pair[0], best_pair[1])\n                extracted_path = shortcut_path(extracted_path)\n\n        return PlannerResult(\n            success=success,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x,y,z,w,h,d = obs\n                px,py,pz = pos\n                if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                    return True\n            else:\n                x,y,w_,h_ = obs\n                px,py = pos\n                if x <= px <= x+w_ and y <= py <= y+h_:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps+1):\n            interp = tuple(from_pos[d] + (to_pos[d]-from_pos[d])*(i/steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -27.43438,
          "time_improvement": 55.0,
          "length_improvement": 14.0,
          "smoothness_improvement": 551.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.014897489547729492,
                    "num_nodes_avg": 124.5,
                    "path_length_avg": 165.8992144863402,
                    "smoothness_avg": 0.026445109039989236,
                    "success_improvement": 0.0,
                    "time_improvement": 40.96415593839107,
                    "length_improvement": 9.068011698756115,
                    "smoothness_improvement": 313.92338294925446,
                    "objective_score": 19.299670715517262
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.04256761074066162,
                    "num_nodes_avg": 306.9,
                    "path_length_avg": 249.54567503822258,
                    "smoothness_avg": 0.029184391199415433,
                    "success_improvement": 0.0,
                    "time_improvement": 74.03474608684778,
                    "length_improvement": 16.694470898245044,
                    "smoothness_improvement": 650.9354062282783,
                    "objective_score": 35.481783396142745
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.025249147415161134,
                    "num_nodes_avg": 227.1,
                    "path_length_avg": 126.84558042649284,
                    "smoothness_avg": 0.06203911235844328,
                    "success_improvement": 0.0,
                    "time_improvement": 48.74297532221194,
                    "length_improvement": 15.755205218182637,
                    "smoothness_improvement": 689.1329299484631,
                    "objective_score": 27.52168037731548
               }
          ],
          "success_rate": 1.0
     }
]