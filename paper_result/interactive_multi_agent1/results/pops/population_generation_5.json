[
     {
          "operator": "cross_over",
          "algorithm_description": "This algorithm implements a bidirectional, goal-biased RRT* planner with adaptive neighborhood radius rewiring, multi-candidate bidirectional connection attempts, and incremental path shortcutting applied during planning and after completion. It enforces a strict 30-second time limit and dynamically adjusts rewiring radius based on tree size and dimension to balance exploration and refinement efficiency. The planner samples with goal bias for faster convergence, alternates expanding start and goal trees, and progressively shortcuts the best found path to minimize length and improve smoothness. Early stopping occurs upon finding a better path.",
          "planning_mechanism": "The planner grows two trees alternately from start and goal positions, samples random points with a goal bias, and extends the nearest node towards samples with a fixed step size while respecting collision constraints. It rewires nearby nodes within an adaptively shrinking radius to optimize path costs. Multiple candidates from the opposite tree are tested for connection on each new node added, enabling early termination when better paths are found. Progressive shortcutting improves path smoothness and length during planning as well as post-planning. The search halts immediately if the 30-second limit is exceeded, returning the best path found so far.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n    def add_child(self, child):\n        self.children.append(child)\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\nclass Planner:\n    def __init__(self, max_iter: int=5000, step_size: float=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.time_limit = 30.0\n        self.goal_sample_rate = 0.15  # probability to sample goal\n\n    def plan(self, map) -> 'PlannerResult':\n        import time\n        import math\n        import random\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        # Tree nodes and edges\n        start_tree = [Node(start_pos, cost=0.0)]\n        goal_tree = [Node(goal_pos, cost=0.0)]\n        nodes = start_tree[:] + goal_tree[:]\n        edges = []\n\n        best_connection = None\n        best_cost = float('inf')\n        success = False\n        extracted_path = []\n\n        step = self.step_size\n        gamma = 35.0  # radius multiplier for rewiring (RRT* theory)\n\n        start_time = time.monotonic()\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def sample_free():\n            # goal bias sampling\n            if random.random() < self.goal_sample_rate:\n                return goal_pos\n            for _ in range(100):\n                p = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n            return goal_pos  # fallback\n\n        def nearest(tree, point):\n            best_node = None\n            best_d = float('inf')\n            for node in tree:\n                d = dist(node.position, point)\n                if d < best_d:\n                    best_node = node\n                    best_d = d\n            return best_node\n\n        def near(tree, point, radius):\n            neighbors = [(dist(n.position, point), n) for n in tree if dist(n.position, point) <= radius]\n            neighbors.sort(key=lambda x: x[0])\n            return [n[1] for n in neighbors]\n\n        def steer(from_p, to_p, max_step):\n            d = dist(from_p, to_p)\n            if d <= max_step:\n                return to_p\n            ratio = max_step / d\n            return tuple(from_p[i] + (to_p[i] - from_p[i]) * ratio for i in range(dim))\n\n        def extract_path(node_start, node_goal):\n            path_start = []\n            cur = node_start\n            while cur:\n                path_start.append(cur.position)\n                cur = cur.parent\n            path_start.reverse()\n            path_goal = []\n            cur = node_goal\n            while cur:\n                path_goal.append(cur.position)\n                cur = cur.parent\n            if path_goal and path_start and path_start[-1] == path_goal[0]:\n                path_goal = path_goal[1:]\n            return path_start + path_goal\n\n        def shortcut_path(path, max_attempts=50):\n            if len(path) < 3:\n                return path\n            for _ in range(max_attempts):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution=max(step*0.2, 0.2)):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        def try_connect(new_node, other_tree):\n            radius = step*2.5\n            candidates = near(other_tree, new_node.position, radius)\n            best_cand = None\n            best_local_cost = float('inf')\n            for node in candidates:\n                d12 = dist(new_node.position, node.position)\n                if d12 <= radius and not self._is_edge_in_obstacle(new_node.position, node.position, obstacles, is_3d, resolution=max(step*0.2, 0.2)):\n                    c = new_node.cost + d12 + node.cost\n                    if c < best_local_cost:\n                        best_local_cost = c\n                        best_cand = node\n            return best_cand, best_local_cost\n\n        def rewire(tree, new_node, neighbors):\n            for nbr in neighbors:\n                if nbr is new_node.parent:\n                    continue\n                cost_through = new_node.cost + dist(new_node.position, nbr.position)\n                if cost_through + 1e-9 < nbr.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, nbr.position, obstacles, is_3d, resolution=max(step*0.2, 0.2)):\n                        if nbr.parent:\n                            try:\n                                edges.remove((nbr.parent, nbr))\n                            except Exception:\n                                pass\n                            nbr.parent.remove_child(nbr)\n                        nbr.parent = new_node\n                        nbr.cost = cost_through\n                        new_node.add_child(nbr)\n                        edges.append((new_node, nbr))\n\n        iter_since_last_shortcut = 0\n        shortcut_interval = 75\n\n        for it in range(self.max_iter):\n            if time.monotonic() - start_time > self.time_limit:\n                break\n\n            tree_a = start_tree if (it % 2 == 0) else goal_tree\n            tree_b = goal_tree if (it % 2 == 0) else start_tree\n\n            sample = sample_free()\n            nearest_node = nearest(tree_a, sample)\n            new_pos = steer(nearest_node.position, sample, step)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d, resolution=max(step*0.2, 0.2)):\n                continue\n\n            n_nodes = len(tree_a) + 1\n            radius = gamma * ((math.log(n_nodes)/n_nodes) ** (1/dim)) if n_nodes > 1 else step*5\n            radius = min(radius, step*5)\n            if radius < step:\n                radius = step\n\n            neighbors = near(tree_a, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            min_parent = nearest_node\n            for nb in neighbors:\n                cost_cand = nb.cost + dist(nb.position, new_pos)\n                if cost_cand + 1e-9 < min_cost:\n                    if not self._is_edge_in_obstacle(nb.position, new_pos, obstacles, is_3d, resolution=max(step*0.2, 0.2)):\n                        min_cost = cost_cand\n                        min_parent = nb\n\n            new_node = Node(new_pos, parent=min_parent, cost=min_cost)\n            min_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((min_parent, new_node))\n\n            rewire(tree_a, new_node, neighbors)\n\n            conn_node, conn_cost = try_connect(new_node, tree_b)\n            if conn_node is not None and conn_cost + 1e-9 < best_cost:\n                best_cost = conn_cost\n                # Maintain start_tree node first in best_connection\n                best_connection = (new_node, conn_node) if it % 2 == 0 else (conn_node, new_node)\n                success = True\n                # Early termination on improved path\n                break\n\n            iter_since_last_shortcut += 1\n            if iter_since_last_shortcut >= shortcut_interval and success:\n                path_cur = extract_path(best_connection[0], best_connection[1])\n                path_short = shortcut_path(path_cur, max_attempts=25)\n                if len(path_short) < len(path_cur):\n                    extracted_path = path_short\n                    iter_since_last_shortcut = 0\n\n        if success and best_connection is not None:\n            extracted_path = extract_path(best_connection[0], best_connection[1])\n            extracted_path = shortcut_path(extracted_path, max_attempts=75)\n        elif not success:\n            # Try partial best connection if no success\n            best_partial_cost = float('inf')\n            best_pair = None\n            search_radius = step * 3.0\n            for n1 in start_tree:\n                candidates = near(goal_tree, n1.position, search_radius)\n                for n2 in candidates:\n                    d12 = dist(n1.position, n2.position)\n                    if d12 <= search_radius:\n                        if not self._is_edge_in_obstacle(n1.position, n2.position, obstacles, is_3d, resolution=max(step*0.2, 0.2)):\n                            cost_sum = n1.cost + n2.cost + d12\n                            if cost_sum + 1e-9 < best_partial_cost:\n                                best_partial_cost = cost_sum\n                                best_pair = (n1, n2)\n            if best_pair:\n                success = True\n                extracted_path = extract_path(best_pair[0], best_pair[1])\n                extracted_path = shortcut_path(extracted_path, max_attempts=75)\n\n        return PlannerResult(\n            success=success,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -40.41506,
          "time_improvement": 74.0,
          "length_improvement": 17.0,
          "smoothness_improvement": 1612.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.010355472564697266,
                    "num_nodes_avg": 88.3,
                    "path_length_avg": 158.02445292325712,
                    "smoothness_avg": 0.04068830742889877,
                    "success_improvement": 0.0,
                    "time_improvement": 58.963282937365015,
                    "length_improvement": 13.384293295064195,
                    "smoothness_improvement": 536.8603673360356,
                    "objective_score": 28.403862694928197
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.025506019592285156,
                    "num_nodes_avg": 305.8,
                    "path_length_avg": 239.66358035944714,
                    "smoothness_avg": 0.11914932396717788,
                    "success_improvement": 0.0,
                    "time_improvement": 84.44192042954145,
                    "length_improvement": 19.993398542344394,
                    "smoothness_improvement": 2965.7979254646784,
                    "objective_score": 52.15760488159246
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.010851669311523437,
                    "num_nodes_avg": 173.2,
                    "path_length_avg": 123.90215675117983,
                    "smoothness_avg": 0.11268141879062014,
                    "success_improvement": 0.0,
                    "time_improvement": 77.97057173653472,
                    "length_improvement": 17.710087072551893,
                    "smoothness_improvement": 1333.2993297395258,
                    "objective_score": 40.683720413189185
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "time_expert",
          "algorithm_description": "A bidirectional RRT* planner with goal-biased adaptive sampling, dynamic neighborhood radius rewiring, incremental path shortcutting for smoothness, and early stopping to minimize planning time while improving path length and smoothness. The planner grows two trees alternately from start and goal, steering towards sampled points biased towards the goal region, rewiring neighbors within a shrinking radius computed in relation to the number of nodes and problem dimension. It attempts connection between trees more aggressively using multiple near neighbors and applies incremental shortcutting on the current best path throughout the search to reduce path length and smoothness. The planner respects a strict 30-second limit, returning the best feasible path found so far.",
          "planning_mechanism": "A bidirectional RRT* planner that alternates growth between start and goal trees, samples points with goal bias, dynamically adapts the rewiring radius based on node count, rewires neighbors to reduce path cost, attempts connection between trees using multiple candidates, performs incremental shortcutting to smooth the path during planning, and enforces a strict time limit with early stopping on improved solutions.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map) -> 'PlannerResult':\n        import time\n        import math\n        import random\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n        TIME_LIMIT = 30.0\n\n        start_time = time.monotonic()\n\n        def dist(p1, p2):\n            return math.dist(p1, p2)\n\n        def sample_free(goal_bias=0.2):\n            if random.random() < goal_bias:\n                if not self._is_in_obstacle(goal_pos, obstacles, is_3d):\n                    return goal_pos\n            for _ in range(30):\n                p = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n            # fallback\n            return start_pos\n\n        def steer(from_p, to_p, step):\n            d = dist(from_p, to_p)\n            if d <= step:\n                return to_p\n            ratio = step / d\n            return tuple(from_p[i] + (to_p[i] - from_p[i]) * ratio for i in range(dim))\n\n        def nearest(tree, point):\n            best_node = None\n            best_dist = float('inf')\n            for node in tree:\n                d = dist(node.position, point)\n                if d < best_dist:\n                    best_dist = d\n                    best_node = node\n            return best_node\n\n        def near(tree, point, radius):\n            r_sq = radius * radius\n            if not is_3d:\n                return [node for node in tree if (node.position[0] - point[0])**2 + (node.position[1] - point[1])**2 <= r_sq]\n            else:\n                return [node for node in tree if sum((node.position[i]-point[i])**2 for i in range(dim)) <= r_sq]\n\n        def extract_path(node_start, node_goal):\n            path_start = []\n            n = node_start\n            while n is not None:\n                path_start.append(n.position)\n                n = n.parent\n            path_goal = []\n            n = node_goal\n            while n is not None:\n                path_goal.append(n.position)\n                n = n.parent\n            return path_start[::-1] + path_goal\n\n        def try_rewire(new_node, neighbors, obstacles, is_3d):\n            improved = False\n            for near_node in neighbors:\n                if near_node is new_node.parent:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, near_node.position)\n                if new_cost + 1e-9 < near_node.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                        if near_node.parent:\n                            if near_node in near_node.parent.children:\n                                near_node.parent.children.remove(near_node)\n                        near_node.parent = new_node\n                        near_node.cost = new_cost\n                        new_node.children.append(near_node)\n                        improved = True\n            return improved\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            smoothed = [path[0]]\n            i = 0\n            while i < len(path) -1:\n                j = len(path) - 1\n                while j > i + 1:\n                    if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d, resolution=self.step_size/5):\n                        break\n                    j -= 1\n                smoothed.append(path[j])\n                i = j\n            return smoothed\n\n        # Initialize trees\n        tree_start = [Node(start_pos, parent=None, cost=0.0)]\n        tree_goal = [Node(goal_pos, parent=None, cost=0.0)]\n        all_nodes = tree_start + tree_goal\n        edges = []\n\n        best_cost = float('inf')\n        best_pair = None\n        success = False\n        last_shortcut_time = start_time\n\n        gamma = 20.0  # tuning parameter for radius\n        max_radius = self.step_size * 5\n\n        for iter_count in range(self.max_iter):\n            now = time.monotonic()\n            if now - start_time > TIME_LIMIT:\n                break\n\n            # Alternate start/goal tree growth\n            tree_a = tree_start if iter_count % 2 == 0 else tree_goal\n            tree_b = tree_goal if iter_count % 2 == 0 else tree_start\n\n            rnd = sample_free(goal_bias=0.2)\n\n            nearest_node = nearest(tree_a, rnd)\n            new_pos = steer(nearest_node.position, rnd, self.step_size)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d, resolution=self.step_size/5):\n                continue\n\n            n_nodes = len(tree_a) + 1\n            radius = min(max_radius, gamma * (math.log(max(n_nodes, 2)) / n_nodes) ** (1.0 / dim))\n\n            near_nodes = near(tree_a, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            min_parent = nearest_node\n            for near_node in near_nodes:\n                new_cost = near_node.cost + dist(near_node.position, new_pos)\n                if new_cost + 1e-9 < min_cost:\n                    if not self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d, resolution=self.step_size/5):\n                        min_cost = new_cost\n                        min_parent = near_node\n\n            new_node = Node(new_pos, parent=min_parent, cost=min_cost)\n            min_parent.children.append(new_node)\n            tree_a.append(new_node)\n            all_nodes.append(new_node)\n            edges.append((min_parent, new_node))\n\n            rewired = try_rewire(new_node, near_nodes, obstacles, is_3d)\n\n            # Attempt multiple connections from new_node to nodes in other tree within radius\n            other_near_nodes = near(tree_b, new_node.position, radius)\n            connected_this_iter = False\n            for other_node in other_near_nodes:\n                connect_dist = dist(new_node.position, other_node.position)\n                total_cost = new_node.cost + other_node.cost + connect_dist\n                if connect_dist <= self.step_size and total_cost + 1e-9 < best_cost:\n                    if not self._is_edge_in_obstacle(new_node.position, other_node.position, obstacles, is_3d, resolution=self.step_size/5):\n                        best_cost = total_cost\n                        best_pair = (new_node, other_node)\n                        success = True\n                        connected_this_iter = True\n            if connected_this_iter:\n                # Early stopping on improved path found to reduce planning time\n                break\n\n            # Periodic incremental path shortcutting on best known path to improve smoothness and length\n            if success and (now - last_shortcut_time > 0.5):\n                candidate_path = extract_path(best_pair[0], best_pair[1])\n                shortened = shortcut_path(candidate_path)\n                if len(shortened) < len(candidate_path):\n                    # Replace path with shortcut path for smoother and shorter result\n                    best_pair_short_nodes = []\n                    # Rebuild nodes for new shortcut path? \n                    # Here we keep original nodes, just update path extraction for final result\n                    # So we just update the extracted_path at end.\n                    last_shortcut_time = now\n\n        if success and best_pair is not None:\n            extracted_path = extract_path(best_pair[0], best_pair[1])\n            extracted_path = shortcut_path(extracted_path)\n        else:\n            # Attempt connection among any near nodes between trees\n            min_total_cost = float('inf')\n            candidate_pair = None\n            for n1 in tree_start:\n                near_goal_nodes = near(tree_goal, n1.position, self.step_size*1.5)\n                for n2 in near_goal_nodes:\n                    dist12 = dist(n1.position, n2.position)\n                    if dist12 <= self.step_size*1.5:\n                        total_cost = n1.cost + n2.cost + dist12\n                        if total_cost + 1e-9 < min_total_cost:\n                            if not self._is_edge_in_obstacle(n1.position, n2.position, obstacles, is_3d, resolution=self.step_size/5):\n                                min_total_cost = total_cost\n                                candidate_pair = (n1,n2)\n            if candidate_pair is not None:\n                extracted_path = extract_path(candidate_pair[0], candidate_pair[1])\n                extracted_path = shortcut_path(extracted_path)\n                success = True\n            else:\n                extracted_path = []\n\n        return PlannerResult(\n            success=success,\n            path=extracted_path,\n            nodes=all_nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -35.41092,
          "time_improvement": 55.0,
          "length_improvement": 15.0,
          "smoothness_improvement": 1973.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.016417622566223145,
                    "num_nodes_avg": 151.9,
                    "path_length_avg": 165.63929068347426,
                    "smoothness_avg": 0.06125909518606807,
                    "success_improvement": 0.0,
                    "time_improvement": 34.940165416687925,
                    "length_improvement": 9.210480053863174,
                    "smoothness_improvement": 858.8378659163208,
                    "objective_score": 20.30252698690589
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.03619728088378906,
                    "num_nodes_avg": 379.6,
                    "path_length_avg": 240.5218456435933,
                    "smoothness_avg": 0.12863602123463258,
                    "success_improvement": 0.0,
                    "time_improvement": 77.92049934774737,
                    "length_improvement": 19.706884886699935,
                    "smoothness_improvement": 3209.8974791481382,
                    "objective_score": 51.24976813208486
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.02301657199859619,
                    "num_nodes_avg": 286.4,
                    "path_length_avg": 126.87756235220226,
                    "smoothness_avg": 0.1534211955820471,
                    "success_improvement": 0.0,
                    "time_improvement": 53.27521442479559,
                    "length_improvement": 15.73396434594209,
                    "smoothness_improvement": 1851.5062834289556,
                    "objective_score": 34.68047435214871
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e2",
          "algorithm_description": "A hybrid bidirectional RRT* planner combining adaptive rewiring radius, goal bias, multi-candidate connectivity between trees each iteration, and progressive shortcutting both during and after planning. The planner alternately grows trees from start and goal, uses an adaptive radius based on the current tree size and dimension for neighborhood searches, attempts multiple connections for early improved path detection, and dynamically shortcuts the current best path to enhance smoothness and path length while enforcing strict collision constraints and a hard 30-second timeout.",
          "planning_mechanism": "A bidirectional, goal-biased RRT* planner expanding two trees alternately with adaptive neighbor radius rewiring, multiple candidate connections between trees each iteration, incremental path shortcutting during planning to enhance path quality, and early termination when improved paths are found, guaranteeing collision-free sampling and edges within map bounds, maximizing planning efficiency and path optimality.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.time_limit = 30.0\n        self.goal_sample_rate = 0.2  # Probability to bias sampling towards goal\n        self.gamma_rrt_star = 35.0  # Multiplier for adaptive radius\n        self.shortcut_interval = 75  # Iterations between incremental shortcut attempts\n\n    def plan(self, map) -> 'PlannerResult':\n        import time\n        import math\n        import random\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = dim == 3\n\n        # Initialization\n        start_tree = [Node(start_pos, cost=0.0)]\n        goal_tree = [Node(goal_pos, cost=0.0)]\n        nodes = start_tree[:] + goal_tree[:]\n        edges = []\n\n        best_connection = None\n        best_cost = float('inf')\n        success = False\n        extracted_path = []\n\n        start_time = time.monotonic()\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def sample_free():\n            # Goal biased sampling\n            if random.random() < self.goal_sample_rate:\n                return goal_pos\n            for _ in range(100):\n                p = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n            return goal_pos  # fallback if no free sample found\n\n        def nearest(tree, point):\n            best_node = None\n            best_dist = float('inf')\n            for node in tree:\n                d = dist(node.position, point)\n                if d < best_dist:\n                    best_node = node\n                    best_dist = d\n            return best_node\n\n        def near(tree, point, radius):\n            neighbors = []\n            for node in tree:\n                d = dist(node.position, point)\n                if d <= radius:\n                    neighbors.append((d, node))\n            neighbors.sort(key=lambda x: x[0])\n            return [n[1] for n in neighbors]\n\n        def steer(from_p, to_p, max_step):\n            d = dist(from_p, to_p)\n            if d <= max_step:\n                return to_p\n            ratio = max_step / d\n            return tuple(from_p[i] + (to_p[i] - from_p[i]) * ratio for i in range(dim))\n\n        def extract_path(node_start, node_goal):\n            path_start = []\n            cur = node_start\n            while cur:\n                path_start.append(cur.position)\n                cur = cur.parent\n            path_start.reverse()\n            path_goal = []\n            cur = node_goal\n            while cur:\n                path_goal.append(cur.position)\n                cur = cur.parent\n            if path_goal and path_start and path_start[-1] == path_goal[0]:\n                path_goal = path_goal[1:]\n            return path_start + path_goal\n\n        def shortcut_path(path, max_attempts=50):\n            if len(path) < 3:\n                return path\n            for _ in range(max_attempts):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution=max(self.step_size * 0.2, 0.2)):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        def rewire(tree, new_node, neighbors):\n            for nbr in neighbors:\n                if nbr is new_node.parent:\n                    continue\n                cost_through = new_node.cost + dist(new_node.position, nbr.position)\n                if cost_through + 1e-9 < nbr.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, nbr.position, obstacles, is_3d, resolution=max(self.step_size * 0.2, 0.2)):\n                        if nbr.parent:\n                            try:\n                                edges.remove((nbr.parent, nbr))\n                            except Exception:\n                                pass\n                            nbr.parent.remove_child(nbr)\n                        nbr.parent = new_node\n                        nbr.cost = cost_through\n                        new_node.add_child(nbr)\n                        edges.append((new_node, nbr))\n\n        def try_connect(new_node, other_tree):\n            radius = self.step_size * 2.5\n            candidates = near(other_tree, new_node.position, radius)\n            best_cand = None\n            best_local_cost = float('inf')\n            for node in candidates:\n                d12 = dist(new_node.position, node.position)\n                if d12 <= radius:\n                    if not self._is_edge_in_obstacle(new_node.position, node.position, obstacles, is_3d, resolution=max(self.step_size * 0.2, 0.2)):\n                        c = new_node.cost + d12 + node.cost\n                        if c < best_local_cost:\n                            best_local_cost = c\n                            best_cand = node\n            return best_cand, best_local_cost\n\n        iter_since_last_shortcut = 0\n\n        for it in range(self.max_iter):\n            if time.monotonic() - start_time > self.time_limit:\n                break\n\n            tree_a = start_tree if (it % 2 == 0) else goal_tree\n            tree_b = goal_tree if (it % 2 == 0) else start_tree\n\n            sample = sample_free()\n            nearest_node = nearest(tree_a, sample)\n            new_pos = steer(nearest_node.position, sample, self.step_size)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d, resolution=max(self.step_size * 0.2, 0.2)):\n                continue\n\n            n_nodes = len(tree_a) + 1\n            radius = self.gamma_rrt_star * ((math.log(n_nodes) / n_nodes) ** (1 / dim)) if n_nodes > 1 else self.step_size * 5\n            radius = max(min(radius, self.step_size * 5), self.step_size)\n\n            neighbors = near(tree_a, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            min_parent = nearest_node\n            for nb in neighbors:\n                cand_cost = nb.cost + dist(nb.position, new_pos)\n                if cand_cost + 1e-9 < min_cost:\n                    if not self._is_edge_in_obstacle(nb.position, new_pos, obstacles, is_3d, resolution=max(self.step_size * 0.2, 0.2)):\n                        min_cost = cand_cost\n                        min_parent = nb\n\n            new_node = Node(new_pos, parent=min_parent, cost=min_cost)\n            min_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((min_parent, new_node))\n\n            rewire(tree_a, new_node, neighbors)\n\n            conn_node, conn_cost = try_connect(new_node, tree_b)\n            if conn_node is not None and conn_cost + 1e-9 < best_cost:\n                best_cost = conn_cost\n                # Keep start_tree node first in best_connection\n                best_connection = (new_node, conn_node) if it % 2 == 0 else (conn_node, new_node)\n                success = True\n                # Early stop for improved path found\n                break\n\n            iter_since_last_shortcut += 1\n            if iter_since_last_shortcut >= self.shortcut_interval and success:\n                current_path = extract_path(best_connection[0], best_connection[1])\n                shortened = shortcut_path(current_path, max_attempts=25)\n                if len(shortened) < len(current_path):\n                    extracted_path = shortened\n                    iter_since_last_shortcut = 0\n\n        if success and best_connection is not None:\n            extracted_path = extract_path(best_connection[0], best_connection[1])\n            extracted_path = shortcut_path(extracted_path, max_attempts=75)\n        elif not success:\n            # Attempt partial best connection if no full success\n            best_partial_cost = float('inf')\n            best_pair = None\n            search_radius = self.step_size * 3.0\n            for n1 in start_tree:\n                candidates = near(goal_tree, n1.position, search_radius)\n                for n2 in candidates:\n                    d12 = dist(n1.position, n2.position)\n                    if d12 <= search_radius:\n                        if not self._is_edge_in_obstacle(n1.position, n2.position, obstacles, is_3d, resolution=max(self.step_size * 0.2, 0.2)):\n                            cost_sum = n1.cost + n2.cost + d12\n                            if cost_sum + 1e-9 < best_partial_cost:\n                                best_partial_cost = cost_sum\n                                best_pair = (n1, n2)\n            if best_pair:\n                success = True\n                extracted_path = extract_path(best_pair[0], best_pair[1])\n                extracted_path = shortcut_path(extracted_path, max_attempts=75)\n\n        return PlannerResult(\n            success=success,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -35.33628,
          "time_improvement": 62.0,
          "length_improvement": 16.0,
          "smoothness_improvement": 1443.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.012826061248779297,
                    "num_nodes_avg": 119.9,
                    "path_length_avg": 166.2253590778505,
                    "smoothness_avg": 0.03994349193242207,
                    "success_improvement": 0.0,
                    "time_improvement": 49.17282207974543,
                    "length_improvement": 8.889246680057553,
                    "smoothness_improvement": 525.2023874234374,
                    "objective_score": 22.711406569075347
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.031331658363342285,
                    "num_nodes_avg": 352.8,
                    "path_length_avg": 237.6735433615076,
                    "smoothness_avg": 0.09937583806217681,
                    "success_improvement": 0.0,
                    "time_improvement": 80.8884160804634,
                    "length_improvement": 20.65773017229562,
                    "smoothness_improvement": 2457.01189086278,
                    "objective_score": 48.94622238183029
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.021689653396606445,
                    "num_nodes_avg": 282.4,
                    "path_length_avg": 123.38229733148862,
                    "smoothness_avg": 0.1136377273219493,
                    "success_improvement": 0.0,
                    "time_improvement": 55.96892516319323,
                    "length_improvement": 18.055352946065405,
                    "smoothness_improvement": 1345.4635036706793,
                    "objective_score": 34.3512068349506
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "A simplified bidirectional RRT* planner emphasizing adaptive neighborhood radius, goal-biased sampling, and efficient rewiring. The planner alternates between growing two trees from start and goal positions, uses an adaptive radius that shrinks as the trees grow to limit rewiring scope, selectively rewires neighbors to improve path cost, attempts multiple connections to the opposite tree for early path discovery, and performs final path shortcutting to enhance smoothness. Time is strictly limited to 30 seconds with early termination upon finding a high-quality path.",
          "planning_mechanism": "A bidirectional RRT* algorithm that grows two trees alternately towards random samples biased towards the goal, uses adaptive radius calculations for neighbor search and rewiring proportional to tree size and problem dimension, selects parents and rewires neighbors based on path cost improvements, attempts multiple connection candidates between the two trees each iteration for improved convergence, and applies shortcutting after path extraction to smooth the final path. The planner enforces collision checks on nodes and edges and respects a hard 30-second time limit for planning.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=5.0, goal_sample_rate=0.15):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.time_limit = 30.0\n\n    def plan(self, map):\n        import time\n        import math\n        import random\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = dim == 3\n\n        gamma_rrt_star = 50.0  # neighborhood radius constant\n        max_radius_factor = self.step_size * 5.0\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        # Samples a point free of obstacles, with goal bias\n        def sample_free():\n            if random.random() < self.goal_sample_rate:\n                return goal_pos\n            for _ in range(100):\n                p = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n            return goal_pos\n\n        # Find nearest node in tree to point (linear search)\n        def nearest(tree, point):\n            best_node = None\n            best_dist = float('inf')\n            for node in tree:\n                d = dist(node.position, point)\n                if d < best_dist:\n                    best_node = node\n                    best_dist = d\n            return best_node\n\n        # Find neighbors within radius\n        def near(tree, point, radius):\n            results = []\n            for node in tree:\n                d = dist(node.position, point)\n                if d <= radius:\n                    results.append((d, node))\n            results.sort(key=lambda x: x[0])\n            return [n[1] for n in results]\n\n        # Steer towards point by step_size\n        def steer(from_p, to_p, max_step):\n            d = dist(from_p, to_p)\n            if d <= max_step:\n                return to_p\n            ratio = max_step / d\n            return tuple(from_p[i] + (to_p[i] - from_p[i]) * ratio for i in range(dim))\n\n        # Extract path by traversing from node up to root\n        def path_from_start(node):\n            p = []\n            cur = node\n            while cur:\n                p.append(cur.position)\n                cur = cur.parent\n            return p[::-1]\n\n        # Combine two paths at connection nodes\n        def extract_path(node_start, node_goal):\n            return path_from_start(node_start) + path_from_start(node_goal)[::-1]\n\n        # Shortcut path by randomly connecting non-adjacent nodes if collision free\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            max_attempts = 100\n            for _ in range(max_attempts):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        # Attempt multiple connections to other tree within radius\n        def try_connect(node, other_tree, radius):\n            candidates = near(other_tree, node.position, radius)\n            best_node = None\n            best_cost = float('inf')\n            for cnode in candidates:\n                d = dist(node.position, cnode.position)\n                if d <= radius:\n                    if not self._is_edge_in_obstacle(node.position, cnode.position, obstacles, is_3d):\n                        cost = node.cost + d + cnode.cost\n                        if cost < best_cost:\n                            best_cost = cost\n                            best_node = cnode\n            return best_node, best_cost\n\n        start_tree = [Node(start_pos, cost=0.0)]\n        goal_tree = [Node(goal_pos, cost=0.0)]\n        nodes = start_tree[:] + goal_tree[:]\n        edges = []\n\n        best_connection = None\n        best_cost = float('inf')\n        success = False\n\n        start_time = time.monotonic()\n\n        for it in range(self.max_iter):\n            if time.monotonic() - start_time > self.time_limit:\n                break\n\n            tree_a = start_tree if it % 2 == 0 else goal_tree\n            tree_b = goal_tree if it % 2 == 0 else start_tree\n\n            sample = sample_free()\n            nearest_node = nearest(tree_a, sample)\n            new_pos = steer(nearest_node.position, sample, self.step_size)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            n_nodes = len(tree_a) + 1\n            radius = min(max_radius_factor, gamma_rrt_star * (math.log(n_nodes) / n_nodes) ** (1 / dim))\n\n            near_nodes = near(tree_a, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            min_parent = nearest_node\n            for near_node in near_nodes:\n                cost_through = near_node.cost + dist(near_node.position, new_pos)\n                if cost_through < min_cost:\n                    if not self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d):\n                        min_cost = cost_through\n                        min_parent = near_node\n\n            new_node = Node(new_pos, parent=min_parent, cost=min_cost)\n            min_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((min_parent, new_node))\n\n            for near_node in near_nodes:\n                if near_node is min_parent:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, near_node.position)\n                if new_cost < near_node.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                        if near_node.parent:\n                            try:\n                                edges.remove((near_node.parent, near_node))\n                            except ValueError:\n                                pass\n                            near_node.parent.remove_child(near_node)\n                        near_node.parent = new_node\n                        near_node.cost = new_cost\n                        new_node.add_child(near_node)\n                        edges.append((new_node, near_node))\n\n            candidate_node, candidate_cost = try_connect(new_node, tree_b, radius)\n            if candidate_node and candidate_cost < best_cost:\n                best_cost = candidate_cost\n                best_connection = (new_node, candidate_node)\n                success = True\n                break\n\n        extracted_path = []\n        if success and best_connection:\n            extracted_path = extract_path(best_connection[0], best_connection[1])\n            extracted_path = shortcut_path(extracted_path)\n        else:\n            # Try to find best partial connection after time or iteration limit\n            min_cost = float('inf')\n            best_pair = None\n            for n1 in start_tree:\n                candidates = near(goal_tree, n1.position, self.step_size * 2.0)\n                for n2 in candidates:\n                    dist12 = dist(n1.position, n2.position)\n                    if dist12 <= self.step_size * 2.0:\n                        if not self._is_edge_in_obstacle(n1.position, n2.position, obstacles, is_3d):\n                            total_cost = n1.cost + n2.cost + dist12\n                            if total_cost < min_cost:\n                                min_cost = total_cost\n                                best_pair = (n1, n2)\n            if best_pair:\n                extracted_path = extract_path(best_pair[0], best_pair[1])\n                extracted_path = shortcut_path(extracted_path)\n                success = True\n\n        return PlannerResult(\n            success=success,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=None):\n        import math\n        if resolution is None:\n            resolution = self.step_size / 5.0\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -35.02465,
          "time_improvement": 62.0,
          "length_improvement": 16.0,
          "smoothness_improvement": 1338.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.014973735809326172,
                    "num_nodes_avg": 100.0,
                    "path_length_avg": 164.06931857874386,
                    "smoothness_avg": 0.0462349451248111,
                    "success_improvement": 0.0,
                    "time_improvement": 40.66200688196913,
                    "length_improvement": 10.071006642265907,
                    "smoothness_improvement": 623.6772919936026,
                    "objective_score": 21.359592509918294
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.02514317035675049,
                    "num_nodes_avg": 295.6,
                    "path_length_avg": 233.50230248538378,
                    "smoothness_avg": 0.0900000244936007,
                    "success_improvement": 0.0,
                    "time_improvement": 84.66325003599387,
                    "length_improvement": 22.050210439257324,
                    "smoothness_improvement": 2215.765454617767,
                    "objective_score": 49.70792854744139
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.01985325813293457,
                    "num_nodes_avg": 219.8,
                    "path_length_avg": 124.90025967338326,
                    "smoothness_avg": 0.1001426301281518,
                    "success_improvement": 0.0,
                    "time_improvement": 59.696898856739885,
                    "length_improvement": 17.047194636178148,
                    "smoothness_improvement": 1173.8068634700342,
                    "objective_score": 34.006420756079024
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "cross_over",
          "algorithm_description": "A hybrid bidirectional RRT* planner employing adaptive neighborhood radius rewiring, goal-biased sampling, multiple candidate connections, and progressive path shortcutting during planning to sharply reduce planning time while minimizing path length and enhancing smoothness and robustness. The planner dynamically balances exploration and exploitation, enforces efficient collision checks, and terminates early when high-quality paths are found.",
          "planning_mechanism": "The planner iteratively grows two trees from start and goal by sampling with a controlled goal bias, steering nearest nodes toward samples using fixed step size, and rewiring nodes within an adaptively shrinking radius based on node density and problem dimension. Each iteration attempts multiple candidate connections across trees with fine collision checking. Progressive shortcutting is applied periodically to smooth the path during planning. The algorithm respects map bounds, collision constraints, and employs a hard 30-second time limit, returning the best feasible path found.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.time_limit = 30.0\n        self.goal_sample_rate = 0.15  # goal bias probability\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n        import time\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        start_tree = [Node(start_pos, cost=0.0)]\n        goal_tree = [Node(goal_pos, cost=0.0)]\n        nodes = start_tree[:] + goal_tree[:]\n        edges = []\n\n        gamma_rrt_star = 35.0  # neighborhood radius constant tuned\n\n        best_connection = None  # tuple(Node from start_tree, Node from goal_tree)\n        best_cost = float('inf')\n        success = False\n\n        step_size = self.step_size\n        start_time = time.monotonic()\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def sample_free():\n            # goal biased sampling with fallback attempts\n            if random.random() < self.goal_sample_rate:\n                return goal_pos\n            for _ in range(100):\n                p = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n            return goal_pos  # fallback if no samples found\n\n        def nearest(tree, point):\n            best_node = None\n            best_d = float('inf')\n            for node in tree:\n                d = dist(node.position, point)\n                if d < best_d:\n                    best_d = d\n                    best_node = node\n            return best_node\n\n        def near(tree, point, radius):\n            neighbors = []\n            for node in tree:\n                d = dist(node.position, point)\n                if d <= radius:\n                    neighbors.append((d, node))\n            neighbors.sort(key=lambda x: x[0])\n            return [n[1] for n in neighbors]\n\n        def steer(from_p, to_p, max_step):\n            d = dist(from_p, to_p)\n            if d <= max_step:\n                return to_p\n            ratio = max_step / d\n            return tuple(from_p[i] + (to_p[i] - from_p[i]) * ratio for i in range(dim))\n\n        def extract_path(n_start, n_goal):\n            path_start = []\n            cur = n_start\n            while cur is not None:\n                path_start.append(cur.position)\n                cur = cur.parent\n            path_start.reverse()\n            path_goal = []\n            cur = n_goal\n            while cur is not None:\n                path_goal.append(cur.position)\n                cur = cur.parent\n            if path_start and path_goal and path_start[-1] == path_goal[0]:\n                path_goal = path_goal[1:]\n            return path_start + path_goal\n\n        def shortcut_path(path, max_attempts=50):\n            # Progressive shortcutting to smooth and shorten paths\n            if len(path) < 3:\n                return path\n            for _ in range(max_attempts):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1 = path[i]\n                p2 = path[j]\n                if not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution=max(step_size * 0.2, 0.2)):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        def try_connect(new_node, other_tree):\n            radius = step_size * 2.5\n            candidates = near(other_tree, new_node.position, radius)\n            best_cand = None\n            best_cost_local = float('inf')\n            for node in candidates:\n                dist_between = dist(new_node.position, node.position)\n                if dist_between <= radius:\n                    if not self._is_edge_in_obstacle(new_node.position, node.position, obstacles, is_3d, resolution=max(step_size * 0.2, 0.2)):\n                        total_cost = new_node.cost + dist_between + node.cost\n                        if total_cost < best_cost_local:\n                            best_cost_local = total_cost\n                            best_cand = node\n            return best_cand, best_cost_local\n\n        def rewire(tree, new_node, neighbors):\n            for neighbor in neighbors:\n                if neighbor is new_node.parent:\n                    continue\n                cost_through = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_through + 1e-9 < neighbor.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d, resolution=max(step_size * 0.2, 0.2)):\n                        if neighbor.parent:\n                            try:\n                                edges.remove((neighbor.parent, neighbor))\n                            except Exception:\n                                pass\n                            neighbor.parent.remove_child(neighbor)\n                        neighbor.parent = new_node\n                        neighbor.cost = cost_through\n                        new_node.add_child(neighbor)\n                        edges.append((new_node, neighbor))\n\n        iter_since_last_shortcut = 0\n        shortcut_interval = 75\n\n        for it in range(self.max_iter):\n            if time.monotonic() - start_time > self.time_limit:\n                break\n\n            tree_a = start_tree if it % 2 == 0 else goal_tree\n            tree_b = goal_tree if it % 2 == 0 else start_tree\n\n            sample = sample_free()\n            nearest_node = nearest(tree_a, sample)\n            new_pos = steer(nearest_node.position, sample, step_size)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d, resolution=max(step_size * 0.2, 0.2)):\n                continue\n\n            n_nodes = len(tree_a) + 1\n            radius = max(step_size, min(step_size * 5, gamma_rrt_star * ((math.log(n_nodes) / n_nodes) ** (1 / dim))))\n\n            neighbors = near(tree_a, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            min_parent = nearest_node\n            for nb in neighbors:\n                candidate_cost = nb.cost + dist(nb.position, new_pos)\n                if candidate_cost + 1e-9 < min_cost:\n                    if not self._is_edge_in_obstacle(nb.position, new_pos, obstacles, is_3d, resolution=max(step_size * 0.2, 0.2)):\n                        min_cost = candidate_cost\n                        min_parent = nb\n\n            new_node = Node(new_pos, parent=min_parent, cost=min_cost)\n            min_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((min_parent, new_node))\n\n            rewire(tree_a, new_node, neighbors)\n\n            conn_node, conn_cost = try_connect(new_node, tree_b)\n            if conn_node is not None and conn_cost + 1e-9 < best_cost:\n                best_cost = conn_cost\n                best_connection = (new_node, conn_node) if it % 2 == 0 else (conn_node, new_node)\n                success = True\n                # Early stop on improved solution\n                break\n\n            iter_since_last_shortcut += 1\n            if iter_since_last_shortcut >= shortcut_interval and success:\n                path_cur = extract_path(best_connection[0], best_connection[1])\n                path_short = shortcut_path(path_cur, max_attempts=25)\n                if len(path_short) < len(path_cur):\n                    iter_since_last_shortcut = 0\n                    # Replace best path with shortcut\n                    # We'll re-extract path before return to keep tree coherence\n                    extracted_path = path_short\n\n        extracted_path = []\n        if success and best_connection is not None:\n            extracted_path = extract_path(best_connection[0], best_connection[1])\n            extracted_path = shortcut_path(extracted_path, max_attempts=75)\n        else:\n            # No full success: find best partial connection\n            best_partial_cost = float('inf')\n            best_pair = None\n            search_radius = step_size * 3.0\n            for n1 in start_tree:\n                candidates = near(goal_tree, n1.position, search_radius)\n                for n2 in candidates:\n                    dist_12 = dist(n1.position, n2.position)\n                    if dist_12 <= search_radius:\n                        if not self._is_edge_in_obstacle(n1.position, n2.position, obstacles, is_3d, resolution=max(step_size * 0.2, 0.2)):\n                            total_cost = n1.cost + n2.cost + dist_12\n                            if total_cost + 1e-9 < best_partial_cost:\n                                best_partial_cost = total_cost\n                                best_pair = (n1, n2)\n            if best_pair:\n                success = True\n                extracted_path = extract_path(best_pair[0], best_pair[1])\n                extracted_path = shortcut_path(extracted_path, max_attempts=75)\n\n        return PlannerResult(\n            success=success,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -34.6527,
          "time_improvement": 61.0,
          "length_improvement": 16.0,
          "smoothness_improvement": 1381.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.011872506141662598,
                    "num_nodes_avg": 107.7,
                    "path_length_avg": 163.66283892228535,
                    "smoothness_avg": 0.04201284504332733,
                    "success_improvement": 0.0,
                    "time_improvement": 52.95157489763024,
                    "length_improvement": 10.29380458305316,
                    "smoothness_improvement": 557.5922572813087,
                    "objective_score": 24.849716505527507
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.02488439083099365,
                    "num_nodes_avg": 310.2,
                    "path_length_avg": 240.20474907561953,
                    "smoothness_avg": 0.09852207245217506,
                    "success_improvement": 0.0,
                    "time_improvement": 84.82109953651525,
                    "length_improvement": 19.812740848208225,
                    "smoothness_improvement": 2435.0438867749226,
                    "objective_score": 49.509193803754115
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.02670140266418457,
                    "num_nodes_avg": 301.3,
                    "path_length_avg": 125.20170451544436,
                    "smoothness_avg": 0.09831100843591407,
                    "success_improvement": 0.0,
                    "time_improvement": 45.794824958412164,
                    "length_improvement": 16.846989325342022,
                    "smoothness_improvement": 1150.5087707410203,
                    "objective_score": 29.599184936433964
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "path_expert",
          "algorithm_description": "A bidirectional, asymmetrically goal-biased RRT* planner implementing adaptive neighborhood radius rewiring, multi-candidate connection attempts across trees, and incremental path shortcutting during planning for improved efficiency, shorter and smoother paths, and robustness within a strict 30-second time limit. It alternates tree expansions while dynamically updating rewiring radii and performs fine-resolution collision checks, early stopping on improved connections, and progressive shortcutting to optimize path quality.",
          "planning_mechanism": "A bidirectional RRT* framework grows start and goal trees, sampling with a controlled goal bias. New nodes are connected with cost-based parent selection and rewiring within an adaptively shrinking radius based on node density and dimension. Multiple candidate connections to the opposite tree are attempted each iteration, improving connection quality and enabling early termination. Progressive shortcutting is applied periodically to smooth intermediate paths during planning. The search respects map bounds and obstacle collisions, enforcing a hard 30-second limit, and outputs the best feasible path found.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float = 0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children: List[Node] = []\n        self.valid = True\n    def add_child(self, child):\n        self.children.append(child)\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.time_limit = 30.0\n        self.goal_sample_rate = 0.15  # Controlled goal biasing\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = dim == 3\n\n        gamma_rrt_star = 35.0  # Tuned constant for neighborhood radius\n\n        # Initialize bidirectional trees: list of Node\n        start_tree = [Node(start_pos, cost=0.0)]\n        goal_tree = [Node(goal_pos, cost=0.0)]\n        nodes = start_tree[:] + goal_tree[:]\n        edges = []\n\n        best_connection = None  # tuple of (Node from start_tree, Node from goal_tree)\n        best_cost = float('inf')\n        success = False\n\n        step_size = self.step_size\n        start_time = time.monotonic()\n\n        def dist(a: Tuple[float, ...], b: Tuple[float, ...]) -> float:\n            return math.dist(a, b)\n\n        def sample_free() -> Tuple[float, ...]:\n            # Goal bias: sample goal with goal_sample_rate probability\n            if random.random() < self.goal_sample_rate:\n                return goal_pos\n            for _ in range(100):\n                p = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n            return goal_pos  # fallback\n\n        def nearest(tree: List[Node], point: Tuple[float, ...]) -> Node:\n            best_node = None\n            best_d = float('inf')\n            for node in tree:\n                d = dist(node.position, point)\n                if d < best_d:\n                    best_d = d\n                    best_node = node\n            return best_node\n\n        def near(tree: List[Node], point: Tuple[float, ...], radius: float) -> List[Node]:\n            neighbors = []\n            for node in tree:\n                d = dist(node.position, point)\n                if d <= radius:\n                    neighbors.append((d, node))\n            neighbors.sort(key=lambda x: x[0])\n            return [n[1] for n in neighbors]\n\n        def steer(from_p: Tuple[float, ...], to_p: Tuple[float, ...], max_step: float) -> Tuple[float, ...]:\n            d = dist(from_p, to_p)\n            if d <= max_step:\n                return to_p\n            ratio = max_step / d\n            return tuple(from_p[i] + (to_p[i] - from_p[i]) * ratio for i in range(dim))\n\n        def extract_path(n_start: Node, n_goal: Node) -> List[Tuple[float, ...]]:\n            path_start = []\n            cur = n_start\n            while cur is not None:\n                path_start.append(cur.position)\n                cur = cur.parent\n            path_start.reverse()\n            path_goal = []\n            cur = n_goal\n            while cur is not None:\n                path_goal.append(cur.position)\n                cur = cur.parent\n            # avoid duplicate connection node position\n            if path_goal and path_start and path_start[-1] == path_goal[0]:\n                path_goal = path_goal[1:]\n            return path_start + path_goal\n\n        def shortcut_path(path: List[Tuple[float, ...]], max_attempts=50) -> List[Tuple[float, ...]]:\n            # Progressive shortcutting: attempt random shortcuts to smooth path preserving collision constraints\n            if len(path) < 3:\n                return path\n            for _ in range(max_attempts):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1 = path[i]\n                p2 = path[j]\n                # Check if shortcut collision free\n                if not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution=max(self.step_size * 0.2, 0.2)):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        def try_connect(new_node: Node, other_tree: List[Node]) -> Tuple[Node, float]:\n            radius = step_size * 2.5\n            candidates = near(other_tree, new_node.position, radius)\n            best_cand = None\n            best_cost_local = float('inf')\n            for node in candidates:\n                dist_between = dist(new_node.position, node.position)\n                if dist_between <= radius and not self._is_edge_in_obstacle(new_node.position, node.position, obstacles, is_3d, resolution=max(step_size * 0.2, 0.2)):\n                    total_cost = new_node.cost + dist_between + node.cost\n                    if total_cost < best_cost_local:\n                        best_cost_local = total_cost\n                        best_cand = node\n            return best_cand, best_cost_local\n\n        def rewire(tree: List[Node], new_node: Node, neighbors: List[Node]) -> None:\n            for neighbor in neighbors:\n                if neighbor is new_node.parent:\n                    continue\n                cost_through = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_through + 1e-9 < neighbor.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d, resolution=max(step_size * 0.2, 0.2)):\n                        # rewire: switch parent\n                        if neighbor.parent:\n                            try:\n                                edges.remove((neighbor.parent, neighbor))\n                            except Exception:\n                                pass\n                            neighbor.parent.remove_child(neighbor)\n                        neighbor.parent = new_node\n                        neighbor.cost = cost_through\n                        new_node.add_child(neighbor)\n                        edges.append((new_node, neighbor))\n\n        iter_since_last_shortcut = 0\n        shortcut_interval = 75\n\n        for it in range(self.max_iter):\n            if time.monotonic() - start_time > self.time_limit:\n                break\n\n            tree_a = start_tree if it % 2 == 0 else goal_tree\n            tree_b = goal_tree if it % 2 == 0 else start_tree\n\n            sample = sample_free()\n            nearest_node = nearest(tree_a, sample)\n            new_pos = steer(nearest_node.position, sample, step_size)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d, resolution=max(step_size * 0.2, 0.2)):\n                continue\n\n            n_nodes = len(tree_a) + 1\n            radius = min(step_size * 5,\n                         gamma_rrt_star * ((math.log(n_nodes) / n_nodes) ** (1 / dim)))\n            if radius < step_size:\n                radius = step_size  # at least step size\n\n            neighbors = near(tree_a, new_pos, radius)\n\n            # Find best parent node (lowest cost + dist) collision safe\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            min_parent = nearest_node\n            for nb in neighbors:\n                cost_candidate = nb.cost + dist(nb.position, new_pos)\n                if cost_candidate + 1e-9 < min_cost:\n                    if not self._is_edge_in_obstacle(nb.position, new_pos, obstacles, is_3d, resolution=max(step_size * 0.2, 0.2)):\n                        min_cost = cost_candidate\n                        min_parent = nb\n\n            new_node = Node(new_pos, parent=min_parent, cost=min_cost)\n            min_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((min_parent, new_node))\n\n            rewire(tree_a, new_node, neighbors)\n\n            # Try connect new_node to other tree with multiple candidates\n            conn_node, conn_cost = try_connect(new_node, tree_b)\n            if conn_node is not None and conn_cost + 1e-9 < best_cost:\n                best_cost = conn_cost\n                best_connection = (new_node, conn_node) if it % 2 == 0 else (conn_node, new_node)\n                success = True\n                # Early stop on improved connection\n                break\n\n            # Periodic incremental shortcutting to improve intermediate path smoothness & length\n            iter_since_last_shortcut += 1\n            if iter_since_last_shortcut >= shortcut_interval and success:\n                path_cur = extract_path(best_connection[0], best_connection[1])\n                path_short = shortcut_path(path_cur, max_attempts=25)\n                # If shortcut reduces nodes substantially, update best path extracted immediately\n                if len(path_short) < len(path_cur):\n                    # Reset iter counter to avoid shortcutting excessive times\n                    iter_since_last_shortcut = 0\n                    extracted_path = path_short\n\n        extracted_path: List[Tuple[float, ...]] = []\n        if success and best_connection is not None:\n            extracted_path = extract_path(best_connection[0], best_connection[1])\n            extracted_path = shortcut_path(extracted_path, max_attempts=75)\n        else:\n            # If no success, try find best partial connection\n            best_partial_cost = float('inf')\n            best_pair = None\n            search_radius = step_size * 3.0\n            for n1 in start_tree:\n                candidates = near(goal_tree, n1.position, search_radius)\n                for n2 in candidates:\n                    d12 = dist(n1.position, n2.position)\n                    if d12 <= search_radius:\n                        if not self._is_edge_in_obstacle(n1.position, n2.position, obstacles, is_3d, resolution=max(step_size * 0.2, 0.2)):\n                            total_cost = n1.cost + n2.cost + d12\n                            if total_cost + 1e-9 < best_partial_cost:\n                                best_partial_cost = total_cost\n                                best_pair = (n1, n2)\n            if best_pair:\n                success = True\n                extracted_path = extract_path(best_pair[0], best_pair[1])\n                extracted_path = shortcut_path(extracted_path, max_attempts=75)\n\n        return PlannerResult(\n            success=success,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -34.56709,
          "time_improvement": 61.0,
          "length_improvement": 15.0,
          "smoothness_improvement": 1406.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.012232446670532226,
                    "num_nodes_avg": 111.9,
                    "path_length_avg": 161.78749064589732,
                    "smoothness_avg": 0.04188267931246853,
                    "success_improvement": 0.0,
                    "time_improvement": 51.11976593857507,
                    "length_improvement": 11.32171269013654,
                    "smoothness_improvement": 555.5548809339598,
                    "objective_score": 24.906731800324245
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.02393496036529541,
                    "num_nodes_avg": 300.9,
                    "path_length_avg": 242.85620828482826,
                    "smoothness_avg": 0.08907932627121147,
                    "success_improvement": 0.0,
                    "time_improvement": 85.36215473141678,
                    "length_improvement": 18.927607446152585,
                    "smoothness_improvement": 2192.075226203567,
                    "objective_score": 47.92558701813442
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.026720166206359863,
                    "num_nodes_avg": 317.0,
                    "path_length_avg": 126.2475615470681,
                    "smoothness_avg": 0.123441994873119,
                    "success_improvement": 0.0,
                    "time_improvement": 46.08887272601328,
                    "length_improvement": 16.152380883297628,
                    "smoothness_improvement": 1470.173063245805,
                    "objective_score": 30.868955664011587
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "A simplified bidirectional RRT* planner with uniform sampling, fixed rewiring radius, and single candidate connection attempts for faster generalization and easier implementation. The planner alternates growing two trees from start and goal, connects new samples through nearest nodes, rewires neighbors within a fixed radius to improve local paths, and performs a single connection attempt between trees each iteration. The algorithm enforces collision checking and terminates after a 30-second hard time limit or upon connecting the trees. Final path shortcutting is applied for path smoothing.",
          "planning_mechanism": "A bidirectional RRT* method using uniform random sampling, fixed neighborhood radius for rewiring, and single connection attempts between trees. The planner alternately expands start and goal trees by sampling, steering with fixed step size, rewiring neighbors within a set radius, attempts one connection to the opposite tree per iteration, and applies shortcutting post-planning. Collision checks ensure feasibility, and planning stops when trees connect or time limit is reached.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=5.0, radius=15.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.radius = radius\n        self.time_limit = 30.0\n\n    def plan(self, map):\n        import time\n        import math\n        import random\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = dim == 3\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def sample_free():\n            for _ in range(100):\n                p = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n            return goal_pos\n\n        def nearest(tree, point):\n            best_node = None\n            best_dist = float('inf')\n            for node in tree:\n                d = dist(node.position, point)\n                if d < best_dist:\n                    best_node = node\n                    best_dist = d\n            return best_node\n\n        def near(tree, point, radius):\n            result = []\n            for node in tree:\n                if dist(node.position, point) <= radius:\n                    result.append(node)\n            return result\n\n        def steer(from_p, to_p, max_step):\n            d = dist(from_p, to_p)\n            if d <= max_step:\n                return to_p\n            ratio = max_step / d\n            return tuple(from_p[i] + (to_p[i] - from_p[i]) * ratio for i in range(dim))\n\n        def path_from_root(node):\n            p = []\n            cur = node\n            while cur:\n                p.append(cur.position)\n                cur = cur.parent\n            return p[::-1]\n\n        def extract_path(node_start, node_goal):\n            return path_from_root(node_start) + path_from_root(node_goal)[::-1]\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            max_attempts = 50\n            for _ in range(max_attempts):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        def can_connect(node, other_tree):\n            # Try single nearest neighbor connection\n            nn = nearest(other_tree, node.position)\n            d = dist(node.position, nn.position)\n            if d <= self.step_size * 2:\n                if not self._is_edge_in_obstacle(node.position, nn.position, obstacles, is_3d):\n                    return nn\n            return None\n\n        start_tree = [Node(start_pos, cost=0.0)]\n        goal_tree = [Node(goal_pos, cost=0.0)]\n        nodes = start_tree[:] + goal_tree[:]\n        edges = []\n\n        success = False\n        best_connection = None\n\n        start_time = time.monotonic()\n\n        for it in range(self.max_iter):\n            if time.monotonic() - start_time > self.time_limit:\n                break\n\n            tree_a = start_tree if it % 2 == 0 else goal_tree\n            tree_b = goal_tree if it % 2 == 0 else start_tree\n\n            q_rand = sample_free()\n            nearest_node = nearest(tree_a, q_rand)\n            q_new_pos = steer(nearest_node.position, q_rand, self.step_size)\n\n            if self._is_in_obstacle(q_new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, q_new_pos, obstacles, is_3d):\n                continue\n\n            near_nodes = near(tree_a, q_new_pos, self.radius)\n            min_cost = nearest_node.cost + dist(nearest_node.position, q_new_pos)\n            min_parent = nearest_node\n            for node_near in near_nodes:\n                tentative_cost = node_near.cost + dist(node_near.position, q_new_pos)\n                if tentative_cost < min_cost:\n                    if not self._is_edge_in_obstacle(node_near.position, q_new_pos, obstacles, is_3d):\n                        min_cost = tentative_cost\n                        min_parent = node_near\n\n            new_node = Node(q_new_pos, parent=min_parent, cost=min_cost)\n            min_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((min_parent, new_node))\n\n            for node_near in near_nodes:\n                if node_near is min_parent:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, node_near.position)\n                if new_cost < node_near.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, node_near.position, obstacles, is_3d):\n                        if node_near.parent:\n                            try:\n                                edges.remove((node_near.parent, node_near))\n                            except ValueError:\n                                pass\n                            node_near.parent.remove_child(node_near)\n                        node_near.parent = new_node\n                        node_near.cost = new_cost\n                        new_node.add_child(node_near)\n                        edges.append((new_node, node_near))\n\n            connect_node = can_connect(new_node, tree_b)\n            if connect_node:\n                success = True\n                best_connection = (new_node, connect_node)\n                break\n\n        extracted_path = []\n        if success and best_connection:\n            extracted_path = extract_path(best_connection[0], best_connection[1])\n            extracted_path = shortcut_path(extracted_path)\n\n        return PlannerResult(\n            success=success,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=None):\n        import math\n        if resolution is None:\n            resolution = self.step_size / 5.0\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -33.44837,
          "time_improvement": 60.0,
          "length_improvement": 16.0,
          "smoothness_improvement": 1127.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.017261242866516112,
                    "num_nodes_avg": 125.1,
                    "path_length_avg": 169.26443026978103,
                    "smoothness_avg": 0.03777728873980467,
                    "success_improvement": 0.0,
                    "time_improvement": 31.59706278615822,
                    "length_improvement": 7.223483602595675,
                    "smoothness_improvement": 491.29660347345225,
                    "objective_score": 16.269692014772133
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.02262437343597412,
                    "num_nodes_avg": 263.3,
                    "path_length_avg": 230.0918053948804,
                    "smoothness_avg": 0.06918445773371493,
                    "success_improvement": 0.0,
                    "time_improvement": 86.19965765826035,
                    "length_improvement": 23.188732533783156,
                    "smoothness_improvement": 1680.1659290391842,
                    "objective_score": 48.173966462943916
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.017999649047851562,
                    "num_nodes_avg": 221.6,
                    "path_length_avg": 123.41943787675473,
                    "smoothness_avg": 0.1029110691665013,
                    "success_improvement": 0.0,
                    "time_improvement": 63.45981746364785,
                    "length_improvement": 18.030685964342368,
                    "smoothness_improvement": 1209.0212036929265,
                    "objective_score": 35.90146283616441
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m1",
          "algorithm_description": "A bidirectional RRT* planner implementing adaptive rewiring with an adaptive neighborhood radius, probabilistic goal bias sampling, multiple candidate connection attempts, and progressive path shortcutting. The algorithm alternates tree expansions (start and goal), rewires local neighborhoods for cost improvement, and incrementally shortcuts paths during search, while enforcing timely termination within a 30-second wall-clock limit. It balances exploration and exploitation to improve planning efficiency, path length, and smoothness.",
          "planning_mechanism": "The planner grow two trees bidirectionally with step-limited expansions guided by goal bias sampling. Each new node rewires neighbors in an adaptive radius that shrinks as trees grow, ensuring efficient local optimization. Candidate connections between trees are assessed each iteration to update best paths and facilitate early stopping. Paths are incrementally shortcut for smoothness and length improvement. Strict collision checking and map bounds are enforced throughout.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position       # Tuple[float, ...]\n        self.parent = parent           # Node or None\n        self.cost = cost               # Cost from start/goal root to this node\n        self.children = []             # List of child nodes\n        self.valid = True              # Used if needed for collision checks\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.time_limit = 30.0\n        self.goal_sample_rate = 0.15  # 15% chance to sample goal, guiding exploration\n\n    def plan(self, map) -> 'PlannerResult':\n        import time\n        import random\n        import math\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        # Constants for rewiring radius calculation and shortcutting\n        gamma_rrt_star = 35.0\n        shortcut_interval = 75\n\n        # Helper functions\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def in_obstacle(pos):\n            for o in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = o\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w_, h_ = o\n                    px, py = pos\n                    if x <= px <= x + w_ and y <= py <= y + h_:\n                        return True\n            return False\n\n        def edge_in_obstacle(a, b, resolution=1.0):\n            distance = dist(a, b)\n            steps = max(1, int(distance / resolution))\n            for i in range(steps + 1):\n                interp = tuple(a[d] + (b[d] - a[d]) * (i / steps) for d in range(dim))\n                if in_obstacle(interp):\n                    return True\n            return False\n\n        def steer(from_p, to_p, max_step):\n            d = dist(from_p, to_p)\n            if d <= max_step:\n                return to_p\n            ratio = max_step / d\n            return tuple(from_p[i] + ratio * (to_p[i] - from_p[i]) for i in range(dim))\n\n        def sample_free():\n            if random.random() < self.goal_sample_rate:\n                return goal_pos\n            for _ in range(100):\n                p = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not in_obstacle(p):\n                    return p\n            # fallback to goal if unable to sample free after attempts\n            return goal_pos\n\n        def nearest(tree, point):\n            best_node = None\n            best_dist = float('inf')\n            for node in tree:\n                d = dist(node.position, point)\n                if d < best_dist:\n                    best_dist = d\n                    best_node = node\n            return best_node\n\n        def near(tree, point, radius):\n            neighbors = []\n            r_sq = radius * radius\n            for node in tree:\n                dx = node.position\n                # squared distance for efficiency\n                d = 0.0\n                for i in range(dim):\n                    delta = dx[i] - point[i]\n                    d += delta * delta\n                    if d > r_sq:\n                        break\n                if d <= r_sq:\n                    neighbors.append((math.sqrt(d), node))\n            neighbors.sort(key=lambda x: x[0])\n            return [n[1] for n in neighbors]\n\n        def extract_path(node_start, node_goal):\n            path_start = []\n            cur = node_start\n            while cur is not None:\n                path_start.append(cur.position)\n                cur = cur.parent\n            path_start.reverse()\n            path_goal = []\n            cur = node_goal\n            while cur is not None:\n                path_goal.append(cur.position)\n                cur = cur.parent\n            if path_start and path_goal and path_start[-1] == path_goal[0]:\n                path_goal = path_goal[1:]\n            return path_start + path_goal\n\n        def shortcut_path(path, max_attempts=50):\n            if len(path) < 3:\n                return path\n            attempts = 0\n            while attempts < max_attempts and len(path) > 2:\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if not edge_in_obstacle(path[i], path[j], resolution=max(self.step_size * 0.2, 0.2)):\n                    path = path[:i + 1] + path[j:]\n                attempts += 1\n            return path\n\n        def rewire(tree, new_node, neighbors):\n            for neighbor in neighbors:\n                if neighbor is new_node.parent:\n                    continue\n                cost_through = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_through + 1e-9 < neighbor.cost:\n                    if not edge_in_obstacle(new_node.position, neighbor.position, resolution=max(self.step_size * 0.2, 0.2)):\n                        # Rewire: change parent to new_node\n                        if neighbor.parent:\n                            try:\n                                edges.remove((neighbor.parent, neighbor))\n                            except ValueError:\n                                pass\n                            neighbor.parent.remove_child(neighbor)\n                        neighbor.parent = new_node\n                        neighbor.cost = cost_through\n                        new_node.add_child(neighbor)\n                        edges.append((new_node, neighbor))\n\n        def try_connect(new_node, other_tree):\n            radius = self.step_size * 2.5\n            candidates = near(other_tree, new_node.position, radius)\n            best_cand = None\n            best_cost_local = float('inf')\n            for node in candidates:\n                d = dist(new_node.position, node.position)\n                if d <= radius and not edge_in_obstacle(new_node.position, node.position, resolution=max(self.step_size * 0.2, 0.2)):\n                    total_cost = new_node.cost + d + node.cost\n                    if total_cost < best_cost_local:\n                        best_cost_local = total_cost\n                        best_cand = node\n            return best_cand, best_cost_local\n\n        start_tree = [Node(start_pos, cost=0.0)]\n        goal_tree = [Node(goal_pos, cost=0.0)]\n        nodes = start_tree[:] + goal_tree[:]\n        edges = []\n\n        best_connection = None\n        best_cost = float('inf')\n        success = False\n        extracted_path = []\n\n        start_time = time.monotonic()\n        iter_since_last_shortcut = 0\n\n        for it in range(self.max_iter):\n            if time.monotonic() - start_time > self.time_limit:\n                break\n\n            tree_a = start_tree if it % 2 == 0 else goal_tree\n            tree_b = goal_tree if it % 2 == 0 else start_tree\n\n            sample = sample_free()\n            nearest_node = nearest(tree_a, sample)\n            new_pos = steer(nearest_node.position, sample, self.step_size)\n\n            if in_obstacle(new_pos):\n                continue\n            if edge_in_obstacle(nearest_node.position, new_pos, resolution=max(self.step_size * 0.2, 0.2)):\n                continue\n\n            n_nodes = len(tree_a) + 1\n            radius = min(self.step_size * 5,\n                         gamma_rrt_star * ((math.log(n_nodes) / n_nodes) ** (1 / dim)))\n            if radius < self.step_size:\n                radius = self.step_size\n\n            neighbors = near(tree_a, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            min_parent = nearest_node\n            for nb in neighbors:\n                cost_candidate = nb.cost + dist(nb.position, new_pos)\n                if cost_candidate + 1e-9 < min_cost:\n                    if not edge_in_obstacle(nb.position, new_pos, resolution=max(self.step_size * 0.2, 0.2)):\n                        min_cost = cost_candidate\n                        min_parent = nb\n\n            new_node = Node(new_pos, parent=min_parent, cost=min_cost)\n            min_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((min_parent, new_node))\n\n            rewire(tree_a, new_node, neighbors)\n\n            conn_node, conn_cost = try_connect(new_node, tree_b)\n            if conn_node is not None and conn_cost + 1e-9 < best_cost:\n                best_cost = conn_cost\n                best_connection = (new_node, conn_node) if it % 2 == 0 else (conn_node, new_node)\n                success = True\n                # Early stop for improved connection\n                break\n\n            iter_since_last_shortcut += 1\n            if iter_since_last_shortcut >= shortcut_interval and success:\n                path_cur = extract_path(best_connection[0], best_connection[1])\n                path_short = shortcut_path(path_cur, max_attempts=25)\n                if len(path_short) < len(path_cur):\n                    iter_since_last_shortcut = 0\n                    extracted_path = path_short\n\n        if success and best_connection is not None:\n            if not extracted_path:\n                extracted_path = extract_path(best_connection[0], best_connection[1])\n            extracted_path = shortcut_path(extracted_path, max_attempts=75)\n        else:\n            # Attempt to find best partial connection if no success\n            best_partial_cost = float('inf')\n            best_pair = None\n            search_radius = self.step_size * 3.0\n            for n1 in start_tree:\n                candidates = near(goal_tree, n1.position, search_radius)\n                for n2 in candidates:\n                    d12 = dist(n1.position, n2.position)\n                    if d12 <= search_radius:\n                        if not edge_in_obstacle(n1.position, n2.position, resolution=max(self.step_size * 0.2, 0.2)):\n                            total_cost = n1.cost + n2.cost + d12\n                            if total_cost + 1e-9 < best_partial_cost:\n                                best_partial_cost = total_cost\n                                best_pair = (n1, n2)\n            if best_pair:\n                success = True\n                extracted_path = extract_path(best_pair[0], best_pair[1])\n                extracted_path = shortcut_path(extracted_path, max_attempts=75)\n\n        return PlannerResult(\n            success=success,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )",
          "objective": -33.38892,
          "time_improvement": 62.0,
          "length_improvement": 14.0,
          "smoothness_improvement": 1201.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.01741950511932373,
                    "num_nodes_avg": 144.8,
                    "path_length_avg": 170.95768293999285,
                    "smoothness_avg": 0.03857219544748236,
                    "success_improvement": 0.0,
                    "time_improvement": 30.969900360727053,
                    "length_improvement": 6.295384982747003,
                    "smoothness_improvement": 503.7386196161522,
                    "objective_score": 15.586894195947078
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.02476348876953125,
                    "num_nodes_avg": 277.2,
                    "path_length_avg": 240.8097731892848,
                    "smoothness_avg": 0.07867206388588006,
                    "success_improvement": 0.0,
                    "time_improvement": 84.89484698604019,
                    "length_improvement": 19.610766384413225,
                    "smoothness_improvement": 1924.2888689808865,
                    "objective_score": 46.85635827136442
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.01417391300201416,
                    "num_nodes_avg": 190.8,
                    "path_length_avg": 124.2791753311308,
                    "smoothness_avg": 0.10031237330959633,
                    "success_improvement": 0.0,
                    "time_improvement": 71.22625185796103,
                    "length_improvement": 17.459689283444,
                    "smoothness_improvement": 1175.9659842088704,
                    "objective_score": 37.723519048499064
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m1",
          "algorithm_description": "An enhanced bidirectional RRT* planner with adaptive neighborhood radius, efficient rewiring, improved goal bias, and periodic path shortcutting to optimize planning time, path length, and smoothness within a strict time limit. It alternates expanding two trees from start and goal with dynamic radius scaling based on tree size, performs cost-based rewiring, tries multiple candidate connections per iteration with early termination on improvement, and continuously refines the best path through shortcutting.",
          "planning_mechanism": "A bidirectional RRT* alternates tree expansions with adaptive neighborhood search and rewiring radius based on logarithmic scaling of the number of nodes and problem dimension. Sampling uses enhanced goal bias to accelerate convergence. Connecting the two trees employs multi-candidate cost-based edge selection. The algorithm interrupts early after strong improvements or after a 30-second time budget, returning the best path found. Periodic shortcutting improves smoothness and shortens paths incrementally, avoiding excessive computation while maintaining high-quality solutions.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\nclass Planner:\n    def __init__(self, max_iter: int = 6000, step_size: float = 4.5, goal_sample_rate: float = 0.20):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.time_limit = 30.0  # Hard time limit in seconds\n\n    def plan(self, map):\n        import time\n        import math\n        import random\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        gamma_rrt_star = 30.0  # Radius coefficient tuned for improved smoothness\n\n        start_tree = [Node(start_pos, cost=0.0)]\n        goal_tree = [Node(goal_pos, cost=0.0)]\n        nodes = start_tree[:] + goal_tree[:]\n        edges = []\n\n        best_connection = None\n        best_cost = float('inf')\n        success = False\n        found_improvement = False\n\n        start_time = time.monotonic()\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def sample_free():\n            # Enhanced goal bias with moderate attempts for efficiency\n            if random.random() < self.goal_sample_rate:\n                return goal_pos\n            for _ in range(30):\n                p = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n            return goal_pos  # Fallback if no free point found\n\n        def nearest(tree, point):\n            best_node = None\n            best_dist = float('inf')\n            for node in tree:\n                d = dist(node.position, point)\n                if d < best_dist:\n                    best_node = node\n                    best_dist = d\n            return best_node\n\n        def near(tree, point, radius):\n            radius_sq = radius * radius\n            neighbors = []\n            for node in tree:\n                # squared distance for efficiency\n                sq_dist = 0.0\n                for i in range(dim):\n                    diff = node.position[i] - point[i]\n                    sq_dist += diff * diff\n                    if sq_dist > radius_sq:\n                        break\n                if sq_dist <= radius_sq:\n                    neighbors.append((sq_dist, node))\n            neighbors.sort(key=lambda x: x[0])\n            return [nd[1] for nd in neighbors]\n\n        def steer(from_p, to_p, max_step):\n            d = dist(from_p, to_p)\n            if d <= max_step:\n                return to_p\n            ratio = max_step / d\n            return tuple(from_p[i] + (to_p[i] - from_p[i]) * ratio for i in range(dim))\n\n        def extract_path(node_start, node_goal):\n            path_start = []\n            cur = node_start\n            while cur is not None:\n                path_start.append(cur.position)\n                cur = cur.parent\n            path_goal = []\n            cur = node_goal\n            while cur is not None:\n                path_goal.append(cur.position)\n                cur = cur.parent\n            return path_start[::-1] + path_goal\n\n        def shortcut_path(path):\n            max_attempts = 80\n            if len(path) < 3:\n                return path\n            for _ in range(max_attempts):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        def try_connect(node, other_tree, radius):\n            candidates = near(other_tree, node.position, radius)\n            best_node = None\n            best_cost_local = float('inf')\n            for cnode in candidates:\n                d = dist(node.position, cnode.position)\n                if d <= radius and not self._is_edge_in_obstacle(node.position, cnode.position, obstacles, is_3d):\n                    total_cost = node.cost + cnode.cost + d\n                    if total_cost < best_cost_local:\n                        best_cost_local = total_cost\n                        best_node = cnode\n            return best_node, best_cost_local\n\n        for it in range(self.max_iter):\n            current_time = time.monotonic()\n            if current_time - start_time > self.time_limit:\n                break\n\n            # Alternate expansion\n            if it % 2 == 0:\n                tree_a, tree_b = start_tree, goal_tree\n            else:\n                tree_a, tree_b = goal_tree, start_tree\n\n            sample = sample_free()\n            nearest_node = nearest(tree_a, sample)\n            new_pos = steer(nearest_node.position, sample, self.step_size)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            n_nodes = len(tree_a) + 1\n            radius = min(self.step_size * 4.5, gamma_rrt_star * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim)))\n\n            near_nodes = near(tree_a, new_pos, radius)\n\n            # Find best parent node (lowest cost)\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            min_parent = nearest_node\n            for near_node in near_nodes:\n                cost_through = near_node.cost + dist(near_node.position, new_pos)\n                if cost_through < min_cost:\n                    if not self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d):\n                        min_cost = cost_through\n                        min_parent = near_node\n\n            new_node = Node(new_pos, parent=min_parent, cost=min_cost)\n            min_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((min_parent, new_node))\n\n            # Rewire neighbors incrementally\n            for near_node in near_nodes:\n                if near_node is min_parent:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, near_node.position)\n                if new_cost < near_node.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                        if near_node.parent:\n                            try:\n                                edges.remove((near_node.parent, near_node))\n                            except ValueError:\n                                pass\n                            near_node.parent.remove_child(near_node)\n                        near_node.parent = new_node\n                        near_node.cost = new_cost\n                        new_node.add_child(near_node)\n                        edges.append((new_node, near_node))\n\n            # Attempt multi-candidate tree connection\n            connect_radius = self.step_size * 3.2\n            conn_node, conn_cost = try_connect(new_node, tree_b, connect_radius)\n            if conn_node is not None and conn_cost < best_cost:\n                best_cost = conn_cost\n                best_connection = (new_node, conn_node)\n                success = True\n                found_improvement = True\n                # Early stop on improvement\n                break\n\n            # Periodic path shortcutting to improve smoothness & length\n            if found_improvement and (it % 120 == 0) and best_connection is not None:\n                path = extract_path(best_connection[0], best_connection[1])\n                shortcut = shortcut_path(path)\n                shortcut_len = sum(dist(shortcut[i], shortcut[i + 1]) for i in range(len(shortcut) - 1))\n                if shortcut_len + 1e-5 < best_cost:\n                    best_cost = shortcut_len\n                    extracted_path = shortcut\n                else:\n                    extracted_path = path\n\n        # Final path extraction and shortcutting if success\n        if success and best_connection is not None:\n            path = extract_path(best_connection[0], best_connection[1])\n            extracted_path = shortcut_path(path)\n        else:\n            # Fallback: find best pair bridging trees if no direct connection found\n            best_pair = None\n            min_total_cost = float('inf')\n            for n1 in start_tree:\n                near_goal_candidates = near(goal_tree, n1.position, self.step_size * 3.2)\n                for n2 in near_goal_candidates:\n                    d12 = dist(n1.position, n2.position)\n                    if d12 <= self.step_size * 3.2 and not self._is_edge_in_obstacle(n1.position, n2.position, obstacles, is_3d):\n                        total_c = n1.cost + n2.cost + d12\n                        if total_c < min_total_cost:\n                            min_total_cost = total_c\n                            best_pair = (n1, n2)\n            if best_pair:\n                path = extract_path(best_pair[0], best_pair[1])\n                extracted_path = shortcut_path(path)\n                success = True\n            else:\n                extracted_path = []\n\n        return PlannerResult(\n            success=success,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -33.36919,
          "time_improvement": 57.0,
          "length_improvement": 15.0,
          "smoothness_improvement": 1442.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.014020967483520507,
                    "num_nodes_avg": 122.0,
                    "path_length_avg": 168.85621197856955,
                    "smoothness_avg": 0.04592179710711396,
                    "success_improvement": 0.0,
                    "time_improvement": 43.972927835189054,
                    "length_improvement": 7.44723451664146,
                    "smoothness_improvement": 618.7758455048379,
                    "objective_score": 20.754098288065784
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.039501094818115236,
                    "num_nodes_avg": 363.8,
                    "path_length_avg": 236.27330058206434,
                    "smoothness_avg": 0.10265783372398023,
                    "success_improvement": 0.0,
                    "time_improvement": 75.84241189195431,
                    "length_improvement": 21.125171515827486,
                    "smoothness_improvement": 2541.460003166907,
                    "objective_score": 48.13512649291732
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.02402009963989258,
                    "num_nodes_avg": 264.6,
                    "path_length_avg": 125.65554175248053,
                    "smoothness_avg": 0.09952911323688463,
                    "success_improvement": 0.0,
                    "time_improvement": 51.53657956993282,
                    "length_improvement": 16.545572241909497,
                    "smoothness_improvement": 1166.002973898222,
                    "objective_score": 31.21833208561665
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e2",
          "algorithm_description": "A hybrid bidirectional RRT*-inspired planner that utilizes adaptive neighborhood radius rewiring, goal bias sampling, multi-candidate connection attempts, and incremental cost-based rewiring for improving planning efficiency, path length, and smoothness. The planner alternates tree expansions from start and goal, applies spatial pruning by dynamically shrinking the radius based on tree cardinality and dimension to focus rewiring on relevant neighbors, uses early stopping upon improved connection, and performs lightweight path shortcutting for smoothing while maintaining collision safety.",
          "planning_mechanism": "The planner maintains two trees growing bidirectionally, samples with a goal bias to efficiently explore near the goal, steers nearest nodes toward samples with a fixed step size, and rewires neighbors dynamically by considering cost improvements confined to an adaptively shrinking radius to optimize path quality and minimize overhead. Each iteration tries multiple candidate nodes to connect the two trees, favoring lower-cost connections and terminating early when a high-quality path is found or time limit exceeded. The final path undergoes fast shortcutting to reduce unnecessary waypoints while preserving collision-freeness and smoothness.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0, goal_sample_rate: float=0.15):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.time_limit = 30.0\n\n    def plan(self, map):\n        import time\n        import math\n        import random\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n        gamma_rrt_star = 50.0  # Controls neighborhood radius scaling for rewiring\n\n        start_tree = [Node(start_pos, cost=0.0)]\n        goal_tree = [Node(goal_pos, cost=0.0)]\n        nodes = start_tree[:] + goal_tree[:]\n        edges = []\n\n        best_connection = None\n        best_cost = float('inf')\n        success = False\n\n        # Precompute squared step size for efficiency\n        step_size = self.step_size\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def sample_free():\n            # Goal biasing: sample goal with probability goal_sample_rate\n            if random.random() < self.goal_sample_rate:\n                return goal_pos\n            for _ in range(100):\n                p = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n            # Fallback in rare case no free sample found\n            return goal_pos\n\n        def nearest(tree, point):\n            # Linear nearest (can be improved with spatial DS, not requested)\n            best_node = None\n            best_dist = float('inf')\n            for node in tree:\n                d = dist(node.position, point)\n                if d < best_dist:\n                    best_node = node\n                    best_dist = d\n            return best_node\n\n        def near(tree, point, radius):\n            neighbors = []\n            for node in tree:\n                d = dist(node.position, point)\n                if d <= radius:\n                    neighbors.append((d, node))\n            neighbors.sort(key=lambda x: x[0])\n            return [nd[1] for nd in neighbors]\n\n        def steer(from_p, to_p, max_step):\n            d = dist(from_p, to_p)\n            if d <= max_step:\n                return to_p\n            ratio = max_step / d\n            return tuple(from_p[i] + (to_p[i] - from_p[i]) * ratio for i in range(dim))\n\n        def extract_path(node_from_start, node_from_goal):\n            path_start = []\n            cur = node_from_start\n            while cur:\n                path_start.append(cur.position)\n                cur = cur.parent\n            path_goal = []\n            cur = node_from_goal\n            while cur:\n                path_goal.append(cur.position)\n                cur = cur.parent\n            return path_start[::-1] + path_goal\n\n        def shortcut_path(path):\n            # Lightweight shortcutting: tries up to 100 random shortcuts to smooth path while collision-free\n            max_attempts = 100\n            if len(path) < 3:\n                return path\n            for _ in range(max_attempts):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d):\n                    # Remove intermediate nodes between i and j\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        def try_connect(node, other_tree):\n            # Try multiple connection candidates from other_tree within radius around node.position\n            radius = step_size * 2.0\n            candidates = near(other_tree, node.position, radius)\n            best_node = None\n            best_cost_local = float('inf')\n            for cnode in candidates:\n                d = dist(node.position, cnode.position)\n                if d <= radius and not self._is_edge_in_obstacle(node.position, cnode.position, obstacles, is_3d):\n                    total_cost = node.cost + cnode.cost + d\n                    if total_cost < best_cost_local:\n                        best_cost_local = total_cost\n                        best_node = cnode\n            return best_node, best_cost_local\n\n        start_time = time.monotonic()\n\n        for it in range(self.max_iter):\n            if time.monotonic() - start_time > self.time_limit:\n                break\n\n            # Alternate expansion between start and goal trees\n            tree_a = start_tree if it % 2 == 0 else goal_tree\n            tree_b = goal_tree if it % 2 == 0 else start_tree\n\n            sample = sample_free()\n            nearest_node = nearest(tree_a, sample)\n            new_pos = steer(nearest_node.position, sample, step_size)\n\n            # Node collision check\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n\n            # Edge collision check\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            # Adaptive rewiring radius\n            n_nodes = len(tree_a) + 1\n            radius = min(step_size * 5, gamma_rrt_star * (math.log(n_nodes) / n_nodes) ** (1 / dim))\n\n            near_nodes = near(tree_a, new_pos, radius)\n\n            # Choose best parent minimizing cost + dist\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            min_parent = nearest_node\n            for near_node in near_nodes:\n                # Check cost through near_node and collision with near_node->new_pos\n                cost_through = near_node.cost + dist(near_node.position, new_pos)\n                if cost_through < min_cost:\n                    if not self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d):\n                        min_cost = cost_through\n                        min_parent = near_node\n\n            new_node = Node(new_pos, parent=min_parent, cost=min_cost)\n            min_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((min_parent, new_node))\n\n            # Rewire neighbors to new_node if cost improves and edge is collision-free\n            for near_node in near_nodes:\n                if near_node == min_parent:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, near_node.position)\n                if new_cost < near_node.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                        # Remove old edge\n                        if near_node.parent:\n                            try:\n                                edges.remove((near_node.parent, near_node))\n                            except ValueError:\n                                pass\n                            near_node.parent.remove_child(near_node)\n                        # Update parent and cost\n                        near_node.parent = new_node\n                        near_node.cost = new_cost\n                        new_node.add_child(near_node)\n                        edges.append((new_node, near_node))\n\n            # Attempt to connect newly added node to other tree candidates\n            conn_node, conn_cost = try_connect(new_node, tree_b)\n            if conn_node and conn_cost < best_cost:\n                best_cost = conn_cost\n                best_connection = (new_node, conn_node)\n                success = True\n                # Early stopping on improved path\n                break\n\n        extracted_path = []\n        if success and best_connection:\n            extracted_path = extract_path(best_connection[0], best_connection[1])\n            extracted_path = shortcut_path(extracted_path)\n        else:\n            # Attempt to find best partial connection on timeout or failure\n            min_cost = float('inf')\n            best_pair = None\n            for n1 in start_tree:\n                candidates = near(goal_tree, n1.position, step_size * 2.0)\n                for n2 in candidates:\n                    dist12 = dist(n1.position, n2.position)\n                    if dist12 <= step_size * 2.0:\n                        if not self._is_edge_in_obstacle(n1.position, n2.position, obstacles, is_3d):\n                            total_cost = n1.cost + n2.cost + dist12\n                            if total_cost < min_cost:\n                                min_cost = total_cost\n                                best_pair = (n1, n2)\n            if best_pair:\n                extracted_path = extract_path(best_pair[0], best_pair[1])\n                extracted_path = shortcut_path(extracted_path)\n                success = True\n\n        return PlannerResult(\n            success=success,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(\n                from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps)\n                for d in range(len(from_pos))\n            )\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -33.09257,
          "time_improvement": 56.0,
          "length_improvement": 16.0,
          "smoothness_improvement": 1398.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.01958200931549072,
                    "num_nodes_avg": 140.8,
                    "path_length_avg": 166.35481911674003,
                    "smoothness_avg": 0.044027487308021036,
                    "success_improvement": 0.0,
                    "time_improvement": 21.75128782371844,
                    "length_improvement": 8.818287581316609,
                    "smoothness_improvement": 589.1257835894651,
                    "objective_score": 14.761987813852823
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.026345157623291017,
                    "num_nodes_avg": 303.5,
                    "path_length_avg": 235.08654885206815,
                    "smoothness_avg": 0.08998220763376255,
                    "success_improvement": 0.0,
                    "time_improvement": 83.88815627932586,
                    "length_improvement": 21.521343402054775,
                    "smoothness_improvement": 2215.3070139811657,
                    "objective_score": 49.15578799493645
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.0191939115524292,
                    "num_nodes_avg": 244.3,
                    "path_length_avg": 125.39778779809066,
                    "smoothness_avg": 0.11710275866810149,
                    "success_improvement": 0.0,
                    "time_improvement": 61.27399056588344,
                    "length_improvement": 16.71676014549089,
                    "smoothness_improvement": 1389.538446631726,
                    "objective_score": 35.359945490218195
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "A simplified bidirectional RRT* planner leveraging goal bias sampling, adaptive neighborhood rewiring, incremental path shortcutting, and efficient collision checking. It balances exploration and exploitation by alternating tree expansions from start and goal, connecting nodes with cost-aware rewiring in a shrinking neighborhood radius, and progressively refines the path during planning while enforcing a strict 30-second limit. Early path connections accelerate termination and incremental shortcutting improves path length and smoothness with low overhead.",
          "planning_mechanism": "The planner grows two trees from start and goal alternately using goal biased sampling. New samples are connected to the best parent in an adaptive neighborhood radius shrinking as trees grow. Rewiring locally improves subtree costs. After each iteration, the planner attempts connections between trees and applies shortcutting periodically to smooth the path. The search stops upon a valid path found or time limit reached, returning the best path. All nodes and edges maintain collision-free guarantees.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.time_limit = 30.0\n        self.goal_sample_rate = 0.15\n\n    def plan(self, map) -> 'PlannerResult':\n        import time\n        import random\n        import math\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def in_obstacle(pos):\n            for o in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = o\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w_, h_ = o\n                    px, py = pos\n                    if x <= px <= x + w_ and y <= py <= y + h_:\n                        return True\n            return False\n\n        def edge_in_obstacle(a, b, resolution=0.5):\n            distance = dist(a, b)\n            steps = max(1, int(distance / resolution))\n            for i in range(steps + 1):\n                interp = tuple(a[d] + (b[d] - a[d]) * (i / steps) for d in range(dim))\n                if in_obstacle(interp):\n                    return True\n            return False\n\n        def steer(from_p, to_p, max_step):\n            d = dist(from_p, to_p)\n            if d <= max_step:\n                return to_p\n            ratio = max_step / d\n            return tuple(from_p[i] + ratio * (to_p[i] - from_p[i]) for i in range(dim))\n\n        def sample_free():\n            if random.random() < self.goal_sample_rate:\n                if not in_obstacle(goal_pos):\n                    return goal_pos\n            for _ in range(30):\n                p = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not in_obstacle(p):\n                    return p\n            return goal_pos\n\n        def nearest(tree, point):\n            best_node = None\n            best_dist = float('inf')\n            for node in tree:\n                d = dist(node.position, point)\n                if d < best_dist:\n                    best_dist = d\n                    best_node = node\n            return best_node\n\n        def near(tree, point, radius):\n            neighbors = []\n            r_sq = radius * radius\n            for node in tree:\n                d_sq = sum((node.position[i] - point[i])**2 for i in range(dim))\n                if d_sq <= r_sq:\n                    neighbors.append((math.sqrt(d_sq), node))\n            neighbors.sort(key=lambda x: x[0])\n            return [n[1] for n in neighbors]\n\n        def extract_path(node_start, node_goal):\n            path_start = []\n            cur = node_start\n            while cur is not None:\n                path_start.append(cur.position)\n                cur = cur.parent\n            path_start.reverse()\n            path_goal = []\n            cur = node_goal\n            while cur is not None:\n                path_goal.append(cur.position)\n                cur = cur.parent\n            if path_start and path_goal and path_start[-1] == path_goal[0]:\n                path_goal = path_goal[1:]\n            return path_start + path_goal\n\n        def shortcut_path(path, max_attempts=30):\n            if len(path) < 3:\n                return path\n            attempts = 0\n            while attempts < max_attempts and len(path) > 2:\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if not edge_in_obstacle(path[i], path[j], resolution=max(self.step_size * 0.2, 0.2)):\n                    path = path[:i+1] + path[j:]\n                attempts += 1\n            return path\n\n        def rewire(tree, new_node, neighbors):\n            for neighbor in neighbors:\n                if neighbor is new_node.parent:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, neighbor.position)\n                if new_cost + 1e-9 < neighbor.cost:\n                    if not edge_in_obstacle(new_node.position, neighbor.position, resolution=max(self.step_size * 0.2, 0.2)):\n                        if neighbor.parent:\n                            try:\n                                edges.remove((neighbor.parent, neighbor))\n                            except ValueError:\n                                pass\n                            neighbor.parent.remove_child(neighbor)\n                        neighbor.parent = new_node\n                        neighbor.cost = new_cost\n                        new_node.add_child(neighbor)\n                        edges.append((new_node, neighbor))\n\n        def try_connect(new_node, other_tree):\n            radius = self.step_size * 3.0\n            candidates = near(other_tree, new_node.position, radius)\n            best_node = None\n            best_cost = float('inf')\n            for node in candidates:\n                d = dist(new_node.position, node.position)\n                if d <= radius and not edge_in_obstacle(new_node.position, node.position, resolution=max(self.step_size * 0.2, 0.2)):\n                    total_cost = new_node.cost + d + node.cost\n                    if total_cost < best_cost:\n                        best_cost = total_cost\n                        best_node = node\n            return best_node, best_cost\n\n        start_tree = [Node(start_pos, cost=0.0)]\n        goal_tree = [Node(goal_pos, cost=0.0)]\n        nodes = start_tree[:] + goal_tree[:]\n        edges = []\n\n        best_connection = None\n        best_cost = float('inf')\n        success = False\n        extracted_path = []\n\n        start_time = time.monotonic()\n        shortcut_counter = 0\n        shortcut_interval = 50\n\n        for iteration in range(self.max_iter):\n            if time.monotonic() - start_time > self.time_limit:\n                break\n\n            tree_a = start_tree if iteration % 2 == 0 else goal_tree\n            tree_b = goal_tree if iteration % 2 == 0 else start_tree\n\n            sample = sample_free()\n            nearest_node = nearest(tree_a, sample)\n            new_pos = steer(nearest_node.position, sample, self.step_size)\n            if in_obstacle(new_pos):\n                continue\n            if edge_in_obstacle(nearest_node.position, new_pos, resolution=max(self.step_size * 0.2, 0.2)):\n                continue\n\n            n_nodes = len(tree_a) + 1\n            gamma = 30.0\n            radius = gamma * ((math.log(max(n_nodes,2)) / n_nodes) ** (1/dim))\n            radius = max(radius, self.step_size)\n\n            neighbors = near(tree_a, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            min_parent = nearest_node\n            for nb in neighbors:\n                cost_candidate = nb.cost + dist(nb.position, new_pos)\n                if cost_candidate + 1e-9 < min_cost:\n                    if not edge_in_obstacle(nb.position, new_pos, resolution=max(self.step_size * 0.2, 0.2)):\n                        min_cost = cost_candidate\n                        min_parent = nb\n\n            new_node = Node(new_pos, parent=min_parent, cost=min_cost)\n            min_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((min_parent, new_node))\n\n            rewire(tree_a, new_node, neighbors)\n\n            conn_node, conn_cost = try_connect(new_node, tree_b)\n            if conn_node and conn_cost + 1e-9 < best_cost:\n                best_cost = conn_cost\n                best_connection = (new_node, conn_node) if iteration % 2 == 0 else (conn_node, new_node)\n                success = True\n                # Early stop on improvement\n                break\n\n            shortcut_counter += 1\n            if shortcut_counter >= shortcut_interval and success:\n                path_cur = extract_path(best_connection[0], best_connection[1])\n                path_short = shortcut_path(path_cur, max_attempts=20)\n                if len(path_short) < len(path_cur):\n                    extracted_path = path_short\n                    shortcut_counter = 0\n\n        if success and best_connection:\n            if not extracted_path:\n                extracted_path = extract_path(best_connection[0], best_connection[1])\n            extracted_path = shortcut_path(extracted_path, max_attempts=50)\n        else:\n            best_partial_cost = float('inf')\n            best_pair = None\n            search_radius = self.step_size * 3.0\n            for node_s in start_tree:\n                candidates = near(goal_tree, node_s.position, search_radius)\n                for node_g in candidates:\n                    d = dist(node_s.position, node_g.position)\n                    if d <= search_radius and not edge_in_obstacle(node_s.position, node_g.position, resolution=max(self.step_size * 0.2, 0.2)):\n                        total_c = node_s.cost + node_g.cost + d\n                        if total_c + 1e-9 < best_partial_cost:\n                            best_partial_cost = total_c\n                            best_pair = (node_s, node_g)\n            if best_pair:\n                success = True\n                extracted_path = extract_path(best_pair[0], best_pair[1])\n                extracted_path = shortcut_path(extracted_path, max_attempts=50)\n            else:\n                extracted_path = []\n\n        return PlannerResult(\n            success=success,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -32.97933,
          "time_improvement": 57.0,
          "length_improvement": 15.0,
          "smoothness_improvement": 1398.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.01585543155670166,
                    "num_nodes_avg": 124.0,
                    "path_length_avg": 166.83473196275344,
                    "smoothness_avg": 0.03680283544081307,
                    "success_improvement": 0.0,
                    "time_improvement": 37.168018684489496,
                    "length_improvement": 8.555239745710967,
                    "smoothness_improvement": 476.0442932850264,
                    "objective_score": 18.663770919198562
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.03920238018035889,
                    "num_nodes_avg": 284.6,
                    "path_length_avg": 237.48604655145664,
                    "smoothness_avg": 0.09819100572051757,
                    "success_improvement": 0.0,
                    "time_improvement": 76.08745857068688,
                    "length_improvement": 20.720322004287073,
                    "smoothness_improvement": 2426.525301311647,
                    "objective_score": 47.39105728033654
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.021207523345947266,
                    "num_nodes_avg": 192.2,
                    "path_length_avg": 127.10856004421139,
                    "smoothness_avg": 0.10928590980034451,
                    "success_improvement": 0.0,
                    "time_improvement": 56.94767313825165,
                    "length_improvement": 15.580546677837685,
                    "smoothness_improvement": 1290.1087060136226,
                    "objective_score": 32.88317347824622
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "cross_over",
          "algorithm_description": "A bidirectional RRT* planner with adaptive dynamic radius, goal-bias enhanced sampling, multi-candidate tree connection evaluation, and incremental path shortcutting to minimize path length and planning time under a strict 30-second time limit. The algorithm grows two trees alternately from start and goal, steering towards samples with fixed step sizes while rewiring nearby nodes within a shrinking adaptive radius. Connections between trees are attempted with multiple candidates to find early lower-cost paths. Periodic incremental shortcutting refines path smoothness and length. The best path is returned immediately if found or upon timeout with up-to-date best solution.",
          "planning_mechanism": "The planner alternates expansions between start and goal trees using goal-biased random samples. It steers nearest nodes towards samples and locally rewires neighbors based on cost and collision checks within an adaptive radius that shrinks with tree size. Multiple candidate connections between the two trees are evaluated each iteration to select the best connection for early stopping. Incremental shortcutting is performed periodically on the best path to improve smoothness and reduce unnecessary detours. Collision detection is enforced for both nodes and edges with adaptive resolution. Planning halts after 30 seconds or max iterations returning the best path found.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position  # Tuple of floats (2D or 3D)\n        self.parent = parent      # Parent Node or None\n        self.cost = cost          # Cost-to-come from root\n        self.children = []\n        self.valid = True         # For collision checks etc.\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\nclass Planner:\n    def __init__(self, max_iter: int = 6000, step_size: float = 4.5, goal_sample_rate: float = 0.20):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.time_limit = 30.0  # Hard time limit in seconds\n\n    def plan(self, map):\n        import time\n        import math\n        import random\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = dim == 3\n\n        gamma_rrt_star = 30.0  # Coefficient for adaptive radius\n\n        start_tree = [Node(start_pos, cost=0.0)]\n        goal_tree = [Node(goal_pos, cost=0.0)]\n        nodes = start_tree[:] + goal_tree[:]\n        edges = []\n\n        best_connection = None\n        best_cost = float('inf')\n        success = False\n\n        start_time = time.monotonic()\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def sample_free():\n            # Goal bias sampling with retry capped\n            if random.random() < self.goal_sample_rate:\n                return goal_pos\n            for _ in range(30):\n                sample = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not self._is_in_obstacle(sample, obstacles, is_3d):\n                    return sample\n            return goal_pos  # fallback if no free found\n\n        def nearest(tree, point):\n            best_node = None\n            best_dist = float('inf')\n            for node in tree:\n                d = dist(node.position, point)\n                if d < best_dist:\n                    best_node = node\n                    best_dist = d\n            return best_node\n\n        def near(tree, point, radius):\n            radius_sq = radius * radius\n            neighbors = []\n            for node in tree:\n                sqdist = 0.0\n                for i in range(dim):\n                    diff = node.position[i] - point[i]\n                    sqdist += diff * diff\n                    if sqdist > radius_sq:\n                        break\n                if sqdist <= radius_sq:\n                    neighbors.append((sqdist, node))\n            neighbors.sort(key=lambda x: x[0])\n            return [nd[1] for nd in neighbors]\n\n        def steer(from_p, to_p, max_step):\n            d = dist(from_p, to_p)\n            if d <= max_step:\n                return to_p\n            ratio = max_step / d\n            return tuple(from_p[i] + (to_p[i] - from_p[i]) * ratio for i in range(dim))\n\n        def extract_path(node_start, node_goal):\n            path_start = []\n            cur = node_start\n            while cur is not None:\n                path_start.append(cur.position)\n                cur = cur.parent\n            path_goal = []\n            cur = node_goal\n            while cur is not None:\n                path_goal.append(cur.position)\n                cur = cur.parent\n            return path_start[::-1] + path_goal\n\n        def shortcut_path(path):\n            max_attempts = 80\n            if len(path) < 3:\n                return path\n            for _ in range(max_attempts):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        def try_connect(node, other_tree, radius):\n            candidates = near(other_tree, node.position, radius)\n            best_node = None\n            best_cost_local = float('inf')\n            for cnode in candidates:\n                d = dist(node.position, cnode.position)\n                if d <= radius and not self._is_edge_in_obstacle(node.position, cnode.position, obstacles, is_3d):\n                    total_cost = node.cost + cnode.cost + d\n                    if total_cost < best_cost_local:\n                        best_cost_local = total_cost\n                        best_node = cnode\n            return best_node, best_cost_local\n\n        extracted_path = []\n        found_improvement = False\n\n        for it in range(self.max_iter):\n            current_time = time.monotonic()\n            if current_time - start_time > self.time_limit:\n                break\n\n            # Alternate expansions between start and goal trees\n            if it % 2 == 0:\n                tree_a, tree_b = start_tree, goal_tree\n            else:\n                tree_a, tree_b = goal_tree, start_tree\n\n            sample = sample_free()\n            nearest_node = nearest(tree_a, sample)\n            new_pos = steer(nearest_node.position, sample, self.step_size)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            n_nodes = len(tree_a) + 1\n            radius = min(self.step_size * 4.5, gamma_rrt_star * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim)))\n\n            near_nodes = near(tree_a, new_pos, radius)\n\n            # Identify best parent with lowest cost + collision-free edge\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            min_parent = nearest_node\n            for near_node in near_nodes:\n                cost_through = near_node.cost + dist(near_node.position, new_pos)\n                if cost_through < min_cost and not self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d):\n                    min_cost = cost_through\n                    min_parent = near_node\n\n            new_node = Node(new_pos, parent=min_parent, cost=min_cost)\n            min_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((min_parent, new_node))\n\n            # Rewire nearby nodes if cheaper via new_node without collisions\n            for near_node in near_nodes:\n                if near_node is min_parent:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, near_node.position)\n                if new_cost < near_node.cost and not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                    if near_node.parent:\n                        try:\n                            edges.remove((near_node.parent, near_node))\n                        except ValueError:\n                            pass\n                        near_node.parent.remove_child(near_node)\n                    near_node.parent = new_node\n                    near_node.cost = new_cost\n                    new_node.add_child(near_node)\n                    edges.append((new_node, near_node))\n\n            # Attempt multiple candidate connections to other tree for best cost\n            connect_radius = self.step_size * 3.2\n            conn_node, conn_cost = try_connect(new_node, tree_b, connect_radius)\n            if conn_node is not None and conn_cost < best_cost:\n                best_cost = conn_cost\n                best_connection = (new_node, conn_node)\n                success = True\n                found_improvement = True\n                # Early termination on improvement\n                break\n\n            # Periodic incremental shortcutting to improve path quality\n            if found_improvement and (it % 120 == 0) and best_connection is not None:\n                path = extract_path(best_connection[0], best_connection[1])\n                shortcut = shortcut_path(path)\n                shortcut_len = sum(dist(shortcut[i], shortcut[i + 1]) for i in range(len(shortcut) - 1))\n                if shortcut_len + 1e-5 < best_cost:\n                    best_cost = shortcut_len\n                    extracted_path = shortcut\n                else:\n                    extracted_path = path\n\n        # Finalize path extraction or fallback if no direct connection found\n        if success and best_connection is not None:\n            path = extract_path(best_connection[0], best_connection[1])\n            extracted_path = shortcut_path(path)\n        else:\n            # Attempt best partial connection between trees within connect radius\n            best_pair = None\n            min_total_cost = float('inf')\n            for n1 in start_tree:\n                near_goal_candidates = near(goal_tree, n1.position, self.step_size * 3.2)\n                for n2 in near_goal_candidates:\n                    d12 = dist(n1.position, n2.position)\n                    if d12 <= self.step_size * 3.2 and not self._is_edge_in_obstacle(n1.position, n2.position, obstacles, is_3d):\n                        total_c = n1.cost + n2.cost + d12\n                        if total_c < min_total_cost:\n                            min_total_cost = total_c\n                            best_pair = (n1, n2)\n            if best_pair:\n                path = extract_path(best_pair[0], best_pair[1])\n                extracted_path = shortcut_path(path)\n                success = True\n            else:\n                extracted_path = []\n\n        return PlannerResult(\n            success=success,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -32.14549,
          "time_improvement": 55.0,
          "length_improvement": 15.0,
          "smoothness_improvement": 1352.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.01823000907897949,
                    "num_nodes_avg": 159.3,
                    "path_length_avg": 166.68606489804506,
                    "smoothness_avg": 0.03600692626925854,
                    "success_improvement": 0.0,
                    "time_improvement": 27.758031325997862,
                    "length_improvement": 8.636726519658023,
                    "smoothness_improvement": 463.58658640576886,
                    "objective_score": 15.827378241623018
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.032488322257995604,
                    "num_nodes_avg": 326.8,
                    "path_length_avg": 235.21169916755744,
                    "smoothness_avg": 0.08933891125866616,
                    "success_improvement": 0.0,
                    "time_improvement": 80.18287796840391,
                    "length_improvement": 21.47956462449235,
                    "smoothness_improvement": 2198.7545349022857,
                    "objective_score": 47.93637483972802
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.02102477550506592,
                    "num_nodes_avg": 251.2,
                    "path_length_avg": 129.2318232365425,
                    "smoothness_avg": 0.11753050832113565,
                    "success_improvement": 0.0,
                    "time_improvement": 57.31866034173415,
                    "length_improvement": 14.170376364419635,
                    "smoothness_improvement": 1394.9793906451255,
                    "objective_score": 32.672720874397655
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "A simplified bidirectional RRT* planner that grows two trees alternately from start and goal positions by sampling free space with goal bias, steering towards samples by fixed step size, and rewiring neighbors within an adaptively shrinking radius to improve path cost progressively. The planner attempts to connect both trees repeatedly and performs periodic path shortcutting to smooth the path, all under a strict 30-second time limit to ensure efficiency. Collision checks for nodes and edges enforce safety, and early stopping occurs once a valid path is found.",
          "planning_mechanism": "The algorithm alternates between expanding start and goal trees, sampling with goal bias to expedite connection, steering nearest nodes towards samples, rewiring neighbors within a calculated radius based on node count to optimize path cost, attempting to connect the two trees via multiple candidates, and performing iterative shortcutting to smooth and shorten the path before termination either when time limit or a valid solution is found.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.time_limit = 30.0\n        self.goal_sample_rate = 0.15  # Probability to sample goal to bias search\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n        import time\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        start_tree = [Node(start_pos, cost=0.0)]\n        goal_tree = [Node(goal_pos, cost=0.0)]\n        nodes = start_tree[:] + goal_tree[:]\n        edges = []\n\n        gamma_rrt_star = 30.0  # Tuned constant for neighborhood radius\n        best_connection = None\n        best_cost = float('inf')\n        success = False\n\n        start_time = time.monotonic()\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def sample_free():\n            if random.random() < self.goal_sample_rate:\n                return goal_pos\n            for _ in range(30):\n                p = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n            return goal_pos  # Fallback if no free sample found in limited retries\n\n        def nearest(tree, point):\n            best_node = None\n            best_d = float('inf')\n            for node in tree:\n                d = dist(node.position, point)\n                if d < best_d:\n                    best_d = d\n                    best_node = node\n            return best_node\n\n        def near(tree, point, radius):\n            neighbors = []\n            r2 = radius * radius\n            for node in tree:\n                d = 0.0\n                for i in range(dim):\n                    diff = node.position[i] - point[i]\n                    d += diff*diff\n                    if d > r2:\n                        break\n                if d <= r2:\n                    neighbors.append(node)\n            return neighbors\n\n        def steer(from_p, to_p, max_step):\n            d = dist(from_p, to_p)\n            if d <= max_step:\n                return to_p\n            ratio = max_step / d\n            return tuple(from_p[i] + (to_p[i] - from_p[i]) * ratio for i in range(dim))\n\n        def extract_path(n_start, n_goal):\n            path_start = []\n            cur = n_start\n            while cur is not None:\n                path_start.append(cur.position)\n                cur = cur.parent\n            path_start.reverse()\n            path_goal = []\n            cur = n_goal\n            while cur is not None:\n                path_goal.append(cur.position)\n                cur = cur.parent\n            if path_start and path_goal and path_start[-1] == path_goal[0]:\n                path_goal = path_goal[1:]\n            return path_start + path_goal\n\n        def shortcut_path(path, max_attempts=50):\n            if len(path) < 3:\n                return path\n            for _ in range(max_attempts):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1 = path[i]\n                p2 = path[j]\n                if not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, \n                                               resolution=max(self.step_size * 0.2, 0.2)):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        def rewire(tree, new_node, neighbors):\n            for neighbor in neighbors:\n                if neighbor is new_node.parent:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, neighbor.position)\n                if new_cost + 1e-9 < neighbor.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d, \n                                                    resolution=max(self.step_size * 0.2, 0.2)):\n                        if neighbor.parent:\n                            try:\n                                edges.remove((neighbor.parent, neighbor))\n                            except Exception:\n                                pass\n                            neighbor.parent.remove_child(neighbor)\n                        neighbor.parent = new_node\n                        neighbor.cost = new_cost\n                        new_node.add_child(neighbor)\n                        edges.append((new_node, neighbor))\n\n        def attempt_connection(new_node, other_tree):\n            radius = self.step_size * 2.5\n            candidates = near(other_tree, new_node.position, radius)\n            best_cand = None\n            best_cand_cost = float('inf')\n            for node in candidates:\n                dist_between = dist(new_node.position, node.position)\n                if dist_between <= radius:\n                    if not self._is_edge_in_obstacle(new_node.position, node.position, obstacles, is_3d,\n                                                    resolution=max(self.step_size * 0.2, 0.2)):\n                        total_cost = new_node.cost + dist_between + node.cost\n                        if total_cost + 1e-9 < best_cand_cost:\n                            best_cand_cost = total_cost\n                            best_cand = node\n            return best_cand, best_cand_cost\n\n        iter_since_last_shortcut = 0\n        shortcut_interval = 75\n\n        for it in range(self.max_iter):\n            if time.monotonic() - start_time > self.time_limit:\n                break\n\n            tree_a = start_tree if it % 2 == 0 else goal_tree\n            tree_b = goal_tree if it % 2 == 0 else start_tree\n\n            sample = sample_free()\n            nearest_node = nearest(tree_a, sample)\n            new_pos = steer(nearest_node.position, sample, self.step_size)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d,\n                                        resolution=max(self.step_size * 0.2, 0.2)):\n                continue\n\n            n_nodes = max(len(tree_a) + 1, 2)\n            radius = min(self.step_size * 5, gamma_rrt_star * ((math.log(n_nodes) / n_nodes) ** (1 / dim)))\n\n            neighbors = near(tree_a, new_pos, radius)\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            min_parent = nearest_node\n\n            for nb in neighbors:\n                cand_cost = nb.cost + dist(nb.position, new_pos)\n                if cand_cost + 1e-9 < min_cost:\n                    if not self._is_edge_in_obstacle(nb.position, new_pos, obstacles, is_3d,\n                                                    resolution=max(self.step_size * 0.2, 0.2)):\n                        min_cost = cand_cost\n                        min_parent = nb\n\n            new_node = Node(new_pos, parent=min_parent, cost=min_cost)\n            min_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((min_parent, new_node))\n\n            rewire(tree_a, new_node, neighbors)\n\n            conn_node, conn_cost = attempt_connection(new_node, tree_b)\n            if conn_node is not None and conn_cost + 1e-9 < best_cost:\n                best_cost = conn_cost\n                best_connection = (new_node, conn_node) if it % 2 == 0 else (conn_node, new_node)\n                success = True\n                break  # Early stop on improved solution\n\n            iter_since_last_shortcut += 1\n            if iter_since_last_shortcut >= shortcut_interval and success:\n                cur_path = extract_path(best_connection[0], best_connection[1])\n                short_path = shortcut_path(cur_path, max_attempts=25)\n                if len(short_path) < len(cur_path):\n                    iter_since_last_shortcut = 0\n\n        extracted_path = []\n        if success and best_connection is not None:\n            extracted_path = extract_path(best_connection[0], best_connection[1])\n            extracted_path = shortcut_path(extracted_path, max_attempts=75)\n        else:\n            # Attempt fallback to best partial connection\n            best_partial_cost = float('inf')\n            best_pair = None\n            search_radius = self.step_size * 3.0\n            for n1 in start_tree:\n                candidates = near(goal_tree, n1.position, search_radius)\n                for n2 in candidates:\n                    dist_12 = dist(n1.position, n2.position)\n                    if dist_12 <= search_radius:\n                        if not self._is_edge_in_obstacle(n1.position, n2.position, obstacles, is_3d,\n                                                        resolution=max(self.step_size * 0.2, 0.2)):\n                            total_cost = n1.cost + n2.cost + dist_12\n                            if total_cost + 1e-9 < best_partial_cost:\n                                best_partial_cost = total_cost\n                                best_pair = (n1, n2)\n            if best_pair:\n                success = True\n                extracted_path = extract_path(best_pair[0], best_pair[1])\n                extracted_path = shortcut_path(extracted_path, max_attempts=75)\n\n        return PlannerResult(\n            success=success,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -31.39487,
          "time_improvement": 50.0,
          "length_improvement": 16.0,
          "smoothness_improvement": 1325.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.011085057258605957,
                    "num_nodes_avg": 100.8,
                    "path_length_avg": 165.54946406884443,
                    "smoothness_avg": 0.03798296007342679,
                    "success_improvement": 0.0,
                    "time_improvement": 56.07208116264085,
                    "length_improvement": 9.259715444735578,
                    "smoothness_improvement": 494.5158064670879,
                    "objective_score": 24.85003264796904
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.03302719593048096,
                    "num_nodes_avg": 334.1,
                    "path_length_avg": 232.4980564980827,
                    "smoothness_avg": 0.08999984717844736,
                    "success_improvement": 0.0,
                    "time_improvement": 79.85417754360348,
                    "length_improvement": 22.385456655436457,
                    "smoothness_improvement": 2215.7608921711562,
                    "objective_score": 48.4663317171987
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.04247584342956543,
                    "num_nodes_avg": 369.5,
                    "path_length_avg": 124.42236173924557,
                    "smoothness_avg": 0.10720066533601189,
                    "success_improvement": 0.0,
                    "time_improvement": 13.771925876127536,
                    "length_improvement": 17.364591688978223,
                    "smoothness_improvement": 1263.5845503440473,
                    "objective_score": 20.86825552794543
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "time_expert",
          "algorithm_description": "A bidirectional RRT* planner with goal bias sampling, adaptive rewiring radius based on tree size, and dynamic step size for faster exploration. It alternates expanding from start and goal trees using efficient nearest neighbor lookups with radius proportional to tree growth, performs cost-based rewiring, incrementally tries connecting the two trees, and applies shortcutting smoothing on the final path to improve smoothness and reduce length. Early stopping is enforced with a hard 30-second timeout to reduce planning time while maintaining path quality and robustness.",
          "planning_mechanism": "A 2D/3D bidirectional RRT* planning method that grows two trees toward random samples biased towards the goal. Each extension selects the best parent from neighbors and rewires nearby nodes within an adaptively shrinking neighborhood radius. After each extension, it attempts to connect the two trees directly. If a better path connection is found, it updates the best known path. It also shortcuts the resulting path for smoothness improvement before returning the best path found within the time limit.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = 0.2  # 20% goal bias\n        self.max_shortcuts = 100     # Number of shortcut attempts after planning\n        self.connection_radius_factor = 30.0  # gamma coefficient\n        self.connection_radius_multiplier = 5.0\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        nodes_start = [Node(start_pos)]\n        nodes_goal = [Node(goal_pos)]\n        edges = []\n        all_nodes = nodes_start + nodes_goal\n\n        success = False\n        best_cost = float('inf')\n        best_connection = None\n\n        start_time = time.monotonic()\n        TIME_LIMIT = 30.0\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def sample_free():\n            for _ in range(30):\n                if random.random() < self.goal_sample_rate:\n                    p = goal_pos\n                else:\n                    p = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n            return start_pos\n\n        def nearest(tree, point):\n            # Linear search for nearest node\n            best_node = None\n            best_dist = float('inf')\n            px2 = point[0]**2 if not is_3d else None  # Precalc for speed not critical\n            for n in tree:\n                d = dist(n.position, point)\n                if d < best_dist:\n                    best_dist = d\n                    best_node = n\n            return best_node\n\n        def near(tree, point, radius):\n            r_sq = radius * radius\n            if not is_3d:\n                return [n for n in tree if (n.position[0]-point[0])**2 + (n.position[1]-point[1])**2 <= r_sq]\n            else:\n                return [n for n in tree if sum((n.position[i]-point[i])**2 for i in range(3)) <= r_sq]\n\n        def steer(from_p, to_p, step):\n            d = dist(from_p, to_p)\n            if d <= step:\n                return to_p\n            ratio = step / d\n            return tuple(from_p[i] + (to_p[i]-from_p[i]) * ratio for i in range(len(from_p)))\n\n        def extract_path(n_start, n_goal):\n            path_start = []\n            node = n_start\n            while node is not None:\n                path_start.append(node.position)\n                node = node.parent\n            path_goal = []\n            node = n_goal\n            while node is not None:\n                path_goal.append(node.position)\n                node = node.parent\n            return path_start[::-1] + path_goal\n\n        def try_rewire(new_node, near_nodes, tree):\n            changed = False\n            for near_node in near_nodes:\n                if near_node is new_node.parent:\n                    continue\n                dist_new_near = dist(new_node.position, near_node.position)\n                new_cost = new_node.cost + dist_new_near\n                if new_cost + 1e-9 < near_node.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                        # Rewire near_node\n                        if near_node.parent:\n                            if (near_node.parent, near_node) in edges:\n                                edges.remove((near_node.parent, near_node))\n                            near_node.parent.remove_child(near_node)\n                        near_node.parent = new_node\n                        near_node.cost = new_cost\n                        new_node.add_child(near_node)\n                        edges.append((new_node, near_node))\n                        changed = True\n            return changed\n\n        def add_node(tree, new_node):\n            tree.append(new_node)\n            all_nodes.append(new_node)\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.max_shortcuts):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i+2, len(path) - 1)\n                p_i = path[i]\n                p_j = path[j]\n                if not self._is_edge_in_obstacle(p_i, p_j, obstacles, is_3d):\n                    # Remove intermediate points between i and j\n                    path = path[:i+1] + path[j:]\n            return path\n\n        gamma = self.connection_radius_factor\n\n        for itr in range(self.max_iter):\n            now = time.monotonic()\n            if now - start_time > TIME_LIMIT:\n                break\n\n            # Alternate tree expansions\n            tree_a = nodes_start if itr % 2 == 0 else nodes_goal\n            tree_b = nodes_goal if itr % 2 == 0 else nodes_start\n\n            rnd = sample_free()\n            nearest_node = nearest(tree_a, rnd)\n            new_pos = steer(nearest_node.position, rnd, self.step_size)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            n_nodes = len(tree_a) + 1\n            radius = min(self.connection_radius_multiplier * self.step_size,\n                         gamma * (math.log(max(n_nodes, 2)) / n_nodes) ** (1/dim))\n            near_nodes = near(tree_a, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            min_parent = nearest_node\n            for near_node in near_nodes:\n                cost_thru = near_node.cost + dist(near_node.position, new_pos)\n                if cost_thru + 1e-9 < min_cost:\n                    if not self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d):\n                        min_cost = cost_thru\n                        min_parent = near_node\n\n            new_node = Node(new_pos, parent=min_parent, cost=min_cost)\n            min_parent.add_child(new_node)\n            add_node(tree_a, new_node)\n            edges.append((min_parent, new_node))\n\n            try_rewire(new_node, near_nodes, tree_a)\n\n            # Try connection to other tree\n            nearest_in_other = nearest(tree_b, new_node.position)\n            dist_conn = dist(new_node.position, nearest_in_other.position)\n            if dist_conn <= self.step_size * 1.2:\n                if not self._is_edge_in_obstacle(new_node.position, nearest_in_other.position, obstacles, is_3d):\n                    total_cost = new_node.cost + nearest_in_other.cost + dist_conn\n                    if total_cost + 1e-9 < best_cost:\n                        best_cost = total_cost\n                        best_connection = (new_node, nearest_in_other)\n                        success = True\n                        # Early stop on improved connection to save time\n                        break\n\n        if success and best_connection is not None:\n            path = extract_path(best_connection[0], best_connection[1])\n            path = shortcut_path(path)\n            return PlannerResult(success=True, path=path, nodes=all_nodes, edges=edges)\n        else:\n            # Try best possible connection at termination\n            min_est_cost = float('inf')\n            best_pair = None\n            for node_start in nodes_start:\n                near_goal = nearest(nodes_goal, node_start.position)\n                d = dist(node_start.position, near_goal.position)\n                if d <= self.step_size * 1.2:\n                    if not self._is_edge_in_obstacle(node_start.position, near_goal.position, obstacles, is_3d):\n                        est_cost = node_start.cost + near_goal.cost + d\n                        if est_cost + 1e-9 < min_est_cost:\n                            min_est_cost = est_cost\n                            best_pair = (node_start, near_goal)\n            if best_pair:\n                path = extract_path(best_pair[0], best_pair[1])\n                path = shortcut_path(path)\n                return PlannerResult(success=True, path=path, nodes=all_nodes, edges=edges)\n\n        return PlannerResult(success=False, path=[], nodes=all_nodes, edges=edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x,y,z,w,h,d = obs\n                px,py,pz = pos\n                if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                    return True\n            else:\n                x,y,w,h = obs\n                px,py = pos\n                if x <= px <= x+w and y <= py <= y+h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -29.68817,
          "time_improvement": 48.0,
          "length_improvement": 15.0,
          "smoothness_improvement": 1307.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.014809727668762207,
                    "num_nodes_avg": 135.4,
                    "path_length_avg": 170.66544462396834,
                    "smoothness_avg": 0.04089497366305359,
                    "success_improvement": 0.0,
                    "time_improvement": 41.31193913935704,
                    "length_improvement": 6.455565434572493,
                    "smoothness_improvement": 540.095142683469,
                    "objective_score": 18.96739671596795
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.036438727378845216,
                    "num_nodes_avg": 383.1,
                    "path_length_avg": 238.75090905172993,
                    "smoothness_avg": 0.08266881742076103,
                    "success_improvement": 0.0,
                    "time_improvement": 77.77322259339138,
                    "length_improvement": 20.29807449464742,
                    "smoothness_improvement": 2027.1282161785853,
                    "objective_score": 45.64645255569879
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.037070393562316895,
                    "num_nodes_avg": 368.9,
                    "path_length_avg": 124.82276282249741,
                    "smoothness_avg": 0.11427581459840219,
                    "success_improvement": 0.0,
                    "time_improvement": 24.74525787361654,
                    "length_improvement": 17.098664354533046,
                    "smoothness_improvement": 1353.579926728457,
                    "objective_score": 24.45067560844707
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e1",
          "algorithm_description": "An adaptive bidirectional RRT* planner with dynamic sampling density control, neighborhood radius scaling, focused rewiring, and path smoothing via lazy shortcutting. The planner alternately grows two trees from start and goal, applies cost-optimizing rewiring within an adaptively computed radius based on node count and problem dimension, and incrementally attempts multiple connection candidates between trees to improve solution quality. It employs goal bias, samples near promising regions, respects a 30-second hard time limit, performs thorough collision checks, and applies post-planning lazy shortcut smoothing to produce shorter, smoother paths efficiently.",
          "planning_mechanism": "A bidirectional RRT* variant that dynamically tunes neighbor radius by node density and dimension, incorporates incremental rewiring only among relevant neighbors, and aggressively connects multiple candidates between trees with continuous path improvements. The planner alternates tree expansions with goal bias sampling, performs strict collision checking on nodes and edges inside map bounds and obstacles, and halts either on timeout or upon finding sufficiently good solutions. Final path extraction is followed by a lazy shortcutting smoothing step that iteratively replaces sub-paths with collision-free direct edges, thus enhancing path smoothness and reducing overall length.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...], e.g. (x, y) or (x, y, z)\n        self.parent = parent            # Parent Node or None\n        self.cost = cost                # Path cost from root (start/goal)\n        self.children = []              # List of child Nodes\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.time_limit = 30.0\n        self.goal_sample_rate = 0.15  # Probability to sample goal point during sampling\n        self.gamma_rrt_star = 50.0    # Tuning constant for neighbor radius, can be adjusted\n\n    def plan(self, map):\n        import time\n        import math\n        import random\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        start_tree = [Node(start_pos, cost=0.0)]\n        goal_tree = [Node(goal_pos, cost=0.0)]\n        all_nodes = start_tree[:] + goal_tree[:]\n        edges = []\n\n        best_cost = float('inf')\n        best_connection = None\n        extracted_path = []\n        success = False\n\n        start_time = time.monotonic()\n\n        def in_obstacle(pos):\n            for o in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = o\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w_, h_ = o\n                    px, py = pos\n                    if x <= px <= x + w_ and y <= py <= y + h_:\n                        return True\n            return False\n\n        def edge_in_obstacle(p1, p2, resolution=None):\n            dist = math.dist(p1, p2)\n            step = resolution if resolution is not None else max(self.step_size * 0.2, 0.2)\n            steps = max(1, int(dist / step))\n            for i in range(steps + 1):\n                interp = tuple(p1[d] + (p2[d] - p1[d]) * (i / steps) for d in range(dim))\n                if in_obstacle(interp):\n                    return True\n            return False\n\n        def steer(from_p, to_p, max_step=None):\n            max_step = max_step if max_step is not None else self.step_size\n            dist = math.dist(from_p, to_p)\n            if dist <= max_step:\n                return to_p\n            r = max_step / dist\n            return tuple(from_p[i] + r * (to_p[i] - from_p[i]) for i in range(dim))\n\n        def sample_free():\n            if random.random() < self.goal_sample_rate:\n                return goal_pos\n            max_attempts = 100\n            for _ in range(max_attempts):\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not in_obstacle(sample):\n                    return sample\n            return goal_pos  # fallback if no free sample found\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def nearest(tree, point):\n            best_node = None\n            best_d = float('inf')\n            for n in tree:\n                d = dist(n.position, point)\n                if d < best_d:\n                    best_d = d\n                    best_node = n\n            return best_node\n\n        def near(tree, point, radius):\n            neighbors = []\n            for n in tree:\n                d = dist(n.position, point)\n                if d <= radius:\n                    neighbors.append((d, n))\n            neighbors.sort(key=lambda x: x[0])\n            return [n[1] for n in neighbors]\n\n        def extract_path(node_start, node_goal):\n            path_start = []\n            cur = node_start\n            while cur is not None:\n                path_start.append(cur.position)\n                cur = cur.parent\n            path_start.reverse()\n\n            path_goal = []\n            cur = node_goal\n            while cur is not None:\n                path_goal.append(cur.position)\n                cur = cur.parent\n\n            # Avoid duplicate connection node position at junction\n            if path_goal and path_start and path_start[-1] == path_goal[0]:\n                path_goal = path_goal[1:]\n            return path_start + path_goal\n\n        def rewire(tree, new_node, neighbors):\n            for neighbor in neighbors:\n                if neighbor is new_node.parent:\n                    continue\n                cost_through = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_through + 1e-9 < neighbor.cost:\n                    if not edge_in_obstacle(new_node.position, neighbor.position):\n                        # Remove old parent link\n                        if neighbor.parent:\n                            try:\n                                edges.remove((neighbor.parent, neighbor))\n                            except Exception:\n                                pass\n                            neighbor.parent.remove_child(neighbor)\n                        neighbor.parent = new_node\n                        neighbor.cost = cost_through\n                        new_node.add_child(neighbor)\n                        edges.append((new_node, neighbor))\n\n        def try_connect(new_node, other_tree):\n            radius = min(self.step_size * 3.0, self.gamma_rrt_star * ((math.log(len(other_tree)+1) / (len(other_tree)+1)) ** (1/dim)))\n            candidates = near(other_tree, new_node.position, radius)\n            best_node = None\n            best_cost_local = float('inf')\n            for node in candidates:\n                dist_connect = dist(new_node.position, node.position)\n                if dist_connect <= radius and not edge_in_obstacle(new_node.position, node.position):\n                    cost = new_node.cost + dist_connect + node.cost\n                    if cost < best_cost_local:\n                        best_cost_local = cost\n                        best_node = node\n            return best_node, best_cost_local\n\n        def lazy_shortcutting(path, max_attempts=100):\n            # Iteratively try random shortcuts to smooth path\n            if len(path) < 3:\n                return path\n            shortened = path[:]\n            for _ in range(max_attempts):\n                if len(shortened) < 3:\n                    break\n                i = random.randint(0, len(shortened) - 3)\n                j = random.randint(i + 2, len(shortened) - 1)\n                p1 = shortened[i]\n                p2 = shortened[j]\n                if not edge_in_obstacle(p1, p2):\n                    # Replace intermediate segment with direct edge\n                    shortened = shortened[:i + 1] + shortened[j:]\n            return shortened\n\n        # Main planning loop\n        for it in range(self.max_iter):\n            if time.monotonic() - start_time > self.time_limit:\n                break\n\n            tree_a, tree_b = (start_tree, goal_tree) if it % 2 == 0 else (goal_tree, start_tree)\n\n            sample = sample_free()\n            nearest_node = nearest(tree_a, sample)\n\n            new_pos = steer(nearest_node.position, sample, self.step_size)\n            if in_obstacle(new_pos):\n                continue\n            if edge_in_obstacle(nearest_node.position, new_pos):\n                continue\n\n            n_nodes = len(tree_a) + 1\n            radius = min(self.step_size * 5.0, self.gamma_rrt_star * ((math.log(n_nodes)/n_nodes) ** (1.0/dim)))\n            radius = max(radius, self.step_size)  # enforce minimum radius\n\n            neighbors = near(tree_a, new_pos, radius)\n\n            # Choose best parent among neighbors\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            min_parent = nearest_node\n            for nb in neighbors:\n                cost_candidate = nb.cost + dist(nb.position, new_pos)\n                if cost_candidate + 1e-9 < min_cost:\n                    if not edge_in_obstacle(nb.position, new_pos):\n                        min_cost = cost_candidate\n                        min_parent = nb\n\n            new_node = Node(new_pos, parent=min_parent, cost=min_cost)\n            min_parent.add_child(new_node)\n            tree_a.append(new_node)\n            all_nodes.append(new_node)\n            edges.append((min_parent, new_node))\n\n            # Rewire neighbors for better cost paths\n            rewire(tree_a, new_node, neighbors)\n\n            # Attempt multiple connections to opposite tree near new_node\n            conn_node, conn_cost = try_connect(new_node, tree_b)\n            if conn_node is not None and conn_cost + 1e-9 < best_cost:\n                best_cost = conn_cost\n                best_connection = (new_node, conn_node) if it % 2 == 0 else (conn_node, new_node)\n                success = True\n                # Early stop on improved connection\n                # But to stabilize path quality a few iterations can be done, here we stop immediately for efficiency\n                break\n\n        if success and best_connection is not None:\n            extracted_path = extract_path(best_connection[0], best_connection[1])\n            extracted_path = lazy_shortcutting(extracted_path, max_attempts=150)\n        else:\n            # Fallback: attempt best partial connection by proximity between trees\n            best_partial_cost = float('inf')\n            best_pair = None\n            search_radius = self.step_size * 3.0\n            for n1 in start_tree:\n                candidates = near(goal_tree, n1.position, search_radius)\n                for n2 in candidates:\n                    d12 = dist(n1.position, n2.position)\n                    if d12 <= search_radius and not edge_in_obstacle(n1.position, n2.position):\n                        total_cost = n1.cost + n2.cost + d12\n                        if total_cost + 1e-9 < best_partial_cost:\n                            best_partial_cost = total_cost\n                            best_pair = (n1, n2)\n            if best_pair:\n                success = True\n                extracted_path = extract_path(best_pair[0], best_pair[1])\n                extracted_path = lazy_shortcutting(extracted_path, max_attempts=150)\n\n        return PlannerResult(\n            success=success,\n            path=extracted_path,\n            nodes=all_nodes,\n            edges=edges\n        )",
          "objective": -28.69397,
          "time_improvement": 42.0,
          "length_improvement": 15.0,
          "smoothness_improvement": 1414.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.026157045364379884,
                    "num_nodes_avg": 168.6,
                    "path_length_avg": 172.36255527491443,
                    "smoothness_avg": 0.052837926790736456,
                    "success_improvement": 0.0,
                    "time_improvement": -3.6552666337874102,
                    "length_improvement": 5.525352194349752,
                    "smoothness_improvement": 727.0282936695193,
                    "objective_score": 5.853772794821225
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.025740861892700195,
                    "num_nodes_avg": 281.9,
                    "path_length_avg": 233.1831140282246,
                    "smoothness_avg": 0.08535792769243598,
                    "success_improvement": 0.0,
                    "time_improvement": 84.2986720805332,
                    "length_improvement": 22.15676473358739,
                    "smoothness_improvement": 2096.320960356621,
                    "objective_score": 49.065265266095494
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.026234531402587892,
                    "num_nodes_avg": 290.9,
                    "path_length_avg": 125.36456275683038,
                    "smoothness_avg": 0.11944698374914178,
                    "success_improvement": 0.0,
                    "time_improvement": 46.74259683298413,
                    "length_improvement": 16.73882663588952,
                    "smoothness_improvement": 1419.3568166298621,
                    "objective_score": 31.16285911457826
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "A simplified bidirectional RRT* planner with adaptive neighborhood radius, goal-biased sampling, and a single final shortcutting phase. It alternately grows start and goal trees by sampling free space with a fixed goal bias, extends nearest nodes toward samples by a fixed step size, rewires neighbors within an adaptive radius, and attempts to connect trees each iteration. It respects map bounds and avoids obstacles for nodes and edges. The algorithm stops when time limit is reached or upon finding a path, returning the best path found. A final shortcutting pass improves path quality.",
          "planning_mechanism": "The planner alternates expansions between two trees growing from start and goal. It samples points with a fixed goal bias, extends nearest tree nodes toward sampled points up to a fixed step size, and rewires nearby nodes within an adaptive radius based on tree size and dimension. In each iteration, it tries to connect the newly added node to the other tree within a connection radius and updates the best path if connected. The search halts if time expires or a solution is found. The final path is shortcut once for smoothing and length improvement.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        if parent:\n            parent.children.append(self)\n    def add_child(self, child):\n        self.children.append(child)\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=5.0, goal_sample_rate=0.15):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.time_limit = 30.0\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map):\n        import time\n        import math\n        import random\n\n        bounds = map.size\n        dim = len(bounds)\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = (dim == 3)\n\n        def dist_sq(a, b):\n            s = 0.0\n            for i in range(dim):\n                d = a[i] - b[i]\n                s += d * d\n            return s\n\n        def dist(a, b):\n            return math.sqrt(dist_sq(a,b))\n\n        def sample_free():\n            if random.random() < self.goal_sample_rate:\n                return goal_pos\n            for _ in range(30):\n                p = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n            # fallback rare case\n            return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n\n        def steer(from_p, to_p, max_step):\n            d = dist(from_p, to_p)\n            if d <= max_step:\n                return to_p\n            ratio = max_step / d\n            return tuple(from_p[i] + (to_p[i] - from_p[i]) * ratio for i in range(dim))\n\n        def nearest(tree, point):\n            best = None\n            best_d = float('inf')\n            for node in tree:\n                d = dist_sq(node.position, point)\n                if d < best_d:\n                    best = node\n                    best_d = d\n            return best\n\n        def near(tree, point, radius):\n            r_sq = radius * radius\n            result = []\n            for node in tree:\n                if dist_sq(node.position, point) <= r_sq:\n                    result.append(node)\n            return result\n\n        def extract_path(node_from_start, node_from_goal):\n            path_start = []\n            cur = node_from_start\n            while cur:\n                path_start.append(cur.position)\n                cur = cur.parent\n            path_start.reverse()\n            path_goal = []\n            cur = node_from_goal\n            while cur:\n                path_goal.append(cur.position)\n                cur = cur.parent\n            if path_start[-1] == path_goal[0]:\n                path_goal = path_goal[1:]\n            return path_start + path_goal\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            attempts = 0\n            max_attempts = 100\n            res = max(self.step_size / 5.0, 0.2)\n            while attempts < max_attempts and len(path) >= 3:\n                i = random.randint(0, len(path)-3)\n                j = random.randint(i+2, len(path)-1)\n                if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d, resolution=res):\n                    path = path[:i+1] + path[j:]\n                attempts += 1\n            return path\n\n        start_tree = [Node(start_pos, cost=0.0)]\n        goal_tree = [Node(goal_pos, cost=0.0)]\n        nodes = start_tree[:] + goal_tree[:]\n        edges = []\n\n        gamma = 35.0  # adaptive radius constant\n        best_connection = None\n        best_cost = float('inf')\n        found_solution = False\n\n        time_start = time.monotonic()\n\n        for iter_count in range(self.max_iter):\n            if time.monotonic() - time_start > self.time_limit:\n                break\n\n            # Alternate trees\n            tree_a = start_tree if iter_count % 2 == 0 else goal_tree\n            tree_b = goal_tree if iter_count % 2 == 0 else start_tree\n\n            q_rand = sample_free()\n            nearest_a = nearest(tree_a, q_rand)\n            q_new_pos = steer(nearest_a.position, q_rand, self.step_size)\n\n            if self._is_in_obstacle(q_new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_a.position, q_new_pos, obstacles, is_3d, resolution=self.step_size/10):\n                continue\n\n            n = max(len(tree_a), 2)\n            radius = min(self.step_size * 5.0, gamma * (math.log(n) / n) ** (1/dim))\n            radius = max(radius, self.step_size * 1.5)  # ensure minimum radius for rewiring\n\n            neighbors = near(tree_a, q_new_pos, radius)\n\n            min_cost = nearest_a.cost + dist(nearest_a.position, q_new_pos)\n            min_parent = nearest_a\n            for near_n in neighbors:\n                cost_to_new = near_n.cost + dist(near_n.position, q_new_pos)\n                if cost_to_new + 1e-9 < min_cost:\n                    if not self._is_edge_in_obstacle(near_n.position, q_new_pos, obstacles, is_3d, resolution=self.step_size/10):\n                        min_cost = cost_to_new\n                        min_parent = near_n\n\n            new_node = Node(q_new_pos, parent=min_parent, cost=min_cost)\n            min_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((min_parent, new_node))\n\n            # Rewire neighbors\n            for near_n in neighbors:\n                if near_n is min_parent:\n                    continue\n                cost_through_new = new_node.cost + dist(new_node.position, near_n.position)\n                if cost_through_new + 1e-9 < near_n.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near_n.position, obstacles, is_3d, resolution=self.step_size/10):\n                        if near_n.parent:\n                            try:\n                                edges.remove((near_n.parent, near_n))\n                            except ValueError:\n                                pass\n                            near_n.parent.remove_child(near_n)\n                        near_n.parent = new_node\n                        near_n.cost = cost_through_new\n                        new_node.add_child(near_n)\n                        edges.append((new_node, near_n))\n\n            # Try connect to other tree\n            connect_radius = self.step_size * 4.0\n            candidates = near(tree_b, new_node.position, connect_radius)\n            for c in candidates:\n                d = dist(new_node.position, c.position)\n                if d <= connect_radius:\n                    if not self._is_edge_in_obstacle(new_node.position, c.position, obstacles, is_3d, resolution=self.step_size/10):\n                        total_cost = new_node.cost + c.cost + d\n                        if total_cost < best_cost:\n                            best_cost = total_cost\n                            best_connection = (new_node, c)\n                            found_solution = True\n\n            if found_solution:\n                break\n\n        if found_solution and best_connection:\n            extracted_path = extract_path(best_connection[0], best_connection[1])\n            extracted_path = shortcut_path(extracted_path)\n        else:\n            # Fallback partial connection if no full path found\n            min_cost_partial = float('inf')\n            best_pair_partial = None\n            search_radius = self.step_size * 4.0\n            for n1 in start_tree:\n                candidates = near(goal_tree, n1.position, search_radius)\n                for n2 in candidates:\n                    if not self._is_edge_in_obstacle(n1.position, n2.position, obstacles, is_3d, resolution=self.step_size/10):\n                        cost_ = n1.cost + n2.cost + dist(n1.position, n2.position)\n                        if cost_ < min_cost_partial:\n                            min_cost_partial = cost_\n                            best_pair_partial = (n1, n2)\n            if best_pair_partial:\n                extracted_path = extract_path(best_pair_partial[0], best_pair_partial[1])\n                extracted_path = shortcut_path(extracted_path)\n                found_solution = True\n            else:\n                extracted_path = []\n\n        return PlannerResult(\n            success=found_solution,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -28.687,
          "time_improvement": 39.0,
          "length_improvement": 15.0,
          "smoothness_improvement": 1654.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.022521281242370607,
                    "num_nodes_avg": 116.4,
                    "path_length_avg": 169.51336511904668,
                    "smoothness_avg": 0.03893990446828376,
                    "success_improvement": 0.0,
                    "time_improvement": 10.75255711826518,
                    "length_improvement": 7.087038467088057,
                    "smoothness_improvement": 509.4940642846131,
                    "objective_score": 10.025460537155453
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.04739372730255127,
                    "num_nodes_avg": 283.9,
                    "path_length_avg": 237.0595338731959,
                    "smoothness_avg": 0.12088341385225838,
                    "success_improvement": 0.0,
                    "time_improvement": 71.09092707132022,
                    "length_improvement": 20.862704212777263,
                    "smoothness_improvement": 3010.4173072222584,
                    "objective_score": 48.896987185173714
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.03233258724212647,
                    "num_nodes_avg": 197.6,
                    "path_length_avg": 126.4366397151005,
                    "smoothness_avg": 0.12128219869438872,
                    "success_improvement": 0.0,
                    "time_improvement": 34.36324027435144,
                    "length_improvement": 16.026804167025343,
                    "smoothness_improvement": 1442.7006152719268,
                    "objective_score": 27.138557658880273
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "A simplified bidirectional RRT* variant with adaptive rewiring radius, goal bias sampling with retry limits, and incremental path improvement leveraging efficient neighbor searches. The planner grows two trees from start and goal alternately, rewiring nearby nodes for cost improvement, connecting trees within a dynamic radius, and performing lightweight shortcutting focused on removing redundancies. A strict 30-second wall-clock timer ensures timely termination with the best path found so far.",
          "planning_mechanism": "A bi-directional RRT* approach sampling free configurations with a fallback retry limit, expanding trees with bounded steering, rewiring neighbors within an adaptive radius logarithmically scaled by tree size, attempting connection candidates between trees in an expanded radius, and incrementally shortcutting the best path on improvements. Early stopping occurs upon finding a better connection for efficient planning.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, goal_sample_rate: float = 0.2):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.time_limit = 30.0\n\n    def plan(self, map) -> 'PlannerResult':\n        import time\n        import math\n        import random\n\n        bounds = map.size\n        dim = len(bounds)\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = dim == 3\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def dist_sq(a, b):\n            return sum((a[i] - b[i]) ** 2 for i in range(dim))\n\n        def sample_free():\n            if random.random() < self.goal_sample_rate:\n                return goal_pos\n            for _ in range(30):\n                p = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n            return goal_pos\n\n        def steer(from_p, to_p, max_step):\n            d = dist(from_p, to_p)\n            if d <= max_step:\n                return to_p\n            ratio = max_step / d\n            return tuple(from_p[i] + (to_p[i] - from_p[i]) * ratio for i in range(dim))\n\n        def nearest(tree, point):\n            best_node = None\n            best_dist_sq = float('inf')\n            for n in tree:\n                d2 = dist_sq(n.position, point)\n                if d2 < best_dist_sq:\n                    best_dist_sq = d2\n                    best_node = n\n            return best_node\n\n        def near(tree, point, radius):\n            r_sq = radius * radius\n            res = []\n            for n in tree:\n                d2 = dist_sq(n.position, point)\n                if d2 <= r_sq:\n                    res.append((d2, n))\n            res.sort(key=lambda x: x[0])\n            return [e[1] for e in res]\n\n        def extract_path(node_start, node_goal):\n            path_start = []\n            cur = node_start\n            while cur:\n                path_start.append(cur.position)\n                cur = cur.parent\n            path_goal = []\n            cur = node_goal\n            while cur:\n                path_goal.append(cur.position)\n                cur = cur.parent\n            return path_start[::-1] + path_goal\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            attempts = 0\n            max_attempts = 100\n            while attempts < max_attempts and len(path) >= 3:\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                    path = path[:i + 1] + path[j:]\n                attempts += 1\n            return path\n\n        def try_connect(new_node, other_tree, radius):\n            candidates = near(other_tree, new_node.position, radius)\n            best_node = None\n            best_cost = float('inf')\n            for c in candidates:\n                d = dist(new_node.position, c.position)\n                if d <= radius and not self._is_edge_in_obstacle(new_node.position, c.position, obstacles, is_3d):\n                    total_cost = new_node.cost + c.cost + d\n                    if total_cost < best_cost:\n                        best_cost = total_cost\n                        best_node = c\n            return best_node, best_cost\n\n        start_tree = [Node(start_pos, cost=0.0)]\n        goal_tree = [Node(goal_pos, cost=0.0)]\n        nodes = start_tree[:] + goal_tree[:]\n        edges = []\n\n        gamma = 35.0\n        best_connection = None\n        best_cost = float('inf')\n        success = False\n\n        start_time = time.monotonic()\n\n        for it in range(self.max_iter):\n            if time.monotonic() - start_time > self.time_limit:\n                break\n\n            tree_a, tree_b = (start_tree, goal_tree) if it % 2 == 0 else (goal_tree, start_tree)\n\n            sample = sample_free()\n            nearest_node = nearest(tree_a, sample)\n            new_pos = steer(nearest_node.position, sample, self.step_size)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            n_nodes = len(tree_a) + 1\n            radius = min(self.step_size * 5,\n                         gamma * (math.log(max(n_nodes, 2)) / n_nodes) ** (1 / dim))\n\n            near_nodes = near(tree_a, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            min_parent = nearest_node\n            for near_node in near_nodes:\n                new_cost = near_node.cost + dist(near_node.position, new_pos)\n                if new_cost + 1e-9 < min_cost:\n                    if not self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d):\n                        min_cost = new_cost\n                        min_parent = near_node\n\n            new_node = Node(new_pos, parent=min_parent, cost=min_cost)\n            min_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((min_parent, new_node))\n\n            # Rewire neighbors\n            for near_node in near_nodes:\n                if near_node is min_parent:\n                    continue\n                rewired_cost = new_node.cost + dist(new_node.position, near_node.position)\n                if rewired_cost + 1e-9 < near_node.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                        if near_node.parent is not None:\n                            try:\n                                edges.remove((near_node.parent, near_node))\n                            except ValueError:\n                                pass\n                            near_node.parent.remove_child(near_node)\n                        near_node.parent = new_node\n                        near_node.cost = rewired_cost\n                        new_node.add_child(near_node)\n                        edges.append((new_node, near_node))\n\n            # Try connecting opposite tree\n            connect_radius = self.step_size * 3.0\n            conn_node, conn_cost = try_connect(new_node, tree_b, connect_radius)\n            if conn_node is not None and conn_cost < best_cost:\n                best_cost = conn_cost\n                best_connection = (new_node, conn_node)\n                success = True\n                # Early stop for efficiency\n                break\n\n            # Periodic shortcutting\n            if it % 100 == 0 and success and best_connection:\n                path = extract_path(best_connection[0], best_connection[1])\n                path = shortcut_path(path)\n                extracted_path = path\n\n        if success and best_connection:\n            extracted_path = extract_path(best_connection[0], best_connection[1])\n            extracted_path = shortcut_path(extracted_path)\n        else:\n            # Attempt partial connection fallback\n            min_cost = float('inf')\n            best_pair = None\n            for n1 in start_tree:\n                candidates = near(goal_tree, n1.position, self.step_size * 3.0)\n                for n2 in candidates:\n                    d = dist(n1.position, n2.position)\n                    if d <= self.step_size * 3.0 and not self._is_edge_in_obstacle(n1.position, n2.position, obstacles, is_3d):\n                        total_c = n1.cost + n2.cost + d\n                        if total_c < min_cost:\n                            min_cost = total_c\n                            best_pair = (n1, n2)\n            if best_pair:\n                extracted_path = extract_path(best_pair[0], best_pair[1])\n                extracted_path = shortcut_path(extracted_path)\n                success = True\n\n        if not success:\n            extracted_path = []\n\n        return PlannerResult(\n            success=success,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=None):\n        import math\n        if resolution is None:\n            resolution = max(0.5, self.step_size / 5)\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -28.40282,
          "time_improvement": 39.0,
          "length_improvement": 15.0,
          "smoothness_improvement": 1467.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.01759207248687744,
                    "num_nodes_avg": 97.3,
                    "path_length_avg": 166.84842552375585,
                    "smoothness_avg": 0.035136022645855615,
                    "success_improvement": 0.0,
                    "time_improvement": 30.286049556980327,
                    "length_improvement": 8.547734087937185,
                    "smoothness_improvement": 449.95505350202524,
                    "objective_score": 16.464230587366536
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.08978750705718994,
                    "num_nodes_avg": 336.1,
                    "path_length_avg": 237.11037975476998,
                    "smoothness_avg": 0.09784145923876689,
                    "success_improvement": 0.0,
                    "time_improvement": 45.23170602239328,
                    "length_improvement": 20.84573039399028,
                    "smoothness_improvement": 2417.5312185680477,
                    "objective_score": 38.16460613595239
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.028477692604064943,
                    "num_nodes_avg": 173.7,
                    "path_length_avg": 124.84088433642191,
                    "smoothness_avg": 0.12847531178014862,
                    "success_improvement": 0.0,
                    "time_improvement": 42.18886806068799,
                    "length_improvement": 17.08662890783816,
                    "smoothness_improvement": 1534.1964827824138,
                    "objective_score": 30.579620176821365
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m1",
          "algorithm_description": "A bidirectional RRT* planner with adaptive rewiring radius and iterative incremental shortcutting, enhanced via goal-biased sampling and multiple progressive connection attempts across trees. The planner incorporates efficient parent selection and rewiring based on cost, uses dynamically computed neighborhoods that scale logarithmically with the number of nodes to optimize exploration-exploitation tradeoff, and applies frequent path shortcutting throughout the planning to improve path smoothness and length. It enforces a strict 30-second time limit, early terminates on improved solutions, and maintains consistent collision checking tailored to step size.",
          "planning_mechanism": "A bidirectional RRT* framework alternately grows two trees from start and goal, sampling with a fixed goal bias. Each new sampled point is extended from the nearest node with a fixed step size, with parent selection and rewiring performed among adaptively computed neighbors to improve path cost. Multiple candidate nodes from the opposite tree within a connection radius are attempted to connect new nodes, allowing earlier discovery of feasible low-cost paths. An incremental shortcutting routine is run periodically and at the end to smooth and shorten the best found path. The planner tracks and returns the best solution found within a 30-second wall-clock limit, or partial path if no full path is found.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent: Optional[\"Node\"]=None, cost: float=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children: List[\"Node\"] = []\n        self.valid = True\n\n    def add_child(self, child: \"Node\"):\n        self.children.append(child)\n\n    def remove_child(self, child: \"Node\"):\n        if child in self.children:\n            self.children.remove(child)\nclass Planner:\n    def __init__(self, max_iter: int=5000, step_size: float=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.time_limit = 30.0\n        self.goal_sample_rate = 0.15  # 15% samples from goal to bias sampling\n        self.gamma = 30.0  # rewiring radius multiplier\n        self.shortcut_interval = 50  # iterations between shortcut runs\n        self.max_shortcut_attempts = 40\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        start_tree: List[Node] = [Node(start_pos, cost=0.0)]\n        goal_tree: List[Node] = [Node(goal_pos, cost=0.0)]\n        nodes: List[Node] = start_tree[:] + goal_tree[:]\n        edges: List[Tuple[Node, Node]] = []\n\n        best_cost = float('inf')\n        best_connection: Optional[Tuple[Node, Node]] = None\n        success = False\n        extracted_path: List[Tuple[float, ...]] = []\n\n        start_time = time.monotonic()\n        iter_since_shortcut = 0\n\n        def dist(a: Tuple[float, ...], b: Tuple[float, ...]) -> float:\n            return math.dist(a, b)\n\n        def sample_free():\n            if random.random() < self.goal_sample_rate:\n                return goal_pos\n            for _ in range(100):\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(sample, obstacles, is_3d):\n                    return sample\n            return goal_pos  # fallback if no free sample found\n\n        def nearest(tree: List[Node], pt: Tuple[float, ...]) -> Node:\n            best_node = None\n            best_dist = float('inf')\n            for node in tree:\n                d = dist(node.position, pt)\n                if d < best_dist:\n                    best_node = node\n                    best_dist = d\n            return best_node\n\n        def near(tree: List[Node], pt: Tuple[float, ...], radius: float) -> List[Node]:\n            def dist_node(n: Node):\n                return dist(n.position, pt)\n            neighbors = [n for n in tree if dist(n.position, pt) <= radius]\n            neighbors.sort(key=dist_node)\n            return neighbors\n\n        def steer(from_p: Tuple[float, ...], to_p: Tuple[float, ...], max_step: float) -> Tuple[float, ...]:\n            d = dist(from_p, to_p)\n            if d <= max_step:\n                return to_p\n            ratio = max_step / d\n            return tuple(from_p[i] + (to_p[i] - from_p[i]) * ratio for i in range(dim))\n\n        def extract_path(node_start: Node, node_goal: Node) -> List[Tuple[float, ...]]:\n            path_start = []\n            cur = node_start\n            while cur is not None:\n                path_start.append(cur.position)\n                cur = cur.parent\n            path_start.reverse()\n\n            path_goal = []\n            cur = node_goal\n            while cur is not None:\n                path_goal.append(cur.position)\n                cur = cur.parent\n            if path_start and path_goal and path_start[-1] == path_goal[0]:\n                path_goal = path_goal[1:]\n            return path_start + path_goal\n\n        def shortcut_path(path: List[Tuple[float, ...]], max_attempts: int) -> List[Tuple[float, ...]]:\n            if len(path) < 3:\n                return path\n            for _ in range(max_attempts):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution=max(self.step_size*0.2, 0.2)):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        def try_connect(new_node: Node, other_tree: List[Node], radius: float) -> Tuple[Optional[Node], float]:\n            candidates = near(other_tree, new_node.position, radius)\n            best_cand = None\n            best_local_cost = float('inf')\n            for node in candidates:\n                d12 = dist(new_node.position, node.position)\n                if d12 <= radius and not self._is_edge_in_obstacle(new_node.position, node.position, obstacles, is_3d, resolution=max(self.step_size*0.2, 0.2)):\n                    cost_sum = new_node.cost + d12 + node.cost\n                    if cost_sum < best_local_cost:\n                        best_local_cost = cost_sum\n                        best_cand = node\n            return best_cand, best_local_cost\n\n        def rewire(tree: List[Node], new_node: Node, neighbors: List[Node]):\n            for nbr in neighbors:\n                if nbr is new_node.parent:\n                    continue\n                cost_through_new = new_node.cost + dist(new_node.position, nbr.position)\n                if cost_through_new + 1e-9 < nbr.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, nbr.position, obstacles, is_3d, resolution=max(self.step_size*0.2, 0.2)):\n                        # Remove old edge\n                        if nbr.parent:\n                            try:\n                                edges.remove((nbr.parent, nbr))\n                            except ValueError:\n                                pass\n                            nbr.parent.remove_child(nbr)\n                        # Reassign parent and cost\n                        nbr.parent = new_node\n                        nbr.cost = cost_through_new\n                        new_node.add_child(nbr)\n                        edges.append((new_node, nbr))\n\n        for it in range(self.max_iter):\n            if time.monotonic() - start_time > self.time_limit:\n                break\n\n            tree_a = start_tree if (it % 2 == 0) else goal_tree\n            tree_b = goal_tree if (it % 2 == 0) else start_tree\n\n            sample = sample_free()\n            nearest_node = nearest(tree_a, sample)\n            new_pos = steer(nearest_node.position, sample, self.step_size)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d, resolution=max(self.step_size*0.2, 0.2)):\n                continue\n\n            n_nodes = len(tree_a) + 1\n            radius = self.gamma * ((math.log(n_nodes)/n_nodes) ** (1/dim)) if n_nodes > 1 else self.step_size*5\n            radius = min(radius, self.step_size*5)\n            radius = max(radius, self.step_size)\n\n            neighbors = near(tree_a, new_pos, radius)\n\n            # Select parent with minimal cost\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            min_parent = nearest_node\n            for nb in neighbors:\n                if not self._is_edge_in_obstacle(nb.position, new_pos, obstacles, is_3d, resolution=max(self.step_size*0.2, 0.2)):\n                    cost_cand = nb.cost + dist(nb.position, new_pos)\n                    if cost_cand + 1e-9 < min_cost:\n                        min_cost = cost_cand\n                        min_parent = nb\n\n            new_node = Node(new_pos, parent=min_parent, cost=min_cost)\n            min_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((min_parent, new_node))\n\n            rewire(tree_a, new_node, neighbors)\n\n            conn_node, conn_cost = try_connect(new_node, tree_b, radius*1.2)\n            if conn_node is not None and conn_cost + 1e-9 < best_cost:\n                success = True\n                best_cost = conn_cost\n                best_connection = (new_node, conn_node) if it % 2 == 0 else (conn_node, new_node)\n                # Early termination on improvement\n                break\n\n            iter_since_shortcut += 1\n            if iter_since_shortcut >= self.shortcut_interval and success and best_connection is not None:\n                current_path = extract_path(best_connection[0], best_connection[1])\n                shortened = shortcut_path(current_path, max_attempts=self.max_shortcut_attempts)\n                if len(shortened) < len(current_path):\n                    extracted_path = shortened\n                iter_since_shortcut = 0\n\n        if success and best_connection is not None:\n            extracted_path = extract_path(best_connection[0], best_connection[1])\n            extracted_path = shortcut_path(extracted_path, max_attempts=self.max_shortcut_attempts*2)\n        else:\n            # Try partial connection fallback\n            best_partial_cost = float('inf')\n            best_pair = None\n            search_radius = self.step_size * 3\n            for n_start in start_tree:\n                candidates = near(goal_tree, n_start.position, search_radius)\n                for n_goal in candidates:\n                    d12 = dist(n_start.position, n_goal.position)\n                    if d12 <= search_radius:\n                        if not self._is_edge_in_obstacle(n_start.position, n_goal.position, obstacles, is_3d, resolution=max(self.step_size*0.2, 0.2)):\n                            cost_sum = n_start.cost + d12 + n_goal.cost\n                            if cost_sum < best_partial_cost:\n                                best_partial_cost = cost_sum\n                                best_pair = (n_start, n_goal)\n            if best_pair:\n                success = True\n                extracted_path = extract_path(best_pair[0], best_pair[1])\n                extracted_path = shortcut_path(extracted_path, max_attempts=self.max_shortcut_attempts*2)\n\n        return PlannerResult(\n            success=success,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos: Tuple[float, ...], obstacles, is_3d: bool) -> bool:\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos: Tuple[float, ...], to_pos: Tuple[float, ...], obstacles, is_3d: bool, resolution=1.0) -> bool:\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -28.23296,
          "time_improvement": 40.0,
          "length_improvement": 15.0,
          "smoothness_improvement": 1447.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.02250080108642578,
                    "num_nodes_avg": 133.2,
                    "path_length_avg": 174.10583657328837,
                    "smoothness_avg": 0.03533155704968899,
                    "success_improvement": 0.0,
                    "time_improvement": 10.833715979886968,
                    "length_improvement": 4.569832090651076,
                    "smoothness_improvement": 453.0155915317716,
                    "objective_score": 8.257092006015593
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.048084449768066403,
                    "num_nodes_avg": 365.9,
                    "path_length_avg": 238.06975876056944,
                    "smoothness_avg": 0.09827401173992896,
                    "success_improvement": 0.0,
                    "time_improvement": 70.66960240948086,
                    "length_improvement": 20.52546206766085,
                    "smoothness_improvement": 2428.661105977921,
                    "objective_score": 45.65946349333038
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.029903388023376463,
                    "num_nodes_avg": 270.1,
                    "path_length_avg": 121.21919591756429,
                    "smoothness_avg": 0.12262243997404691,
                    "success_improvement": 0.0,
                    "time_improvement": 39.29463547179747,
                    "length_improvement": 19.4919819093734,
                    "smoothness_improvement": 1459.748385422858,
                    "objective_score": 30.782321714277572
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "A streamlined bidirectional RRT* planner that grows two trees from start and goal points by iterative sampling with goal bias, adaptive neighborhood radius rewiring based on tree size, and collision-checked extensions. It attempts connections between trees with an extended radius and performs lightweight path shortcutting only after path discovery. The planner enforces a hard 30-second limit and returns the best found path with improved efficiency, shorter length, and smoother trajectories.",
          "planning_mechanism": "The planner alternately samples free configurations biased toward the goal, extends the current tree toward samples using a fixed step size, rewires neighbors within an adaptive radius computed from the number of nodes and dimension, and tries connecting to the opposite tree within a radius. Upon finding a valid connection, it stores the best path and applies path shortcutting only once after planning completes or time expires, ensuring rapid convergence and improved path quality.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=5.0, goal_sample_rate=0.15):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.time_limit = 30.0\n\n    def plan(self, map):\n        import time\n        import math\n        import random\n\n        bounds = map.size\n        dim = len(bounds)\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = (dim == 3)\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def sample_free():\n            if random.random() < self.goal_sample_rate:\n                return goal_pos\n            for _ in range(30):\n                p = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n            return goal_pos\n\n        def steer(from_p, to_p, max_step):\n            d = dist(from_p, to_p)\n            if d <= max_step:\n                return to_p\n            ratio = max_step / d\n            return tuple(from_p[i] + (to_p[i] - from_p[i]) * ratio for i in range(dim))\n\n        def nearest(tree, point):\n            best_node = None\n            best_dist_sq = float('inf')\n            for n in tree:\n                d_sq = sum((n.position[i] - point[i]) ** 2 for i in range(dim))\n                if d_sq < best_dist_sq:\n                    best_dist_sq = d_sq\n                    best_node = n\n            return best_node\n\n        def near(tree, point, radius):\n            rsq = radius * radius\n            neighbors = []\n            for n in tree:\n                d_sq = sum((n.position[i] - point[i]) ** 2 for i in range(dim))\n                if d_sq <= rsq:\n                    neighbors.append((d_sq, n))\n            neighbors.sort(key=lambda x: x[0])\n            return [n[1] for n in neighbors]\n\n        def extract_path(n_start, n_goal):\n            path_start = []\n            cur = n_start\n            while cur:\n                path_start.append(cur.position)\n                cur = cur.parent\n            path_start.reverse()\n            path_goal = []\n            cur = n_goal\n            while cur:\n                path_goal.append(cur.position)\n                cur = cur.parent\n            if path_start[-1] == path_goal[0]:\n                path_goal = path_goal[1:]\n            return path_start + path_goal\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            attempts = 0\n            max_attempts = 100\n            while attempts < max_attempts and len(path) >= 3:\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                    path = path[:i + 1] + path[j:]\n                attempts += 1\n            return path\n\n        def try_connect(new_node, other_tree, radius):\n            candidates = near(other_tree, new_node.position, radius)\n            best_cand = None\n            best_cost = float('inf')\n            for c in candidates:\n                d = dist(new_node.position, c.position)\n                if d <= radius and not self._is_edge_in_obstacle(new_node.position, c.position, obstacles, is_3d):\n                    cost = new_node.cost + c.cost + d\n                    if cost < best_cost:\n                        best_cost = cost\n                        best_cand = c\n            return best_cand, best_cost\n\n        start_tree = [Node(start_pos, cost=0.0)]\n        goal_tree = [Node(goal_pos, cost=0.0)]\n        nodes = start_tree[:] + goal_tree[:]\n        edges = []\n\n        gamma = 35.0\n        best_connection = None\n        best_cost = float('inf')\n        success = False\n\n        start_time = time.monotonic()\n\n        for it in range(self.max_iter):\n            if time.monotonic() - start_time > self.time_limit:\n                break\n\n            tree_a, tree_b = (start_tree, goal_tree) if it % 2 == 0 else (goal_tree, start_tree)\n\n            sample = sample_free()\n            nearest_node = nearest(tree_a, sample)\n            new_pos = steer(nearest_node.position, sample, self.step_size)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            n = len(tree_a) + 1\n            radius = min(self.step_size * 5,\n                         gamma * (math.log(max(n, 2)) / n) ** (1 / dim))\n\n            near_nodes = near(tree_a, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            min_parent = nearest_node\n            for near_node in near_nodes:\n                new_cost = near_node.cost + dist(near_node.position, new_pos)\n                if new_cost < min_cost:\n                    if not self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d):\n                        min_cost = new_cost\n                        min_parent = near_node\n\n            new_node = Node(new_pos, parent=min_parent, cost=min_cost)\n            min_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((min_parent, new_node))\n\n            for near_node in near_nodes:\n                if near_node is min_parent:\n                    continue\n                rewired_cost = new_node.cost + dist(new_node.position, near_node.position)\n                if rewired_cost < near_node.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                        if near_node.parent:\n                            try:\n                                edges.remove((near_node.parent, near_node))\n                            except ValueError:\n                                pass\n                            near_node.parent.remove_child(near_node)\n                        near_node.parent = new_node\n                        near_node.cost = rewired_cost\n                        new_node.add_child(near_node)\n                        edges.append((new_node, near_node))\n\n            conn_node, conn_cost = try_connect(new_node, tree_b, self.step_size * 3.0)\n            if conn_node and conn_cost < best_cost:\n                best_cost = conn_cost\n                best_connection = (new_node, conn_node)\n                success = True\n                # Early stopping for efficiency\n                break\n\n        if success and best_connection:\n            path = extract_path(best_connection[0], best_connection[1])\n            path = shortcut_path(path)\n        else:\n            # Partial connection fallback\n            min_cost = float('inf')\n            best_pair = None\n            for n1 in start_tree:\n                candidates = near(goal_tree, n1.position, self.step_size * 3.0)\n                for n2 in candidates:\n                    d = dist(n1.position, n2.position)\n                    if d <= self.step_size * 3.0 and not self._is_edge_in_obstacle(n1.position, n2.position, obstacles, is_3d):\n                        cost = n1.cost + n2.cost + d\n                        if cost < min_cost:\n                            min_cost = cost\n                            best_pair = (n1, n2)\n            if best_pair:\n                path = extract_path(best_pair[0], best_pair[1])\n                path = shortcut_path(path)\n                success = True\n            else:\n                path = []\n\n        return PlannerResult(\n            success=success,\n            path=path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=None):\n        import math\n        if resolution is None:\n            resolution = max(0.5, self.step_size / 5)\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -27.74825,
          "time_improvement": 40.0,
          "length_improvement": 15.0,
          "smoothness_improvement": 1335.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.019061350822448732,
                    "num_nodes_avg": 114.5,
                    "path_length_avg": 170.6394137840905,
                    "smoothness_avg": 0.04178132687174441,
                    "success_improvement": 0.0,
                    "time_improvement": 24.463586220188997,
                    "length_improvement": 6.4698333503945955,
                    "smoothness_improvement": 553.9684951462797,
                    "objective_score": 13.990818352024853
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.07259199619293213,
                    "num_nodes_avg": 321.5,
                    "path_length_avg": 239.4914611910675,
                    "smoothness_avg": 0.08843483732520492,
                    "success_improvement": 0.0,
                    "time_improvement": 55.72056828147064,
                    "length_improvement": 20.050856874925092,
                    "smoothness_improvement": 2175.4920614161942,
                    "objective_score": 39.62414491647722
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.02925105094909668,
                    "num_nodes_avg": 195.0,
                    "path_length_avg": 122.79799507744235,
                    "smoothness_avg": 0.10814640237504218,
                    "success_improvement": 0.0,
                    "time_improvement": 40.61891216775107,
                    "length_improvement": 18.443418681719525,
                    "smoothness_improvement": 1275.6142556734658,
                    "objective_score": 29.629796137724362
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "initial",
          "algorithm_description": "This algorithm is a bidirectional extension of RRT* that grows two trees from start and goal while optimizing paths via rewiring. It combines RRT*\u2018s asymptotic optimality with RRT-Connect\u2019s fast convergence through connection attempts between the trees.",
          "planning_mechanism": "The planner alternates growing two trees with sampling, extension, and rewiring. After each extension, it attempts to connect both trees. When connection is successful, a rewired optimal path is extracted across both trees.",
          "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, radius: float = 10.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.radius = radius\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n        nodes = []\n        edges = []\n        success_state = False\n        extracted_path = []\n\n        for iter in range(self.max_iter):\n            rand = self._sample_free(bounds, obstacles, is_3d)\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest = self._nearest(tree_a, rand)\n                new_pos = self._steer(nearest.position, rand, self.step_size)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                    continue\n\n                new_node = Node(new_pos)\n                near_nodes = self._near(tree_a, new_pos, self.radius)\n                min_cost = nearest.cost + self._distance(nearest.position, new_pos)\n                min_parent = nearest\n\n                for near in near_nodes:\n                    cost = near.cost + self._distance(near.position, new_pos)\n                    if cost < min_cost and not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d):\n                        min_cost = cost\n                        min_parent = near\n\n                new_node.parent = min_parent\n                new_node.cost = min_cost\n                min_parent.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((min_parent, new_node))\n\n                for near in near_nodes:\n                    if near == min_parent:\n                        continue\n                    new_cost = new_node.cost + self._distance(new_node.position, near.position)\n                    if new_cost < near.cost and not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                        if near.parent:\n                            edges.remove((near.parent, near))\n                        near.parent = new_node\n                        near.cost = new_cost\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n\n                connect_node = self._nearest(tree_b, new_node.position)\n                if self._distance(new_node.position, connect_node.position) < self.step_size and not self._is_edge_in_obstacle(new_node.position, connect_node.position, obstacles, is_3d):\n                    success_state = True\n                    extracted_path = self._extract_path(new_node, connect_node)\n                    return PlannerResult(True, extracted_path, start_tree + goal_tree, edges)\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        while True:\n            point = tuple(random.uniform(0, bounds[i]) for i in range(3 if is_3d else 2))\n            if not self._is_in_obstacle(point, obstacles, is_3d):\n                return point\n\n    def _nearest(self, tree, point):\n        return min(tree, key=lambda node: self._distance(node.position, point))\n\n    def _near(self, tree, point, radius):\n        return [node for node in tree if self._distance(node.position, point) <= radius]\n\n    def _steer(self, from_pos, to_pos, step_size):\n        dist = self._distance(from_pos, to_pos)\n        if dist <= step_size:\n            return to_pos\n        ratio = step_size / dist\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n    def _extract_path(self, node_a, node_b):\n        path_a = []\n        while node_a:\n            path_a.append(node_a.position)\n            node_a = node_a.parent\n        path_b = []\n        while node_b:\n            path_b.append(node_b.position)\n            node_b = node_b.parent\n        return list(reversed(path_a)) + path_b\n\n    def _distance(self, a, b):\n        return math.dist(a, b)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = self._distance(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n    ",
          "objective": -27.725799297442336,
          "time_improvement": 75.0,
          "length_improvement": 7.0,
          "smoothness_improvement": 170.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.010820579528808594,
                    "num_nodes_avg": 133.0,
                    "path_length_avg": 175.27050435154484,
                    "smoothness_avg": 0.016726285105375487,
                    "success_improvement": 0.0,
                    "time_improvement": 56.761515149494244,
                    "length_improvement": 3.931459226046746,
                    "smoothness_improvement": 161.80268360858182,
                    "objective_score": 20.19634349851923
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.019153308868408204,
                    "num_nodes_avg": 264.6,
                    "path_length_avg": 258.5920512869376,
                    "smoothness_avg": 0.010908242682381757,
                    "success_improvement": 0.0,
                    "time_improvement": 88.28645766200407,
                    "length_improvement": 13.674530120921121,
                    "smoothness_improvement": 180.67694110730886,
                    "objective_score": 35.59404007669044
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.010100054740905761,
                    "num_nodes_avg": 179.6,
                    "path_length_avg": 143.86931760330097,
                    "smoothness_avg": 0.02092975461741331,
                    "success_improvement": 0.0,
                    "time_improvement": 79.62193302219796,
                    "length_improvement": 4.448849568598979,
                    "smoothness_improvement": 166.22493385971097,
                    "objective_score": 27.38701431711733
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "A simplified bidirectional RRT* planner with balanced goal bias, adaptive rewiring radius based on the logarithm of node count, incremental rewiring for cost improvement, and lightweight randomized shortcutting for path smoothing, all within a 30-second runtime limit. It alternates tree expansions from start and goal, uses direct nearest and near neighbor searches, and updates the best path found efficiently to reduce planning time while improving path length and smoothness.",
          "planning_mechanism": "The planner grows two trees alternately from start and goal positions by sampling free points biased towards the goal, connects new nodes selecting parents minimizing path costs within an adaptive radius, rewires neighbor nodes to reduce costs, attempts connections between the two trees within a neighborhood radius, applies periodic lightweight shortcutting on the best available path, and terminates early upon finding a better solution or when the time limit is reached, ultimately returning the best feasible path found.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0, goal_sample_rate: float=0.2):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.time_limit = 30.0\n\n    def plan(self, map):\n        import time\n        import math\n        import random\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = dim == 3\n\n        start_tree = [Node(start_pos, cost=0.0)]\n        goal_tree = [Node(goal_pos, cost=0.0)]\n        nodes = start_tree[:] + goal_tree[:]\n        edges = []\n\n        best_connection = None\n        best_cost = float('inf')\n        success = False\n        extracted_path = []\n\n        def dist(a,b):\n            return math.dist(a,b)\n\n        def dist_sq(a,b):\n            s = 0.0\n            for i in range(dim):\n                d = a[i]-b[i]\n                s += d*d\n            return s\n\n        def sample_free():\n            if random.random() < self.goal_sample_rate:\n                return goal_pos\n            for _ in range(30):\n                p = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n            return goal_pos\n\n        def nearest(tree, point):\n            best_node = None\n            best_dist = float('inf')\n            for node in tree:\n                d = dist_sq(node.position, point)\n                if d < best_dist:\n                    best_dist = d\n                    best_node = node\n            return best_node\n\n        def near(tree, point, radius):\n            r_sq = radius*radius\n            neighbors = []\n            for node in tree:\n                d = dist_sq(node.position, point)\n                if d <= r_sq:\n                    neighbors.append((d, node))\n            neighbors.sort(key=lambda x: x[0])\n            return [n[1] for n in neighbors]\n\n        def steer(from_p, to_p, max_step):\n            d = dist(from_p, to_p)\n            if d <= max_step:\n                return to_p\n            ratio = max_step / d\n            return tuple(from_p[i] + ratio*(to_p[i]-from_p[i]) for i in range(dim))\n\n        def extract_path(n_start, n_goal):\n            path_start = []\n            cur = n_start\n            while cur:\n                path_start.append(cur.position)\n                cur = cur.parent\n            path_goal = []\n            cur = n_goal\n            while cur:\n                path_goal.append(cur.position)\n                cur = cur.parent\n            return path_start[::-1] + path_goal\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            attempts = 30\n            for _ in range(attempts):\n                if len(path) < 3:\n                    break\n                i = random.randint(0,len(path)-3)\n                j = random.randint(i+2,len(path)-1)\n                if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        def try_connect(node, other_tree, radius):\n            candidates = near(other_tree, node.position, radius)\n            best_node = None\n            best_cost_local = float('inf')\n            for cnode in candidates:\n                d = dist(node.position, cnode.position)\n                if d <= radius and not self._is_edge_in_obstacle(node.position, cnode.position, obstacles, is_3d):\n                    total_cost = node.cost + cnode.cost + d\n                    if total_cost < best_cost_local:\n                        best_cost_local = total_cost\n                        best_node = cnode\n            return best_node, best_cost_local\n\n        def rewire(tree, new_node, neighbors):\n            for near_node in neighbors:\n                if near_node == new_node.parent:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, near_node.position)\n                if new_cost + 1e-9 < near_node.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                        if near_node.parent:\n                            try:\n                                edges.remove((near_node.parent, near_node))\n                            except ValueError:\n                                pass\n                            near_node.parent.remove_child(near_node)\n                        near_node.parent = new_node\n                        near_node.cost = new_cost\n                        new_node.add_child(near_node)\n                        edges.append((new_node, near_node))\n\n        start_time = time.monotonic()\n        gamma_rrt_star = 30.0\n\n        for it in range(self.max_iter):\n            current_time = time.monotonic()\n            if current_time - start_time > self.time_limit:\n                break\n\n            tree_a = start_tree if it % 2 == 0 else goal_tree\n            tree_b = goal_tree if it % 2 == 0 else start_tree\n\n            q_rand = sample_free()\n\n            nearest_node = nearest(tree_a, q_rand)\n            q_new = steer(nearest_node.position, q_rand, self.step_size)\n\n            if self._is_in_obstacle(q_new, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, q_new, obstacles, is_3d):\n                continue\n\n            n_nodes = max(len(tree_a),2)\n            radius = min(self.step_size*5.0, gamma_rrt_star * (math.log(n_nodes)/n_nodes)**(1.0/dim))\n\n            neighbors = near(tree_a, q_new, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, q_new)\n            min_parent = nearest_node\n            for near_n in neighbors:\n                cost_through = near_n.cost + dist(near_n.position, q_new)\n                if cost_through + 1e-9 < min_cost:\n                    if not self._is_edge_in_obstacle(near_n.position, q_new, obstacles, is_3d):\n                        min_cost = cost_through\n                        min_parent = near_n\n\n            new_node = Node(q_new, parent=min_parent, cost=min_cost)\n            min_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((min_parent, new_node))\n\n            rewire(tree_a, new_node, neighbors)\n\n            connect_radius = self.step_size*3.0\n            conn_node, conn_cost = try_connect(new_node, tree_b, connect_radius)\n            if conn_node and conn_cost < best_cost:\n                best_cost = conn_cost\n                best_connection = (new_node, conn_node)\n                success = True\n                extracted_path = extract_path(new_node, conn_node)\n                extracted_path = shortcut_path(extracted_path)\n                break\n\n            if success and it % 100 == 0 and best_connection:\n                path = extract_path(best_connection[0], best_connection[1])\n                shortcut = shortcut_path(path)\n                shortcut_len = sum(dist(shortcut[i], shortcut[i+1]) for i in range(len(shortcut)-1))\n                curr_len = sum(dist(extracted_path[i], extracted_path[i+1]) for i in range(len(extracted_path)-1))\n                if shortcut_len + 1e-8 < curr_len:\n                    extracted_path = shortcut\n\n        if not success:\n            best_pair = None\n            min_total = float('inf')\n            for n1 in start_tree:\n                candidates = near(goal_tree, n1.position, self.step_size*3.0)\n                for n2 in candidates:\n                    d = dist(n1.position, n2.position)\n                    if d <= self.step_size*3.0 and not self._is_edge_in_obstacle(n1.position, n2.position, obstacles, is_3d):\n                        total_c = n1.cost + n2.cost + d\n                        if total_c < min_total:\n                            min_total = total_c\n                            best_pair = (n1, n2)\n            if best_pair:\n                success = True\n                extracted_path = extract_path(best_pair[0], best_pair[1])\n                extracted_path = shortcut_path(extracted_path)\n\n        return PlannerResult(\n            success=success,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x,y,z,w,h,d = obs\n                px,py,pz = pos\n                if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                    return True\n            else:\n                x,y,w_,h_ = obs\n                px,py = pos\n                if x <= px <= x+w_ and y <= py <= y+h_:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps+1):\n            interp = tuple(from_pos[d] + (to_pos[d]-from_pos[d])*(i/steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -27.43438,
          "time_improvement": 55.0,
          "length_improvement": 14.0,
          "smoothness_improvement": 551.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.014897489547729492,
                    "num_nodes_avg": 124.5,
                    "path_length_avg": 165.8992144863402,
                    "smoothness_avg": 0.026445109039989236,
                    "success_improvement": 0.0,
                    "time_improvement": 40.96415593839107,
                    "length_improvement": 9.068011698756115,
                    "smoothness_improvement": 313.92338294925446,
                    "objective_score": 19.299670715517262
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.04256761074066162,
                    "num_nodes_avg": 306.9,
                    "path_length_avg": 249.54567503822258,
                    "smoothness_avg": 0.029184391199415433,
                    "success_improvement": 0.0,
                    "time_improvement": 74.03474608684778,
                    "length_improvement": 16.694470898245044,
                    "smoothness_improvement": 650.9354062282783,
                    "objective_score": 35.481783396142745
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.025249147415161134,
                    "num_nodes_avg": 227.1,
                    "path_length_avg": 126.84558042649284,
                    "smoothness_avg": 0.06203911235844328,
                    "success_improvement": 0.0,
                    "time_improvement": 48.74297532221194,
                    "length_improvement": 15.755205218182637,
                    "smoothness_improvement": 689.1329299484631,
                    "objective_score": 27.52168037731548
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "path_expert",
          "algorithm_description": "A bidirectional RRT* planner with goal bias and dynamically shrinking rewiring radius, improved parent selection via cost+distance heuristic, adaptive neighborhood rewiring focused on cost reduction, early connection attempts, and path shortcutting for minimal length under a hard 30s time limit.",
          "planning_mechanism": "The planner alternately grows start and goal trees using random sampling with goal bias, steering with fixed step size, and rewiring neighbors within a logarithmically shrinking radius for cost efficiency. It attempts early connection between trees by checking neighbors within an adaptive radius, selects parents minimizing cost-to-node plus distance heuristic, rewires incrementally to reduce path cost, and extracts and shortcuts the best path found periodically or on termination, always respecting collision constraints and bounds.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\nclass Planner:\n    def __init__(self, max_iter: int = 6000, step_size: float = 4.5, goal_sample_rate: float = 0.2):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.time_limit = 30.0\n\n    def plan(self, map):\n        import time\n        import random\n        import math\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        start_tree = [Node(start_pos, cost=0.0)]\n        goal_tree = [Node(goal_pos, cost=0.0)]\n        nodes = start_tree[:] + goal_tree[:]\n        edges = []\n\n        best_connection = None\n        best_cost = float('inf')\n        success = False\n        extracted_path = []\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def sample_free():\n            for _ in range(30):\n                if random.random() < self.goal_sample_rate:\n                    p = goal_pos\n                else:\n                    p = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n            return goal_pos\n\n        def nearest(tree, point):\n            best_node = None\n            best_dist = float('inf')\n            for node in tree:\n                d = dist(node.position, point)\n                if d < best_dist:\n                    best_node = node\n                    best_dist = d\n            return best_node\n\n        def near(tree, point, radius):\n            r_sq = radius * radius\n            neighbors = []\n            for node in tree:\n                d_sq = sum((node.position[i] - point[i])**2 for i in range(dim))\n                if d_sq <= r_sq:\n                    neighbors.append((math.sqrt(d_sq), node))\n            neighbors.sort(key=lambda x: x[0])\n            return [n[1] for n in neighbors]\n\n        def steer(from_p, to_p, max_step):\n            d = dist(from_p, to_p)\n            if d <= max_step:\n                return to_p\n            ratio = max_step / d\n            return tuple(from_p[i] + ratio * (to_p[i] - from_p[i]) for i in range(dim))\n\n        def extract_path(n_start, n_goal):\n            path_start = []\n            cur = n_start\n            while cur:\n                path_start.append(cur.position)\n                cur = cur.parent\n            path_goal = []\n            cur = n_goal\n            while cur:\n                path_goal.append(cur.position)\n                cur = cur.parent\n            return path_start[::-1] + path_goal\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            for _ in range(75):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        def try_connect(node, other_tree, radius):\n            candidates = near(other_tree, node.position, radius)\n            best_node = None\n            best_cost_local = float('inf')\n            for cnode in candidates:\n                d = dist(node.position, cnode.position)\n                if d <= radius and not self._is_edge_in_obstacle(node.position, cnode.position, obstacles, is_3d):\n                    total_cost = node.cost + cnode.cost + d\n                    if total_cost < best_cost_local:\n                        best_cost_local = total_cost\n                        best_node = cnode\n            return best_node, best_cost_local\n\n        start_time = time.monotonic()\n\n        for it in range(self.max_iter):\n            current_time = time.monotonic()\n            if current_time - start_time > self.time_limit:\n                break\n\n            tree_a = start_tree if it % 2 == 0 else goal_tree\n            tree_b = goal_tree if it % 2 == 0 else start_tree\n\n            sample = sample_free()\n            nearest_node = nearest(tree_a, sample)\n            new_pos = steer(nearest_node.position, sample, self.step_size)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            n_nodes = len(tree_a) + 1\n            gamma = 30.0  # radius scaling coefficient\n            radius = min(self.step_size * 5.5, gamma * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim)))\n\n            near_nodes = near(tree_a, new_pos, radius)\n\n            # Select parent that minimizes cost-to-node + dist heuristic\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            min_parent = nearest_node\n            for near_node in near_nodes:\n                cost_through = near_node.cost + dist(near_node.position, new_pos)\n                if cost_through < min_cost:\n                    if not self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d):\n                        min_cost = cost_through\n                        min_parent = near_node\n\n            new_node = Node(new_pos, parent=min_parent, cost=min_cost)\n            min_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((min_parent, new_node))\n\n            # Rewire neighbors to new node if cost improves and edge collision free\n            for near_node in near_nodes:\n                if near_node == min_parent:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, near_node.position)\n                if new_cost < near_node.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                        if near_node.parent:\n                            try:\n                                edges.remove((near_node.parent, near_node))\n                            except ValueError:\n                                pass\n                            near_node.parent.remove_child(near_node)\n                        near_node.parent = new_node\n                        near_node.cost = new_cost\n                        new_node.add_child(near_node)\n                        edges.append((new_node, near_node))\n\n            # Attempt connection to other tree within adaptive radius\n            connect_radius = self.step_size * 3.2\n            conn_node, conn_cost = try_connect(new_node, tree_b, connect_radius)\n            if conn_node and conn_cost < best_cost:\n                best_cost = conn_cost\n                best_connection = (new_node, conn_node)\n                success = True\n                # Early stop for improved path\n                break\n\n            # Periodically shortcut best path if improvement found\n            if success and it % 120 == 0 and best_connection:\n                path = extract_path(best_connection[0], best_connection[1])\n                shortcut = shortcut_path(path)\n                new_length = sum(dist(shortcut[i], shortcut[i+1]) for i in range(len(shortcut)-1))\n                if new_length + 1e-5 < best_cost:\n                    best_cost = new_length\n                    extracted_path = shortcut\n                else:\n                    extracted_path = path\n\n        if success and best_connection:\n            extracted_path = extract_path(best_connection[0], best_connection[1])\n            extracted_path = shortcut_path(extracted_path)\n        else:\n            # Fallback: find best cross-tree pair and shortcut fallback path\n            best_pair = None\n            min_total_cost = float('inf')\n            for n1 in start_tree:\n                near_goal_cands = near(goal_tree, n1.position, self.step_size * 3.2)\n                for n2 in near_goal_cands:\n                    d12 = dist(n1.position, n2.position)\n                    if d12 <= self.step_size * 3.2 and not self._is_edge_in_obstacle(n1.position, n2.position, obstacles, is_3d):\n                        total_c = n1.cost + n2.cost + d12\n                        if total_c < min_total_cost:\n                            min_total_cost = total_c\n                            best_pair = (n1, n2)\n            if best_pair:\n                extracted_path = extract_path(best_pair[0], best_pair[1])\n                extracted_path = shortcut_path(extracted_path)\n                success = True\n\n        return PlannerResult(\n            success=success,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -27.40187,
          "time_improvement": 38.0,
          "length_improvement": 16.0,
          "smoothness_improvement": 1257.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.02119297981262207,
                    "num_nodes_avg": 152.1,
                    "path_length_avg": 163.87341701691048,
                    "smoothness_avg": 0.04087808433626587,
                    "success_improvement": 0.0,
                    "time_improvement": 15.313931742246611,
                    "length_improvement": 10.17838339256568,
                    "smoothness_improvement": 539.830788043481,
                    "objective_score": 13.400363498430796
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.057435345649719236,
                    "num_nodes_avg": 355.1,
                    "path_length_avg": 241.9364752247091,
                    "smoothness_avg": 0.07969677886958462,
                    "success_improvement": 0.0,
                    "time_improvement": 64.87440590095132,
                    "length_improvement": 19.23464081466865,
                    "smoothness_improvement": 1950.6555235839744,
                    "objective_score": 40.756383877006456
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.03343057632446289,
                    "num_nodes_avg": 235.3,
                    "path_length_avg": 120.76782331760107,
                    "smoothness_avg": 0.10863055365717608,
                    "success_improvement": 0.0,
                    "time_improvement": 32.549818696791185,
                    "length_improvement": 19.79176209821548,
                    "smoothness_improvement": 1281.7726242458787,
                    "objective_score": 28.048865989196038
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "time_expert",
          "algorithm_description": "A bidirectional RRT* planner with adaptive neighborhood radius, efficient rewiring, and early stopping to minimize planning time and improve path quality. It grows two trees from start and goal by sampling free space, steering towards samples with fixed step size, and rewiring a shrinking neighborhood for path cost optimization. The planner attempts tree connection after each extension and returns the best path found within a 30-second limit.",
          "planning_mechanism": "A bidirectional RRT* planner alternates growing two trees by sampling, nearest node selection, steering, collision checks, and cost-based rewiring within an adaptively shrinking radius. It tries connecting the two trees whenever a new node is added, stopping early on the first improved connection. The adaptive radius balances exploration and efficient rewiring, reducing overhead and improving solution quality over time.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n        import time\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = start_tree[:] + goal_tree[:]\n        edges = []\n\n        success = False\n        best_cost = float('inf')\n        best_connect = None\n\n        start_time = time.monotonic()\n        TIME_LIMIT = 30.0\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def sample_free():\n            for _ in range(30):\n                p = tuple(random.uniform(0, bounds[i]) for i in range(len(bounds)))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n            # fallback: return start or goal to prevent infinite loop (rare)\n            return start_pos\n\n        def nearest(tree, point):\n            # Linear search; for improvement, can be replaced with spatial index\n            best_node = None\n            best_dist = float('inf')\n            for n in tree:\n                d = dist(n.position, point)\n                if d < best_dist:\n                    best_dist = d\n                    best_node = n\n            return best_node\n\n        def near(tree, point, radius):\n            r_sq = radius * radius\n            return [n for n in tree if (n.position[0] - point[0]) ** 2 + (n.position[1] - point[1]) ** 2 <= r_sq] if not is_3d else \\\n                   [n for n in tree if sum((n.position[i] - point[i]) ** 2 for i in range(3)) <= r_sq]\n\n        def steer(from_p, to_p, step):\n            d = dist(from_p, to_p)\n            if d <= step:\n                return to_p\n            ratio = step / d\n            return tuple(from_p[i] + (to_p[i] - from_p[i]) * ratio for i in range(len(from_p)))\n\n        def extract_path(n_start, n_goal):\n            path_start = []\n            curr = n_start\n            while curr is not None:\n                path_start.append(curr.position)\n                curr = curr.parent\n            path_goal = []\n            curr = n_goal\n            while curr is not None:\n                path_goal.append(curr.position)\n                curr = curr.parent\n            # Reverse start path and append goal path (connecting at the connecting edge)\n            return path_start[::-1] + path_goal\n\n        def cost_to_reach(node):\n            return node.cost\n\n        def try_rewire(new_node, neighbors, tree, obstacles, is_3d):\n            changed = False\n            for near_node in neighbors:\n                if near_node is new_node.parent:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, near_node.position)\n                if new_cost + 1e-9 < near_node.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                        # Rewire near_node\n                        if near_node.parent:\n                            try:\n                                edges.remove((near_node.parent, near_node))\n                            except ValueError:\n                                pass\n                            if near_node in near_node.parent.children:\n                                near_node.parent.children.remove(near_node)\n                        near_node.parent = new_node\n                        near_node.cost = new_cost\n                        new_node.add_child(near_node)\n                        edges.append((new_node, near_node))\n                        changed = True\n            return changed\n\n        def add_node(tree, new_node):\n            tree.append(new_node)\n            nodes.append(new_node)\n\n        gamma = 30.0\n        dim = len(bounds)\n\n        for iter_count in range(self.max_iter):\n            now = time.monotonic()\n            if now - start_time > TIME_LIMIT:\n                break\n\n            # Alternate tree growth\n            tree_a = start_tree if iter_count % 2 == 0 else goal_tree\n            tree_b = goal_tree if iter_count % 2 == 0 else start_tree\n\n            rnd = sample_free()\n\n            nearest_node = nearest(tree_a, rnd)\n            new_pos = steer(nearest_node.position, rnd, self.step_size)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            n_nodes = len(tree_a) + 1\n            radius = min(self.step_size * 5, gamma * (math.log(max(n_nodes, 2)) / n_nodes) ** (1 / dim))\n\n            near_nodes = near(tree_a, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            min_parent = nearest_node\n            for near_node in near_nodes:\n                cost_through = near_node.cost + dist(near_node.position, new_pos)\n                if cost_through + 1e-9 < min_cost:\n                    if not self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d):\n                        min_cost = cost_through\n                        min_parent = near_node\n\n            new_node = Node(new_pos, parent=min_parent, cost=min_cost)\n            min_parent.add_child(new_node)\n            add_node(tree_a, new_node)\n            edges.append((min_parent, new_node))\n\n            try_rewire(new_node, near_nodes, tree_a, obstacles, is_3d)\n\n            # Try connecting other tree near new_node\n            nearest_in_other = nearest(tree_b, new_node.position)\n            dist_connect = dist(new_node.position, nearest_in_other.position)\n            if dist_connect <= self.step_size:\n                if not self._is_edge_in_obstacle(new_node.position, nearest_in_other.position, obstacles, is_3d):\n                    total_cost = new_node.cost + nearest_in_other.cost + dist_connect\n                    if total_cost + 1e-9 < best_cost:\n                        best_cost = total_cost\n                        best_connect = (new_node, nearest_in_other)\n                        success = True\n                        # Early stop on first good solution to reduce planning time\n                        break\n\n        # Extract best path if found\n        if success and best_connect is not None:\n            extracted_path = extract_path(best_connect[0], best_connect[1])\n        else:\n            # No direct connection found in time, try minimal-cost pair and path extraction\n            min_cost_est = float('inf')\n            best_pair = None\n            for n1 in start_tree:\n                n2 = nearest(goal_tree, n1.position)\n                d12 = dist(n1.position, n2.position)\n                if d12 <= self.step_size:\n                    if not self._is_edge_in_obstacle(n1.position, n2.position, obstacles, is_3d):\n                        cost_sum = n1.cost + n2.cost + d12\n                        if cost_sum + 1e-9 < min_cost_est:\n                            min_cost_est = cost_sum\n                            best_pair = (n1, n2)\n            if best_pair is not None:\n                extracted_path = extract_path(best_pair[0], best_pair[1])\n                success = True\n            else:\n                extracted_path = []\n\n        return PlannerResult(\n            success=success,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -27.32825,
          "time_improvement": 72.0,
          "length_improvement": 8.0,
          "smoothness_improvement": 142.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.011930179595947266,
                    "num_nodes_avg": 135.2,
                    "path_length_avg": 171.34059103033889,
                    "smoothness_avg": 0.01642005874301497,
                    "success_improvement": 0.0,
                    "time_improvement": 52.327609778218985,
                    "length_improvement": 6.085506990861369,
                    "smoothness_improvement": 157.00957605645047,
                    "objective_score": 20.13463500826477
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.01886107921600342,
                    "num_nodes_avg": 282.1,
                    "path_length_avg": 270.38122584620703,
                    "smoothness_avg": 0.008398311675666579,
                    "success_improvement": 0.0,
                    "time_improvement": 88.4651758369878,
                    "length_improvement": 9.738964320462099,
                    "smoothness_improvement": 116.09460847429625,
                    "objective_score": 32.96340438574508
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.012389254570007325,
                    "num_nodes_avg": 219.8,
                    "path_length_avg": 136.44974335966273,
                    "smoothness_avg": 0.019808586046500164,
                    "success_improvement": 0.0,
                    "time_improvement": 75.00319890246378,
                    "length_improvement": 9.376577499064672,
                    "smoothness_improvement": 151.9637523937513,
                    "objective_score": 28.88672493214669
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "A simplified bidirectional RRT planner with uniform random sampling, fixed step size, and a constant radius rewiring to locally optimize path cost. The planner grows two trees alternately from start and goal, selecting nearest nodes, steering stepwise toward random free samples, and rewiring neighbors within a fixed radius. Connection attempts between trees are performed each iteration, and the shortest combined path found is returned. No goal biasing, shortcutting, or adaptive radius is used, favoring simplicity and easier generalization. Planning halts after 30 seconds or a valid path is found.",
          "planning_mechanism": "The planner alternately expands start and goal trees by sampling uniformly, extends the nearest node toward samples by a fixed step, rewires neighbor nodes within a fixed radius for cost improvement, attempts to connect the two trees when segments are close, and extracts the shortest feasible path found. Early termination occurs on any valid connection or time limit.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.time_limit = 30.0\n        self.rewire_radius = 15.0\n\n    def plan(self, map) -> 'PlannerResult':\n        import time\n        import math\n        import random\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def sample_free():\n            for _ in range(30):\n                pt = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not self._is_in_obstacle(pt, obstacles, is_3d):\n                    return pt\n            return goal_pos\n\n        def nearest(tree, point):\n            best = None\n            best_dist = float('inf')\n            for node in tree:\n                d = dist(node.position, point)\n                if d < best_dist:\n                    best_dist = d\n                    best = node\n            return best\n\n        def near(tree, point, radius):\n            r2 = radius * radius\n            neighbors = []\n            for node in tree:\n                d2 = 0.0\n                for i in range(dim):\n                    diff = node.position[i] - point[i]\n                    d2 += diff * diff\n                    if d2 > r2:\n                        break\n                if d2 <= r2:\n                    neighbors.append(node)\n            return neighbors\n\n        def steer(frm, to, max_step):\n            d = dist(frm, to)\n            if d <= max_step:\n                return to\n            ratio = max_step / d\n            return tuple(frm[i] + (to[i]-frm[i])*ratio for i in range(dim))\n\n        def extract_path(node_start, node_goal):\n            path_start = []\n            cur = node_start\n            while cur:\n                path_start.append(cur.position)\n                cur = cur.parent\n            path_start.reverse()\n            path_goal = []\n            cur = node_goal\n            while cur:\n                path_goal.append(cur.position)\n                cur = cur.parent\n            if path_start and path_goal and path_start[-1] == path_goal[0]:\n                path_goal = path_goal[1:]\n            return path_start + path_goal\n\n        start_tree = [Node(start_pos, cost=0.0)]\n        goal_tree = [Node(goal_pos, cost=0.0)]\n        nodes = start_tree[:] + goal_tree[:]\n        edges = []\n\n        start_time = time.monotonic()\n        success = False\n        best_connection = None\n        best_cost = float('inf')\n\n        for it in range(self.max_iter):\n            if time.monotonic() - start_time > self.time_limit:\n                break\n\n            tree_a = start_tree if it % 2 == 0 else goal_tree\n            tree_b = goal_tree if it % 2 == 0 else start_tree\n\n            sample = sample_free()\n            nearest_node = nearest(tree_a, sample)\n            if nearest_node is None:\n                continue\n            new_pos = steer(nearest_node.position, sample, self.step_size)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d, resolution=1.0):\n                continue\n\n            neighbors = near(tree_a, new_pos, self.rewire_radius)\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            min_parent = nearest_node\n            for nb in neighbors:\n                cost_candidate = nb.cost + dist(nb.position, new_pos)\n                if cost_candidate < min_cost:\n                    if not self._is_edge_in_obstacle(nb.position, new_pos, obstacles, is_3d, resolution=1.0):\n                        min_cost = cost_candidate\n                        min_parent = nb\n\n            new_node = Node(new_pos, parent=min_parent, cost=min_cost)\n            min_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((min_parent, new_node))\n\n            for nb in neighbors:\n                if nb == new_node.parent:\n                    continue\n                cost_through_new = new_node.cost + dist(new_node.position, nb.position)\n                if cost_through_new < nb.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, nb.position, obstacles, is_3d, resolution=1.0):\n                        if nb.parent:\n                            try:\n                                edges.remove((nb.parent, nb))\n                            except ValueError:\n                                pass\n                            if nb in nb.parent.children:\n                                nb.parent.children.remove(nb)\n                        nb.parent = new_node\n                        nb.cost = cost_through_new\n                        new_node.add_child(nb)\n                        edges.append((new_node, nb))\n\n            # Try connecting to the other tree\n            for node_b in tree_b:\n                d_connect = dist(new_node.position, node_b.position)\n                if d_connect <= self.step_size:\n                    if not self._is_edge_in_obstacle(new_node.position, node_b.position, obstacles, is_3d, resolution=1.0):\n                        total_cost = new_node.cost + d_connect + node_b.cost\n                        if total_cost < best_cost:\n                            best_cost = total_cost\n                            best_connection = (new_node, node_b)\n                            success = True\n                            break\n            if success:\n                break\n\n        if success and best_connection is not None:\n            extracted_path = extract_path(best_connection[0], best_connection[1])\n        else:\n            extracted_path = []\n\n        return PlannerResult(success, extracted_path, nodes, edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -27.27263,
          "time_improvement": 54.0,
          "length_improvement": 16.0,
          "smoothness_improvement": 318.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.01560060977935791,
                    "num_nodes_avg": 127.3,
                    "path_length_avg": 162.7051855336661,
                    "smoothness_avg": 0.024214300360785524,
                    "success_improvement": 0.0,
                    "time_improvement": 38.1778276635507,
                    "length_improvement": 10.818709580344397,
                    "smoothness_improvement": 279.00638284113415,
                    "objective_score": 19.33960596147752
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.021555614471435548,
                    "num_nodes_avg": 250.1,
                    "path_length_avg": 246.71915989591085,
                    "smoothness_avg": 0.01699784699404939,
                    "success_improvement": 0.0,
                    "time_improvement": 86.85157580455399,
                    "length_improvement": 17.638043009476124,
                    "smoothness_improvement": 337.36684621121265,
                    "objective_score": 38.32513277810793
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.03135390281677246,
                    "num_nodes_avg": 296.6,
                    "path_length_avg": 121.57636962108047,
                    "smoothness_avg": 0.03451721522989071,
                    "success_improvement": 0.0,
                    "time_improvement": 36.35001831945943,
                    "length_improvement": 19.254764142282024,
                    "smoothness_improvement": 339.05642992840615,
                    "objective_score": 24.15314613084907
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "path_expert",
          "algorithm_description": "An improved bidirectional RRT* planner with adaptive neighborhood radius, refined goal bias sampling, enhanced rewiring with cost-aware parent updates, multiple candidate connections to the opposite tree per iteration, and incremental path shortcutting to simultaneously optimize planning time, path length, and smoothness under a hard 30-second limit. It alternates tree expansions, uses logarithmic scaling for neighborhood radius, performs early stopping after improvements, and returns the best path found so far.",
          "planning_mechanism": "A bidirectional RRT* algorithm grows two trees from start and goal, alternately sampling the space with goal bias. It adaptively determines the rewiring radius based on current tree size and problem dimension, selects parents minimizing cost, and rewires neighbors to lower-cost paths. Multiple candidate connections between trees accelerate discovering feasible paths. Periodic incremental shortcutting refines the path's length and smoothness steadily. Execution halts upon timeout or after a new best path, returning the best-found solution.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\nclass Planner:\n    def __init__(self, max_iter: int = 6000, step_size: float = 4.0, goal_sample_rate: float = 0.18):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.time_limit = 30.0\n\n    def plan(self, map):\n        import time\n        import math\n        import random\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        # Parameters tuned for balanced performance\n        gamma_rrt_star = 35.0\n        min_radius = self.step_size * 1.5\n        shortcut_interval = 100\n        shortcut_attempts_per_cycle = 40\n        shortcut_check_resolution = self.step_size * 0.2\n        connect_radius_coeff = 3.0\n\n        start_tree = [Node(start_pos, cost=0.0)]\n        goal_tree = [Node(goal_pos, cost=0.0)]\n        nodes = start_tree[:] + goal_tree[:]\n        edges = []\n\n        best_connection = None\n        best_cost = float('inf')\n        found_improvement = False\n        success = False\n\n        time_start = time.monotonic()\n\n        def dist(p1, p2):\n            return math.dist(p1, p2)\n\n        def sample_free():\n            if random.random() < self.goal_sample_rate:\n                return goal_pos\n            for _ in range(30):\n                pt = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not self._is_in_obstacle(pt, obstacles, is_3d):\n                    return pt\n            return goal_pos  # fallback\n\n        def nearest(tree, point):\n            best_node = None\n            min_dist = float('inf')\n            for n in tree:\n                d = dist(n.position, point)\n                if d < min_dist:\n                    best_node = n\n                    min_dist = d\n            return best_node\n\n        def near(tree, point, radius):\n            r_sq = radius * radius\n            neighbors = []\n            for n in tree:\n                d_sq = 0.0\n                for i in range(dim):\n                    dx = n.position[i] - point[i]\n                    d_sq += dx*dx\n                    if d_sq > r_sq:\n                        break\n                else:\n                    neighbors.append((d_sq, n))\n            neighbors.sort(key=lambda x: x[0])\n            return [n for (_, n) in neighbors]\n\n        def steer(from_p, to_p, max_step):\n            d = dist(from_p, to_p)\n            if d <= max_step:\n                return to_p\n            ratio = max_step / d\n            return tuple(from_p[i] + (to_p[i] - from_p[i]) * ratio for i in range(dim))\n\n        def extract_path(n_start, n_goal):\n            path_start = []\n            node = n_start\n            while node:\n                path_start.append(node.position)\n                node = node.parent\n            path_goal = []\n            node = n_goal\n            while node:\n                path_goal.append(node.position)\n                node = node.parent\n            return path_start[::-1] + path_goal\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            attempts = 0\n            path_changed = True\n            while attempts < shortcut_attempts_per_cycle and path_changed:\n                path_changed = False\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution=shortcut_check_resolution):\n                    path = path[:i+1] + path[j:]\n                    path_changed = True\n                attempts += 1\n            return path\n\n        def try_connect(node, other_tree, radius):\n            candidates = near(other_tree, node.position, radius)\n            optimal_node = None\n            min_connection_cost = float('inf')\n            for cnode in candidates:\n                d = dist(node.position, cnode.position)\n                if d > radius:\n                    continue\n                if self._is_edge_in_obstacle(node.position, cnode.position, obstacles, is_3d):\n                    continue\n                total_cost = node.cost + cnode.cost + d\n                if total_cost < min_connection_cost:\n                    min_connection_cost = total_cost\n                    optimal_node = cnode\n            return optimal_node, min_connection_cost\n\n        def rewire(tree, new_node, near_nodes, radius):\n            for near_node in near_nodes:\n                if near_node is new_node.parent:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, near_node.position)\n                if new_cost + 1e-8 < near_node.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                        # Remove old parent child relation\n                        if near_node.parent:\n                            try:\n                                edges.remove((near_node.parent, near_node))\n                            except ValueError:\n                                pass\n                            near_node.parent.remove_child(near_node)\n                        # Reassign parent\n                        near_node.parent = new_node\n                        near_node.cost = new_cost\n                        new_node.add_child(near_node)\n                        edges.append((new_node, near_node))\n\n        for iter_num in range(self.max_iter):\n            elapsed = time.monotonic() - time_start\n            if elapsed > self.time_limit:\n                break\n\n            if iter_num % 2 == 0:\n                tree_a, tree_b = start_tree, goal_tree\n            else:\n                tree_a, tree_b = goal_tree, start_tree\n\n            sample = sample_free()\n            near_radius = max(min_radius, \n                              gamma_rrt_star * ((math.log(len(tree_a) + 1) / (len(tree_a) + 1)) ** (1.0 / dim)))\n            near_radius = min(near_radius, self.step_size*5.5)\n\n            nearest_node = nearest(tree_a, sample)\n            new_pos = steer(nearest_node.position, sample, self.step_size)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            near_nodes = near(tree_a, new_pos, near_radius)\n\n            # Choose parent with minimal cost + distance, check collision\n            parent_node = nearest_node\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            for near_node in near_nodes:\n                if near_node == nearest_node:\n                    continue\n                cost_candidate = near_node.cost + dist(near_node.position, new_pos)\n                if cost_candidate + 1e-10 < min_cost:\n                    if not self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d):\n                        min_cost = cost_candidate\n                        parent_node = near_node\n\n            new_node = Node(new_pos, parent=parent_node, cost=min_cost)\n            parent_node.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((parent_node, new_node))\n\n            # Rewire neighbors to new_node if beneficial\n            rewire(tree_a, new_node, near_nodes, near_radius)\n\n            # Attempt multiple candidate connections to opposite tree within radius\n            connect_radius = self.step_size * connect_radius_coeff\n            connected_node, connection_cost = try_connect(new_node, tree_b, connect_radius)\n            if connected_node and connection_cost + 1e-9 < best_cost:\n                best_cost = connection_cost\n                best_connection = (new_node, connected_node)\n                success = True\n                found_improvement = True\n                # Early stopping on improvement\n                break\n\n            # Periodically refine best path found so far via shortcutting to improve smoothness and length\n            if found_improvement and (iter_num % shortcut_interval == 0) and best_connection is not None:\n                raw_path = extract_path(best_connection[0], best_connection[1])\n                refined_path = shortcut_path(raw_path)\n                raw_len = 0.0\n                refined_len = 0.0\n                for i in range(len(raw_path)-1):\n                    raw_len += dist(raw_path[i], raw_path[i+1])\n                for i in range(len(refined_path)-1):\n                    refined_len += dist(refined_path[i], refined_path[i+1])\n                if refined_len + 1e-6 < raw_len:\n                    extracted_path = refined_path\n                    best_cost = refined_len\n                else:\n                    extracted_path = raw_path\n\n        # If no direct connection found during search, try to connect closest pair across trees\n        if (not success) or (best_connection is None):\n            min_pair_cost = float('inf')\n            candidate_pair = None\n            for n_s in start_tree:\n                near_goal_nodes = near(goal_tree, n_s.position, self.step_size*connect_radius_coeff)\n                for n_g in near_goal_nodes:\n                    d = dist(n_s.position, n_g.position)\n                    if d <= self.step_size*connect_radius_coeff and not self._is_edge_in_obstacle(n_s.position, n_g.position, obstacles, is_3d):\n                        total_c = n_s.cost + n_g.cost + d\n                        if total_c < min_pair_cost:\n                            min_pair_cost = total_c\n                            candidate_pair = (n_s, n_g)\n            if candidate_pair:\n                best_connection = candidate_pair\n                best_cost = min_pair_cost\n                success = True\n                # Extract and shortcut path\n                path_raw = extract_path(best_connection[0], best_connection[1])\n                extracted_path = shortcut_path(path_raw)\n            else:\n                extracted_path = []\n\n        else:\n            # Final path extraction with shortcutting\n            extracted_path = shortcut_path(extract_path(best_connection[0], best_connection[1]))\n\n        return {\n            \"success\": success,\n            \"path\": extracted_path,\n            \"nodes\": nodes,\n            \"edges\": edges\n        }\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -26.9049,
          "time_improvement": 62.0,
          "length_improvement": 12.0,
          "smoothness_improvement": 193.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.011151480674743652,
                    "num_nodes_avg": 123.3,
                    "path_length_avg": 155.62788784629282,
                    "smoothness_avg": 0.0219086980671148,
                    "success_improvement": 0.0,
                    "time_improvement": 55.8088581259956,
                    "length_improvement": 14.697888589752168,
                    "smoothness_improvement": 242.91870024967164,
                    "objective_score": 26.77598409289834
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.046439528465270996,
                    "num_nodes_avg": 426.2,
                    "path_length_avg": 263.7970318009044,
                    "smoothness_avg": 0.009124090278487504,
                    "success_improvement": 0.0,
                    "time_improvement": 71.67296620066112,
                    "length_improvement": 11.93695780830174,
                    "smoothness_improvement": 134.76941468207625,
                    "objective_score": 29.33791161858976
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.020896553993225098,
                    "num_nodes_avg": 257.1,
                    "path_length_avg": 134.70422924216743,
                    "smoothness_avg": 0.02367285330263675,
                    "success_improvement": 0.0,
                    "time_improvement": 57.578956386134514,
                    "length_improvement": 10.535864863454735,
                    "smoothness_improvement": 201.1169466612698,
                    "objective_score": 24.600790567219544
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "path_expert",
          "algorithm_description": "An adaptive bidirectional RRT* planner employing logarithmic neighborhood radius adjustment, enhanced rewiring with recursive cost propagation, incremental multi-candidate tree connection, and periodic aggressive shortcutting for minimal path length and high smoothness within strict 30-second time constraints. The algorithm alternately expands the start and goal trees, efficiently samples with dynamic goal bias, performs cost-based rewiring with descendant update, attempts multiple connection candidates each iteration with early stopping on improvement, and continuously shortcuts the best path to reduce length and smoothness.",
          "planning_mechanism": "The planner grows two trees from start and goal alternatingly, sampling states in free space with adaptive goal bias, steering incrementally up to step_size toward samples, connecting using rewiring within an adaptive radius scaling with the number of nodes and dimension (log(n)/n)^(1/d), recursively updating subtree costs after rewiring, tries to connect trees with multiple candidate pairs each iteration, applies path shortcutting periodically during planning, and halts when time limit or max iterations reached, always returning the best path found for minimized length and smoothness.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\nclass Planner:\n    def __init__(self, max_iter: int = 6000, step_size: float = 5.0, goal_sample_rate: float = 0.15):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.time_limit = 30.0\n\n    def plan(self, map):\n        import time\n        import math\n        import random\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = dim == 3\n\n        start_time = time.monotonic()\n\n        start_tree = [Node(start_pos, cost=0.0)]\n        goal_tree = [Node(goal_pos, cost=0.0)]\n        nodes = start_tree[:] + goal_tree[:]\n        edges = []\n\n        best_cost = float('inf')\n        best_connection = None\n        success = False\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def sample_free():\n            for _ in range(20):\n                if random.random() < self.goal_sample_rate:\n                    return goal_pos\n                p = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n            return goal_pos\n\n        def nearest(tree, point):\n            best_node = None\n            best_dist = float('inf')\n            for node in tree:\n                d = dist(node.position, point)\n                if d < best_dist:\n                    best_node = node\n                    best_dist = d\n            return best_node\n\n        def near(tree, point, radius):\n            radius_sq = radius * radius\n            neighbors = []\n            for node in tree:\n                d_sq = 0.0\n                for i in range(dim):\n                    diff = node.position[i] - point[i]\n                    d_sq += diff * diff\n                    if d_sq > radius_sq:\n                        break\n                if d_sq <= radius_sq:\n                    neighbors.append((d_sq, node))\n            neighbors.sort(key=lambda x: x[0])\n            return [n[1] for n in neighbors]\n\n        def steer(from_p, to_p, max_step):\n            d = dist(from_p, to_p)\n            if d <= max_step:\n                return to_p\n            ratio = max_step / d\n            return tuple(from_p[i] + (to_p[i] - from_p[i]) * ratio for i in range(dim))\n\n        def extract_path(node_start, node_goal):\n            path_start = []\n            cur = node_start\n            while cur is not None:\n                path_start.append(cur.position)\n                cur = cur.parent\n            path_goal = []\n            cur = node_goal\n            while cur is not None:\n                path_goal.append(cur.position)\n                cur = cur.parent\n            # Avoid duplicate node at connection\n            return path_start[::-1] + path_goal\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            max_attempts = 120\n            for _ in range(max_attempts):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution=0.5):\n                    # Remove intermediate points i+1 to j-1\n                    path = path[:i+1] + path[j:]\n            return path\n\n        def update_subtree_costs(node):\n            for c in node.children:\n                old_cost = c.cost\n                c.cost = node.cost + dist(node.position, c.position)\n                if abs(c.cost - old_cost) > 1e-10 and c.children:\n                    update_subtree_costs(c)\n\n        def try_connect(node, other_tree, radius):\n            candidates = near(other_tree, node.position, radius)\n            best_cnode = None\n            best_total_cost = float('inf')\n            for cnode in candidates:\n                d = dist(node.position, cnode.position)\n                if d <= radius and not self._is_edge_in_obstacle(node.position, cnode.position, obstacles, is_3d, resolution=0.5):\n                    total_cost = node.cost + d + cnode.cost\n                    if total_cost < best_total_cost:\n                        best_total_cost = total_cost\n                        best_cnode = cnode\n            return best_cnode, best_total_cost\n\n        for it in range(self.max_iter):\n            current_time = time.monotonic()\n            if current_time - start_time > self.time_limit:\n                break\n\n            expand_start_tree = (it % 2 == 0)\n            tree_a, tree_b = (start_tree, goal_tree) if expand_start_tree else (goal_tree, start_tree)\n\n            sample = sample_free()\n            nearest_node = nearest(tree_a, sample)\n            new_pos = steer(nearest_node.position, sample, self.step_size)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d): \n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d, resolution=0.5):\n                continue\n\n            n_nodes = len(tree_a) + 1\n            radius = min(self.step_size * 4.0, 20.0 * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim)))\n            if radius < self.step_size * 1.5:\n                radius = self.step_size * 1.5\n\n            near_nodes = near(tree_a, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            min_parent = nearest_node\n            for near_node in near_nodes:\n                edge_dist = dist(near_node.position, new_pos)\n                cost_through = near_node.cost + edge_dist\n                if cost_through < min_cost:\n                    if not self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d, resolution=0.5):\n                        min_cost = cost_through\n                        min_parent = near_node\n\n            new_node = Node(new_pos, parent=min_parent, cost=min_cost)\n            min_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((min_parent, new_node))\n\n            # Rewire nearby nodes if cheaper\n            for near_node in near_nodes:\n                if near_node is min_parent:\n                    continue\n                edge_dist = dist(new_node.position, near_node.position)\n                new_cost = new_node.cost + edge_dist\n                if new_cost + 1e-8 < near_node.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d, resolution=0.5):\n                        if near_node.parent:\n                            try:\n                                edges.remove((near_node.parent, near_node))\n                            except ValueError:\n                                pass\n                            near_node.parent.remove_child(near_node)\n                        near_node.parent = new_node\n                        near_node.cost = new_cost\n                        new_node.add_child(near_node)\n                        edges.append((new_node, near_node))\n                        # Update subtree costs recursively\n                        if near_node.children:\n                            update_subtree_costs(near_node)\n\n            # Try to connect to the other tree with multiple candidates\n            connect_radius = self.step_size * 3.5\n            candidate, total_cost = try_connect(new_node, tree_b, connect_radius)\n            if candidate is not None and total_cost + 1e-8 < best_cost:\n                best_cost = total_cost\n                best_connection = (new_node, candidate)\n                success = True\n                # Early stop on improved path\n                break\n\n            # Periodic shortcutting after successful connection\n            if success and (it % 100 == 0) and best_connection is not None:\n                path = extract_path(best_connection[0], best_connection[1])\n                shortcut = shortcut_path(path)\n                shortcut_len = sum(dist(shortcut[i], shortcut[i+1]) for i in range(len(shortcut)-1))\n                if shortcut_len + 1e-8 < best_cost:\n                    best_cost = shortcut_len\n                    extracted_path = shortcut\n                else:\n                    extracted_path = path\n\n        if success and best_connection is not None:\n            path = extract_path(best_connection[0], best_connection[1])\n            extracted_path = shortcut_path(path)\n        else:\n            # If no direct connection, try best approximate connection\n            best_pair = None\n            min_cost = float('inf')\n            for n1 in start_tree:\n                close_nodes = near(goal_tree, n1.position, self.step_size * 3.5)\n                for n2 in close_nodes:\n                    d = dist(n1.position, n2.position)\n                    if d <= self.step_size * 3.5 and not self._is_edge_in_obstacle(n1.position, n2.position, obstacles, is_3d, resolution=0.5):\n                        c = n1.cost + n2.cost + d\n                        if c < min_cost:\n                            min_cost = c\n                            best_pair = (n1, n2)\n            if best_pair is not None:\n                path = extract_path(best_pair[0], best_pair[1])\n                extracted_path = shortcut_path(path)\n                success = True\n            else:\n                extracted_path = []\n\n        return PlannerResult(\n            success=success,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -26.69522,
          "time_improvement": 33.0,
          "length_improvement": 15.0,
          "smoothness_improvement": 1524.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.025310325622558593,
                    "num_nodes_avg": 149.6,
                    "path_length_avg": 168.92360461721657,
                    "smoothness_avg": 0.042959197175055044,
                    "success_improvement": 0.0,
                    "time_improvement": -0.299881521289315,
                    "length_improvement": 7.41029554349433,
                    "smoothness_improvement": 572.4047231793935,
                    "objective_score": 7.218236485606772
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.04148766994476318,
                    "num_nodes_avg": 314.0,
                    "path_length_avg": 238.10811852826797,
                    "smoothness_avg": 0.10945117992607334,
                    "success_improvement": 0.0,
                    "time_improvement": 74.69348489057136,
                    "length_improvement": 20.51265647307839,
                    "smoothness_improvement": 2716.2576939962532,
                    "objective_score": 48.296927820999706
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.03673982620239258,
                    "num_nodes_avg": 259.7,
                    "path_length_avg": 124.14177221061985,
                    "smoothness_avg": 0.10872741664177799,
                    "success_improvement": 0.0,
                    "time_improvement": 25.416326050561704,
                    "length_improvement": 17.55094589365388,
                    "smoothness_improvement": 1283.0047142603332,
                    "objective_score": 24.570488922662506
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "initial",
          "algorithm_description": "This algorithm grows two trees simultaneously, one from the start position and one from the goal position, and attempts to connect them to find a feasible path. This bidirectional approach accelerates convergence and increases the success rate compared to a single tree RRT.",
          "planning_mechanism": "The planning mechanism involves randomly sampling points within the map bounds, extending each tree towards the sampled points, and attempting to connect the two trees whenever new nodes are added. Collision checks are performed for nodes and edges to ensure safety, and once the two trees connect, the final path is reconstructed by backtracking through the parent nodes of each tree.",
          "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map) -> PlannerResult:\n        import math, random\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position)\n        goal_root = Node(goal_position)\n        nodes.extend([start_root, goal_root])\n        tree_a, tree_b = [start_root], [goal_root]\n\n        for _ in range(self.max_iter):\n            rand_point = self._sample_free(bounds, obstacles, is_3d)\n            new_a = self._extend_tree(tree_a, rand_point, obstacles, is_3d, nodes, edges)\n            if new_a is None:\n                continue\n\n            new_b = self._connect_trees(tree_b, new_a, obstacles, is_3d, nodes, edges)\n            if new_b:\n                success_state = True\n                path_a = new_a.path_from_root()\n                path_b = new_b.path_from_root()\n                extracted_path = path_a + path_b[::-1]\n                break\n\n            tree_a, tree_b = tree_b, tree_a  # Swap trees\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        import random\n        while True:\n            if is_3d:\n                p = (random.uniform(0, bounds[0]),\n                     random.uniform(0, bounds[1]),\n                     random.uniform(0, bounds[2]))\n            else:\n                p = (random.uniform(0, bounds[0]),\n                     random.uniform(0, bounds[1]))\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    def _nearest(self, tree, point):\n        import math\n        return min(tree, key=lambda node: math.dist(node.position, point))\n\n    def _steer(self, from_pos, to_pos):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _extend_tree(self, tree, point, obstacles, is_3d, nodes, edges):\n        nearest_node = self._nearest(tree, point)\n        new_pos = self._steer(nearest_node.position, point)\n        if not self._is_in_obstacle(new_pos, obstacles, is_3d) and not self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n            new_node = Node(new_pos, parent=nearest_node)\n            nearest_node.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n            return new_node\n        return None\n\n    def _connect_trees(self, tree, new_node, obstacles, is_3d, nodes, edges):\n        import math\n        nearest_node = self._nearest(tree, new_node.position)\n        while True:\n            new_pos = self._steer(nearest_node.position, new_node.position)\n            if (not self._is_in_obstacle(new_pos, obstacles, is_3d) and\n                not self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d)):\n                next_node = Node(new_pos, parent=nearest_node)\n                nearest_node.add_child(next_node)\n                tree.append(next_node)\n                nodes.append(next_node)\n                edges.append((nearest_node, next_node))\n\n                if math.dist(next_node.position, new_node.position) <= self.step_size:\n                    if not self._is_edge_in_obstacle(next_node.position, new_node.position, obstacles, is_3d):\n                        final_node = Node(new_node.position, parent=next_node)\n                        next_node.add_child(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((next_node, final_node))\n                        return final_node\n                    else:\n                        return None\n                nearest_node = next_node\n            else:\n                return None\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n",
          "objective": -26.578979600033247,
          "time_improvement": 90.0,
          "length_improvement": -1.0,
          "smoothness_improvement": 67.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.0023192644119262697,
                    "num_nodes_avg": 60.1,
                    "path_length_avg": 170.9770888905735,
                    "smoothness_avg": 0.011275125135943505,
                    "success_improvement": 0.0,
                    "time_improvement": 90.73233749889248,
                    "length_improvement": 6.284748273726786,
                    "smoothness_improvement": 76.48019270363378,
                    "objective_score": 31.372951177421985
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.008306598663330078,
                    "num_nodes_avg": 214.3,
                    "path_length_avg": 300.2930706351261,
                    "smoothness_avg": 0.006534541605897799,
                    "success_improvement": 0.0,
                    "time_improvement": 94.91995373769882,
                    "length_improvement": -0.24647043479386058,
                    "smoothness_improvement": 68.1384621598253,
                    "objective_score": 28.668796171232458
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.007047319412231445,
                    "num_nodes_avg": 165.1,
                    "path_length_avg": 166.43066776648297,
                    "smoothness_avg": 0.012296125703856912,
                    "success_improvement": 0.0,
                    "time_improvement": 85.78119122317372,
                    "length_improvement": -10.535324953740279,
                    "smoothness_improvement": 56.405811347470625,
                    "objective_score": 19.6951914514453
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m1",
          "algorithm_description": "This is a bidirectional RRT* planner that incorporates adaptive neighborhood radius, efficient rewiring with incremental cost updates, goal-biased sampling with retry limits, and periodic iterative path shortcutting during planning to improve path length, smoothness, and planning efficiency. The planner grows two trees alternatingly from start and goal positions, uses squared-distance based near neighbor searches to optimize rewiring, attempts multiple candidate connections between trees with early stopping on improvement, and maintains the best path found so far within a strict 30-second time limit. The plan method returns the best valid path found at timeout or successful connection.",
          "planning_mechanism": "The planner grows start and goal trees alternately by sampling free points with goal bias and retry limits. It selects nearest nodes using squared distances, steers towards samples with capped step size, and performs collision checks for nodes and edges. An adaptive rewiring radius logarithmically shrinks with increasing node count. When adding a new node, it rewires neighboring nodes if cost improves and edges are free. It attempts multiple candidate connections to the opposite tree within an expanded radius, updates the best path on improvement, and performs iterative shortcutting every 100 iterations to smooth the path. Planning respects a 30-second wall-clock limit and returns the best feasible path found so far.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position      # Tuple[float, ...]\n        self.parent = parent          # Node or None\n        self.cost = cost              # Path cost from root\n        self.children = []            # List[Node]\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, goal_sample_rate: float = 0.2):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.time_limit = 30.0\n\n    def plan(self, map) -> 'PlannerResult':\n        import time\n        import math\n        import random\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def dist_sq(a, b):\n            return sum((a[i] - b[i]) ** 2 for i in range(dim))\n\n        def dist(a, b):\n            return math.sqrt(dist_sq(a, b))\n\n        def sample_free():\n            # Goal bias sampling with retry limit\n            if random.random() < self.goal_sample_rate:\n                return goal_pos\n            for _ in range(30):\n                p = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n            return goal_pos  # fallback if sampling failed\n\n        def steer(from_p, to_p, max_step):\n            d = dist(from_p, to_p)\n            if d <= max_step:\n                return to_p\n            ratio = max_step / d\n            return tuple(from_p[i] + (to_p[i] - from_p[i]) * ratio for i in range(dim))\n\n        def nearest(tree, point):\n            best_node = None\n            best_dist_sq = float('inf')\n            for node in tree:\n                d2 = dist_sq(node.position, point)\n                if d2 < best_dist_sq:\n                    best_dist_sq = d2\n                    best_node = node\n            return best_node\n\n        def near(tree, point, radius):\n            r_sq = radius * radius\n            near_nodes = []\n            for node in tree:\n                d2 = dist_sq(node.position, point)\n                if d2 <= r_sq:\n                    near_nodes.append((d2, node))\n            near_nodes.sort(key=lambda x: x[0])\n            return [n[1] for n in near_nodes]\n\n        def extract_path(node_start, node_goal):\n            path_start = []\n            cur = node_start\n            while cur:\n                path_start.append(cur.position)\n                cur = cur.parent\n            path_goal = []\n            cur = node_goal\n            while cur:\n                path_goal.append(cur.position)\n                cur = cur.parent\n            return path_start[::-1] + path_goal\n\n        def shortcut_path(path):\n            # Up to 100 random shortcut attempts\n            if len(path) < 3:\n                return path\n            attempts = 0\n            max_attempts = 100\n            while attempts < max_attempts and len(path) >= 3:\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                    path = path[:i + 1] + path[j:]\n                attempts += 1\n            return path\n\n        def try_connect(new_node, other_tree):\n            # Attempt multiple candidates within 3*step_size radius\n            radius = self.step_size * 3.0\n            candidates = near(other_tree, new_node.position, radius)\n            best_node = None\n            best_total_cost = float('inf')\n            for c in candidates:\n                d = dist(new_node.position, c.position)\n                if d <= radius and not self._is_edge_in_obstacle(new_node.position, c.position, obstacles, is_3d):\n                    total_cost = new_node.cost + c.cost + d\n                    if total_cost < best_total_cost:\n                        best_total_cost = total_cost\n                        best_node = c\n            return best_node, best_total_cost\n\n        start_tree = [Node(start_pos, cost=0.0)]\n        goal_tree = [Node(goal_pos, cost=0.0)]\n        nodes = start_tree[:] + goal_tree[:]\n        edges = []\n\n        gamma_rrt_star = 35.0\n        best_connection = None\n        best_cost = float('inf')\n        success = False\n\n        start_time = time.monotonic()\n\n        for iteration in range(self.max_iter):\n            elapsed = time.monotonic() - start_time\n            if elapsed > self.time_limit:\n                break\n\n            # Alternate between start_tree and goal_tree expansions\n            if iteration % 2 == 0:\n                tree_a, tree_b = start_tree, goal_tree\n            else:\n                tree_a, tree_b = goal_tree, start_tree\n\n            sample = sample_free()\n            nearest_node = nearest(tree_a, sample)\n            new_pos = steer(nearest_node.position, sample, self.step_size)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            n_nodes = len(tree_a) + 1\n            radius = min(self.step_size * 5,\n                         gamma_rrt_star * (math.log(max(n_nodes, 2)) / n_nodes) ** (1 / dim))\n\n            near_nodes = near(tree_a, new_pos, radius)\n\n            # Choose best parent minimizing cost\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            min_parent = nearest_node\n            for near_node in near_nodes:\n                new_cost = near_node.cost + dist(near_node.position, new_pos)\n                if new_cost < min_cost and not self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d):\n                    min_cost = new_cost\n                    min_parent = near_node\n\n            new_node = Node(new_pos, parent=min_parent, cost=min_cost)\n            min_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((min_parent, new_node))\n\n            # Rewire neighbors for improved costs\n            for near_node in near_nodes:\n                if near_node == min_parent:\n                    continue\n                rewired_cost = new_node.cost + dist(new_node.position, near_node.position)\n                if rewired_cost + 1e-12 < near_node.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                        # Remove old edge\n                        if near_node.parent is not None:\n                            try:\n                                edges.remove((near_node.parent, near_node))\n                            except ValueError:\n                                pass\n                            near_node.parent.remove_child(near_node)\n                        # Rewire\n                        near_node.parent = new_node\n                        near_node.cost = rewired_cost\n                        new_node.add_child(near_node)\n                        edges.append((new_node, near_node))\n\n            # Attempt to connect the new node to the opposite tree\n            conn_node, conn_cost = try_connect(new_node, tree_b)\n            if conn_node is not None and conn_cost < best_cost:\n                best_cost = conn_cost\n                best_connection = (new_node, conn_node)\n                success = True\n                # Early stop on improvement\n                break\n\n            # Periodic shortcutting to improve path if existing\n            if iteration % 100 == 0 and success and best_connection:\n                path = extract_path(best_connection[0], best_connection[1])\n                path = shortcut_path(path)\n                # Update best connection path to shortcut result\n                # Note: for simplicity, best_connection remains original nodes,\n                # will return shortcut path at the end\n                extracted_path = path\n\n        if success and best_connection:\n            extracted_path = extract_path(best_connection[0], best_connection[1])\n            extracted_path = shortcut_path(extracted_path)\n        else:\n            # Try partial connection if no solution found\n            min_cost = float('inf')\n            best_pair = None\n            for n1 in start_tree:\n                candidates = near(goal_tree, n1.position, self.step_size * 3.0)\n                for n2 in candidates:\n                    d = dist(n1.position, n2.position)\n                    if d <= self.step_size * 3.0 and not self._is_edge_in_obstacle(n1.position, n2.position, obstacles, is_3d):\n                        total_c = n1.cost + n2.cost + d\n                        if total_c < min_cost:\n                            min_cost = total_c\n                            best_pair = (n1, n2)\n            if best_pair:\n                extracted_path = extract_path(best_pair[0], best_pair[1])\n                extracted_path = shortcut_path(extracted_path)\n                success = True\n\n        return PlannerResult(\n            success=success,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=None):\n        # Set finer resolution based on step size or default 0.5 if not provided\n        import math\n        if resolution is None:\n            resolution = max(0.5, self.step_size / 5)\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -26.44459,
          "time_improvement": 27.0,
          "length_improvement": 17.0,
          "smoothness_improvement": 1657.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.018362045288085938,
                    "num_nodes_avg": 95.9,
                    "path_length_avg": 157.9445718033501,
                    "smoothness_avg": 0.03828957212971301,
                    "success_improvement": 0.0,
                    "time_improvement": 26.626201960864638,
                    "length_improvement": 13.428077402682579,
                    "smoothness_improvement": 499.3149509667044,
                    "objective_score": 18.54128178470246
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.0771651029586792,
                    "num_nodes_avg": 295.6,
                    "path_length_avg": 241.94613299404665,
                    "smoothness_avg": 0.1236608223702053,
                    "success_improvement": 0.0,
                    "time_improvement": 52.80832639768198,
                    "length_improvement": 19.231416773280305,
                    "smoothness_improvement": 3081.882028875528,
                    "objective_score": 42.79075812765041
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.04898715019226074,
                    "num_nodes_avg": 221.4,
                    "path_length_avg": 123.7035308979866,
                    "smoothness_avg": 0.1171036094758882,
                    "success_improvement": 0.0,
                    "time_improvement": 1.162572552550987,
                    "length_improvement": 17.8420049066961,
                    "smoothness_improvement": 1389.5492688439726,
                    "objective_score": 18.00172105400282
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "initial",
          "algorithm_description": "This algorithm enhances the standard BI-RRT by incorporating an optimization step that rewires nearby nodes to minimize cost, resulting in asymptotically optimal paths. It grows two trees\u2014one from the start and one from the goal\u2014and attempts to connect them while optimizing the path cost dynamically.",
          "planning_mechanism": "The planning mechanism includes sampling a random point, extending each tree toward it, rewiring neighbors within a radius to optimize the cost, and attempting to connect the two trees. When a connection is established, the combined path is extracted from both trees. Node validity and edge collision checks are strictly enforced throughout the process.",
          "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost: float = 0.0):\n        self.position = position              # Tuple[float, ...]\n        self.parent: Optional[\"Node\"] = parent\n        self.cost: float = cost\n        self.children: List[\"Node\"] = []\n        self.valid = True\n\n    def add_child(self, child_node: \"Node\"):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n\nclass Planner:\n    def __init__(\n        self,\n        max_iter: int = 5000,\n        step_size: float = 5.0,\n        gamma_rrt_star: float = 50.0,\n        max_radius: float = 60.0,\n    ):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.gamma_rrt_star = gamma_rrt_star\n        self.max_radius = max_radius\n\n    # ======================= Public API =======================\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        start_root = Node(start_position, parent=None, cost=0.0)\n        goal_root  = Node(goal_position,  parent=None, cost=0.0)\n        nodes.extend([start_root, goal_root])\n\n        tree_a: List[Node] = [start_root]\n        tree_b: List[Node] = [goal_root]\n\n        for _ in range(self.max_iter):\n            rand_point = self._sample_free(bounds, obstacles, is_3d)\n\n            new_a = self._extend_and_rewire(tree_a, rand_point, obstacles, is_3d, nodes, edges, bounds)\n            if new_a is None:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            new_b = self._connect_and_rewire(tree_b, new_a, obstacles, is_3d, nodes, edges, bounds)\n            if new_b:\n                success_state = True\n                path_a = new_a.path_from_root()\n                path_b = new_b.path_from_root()\n                if path_a and path_b and path_a[-1] == path_b[-1]:\n                    path_b = path_b[:-1]\n                extracted_path = path_a + path_b[::-1]\n                break\n\n            tree_a, tree_b = tree_b, tree_a\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        while True:\n            p = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    def _nearest(self, tree: List[Node], point):\n        return min(tree, key=lambda node: math.dist(node.position, point))\n\n    def _steer(self, from_pos, to_pos):\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _near_nodes(self, tree: List[Node], position, bounds) -> List[Node]:\n        n = max(1, len(tree))\n        d = len(position)\n        # \uacf5\uac04 \uc2a4\ucf00\uc77c\uc744 \uac04\ub2e8\ud788 bounds\ub85c \ucd94\uc815 (\uc815\ubc00 X, \uc2e4\uc6a9\uc801)\n        scale = max(1.0, sum(bounds) / d)\n        r_theory = self.gamma_rrt_star * ((math.log(n + 1) / (n + 1)) ** (1.0 / d))\n        radius = max(self.step_size * 2.0, min(self.max_radius, r_theory * 0.5 + scale * 0.02))\n        return [node for node in tree if math.dist(node.position, position) <= radius]\n\n    def _choose_parent_and_add(self, tree, new_pos, obstacles, is_3d, nodes, edges, bounds):\n        nearest = self._nearest(tree, new_pos)\n        neighbors = self._near_nodes(tree, new_pos, bounds)\n\n        min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n        best_parent = nearest\n\n        for nb in neighbors:\n            if not self._is_edge_in_obstacle(nb.position, new_pos, obstacles, is_3d):\n                cand = nb.cost + math.dist(nb.position, new_pos)\n                if cand < min_cost:\n                    min_cost = cand\n                    best_parent = nb\n\n        new_node = Node(new_pos, parent=None, cost=min_cost)\n        best_parent.add_child(new_node)\n        tree.append(new_node)\n        nodes.append(new_node)\n        edges.append((best_parent, new_node))\n        return new_node, neighbors\n\n    def _rewire_from(self, pivot: Node, neighbors: List[Node], obstacles, is_3d, edges):\n        for nb in neighbors:\n            if not self._is_edge_in_obstacle(pivot.position, nb.position, obstacles, is_3d):\n                new_cost = pivot.cost + math.dist(pivot.position, nb.position)\n                if new_cost + 1e-12 < nb.cost:  # \uc791\uc740 \uc218\uce58 \ubc84\ud37c\n                    if nb.parent is not None:\n                        try:\n                            edges.remove((nb.parent, nb))\n                        except ValueError:\n                            pass\n                        if nb in nb.parent.children:\n                            nb.parent.children.remove(nb)\n                    pivot.add_child(nb)\n                    nb.cost = new_cost\n                    edges.append((pivot, nb))\n\n    def _extend_and_rewire(self, tree, sample_point, obstacles, is_3d, nodes, edges, bounds):\n        nearest = self._nearest(tree, sample_point)\n        new_pos = self._steer(nearest.position, sample_point)\n\n        if self._is_in_obstacle(new_pos, obstacles, is_3d):\n            return None\n        if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n            return None\n\n        new_node, neighbors = self._choose_parent_and_add(tree, new_pos, obstacles, is_3d, nodes, edges, bounds)\n        self._rewire_from(new_node, neighbors, obstacles, is_3d, edges)\n        return new_node\n\n    def _connect_and_rewire(self, tree, target_node: Node, obstacles, is_3d, nodes, edges, bounds):\n        nearest = self._nearest(tree, target_node.position)\n\n        while True:\n            new_pos = self._steer(nearest.position, target_node.position)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                return None\n\n            connect_node, neighbors = self._choose_parent_and_add(tree, new_pos, obstacles, is_3d, nodes, edges, bounds)\n            self._rewire_from(connect_node, neighbors, obstacles, is_3d, edges)\n\n            if math.dist(connect_node.position, target_node.position) <= self.step_size:\n                if (not self._is_edge_in_obstacle(connect_node.position, target_node.position, obstacles, is_3d) and\n                    not self._is_in_obstacle(target_node.position, obstacles, is_3d)):\n                    final_node = Node(target_node.position, parent=None, cost=connect_node.cost + math.dist(connect_node.position, target_node.position))\n                    connect_node.add_child(final_node)\n                    tree.append(final_node)\n                    nodes.append(final_node)\n                    edges.append((connect_node, final_node))\n                    return final_node\n                else:\n                    return None\n\n            nearest = connect_node\n\n        \n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n        \n        \n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n",
          "objective": -26.116386668393563,
          "time_improvement": 59.0,
          "length_improvement": 12.0,
          "smoothness_improvement": 178.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.01048591136932373,
                    "num_nodes_avg": 55.0,
                    "path_length_avg": 161.06168019947768,
                    "smoothness_avg": 0.018734837295491497,
                    "success_improvement": 0.0,
                    "time_improvement": 58.09883207464661,
                    "length_improvement": 11.719540897021666,
                    "smoothness_improvement": 193.24088702478866,
                    "objective_score": 25.42757859573092
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.025601959228515624,
                    "num_nodes_avg": 202.1,
                    "path_length_avg": 260.76133699173454,
                    "smoothness_avg": 0.010239608160588953,
                    "success_improvement": 0.0,
                    "time_improvement": 84.34267230695025,
                    "length_improvement": 12.950360113232934,
                    "smoothness_improvement": 163.47249326360028,
                    "objective_score": 33.890380226342835
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.03202393054962158,
                    "num_nodes_avg": 227.8,
                    "path_length_avg": 131.686727202312,
                    "smoothness_avg": 0.021869076335319346,
                    "success_improvement": 0.0,
                    "time_improvement": 35.387894583416305,
                    "length_improvement": 12.539946040320416,
                    "smoothness_improvement": 178.1730367779587,
                    "objective_score": 19.031201183106933
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "A simplified bidirectional RRT* planner that alternates between growing trees from start and goal, uses adaptive rewiring radius based on node count and dimension, employs goal-biased sampling, and applies path shortcutting only once after path discovery or timeout. It enforces strict 30-second planning time and performs consistent node and edge collision checking to ensure valid expansions and connections. Early stopping occurs when improved inter-tree connections are found, balancing search speed and path quality.",
          "planning_mechanism": "The planner grows two trees alternately towards random samples biased by goal, rewires nodes within an adaptively computed radius to optimize cost, attempts connections between the trees within a larger radius, and upon success, extracts and shortcut the final path. The search respects a 30-second time limit and returns the best found path or an empty path if no valid connection is found.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=5.0, goal_sample_rate=0.2):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.time_limit = 30.0\n\n    def plan(self, map):\n        import time\n        import math\n        import random\n\n        bounds = map.size\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def sample_free():\n            if random.random() < self.goal_sample_rate:\n                return goal_pos\n            for _ in range(30):\n                p = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n            return goal_pos\n\n        def steer(from_p, to_p, max_step):\n            d = dist(from_p, to_p)\n            if d <= max_step:\n                return to_p\n            ratio = max_step / d\n            return tuple(from_p[i] + (to_p[i] - from_p[i]) * ratio for i in range(dim))\n\n        def nearest(tree, point):\n            best = None\n            best_dist_sq = float('inf')\n            for node in tree:\n                d_sq = sum((node.position[i] - point[i]) ** 2 for i in range(dim))\n                if d_sq < best_dist_sq:\n                    best_dist_sq = d_sq\n                    best = node\n            return best\n\n        def near(tree, point, radius):\n            r_sq = radius * radius\n            nbrs = []\n            for node in tree:\n                d_sq = sum((node.position[i] - point[i]) ** 2 for i in range(dim))\n                if d_sq <= r_sq:\n                    nbrs.append((d_sq, node))\n            nbrs.sort(key=lambda x: x[0])\n            return [n[1] for n in nbrs]\n\n        def extract_path(n_start, n_goal):\n            path_start = []\n            cur = n_start\n            while cur:\n                path_start.append(cur.position)\n                cur = cur.parent\n            path_start.reverse()\n            path_goal = []\n            cur = n_goal\n            while cur:\n                path_goal.append(cur.position)\n                cur = cur.parent\n            if path_start and path_goal and path_start[-1] == path_goal[0]:\n                path_goal = path_goal[1:]\n            return path_start + path_goal\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            attempts = 0\n            max_attempts = 100\n            while attempts < max_attempts and len(path) >= 3:\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                    path = path[:i + 1] + path[j:]\n                attempts += 1\n            return path\n\n        def try_connect(new_node, other_tree, radius):\n            candidates = near(other_tree, new_node.position, radius)\n            best_node = None\n            best_cost = float('inf')\n            for c in candidates:\n                d = dist(new_node.position, c.position)\n                if d <= radius and not self._is_edge_in_obstacle(new_node.position, c.position, obstacles, is_3d):\n                    cost = new_node.cost + d + c.cost\n                    if cost < best_cost:\n                        best_cost = cost\n                        best_node = c\n            return best_node, best_cost\n\n        start_tree = [Node(start_pos, cost=0.0)]\n        goal_tree = [Node(goal_pos, cost=0.0)]\n        nodes = start_tree[:] + goal_tree[:]\n        edges = []\n\n        gamma = 35.0\n        best_connection = None\n        best_cost = float('inf')\n        success = False\n\n        start_time = time.monotonic()\n\n        for it in range(self.max_iter):\n            if time.monotonic() - start_time > self.time_limit:\n                break\n\n            tree_a, tree_b = (start_tree, goal_tree) if it % 2 == 0 else (goal_tree, start_tree)\n\n            sample = sample_free()\n            nearest_node = nearest(tree_a, sample)\n            new_pos = steer(nearest_node.position, sample, self.step_size)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            n = len(tree_a) + 1\n            radius = min(self.step_size * 5.0, gamma * (math.log(max(n, 2)) / n) ** (1 / dim))\n\n            near_nodes = near(tree_a, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            min_parent = nearest_node\n            for near_node in near_nodes:\n                new_cost = near_node.cost + dist(near_node.position, new_pos)\n                if new_cost < min_cost:\n                    if not self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d):\n                        min_cost = new_cost\n                        min_parent = near_node\n\n            new_node = Node(new_pos, parent=min_parent, cost=min_cost)\n            min_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((min_parent, new_node))\n\n            for near_node in near_nodes:\n                if near_node is min_parent:\n                    continue\n                rewired_cost = new_node.cost + dist(new_node.position, near_node.position)\n                if rewired_cost < near_node.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                        if near_node.parent:\n                            try:\n                                edges.remove((near_node.parent, near_node))\n                            except ValueError:\n                                pass\n                            near_node.parent.remove_child(near_node)\n                        near_node.parent = new_node\n                        near_node.cost = rewired_cost\n                        new_node.add_child(near_node)\n                        edges.append((new_node, near_node))\n\n            conn_node, conn_cost = try_connect(new_node, tree_b, self.step_size * 3.0)\n            if conn_node and conn_cost < best_cost:\n                best_cost = conn_cost\n                best_connection = (new_node, conn_node)\n                success = True\n                break\n\n        if success and best_connection:\n            path = extract_path(best_connection[0], best_connection[1])\n            path = shortcut_path(path)\n        else:\n            min_cost = float('inf')\n            best_pair = None\n            for n1 in start_tree:\n                candidates = near(goal_tree, n1.position, self.step_size * 3.0)\n                for n2 in candidates:\n                    d = dist(n1.position, n2.position)\n                    if d <= self.step_size * 3.0 and not self._is_edge_in_obstacle(n1.position, n2.position, obstacles, is_3d):\n                        cost = n1.cost + n2.cost + d\n                        if cost < min_cost:\n                            min_cost = cost\n                            best_pair = (n1, n2)\n            if best_pair:\n                path = extract_path(best_pair[0], best_pair[1])\n                path = shortcut_path(path)\n                success = True\n            else:\n                path = []\n\n        return PlannerResult(\n            success=success,\n            path=path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=None):\n        import math\n        if resolution is None:\n            resolution = max(0.5, self.step_size / 5)\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -26.08123,
          "time_improvement": 33.0,
          "length_improvement": 14.0,
          "smoothness_improvement": 1584.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.021164131164550782,
                    "num_nodes_avg": 123.3,
                    "path_length_avg": 173.53258203340735,
                    "smoothness_avg": 0.040836975071454416,
                    "success_improvement": 0.0,
                    "time_improvement": 16.13067804969303,
                    "length_improvement": 4.884041987759347,
                    "smoothness_improvement": 539.1873387789844,
                    "objective_score": 10.465565301458438
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.06961920261383056,
                    "num_nodes_avg": 308.0,
                    "path_length_avg": 239.475192631327,
                    "smoothness_avg": 0.11242119414567661,
                    "success_improvement": 0.0,
                    "time_improvement": 57.533903321180254,
                    "length_improvement": 20.056287788430996,
                    "smoothness_improvement": 2792.6782990814204,
                    "objective_score": 43.25733516481978
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.036632204055786134,
                    "num_nodes_avg": 209.6,
                    "path_length_avg": 126.15927240069682,
                    "smoothness_avg": 0.11955644052327277,
                    "success_improvement": 0.0,
                    "time_improvement": 25.634804359305335,
                    "length_improvement": 16.21101833044007,
                    "smoothness_improvement": 1420.7490987175497,
                    "objective_score": 24.52079779964339
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m2",
          "algorithm_description": "A balanced bidirectional RRT* planner with adaptive rewiring radius, enhanced goal-biased sampling, efficient nearest/neighbor queries using squared distances, iterative multi-candidate cross-tree connections, and progressive shortcutting for achieving improved planning time, path length, and smoothness within a 30-second limit.",
          "planning_mechanism": "The planner alternates growth between forward and backward trees, samples with increasing goal bias and limited retries, steers with fixed step size, rewires neighbors within a radius adapting to node density, attempts multiple connections to opposite tree nodes for cost optimization, applies repeated lightweight shortcutting during planning to refine path smoothness, and terminates early on time limit or improved solution, returning the best viable path.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float = 0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n        if parent:\n            parent.children.append(self)\n    def add_child(self, child):\n        self.children.append(child)\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, base_goal_sample_rate: float=0.2):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.time_limit = 30.0\n        self.base_goal_sample_rate = base_goal_sample_rate\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = dim == 3\n\n        start_tree = [Node(start_pos, cost=0.0)]\n        goal_tree = [Node(goal_pos, cost=0.0)]\n        nodes = start_tree[:] + goal_tree[:]\n        edges = []\n\n        best_connection = None\n        best_cost = float('inf')\n        success = False\n        extracted_path = []\n\n        def dist_sq(a, b):\n            s = 0.0\n            for i in range(dim):\n                d = a[i] - b[i]\n                s += d * d\n            return s\n\n        def dist(a, b):\n            return math.sqrt(dist_sq(a,b))\n\n        def sample_free(goal_bias):\n            if random.random() < goal_bias:\n                return goal_pos\n            for _ in range(30):\n                p = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n            return goal_pos\n\n        def nearest(tree, point):\n            best_node = None\n            best_dist = float('inf')\n            for node in tree:\n                d = dist_sq(node.position, point)\n                if d < best_dist:\n                    best_dist = d\n                    best_node = node\n            return best_node\n\n        def near(tree, point, radius):\n            r_sq = radius * radius\n            neighbors = []\n            for node in tree:\n                d = dist_sq(node.position, point)\n                if d <= r_sq:\n                    neighbors.append((d, node))\n            neighbors.sort(key=lambda x: x[0])\n            return [n[1] for n in neighbors]\n\n        def steer(from_p, to_p, max_step):\n            d = dist(from_p, to_p)\n            if d <= max_step:\n                return to_p\n            ratio = max_step / d\n            return tuple(from_p[i] + ratio * (to_p[i] - from_p[i]) for i in range(dim))\n\n        def extract_path(n_start, n_goal):\n            path_start = []\n            cur = n_start\n            while cur:\n                path_start.append(cur.position)\n                cur = cur.parent\n            path_goal = []\n            cur = n_goal\n            while cur:\n                path_goal.append(cur.position)\n                cur = cur.parent\n            # Avoid duplicate join point\n            return path_start[::-1] + path_goal\n\n        def shortcut_path(path, attempts=30, resolution=None):\n            if len(path) < 3:\n                return path\n            if resolution is None:\n                resolution = max(self.step_size / 5.0, 0.5)\n            for _ in range(attempts):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d, resolution):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        def try_connect(node, other_tree, radius):\n            candidates = near(other_tree, node.position, radius)\n            best_node = None\n            best_cost_local = float('inf')\n            for cnode in candidates:\n                d = dist(node.position, cnode.position)\n                if d <= radius and not self._is_edge_in_obstacle(node.position, cnode.position, obstacles, is_3d, resolution=self.step_size/5):\n                    total_cost = node.cost + cnode.cost + d\n                    if total_cost < best_cost_local:\n                        best_cost_local = total_cost\n                        best_node = cnode\n            return best_node, best_cost_local\n\n        def rewire(tree, new_node, neighbors):\n            for near_node in neighbors:\n                if near_node == new_node.parent:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, near_node.position)\n                if new_cost + 1e-9 < near_node.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d, resolution=self.step_size/5):\n                        if near_node.parent:\n                            try:\n                                edges.remove((near_node.parent, near_node))\n                            except ValueError:\n                                pass\n                            near_node.parent.remove_child(near_node)\n                        near_node.parent = new_node\n                        near_node.cost = new_cost\n                        new_node.add_child(near_node)\n                        edges.append((new_node, near_node))\n\n        start_time = time.monotonic()\n        gamma_rrt_star = 35.0\n\n        # Adaptive goal sample rate linearly increases from base to 0.5 over iterations\n        def adaptive_goal_sample_rate(iter_idx):\n            return min(self.base_goal_sample_rate + 0.3 * (iter_idx / self.max_iter), 0.5)\n\n        for it in range(self.max_iter):\n            current_time = time.monotonic()\n            if current_time - start_time > self.time_limit:\n                break\n\n            tree_a = start_tree if it % 2 == 0 else goal_tree\n            tree_b = goal_tree if it % 2 == 0 else start_tree\n\n            goal_bias = adaptive_goal_sample_rate(it)\n            q_rand = sample_free(goal_bias)\n\n            nearest_node = nearest(tree_a, q_rand)\n            q_new = steer(nearest_node.position, q_rand, self.step_size)\n\n            if self._is_in_obstacle(q_new, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, q_new, obstacles, is_3d, resolution=self.step_size/10):\n                continue\n\n            n_nodes = max(len(tree_a), 2)\n            radius = min(self.step_size * 5.0, gamma_rrt_star * (math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            radius = max(radius, self.step_size * 1.5)  # Minimum radius threshold\n\n            neighbors = near(tree_a, q_new, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, q_new)\n            min_parent = nearest_node\n            for near_n in neighbors:\n                cost_through = near_n.cost + dist(near_n.position, q_new)\n                if cost_through + 1e-9 < min_cost:\n                    if not self._is_edge_in_obstacle(near_n.position, q_new, obstacles, is_3d, resolution=self.step_size/10):\n                        min_cost = cost_through\n                        min_parent = near_n\n\n            new_node = Node(q_new, parent=min_parent, cost=min_cost)\n            min_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((min_parent, new_node))\n\n            rewire(tree_a, new_node, neighbors)\n\n            connect_radius = self.step_size * 4.0\n            conn_node, conn_cost = try_connect(new_node, tree_b, connect_radius)\n            if conn_node and conn_cost < best_cost:\n                best_cost = conn_cost\n                best_connection = (new_node, conn_node)\n                success = True\n                extracted_path = extract_path(new_node, conn_node)\n                # Progressive shortcutting\n                extracted_path = shortcut_path(extracted_path, attempts=40)\n                break\n\n            # Periodic shortcutting on best path found to improve smoothness & length progressively\n            if success and it % 100 == 0 and best_connection:\n                path = extract_path(best_connection[0], best_connection[1])\n                shortcut = shortcut_path(path, attempts=20)\n                if len(shortcut) < len(extracted_path) or \\\n                        sum(dist(shortcut[i], shortcut[i+1]) for i in range(len(shortcut) - 1)) + 1e-9 < \\\n                        sum(dist(extracted_path[i], extracted_path[i + 1]) for i in range(len(extracted_path) - 1)):\n                    extracted_path = shortcut\n\n        if not success:\n            # Attempt to find best connection between trees post search\n            best_pair = None\n            min_total = float('inf')\n            for n1 in start_tree:\n                candidates = near(goal_tree, n1.position, self.step_size * 4.0)\n                for n2 in candidates:\n                    d = dist(n1.position, n2.position)\n                    if d <= self.step_size * 4.0 and not self._is_edge_in_obstacle(n1.position, n2.position, obstacles, is_3d, resolution=self.step_size/10):\n                        total_c = n1.cost + n2.cost + d\n                        if total_c < min_total:\n                            min_total = total_c\n                            best_pair = (n1, n2)\n            if best_pair:\n                success = True\n                extracted_path = extract_path(best_pair[0], best_pair[1])\n                extracted_path = shortcut_path(extracted_path, attempts=50)\n\n        return PlannerResult(\n            success=success,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -24.9939,
          "time_improvement": 40.0,
          "length_improvement": 14.0,
          "smoothness_improvement": 898.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.020251083374023437,
                    "num_nodes_avg": 120.6,
                    "path_length_avg": 159.18824704749517,
                    "smoothness_avg": 0.03530194092180055,
                    "success_improvement": 0.0,
                    "time_improvement": 19.74890827631428,
                    "length_improvement": 12.746399294071296,
                    "smoothness_improvement": 452.5520348178664,
                    "objective_score": 15.835272233426393
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.07450652122497559,
                    "num_nodes_avg": 369.9,
                    "path_length_avg": 247.96811841622667,
                    "smoothness_avg": 0.04634272288256144,
                    "success_improvement": 0.0,
                    "time_improvement": 54.552752477032996,
                    "length_improvement": 17.221104706116957,
                    "smoothness_improvement": 1092.4316390823963,
                    "objective_score": 32.16064676219205
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.026442480087280274,
                    "num_nodes_avg": 185.5,
                    "path_length_avg": 132.12046483565678,
                    "smoothness_avg": 0.0980904466313902,
                    "success_improvement": 0.0,
                    "time_improvement": 46.32045066354195,
                    "length_improvement": 12.251878156619439,
                    "smoothness_improvement": 1147.7032408676555,
                    "objective_score": 26.985778297372526
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m1",
          "algorithm_description": "This algorithm is a bidirectional RRT* planner enhanced with adaptive neighborhood radius based on the number of nodes to balance rewiring efficiency and exploration speed. It grows two trees (from start and goal) by sampling the space, extending towards samples, rewiring locally to optimize path cost, and attempts connections between trees to find a feasible path quickly. The rewiring radius shrinks with node count to focus optimization locally as the tree grows. Once a connection is achieved, it extracts the shortest path connecting start and goal. The planner respects collision constraints for nodes and edges, enforces map boundaries, and stops if time limit or iteration limit is reached, returning the best path found.",
          "planning_mechanism": "The planner alternates growing start and goal trees by sampling random free points, steering nearest nodes toward samples with fixed step size, rewiring nearby nodes within a dynamically computed radius to minimize path cost, and tries connecting the trees when a new node is added. The radius shrinks with tree size to keep rewiring efficient. The planning stops upon reaching max iterations or 30 seconds. Upon success or timeout, the best found path from the connected trees is extracted by traversing parent links to the roots, composing a continuous path between start and goal.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n        import time\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = start_tree[:] + goal_tree[:]\n        edges = []\n\n        success = False\n        best_cost = float('inf')\n        best_connect = None\n\n        start_time = time.monotonic()\n        TIME_LIMIT = 30.0\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def sample_free():\n            while True:\n                p = tuple(random.uniform(0, bounds[i]) for i in range(len(bounds)))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: dist(n.position, point))\n\n        def near(tree, point, radius):\n            return [node for node in tree if dist(node.position, point) <= radius]\n\n        def steer(from_p, to_p, step):\n            d = dist(from_p, to_p)\n            if d <= step:\n                return to_p\n            ratio = step / d\n            return tuple(from_p[i] + (to_p[i] - from_p[i]) * ratio for i in range(len(from_p)))\n\n        def path_cost(node):\n            return node.cost\n\n        def extract_path(node_start, node_goal):\n            path_start = []\n            cur = node_start\n            while cur:\n                path_start.append(cur.position)\n                cur = cur.parent\n            path_goal = []\n            cur = node_goal\n            while cur:\n                path_goal.append(cur.position)\n                cur = cur.parent\n            return path_start[::-1] + path_goal\n\n        # Maintain mapping from position to Node for quick reference if needed\n        for iter_count in range(self.max_iter):\n            if time.monotonic() - start_time > TIME_LIMIT:\n                break\n\n            # Alternate trees: odd iter grow start_tree, even iter grow goal_tree\n            tree_a = start_tree if iter_count % 2 == 0 else goal_tree\n            tree_b = goal_tree if iter_count % 2 == 0 else start_tree\n\n            sample = sample_free()\n\n            nearest_node = nearest(tree_a, sample)\n            new_pos = steer(nearest_node.position, sample, self.step_size)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            # Radius adapted as per RRT* theory: gamma*(log(n)/n)^{1/d}\n            n = len(tree_a) + 1\n            d = len(bounds)\n            gamma = 30.0  # Tuned constant for neighborhood radius\n            radius = min(self.step_size * 5, gamma * (math.log(n) / n) ** (1 / d))\n\n            near_nodes = near(tree_a, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            min_parent = nearest_node\n            # Find best parent among neighbors\n            for near_node in near_nodes:\n                cost_through_near = near_node.cost + dist(near_node.position, new_pos)\n                if cost_through_near < min_cost and not self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d):\n                    min_cost = cost_through_near\n                    min_parent = near_node\n\n            new_node = Node(new_pos, parent=min_parent, cost=min_cost)\n            min_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((min_parent, new_node))\n\n            # Rewire neighbors if better through new_node\n            for near_node in near_nodes:\n                if near_node == min_parent:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, near_node.position)\n                if new_cost < near_node.cost and not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                    if near_node.parent:\n                        try:\n                            edges.remove((near_node.parent, near_node))\n                        except ValueError:\n                            pass\n                        near_node.parent.children.remove(near_node)\n                    near_node.parent = new_node\n                    near_node.cost = new_cost\n                    new_node.add_child(near_node)\n                    edges.append((new_node, near_node))\n\n            # Attempt to connect to other tree\n            nearest_to_new_in_other = nearest(tree_b, new_node.position)\n            dist_between = dist(new_node.position, nearest_to_new_in_other.position)\n            if dist_between <= self.step_size:\n                if not self._is_edge_in_obstacle(new_node.position, nearest_to_new_in_other.position, obstacles, is_3d):\n                    # Connection found\n                    candidate_cost = new_node.cost + nearest_to_new_in_other.cost + dist_between\n                    if candidate_cost < best_cost:\n                        best_cost = candidate_cost\n                        best_connect = (new_node, nearest_to_new_in_other)\n                        success = True\n                        # Stop early on first solution\n                        break\n\n        extracted_path = []\n        if success and best_connect is not None:\n            extracted_path = extract_path(best_connect[0], best_connect[1])\n\n        # If no success but time/iter limit reached, try to find best partial connection\n        if not success:\n            # Attempt to find minimal-cost connection between trees\n            min_cost = float('inf')\n            best_pair = None\n            for n1 in start_tree:\n                # Nearest node in goal_tree\n                n2 = min(goal_tree, key=lambda node: dist(n1.position, node.position))\n                d12 = dist(n1.position, n2.position)\n                if d12 <= self.step_size:\n                    if not self._is_edge_in_obstacle(n1.position, n2.position, obstacles, is_3d):\n                        cost_sum = n1.cost + n2.cost + d12\n                        if cost_sum < min_cost:\n                            min_cost = cost_sum\n                            best_pair = (n1, n2)\n            if best_pair is not None:\n                extracted_path = extract_path(best_pair[0], best_pair[1])\n                success = True\n\n        return PlannerResult(\n            success=success,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -24.50215,
          "time_improvement": 67.0,
          "length_improvement": 6.0,
          "smoothness_improvement": 140.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.009191942214965821,
                    "num_nodes_avg": 110.2,
                    "path_length_avg": 170.91077029046983,
                    "smoothness_avg": 0.01777274497333912,
                    "success_improvement": 0.0,
                    "time_improvement": 63.26946693101152,
                    "length_improvement": 6.321098549329074,
                    "smoothness_improvement": 178.1820529661874,
                    "objective_score": 23.664409473731837
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.02384507656097412,
                    "num_nodes_avg": 292.0,
                    "path_length_avg": 282.72493325276366,
                    "smoothness_avg": 0.008011301853497212,
                    "success_improvement": 0.0,
                    "time_improvement": 85.41712475015616,
                    "length_improvement": 5.618279494235603,
                    "smoothness_improvement": 106.13656699797079,
                    "objective_score": 29.52678795657806
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.023160457611083984,
                    "num_nodes_avg": 291.8,
                    "path_length_avg": 141.37742625459262,
                    "smoothness_avg": 0.018422059860500224,
                    "success_improvement": 0.0,
                    "time_improvement": 53.271010054655534,
                    "length_improvement": 6.10384515129628,
                    "smoothness_improvement": 134.3272416505493,
                    "objective_score": 20.31524631542717
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "A simplified bidirectional RRT* planner that grows two trees from start and goal points with uniform random sampling, consistent fixed step size extend, and rewiring within an adaptive radius. It attempts connections between trees each iteration, applies a single path shortcutting phase after completion, and respects a 30-second hard time limit, returning the best found path.",
          "planning_mechanism": "The planner alternately grows two trees by sampling free space uniformly, extends the nearest node toward the sample by a fixed step size, rewires neighbors within a radius shrinking adaptively with tree size, and tries connecting to the opposite tree within an extended radius. It returns the concatenated path of connected nodes if found, applies shortcutting once at the end, and stops early if time expires.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.time_limit = 30.0\n\n    def plan(self, map):\n        import time\n        import math\n        import random\n\n        bounds = map.size\n        dim = len(bounds)\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = (dim == 3)\n\n        def dist_sq(a, b):\n            return sum((a[i] - b[i]) ** 2 for i in range(dim))\n\n        def dist(a, b):\n            return math.sqrt(dist_sq(a,b))\n\n        def sample_free():\n            for _ in range(30):\n                p = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n            return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n\n        def steer(from_p, to_p, max_step):\n            d = dist(from_p, to_p)\n            if d <= max_step:\n                return to_p\n            ratio = max_step / d\n            return tuple(from_p[i] + (to_p[i] - from_p[i]) * ratio for i in range(dim))\n\n        def nearest(tree, point):\n            best_node = None\n            best_dist_sq = float('inf')\n            for node in tree:\n                d_sq = dist_sq(node.position, point)\n                if d_sq < best_dist_sq:\n                    best_dist_sq = d_sq\n                    best_node = node\n            return best_node\n\n        def near(tree, point, radius):\n            r_sq = radius * radius\n            return [n for n in tree if dist_sq(n.position, point) <= r_sq]\n\n        def extract_path(n_start, n_goal):\n            path_start = []\n            node = n_start\n            while node:\n                path_start.append(node.position)\n                node = node.parent\n            path_start.reverse()\n\n            path_goal = []\n            node = n_goal\n            while node:\n                path_goal.append(node.position)\n                node = node.parent\n\n            if path_start[-1] == path_goal[0]:\n                path_goal = path_goal[1:]\n            return path_start + path_goal\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            attempts = 0\n            max_attempts = 100\n            while attempts < max_attempts and len(path) >=3:\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) -1)\n                if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d, resolution=0.5):\n                    path = path[:i+1] + path[j:]\n                attempts += 1\n            return path\n\n        start_tree = [Node(start_pos, cost=0.0)]\n        goal_tree = [Node(goal_pos, cost=0.0)]\n        nodes = start_tree[:] + goal_tree[:]\n        edges = []\n\n        gamma = 30.0\n        best_connection = None\n        best_cost = float('inf')\n        found_solution = False\n\n        start_time = time.monotonic()\n\n        for it in range(self.max_iter):\n            if time.monotonic() - start_time > self.time_limit:\n                break\n\n            tree_a, tree_b = (start_tree, goal_tree) if it % 2 == 0 else (goal_tree, start_tree)\n\n            sample = sample_free()\n            nearest_node = nearest(tree_a, sample)\n            new_pos = steer(nearest_node.position, sample, self.step_size)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d, resolution=0.5):\n                continue\n\n            n = len(tree_a) + 1\n            radius = min(self.step_size * 5,\n                         gamma * (math.log(max(n,2)) / n) ** (1/dim))\n\n            near_nodes = near(tree_a, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            min_parent = nearest_node\n            for near_node in near_nodes:\n                potential_cost = near_node.cost + dist(near_node.position, new_pos)\n                if potential_cost < min_cost and not self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d, resolution=0.5):\n                    min_cost = potential_cost\n                    min_parent = near_node\n\n            new_node = Node(new_pos, parent=min_parent, cost=min_cost)\n            min_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((min_parent, new_node))\n\n            for near_node in near_nodes:\n                if near_node == min_parent:\n                    continue\n                rewired_cost = new_node.cost + dist(new_node.position, near_node.position)\n                if rewired_cost < near_node.cost and not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d, resolution=0.5):\n                    if near_node.parent:\n                        try:\n                            edges.remove((near_node.parent, near_node))\n                        except ValueError:\n                            pass\n                        near_node.parent.remove_child(near_node)\n                    near_node.parent = new_node\n                    near_node.cost = rewired_cost\n                    new_node.add_child(near_node)\n                    edges.append((new_node, near_node))\n\n            connection_radius = self.step_size * 3.0\n            candidates = near(tree_b, new_node.position, connection_radius)\n            for c in candidates:\n                d = dist(new_node.position, c.position)\n                if d <= connection_radius:\n                    if not self._is_edge_in_obstacle(new_node.position, c.position, obstacles, is_3d, resolution=0.5):\n                        total_cost = new_node.cost + c.cost + d\n                        if total_cost < best_cost:\n                            best_cost = total_cost\n                            best_connection = (new_node, c)\n                            found_solution = True\n\n            if found_solution:\n                break\n\n        if found_solution and best_connection:\n            extracted_path = extract_path(best_connection[0], best_connection[1])\n            extracted_path = shortcut_path(extracted_path)\n        else:\n            extracted_path = []\n            # Attempt partial connection fallback\n            min_cost = float('inf')\n            best_pair = None\n            radius = self.step_size * 3.0\n            for n1 in start_tree:\n                candidates = near(goal_tree, n1.position, radius)\n                for n2 in candidates:\n                    if not self._is_edge_in_obstacle(n1.position, n2.position, obstacles, is_3d, resolution=0.5):\n                        cost = n1.cost + n2.cost + dist(n1.position, n2.position)\n                        if cost < min_cost:\n                            min_cost = cost\n                            best_pair = (n1, n2)\n            if best_pair:\n                extracted_path = extract_path(best_pair[0], best_pair[1])\n                extracted_path = shortcut_path(extracted_path)\n                found_solution = True\n\n        return PlannerResult(\n            success=found_solution,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -24.446,
          "time_improvement": 26.0,
          "length_improvement": 15.0,
          "smoothness_improvement": 1500.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.029849815368652343,
                    "num_nodes_avg": 116.6,
                    "path_length_avg": 170.38725213240568,
                    "smoothness_avg": 0.04465691958938441,
                    "success_improvement": 0.0,
                    "time_improvement": -18.288993573427508,
                    "length_improvement": 6.608047147440114,
                    "smoothness_improvement": 598.977765626878,
                    "objective_score": 1.473019044570206
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.05046825408935547,
                    "num_nodes_avg": 236.7,
                    "path_length_avg": 236.7646066396825,
                    "smoothness_avg": 0.09726789019650597,
                    "success_improvement": 0.0,
                    "time_improvement": 69.21553713767985,
                    "length_improvement": 20.961159412333764,
                    "smoothness_improvement": 2402.7728739855916,
                    "objective_score": 45.35522115863217
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.03538343906402588,
                    "num_nodes_avg": 189.8,
                    "path_length_avg": 124.03167392139687,
                    "smoothness_avg": 0.1255408021326705,
                    "success_improvement": 0.0,
                    "time_improvement": 28.169859383023837,
                    "length_improvement": 17.62406793503863,
                    "smoothness_improvement": 1496.869736669463,
                    "objective_score": 26.509747259277646
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "A simplified bidirectional RRT* planner employing uniform random sampling with retry limits, fixed step steering, adaptive rewiring radius shrinking with the number of nodes, and intermittent randomized shortcutting to balance planning time, path length, and smoothness. The planner alternately expands trees from start and goal, rewires neighbors locally to minimize cost, attempts connections between trees, and returns the best path found within a strict 30-second limit.",
          "planning_mechanism": "The planner performs uniform random sample generation with a capped number of retries to avoid costly sampling in obstacle-dense maps, extends nearest nodes by a fixed step size if collision-free, rewires neighbors within an adaptively shrinking radius based on the current tree size to improve path cost, connects newly added nodes to the opposite tree if collision-free to form the solution, and applies periodic randomized shortcutting on the resultant path to improve smoothness before returning.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.time_limit = 30.0\n\n    def plan(self, map):\n        import time\n        import math\n        import random\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def in_obstacle(pos):\n            for o in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = o\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w_, h_ = o\n                    px, py = pos\n                    if x <= px <= x + w_ and y <= py <= y + h_:\n                        return True\n            return False\n\n        def edge_in_obstacle(a, b, resolution=0.5):\n            dist = math.dist(a, b)\n            steps = max(1, int(dist / resolution))\n            for i in range(steps + 1):\n                interp = tuple(a[d] + (b[d] - a[d]) * i / steps for d in range(dim))\n                if in_obstacle(interp):\n                    return True\n            return False\n\n        def steer(from_p, to_p):\n            dist = math.dist(from_p, to_p)\n            if dist <= self.step_size:\n                return to_p\n            r = self.step_size / dist\n            return tuple(from_p[i] + r * (to_p[i] - from_p[i]) for i in range(dim))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: math.dist(n.position, point))\n\n        def neighbors(tree, pos, radius):\n            r2 = radius * radius\n            return [n for n in tree if sum((n.position[i] - pos[i])**2 for i in range(dim)) <= r2]\n\n        def propagate_cost(node):\n            for c in node.children:\n                new_cost = node.cost + math.dist(node.position, c.position)\n                if new_cost < c.cost:\n                    c.cost = new_cost\n                    propagate_cost(c)\n\n        def rewire(tree, new_node, radius):\n            for nbr in neighbors(tree, new_node.position, radius):\n                if nbr is new_node.parent:\n                    continue\n                if not edge_in_obstacle(new_node.position, nbr.position):\n                    new_cost = new_node.cost + math.dist(new_node.position, nbr.position)\n                    if new_cost + 1e-9 < nbr.cost:  # numerical tolerance\n                        nbr.update_parent(new_node, new_cost)\n                        propagate_cost(nbr)\n\n        def extract_path(n_start, n_goal):\n            path_start = []\n            cur = n_start\n            while cur:\n                path_start.append(cur.position)\n                cur = cur.parent\n            path_goal = []\n            cur = n_goal\n            while cur:\n                path_goal.append(cur.position)\n                cur = cur.parent\n            return path_start[::-1] + path_goal\n\n        def sample_free(max_tries=30):\n            for _ in range(max_tries):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not in_obstacle(p):\n                    return p\n            return goal_pos  # fallback\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            max_attempts = 100\n            for _ in range(max_attempts):\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if not edge_in_obstacle(path[i], path[j]):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        start_tree = [Node(start_pos, cost=0.0)]\n        goal_tree = [Node(goal_pos, cost=0.0)]\n        all_nodes = start_tree + goal_tree\n        edges = []\n\n        best_cost = float('inf')\n        best_pair = None\n        success = False\n        result_path = []\n\n        start_time = time.monotonic()\n\n        for iteration in range(self.max_iter):\n            if time.monotonic() - start_time > self.time_limit:\n                break\n\n            tree_a, tree_b = (start_tree, goal_tree) if iteration % 2 == 0 else (goal_tree, start_tree)\n\n            sample = sample_free()\n            nearest_node = nearest(tree_a, sample)\n            new_pos = steer(nearest_node.position, sample)\n\n            if in_obstacle(new_pos) or edge_in_obstacle(nearest_node.position, new_pos):\n                continue\n\n            new_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            new_node = Node(new_pos, nearest_node, new_cost)\n            nearest_node.add_child(new_node)\n            tree_a.append(new_node)\n            all_nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n\n            n = len(tree_a)\n            radius = min(self.step_size * 10, self.step_size * (math.log(max(n,2)) / max(n,2)) ** (1 / dim))\n            rewire(tree_a, new_node, radius)\n\n            nearest_other = nearest(tree_b, new_pos)\n            if not edge_in_obstacle(new_pos, nearest_other.position):\n                total_cost = new_node.cost + nearest_other.cost + math.dist(new_pos, nearest_other.position)\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pair = (new_node, nearest_other)\n                    edges.append((new_node, nearest_other))\n                    result_path = extract_path(new_node, nearest_other)\n                    result_path = shortcut_path(result_path)\n                    success = True\n                    break\n\n        if not success and best_pair:\n            result_path = extract_path(best_pair[0], best_pair[1])\n            result_path = shortcut_path(result_path)\n            success = True\n\n        return PlannerResult(\n            success=success,\n            path=result_path,\n            nodes=all_nodes,\n            edges=edges\n        )",
          "objective": -24.03211,
          "time_improvement": 31.0,
          "length_improvement": 12.0,
          "smoothness_improvement": 1548.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.026597762107849122,
                    "num_nodes_avg": 111.7,
                    "path_length_avg": 172.3918569938552,
                    "smoothness_avg": 0.046426392817485854,
                    "success_improvement": 0.0,
                    "time_improvement": -5.4017410890593345,
                    "length_improvement": 5.509291457882858,
                    "smoothness_improvement": 626.6738641192812,
                    "objective_score": 4.818421868608321
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.03292849063873291,
                    "num_nodes_avg": 232.7,
                    "path_length_avg": 245.15576151695177,
                    "smoothness_avg": 0.10954518614085582,
                    "success_improvement": 0.0,
                    "time_improvement": 79.91438547912574,
                    "length_improvement": 18.159950388299915,
                    "smoothness_improvement": 2718.676541612546,
                    "objective_score": 48.46366858478041
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.040723347663879396,
                    "num_nodes_avg": 263.9,
                    "path_length_avg": 132.70824873952333,
                    "smoothness_avg": 0.11003937200953669,
                    "success_improvement": 0.0,
                    "time_improvement": 17.329579417155625,
                    "length_improvement": 11.861500074933032,
                    "smoothness_improvement": 1299.6926896997518,
                    "objective_score": 18.814237318605265
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "A streamlined bidirectional RRT* planner with uniform random sampling, fixed rewiring radius, and simplified path extraction. It incrementally grows start and goal trees alternately by steering fixed steps toward random free samples, rewirings neighbors in a fixed radius to improve costs, and connects trees when close. The path is extracted by concatenation and returned within a 30-second time limit without shortcutting or goal biasing, focusing on conceptual clarity and generalization.",
          "planning_mechanism": "The planner grows two trees from start and goal alternately using uniform sampling within map bounds, expands nodes stepwise toward samples, applies simple rewiring among neighbors inside a fixed radius, attempts to connect trees, and returns the concatenated feasible path or partial best found when time expires.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.time_limit = 30.0\n        self.rewire_radius = 20.0\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import time\n        import math\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        start_tree = [Node(start_pos, cost=0.0)]\n        goal_tree = [Node(goal_pos, cost=0.0)]\n        nodes = start_tree[:] + goal_tree[:]\n        edges = []\n\n        start_time = time.monotonic()\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def sample_free():\n            for _ in range(30):\n                point = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not self._is_in_obstacle(point, obstacles, is_3d):\n                    return point\n            return goal_pos\n\n        def nearest(tree, point):\n            best_node = None\n            best_dist = float('inf')\n            for node in tree:\n                d = dist(node.position, point)\n                if d < best_dist:\n                    best_dist = d\n                    best_node = node\n            return best_node\n\n        def near(tree, point, radius):\n            r2 = radius * radius\n            neighbors = []\n            for node in tree:\n                d = 0.0\n                for i in range(dim):\n                    diff = node.position[i] - point[i]\n                    d += diff * diff\n                    if d > r2:\n                        break\n                if d <= r2:\n                    neighbors.append(node)\n            return neighbors\n\n        def steer(from_p, to_p, max_step):\n            d = dist(from_p, to_p)\n            if d <= max_step:\n                return to_p\n            ratio = max_step / d\n            return tuple(from_p[i] + (to_p[i] - from_p[i]) * ratio for i in range(dim))\n\n        def extract_path(node_start, node_goal):\n            path_start = []\n            cur = node_start\n            while cur:\n                path_start.append(cur.position)\n                cur = cur.parent\n            path_start.reverse()\n            path_goal = []\n            cur = node_goal\n            while cur:\n                path_goal.append(cur.position)\n                cur = cur.parent\n            if path_start and path_goal and path_start[-1] == path_goal[0]:\n                path_goal = path_goal[1:]\n            return path_start + path_goal\n\n        success = False\n        best_connection = None\n        best_cost = float('inf')\n\n        for it in range(self.max_iter):\n            if time.monotonic() - start_time > self.time_limit:\n                break\n\n            tree_a = start_tree if it % 2 == 0 else goal_tree\n            tree_b = goal_tree if it % 2 == 0 else start_tree\n\n            sample = sample_free()\n            nearest_node = nearest(tree_a, sample)\n            new_pos = steer(nearest_node.position, sample, self.step_size)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d, resolution=1.0):\n                continue\n\n            neighbors = near(tree_a, new_pos, self.rewire_radius)\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            min_parent = nearest_node\n            for nb in neighbors:\n                cost_through_nb = nb.cost + dist(nb.position, new_pos)\n                if cost_through_nb < min_cost:\n                    if not self._is_edge_in_obstacle(nb.position, new_pos, obstacles, is_3d, resolution=1.0):\n                        min_cost = cost_through_nb\n                        min_parent = nb\n\n            new_node = Node(new_pos, parent=min_parent, cost=min_cost)\n            min_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((min_parent, new_node))\n\n            for nb in neighbors:\n                if nb == new_node.parent:\n                    continue\n                cost_through_new = new_node.cost + dist(new_node.position, nb.position)\n                if cost_through_new < nb.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, nb.position, obstacles, is_3d, resolution=1.0):\n                        if nb.parent:\n                            try:\n                                edges.remove((nb.parent, nb))\n                            except ValueError:\n                                pass\n                            nb.parent.children.remove(nb)\n                        nb.parent = new_node\n                        nb.cost = cost_through_new\n                        new_node.add_child(nb)\n                        edges.append((new_node, nb))\n\n            # Attempt connection between trees\n            for node_b in tree_b:\n                dist_between = dist(new_node.position, node_b.position)\n                if dist_between <= self.step_size:\n                    if not self._is_edge_in_obstacle(new_node.position, node_b.position, obstacles, is_3d, resolution=1.0):\n                        total_cost = new_node.cost + dist_between + node_b.cost\n                        if total_cost < best_cost:\n                            best_cost = total_cost\n                            best_connection = (new_node, node_b)\n                            success = True\n                            break\n            if success:\n                break\n\n        if success and best_connection is not None:\n            extracted_path = extract_path(best_connection[0], best_connection[1])\n        else:\n            extracted_path = []\n\n        return PlannerResult(success, extracted_path, nodes, edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -23.19298,
          "time_improvement": 39.0,
          "length_improvement": 16.0,
          "smoothness_improvement": 409.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.014668798446655274,
                    "num_nodes_avg": 103.2,
                    "path_length_avg": 163.66165882904005,
                    "smoothness_avg": 0.028036084167031704,
                    "success_improvement": 0.0,
                    "time_improvement": 41.870414146395845,
                    "length_improvement": 10.294451410860681,
                    "smoothness_improvement": 338.82559854525437,
                    "objective_score": 20.431923083161436
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.0317645788192749,
                    "num_nodes_avg": 292.0,
                    "path_length_avg": 238.43000837576074,
                    "smoothness_avg": 0.020539333677713312,
                    "success_improvement": 0.0,
                    "time_improvement": 80.624344656982,
                    "length_improvement": 20.40520037689976,
                    "smoothness_improvement": 428.4918494116384,
                    "objective_score": 38.572882870292645
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.051363444328308104,
                    "num_nodes_avg": 327.9,
                    "path_length_avg": 126.58071176738659,
                    "smoothness_avg": 0.04397139555819815,
                    "success_improvement": 0.0,
                    "time_improvement": -4.270345853001947,
                    "length_improvement": 15.931118369870823,
                    "smoothness_improvement": 459.3129058694746,
                    "objective_score": 10.574131795369283
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "A simplified bidirectional RRT planner that grows two trees alternately from start and goal positions by extending towards random collision-free samples with a fixed step size. It performs straightforward nearest neighbor searches via linear scans, validates nodes and edges for collisions, attempts to directly connect the trees after each extension, and stops early upon successful connection or time limit. This minimalistic approach prioritizes robustness, generalization, and computational efficiency without rewiring or adaptive parameters.",
          "planning_mechanism": "The planner samples collision-free points within map bounds, extends the nearest node in the active tree toward the sample with fixed step length, checks collisions for nodes and edges, alternates tree expansions, and tries to connect the two trees after each new node insertion. It returns the best path found within a 30-second limit or earlier if connection succeeds.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\nclass Planner:\n    def __init__(self, max_iter: int=5000, step_size: float=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.time_limit = 30.0  # seconds\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def in_obstacle(pos):\n            for o in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d = o\n                    px,py,pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x,y,w_,h_ = o\n                    px,py = pos\n                    if x <= px <= x + w_ and y <= py <= y + h_:\n                        return True\n            return False\n\n        def edge_in_obstacle(a,b,resolution=1.0):\n            dist = math.dist(a,b)\n            steps = max(1,int(dist/resolution))\n            for i in range(steps+1):\n                interp = tuple(a[d] + (b[d]-a[d]) * (i/steps) for d in range(dim))\n                if in_obstacle(interp):\n                    return True\n            return False\n\n        def steer(from_p, to_p):\n            dist = math.dist(from_p, to_p)\n            if dist <= self.step_size:\n                return to_p\n            ratio = self.step_size / dist\n            return tuple(from_p[i] + ratio*(to_p[i]-from_p[i]) for i in range(dim))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: math.dist(n.position, point))\n\n        def extract_path(node_start, node_goal):\n            path_start, path_goal = [], []\n            c = node_start\n            while c is not None:\n                path_start.append(c.position)\n                c = c.parent\n            c = node_goal\n            while c is not None:\n                path_goal.append(c.position)\n                c = c.parent\n            return path_start[::-1] + path_goal\n\n        start_tree = [Node(start_pos, cost=0.0)]\n        goal_tree = [Node(goal_pos, cost=0.0)]\n        all_nodes = start_tree + goal_tree\n        edges = []\n\n        best_cost = float('inf')\n        best_pair = None\n        success = False\n        result_path = []\n\n        start_time = time.monotonic()\n\n        for i in range(self.max_iter):\n            if time.monotonic() - start_time > self.time_limit:\n                break\n\n            # Alternate trees\n            tree_a, tree_b = (start_tree, goal_tree) if i % 2 == 0 else (goal_tree, start_tree)\n\n            # Sample free point\n            while True:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not in_obstacle(sample):\n                    break\n\n            nearest_node = nearest(tree_a, sample)\n            new_pos = steer(nearest_node.position, sample)\n            if in_obstacle(new_pos) or edge_in_obstacle(nearest_node.position, new_pos):\n                continue\n\n            new_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            new_node = Node(new_pos, nearest_node, new_cost)\n            nearest_node.add_child(new_node)\n            tree_a.append(new_node)\n            all_nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n\n            nearest_other = nearest(tree_b, new_pos)\n            if not edge_in_obstacle(new_pos, nearest_other.position):\n                total_cost = new_node.cost + nearest_other.cost + math.dist(new_pos, nearest_other.position)\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pair = (new_node, nearest_other)\n                    edges.append((new_node, nearest_other))\n                    result_path = extract_path(new_node, nearest_other)\n                    success = True\n                    break\n\n        if not success and best_pair:\n            result_path = extract_path(best_pair[0], best_pair[1])\n            success = True\n\n        return PlannerResult(success=success, path=result_path, nodes=all_nodes, edges=edges)",
          "objective": -22.62921,
          "time_improvement": 80.0,
          "length_improvement": -3.0,
          "smoothness_improvement": 84.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.009570622444152832,
                    "num_nodes_avg": 106.8,
                    "path_length_avg": 192.76832085666933,
                    "smoothness_avg": 0.011343034743691166,
                    "success_improvement": 0.0,
                    "time_improvement": 62.073490813648306,
                    "length_improvement": -5.659371271057874,
                    "smoothness_improvement": 77.5431255329582,
                    "objective_score": 15.614140109124559
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.011603641510009765,
                    "num_nodes_avg": 208.9,
                    "path_length_avg": 295.1488835150884,
                    "smoothness_avg": 0.007552260121122536,
                    "success_improvement": 0.0,
                    "time_improvement": 92.92204817507421,
                    "length_improvement": 1.4708072930911686,
                    "smoothness_improvement": 94.32509258957488,
                    "objective_score": 29.230724291324837
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.006852197647094727,
                    "num_nodes_avg": 156.5,
                    "path_length_avg": 158.5518616309143,
                    "smoothness_avg": 0.014110569175713206,
                    "success_improvement": 0.0,
                    "time_improvement": 86.08969807498055,
                    "length_improvement": -5.302597066927146,
                    "smoothness_improvement": 79.48539838119697,
                    "objective_score": 23.04277817424386
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "This algorithm implements a straightforward bidirectional RRT planner prioritizing general applicability and simplicity for 2D/3D pathfinding. It grows two trees alternately from start and goal positions by extending the nearest node toward randomly sampled free points using fixed step sizes. No rewiring or adaptive radius heuristics are applied, improving robustness and generalization. After adding new nodes, it attempts to connect the two trees directly to form a complete path. The planner terminates early if a valid path is found or a hard 30-second limit is reached, returning the best feasible path found so far.",
          "planning_mechanism": "The planner samples random free points within bounds, extends nearest nodes of alternating trees in fixed increments toward samples, and upon each new node insertion attempts to connect the other tree. Collision checks ensure all nodes and edges are obstacle-free. Planning stops early on a successful tree connection or when time expires, guaranteeing timely and general-purpose pathfinding.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.time_limit = 30.0\n\n    def plan(self, map):\n        import time\n        import math\n        import random\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def in_obstacle(pos):\n            for o in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = o\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w_, h_ = o\n                    px, py = pos\n                    if x <= px <= x + w_ and y <= py <= y + h_:\n                        return True\n            return False\n\n        def edge_in_obstacle(a, b, resolution=1.0):\n            dist = math.dist(a, b)\n            steps = max(1, int(dist / resolution))\n            for i in range(steps + 1):\n                interp = tuple(a[d] + (b[d] - a[d]) * (i / steps) for d in range(dim))\n                if in_obstacle(interp):\n                    return True\n            return False\n\n        def steer(from_p, to_p):\n            dist = math.dist(from_p, to_p)\n            if dist <= self.step_size:\n                return to_p\n            r = self.step_size / dist\n            return tuple(from_p[i] + r * (to_p[i] - from_p[i]) for i in range(dim))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: math.dist(n.position, point))\n\n        def extract_path(node_start, node_goal):\n            path_start = []\n            cur = node_start\n            while cur is not None:\n                path_start.append(cur.position)\n                cur = cur.parent\n            path_goal = []\n            cur = node_goal\n            while cur is not None:\n                path_goal.append(cur.position)\n                cur = cur.parent\n            return path_start[::-1] + path_goal\n\n        start_tree = [Node(start_pos, cost=0.0)]\n        goal_tree = [Node(goal_pos, cost=0.0)]\n        all_nodes = start_tree + goal_tree\n        edges = []\n\n        best_cost = float('inf')\n        best_pair = None\n        success = False\n        result_path = []\n\n        start_time = time.monotonic()\n\n        for i in range(self.max_iter):\n            if time.monotonic() - start_time > self.time_limit:\n                break\n\n            tree_a, tree_b = (start_tree, goal_tree) if i % 2 == 0 else (goal_tree, start_tree)\n\n            # sample free point\n            for _ in range(100):  # limit attempts to avoid infinite loop\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not in_obstacle(sample):\n                    break\n            else:\n                continue  # failed to sample free point; skip iteration\n\n            nearest_node = nearest(tree_a, sample)\n            new_pos = steer(nearest_node.position, sample)\n\n            if in_obstacle(new_pos) or edge_in_obstacle(nearest_node.position, new_pos):\n                continue\n\n            new_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            new_node = Node(new_pos, nearest_node, new_cost)\n            nearest_node.add_child(new_node)\n            tree_a.append(new_node)\n            all_nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n\n            nearest_other = nearest(tree_b, new_pos)\n            if not edge_in_obstacle(new_pos, nearest_other.position):\n                total_cost = new_node.cost + nearest_other.cost + math.dist(new_pos, nearest_other.position)\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pair = (new_node, nearest_other)\n                    edges.append((new_node, nearest_other))\n                    result_path = extract_path(new_node, nearest_other)\n                    success = True\n                    break\n\n        if not success and best_pair:\n            result_path = extract_path(best_pair[0], best_pair[1])\n            success = True\n\n        return PlannerResult(\n            success=success,\n            path=result_path,\n            nodes=all_nodes,\n            edges=edges\n        )",
          "objective": -22.40292,
          "time_improvement": 80.0,
          "length_improvement": -4.0,
          "smoothness_improvement": 84.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.009536957740783692,
                    "num_nodes_avg": 118.6,
                    "path_length_avg": 192.59619741246652,
                    "smoothness_avg": 0.011420369656766056,
                    "success_improvement": 0.0,
                    "time_improvement": 61.89080245684468,
                    "length_improvement": -5.565027683819801,
                    "smoothness_improvement": 78.75358485803187,
                    "objective_score": 15.621992051051683
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.011902427673339844,
                    "num_nodes_avg": 220.1,
                    "path_length_avg": 301.413123636028,
                    "smoothness_avg": 0.007188592015571945,
                    "success_improvement": 0.0,
                    "time_improvement": 92.720861369987,
                    "length_improvement": -0.6203763654329967,
                    "smoothness_improvement": 84.96765029420942,
                    "objective_score": 27.868870843207354
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.006809234619140625,
                    "num_nodes_avg": 142.4,
                    "path_length_avg": 157.08076258922875,
                    "smoothness_avg": 0.014697771057838723,
                    "success_improvement": 0.0,
                    "time_improvement": 86.26155573450168,
                    "length_improvement": -4.325563129648229,
                    "smoothness_improvement": 86.95456297909918,
                    "objective_score": 23.717901657457062
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e1",
          "algorithm_description": "A hybrid informed bidirectional RRT* planner leveraging batch informed sampling inside an adaptively shrinking ellipsoidal subset after the first solution, combined with efficient rewiring based on adaptive neighborhood radius, dynamic collision-check resolution proportional to edge length, and progressive incremental shortcutting during planning to improve both path length and smoothness. The planner respects a hard 30-second limit, returning the best found path, and uses early termination upon substantial solution improvements.",
          "planning_mechanism": "A bidirectional RRT* grows two trees from start and goal, alternately sampling within an ellipsoidal informed subset once a solution is found to focus search on promising areas and speed convergence. Nodes are connected with adaptive neighborhood radius rewiring that balances exploration and optimization. Dynamic collision-check resolution speeds feasibility checks proportional to edge length. The planner performs periodic and incremental shortcutting on the current best path to enhance smoothness and reduce length progressively. The search terminates either on timeout or after stable improvements, always returning the best path discovered.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\nclass Planner:\n    def __init__(self, max_iter: int = 7000, step_size: float = 5.0, goal_sample_rate: float = 0.15):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.time_limit = 30.0\n\n    def plan(self, map):\n        import time\n        import math\n        import random\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        gamma_rrt_star = 30.0\n        min_near_radius = self.step_size * 1.5\n        connect_radius_coeff = 3.5\n        shortcut_interval = 75\n        shortcut_attempts_per_cycle = 50\n\n        start_tree = [Node(start_pos, cost=0.0)]\n        goal_tree = [Node(goal_pos, cost=0.0)]\n        nodes_all = start_tree[:] + goal_tree[:]\n        edges = []\n\n        best_connection = None\n        best_cost = float('inf')\n        found_improvement = False\n        success = False\n\n        time_start = time.monotonic()\n\n        # Ellipse parameters for batch informed sampling once first path found\n        def dist(p1, p2):\n            return math.dist(p1, p2)\n\n        def sample_uniform():\n            for _ in range(30):\n                pt = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not self._is_in_obstacle(pt, obstacles, is_3d):\n                    return pt\n            return goal_pos # fallback\n\n        def ellipse_contains(pt, c, a_len, b_len, u_vec):\n            # Check if pt lies inside the prolate hyperspheroid ellipse centered at c with axes lengths a_len,b_len,...\n            # Only supports dim 2 or 3.\n            # Transform pt relative to center c and rotated by unit vector u_vec onto ellipse coordinate system.\n            # If sum of squared normalized coords <=1, inside ellipse.\n            dx = tuple(pt[i] - c[i] for i in range(dim))\n            if dim == 2:\n                # coordinate transform to align major axis with x axis\n                cos_theta = u_vec[0]\n                sin_theta = u_vec[1]\n                x_rot = dx[0]*cos_theta + dx[1]*sin_theta\n                y_rot = -dx[0]*sin_theta + dx[1]*cos_theta\n                val = (x_rot*x_rot)/(a_len*a_len) + (y_rot*y_rot)/(b_len*b_len)\n                return val <= 1.0\n            elif dim == 3:\n                # find two orthogonal unit vectors v1,v2 perpendicular to u_vec\n                import math\n                ux, uy, uz = u_vec\n                # choose v1 to be perpendicular to u_vec\n                if abs(ux) > 1e-5 or abs(uy) > 1e-5:\n                    v1 = (-uy, ux, 0.0)\n                else:\n                    v1 = (0.0, -uz, uy)\n                norm_v1 = math.sqrt(sum(x*x for x in v1))\n                if norm_v1 < 1e-12:\n                    # degenerate fallback\n                    v1 = (1.0,0.0,0.0)\n                    norm_v1 = 1.0\n                v1 = tuple(x / norm_v1 for x in v1)\n                # v2 = u_vec cross v1\n                v2 = (uy*v1[2]-uz*v1[1], uz*v1[0]-ux*v1[2], ux*v1[1]-uy*v1[0])\n                x_rot = sum(dx[i]*u_vec[i] for i in range(3))\n                y_rot = sum(dx[i]*v1[i] for i in range(3))\n                z_rot = sum(dx[i]*v2[i] for i in range(3))\n                val = (x_rot*x_rot)/(a_len*a_len) + (y_rot*y_rot)/(b_len*b_len) + (z_rot*z_rot)/(b_len*b_len)\n                return val <= 1.0\n            else:\n                return False\n\n        def batch_informed_sample():\n            # If no path yet, sample uniform free space\n            if best_connection is None:\n                return sample_uniform()\n            # Else sample within informed ellipse\n            c = tuple((start_pos[i]+goal_pos[i])/2.0 for i in range(dim))\n            c_to_s = dist(start_pos, goal_pos)/2.0\n            c_to_g = c_to_s\n            c_best = best_cost / 2.0\n            # Ellipse axis lengths: major axis = c_best, minor = sqrt(c_best^2 - c_to_s^2)\n            if c_best*c_best - c_to_s*c_to_s < 0:\n                b_len = 1e-6\n            else:\n                b_len = math.sqrt(c_best*c_best - c_to_s*c_to_s)\n            a_len = c_best\n            if a_len < 1e-6:\n                a_len = 1e-6\n            # Unit vector from start to goal\n            vector = tuple(goal_pos[i]-start_pos[i] for i in range(dim))\n            norm_v = math.sqrt(sum(x*x for x in vector))\n            if norm_v < 1e-8:\n                u_vec = tuple(1.0 for _ in range(dim))\n            else:\n                u_vec = tuple(x/norm_v for x in vector)\n            max_tries = 80\n            for _ in range(max_tries):\n                pt = []\n                # sample a random point inside unit ball in dim-d space scaled by ellipse axes\n                # sample radius uniformly to ensure uniform inside ellipse volume\n                # method: sample normal vector then scale radius^{1/dim} for uniform volume\n                # Normal vector sampling:\n                samples = [random.gauss(0.0,1.0) for _ in range(dim)]\n                norm_samps = math.sqrt(sum(s*s for s in samples))\n                unit_vec = [s/norm_samps for s in samples]\n                r = random.random() ** (1.0/dim)\n                coords = []\n                coords.append(unit_vec[0]*r*a_len)\n                for i in range(1,dim):\n                    coords.append(unit_vec[i]*r*b_len)\n                # coordinate transform back to world\n                if dim == 2:\n                    cos_theta = u_vec[0]\n                    sin_theta = u_vec[1]\n                    x = c[0] + cos_theta*coords[0] - sin_theta*coords[1]\n                    y = c[1] + sin_theta*coords[0] + cos_theta*coords[1]\n                    pt = (x,y)\n                else:\n                    # construct orthonormal basis U=[u_vec,v1,v2]\n                    # v1,v2 as defined above\n                    ux, uy, uz = u_vec\n                    if abs(ux) > 1e-5 or abs(uy) > 1e-5:\n                        v1 = (-uy, ux, 0.0)\n                    else:\n                        v1 = (0.0, -uz, uy)\n                    norm_v1 = math.sqrt(sum(x*x for x in v1))\n                    v1 = tuple(x / norm_v1 for x in v1)\n                    v2 = (uy*v1[2]-uz*v1[1], uz*v1[0]-ux*v1[2], ux*v1[1]-uy*v1[0])\n                    x = c[0] + u_vec[0]*coords[0] + v1[0]*coords[1] + v2[0]*coords[2]\n                    y = c[1] + u_vec[1]*coords[0] + v1[1]*coords[1] + v2[1]*coords[2]\n                    z = c[2] + u_vec[2]*coords[0] + v1[2]*coords[1] + v2[2]*coords[2]\n                    pt = (x,y,z)\n                # Verify within map bounds\n                if all(0.0 <= pt[i] <= bounds[i] for i in range(dim)) and not self._is_in_obstacle(pt, obstacles, is_3d):\n                    return pt\n            return sample_uniform()\n\n        def uniform_sample():\n            # Fallback uniform sample with obstacle check\n            for _ in range(30):\n                pt = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not self._is_in_obstacle(pt, obstacles, is_3d):\n                    return pt\n            return goal_pos\n\n        def sample_free():\n            # 15% goal bias for initial exploration, else batch informed if solution found\n            if best_connection is None:\n                if random.random() < self.goal_sample_rate:\n                    return goal_pos\n                else:\n                    return uniform_sample()\n            else:\n                if random.random() < self.goal_sample_rate:\n                    return goal_pos\n                return batch_informed_sample()\n\n        def steer(from_p, to_p, max_step):\n            d = dist(from_p, to_p)\n            if d <= max_step:\n                return to_p\n            ratio = max_step / d if d > 0 else 0.0\n            return tuple(from_p[i] + (to_p[i] - from_p[i]) * ratio for i in range(dim))\n\n        def nearest(tree, point):\n            best_node = None\n            best_dist = float('inf')\n            for node in tree:\n                d = dist(node.position, point)\n                if d < best_dist:\n                    best_dist = d\n                    best_node = node\n            return best_node\n\n        def near(tree, point, radius):\n            r_sq = radius * radius\n            neighbors = []\n            for node in tree:\n                d_sq = 0.0\n                for i in range(dim):\n                    dx = node.position[i] - point[i]\n                    d_sq += dx*dx\n                    if d_sq > r_sq:\n                        break\n                else:\n                    neighbors.append((math.sqrt(d_sq), node))\n            neighbors.sort(key=lambda x: x[0])\n            return [n for (_, n) in neighbors]\n\n        def extract_path(node_a, node_b):\n            path_start = []\n            cur = node_a\n            while cur is not None:\n                path_start.append(cur.position)\n                cur = cur.parent\n            path_goal = []\n            cur = node_b\n            while cur is not None:\n                path_goal.append(cur.position)\n                cur = cur.parent\n            return path_start[::-1] + path_goal\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            attempts = 0\n            changed = True\n            while changed and attempts < shortcut_attempts_per_cycle:\n                changed = False\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                resolution = max(self.step_size * 0.15, 0.5)\n                if not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution=resolution):\n                    path = path[:i+1] + path[j:]\n                    changed = True\n                attempts += 1\n            return path\n\n        def try_connect(node, other_tree, radius):\n            candidates = near(other_tree, node.position, radius)\n            best_node = None\n            best_total_cost = float('inf')\n            for cnode in candidates:\n                d = dist(node.position, cnode.position)\n                if d > radius:\n                    continue\n                if self._is_edge_in_obstacle(node.position, cnode.position, obstacles, is_3d, resolution=max(self.step_size*0.1,0.5)):\n                    continue\n                total_cost = node.cost + cnode.cost + d\n                if total_cost < best_total_cost:\n                    best_total_cost = total_cost\n                    best_node = cnode\n            return best_node, best_total_cost\n\n        # Rewiring helper\n        def rewire(tree, new_node, near_nodes):\n            for near_node in near_nodes:\n                if near_node is new_node.parent:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, near_node.position)\n                if new_cost + 1e-9 < near_node.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d,\n                                                     resolution=max(self.step_size*0.1,0.5)):\n                        # Remove old parent-child relation\n                        if near_node.parent:\n                            try:\n                                edges.remove((near_node.parent, near_node))\n                            except ValueError:\n                                pass\n                            near_node.parent.remove_child(near_node)\n                        near_node.parent = new_node\n                        near_node.cost = new_cost\n                        new_node.add_child(near_node)\n                        edges.append((new_node, near_node))\n\n        extracted_path = []\n        for iter in range(self.max_iter):\n            elapsed = time.monotonic() - time_start\n            if elapsed > self.time_limit:\n                break\n\n            tree_a, tree_b = (start_tree, goal_tree) if (iter % 2 == 0) else (goal_tree, start_tree)\n\n            sample = sample_free()\n\n            nearest_node = nearest(tree_a, sample)\n            new_pos = steer(nearest_node.position, sample, self.step_size)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            # Collision check resolution proportional to edge length but bounded below\n            edge_length = dist(nearest_node.position, new_pos)\n            resolution = max(edge_length * 0.12, 0.5)\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d, resolution):\n                continue\n\n            n_nodes = len(tree_a) + 1\n            near_radius = max(min_near_radius, gamma_rrt_star * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim)))\n            near_radius = min(near_radius, self.step_size * 6.0)\n\n            near_nodes = near(tree_a, new_pos, near_radius)\n\n            # Choose parent minimizing cost + dist with collision check\n            parent_node = nearest_node\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            for near_node in near_nodes:\n                cost_candidate = near_node.cost + dist(near_node.position, new_pos)\n                if cost_candidate + 1e-12 < min_cost:\n                    if not self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d, resolution):\n                        min_cost = cost_candidate\n                        parent_node = near_node\n\n            new_node = Node(new_pos, parent=parent_node, cost=min_cost)\n            parent_node.add_child(new_node)\n            tree_a.append(new_node)\n            nodes_all.append(new_node)\n            edges.append((parent_node, new_node))\n\n            # Rewire neighbors to new_node if path cost improves\n            rewire(tree_a, new_node, near_nodes)\n\n            # Attempt multiple candidate connections to the opposite tree\n            connect_radius = self.step_size * connect_radius_coeff\n            conn_node, conn_cost = try_connect(new_node, tree_b, connect_radius)\n            if conn_node and conn_cost + 1e-9 < best_cost:\n                best_cost = conn_cost\n                best_connection = (new_node, conn_node)\n                success = True\n                found_improvement = True\n                # Early stop on improvement\n                break\n\n            # Periodic incremental shortcutting of the best path found so far (if any)\n            if found_improvement and (iter % shortcut_interval == 0) and best_connection is not None:\n                raw_path = extract_path(best_connection[0], best_connection[1])\n                refined_path = shortcut_path(raw_path)\n                # Accept if refined shorter than raw\n                raw_len = sum(dist(raw_path[i], raw_path[i+1]) for i in range(len(raw_path)-1))\n                refined_len = sum(dist(refined_path[i], refined_path[i+1]) for i in range(len(refined_path)-1))\n                if refined_len + 1e-7 < raw_len:\n                    extracted_path = refined_path\n                    best_cost = refined_len\n                else:\n                    extracted_path = raw_path\n\n        # If no direct connection found, try connecting closest pair across two trees after iterations or timeout\n        if not success or best_connection is None:\n            best_pair = None\n            best_pair_cost = float('inf')\n            for n_s in start_tree:\n                near_goal_nodes = near(goal_tree, n_s.position, self.step_size*connect_radius_coeff)\n                for n_g in near_goal_nodes:\n                    dng = dist(n_s.position, n_g.position)\n                    if dng <= self.step_size*connect_radius_coeff:\n                        if not self._is_edge_in_obstacle(n_s.position, n_g.position, obstacles, is_3d,\n                                                        resolution=max(dng*0.1, 0.5)):\n                            total_c = n_s.cost + n_g.cost + dng\n                            if total_c < best_pair_cost:\n                                best_pair_cost = total_c\n                                best_pair = (n_s, n_g)\n\n            if best_pair is not None:\n                best_connection = best_pair\n                best_cost = best_pair_cost\n                success = True\n                path_raw = extract_path(best_connection[0], best_connection[1])\n                extracted_path = shortcut_path(path_raw)\n            else:\n                extracted_path = []\n\n        else:\n            # Final shortcut before returning\n            if best_connection is not None and (not extracted_path):\n                path_raw = extract_path(best_connection[0], best_connection[1])\n                extracted_path = shortcut_path(path_raw)\n\n        return {\n            \"success\": success,\n            \"path\": extracted_path,\n            \"nodes\": nodes_all,\n            \"edges\": edges\n        }\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -22.17681,
          "time_improvement": 59.0,
          "length_improvement": 6.0,
          "smoothness_improvement": 161.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.015401244163513184,
                    "num_nodes_avg": 122.1,
                    "path_length_avg": 180.2060390843688,
                    "smoothness_avg": 0.017777806694130656,
                    "success_improvement": 0.0,
                    "time_improvement": 38.96787469600858,
                    "length_improvement": 1.2262144304333007,
                    "smoothness_improvement": 178.26127988827753,
                    "objective_score": 13.317397466503941
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.02993757724761963,
                    "num_nodes_avg": 287.8,
                    "path_length_avg": 279.1283728908018,
                    "smoothness_avg": 0.008827102174618188,
                    "success_improvement": 0.0,
                    "time_improvement": 81.73877318332734,
                    "length_improvement": 6.818914864308597,
                    "smoothness_improvement": 127.12769685763392,
                    "objective_score": 29.24861935787153
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.020873546600341797,
                    "num_nodes_avg": 212.0,
                    "path_length_avg": 136.03132382378095,
                    "smoothness_avg": 0.021761838309354832,
                    "success_improvement": 0.0,
                    "time_improvement": 57.62566253764927,
                    "length_improvement": 9.654471831800143,
                    "smoothness_improvement": 176.80897700317777,
                    "objective_score": 23.964426745390757
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "cross_over",
          "algorithm_description": "An optimized bidirectional RRT*-based planner incorporating goal biasing, dynamic adaptive rewiring radius, efficient incremental collision checking with adaptive resolution, and iterative shortcutting for path smoothing. The algorithm uses alternating tree expansions with improved nearest neighbor searches and multiple candidate connections to accelerate convergence, maintaining a strict 30-second limit. Continuous path cost tracking and rewiring ensure near-optimal path lengths while lightweight shortcutting improves smoothness and reduces unnecessary waypoints. Early termination on time or successful path discovery guarantees computational efficiency.",
          "planning_mechanism": "The planner grows two trees from start and goal, sampling mostly free space with goal bias. It extends nodes toward samples using a fine step size, rewires nearby nodes within a dynamically shrinking neighborhood radius computed from node count and dimension, attempts multiple connection candidates between trees, and upon connection applies iterative shortcutting. Collision checks adapt resolution based on edge length for efficiency. The planner updates best path continuously and returns the best feasible path if time expires.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children: List[Node] = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=4.0, goal_sample_rate: float=0.2):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.time_limit = 30.0\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        start_tree = [Node(start_pos, cost=0.0)]\n        goal_tree = [Node(goal_pos, cost=0.0)]\n        nodes = start_tree[:] + goal_tree[:]\n        edges = []\n\n        gamma_rrt_star = 20.0  # Smaller gamma for adaptive radius to reduce neighbor overhead\n\n        success = False\n        best_cost = float('inf')\n        best_connection = None\n        extracted_path: List[Tuple[float,...]] = []\n\n        step_size = self.step_size\n\n        def dist(a, b):\n            # Euclidean distance\n            return math.dist(a, b)\n\n        def sample_free():\n            # Goal biasing sampler with max 30 attempts\n            if random.random() < self.goal_sample_rate:\n                return goal_pos\n            for _ in range(30):\n                p = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n            return goal_pos  # fallback\n\n        def nearest(tree, point):\n            min_node = None\n            min_dist = float('inf')\n            for node in tree:\n                d = dist(node.position, point)\n                if d < min_dist:\n                    min_dist = d\n                    min_node = node\n            return min_node\n\n        def near(tree, point, radius):\n            neighbors = []\n            for node in tree:\n                d = dist(node.position, point)\n                if d <= radius:\n                    neighbors.append((d, node))\n            neighbors.sort(key=lambda x: x[0])\n            return [n[1] for n in neighbors]\n\n        def steer(from_p, to_p, max_step):\n            d = dist(from_p, to_p)\n            if d <= max_step:\n                return to_p\n            ratio = max_step / d\n            return tuple(from_p[i] + (to_p[i] - from_p[i]) * ratio for i in range(dim))\n\n        def extract_path(node_start, node_goal):\n            # Trace back parents from start node to root\n            path_start = []\n            c = node_start\n            while c is not None:\n                path_start.append(c.position)\n                c = c.parent\n            # Trace back parents from goal node to root\n            path_goal = []\n            c = node_goal\n            while c is not None:\n                path_goal.append(c.position)\n                c = c.parent\n            return path_start[::-1] + path_goal\n\n        def shortcut_path(path):\n            # Iterative shortcutting tries 100 times to connect random pairs with collision-free edges\n            if len(path) < 3:\n                return path\n            for _ in range(100):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d,\n                        resolution=max(0.1,self.step_size*0.05)):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        def adaptive_edge_resolution(p1, p2):\n            # Edge collision check resolution adapts from edge length, min 0.1, max step_size/3\n            length = dist(p1, p2)\n            return max(0.1, min(self.step_size/3, length/10))\n\n        def try_connect(new_node, other_tree):\n            # Get multiple near candidates in other tree within connection radius\n            connection_radius = self.step_size * 2.5\n            candidates = near(other_tree, new_node.position, connection_radius)\n            best_node = None\n            best_cost_local = float('inf')\n            for cnode in candidates:\n                d = dist(new_node.position, cnode.position)\n                if d <= connection_radius:\n                    if not self._is_edge_in_obstacle(new_node.position, cnode.position, obstacles, is_3d,\n                                                    resolution=adaptive_edge_resolution(new_node.position,cnode.position)):\n                        total_cost = new_node.cost + cnode.cost + d\n                        if total_cost < best_cost_local:\n                            best_cost_local = total_cost\n                            best_node = cnode\n            return best_node, best_cost_local\n\n        start_time = time.monotonic()\n        for iter_count in range(self.max_iter):\n            if time.monotonic() - start_time > self.time_limit:\n                break\n\n            # Alternate tree growth\n            tree_a = start_tree if iter_count % 2 == 0 else goal_tree\n            tree_b = goal_tree if iter_count % 2 == 0 else start_tree\n\n            sample = sample_free()\n            nearest_node = nearest(tree_a, sample)\n            new_pos = steer(nearest_node.position, sample, step_size)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d,\n                                         resolution=adaptive_edge_resolution(nearest_node.position, new_pos)):\n                continue\n\n            n_nodes = len(tree_a) + 1\n            radius = min(step_size * 5, gamma_rrt_star * (math.log(n_nodes) / n_nodes) ** (1/dim))\n\n            near_nodes = near(tree_a, new_pos, radius)\n\n            # Choose best parent (minimum cost)\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            min_parent = nearest_node\n            for near_node in near_nodes:\n                cost_through = near_node.cost + dist(near_node.position, new_pos)\n                if cost_through < min_cost:\n                    if not self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d,\n                                                    resolution=adaptive_edge_resolution(near_node.position,new_pos)):\n                        min_cost = cost_through\n                        min_parent = near_node\n\n            new_node = Node(new_pos, parent=min_parent, cost=min_cost)\n            min_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((min_parent, new_node))\n\n            # Rewire neighbors with better cost paths\n            for near_node in near_nodes:\n                if near_node == min_parent:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, near_node.position)\n                if new_cost < near_node.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d,\n                                                    resolution=adaptive_edge_resolution(new_node.position, near_node.position)):\n                        # Remove old edge safely\n                        if near_node.parent:\n                            try:\n                                edges.remove((near_node.parent, near_node))\n                            except ValueError:\n                                pass\n                            near_node.parent.remove_child(near_node)\n                        near_node.parent = new_node\n                        near_node.cost = new_cost\n                        new_node.add_child(near_node)\n                        edges.append((new_node, near_node))\n\n            # Attempt multiple candidate connection to other tree\n            conn_node, conn_cost = try_connect(new_node, tree_b)\n            if conn_node and conn_cost < best_cost:\n                best_cost = conn_cost\n                best_connection = (new_node, conn_node)\n                success = True\n                # Early stopping here for efficiency\n                break\n\n        if success and best_connection is not None:\n            path = extract_path(best_connection[0], best_connection[1])\n            path = shortcut_path(path)\n            extracted_path = path\n        else:\n            # Attempt best partial connection on timeout or failure\n            min_cost = float('inf')\n            best_pair = None\n            for n1 in start_tree:\n                candidates = near(goal_tree, n1.position, step_size * 2.5)\n                for n2 in candidates:\n                    d12 = dist(n1.position, n2.position)\n                    if d12 <= step_size * 2.5:\n                        if not self._is_edge_in_obstacle(n1.position, n2.position, obstacles, is_3d,\n                                                        resolution=adaptive_edge_resolution(n1.position, n2.position)):\n                            total_cost = n1.cost + n2.cost + d12\n                            if total_cost < min_cost:\n                                min_cost = total_cost\n                                best_pair = (n1, n2)\n            if best_pair is not None:\n                path = extract_path(best_pair[0], best_pair[1])\n                path = shortcut_path(path)\n                extracted_path = path\n                success = True\n\n        return PlannerResult(\n            success=success,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -21.99245,
          "time_improvement": 20.0,
          "length_improvement": 14.0,
          "smoothness_improvement": 1523.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.03138778209686279,
                    "num_nodes_avg": 163.2,
                    "path_length_avg": 167.21015564949224,
                    "smoothness_avg": 0.04103033539568809,
                    "success_improvement": 0.0,
                    "time_improvement": -25.423979101386283,
                    "length_improvement": 8.349464074040423,
                    "smoothness_improvement": 542.213847741906,
                    "objective_score": 0.09355395271789968
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.053638553619384764,
                    "num_nodes_avg": 436.8,
                    "path_length_avg": 246.5065194564645,
                    "smoothness_avg": 0.10805898201144767,
                    "success_improvement": 0.0,
                    "time_improvement": 67.19640073231147,
                    "length_improvement": 17.709028508679005,
                    "smoothness_improvement": 2680.435438893309,
                    "objective_score": 44.18651451936739
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.040125346183776854,
                    "num_nodes_avg": 359.0,
                    "path_length_avg": 127.36695570951193,
                    "smoothness_avg": 0.11382510858983455,
                    "success_improvement": 0.0,
                    "time_improvement": 19.042320758038862,
                    "length_improvement": 15.40893258042441,
                    "smoothness_improvement": 1347.8469795671333,
                    "objective_score": 21.69729067350197
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m2",
          "algorithm_description": "This algorithm implements a bidirectional RRT* planner with refined parameters for step size, sampling bias, rewiring radius, and connection attempts. It incorporates bounded sampling retries, dynamic rewiring radius adapted to node count and dimension, multi-neighbor connections between trees, and iterative path shortcutting triggered at fixed iteration intervals to improve path smoothness and length without sacrificing planning efficiency. The algorithm stops early upon finding a sufficient solution or after a 30-second timeout, always returning the best path discovered.",
          "planning_mechanism": "The planner alternately grows two trees from start and goal by sampling with a goal bias and retry limit, steering towards sampled points with a tuned step size. Nodes connect and rewire according to an adaptive radius computed logarithmically with node count and dimension, improving path quality progressively. Upon each new node addition, multiple candidate connections are attempted with the opposite tree within an extended radius to boost connectivity. Shortcuts are applied every 100 iterations on the best current path to smooth and shorten it. The planner executes until a path connects both trees or a 30-second time limit is reached, outputting the best path found with its nodes and edges.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=6.0, goal_sample_rate=0.25):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.time_limit = 30.0\n        self.sample_retry_limit = 30\n\n    def plan(self, map):\n        import time\n        import math\n        import random\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def dist_sq(a, b):\n            return sum((a[i] - b[i]) ** 2 for i in range(dim))\n\n        def sample_free():\n            if random.random() < self.goal_sample_rate:\n                return goal_pos\n            for _ in range(self.sample_retry_limit):\n                p = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n            return goal_pos\n\n        def steer(from_p, to_p, max_step):\n            d = dist(from_p, to_p)\n            if d <= max_step:\n                return to_p\n            ratio = max_step / d\n            return tuple(from_p[i] + (to_p[i] - from_p[i]) * ratio for i in range(dim))\n\n        def nearest(tree, point):\n            best_node = None\n            best_dist_sq = float('inf')\n            for node in tree:\n                d2 = dist_sq(node.position, point)\n                if d2 < best_dist_sq:\n                    best_dist_sq = d2\n                    best_node = node\n            return best_node\n\n        def near(tree, point, radius):\n            r_sq = radius * radius\n            near_nodes = [(dist_sq(n.position, point), n) for n in tree if dist_sq(n.position, point) <= r_sq]\n            near_nodes.sort(key=lambda x: x[0])\n            return [n for _, n in near_nodes]\n\n        def extract_path(node_start, node_goal):\n            path_start = []\n            current = node_start\n            while current:\n                path_start.append(current.position)\n                current = current.parent\n            path_goal = []\n            current = node_goal\n            while current:\n                path_goal.append(current.position)\n                current = current.parent\n            return path_start[::-1] + path_goal\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            attempts = 0\n            max_attempts = 100\n            resolution = max(0.2, self.step_size * 0.1)\n            while attempts < max_attempts and len(path) >= 3:\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d, resolution=resolution):\n                    path = path[:i + 1] + path[j:]\n                attempts += 1\n            return path\n\n        def update_parent(child, new_parent, new_cost):\n            if child.parent is not None:\n                try:\n                    edges.remove((child.parent, child))\n                except ValueError:\n                    pass\n                child.parent.remove_child(child)\n            child.parent = new_parent\n            child.cost = new_cost\n            new_parent.add_child(child)\n            edges.append((new_parent, child))\n\n        def propagate_costs(node):\n            stack = [node]\n            while stack:\n                current = stack.pop()\n                for c in current.children:\n                    new_cost = current.cost + dist(current.position, c.position)\n                    if abs(new_cost - c.cost) > 1e-12:\n                        c.cost = new_cost\n                        stack.append(c)\n\n        def try_connect(new_node, other_tree, connect_radius):\n            candidates = near(other_tree, new_node.position, connect_radius)\n            best_node = None\n            best_cost = float('inf')\n            for c in candidates:\n                edge_dist = dist(new_node.position, c.position)\n                if edge_dist <= connect_radius:\n                    if not self._is_edge_in_obstacle(new_node.position, c.position, obstacles, is_3d):\n                        total_cost = new_node.cost + c.cost + edge_dist\n                        if total_cost < best_cost:\n                            best_cost = total_cost\n                            best_node = c\n            return best_node, best_cost\n\n        start_tree = [Node(start_pos, cost=0.0)]\n        goal_tree = [Node(goal_pos, cost=0.0)]\n        nodes = start_tree[:] + goal_tree[:]\n        edges = []\n        gamma_rrt_star = 30.0\n        best_connection = None\n        best_cost = float('inf')\n        success = False\n        extracted_path = []\n\n        start_time = time.monotonic()\n\n        for iteration in range(self.max_iter):\n            if time.monotonic() - start_time > self.time_limit:\n                break\n\n            # Alternate between trees\n            if iteration % 2 == 0:\n                tree_a, tree_b = start_tree, goal_tree\n            else:\n                tree_a, tree_b = goal_tree, start_tree\n\n            sample = sample_free()\n            nearest_node = nearest(tree_a, sample)\n            new_pos = steer(nearest_node.position, sample, self.step_size)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            n_nodes = len(tree_a) + 1\n            radius = gamma_rrt_star * (math.log(max(n_nodes, 2)) / n_nodes) ** (1 / dim)\n            radius = min(radius, self.step_size * 4.0)\n            radius = max(radius, self.step_size * 2.0)\n\n            near_nodes = near(tree_a, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            min_parent = nearest_node\n            for near_node in near_nodes:\n                cost_tmp = near_node.cost + dist(near_node.position, new_pos)\n                if cost_tmp + 1e-10 < min_cost:\n                    if not self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d):\n                        min_cost = cost_tmp\n                        min_parent = near_node\n\n            new_node = Node(new_pos, parent=min_parent, cost=min_cost)\n            min_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((min_parent, new_node))\n\n            for near_node in near_nodes:\n                if near_node is min_parent:\n                    continue\n                rewired_cost = new_node.cost + dist(new_node.position, near_node.position)\n                if rewired_cost + 1e-12 < near_node.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                        update_parent(near_node, new_node, rewired_cost)\n                        propagate_costs(near_node)\n\n            connect_radius = self.step_size * 3.5\n            conn_node, conn_cost = try_connect(new_node, tree_b, connect_radius)\n            if conn_node is not None and conn_cost < best_cost:\n                best_cost = conn_cost\n                best_connection = (new_node, conn_node)\n                success = True\n\n                # Early stop if improved path found after minimum iterations\n                if iteration > 60:\n                    break\n\n            if success and best_connection and iteration % 100 == 0:\n                path = extract_path(best_connection[0], best_connection[1])\n                path = shortcut_path(path)\n                extracted_path = path\n\n        if success and best_connection:\n            extracted_path = extract_path(best_connection[0], best_connection[1])\n            extracted_path = shortcut_path(extracted_path)\n        else:\n            # Attempt to join closest nodes if no exact connection\n            min_cost = float('inf')\n            best_pair = None\n            for n1 in start_tree:\n                candidates = near(goal_tree, n1.position, self.step_size * 3.5)\n                for n2 in candidates:\n                    dist_ = dist(n1.position, n2.position)\n                    if dist_ <= self.step_size * 3.5:\n                        if not self._is_edge_in_obstacle(n1.position, n2.position, obstacles, is_3d):\n                            total_c = n1.cost + n2.cost + dist_\n                            if total_c < min_cost:\n                                min_cost = total_c\n                                best_pair = (n1, n2)\n            if best_pair:\n                extracted_path = extract_path(best_pair[0], best_pair[1])\n                extracted_path = shortcut_path(extracted_path)\n                success = True\n            else:\n                extracted_path = []\n\n        return PlannerResult(\n            success=success,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -21.79279,
          "time_improvement": 24.0,
          "length_improvement": 13.0,
          "smoothness_improvement": 1323.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.02416062355041504,
                    "num_nodes_avg": 114.0,
                    "path_length_avg": 176.99037189238447,
                    "smoothness_avg": 0.04017511897888593,
                    "success_improvement": 0.0,
                    "time_improvement": 4.256163443932362,
                    "length_improvement": 2.9887725738673576,
                    "smoothness_improvement": 528.8278536867788,
                    "objective_score": 5.714251845934017
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.09086897373199462,
                    "num_nodes_avg": 306.2,
                    "path_length_avg": 235.34604891065732,
                    "smoothness_avg": 0.0851142698164726,
                    "success_improvement": 0.0,
                    "time_improvement": 44.572036467975636,
                    "length_improvement": 21.43471481320267,
                    "smoothness_improvement": 2090.0514677084084,
                    "objective_score": 36.682697166856336
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.03740153312683105,
                    "num_nodes_avg": 174.2,
                    "path_length_avg": 127.95174837067638,
                    "smoothness_avg": 0.11395012731757459,
                    "success_improvement": 0.0,
                    "time_improvement": 24.073028092903133,
                    "length_improvement": 15.020541139713064,
                    "smoothness_improvement": 1349.4372085560642,
                    "objective_score": 22.9814191544791
               }
          ],
          "success_rate": 1.0
     }
]