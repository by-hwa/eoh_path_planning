{
    "operator": "e1",
    "algorithm_description": null,
    "planning_mechanism": null,
    "code": null,
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "success_rate": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 114, in evaluate\n    exec(self.import_string+code_string, planning_module.__dict__)\nTypeError: can only concatenate str (not \"NoneType\") to str\n"
    }
}
{
    "operator": "e1",
    "algorithm_description": null,
    "planning_mechanism": null,
    "code": null,
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "success_rate": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 114, in evaluate\n    exec(self.import_string+code_string, planning_module.__dict__)\nTypeError: can only concatenate str (not \"NoneType\") to str\n"
    }
}
{
    "operator": "e1",
    "algorithm_description": null,
    "planning_mechanism": null,
    "code": null,
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "success_rate": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 114, in evaluate\n    exec(self.import_string+code_string, planning_module.__dict__)\nTypeError: can only concatenate str (not \"NoneType\") to str\n"
    }
}
{
    "operator": "e1",
    "algorithm_description": null,
    "planning_mechanism": null,
    "code": null,
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "success_rate": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 114, in evaluate\n    exec(self.import_string+code_string, planning_module.__dict__)\nTypeError: can only concatenate str (not \"NoneType\") to str\n"
    }
}
{
    "operator": "e2",
    "algorithm_description": null,
    "planning_mechanism": null,
    "code": null,
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "success_rate": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 114, in evaluate\n    exec(self.import_string+code_string, planning_module.__dict__)\nTypeError: can only concatenate str (not \"NoneType\") to str\n"
    }
}
{
    "operator": "e2",
    "algorithm_description": null,
    "planning_mechanism": null,
    "code": null,
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "success_rate": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 114, in evaluate\n    exec(self.import_string+code_string, planning_module.__dict__)\nTypeError: can only concatenate str (not \"NoneType\") to str\n"
    }
}
{
    "operator": "e2",
    "algorithm_description": null,
    "planning_mechanism": null,
    "code": null,
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "success_rate": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 114, in evaluate\n    exec(self.import_string+code_string, planning_module.__dict__)\nTypeError: can only concatenate str (not \"NoneType\") to str\n"
    }
}
{
    "operator": "e2",
    "algorithm_description": null,
    "planning_mechanism": null,
    "code": null,
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "success_rate": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 114, in evaluate\n    exec(self.import_string+code_string, planning_module.__dict__)\nTypeError: can only concatenate str (not \"NoneType\") to str\n"
    }
}
{
    "operator": "m1",
    "algorithm_description": null,
    "planning_mechanism": null,
    "code": null,
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "success_rate": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 114, in evaluate\n    exec(self.import_string+code_string, planning_module.__dict__)\nTypeError: can only concatenate str (not \"NoneType\") to str\n"
    }
}
{
    "operator": "m1",
    "algorithm_description": null,
    "planning_mechanism": null,
    "code": null,
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "success_rate": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 114, in evaluate\n    exec(self.import_string+code_string, planning_module.__dict__)\nTypeError: can only concatenate str (not \"NoneType\") to str\n"
    }
}
{
    "operator": "m1",
    "algorithm_description": null,
    "planning_mechanism": null,
    "code": null,
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "success_rate": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 114, in evaluate\n    exec(self.import_string+code_string, planning_module.__dict__)\nTypeError: can only concatenate str (not \"NoneType\") to str\n"
    }
}
{
    "operator": "m1",
    "algorithm_description": null,
    "planning_mechanism": null,
    "code": null,
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "success_rate": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 114, in evaluate\n    exec(self.import_string+code_string, planning_module.__dict__)\nTypeError: can only concatenate str (not \"NoneType\") to str\n"
    }
}
{
    "operator": "m2",
    "algorithm_description": null,
    "planning_mechanism": null,
    "code": null,
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "success_rate": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 114, in evaluate\n    exec(self.import_string+code_string, planning_module.__dict__)\nTypeError: can only concatenate str (not \"NoneType\") to str\n"
    }
}
{
    "operator": "m2",
    "algorithm_description": null,
    "planning_mechanism": null,
    "code": null,
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "success_rate": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 114, in evaluate\n    exec(self.import_string+code_string, planning_module.__dict__)\nTypeError: can only concatenate str (not \"NoneType\") to str\n"
    }
}
{
    "operator": "m2",
    "algorithm_description": null,
    "planning_mechanism": null,
    "code": null,
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "success_rate": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 114, in evaluate\n    exec(self.import_string+code_string, planning_module.__dict__)\nTypeError: can only concatenate str (not \"NoneType\") to str\n"
    }
}
{
    "operator": "m2",
    "algorithm_description": null,
    "planning_mechanism": null,
    "code": null,
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "success_rate": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 114, in evaluate\n    exec(self.import_string+code_string, planning_module.__dict__)\nTypeError: can only concatenate str (not \"NoneType\") to str\n"
    }
}
{
    "operator": "m3",
    "algorithm_description": null,
    "planning_mechanism": null,
    "code": null,
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "success_rate": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 114, in evaluate\n    exec(self.import_string+code_string, planning_module.__dict__)\nTypeError: can only concatenate str (not \"NoneType\") to str\n"
    }
}
{
    "operator": "m3",
    "algorithm_description": null,
    "planning_mechanism": null,
    "code": null,
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "success_rate": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 114, in evaluate\n    exec(self.import_string+code_string, planning_module.__dict__)\nTypeError: can only concatenate str (not \"NoneType\") to str\n"
    }
}
{
    "operator": "m3",
    "algorithm_description": null,
    "planning_mechanism": null,
    "code": null,
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "success_rate": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 114, in evaluate\n    exec(self.import_string+code_string, planning_module.__dict__)\nTypeError: can only concatenate str (not \"NoneType\") to str\n"
    }
}
{
    "operator": "m3",
    "algorithm_description": null,
    "planning_mechanism": null,
    "code": null,
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "success_rate": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 114, in evaluate\n    exec(self.import_string+code_string, planning_module.__dict__)\nTypeError: can only concatenate str (not \"NoneType\") to str\n"
    }
}
{
    "operator": "cross_over",
    "algorithm_description": null,
    "planning_mechanism": null,
    "code": null,
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "success_rate": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 114, in evaluate\n    exec(self.import_string+code_string, planning_module.__dict__)\nTypeError: can only concatenate str (not \"NoneType\") to str\n"
    }
}
{
    "operator": "cross_over",
    "algorithm_description": null,
    "planning_mechanism": null,
    "code": null,
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "success_rate": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 114, in evaluate\n    exec(self.import_string+code_string, planning_module.__dict__)\nTypeError: can only concatenate str (not \"NoneType\") to str\n"
    }
}
{
    "operator": "cross_over",
    "algorithm_description": null,
    "planning_mechanism": null,
    "code": null,
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "success_rate": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 114, in evaluate\n    exec(self.import_string+code_string, planning_module.__dict__)\nTypeError: can only concatenate str (not \"NoneType\") to str\n"
    }
}
{
    "operator": "cross_over",
    "algorithm_description": null,
    "planning_mechanism": null,
    "code": null,
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "success_rate": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 114, in evaluate\n    exec(self.import_string+code_string, planning_module.__dict__)\nTypeError: can only concatenate str (not \"NoneType\") to str\n"
    }
}
{
    "operator": "time_expert",
    "algorithm_description": null,
    "planning_mechanism": null,
    "code": null,
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "success_rate": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 114, in evaluate\n    exec(self.import_string+code_string, planning_module.__dict__)\nTypeError: can only concatenate str (not \"NoneType\") to str\n"
    }
}
{
    "operator": "time_expert",
    "algorithm_description": null,
    "planning_mechanism": null,
    "code": null,
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "success_rate": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 114, in evaluate\n    exec(self.import_string+code_string, planning_module.__dict__)\nTypeError: can only concatenate str (not \"NoneType\") to str\n"
    }
}
{
    "operator": "time_expert",
    "algorithm_description": null,
    "planning_mechanism": null,
    "code": null,
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "success_rate": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 114, in evaluate\n    exec(self.import_string+code_string, planning_module.__dict__)\nTypeError: can only concatenate str (not \"NoneType\") to str\n"
    }
}
{
    "operator": "time_expert",
    "algorithm_description": null,
    "planning_mechanism": null,
    "code": null,
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "success_rate": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 114, in evaluate\n    exec(self.import_string+code_string, planning_module.__dict__)\nTypeError: can only concatenate str (not \"NoneType\") to str\n"
    }
}
{
    "operator": "path_expert",
    "algorithm_description": null,
    "planning_mechanism": null,
    "code": null,
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "success_rate": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 114, in evaluate\n    exec(self.import_string+code_string, planning_module.__dict__)\nTypeError: can only concatenate str (not \"NoneType\") to str\n"
    }
}
{
    "operator": "path_expert",
    "algorithm_description": null,
    "planning_mechanism": null,
    "code": null,
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "success_rate": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 114, in evaluate\n    exec(self.import_string+code_string, planning_module.__dict__)\nTypeError: can only concatenate str (not \"NoneType\") to str\n"
    }
}
{
    "operator": "path_expert",
    "algorithm_description": null,
    "planning_mechanism": null,
    "code": null,
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "success_rate": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 114, in evaluate\n    exec(self.import_string+code_string, planning_module.__dict__)\nTypeError: can only concatenate str (not \"NoneType\") to str\n"
    }
}
{
    "operator": "path_expert",
    "algorithm_description": null,
    "planning_mechanism": null,
    "code": null,
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "success_rate": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 114, in evaluate\n    exec(self.import_string+code_string, planning_module.__dict__)\nTypeError: can only concatenate str (not \"NoneType\") to str\n"
    }
}
{
    "operator": "e1",
    "algorithm_description": null,
    "planning_mechanism": null,
    "code": null,
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "success_rate": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 114, in evaluate\n    exec(self.import_string+code_string, planning_module.__dict__)\nTypeError: can only concatenate str (not \"NoneType\") to str\n"
    }
}
{
    "operator": "e1",
    "algorithm_description": null,
    "planning_mechanism": null,
    "code": null,
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "success_rate": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 114, in evaluate\n    exec(self.import_string+code_string, planning_module.__dict__)\nTypeError: can only concatenate str (not \"NoneType\") to str\n"
    }
}
{
    "operator": "e1",
    "algorithm_description": null,
    "planning_mechanism": null,
    "code": null,
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "success_rate": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 114, in evaluate\n    exec(self.import_string+code_string, planning_module.__dict__)\nTypeError: can only concatenate str (not \"NoneType\") to str\n"
    }
}
{
    "operator": "e1",
    "algorithm_description": null,
    "planning_mechanism": null,
    "code": null,
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "success_rate": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 114, in evaluate\n    exec(self.import_string+code_string, planning_module.__dict__)\nTypeError: can only concatenate str (not \"NoneType\") to str\n"
    }
}
{
    "operator": "e2",
    "algorithm_description": null,
    "planning_mechanism": null,
    "code": null,
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "success_rate": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 114, in evaluate\n    exec(self.import_string+code_string, planning_module.__dict__)\nTypeError: can only concatenate str (not \"NoneType\") to str\n"
    }
}
{
    "operator": "e2",
    "algorithm_description": null,
    "planning_mechanism": null,
    "code": null,
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "success_rate": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 114, in evaluate\n    exec(self.import_string+code_string, planning_module.__dict__)\nTypeError: can only concatenate str (not \"NoneType\") to str\n"
    }
}
{
    "operator": "e2",
    "algorithm_description": null,
    "planning_mechanism": null,
    "code": null,
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "success_rate": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 114, in evaluate\n    exec(self.import_string+code_string, planning_module.__dict__)\nTypeError: can only concatenate str (not \"NoneType\") to str\n"
    }
}
{
    "operator": "e2",
    "algorithm_description": null,
    "planning_mechanism": null,
    "code": null,
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "success_rate": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 114, in evaluate\n    exec(self.import_string+code_string, planning_module.__dict__)\nTypeError: can only concatenate str (not \"NoneType\") to str\n"
    }
}
{
    "operator": "m1",
    "algorithm_description": null,
    "planning_mechanism": null,
    "code": null,
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "success_rate": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 114, in evaluate\n    exec(self.import_string+code_string, planning_module.__dict__)\nTypeError: can only concatenate str (not \"NoneType\") to str\n"
    }
}
{
    "operator": "m1",
    "algorithm_description": null,
    "planning_mechanism": null,
    "code": null,
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "success_rate": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 114, in evaluate\n    exec(self.import_string+code_string, planning_module.__dict__)\nTypeError: can only concatenate str (not \"NoneType\") to str\n"
    }
}
{
    "operator": "m1",
    "algorithm_description": null,
    "planning_mechanism": null,
    "code": null,
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "success_rate": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 114, in evaluate\n    exec(self.import_string+code_string, planning_module.__dict__)\nTypeError: can only concatenate str (not \"NoneType\") to str\n"
    }
}
{
    "operator": "m1",
    "algorithm_description": null,
    "planning_mechanism": null,
    "code": null,
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "success_rate": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 114, in evaluate\n    exec(self.import_string+code_string, planning_module.__dict__)\nTypeError: can only concatenate str (not \"NoneType\") to str\n"
    }
}
{
    "operator": "m2",
    "algorithm_description": null,
    "planning_mechanism": null,
    "code": null,
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "success_rate": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 114, in evaluate\n    exec(self.import_string+code_string, planning_module.__dict__)\nTypeError: can only concatenate str (not \"NoneType\") to str\n"
    }
}
{
    "operator": "m2",
    "algorithm_description": null,
    "planning_mechanism": null,
    "code": null,
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "success_rate": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 114, in evaluate\n    exec(self.import_string+code_string, planning_module.__dict__)\nTypeError: can only concatenate str (not \"NoneType\") to str\n"
    }
}
{
    "operator": "m2",
    "algorithm_description": null,
    "planning_mechanism": null,
    "code": null,
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "success_rate": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 114, in evaluate\n    exec(self.import_string+code_string, planning_module.__dict__)\nTypeError: can only concatenate str (not \"NoneType\") to str\n"
    }
}
{
    "operator": "m2",
    "algorithm_description": null,
    "planning_mechanism": null,
    "code": null,
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "success_rate": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 114, in evaluate\n    exec(self.import_string+code_string, planning_module.__dict__)\nTypeError: can only concatenate str (not \"NoneType\") to str\n"
    }
}
{
    "operator": "m3",
    "algorithm_description": null,
    "planning_mechanism": null,
    "code": null,
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "success_rate": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 114, in evaluate\n    exec(self.import_string+code_string, planning_module.__dict__)\nTypeError: can only concatenate str (not \"NoneType\") to str\n"
    }
}
{
    "operator": "m3",
    "algorithm_description": null,
    "planning_mechanism": null,
    "code": null,
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "success_rate": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 114, in evaluate\n    exec(self.import_string+code_string, planning_module.__dict__)\nTypeError: can only concatenate str (not \"NoneType\") to str\n"
    }
}
{
    "operator": "m3",
    "algorithm_description": null,
    "planning_mechanism": null,
    "code": null,
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "success_rate": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 114, in evaluate\n    exec(self.import_string+code_string, planning_module.__dict__)\nTypeError: can only concatenate str (not \"NoneType\") to str\n"
    }
}
{
    "operator": "m3",
    "algorithm_description": null,
    "planning_mechanism": null,
    "code": null,
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "success_rate": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 114, in evaluate\n    exec(self.import_string+code_string, planning_module.__dict__)\nTypeError: can only concatenate str (not \"NoneType\") to str\n"
    }
}
{
    "operator": "cross_over",
    "algorithm_description": null,
    "planning_mechanism": null,
    "code": null,
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "success_rate": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 114, in evaluate\n    exec(self.import_string+code_string, planning_module.__dict__)\nTypeError: can only concatenate str (not \"NoneType\") to str\n"
    }
}
{
    "operator": "cross_over",
    "algorithm_description": null,
    "planning_mechanism": null,
    "code": null,
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "success_rate": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 114, in evaluate\n    exec(self.import_string+code_string, planning_module.__dict__)\nTypeError: can only concatenate str (not \"NoneType\") to str\n"
    }
}
{
    "operator": "cross_over",
    "algorithm_description": null,
    "planning_mechanism": null,
    "code": null,
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "success_rate": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 114, in evaluate\n    exec(self.import_string+code_string, planning_module.__dict__)\nTypeError: can only concatenate str (not \"NoneType\") to str\n"
    }
}
{
    "operator": "cross_over",
    "algorithm_description": null,
    "planning_mechanism": null,
    "code": null,
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "success_rate": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 114, in evaluate\n    exec(self.import_string+code_string, planning_module.__dict__)\nTypeError: can only concatenate str (not \"NoneType\") to str\n"
    }
}
{
    "operator": "time_expert",
    "algorithm_description": null,
    "planning_mechanism": null,
    "code": null,
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "success_rate": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 114, in evaluate\n    exec(self.import_string+code_string, planning_module.__dict__)\nTypeError: can only concatenate str (not \"NoneType\") to str\n"
    }
}
{
    "operator": "time_expert",
    "algorithm_description": null,
    "planning_mechanism": null,
    "code": null,
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "success_rate": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 114, in evaluate\n    exec(self.import_string+code_string, planning_module.__dict__)\nTypeError: can only concatenate str (not \"NoneType\") to str\n"
    }
}
{
    "operator": "time_expert",
    "algorithm_description": null,
    "planning_mechanism": null,
    "code": null,
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "success_rate": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 114, in evaluate\n    exec(self.import_string+code_string, planning_module.__dict__)\nTypeError: can only concatenate str (not \"NoneType\") to str\n"
    }
}
{
    "operator": "time_expert",
    "algorithm_description": null,
    "planning_mechanism": null,
    "code": null,
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "success_rate": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 114, in evaluate\n    exec(self.import_string+code_string, planning_module.__dict__)\nTypeError: can only concatenate str (not \"NoneType\") to str\n"
    }
}
{
    "operator": "path_expert",
    "algorithm_description": null,
    "planning_mechanism": null,
    "code": null,
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "success_rate": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 114, in evaluate\n    exec(self.import_string+code_string, planning_module.__dict__)\nTypeError: can only concatenate str (not \"NoneType\") to str\n"
    }
}
{
    "operator": "path_expert",
    "algorithm_description": null,
    "planning_mechanism": null,
    "code": null,
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "success_rate": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 114, in evaluate\n    exec(self.import_string+code_string, planning_module.__dict__)\nTypeError: can only concatenate str (not \"NoneType\") to str\n"
    }
}
{
    "operator": "path_expert",
    "algorithm_description": null,
    "planning_mechanism": null,
    "code": null,
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "success_rate": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 114, in evaluate\n    exec(self.import_string+code_string, planning_module.__dict__)\nTypeError: can only concatenate str (not \"NoneType\") to str\n"
    }
}
{
    "operator": "path_expert",
    "algorithm_description": null,
    "planning_mechanism": null,
    "code": null,
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "success_rate": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 114, in evaluate\n    exec(self.import_string+code_string, planning_module.__dict__)\nTypeError: can only concatenate str (not \"NoneType\") to str\n"
    }
}
{
    "operator": "e1",
    "algorithm_description": null,
    "planning_mechanism": null,
    "code": null,
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "success_rate": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 114, in evaluate\n    exec(self.import_string+code_string, planning_module.__dict__)\nTypeError: can only concatenate str (not \"NoneType\") to str\n"
    }
}
{
    "operator": "e1",
    "algorithm_description": null,
    "planning_mechanism": null,
    "code": null,
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "success_rate": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 114, in evaluate\n    exec(self.import_string+code_string, planning_module.__dict__)\nTypeError: can only concatenate str (not \"NoneType\") to str\n"
    }
}
{
    "operator": "e1",
    "algorithm_description": null,
    "planning_mechanism": null,
    "code": null,
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "success_rate": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 114, in evaluate\n    exec(self.import_string+code_string, planning_module.__dict__)\nTypeError: can only concatenate str (not \"NoneType\") to str\n"
    }
}
{
    "operator": "e1",
    "algorithm_description": null,
    "planning_mechanism": null,
    "code": null,
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "success_rate": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 114, in evaluate\n    exec(self.import_string+code_string, planning_module.__dict__)\nTypeError: can only concatenate str (not \"NoneType\") to str\n"
    }
}
{
    "operator": "e2",
    "algorithm_description": null,
    "planning_mechanism": null,
    "code": null,
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "success_rate": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 114, in evaluate\n    exec(self.import_string+code_string, planning_module.__dict__)\nTypeError: can only concatenate str (not \"NoneType\") to str\n"
    }
}
{
    "operator": "e2",
    "algorithm_description": null,
    "planning_mechanism": null,
    "code": null,
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "success_rate": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 114, in evaluate\n    exec(self.import_string+code_string, planning_module.__dict__)\nTypeError: can only concatenate str (not \"NoneType\") to str\n"
    }
}
{
    "operator": "e2",
    "algorithm_description": null,
    "planning_mechanism": null,
    "code": null,
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "success_rate": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 114, in evaluate\n    exec(self.import_string+code_string, planning_module.__dict__)\nTypeError: can only concatenate str (not \"NoneType\") to str\n"
    }
}
{
    "operator": "e2",
    "algorithm_description": null,
    "planning_mechanism": null,
    "code": null,
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "success_rate": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 114, in evaluate\n    exec(self.import_string+code_string, planning_module.__dict__)\nTypeError: can only concatenate str (not \"NoneType\") to str\n"
    }
}
{
    "operator": "m1",
    "algorithm_description": null,
    "planning_mechanism": null,
    "code": null,
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "success_rate": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 114, in evaluate\n    exec(self.import_string+code_string, planning_module.__dict__)\nTypeError: can only concatenate str (not \"NoneType\") to str\n"
    }
}
{
    "operator": "m1",
    "algorithm_description": null,
    "planning_mechanism": null,
    "code": null,
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "success_rate": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 114, in evaluate\n    exec(self.import_string+code_string, planning_module.__dict__)\nTypeError: can only concatenate str (not \"NoneType\") to str\n"
    }
}
{
    "operator": "m1",
    "algorithm_description": null,
    "planning_mechanism": null,
    "code": null,
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "success_rate": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 114, in evaluate\n    exec(self.import_string+code_string, planning_module.__dict__)\nTypeError: can only concatenate str (not \"NoneType\") to str\n"
    }
}
{
    "operator": "m1",
    "algorithm_description": null,
    "planning_mechanism": null,
    "code": null,
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "success_rate": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 114, in evaluate\n    exec(self.import_string+code_string, planning_module.__dict__)\nTypeError: can only concatenate str (not \"NoneType\") to str\n"
    }
}
{
    "operator": "m2",
    "algorithm_description": null,
    "planning_mechanism": null,
    "code": null,
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "success_rate": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 114, in evaluate\n    exec(self.import_string+code_string, planning_module.__dict__)\nTypeError: can only concatenate str (not \"NoneType\") to str\n"
    }
}
{
    "operator": "m2",
    "algorithm_description": null,
    "planning_mechanism": null,
    "code": null,
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "success_rate": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 114, in evaluate\n    exec(self.import_string+code_string, planning_module.__dict__)\nTypeError: can only concatenate str (not \"NoneType\") to str\n"
    }
}
{
    "operator": "m2",
    "algorithm_description": null,
    "planning_mechanism": null,
    "code": null,
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "success_rate": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 114, in evaluate\n    exec(self.import_string+code_string, planning_module.__dict__)\nTypeError: can only concatenate str (not \"NoneType\") to str\n"
    }
}
{
    "operator": "m2",
    "algorithm_description": null,
    "planning_mechanism": null,
    "code": null,
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "success_rate": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 114, in evaluate\n    exec(self.import_string+code_string, planning_module.__dict__)\nTypeError: can only concatenate str (not \"NoneType\") to str\n"
    }
}
{
    "operator": "m3",
    "algorithm_description": null,
    "planning_mechanism": null,
    "code": null,
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "success_rate": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 114, in evaluate\n    exec(self.import_string+code_string, planning_module.__dict__)\nTypeError: can only concatenate str (not \"NoneType\") to str\n"
    }
}
{
    "operator": "m3",
    "algorithm_description": null,
    "planning_mechanism": null,
    "code": null,
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "success_rate": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 114, in evaluate\n    exec(self.import_string+code_string, planning_module.__dict__)\nTypeError: can only concatenate str (not \"NoneType\") to str\n"
    }
}
{
    "operator": "m3",
    "algorithm_description": null,
    "planning_mechanism": null,
    "code": null,
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "success_rate": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 114, in evaluate\n    exec(self.import_string+code_string, planning_module.__dict__)\nTypeError: can only concatenate str (not \"NoneType\") to str\n"
    }
}
{
    "operator": "m3",
    "algorithm_description": null,
    "planning_mechanism": null,
    "code": null,
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "success_rate": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 114, in evaluate\n    exec(self.import_string+code_string, planning_module.__dict__)\nTypeError: can only concatenate str (not \"NoneType\") to str\n"
    }
}
{
    "operator": "cross_over",
    "algorithm_description": null,
    "planning_mechanism": null,
    "code": null,
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "success_rate": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 114, in evaluate\n    exec(self.import_string+code_string, planning_module.__dict__)\nTypeError: can only concatenate str (not \"NoneType\") to str\n"
    }
}
{
    "operator": "cross_over",
    "algorithm_description": null,
    "planning_mechanism": null,
    "code": null,
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "success_rate": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 114, in evaluate\n    exec(self.import_string+code_string, planning_module.__dict__)\nTypeError: can only concatenate str (not \"NoneType\") to str\n"
    }
}
{
    "operator": "cross_over",
    "algorithm_description": null,
    "planning_mechanism": null,
    "code": null,
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "success_rate": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 114, in evaluate\n    exec(self.import_string+code_string, planning_module.__dict__)\nTypeError: can only concatenate str (not \"NoneType\") to str\n"
    }
}
{
    "operator": "cross_over",
    "algorithm_description": null,
    "planning_mechanism": null,
    "code": null,
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "success_rate": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 114, in evaluate\n    exec(self.import_string+code_string, planning_module.__dict__)\nTypeError: can only concatenate str (not \"NoneType\") to str\n"
    }
}
{
    "operator": "time_expert",
    "algorithm_description": null,
    "planning_mechanism": null,
    "code": null,
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "success_rate": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 114, in evaluate\n    exec(self.import_string+code_string, planning_module.__dict__)\nTypeError: can only concatenate str (not \"NoneType\") to str\n"
    }
}
{
    "operator": "time_expert",
    "algorithm_description": null,
    "planning_mechanism": null,
    "code": null,
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "success_rate": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 114, in evaluate\n    exec(self.import_string+code_string, planning_module.__dict__)\nTypeError: can only concatenate str (not \"NoneType\") to str\n"
    }
}
{
    "operator": "time_expert",
    "algorithm_description": null,
    "planning_mechanism": null,
    "code": null,
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "success_rate": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 114, in evaluate\n    exec(self.import_string+code_string, planning_module.__dict__)\nTypeError: can only concatenate str (not \"NoneType\") to str\n"
    }
}
{
    "operator": "time_expert",
    "algorithm_description": null,
    "planning_mechanism": null,
    "code": null,
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "success_rate": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 114, in evaluate\n    exec(self.import_string+code_string, planning_module.__dict__)\nTypeError: can only concatenate str (not \"NoneType\") to str\n"
    }
}
{
    "operator": "path_expert",
    "algorithm_description": null,
    "planning_mechanism": null,
    "code": null,
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "success_rate": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 114, in evaluate\n    exec(self.import_string+code_string, planning_module.__dict__)\nTypeError: can only concatenate str (not \"NoneType\") to str\n"
    }
}
{
    "operator": "path_expert",
    "algorithm_description": null,
    "planning_mechanism": null,
    "code": null,
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "success_rate": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 114, in evaluate\n    exec(self.import_string+code_string, planning_module.__dict__)\nTypeError: can only concatenate str (not \"NoneType\") to str\n"
    }
}
{
    "operator": "path_expert",
    "algorithm_description": null,
    "planning_mechanism": null,
    "code": null,
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "success_rate": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 114, in evaluate\n    exec(self.import_string+code_string, planning_module.__dict__)\nTypeError: can only concatenate str (not \"NoneType\") to str\n"
    }
}
{
    "operator": "path_expert",
    "algorithm_description": null,
    "planning_mechanism": null,
    "code": null,
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "success_rate": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 114, in evaluate\n    exec(self.import_string+code_string, planning_module.__dict__)\nTypeError: can only concatenate str (not \"NoneType\") to str\n"
    }
}
{
    "operator": "e1",
    "algorithm_description": null,
    "planning_mechanism": null,
    "code": null,
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "success_rate": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 114, in evaluate\n    exec(self.import_string+code_string, planning_module.__dict__)\nTypeError: can only concatenate str (not \"NoneType\") to str\n"
    }
}
{
    "operator": "e1",
    "algorithm_description": null,
    "planning_mechanism": null,
    "code": null,
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "success_rate": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 114, in evaluate\n    exec(self.import_string+code_string, planning_module.__dict__)\nTypeError: can only concatenate str (not \"NoneType\") to str\n"
    }
}
{
    "operator": "e1",
    "algorithm_description": null,
    "planning_mechanism": null,
    "code": null,
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "success_rate": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 114, in evaluate\n    exec(self.import_string+code_string, planning_module.__dict__)\nTypeError: can only concatenate str (not \"NoneType\") to str\n"
    }
}
{
    "operator": "e1",
    "algorithm_description": null,
    "planning_mechanism": null,
    "code": null,
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "success_rate": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 114, in evaluate\n    exec(self.import_string+code_string, planning_module.__dict__)\nTypeError: can only concatenate str (not \"NoneType\") to str\n"
    }
}
{
    "operator": "e2",
    "algorithm_description": null,
    "planning_mechanism": null,
    "code": null,
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "success_rate": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 114, in evaluate\n    exec(self.import_string+code_string, planning_module.__dict__)\nTypeError: can only concatenate str (not \"NoneType\") to str\n"
    }
}
{
    "operator": "e2",
    "algorithm_description": null,
    "planning_mechanism": null,
    "code": null,
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "success_rate": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 114, in evaluate\n    exec(self.import_string+code_string, planning_module.__dict__)\nTypeError: can only concatenate str (not \"NoneType\") to str\n"
    }
}
{
    "operator": "e2",
    "algorithm_description": null,
    "planning_mechanism": null,
    "code": null,
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "success_rate": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 114, in evaluate\n    exec(self.import_string+code_string, planning_module.__dict__)\nTypeError: can only concatenate str (not \"NoneType\") to str\n"
    }
}
{
    "operator": "e2",
    "algorithm_description": null,
    "planning_mechanism": null,
    "code": null,
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "success_rate": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 114, in evaluate\n    exec(self.import_string+code_string, planning_module.__dict__)\nTypeError: can only concatenate str (not \"NoneType\") to str\n"
    }
}
{
    "operator": "m1",
    "algorithm_description": null,
    "planning_mechanism": null,
    "code": null,
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "success_rate": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 114, in evaluate\n    exec(self.import_string+code_string, planning_module.__dict__)\nTypeError: can only concatenate str (not \"NoneType\") to str\n"
    }
}
{
    "operator": "m1",
    "algorithm_description": null,
    "planning_mechanism": null,
    "code": null,
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "success_rate": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 114, in evaluate\n    exec(self.import_string+code_string, planning_module.__dict__)\nTypeError: can only concatenate str (not \"NoneType\") to str\n"
    }
}
{
    "operator": "m1",
    "algorithm_description": null,
    "planning_mechanism": null,
    "code": null,
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "success_rate": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 114, in evaluate\n    exec(self.import_string+code_string, planning_module.__dict__)\nTypeError: can only concatenate str (not \"NoneType\") to str\n"
    }
}
{
    "operator": "m1",
    "algorithm_description": null,
    "planning_mechanism": null,
    "code": null,
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "success_rate": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 114, in evaluate\n    exec(self.import_string+code_string, planning_module.__dict__)\nTypeError: can only concatenate str (not \"NoneType\") to str\n"
    }
}
{
    "operator": "m2",
    "algorithm_description": null,
    "planning_mechanism": null,
    "code": null,
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "success_rate": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 114, in evaluate\n    exec(self.import_string+code_string, planning_module.__dict__)\nTypeError: can only concatenate str (not \"NoneType\") to str\n"
    }
}
{
    "operator": "m2",
    "algorithm_description": null,
    "planning_mechanism": null,
    "code": null,
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "success_rate": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 114, in evaluate\n    exec(self.import_string+code_string, planning_module.__dict__)\nTypeError: can only concatenate str (not \"NoneType\") to str\n"
    }
}
{
    "operator": "m2",
    "algorithm_description": null,
    "planning_mechanism": null,
    "code": null,
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "success_rate": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 114, in evaluate\n    exec(self.import_string+code_string, planning_module.__dict__)\nTypeError: can only concatenate str (not \"NoneType\") to str\n"
    }
}
{
    "operator": "m2",
    "algorithm_description": null,
    "planning_mechanism": null,
    "code": null,
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "success_rate": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 114, in evaluate\n    exec(self.import_string+code_string, planning_module.__dict__)\nTypeError: can only concatenate str (not \"NoneType\") to str\n"
    }
}
{
    "operator": "m3",
    "algorithm_description": null,
    "planning_mechanism": null,
    "code": null,
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "success_rate": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 114, in evaluate\n    exec(self.import_string+code_string, planning_module.__dict__)\nTypeError: can only concatenate str (not \"NoneType\") to str\n"
    }
}
{
    "operator": "m3",
    "algorithm_description": null,
    "planning_mechanism": null,
    "code": null,
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "success_rate": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 114, in evaluate\n    exec(self.import_string+code_string, planning_module.__dict__)\nTypeError: can only concatenate str (not \"NoneType\") to str\n"
    }
}
{
    "operator": "m3",
    "algorithm_description": null,
    "planning_mechanism": null,
    "code": null,
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "success_rate": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 114, in evaluate\n    exec(self.import_string+code_string, planning_module.__dict__)\nTypeError: can only concatenate str (not \"NoneType\") to str\n"
    }
}
{
    "operator": "m3",
    "algorithm_description": null,
    "planning_mechanism": null,
    "code": null,
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "success_rate": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 114, in evaluate\n    exec(self.import_string+code_string, planning_module.__dict__)\nTypeError: can only concatenate str (not \"NoneType\") to str\n"
    }
}
{
    "operator": "cross_over",
    "algorithm_description": null,
    "planning_mechanism": null,
    "code": null,
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "success_rate": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 114, in evaluate\n    exec(self.import_string+code_string, planning_module.__dict__)\nTypeError: can only concatenate str (not \"NoneType\") to str\n"
    }
}
{
    "operator": "cross_over",
    "algorithm_description": null,
    "planning_mechanism": null,
    "code": null,
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "success_rate": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 114, in evaluate\n    exec(self.import_string+code_string, planning_module.__dict__)\nTypeError: can only concatenate str (not \"NoneType\") to str\n"
    }
}
{
    "operator": "cross_over",
    "algorithm_description": null,
    "planning_mechanism": null,
    "code": null,
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "success_rate": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 114, in evaluate\n    exec(self.import_string+code_string, planning_module.__dict__)\nTypeError: can only concatenate str (not \"NoneType\") to str\n"
    }
}
{
    "operator": "cross_over",
    "algorithm_description": null,
    "planning_mechanism": null,
    "code": null,
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "success_rate": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 114, in evaluate\n    exec(self.import_string+code_string, planning_module.__dict__)\nTypeError: can only concatenate str (not \"NoneType\") to str\n"
    }
}
{
    "operator": "time_expert",
    "algorithm_description": null,
    "planning_mechanism": null,
    "code": null,
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "success_rate": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 114, in evaluate\n    exec(self.import_string+code_string, planning_module.__dict__)\nTypeError: can only concatenate str (not \"NoneType\") to str\n"
    }
}
{
    "operator": "time_expert",
    "algorithm_description": null,
    "planning_mechanism": null,
    "code": null,
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "success_rate": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 114, in evaluate\n    exec(self.import_string+code_string, planning_module.__dict__)\nTypeError: can only concatenate str (not \"NoneType\") to str\n"
    }
}
{
    "operator": "time_expert",
    "algorithm_description": null,
    "planning_mechanism": null,
    "code": null,
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "success_rate": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 114, in evaluate\n    exec(self.import_string+code_string, planning_module.__dict__)\nTypeError: can only concatenate str (not \"NoneType\") to str\n"
    }
}
{
    "operator": "time_expert",
    "algorithm_description": null,
    "planning_mechanism": null,
    "code": null,
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "success_rate": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 114, in evaluate\n    exec(self.import_string+code_string, planning_module.__dict__)\nTypeError: can only concatenate str (not \"NoneType\") to str\n"
    }
}
{
    "operator": "path_expert",
    "algorithm_description": null,
    "planning_mechanism": null,
    "code": null,
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "success_rate": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 114, in evaluate\n    exec(self.import_string+code_string, planning_module.__dict__)\nTypeError: can only concatenate str (not \"NoneType\") to str\n"
    }
}
{
    "operator": "path_expert",
    "algorithm_description": null,
    "planning_mechanism": null,
    "code": null,
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "success_rate": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 114, in evaluate\n    exec(self.import_string+code_string, planning_module.__dict__)\nTypeError: can only concatenate str (not \"NoneType\") to str\n"
    }
}
{
    "operator": "path_expert",
    "algorithm_description": null,
    "planning_mechanism": null,
    "code": null,
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "success_rate": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 114, in evaluate\n    exec(self.import_string+code_string, planning_module.__dict__)\nTypeError: can only concatenate str (not \"NoneType\") to str\n"
    }
}
{
    "operator": "path_expert",
    "algorithm_description": null,
    "planning_mechanism": null,
    "code": null,
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "success_rate": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 114, in evaluate\n    exec(self.import_string+code_string, planning_module.__dict__)\nTypeError: can only concatenate str (not \"NoneType\") to str\n"
    }
}
{
    "operator": "e1",
    "algorithm_description": null,
    "planning_mechanism": null,
    "code": null,
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "success_rate": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 114, in evaluate\n    exec(self.import_string+code_string, planning_module.__dict__)\nTypeError: can only concatenate str (not \"NoneType\") to str\n"
    }
}
{
    "operator": "e1",
    "algorithm_description": null,
    "planning_mechanism": null,
    "code": null,
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "success_rate": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 114, in evaluate\n    exec(self.import_string+code_string, planning_module.__dict__)\nTypeError: can only concatenate str (not \"NoneType\") to str\n"
    }
}
{
    "operator": "e1",
    "algorithm_description": null,
    "planning_mechanism": null,
    "code": null,
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "success_rate": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 114, in evaluate\n    exec(self.import_string+code_string, planning_module.__dict__)\nTypeError: can only concatenate str (not \"NoneType\") to str\n"
    }
}
{
    "operator": "e1",
    "algorithm_description": null,
    "planning_mechanism": null,
    "code": null,
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "success_rate": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 114, in evaluate\n    exec(self.import_string+code_string, planning_module.__dict__)\nTypeError: can only concatenate str (not \"NoneType\") to str\n"
    }
}
{
    "operator": "e2",
    "algorithm_description": null,
    "planning_mechanism": null,
    "code": null,
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "success_rate": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 114, in evaluate\n    exec(self.import_string+code_string, planning_module.__dict__)\nTypeError: can only concatenate str (not \"NoneType\") to str\n"
    }
}
{
    "operator": "e2",
    "algorithm_description": null,
    "planning_mechanism": null,
    "code": null,
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "success_rate": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 114, in evaluate\n    exec(self.import_string+code_string, planning_module.__dict__)\nTypeError: can only concatenate str (not \"NoneType\") to str\n"
    }
}
{
    "operator": "e2",
    "algorithm_description": null,
    "planning_mechanism": null,
    "code": null,
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "success_rate": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 114, in evaluate\n    exec(self.import_string+code_string, planning_module.__dict__)\nTypeError: can only concatenate str (not \"NoneType\") to str\n"
    }
}
{
    "operator": "e2",
    "algorithm_description": null,
    "planning_mechanism": null,
    "code": null,
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "success_rate": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 114, in evaluate\n    exec(self.import_string+code_string, planning_module.__dict__)\nTypeError: can only concatenate str (not \"NoneType\") to str\n"
    }
}
{
    "operator": "m1",
    "algorithm_description": null,
    "planning_mechanism": null,
    "code": null,
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "success_rate": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 114, in evaluate\n    exec(self.import_string+code_string, planning_module.__dict__)\nTypeError: can only concatenate str (not \"NoneType\") to str\n"
    }
}
{
    "operator": "m1",
    "algorithm_description": null,
    "planning_mechanism": null,
    "code": null,
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "success_rate": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 114, in evaluate\n    exec(self.import_string+code_string, planning_module.__dict__)\nTypeError: can only concatenate str (not \"NoneType\") to str\n"
    }
}
{
    "operator": "m1",
    "algorithm_description": null,
    "planning_mechanism": null,
    "code": null,
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "success_rate": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 114, in evaluate\n    exec(self.import_string+code_string, planning_module.__dict__)\nTypeError: can only concatenate str (not \"NoneType\") to str\n"
    }
}
{
    "operator": "m1",
    "algorithm_description": null,
    "planning_mechanism": null,
    "code": null,
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "success_rate": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 114, in evaluate\n    exec(self.import_string+code_string, planning_module.__dict__)\nTypeError: can only concatenate str (not \"NoneType\") to str\n"
    }
}
{
    "operator": "m2",
    "algorithm_description": null,
    "planning_mechanism": null,
    "code": null,
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "success_rate": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 114, in evaluate\n    exec(self.import_string+code_string, planning_module.__dict__)\nTypeError: can only concatenate str (not \"NoneType\") to str\n"
    }
}
{
    "operator": "m2",
    "algorithm_description": null,
    "planning_mechanism": null,
    "code": null,
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "success_rate": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 114, in evaluate\n    exec(self.import_string+code_string, planning_module.__dict__)\nTypeError: can only concatenate str (not \"NoneType\") to str\n"
    }
}
{
    "operator": "m2",
    "algorithm_description": null,
    "planning_mechanism": null,
    "code": null,
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "success_rate": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 114, in evaluate\n    exec(self.import_string+code_string, planning_module.__dict__)\nTypeError: can only concatenate str (not \"NoneType\") to str\n"
    }
}
{
    "operator": "m2",
    "algorithm_description": null,
    "planning_mechanism": null,
    "code": null,
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "success_rate": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 114, in evaluate\n    exec(self.import_string+code_string, planning_module.__dict__)\nTypeError: can only concatenate str (not \"NoneType\") to str\n"
    }
}
{
    "operator": "m3",
    "algorithm_description": null,
    "planning_mechanism": null,
    "code": null,
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "success_rate": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 114, in evaluate\n    exec(self.import_string+code_string, planning_module.__dict__)\nTypeError: can only concatenate str (not \"NoneType\") to str\n"
    }
}
{
    "operator": "m3",
    "algorithm_description": null,
    "planning_mechanism": null,
    "code": null,
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "success_rate": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 114, in evaluate\n    exec(self.import_string+code_string, planning_module.__dict__)\nTypeError: can only concatenate str (not \"NoneType\") to str\n"
    }
}
{
    "operator": "m3",
    "algorithm_description": null,
    "planning_mechanism": null,
    "code": null,
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "success_rate": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 114, in evaluate\n    exec(self.import_string+code_string, planning_module.__dict__)\nTypeError: can only concatenate str (not \"NoneType\") to str\n"
    }
}
{
    "operator": "m3",
    "algorithm_description": null,
    "planning_mechanism": null,
    "code": null,
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "success_rate": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 114, in evaluate\n    exec(self.import_string+code_string, planning_module.__dict__)\nTypeError: can only concatenate str (not \"NoneType\") to str\n"
    }
}
{
    "operator": "cross_over",
    "algorithm_description": null,
    "planning_mechanism": null,
    "code": null,
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "success_rate": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 114, in evaluate\n    exec(self.import_string+code_string, planning_module.__dict__)\nTypeError: can only concatenate str (not \"NoneType\") to str\n"
    }
}
{
    "operator": "cross_over",
    "algorithm_description": null,
    "planning_mechanism": null,
    "code": null,
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "success_rate": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 114, in evaluate\n    exec(self.import_string+code_string, planning_module.__dict__)\nTypeError: can only concatenate str (not \"NoneType\") to str\n"
    }
}
{
    "operator": "cross_over",
    "algorithm_description": null,
    "planning_mechanism": null,
    "code": null,
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "success_rate": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 114, in evaluate\n    exec(self.import_string+code_string, planning_module.__dict__)\nTypeError: can only concatenate str (not \"NoneType\") to str\n"
    }
}
{
    "operator": "cross_over",
    "algorithm_description": null,
    "planning_mechanism": null,
    "code": null,
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "success_rate": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 114, in evaluate\n    exec(self.import_string+code_string, planning_module.__dict__)\nTypeError: can only concatenate str (not \"NoneType\") to str\n"
    }
}
{
    "operator": "time_expert",
    "algorithm_description": null,
    "planning_mechanism": null,
    "code": null,
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "success_rate": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 114, in evaluate\n    exec(self.import_string+code_string, planning_module.__dict__)\nTypeError: can only concatenate str (not \"NoneType\") to str\n"
    }
}
{
    "operator": "time_expert",
    "algorithm_description": null,
    "planning_mechanism": null,
    "code": null,
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "success_rate": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 114, in evaluate\n    exec(self.import_string+code_string, planning_module.__dict__)\nTypeError: can only concatenate str (not \"NoneType\") to str\n"
    }
}
{
    "operator": "time_expert",
    "algorithm_description": null,
    "planning_mechanism": null,
    "code": null,
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "success_rate": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 114, in evaluate\n    exec(self.import_string+code_string, planning_module.__dict__)\nTypeError: can only concatenate str (not \"NoneType\") to str\n"
    }
}
{
    "operator": "time_expert",
    "algorithm_description": null,
    "planning_mechanism": null,
    "code": null,
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "success_rate": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 114, in evaluate\n    exec(self.import_string+code_string, planning_module.__dict__)\nTypeError: can only concatenate str (not \"NoneType\") to str\n"
    }
}
{
    "operator": "path_expert",
    "algorithm_description": null,
    "planning_mechanism": null,
    "code": null,
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "success_rate": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 114, in evaluate\n    exec(self.import_string+code_string, planning_module.__dict__)\nTypeError: can only concatenate str (not \"NoneType\") to str\n"
    }
}
{
    "operator": "path_expert",
    "algorithm_description": null,
    "planning_mechanism": null,
    "code": null,
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "success_rate": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 114, in evaluate\n    exec(self.import_string+code_string, planning_module.__dict__)\nTypeError: can only concatenate str (not \"NoneType\") to str\n"
    }
}
{
    "operator": "path_expert",
    "algorithm_description": null,
    "planning_mechanism": null,
    "code": null,
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "success_rate": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 114, in evaluate\n    exec(self.import_string+code_string, planning_module.__dict__)\nTypeError: can only concatenate str (not \"NoneType\") to str\n"
    }
}
{
    "operator": "path_expert",
    "algorithm_description": null,
    "planning_mechanism": null,
    "code": null,
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "success_rate": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 114, in evaluate\n    exec(self.import_string+code_string, planning_module.__dict__)\nTypeError: can only concatenate str (not \"NoneType\") to str\n"
    }
}
{
    "operator": "time_expert",
    "algorithm_description": null,
    "planning_mechanism": null,
    "code": null,
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "success_rate": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 114, in evaluate\n    exec(self.import_string+code_string, planning_module.__dict__)\nTypeError: can only concatenate str (not \"NoneType\") to str\n"
    }
}
{
    "operator": "time_expert",
    "algorithm_description": null,
    "planning_mechanism": null,
    "code": null,
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "success_rate": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 114, in evaluate\n    exec(self.import_string+code_string, planning_module.__dict__)\nTypeError: can only concatenate str (not \"NoneType\") to str\n"
    }
}
{
    "operator": "time_expert",
    "algorithm_description": null,
    "planning_mechanism": null,
    "code": null,
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "success_rate": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 114, in evaluate\n    exec(self.import_string+code_string, planning_module.__dict__)\nTypeError: can only concatenate str (not \"NoneType\") to str\n"
    }
}
{
    "operator": "time_expert",
    "algorithm_description": null,
    "planning_mechanism": null,
    "code": null,
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "success_rate": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 114, in evaluate\n    exec(self.import_string+code_string, planning_module.__dict__)\nTypeError: can only concatenate str (not \"NoneType\") to str\n"
    }
}
{
    "operator": "path_expert",
    "algorithm_description": null,
    "planning_mechanism": null,
    "code": null,
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "success_rate": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 114, in evaluate\n    exec(self.import_string+code_string, planning_module.__dict__)\nTypeError: can only concatenate str (not \"NoneType\") to str\n"
    }
}
{
    "operator": "path_expert",
    "algorithm_description": null,
    "planning_mechanism": null,
    "code": null,
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "success_rate": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 114, in evaluate\n    exec(self.import_string+code_string, planning_module.__dict__)\nTypeError: can only concatenate str (not \"NoneType\") to str\n"
    }
}
{
    "operator": "path_expert",
    "algorithm_description": null,
    "planning_mechanism": null,
    "code": null,
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "success_rate": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 114, in evaluate\n    exec(self.import_string+code_string, planning_module.__dict__)\nTypeError: can only concatenate str (not \"NoneType\") to str\n"
    }
}
{
    "operator": "path_expert",
    "algorithm_description": null,
    "planning_mechanism": null,
    "code": null,
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "success_rate": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 114, in evaluate\n    exec(self.import_string+code_string, planning_module.__dict__)\nTypeError: can only concatenate str (not \"NoneType\") to str\n"
    }
}
{
    "operator": "cross_over",
    "algorithm_description": null,
    "planning_mechanism": null,
    "code": null,
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "success_rate": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 114, in evaluate\n    exec(self.import_string+code_string, planning_module.__dict__)\nTypeError: can only concatenate str (not \"NoneType\") to str\n"
    }
}
{
    "operator": "cross_over",
    "algorithm_description": null,
    "planning_mechanism": null,
    "code": null,
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "success_rate": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 114, in evaluate\n    exec(self.import_string+code_string, planning_module.__dict__)\nTypeError: can only concatenate str (not \"NoneType\") to str\n"
    }
}
{
    "operator": "cross_over",
    "algorithm_description": null,
    "planning_mechanism": null,
    "code": null,
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "success_rate": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 114, in evaluate\n    exec(self.import_string+code_string, planning_module.__dict__)\nTypeError: can only concatenate str (not \"NoneType\") to str\n"
    }
}
{
    "operator": "cross_over",
    "algorithm_description": null,
    "planning_mechanism": null,
    "code": null,
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "success_rate": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 114, in evaluate\n    exec(self.import_string+code_string, planning_module.__dict__)\nTypeError: can only concatenate str (not \"NoneType\") to str\n"
    }
}
{
    "operator": "e1",
    "algorithm_description": "This algorithm is an Adaptive Informed RRT* with batch rewiring and incremental path shortcutting. It improves efficiency by focusing sampling within the informed subset once a feasible path is found, rewires neighbors in batches to reduce redundant computations, and progressively shortcuts the path during planning to improve smoothness and shorten path length. Strict collision checking of nodes and edges with early exits and a 30-second time limit ensure robust and timely responses.",
    "planning_mechanism": "The planner initially samples uniformly but adaptively focuses sampling inside an ellipsoidal informed subset defined by the current best path cost and tree roots after an initial solution. It extends the tree using fixed step sizes and rewires neighbors within a dynamic radius calculated based on tree size and cost improvement. Whenever a better path connects start to goal, the informed subset shrinks and the path is incrementally shortcut to improve smoothness. Planning halts immediately once 30 seconds passes, returning the best found path up to that time.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Parent Node or None\n        self.cost = cost                # Cost from root to this node\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.children.remove(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int=50000, step_size: float=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.best_cost = float('inf')\n        self.best_goal_node = None\n\n    def plan(self, map):\n        import time\n        import math\n        import random\n\n        bounds = map.size\n        start_p = map.start\n        goal_p = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_time = time.monotonic()\n        time_limit = 30.0\n\n        nodes = []\n        edges = []\n        success = False\n        path = []\n\n        root = Node(start_p, cost=0.0)\n        nodes.append(root)\n\n        def dist(p1, p2):\n            return math.dist(p1, p2)\n\n        def steer(from_p, to_p):\n            d = dist(from_p, to_p)\n            if d <= self.step_size:\n                return to_p\n            ratio = self.step_size / d\n            return tuple(from_p[i] + (to_p[i] - from_p[i]) * ratio for i in range(len(from_p)))\n\n        def in_bounds(p):\n            for i, lim in enumerate(bounds):\n                if not (0 <= p[i] <= lim):\n                    return False\n            return True\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    px, py = pos\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(f, t, resolution=1.0):\n            d = dist(f, t)\n            steps = max(1, int(d / resolution))\n            for i in range(steps + 1):\n                interp = tuple(f[j] + (t[j] - f[j]) * i / steps for j in range(len(f)))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def sample_free():\n            # If we have a best path, use informed sampling in ellipsoid\n            if self.best_cost < float('inf'):\n                c_best = self.best_cost\n                c_min = dist(start_p, goal_p)\n                if c_best < float('inf') and c_best > c_min and c_min > 0:\n                    # 2D or 3D informed sampling ellipsoid:\n                    # Compute center, rotation and radii for sampling\n                    center = tuple((start_p[i] + goal_p[i]) * 0.5 for i in range(len(bounds)))\n                    # Unit vector from start to goal\n                    a1 = tuple((goal_p[i] - start_p[i]) / c_min for i in range(len(bounds)))\n\n                    # Build rotation matrix to align x axis with a1\n                    # For 2D or 3D only: we do 2D rotation or generalize\n                    # Construct orthonormal basis with a1 as first vector\n                    # Here we'll do a simple approach using Gram-Schmidt for 2D or 3D\n\n                    import math\n                    import random\n\n                    # Generate random point in unit ball of dimension d\n                    def unit_ball_sample(d):\n                        while True:\n                            z = [random.uniform(-1,1) for _ in range(d)]\n                            norm = math.sqrt(sum(x*x for x in z))\n                            if norm <= 1 and norm > 1e-12:\n                                return [x / norm for x in z]\n\n                    # Radii of ellipsoid semi-axes\n                    r1 = c_best / 2.0\n                    if len(bounds) == 2:\n                        r2 = math.sqrt(c_best**2 - c_min**2) / 2.0\n                        # Sample in unit ball and scale\n                        x_ball = unit_ball_sample(2)\n                        x = [r1 * x_ball[0], r2 * x_ball[1]]\n                        # Rotate x back to global space\n                        cos_theta = a1[0]\n                        sin_theta = a1[1]\n                        px = center[0] + cos_theta * x[0] - sin_theta * x[1]\n                        py = center[1] + sin_theta * x[0] + cos_theta * x[1]\n                        sample = (px, py)\n                        if in_bounds(sample) and not is_in_obstacle(sample):\n                            return sample\n                        else:\n                            # fallback uniform sample\n                            return tuple(random.uniform(0, bounds[i]) for i in range(len(bounds)))\n                    else:\n                        # 3D version inspired by https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=7961866\n                        # r2 and r3 same radii\n                        r23 = math.sqrt(c_best**2 - c_min**2) / 2.0\n                        x_ball = unit_ball_sample(3)\n                        x = [r1 * x_ball[0], r23 * x_ball[1], r23 * x_ball[2]]\n\n                        # Construct rotation matrix R to align x-axis (1,0,0) with a1\n                        # Use quaternion or axis-angle rotation; simplified here:\n\n                        def rotation_matrix_from_a1(a1):\n                            # a1 is unit vector\n                            import math\n                            x1, y1, z1 = a1\n                            # Angle between (1,0,0) and a1\n                            angle = math.acos(x1)\n                            if abs(angle) < 1e-6:\n                                return [[1,0,0],[0,1,0],[0,0,1]]\n                            # Rotation axis is cross product (1,0,0) x a1 = (0,-z1,y1)\n                            axis = (0,-z1,y1)\n                            norm_axis = math.sqrt(axis[0]*axis[0]+axis[1]*axis[1]+axis[2]*axis[2])\n                            if norm_axis < 1e-6:\n                                return [[1,0,0],[0,1,0],[0,0,1]]\n                            axis = (axis[0]/norm_axis, axis[1]/norm_axis, axis[2]/norm_axis)\n                            ux, uy, uz = axis\n                            c = math.cos(angle)\n                            s = math.sin(angle)\n                            C = 1 - c\n                            R = [\n                                [ c + ux*ux*C, ux*uy*C - uz*s, ux*uz*C + uy*s],\n                                [ uy*ux*C + uz*s, c + uy*uy*C, uy*uz*C - ux*s],\n                                [ uz*ux*C - uy*s, uz*uy*C + ux*s, c + uz*uz*C]\n                            ]\n                            return R\n\n                        R = rotation_matrix_from_a1(a1)\n                        x_rot = [sum(R[i][j]*x[j] for j in range(3)) for i in range(3)]\n                        sample = tuple(center[i] + x_rot[i] for i in range(3))\n                        if in_bounds(sample) and not is_in_obstacle(sample):\n                            return sample\n                        else:\n                            return tuple(random.uniform(0, bounds[i]) for i in range(len(bounds)))\n                else:\n                    # In case best_cost equals c_min or is inf fallback uniform\n                    return tuple(random.uniform(0, bounds[i]) for i in range(len(bounds)))\n            else:\n                return tuple(random.uniform(0, bounds[i]) for i in range(len(bounds)))\n\n        def near_nodes(position, radius):\n            return [n for n in nodes if dist(n.position, position) <= radius]\n\n        def choose_parent(new_pos, near_nodes_list):\n            min_cost = float('inf')\n            best_parent = None\n            for node in near_nodes_list:\n                cost_to_new = node.cost + dist(node.position, new_pos)\n                if cost_to_new < min_cost and not is_edge_in_obstacle(node.position, new_pos):\n                    min_cost = cost_to_new\n                    best_parent = node\n            return best_parent, min_cost\n\n        def rewire(new_node, near_nodes_list):\n            for nbr in near_nodes_list:\n                if nbr == new_node.parent:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, nbr.position)\n                if new_cost + 1e-12 < nbr.cost and not is_edge_in_obstacle(new_node.position, nbr.position):\n                    if nbr.parent:\n                        try:\n                            edges.remove((nbr.parent, nbr))\n                        except ValueError:\n                            pass\n                        if nbr in nbr.parent.children:\n                            nbr.parent.children.remove(nbr)\n                    nbr.update_parent(new_node, new_cost)\n                    edges.append((new_node, nbr))\n\n        def update_best_goal_node(candidate_node):\n            nonlocal success, path\n            if candidate_node.cost < self.best_cost:\n                self.best_cost = candidate_node.cost\n                self.best_goal_node = candidate_node\n                success = True\n                path = candidate_node.path_from_root()\n                # Incremental shortcut to improve path quality\n                shortcut_path()\n\n        def shortcut_path():\n            # Perform quick path shortcut with limited attempts, improving smoothness and shortening length\n            if not self.best_goal_node:\n                return\n            pts = path[:]\n            if len(pts) < 3:\n                return\n            changed = True\n            attempts = 0\n            max_attempts = 100\n            while changed and attempts < max_attempts:\n                changed = False\n                attempts +=1\n                i = 0\n                while i < len(pts) - 2:\n                    j = i + 2\n                    if j >= len(pts):\n                        break\n                    if not is_edge_in_obstacle(pts[i], pts[j]):\n                        # shortcut by removing intermediate points i+1..j-1\n                        pts = pts[:i+1] + pts[j:]\n                        changed = True\n                    else:\n                        i += 1\n            # Rebuild the tree for nodes and edges along the shortcut path\n            # Drop nodes & edges after shortcut - keep consistent with planner goal\n            nonlocal nodes, edges\n            new_nodes = []\n            new_edges = []\n            last_node = Node(pts[0], parent=None, cost=0.0)\n            new_nodes.append(last_node)\n            cum_cost = 0.0\n            for idx in range(1,len(pts)):\n                p = pts[idx]\n                cost_inc = dist(pts[idx-1], p)\n                cum_cost += cost_inc\n                n = Node(p, parent=last_node, cost=cum_cost)\n                last_node.add_child(n)\n                new_nodes.append(n)\n                new_edges.append((last_node,n))\n                last_node = n\n            nodes = new_nodes\n            edges = new_edges\n            # Update best_goal_node to last node in shortcut path\n            self.best_goal_node = nodes[-1]\n            # update path global var\n            nonlocal path\n            path = pts\n\n        # Find dynamic neighbor radius according to RRT* theory with max radius clamp\n        def neighbor_radius():\n            n = len(nodes)\n            if n <= 1:\n                return self.step_size * 5.0\n            d = len(bounds)\n            gamma = 35.0  # tuning parameter\n            r = gamma * (math.log(n)/n) ** (1/d)\n            r = max(r, self.step_size)\n            return min(r, self.step_size*15)\n\n        # Main planning loop\n        for iter_num in range(self.max_iter):\n            if time.monotonic() - start_time > time_limit:\n                break\n            samp = sample_free()\n            nearest = min(nodes, key=lambda nd: dist(nd.position, samp))\n            new_pos = steer(nearest.position, samp)\n\n            if not in_bounds(new_pos):\n                continue\n            if is_in_obstacle(new_pos):\n                continue\n            if is_edge_in_obstacle(nearest.position, new_pos):\n                continue\n\n            nbrs = near_nodes(new_pos, neighbor_radius())\n            parent, minc = choose_parent(new_pos, nbrs + [nearest])\n            if parent is None:\n                parent = nearest\n                minc = nearest.cost + dist(nearest.position,new_pos)\n                if is_edge_in_obstacle(parent.position, new_pos):\n                    continue\n\n            new_node = Node(new_pos)\n            new_node.update_parent(parent, minc)\n            nodes.append(new_node)\n            edges.append((parent,new_node))\n\n            rewire(new_node, nbrs)\n\n            # Attempt connecting to goal if close\n            if dist(new_pos, goal_p) <= self.step_size and not is_in_obstacle(goal_p):\n                if not is_edge_in_obstacle(new_pos, goal_p):\n                    goal_node = Node(goal_p)\n                    goal_cost = new_node.cost + dist(new_pos, goal_p)\n                    goal_node.update_parent(new_node, goal_cost)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    update_best_goal_node(goal_node)\n\n            # If found best cost close to minimum possible, can early exit\n            if success and abs(self.best_cost - dist(start_p, goal_p)) < 1e-3:\n                break\n\n        if success:\n            return type('PlannerResult', (), {\n                'success': True,\n                'path': path,\n                'nodes': nodes,\n                'edges': edges\n            })()\n        else:\n            # Return best found path even if no success\n            if self.best_goal_node:\n                return type('PlannerResult', (), {\n                    'success': False,\n                    'path': self.best_goal_node.path_from_root(),\n                    'nodes': nodes,\n                    'edges': edges\n                })()\n            else:\n                # No path found at all, return empty\n                return type('PlannerResult', (), {\n                    'success': False,\n                    'path': [],\n                    'nodes': nodes,\n                    'edges': edges\n                })()",
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 114, in evaluate\n    exec(self.import_string+code_string, planning_module.__dict__)\n  File \"<string>\", line 284\nSyntaxError: name 'path' is used prior to nonlocal declaration\n"
    }
}
{
    "operator": "m2",
    "algorithm_description": "This algorithm is a refined bidirectional RRT* planner with adaptive rewiring radius, improved goal bias, dynamic collision checking resolution, and incremental shortcutting applied periodically for smoother, shorter paths. It employs spatial hashing for efficient near-neighbor queries, alternates expansion between start and goal trees, and adaptively adjusts parameters based on current node count and environment size. The planner enforces a strict 30-second time limit, performs early stopping on near-optimal path discovery, and continuously updates the best path found.",
    "planning_mechanism": "The planner alternates expansions between start and goal trees, sampling with a goal bias of 0.2 and steering incrementally with a step size of 4.2. It uses spatial hashing to efficiently find neighbors within a dynamically computed rewiring radius shrinking with the number of nodes. Rewiring optimizes path costs with incremental cost propagation. Multiple candidate connections between trees are checked to discover better solutions sooner. The best path is progressively shortcut smoothed every 150 iterations to reduce length and improve smoothness. The process terminates early if an adequately short path is found or the 30-second timer expires, returning the best path found.",
    "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float = 0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children: List[Node] = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\nclass Planner:\n    def __init__(self):\n        self.max_iter = 7000\n        self.step_size = 4.2\n        self.goal_sample_rate = 0.2\n        self.time_limit = 30.0\n        self.max_sample_attempts = 20\n        self.smoothing_attempts = 80\n        self.cell_size_factor = 2.3  # tuning spatial hash cell size\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = dim == 3\n\n        cell_size = max(1.0, self.step_size * self.cell_size_factor)\n        grid_dims = tuple(max(1, int(math.ceil(bounds[d] / cell_size))) for d in range(dim))\n        grid_start = {}\n        grid_goal = {}\n\n        def pos_to_cell(pos):\n            return tuple(int(pos[d] // cell_size) for d in range(dim))\n\n        def insert_node(grid, node):\n            c = pos_to_cell(node.position)\n            if c not in grid:\n                grid[c] = []\n            grid[c].append(node)\n\n        def get_neighbors(grid, position, radius):\n            radius_cells = int(math.ceil(radius / cell_size))\n            center_cell = pos_to_cell(position)\n            neighbors = []\n            for offset in self._grid_offsets(dim, radius_cells):\n                cell = tuple(center_cell[d] + offset[d] for d in range(dim))\n                if any(cell[d] < 0 or cell[d] >= grid_dims[d] for d in range(dim)):\n                    continue\n                if cell in grid:\n                    neighbors.extend(grid[cell])\n            r2 = radius * radius\n            return [n for n in neighbors if self._squared_dist(n.position, position) <= r2]\n\n        def in_obstacle(pos):\n            for o in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = o\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = o\n                    px, py = pos\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def edge_in_obstacle(a, b):\n            dist = math.dist(a, b)\n            # Adaptive resolution: finer checks for longer edges but limit minimum resolution\n            resolution = max(0.15, self.step_size * 0.06)\n            steps = max(1, int(dist / resolution))\n            for i in range(steps + 1):\n                interp = tuple(a[d] + (b[d] - a[d]) * (i / steps) for d in range(dim))\n                if in_obstacle(interp):\n                    return True\n            return False\n\n        def steer(from_p, to_p):\n            dist = math.dist(from_p, to_p)\n            if dist <= self.step_size:\n                return to_p\n            ratio = self.step_size / dist\n            return tuple(from_p[d] + ratio * (to_p[d] - from_p[d]) for d in range(dim))\n\n        def _squared_dist(a, b):\n            return sum((a[d] - b[d]) ** 2 for d in range(len(a)))\n\n        def nearest(tree_grid, tree_nodes, point):\n            search_radius = self.step_size * 5.0\n            best_node = None\n            best_dist = float(\"inf\")\n            neighbors = get_neighbors(tree_grid, point, search_radius)\n            if not neighbors:\n                for node in tree_nodes:\n                    d = _squared_dist(node.position, point)\n                    if d < best_dist:\n                        best_dist = d\n                        best_node = node\n                return best_node\n            for node in neighbors:\n                d = _squared_dist(node.position, point)\n                if d < best_dist:\n                    best_dist = d\n                    best_node = node\n            return best_node\n\n        def adaptive_radius(node_count):\n            gamma = 20.0  # Reduced gamma for tighter but effective radius\n            if node_count <= 1:\n                return gamma\n            val = gamma * ((math.log(node_count) / node_count) ** (1 / dim))\n            max_r = min(bounds) * 0.13\n            return max(2.2, min(val, max_r))\n\n        def propagate_cost(node):\n            stack = node.children[:]\n            while stack:\n                current = stack.pop()\n                new_cost = current.parent.cost + math.dist(current.position, current.parent.position)\n                if new_cost + 1e-12 < current.cost:\n                    current.cost = new_cost\n                    stack.extend(current.children)\n\n        def rewire(grid, tree, new_node, radius):\n            neighbors = get_neighbors(grid, new_node.position, radius)\n            for neighbor in neighbors:\n                if neighbor is new_node.parent:\n                    continue\n                if edge_in_obstacle(new_node.position, neighbor.position):\n                    continue\n                new_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n                if new_cost + 1e-12 < neighbor.cost:\n                    neighbor.update_parent(new_node, new_cost)\n                    propagate_cost(neighbor)\n\n        def extract_path(node_from, node_to):\n            path_from = []\n            cur = node_from\n            while cur is not None:\n                path_from.append(cur.position)\n                cur = cur.parent\n            path_to = []\n            cur = node_to\n            while cur is not None:\n                path_to.append(cur.position)\n                cur = cur.parent\n            return path_from[::-1] + path_to\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_attempts):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if not edge_in_obstacle(path[i], path[j]):\n                    path = path[: i + 1] + path[j:]\n            return path\n\n        # Initialize trees\n        start_tree = [Node(start_pos, cost=0.0)]\n        goal_tree = [Node(goal_pos, cost=0.0)]\n        all_nodes = start_tree + goal_tree\n        edges: List[Tuple[Node, Node]] = []\n\n        insert_node(grid_start, start_tree[0])\n        insert_node(grid_goal, goal_tree[0])\n\n        best_cost = float(\"inf\")\n        best_pair = None\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n\n        start_time = time.monotonic()\n\n        if in_obstacle(start_pos) or in_obstacle(goal_pos):\n            return PlannerResult(False, [], all_nodes, edges)\n\n        for iteration in range(self.max_iter):\n            elapsed = time.monotonic() - start_time\n            if elapsed > self.time_limit:\n                break\n\n            tree_a, tree_b = (start_tree, goal_tree) if iteration % 2 == 0 else (goal_tree, start_tree)\n            grid_a, grid_b = (grid_start, grid_goal) if iteration % 2 == 0 else (grid_goal, grid_start)\n\n            sample = None\n            for _ in range(self.max_sample_attempts):\n                if random.random() < self.goal_sample_rate:\n                    sample = goal_pos if tree_a is start_tree else start_pos\n                else:\n                    sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not in_obstacle(sample):\n                    break\n            else:\n                continue\n\n            nearest_node = nearest(grid_a, tree_a, sample)\n            new_pos = steer(nearest_node.position, sample)\n            if in_obstacle(new_pos) or edge_in_obstacle(nearest_node.position, new_pos):\n                continue\n\n            new_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            new_node = Node(new_pos, parent=nearest_node, cost=new_cost)\n            nearest_node.add_child(new_node)\n            tree_a.append(new_node)\n            all_nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n            insert_node(grid_a, new_node)\n\n            radius = adaptive_radius(len(all_nodes))\n            rewire(grid_a, tree_a, new_node, radius)\n\n            neighbor_candidates = get_neighbors(grid_b, new_pos, radius)\n            improved_path_found = False\n            for other_node in neighbor_candidates:\n                if edge_in_obstacle(new_pos, other_node.position):\n                    continue\n                combined_cost = new_node.cost + other_node.cost + math.dist(new_pos, other_node.position)\n                if combined_cost + 1e-12 < best_cost:\n                    best_cost = combined_cost\n                    best_pair = (new_node, other_node)\n                    edges.append((new_node, other_node))\n                    extracted_path = extract_path(new_node, other_node)\n                    extracted_path = shortcut_path(extracted_path)\n                    success_state = True\n                    improved_path_found = True\n                    if best_cost < self.step_size * 1.7:\n                        break\n            if improved_path_found and best_cost < self.step_size * 1.7:\n                break\n\n            if success_state and iteration % 150 == 0:\n                extracted_path = shortcut_path(extracted_path)\n\n        if not success_state and best_pair:\n            extracted_path = extract_path(best_pair[0], best_pair[1])\n            extracted_path = shortcut_path(extracted_path)\n            success_state = True\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=all_nodes,\n            edges=edges,\n        )\n\n    def _grid_offsets(self, dim, radius_cells):\n        def recurse(depth):\n            if depth == 0:\n                yield ()\n                return\n            for offset in range(-radius_cells, radius_cells + 1):\n                for tail in recurse(depth - 1):\n                    yield (offset,) + tail\n        return list(recurse(dim))\n\n    def _squared_dist(self, a, b):\n        return sum((a[d] - b[d]) ** 2 for d in range(len(a)))",
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 121, in evaluate\n    fitness, results = self.__evaluate_path(planning_module)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 75, in __evaluate_path\n    planner = alg.Planner(max_iter=5000)\nTypeError: Planner.__init__() got an unexpected keyword argument 'max_iter'\n"
    }
}
{
    "operator": "path_expert",
    "algorithm_description": null,
    "planning_mechanism": null,
    "code": null,
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "success_rate": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 115, in evaluate\n    exec(self.import_string+code_string, planning_module.__dict__)\nTypeError: can only concatenate str (not \"NoneType\") to str\n"
    }
}
{
    "operator": "cross_over",
    "algorithm_description": null,
    "planning_mechanism": null,
    "code": null,
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "success_rate": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 115, in evaluate\n    exec(self.import_string+code_string, planning_module.__dict__)\nTypeError: can only concatenate str (not \"NoneType\") to str\n"
    }
}
{
    "operator": "m2",
    "algorithm_description": null,
    "planning_mechanism": null,
    "code": null,
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "success_rate": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 115, in evaluate\n    exec(self.import_string+code_string, planning_module.__dict__)\nTypeError: can only concatenate str (not \"NoneType\") to str\n"
    }
}
{
    "operator": "time_expert",
    "algorithm_description": "This algorithm implements a bidirectional RRT* planner with adaptive and shrinking neighborhood radius, goal biasing, incremental shortcut smoothing during planning, and finer collision resolution for better edge validation. It grows two trees alternately from start and goal by sampling free space points (with goal bias), steering nearest nodes towards samples, rewiring neighbors within an adaptive radius to minimize cost, and attempts multiple candidate connections between trees within an adaptive connection radius. Early termination is triggered upon finding a high-quality path or the 30-second time limit. Continuous iterative shortcutting is applied during planning to smooth partial paths, improving path length and smoothness significantly.",
    "planning_mechanism": "The planner maintains two growing trees and expands them alternately by sampling points biased toward the goal, steering nearest nodes toward these points with a reduced step size for smoothness. It dynamically computes a diminishing rewiring radius dependent on tree size and dimensionality to optimize rewiring scope. For every new node, it tries to connect to multiple nearby nodes in the opposite tree within an enhanced adaptive connection radius to increase chances of shorter, smoother paths. Incremental shortcutting is performed periodically on the current best path during planning. The process halts if a sufficiently low-cost path is found or 30 seconds expire, returning the best path found so far.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except ValueError:\n            pass\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 4.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        # Gamma constant for radius calculation (tuned)\n        self.gamma_rrt_star = 20.0\n        self.goal_sample_rate = 0.2  # 20% samples biased towards goal\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n        import time\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def sample_free():\n            # Goal bias sampling\n            if random.random() < self.goal_sample_rate:\n                if not self._is_in_obstacle(goal_pos, obstacles, is_3d):\n                    return goal_pos\n            while True:\n                p = tuple(random.uniform(0, bounds[i]) for i in range(len(bounds)))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n\n        def nearest(tree, point):\n            # Linear search - could be improved with spatial indexing\n            return min(tree, key=lambda n: dist(n.position, point))\n\n        def near(tree, point, radius):\n            return [node for node in tree if dist(node.position, point) <= radius]\n\n        def steer(from_p, to_p, step):\n            d = dist(from_p, to_p)\n            if d <= step:\n                return to_p\n            ratio = step / d\n            return tuple(from_p[i] + (to_p[i] - from_p[i]) * ratio for i in range(len(from_p)))\n\n        def path_cost(node):\n            return node.cost\n\n        def extract_path(node_start, node_goal):\n            path_start = []\n            cur = node_start\n            while cur:\n                path_start.append(cur.position)\n                cur = cur.parent\n            path_goal = []\n            cur = node_goal\n            while cur:\n                path_goal.append(cur.position)\n                cur = cur.parent\n            return path_start[::-1] + path_goal\n\n        # Shortcutting function: attempts to shortcut the path incrementally\n        def shortcut_path(path, max_attempts=100):\n            if len(path) < 3:\n                return path\n            for _ in range(max_attempts):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1 = path[i]\n                p2 = path[j]\n                # Check edge collision at finer resolution (0.2 units)\n                if not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution=0.2):\n                    # Shortcut possible: remove intermediate nodes between i+1 and j-1\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = start_tree[:] + goal_tree[:]\n        edges = []\n\n        best_cost = float('inf')\n        best_connect = None\n        success = False\n        extracted_path = []\n\n        TIME_LIMIT = 30.0\n        start_time = time.monotonic()\n\n        d = len(bounds)\n        min_radius = self.step_size * 1.5  # Minimum radius for rewiring to avoid too small neighborhoods\n\n        for iter_count in range(self.max_iter):\n            if time.monotonic() - start_time > TIME_LIMIT:\n                break\n\n            # Switch trees to expand\n            tree_a = start_tree if iter_count % 2 == 0 else goal_tree\n            tree_b = goal_tree if iter_count % 2 == 0 else start_tree\n\n            sample = sample_free()\n            nearest_node = nearest(tree_a, sample)\n            new_pos = steer(nearest_node.position, sample, self.step_size)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d, resolution=0.5):\n                continue\n\n            # Adaptive radius: gamma * (log(n)/n)^{1/d} with min radius threshold and max cap\n            n = len(tree_a) + 1\n            radius = self.gamma_rrt_star * (math.log(n) / n) ** (1.0 / d)\n            radius = max(radius, min_radius)\n            radius = min(radius, self.step_size * 4.0)\n\n            near_nodes = near(tree_a, new_pos, radius)\n\n            # Choose best parent\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            min_parent = nearest_node\n            for near_node in near_nodes:\n                tentative_cost = near_node.cost + dist(near_node.position, new_pos)\n                if tentative_cost < min_cost:\n                    if not self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d, resolution=0.5):\n                        min_cost = tentative_cost\n                        min_parent = near_node\n\n            new_node = Node(new_pos, parent=min_parent, cost=min_cost)\n            min_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((min_parent, new_node))\n\n            # Rewire neighbors\n            for near_node in near_nodes:\n                if near_node is min_parent:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, near_node.position)\n                if new_cost + 1e-7 < near_node.cost:  # small epsilon for numerical stability\n                    if not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d, resolution=0.5):\n                        # Update edges\n                        if near_node.parent:\n                            try:\n                                edges.remove((near_node.parent, near_node))\n                            except ValueError:\n                                pass\n                            near_node.parent.remove_child(near_node)\n                        near_node.parent = new_node\n                        near_node.cost = new_cost\n                        new_node.add_child(near_node)\n                        edges.append((new_node, near_node))\n\n            # Attempt multiple connections to tree_b within dynamic connection radius\n            # Connection radius slightly larger than rewiring radius for more candidates\n            conn_radius = radius * 1.25\n            candidate_nodes = near(tree_b, new_node.position, conn_radius)\n            for tgt_node in candidate_nodes:\n                dist_between = dist(new_node.position, tgt_node.position)\n                if dist_between <= self.step_size * 2.0:  # accept connections within twice the step size\n                    if not self._is_edge_in_obstacle(new_node.position, tgt_node.position, obstacles, is_3d, resolution=0.3):\n                        candidate_cost = new_node.cost + tgt_node.cost + dist_between\n                        if candidate_cost < best_cost:\n                            best_cost = candidate_cost\n                            best_connect = (new_node, tgt_node)\n                            success = True\n                            # Continue searching for potentially better paths but enforce early break at low costs\n                            if best_cost <= dist(start_pos, goal_pos) * 1.02:\n                                # Good enough path found close to optimal, break early\n                                break\n            else:\n                # Continue if inner loop was not broken\n                continue\n            break  # break outer loop if inner break triggered\n\n            # Periodically attempt incremental shortcutting on best path found so far\n            if iter_count % 250 == 0 and success and best_connect is not None:\n                cur_path = extract_path(best_connect[0], best_connect[1])\n                shortened = shortcut_path(cur_path, max_attempts=30)\n                if len(shortened) < len(cur_path):\n                    extracted_path = shortened\n                else:\n                    extracted_path = cur_path\n\n        # If successful, extract and shortcut the found path\n        if success and best_connect is not None:\n            extracted_path = extract_path(best_connect[0], best_connect[1])\n            extracted_path = shortcut_path(extracted_path, max_attempts=100)\n        else:\n            # No direct connection found - attempt best partial connection between trees\n            # Use a limited search for near nodes crossing trees for best connection attempt\n            min_total_cost = float('inf')\n            best_pair = None\n            max_conn_dist = self.step_size * 2.0\n            for n1 in start_tree:\n                candidates = near(goal_tree, n1.position, max_conn_dist)\n                for n2 in candidates:\n                    d12 = dist(n1.position, n2.position)\n                    if not self._is_edge_in_obstacle(n1.position, n2.position, obstacles, is_3d, resolution=0.3):\n                        cost_sum = n1.cost + n2.cost + d12\n                        if cost_sum < min_total_cost:\n                            min_total_cost = cost_sum\n                            best_pair = (n1, n2)\n            if best_pair is not None:\n                extracted_path = extract_path(best_pair[0], best_pair[1])\n                extracted_path = shortcut_path(extracted_path, max_attempts=100)\n                success = True\n\n        return PlannerResult(\n            success=success,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 159, in evaluate\n    fitness, results = self.__evaluate_path(planning_module)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 125, in __evaluate_path\n    result, avg_result = evaluate_with_timeout(lambda: self.benchmarker.run(planner.plan),\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 39, in evaluate_with_timeout\n    p.start()\n  File \"C:\\Users\\byeonghwa\\anaconda3\\envs\\peoh\\lib\\multiprocessing\\process.py\", line 121, in start\n    self._popen = self._Popen(self)\n  File \"C:\\Users\\byeonghwa\\anaconda3\\envs\\peoh\\lib\\multiprocessing\\context.py\", line 224, in _Popen\n    return _default_context.get_context().Process._Popen(process_obj)\n  File \"C:\\Users\\byeonghwa\\anaconda3\\envs\\peoh\\lib\\multiprocessing\\context.py\", line 336, in _Popen\n    return Popen(process_obj)\n  File \"C:\\Users\\byeonghwa\\anaconda3\\envs\\peoh\\lib\\multiprocessing\\popen_spawn_win32.py\", line 93, in __init__\n    reduction.dump(process_obj, to_child)\n  File \"C:\\Users\\byeonghwa\\anaconda3\\envs\\peoh\\lib\\multiprocessing\\reduction.py\", line 60, in dump\n    ForkingPickler(file, protocol).dump(obj)\nAttributeError: Can't pickle local object 'PATHPLANNING.__evaluate_path.<locals>.<lambda>'\n"
    }
}
{
    "operator": "time_expert",
    "algorithm_description": "This algorithm implements an enhanced bidirectional RRT* planner with goal biasing, adaptive shrinking neighborhood radius using a smaller gamma constant, efficient squared-distance neighbor searches, and early stopping upon first improved connection detection. It also applies periodic iterative shortcut smoothing on the best path found so far to improve smoothness and path length throughout planning. Sampling is retried with a limited retry count to avoid excessive computation near obstacles. Collision checking resolution adjusts dynamically based on edge length to optimize speed and accuracy. The planner alternately grows trees from start and goal with a smaller step size for more refined expansions, rewiring nearby nodes to minimize cost locally, and attempts multiple candidate connections to the opposite tree within an adaptive radius to improve path quality and smoothness. The search halts after 30 seconds or upon finding an improved path, returning the best feasible path discovered.",
    "planning_mechanism": "The planner maintains two trees grown alternately by sampling the free space with goal biasing and limited retries, steering nearest nodes toward samples with a small step size, and rewiring neighbors within an adaptive radius computed from node count, problem dimension, and a tuned gamma parameter. It attempts multiple candidate connections between trees within an adaptive connection radius. Early stopping occurs immediately upon path improvement. Collision checking resolution scales dynamically with edge length. Iterative shortcutting is applied periodically to smooth the best path continuously. The process repeats until time expires or a good solution is found, returning the shortest best path discovered.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 4.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self._goal_sample_rate = 0.2  # Probability of sampling goal to bias growth\n        self._gamma = 20.0            # Smaller gamma to reduce neighbor count in rewiring\n        self._shortcut_interval = 50  # Perform shortcutting every 50 iterations\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n        import time\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = start_tree[:] + goal_tree[:]\n        edges = []\n\n        success = False\n        best_cost = float('inf')\n        best_connect = None\n        best_path = []\n\n        start_time = time.monotonic()\n        TIME_LIMIT = 30.0\n\n        dim = len(bounds)\n\n        def sq_dist(a, b):\n            return sum((a[i]-b[i])**2 for i in range(dim))\n\n        def dist(a, b):\n            return math.sqrt(sq_dist(a, b))\n\n        def sample_free():\n            max_retries = 30\n            for _ in range(max_retries):\n                if random.random() < self._goal_sample_rate:\n                    # Goal biased sample\n                    p = goal_pos\n                else:\n                    p = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n            # Fallback to random sampling without collision check for rare degenerate cases\n            for _ in range(100):\n                p = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n            return goal_pos  # Last resort\n\n        def nearest(tree, point):\n            best_node = None\n            best_dist = float('inf')\n            for node in tree:\n                d = sq_dist(node.position, point)\n                if d < best_dist:\n                    best_dist = d\n                    best_node = node\n            return best_node\n\n        def near(tree, point, radius):\n            radius_sq = radius*radius\n            return [node for node in tree if sq_dist(node.position, point) <= radius_sq]\n\n        def steer(from_p, to_p, step):\n            d = dist(from_p, to_p)\n            if d <= step:\n                return to_p\n            ratio = step / d\n            return tuple(from_p[i] + (to_p[i] - from_p[i]) * ratio for i in range(dim))\n\n        def extract_path(node_start, node_goal):\n            path_start = []\n            cur = node_start\n            while cur:\n                path_start.append(cur.position)\n                cur = cur.parent\n            path_goal = []\n            cur = node_goal\n            while cur:\n                path_goal.append(cur.position)\n                cur = cur.parent\n            return path_start[::-1] + path_goal\n\n        def iterative_shortcut(path, attempts=100):\n            if len(path) < 3:\n                return path\n            for _ in range(attempts):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path)-3)\n                j = random.randint(i+2, len(path)-1)\n                p_i = path[i]\n                p_j = path[j]\n                if not self._is_edge_in_obstacle(p_i, p_j, obstacles, is_3d, resolution= self.step_size * 0.5):\n                    # Remove intermediate points\n                    path = path[:i+1] + path[j:]\n            return path\n\n        def rewire(new_node, near_nodes, tree):\n            for near_node in near_nodes:\n                if near_node is new_node.parent:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, near_node.position)\n                if new_cost + 1e-9 < near_node.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                        # Remove old edge\n                        if near_node.parent:\n                            try:\n                                near_node.parent.children.remove(near_node)\n                            except ValueError:\n                                pass\n                            try:\n                                edges.remove((near_node.parent, near_node))\n                            except ValueError:\n                                pass\n                        near_node.parent = new_node\n                        near_node.cost = new_cost\n                        new_node.add_child(near_node)\n                        edges.append((new_node, near_node))\n\n        iter_count = 0\n        while iter_count < self.max_iter:\n            if time.monotonic() - start_time > TIME_LIMIT:\n                break\n\n            tree_a = start_tree if iter_count % 2 == 0 else goal_tree\n            tree_b = goal_tree if iter_count % 2 == 0 else start_tree\n\n            sample = sample_free()\n\n            nearest_node = nearest(tree_a, sample)\n            new_pos = steer(nearest_node.position, sample, self.step_size)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                iter_count += 1\n                continue\n            edge_resolution = max(self.step_size * 0.2, 0.5)\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d, resolution=edge_resolution):\n                iter_count += 1\n                continue\n\n            n_nodes = max(len(tree_a), 2)\n            radius = min(self.step_size * 5,\n                         self._gamma * (math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n\n            near_nodes = near(tree_a, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            min_parent = nearest_node\n\n            for near_node in near_nodes:\n                cost_through_near = near_node.cost + dist(near_node.position, new_pos)\n                if cost_through_near + 1e-9 < min_cost:\n                    if not self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d, resolution=edge_resolution):\n                        min_cost = cost_through_near\n                        min_parent = near_node\n\n            new_node = Node(new_pos, parent=min_parent, cost=min_cost)\n            min_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((min_parent, new_node))\n\n            rewire(new_node, near_nodes, tree_a)\n\n            # Attempt multiple connections to opposite tree within adaptive radius\n            connect_radius = radius * 1.5\n            near_other = near(tree_b, new_node.position, connect_radius)\n            updated_best = False\n            for other_node in near_other:\n                if other_node is None or other_node == new_node:\n                    continue\n                dist_between = dist(new_node.position, other_node.position)\n                if dist_between <= connect_radius:\n                    if not self._is_edge_in_obstacle(new_node.position, other_node.position, obstacles, is_3d, resolution=edge_resolution):\n                        candidate_cost = new_node.cost + other_node.cost + dist_between\n                        if candidate_cost + 1e-9 < best_cost:\n                            best_cost = candidate_cost\n                            best_connect = (new_node, other_node)\n                            success = True\n                            updated_best = True\n                            best_path = extract_path(new_node, other_node)\n            if updated_best:\n                # Perform iterative shortcutting on best path found so far\n                best_path = iterative_shortcut(best_path, attempts=50)\n                # Early stopping on improvement\n                break\n\n            # Periodic shortcutting helps improve partial solutions\n            if iter_count > 0 and iter_count % self._shortcut_interval == 0 and success:\n                best_path = iterative_shortcut(best_path, attempts=50)\n\n            iter_count += 1\n\n        # If we have a connection, return that\n        if success and best_connect is not None:\n            extracted_path = best_path\n        else:\n            # Try to find best partial connection between trees within step_size\n            min_cost_partial = float('inf')\n            best_pair = None\n            for n1 in start_tree:\n                near_goal_candidates = [n2 for n2 in goal_tree if sq_dist(n1.position, n2.position) <= self.step_size ** 2]\n                for n2 in near_goal_candidates:\n                    edge_res = max(self.step_size * 0.2, 0.5)\n                    if not self._is_edge_in_obstacle(n1.position, n2.position, obstacles, is_3d, resolution=edge_res):\n                        cost_sum = n1.cost + n2.cost + dist(n1.position, n2.position)\n                        if cost_sum < min_cost_partial:\n                            min_cost_partial = cost_sum\n                            best_pair = (n1, n2)\n            if best_pair is not None:\n                extracted_path = extract_path(best_pair[0], best_pair[1])\n                extracted_path = iterative_shortcut(extracted_path, attempts=100)\n                success = True\n            else:\n                extracted_path = []\n\n        return PlannerResult(\n            success=success,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 159, in evaluate\n    fitness, results = self.__evaluate_path(planning_module)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 125, in __evaluate_path\n    result, avg_result = evaluate_with_timeout(lambda: self.benchmarker.run(planner.plan),\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 39, in evaluate_with_timeout\n    p.start()\n  File \"C:\\Users\\byeonghwa\\anaconda3\\envs\\peoh\\lib\\multiprocessing\\process.py\", line 121, in start\n    self._popen = self._Popen(self)\n  File \"C:\\Users\\byeonghwa\\anaconda3\\envs\\peoh\\lib\\multiprocessing\\context.py\", line 224, in _Popen\n    return _default_context.get_context().Process._Popen(process_obj)\n  File \"C:\\Users\\byeonghwa\\anaconda3\\envs\\peoh\\lib\\multiprocessing\\context.py\", line 336, in _Popen\n    return Popen(process_obj)\n  File \"C:\\Users\\byeonghwa\\anaconda3\\envs\\peoh\\lib\\multiprocessing\\popen_spawn_win32.py\", line 93, in __init__\n    reduction.dump(process_obj, to_child)\n  File \"C:\\Users\\byeonghwa\\anaconda3\\envs\\peoh\\lib\\multiprocessing\\reduction.py\", line 60, in dump\n    ForkingPickler(file, protocol).dump(obj)\nAttributeError: Can't pickle local object 'PATHPLANNING.__evaluate_path.<locals>.<lambda>'\n"
    }
}
{
    "operator": "time_expert",
    "algorithm_description": "This algorithm implements an improved bidirectional RRT* planner with adaptive radius rewiring, goal bias sampling, and efficient collision checking for faster convergence. It alternates expanding trees from start and goal, samples with goal bias to speed up goal reaching, dynamically adjusts neighbor radius inversely with node count to limit rewiring overhead, and performs early termination when a better path is found. Incremental rewiring improves path quality, while pruning of nodes outside the bounds and incremental cost updates maintain consistency. The search respects time constraints and avoids unnecessary collision checks, returning the best path found when timing out or completing.",
    "planning_mechanism": "The planner grows two RRT* trees from start and goal points alternately. Sampling is biased towards the goal at a fixed rate. For each sampled point, the nearest node is steered towards it. The new node's parent is chosen via rewiring within an adaptive radius that shrinks as trees grow, balancing between exploration and local optimization. After insertion, nearby nodes are rewired for lower cost. The trees try to connect periodically; upon a successful, collision-free connection, the best combined path is extracted. The procedure interrupts if it finds a valid path early or when the 30-second limit is hit, returning the best current solution._\n\n```python\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = 0.15  # probability of sampling goal for biasing\n\n    def plan(self, map) -",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = 0.15  # probability of sampling goal for biasing\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n        import time\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dimension = len(bounds)\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = start_tree[:] + goal_tree[:]\n        edges = []\n\n        success = False\n        best_cost = float('inf')\n        best_connection = None\n\n        time_limit = 30.0\n        start_time = time.monotonic()\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def sample_free():\n            # Goal biased sampling to improve convergence speed\n            if random.random() < self.goal_sample_rate:\n                return goal_pos\n            while True:\n                p = tuple(random.uniform(0, bounds[i]) for i in range(dimension))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n\n        def nearest(tree, point):\n            # Linear scan nearest; could be optimized with spatial index if allowed\n            return min(tree, key=lambda n: dist(n.position, point))\n\n        def near(tree, point, radius):\n            r_sq = radius * radius\n            return [node for node in tree if self._dist_sq(node.position, point) <= r_sq]\n\n        def steer(from_p, to_p, step):\n            d = dist(from_p, to_p)\n            if d <= step:\n                return to_p\n            ratio = step / d\n            return tuple(from_p[i] + (to_p[i] - from_p[i]) * ratio for i in range(dimension))\n\n        def extract_path(connect_start, connect_goal):\n            path_start = []\n            node = connect_start\n            while node is not None:\n                path_start.append(node.position)\n                node = node.parent\n            path_goal = []\n            node = connect_goal\n            while node is not None:\n                path_goal.append(node.position)\n                node = node.parent\n            return path_start[::-1] + path_goal\n\n        def update_edge_parent(child_node, new_parent, new_cost):\n            # Reassign parent with cost update and maintain children linkage\n            old_parent = child_node.parent\n            if old_parent is not None:\n                old_parent.remove_child(child_node)\n                try:\n                    edges.remove((old_parent, child_node))\n                except ValueError:\n                    pass\n            child_node.parent = new_parent\n            child_node.cost = new_cost\n            new_parent.add_child(child_node)\n            edges.append((new_parent, child_node))\n\n        def connection_radius(num_nodes):\n            # Adaptive radius: shrink as trees grow for rewiring efficiency\n            if num_nodes <= 1:\n                return self.step_size * 2.5\n            gamma_rrtstar = 20.0  # tuned constant\n            r = gamma_rrtstar * (math.log(num_nodes) / num_nodes) ** (1 / dimension)\n            return min(r, self.step_size * 4.0)\n\n        best_path_cost = float('inf')\n        best_path_pair = None\n\n        for iter_num in range(self.max_iter):\n            if time.monotonic() - start_time > time_limit:\n                break  # Time limit reached\n\n            # Alternate tree to expand\n            tree_from = start_tree if (iter_num % 2 == 0) else goal_tree\n            tree_to = goal_tree if (iter_num % 2 == 0) else start_tree\n\n            sample = sample_free()\n\n            nearest_node = nearest(tree_from, sample)\n            new_pos = steer(nearest_node.position, sample, self.step_size)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d, resolution=0.5):\n                continue\n\n            radius = connection_radius(len(tree_from) + 1)\n            near_nodes = near(tree_from, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            min_parent = nearest_node\n            # Choose best parent with least cost and collision-free edge\n            for near_node in near_nodes:\n                cost_through = near_node.cost + dist(near_node.position, new_pos)\n                if cost_through < min_cost:\n                    if not self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d, resolution=0.5):\n                        min_cost = cost_through\n                        min_parent = near_node\n\n            new_node = Node(new_pos, parent=min_parent, cost=min_cost)\n            min_parent.add_child(new_node)\n            tree_from.append(new_node)\n            nodes.append(new_node)\n            edges.append((min_parent, new_node))\n\n            # Rewire neighbors if this node provides lower cost path\n            for near_node in near_nodes:\n                if near_node is min_parent:\n                    continue\n                potential_cost = new_node.cost + dist(new_node.position, near_node.position)\n                if potential_cost < near_node.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d, resolution=0.5):\n                        update_edge_parent(near_node, new_node, potential_cost)\n\n            # Try to connect new_node to tree_to to find solution\n            radius_connection = connection_radius(len(tree_to))\n            near_in_other = near(tree_to, new_node.position, radius_connection)\n\n            for other_node in near_in_other:\n                dist_nodes = dist(new_node.position, other_node.position)\n                cost_through = new_node.cost + other_node.cost + dist_nodes\n                if dist_nodes <= self.step_size * 1.5 and cost_through < best_path_cost:\n                    if not self._is_edge_in_obstacle(new_node.position, other_node.position, obstacles, is_3d, resolution=0.5):\n                        best_path_cost = cost_through\n                        best_path_pair = (new_node, other_node)\n                        success = True\n                        # Early stop if improvement found\n                        break\n            if success:\n                break\n\n        extracted_path = []\n        if success and best_path_pair is not None:\n            extracted_path = extract_path(best_path_pair[0], best_path_pair[1])\n        else:\n            # No connection found: find best partial connectable pair if any\n            min_partial_cost = float('inf')\n            best_partial = None\n            for n1 in start_tree:\n                near_nodes = near(goal_tree, n1.position, self.step_size * 1.5)\n                for n2 in near_nodes:\n                    distance_between = dist(n1.position, n2.position)\n                    if distance_between <= self.step_size * 1.5:\n                        if not self._is_edge_in_obstacle(n1.position, n2.position, obstacles, is_3d, resolution=0.5):\n                            total_cost = n1.cost + n2.cost + distance_between\n                            if total_cost < min_partial_cost:\n                                min_partial_cost = total_cost\n                                best_partial = (n1, n2)\n            if best_partial is not None:\n                extracted_path = extract_path(best_partial[0], best_partial[1])\n                success = True\n\n        return PlannerResult(\n            success=success,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _dist_sq(self, a, b):\n        return sum((a[i] - b[i]) ** 2 for i in range(len(a)))",
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 159, in evaluate\n    fitness, results = self.__evaluate_path(planning_module)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 125, in __evaluate_path\n    result, avg_result = evaluate_with_timeout(self.benchmarker.run(planner.plan),\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 62, in evaluate_with_timeout\n    raise payload\nTypeError: 'tuple' object is not callable\n"
    }
}
{
    "operator": "time_expert",
    "algorithm_description": "This algorithm is an improved bidirectional RRT* planner that leverages adaptive neighborhood radius scaling, efficient sampling with a fixed retry limit, squared-distance nearest neighbor searches for speed, and incremental rewiring encapsulated for clarity. It incorporates early stopping upon first valid connection to reduce planning time and employs final path shortcutting to enhance path length and smoothness. This planner carefully manages collision-checked node and edge addition, respects map boundaries, and enforces a 30-second hard time limit, returning the best path found so far.",
    "planning_mechanism": "The planner grows two RRT* trees (from start and goal) alternately by sampling free points with retries, extending nearest nodes stepwise, rewiring neighbors within a shrinking radius based on tree size and dimension, and attempts connection between trees as nodes are added. Rewiring uses squared distances for efficiency and a small tolerance to avoid redundant operations. Once two trees connect, early stopping triggers. After planning, the extracted path undergoes shortcutting to reduce length and jaggedness, improving smoothness and overall quality.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n        \n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.TIME_LIMIT = 30.0\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        start_tree = [Node(start_pos, cost=0.0)]\n        goal_tree = [Node(goal_pos, cost=0.0)]\n\n        all_nodes = start_tree[:] + goal_tree[:]\n        edges = []\n\n        start_time = time.monotonic()\n\n        success = False\n        best_connect = None\n        best_cost = float('inf')\n\n        # Fast squared Euclidean distance\n        def dist2(a, b):\n            return sum((a[i] - b[i])**2 for i in range(len(a)))\n\n        def dist(a, b):\n            return math.sqrt(dist2(a,b))\n\n        # Sampling with retry limit (to avoid infinite loops)\n        def sample_free(max_trials=30):\n            for _ in range(max_trials):\n                p = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n            # fallback: return start or goal to ensure progress\n            return start_pos if random.random() < 0.5 else goal_pos\n\n        # Find nearest node by squared distance\n        def nearest(tree, point):\n            best = None\n            best_d2 = float('inf')\n            for n in tree:\n                d2 = dist2(n.position, point)\n                if d2 < best_d2:\n                    best_d2 = d2\n                    best = n\n            return best\n\n        # Find neighbors within radius (using squared distance)\n        def near(tree, point, radius):\n            radius2 = radius*radius\n            return [node for node in tree if dist2(node.position, point) <= radius2]\n\n        def steer(from_p, to_p, step):\n            d = dist(from_p, to_p)\n            if d <= step:\n                return to_p\n            ratio = step / d\n            return tuple(from_p[i] + (to_p[i] - from_p[i]) * ratio for i in range(dim))\n\n        # Extract path by traversing parents from nodes of start and goal trees\n        def extract_path(node_start, node_goal):\n            path_start = []\n            cur = node_start\n            while cur:\n                path_start.append(cur.position)\n                cur = cur.parent\n            path_goal = []\n            cur = node_goal\n            while cur:\n                path_goal.append(cur.position)\n                cur = cur.parent\n            return path_start[::-1] + path_goal\n\n        # Shortcutting: tries to connect non-adjacent waypoints directly if collision-free\n        def path_shortcut(path, max_attempts=50):\n            if len(path) < 3:\n                return path  # nothing to shortcut\n            for _ in range(max_attempts):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path)-3)\n                j = random.randint(i+2, len(path)-1)\n                if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                    # remove intermediate points i+1..j-1\n                    path = path[:i+1] + path[j:]\n            return path\n\n        # Rewiring encapsulated for clarity and efficiency\n        def rewire(tree, neighbors, new_node):\n            tol = 1e-9\n            for near_node in neighbors:\n                if near_node is new_node.parent:\n                    continue\n                edge_cost = dist(new_node.position, near_node.position)\n                new_cost = new_node.cost + edge_cost\n                if new_cost + tol < near_node.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                        # Remove old edge\n                        if near_node.parent:\n                            try:\n                                edges.remove((near_node.parent, near_node))\n                            except ValueError:\n                                pass\n                            near_node.parent.remove_child(near_node)\n                        # Add new edge\n                        near_node.parent = new_node\n                        near_node.cost = new_cost\n                        new_node.add_child(near_node)\n                        edges.append((new_node, near_node))\n\n        # Main planning loop\n        for iter_count in range(self.max_iter):\n            if time.monotonic() - start_time > self.TIME_LIMIT:\n                break\n\n            # Alternate trees\n            tree_a = start_tree if (iter_count % 2 == 0) else goal_tree\n            tree_b = goal_tree if (iter_count % 2 == 0) else start_tree\n\n            sample = sample_free()\n\n            nearest_node = nearest(tree_a, sample)\n            new_pos = steer(nearest_node.position, sample, self.step_size)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            # Adaptive neighborhood radius (log(n)/n)^{1/d} with safeguards\n            n_nodes = max(len(tree_a), 2)\n            gamma = 20.0  # tuned smaller gamma for smaller neighborhoods to save time\n            radius = min(self.step_size*5, gamma * (math.log(n_nodes) / n_nodes) ** (1/dim))\n            neighbors = near(tree_a, new_pos, radius)\n\n            # Choose best parent minimizing cost+edge if collision-free\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            min_parent = nearest_node\n            for near_node in neighbors:\n                cost_through_near = near_node.cost + dist(near_node.position, new_pos)\n                if cost_through_near + 1e-9 < min_cost:\n                    if not self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d):\n                        min_cost = cost_through_near\n                        min_parent = near_node\n\n            new_node = Node(new_pos, parent=min_parent, cost=min_cost)\n            min_parent.add_child(new_node)\n            tree_a.append(new_node)\n            all_nodes.append(new_node)\n            edges.append((min_parent, new_node))\n\n            rewire(tree_a, neighbors, new_node)\n\n            # Attempt connection to other tree - try multiple neighbors within step_size for better chance\n            radius_connect = self.step_size * 1.5\n            neighbors_b = near(tree_b, new_pos, radius_connect)\n            connected_in_this_iter = False\n            for near_b_node in neighbors_b:\n                d_new_other = dist(new_pos, near_b_node.position)\n                if d_new_other <= radius_connect:\n                    if not self._is_edge_in_obstacle(new_pos, near_b_node.position, obstacles, is_3d):\n                        candidate_cost = new_node.cost + near_b_node.cost + d_new_other\n                        if candidate_cost + 1e-9 < best_cost:\n                            best_cost = candidate_cost\n                            best_connect = (new_node, near_b_node)\n                            success = True\n                            connected_in_this_iter = True\n                            break\n            if connected_in_this_iter:\n                break  # early stop on first good connection\n\n        extracted_path = []\n        if success and best_connect is not None:\n            extracted_path = extract_path(best_connect[0], best_connect[1])\n            extracted_path = path_shortcut(extracted_path, max_attempts=100)\n\n        # If no success, try partial best connection among all nodes with limited radius_connect\n        if not success:\n            search_radius = self.step_size * 1.5\n            min_cost = float('inf')\n            best_pair = None\n            # For efficiency limit number of tries (sample nodes randomly if large trees)\n            max_search = 200\n            subset_start = start_tree if len(start_tree) <= max_search else random.sample(start_tree, max_search)\n            subset_goal = goal_tree if len(goal_tree) <= max_search else random.sample(goal_tree, max_search)\n            for n1 in subset_start:\n                for n2 in subset_goal:\n                    d12 = dist(n1.position, n2.position)\n                    if d12 <= search_radius and not self._is_edge_in_obstacle(n1.position, n2.position, obstacles, is_3d):\n                        cost_sum = n1.cost + n2.cost + d12\n                        if cost_sum < min_cost:\n                            min_cost = cost_sum\n                            best_pair = (n1, n2)\n            if best_pair is not None:\n                extracted_path = extract_path(best_pair[0], best_pair[1])\n                extracted_path = path_shortcut(extracted_path, max_attempts=100)\n                success = True\n\n        return PlannerResult(\n            success=success,\n            path=extracted_path,\n            nodes=all_nodes,\n            edges=edges\n        )",
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 159, in evaluate\n    fitness, results = self.__evaluate_path(planning_module)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 125, in __evaluate_path\n    result, avg_result = evaluate_with_timeout(self.benchmarker.run(planner.plan),\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 62, in evaluate_with_timeout\n    raise payload\nTypeError: 'tuple' object is not callable\n"
    }
}
{
    "operator": "time_expert",
    "algorithm_description": "This algorithm is an enhanced bidirectional RRT* planner incorporating adaptive rewiring radius, goal biasing, strategic sampling within informed sets after a solution is found, and iterative path shortcutting for smoothness and shortened path length. It alternates between growing start and goal trees with cost-aware parent selection and rewiring in a dynamically shrinking neighborhood. It employs early stopping on improved connection and continuously maintains the best solution found. The approach uses time limits and iteration caps to ensure responsiveness, and applies post-planning iterative shortcutting to smooth the final path.",
    "planning_mechanism": "The planner alternates extending two trees (start and goal), sampling mostly uniform points with a goal bias, then after a first solution, samples within an ellipsoid \"informed\" region to focus search for better paths. New nodes connect to lowest-cost parents within an adaptive radius that shrinks as trees grow, enabling efficient rewiring. When a connection between trees is found and improves path cost, the best path is updated, and planning continues up to time/iteration limits. After planning, iterative shortcutting reduces unnecessary waypoints, improving path smoothness and shortening overall length.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except ValueError:\n            pass\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.GAMMA = 30.0            # rewiring radius tuning constant\n        self.GOAL_SAMPLE_RATE = 0.15 # probability for goal bias sampling\n        self.SHORTCUT_ITERS = 120    # shortcutting attempts after planning\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n        import time\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = start_tree[:] + goal_tree[:]\n        edges = []\n\n        best_cost = float('inf')\n        best_connection = None\n        success = False\n\n        start_time = time.monotonic()\n        TIME_LIMIT = 30.0\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_p, to_p, step):\n            d = dist(from_p, to_p)\n            if d <= step:\n                return to_p\n            ratio = step / d\n            return tuple(from_p[i] + (to_p[i] - from_p[i]) * ratio for i in range(len(from_p)))\n\n        def sample_uniform_free():\n            # Uniform random sample in bounds hitting free space\n            while True:\n                p = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n\n        def sample_goal_bias():\n            # With GOAL_SAMPLE_RATE probability return goal or start (depending on tree), else uniform free\n            if random.random() < self.GOAL_SAMPLE_RATE:\n                return goal_pos\n            return sample_uniform_free()\n\n        def sample_informed(c_best, c_min, start_p, goal_p):\n            # Sample within prolate hyperspheroid (informed set) if c_best < inf else uniform\n            if c_best == float('inf'):\n                return sample_uniform_free()\n            else:\n                # Calculate unit vector from start to goal\n                center = tuple((start_p[i] + goal_p[i]) * 0.5 for i in range(dim))\n                a1 = tuple((goal_p[i] - start_p[i]) / c_min for i in range(dim))\n                # Define rotation matrix via coordinate transformations\n                # Using orthonormal basis: a1 as first basis vector, construct other bases via Gram-Schmidt if needed\n                # For 2D and 3D simplified, keep rotation as identity for 2D aligned case\n                # Length of major axis: c_best/2; minor axis: sqrt(c_best^2 - c_min^2)/2\n                r1 = c_best * 0.5\n                if dim == 2:\n                    r2 = math.sqrt(c_best**2 - c_min**2) * 0.5 if c_best**2 - c_min**2 > 0 else 0.0\n\n                    while True:\n                        # Sample in unit circle\n                        theta = random.uniform(0, 2 * math.pi)\n                        rad = random.uniform(0, 1) ** 0.5\n                        x1 = rad * math.cos(theta)\n                        x2 = rad * math.sin(theta)\n                        # Scale by radii\n                        sample_local = (x1 * r1, x2 * r2)\n                        # Rotate aligned with a1 (unit vector on x-axis for 2D)\n                        # Here a1 assumed aligned with x-axis, so direct add\n                        sample_world = (center[0] + sample_local[0], center[1] + sample_local[1])\n                        if 0 <= sample_world[0] <= bounds[0] and 0 <= sample_world[1] <= bounds[1]:\n                            if not self._is_in_obstacle(sample_world, obstacles, is_3d):\n                                return sample_world\n                else:\n                    # For 3D or higher dim: sample unit ball then scale\n                    r2 = math.sqrt(c_best**2 - c_min**2)*0.5 if c_best**2 - c_min**2 > 0 else 0.0\n                    while True:\n                        # Sample inside unit ball\n                        vec = [random.gauss(0,1) for _ in range(dim)]\n                        norm = math.sqrt(sum(v*v for v in vec))\n                        unit_vec = [v/norm for v in vec]\n                        rad = random.uniform(0,1) ** (1/dim)\n                        scaled_unit = [uv * rad for uv in unit_vec]\n                        # Scale axes: first axis by r1, others by r2\n                        scaled_unit[0] *= r1\n                        for i in range(1, dim):\n                            scaled_unit[i] *= r2\n                        sample_world = tuple(center[i] + scaled_unit[i] for i in range(dim))\n                        if all(0 <= sample_world[i] <= bounds[i] for i in range(dim)):\n                            if not self._is_in_obstacle(sample_world, obstacles, is_3d):\n                                return sample_world\n\n        def nearest(tree, point):\n            best_node = None\n            best_dist = float('inf')\n            for node in tree:\n                d = dist(node.position, point)\n                if d < best_dist:\n                    best_dist = d\n                    best_node = node\n            return best_node\n\n        def near(tree, point, radius):\n            return [node for node in tree if dist(node.position, point) <= radius]\n\n        def path_cost(node):\n            return node.cost\n\n        def extract_path(node_start, node_goal):\n            path_start = []\n            cur = node_start\n            while cur:\n                path_start.append(cur.position)\n                cur = cur.parent\n            path_goal = []\n            cur = node_goal\n            while cur:\n                path_goal.append(cur.position)\n                cur = cur.parent\n            return path_start[::-1] + path_goal\n\n        def try_connect_nodes(from_node, to_node):\n            d = dist(from_node.position, to_node.position)\n            if d > self.step_size:\n                return None\n            if self._is_edge_in_obstacle(from_node.position, to_node.position, obstacles, is_3d):\n                return None\n            return d\n\n        def update_best_connection(new_node, other_tree):\n            nonlocal best_cost, best_connection, success\n            near_node = nearest(other_tree, new_node.position)\n            dist_between = dist(new_node.position, near_node.position)\n            if dist_between <= self.step_size:\n                if not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                    candidate_cost = new_node.cost + near_node.cost + dist_between\n                    if candidate_cost < best_cost:\n                        best_cost = candidate_cost\n                        best_connection = (new_node, near_node)\n                        success = True\n\n        def path_shortcut(path):\n            if len(path) < 3:\n                return path\n            import math\n            shortened = [path[0]]\n            i = 0\n            while i < len(path)-1:\n                j = len(path)-1\n                while j > i+1:\n                    if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                        break\n                    j -= 1\n                shortened.append(path[j])\n                i = j\n            return shortened\n\n        def iterative_shortcutting(path, iters):\n            best_path = path[:]\n            for _ in range(iters):\n                if len(best_path) < 3:\n                    break\n                i = random.randint(0, len(best_path)-3)\n                j = random.randint(i+2, len(best_path)-1)\n                if not self._is_edge_in_obstacle(best_path[i], best_path[j], obstacles, is_3d):\n                    # Shortcut\n                    new_path = best_path[:i+1] + best_path[j:]\n                    best_path = new_path\n            return best_path\n\n        def add_node(tree, node):\n            tree.append(node)\n            nodes.append(node)\n\n        def rewire(tree, new_node, near_nodes):\n            for near_node in near_nodes:\n                if near_node == new_node.parent:\n                    continue\n                edge_cost = dist(new_node.position, near_node.position)\n                new_cost = new_node.cost + edge_cost\n                if new_cost + 1e-9 < near_node.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                        # Remove old edge\n                        if near_node.parent:\n                            near_node.parent.remove_child(near_node)\n                            try:\n                                edges.remove((near_node.parent, near_node))\n                            except ValueError:\n                                pass\n                        # Reassign parent and cost\n                        near_node.parent = new_node\n                        near_node.cost = new_cost\n                        new_node.add_child(near_node)\n                        edges.append((new_node, near_node))\n\n        def compute_radius(n):\n            if n <= 1:\n                return self.step_size * 5\n            return min(self.step_size * 5, self.GAMMA * ((math.log(n) / n) ** (1.0/dim)))\n\n        # Start main loop\n        for it in range(self.max_iter):\n            elapsed = time.monotonic() - start_time\n            if elapsed > TIME_LIMIT:\n                break\n\n            # Alternate tree growth\n            tree_a = start_tree if it % 2 == 0 else goal_tree\n            tree_b = goal_tree if it % 2 == 0 else start_tree\n            start_tree_is_a = (tree_a is start_tree)\n\n            # Sample point\n            if success:\n                # Sample from ellipsoid informed set to improve solution\n                sample = sample_informed(best_cost, dist(start_pos, goal_pos), start_pos, goal_pos)\n            else:\n                # Before solution: employ goal biasing toward goal (if growing start tree), else uniform free\n                if start_tree_is_a:\n                    if random.random() < self.GOAL_SAMPLE_RATE:\n                        sample = goal_pos\n                    else:\n                        sample = sample_uniform_free()\n                else:\n                    if random.random() < self.GOAL_SAMPLE_RATE:\n                        sample = start_pos\n                    else:\n                        sample = sample_uniform_free()\n\n            nearest_node = nearest(tree_a, sample)\n            new_pos = steer(nearest_node.position, sample, self.step_size)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            n = len(tree_a) + 1\n            radius = compute_radius(n)\n            near_nodes = near(tree_a, new_pos, radius)\n\n            # Select lowest cost parent in near set + nearest node\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            min_parent = nearest_node\n            for near_node in near_nodes:\n                c = near_node.cost + dist(near_node.position, new_pos)\n                if c < min_cost:\n                    if not self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d):\n                        min_cost = c\n                        min_parent = near_node\n\n            new_node = Node(new_pos, parent=min_parent, cost=min_cost)\n            min_parent.add_child(new_node)\n            add_node(tree_a, new_node)\n            edges.append((min_parent, new_node))\n\n            # Rewire near nodes for cost improvement\n            rewire(tree_a, new_node, near_nodes)\n\n            # Try connecting new_node to other tree\n            update_best_connection(new_node, tree_b)\n\n            # Early stop if very close to optimal or after first connection to reduce runtime\n            # Here we allow full time but can break early if desired\n            # if success and (time.monotonic() - start_time) > 2.0:\n            #     break\n\n        # Extract path if found\n        path = []\n        if success and best_connection is not None:\n            path = extract_path(best_connection[0], best_connection[1])\n            # Iterative shortcutting to smooth path\n            path = iterative_shortcutting(path, self.SHORTCUT_ITERS)\n\n        # If no success, try best approximate connection between trees\n        if not success:\n            min_cost = float('inf')\n            best_pair = None\n            for n1 in start_tree:\n                n2 = nearest(goal_tree, n1.position)\n                d12 = dist(n1.position, n2.position)\n                if d12 <= self.step_size:\n                    if not self._is_edge_in_obstacle(n1.position, n2.position, obstacles, is_3d):\n                        cost_sum = n1.cost + n2.cost + d12\n                        if cost_sum < min_cost:\n                            min_cost = cost_sum\n                            best_pair = (n1, n2)\n            if best_pair is not None:\n                success = True\n                path = extract_path(best_pair[0], best_pair[1])\n                path = iterative_shortcutting(path, self.SHORTCUT_ITERS)\n\n        return PlannerResult(\n            success=success,\n            path=path,\n            nodes=nodes,\n            edges=edges\n        )",
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 172, in evaluate\n    fitness, results = self.__evaluate_path(planning_module, code_string=code_string)\nUnboundLocalError: local variable 'planning_module' referenced before assignment\n"
    }
}
{
    "operator": "time_expert",
    "algorithm_description": "This algorithm is a bidirectional informed RRT*-based planner with adaptive rewiring radius, goal bias sampling and incremental path shortcutting. It grows two trees from start and goal, focusing sampling around the line connecting them to accelerate convergence. The rewiring radius adapts dynamically with tree size, balancing optimization and efficiency. After each connection, incremental shortcutting improves path length and smoothness progressively. The planner respects collision constraints, bounding box limits, and halts if a time limit is reached or an optimal path found, always returning the best discovered path so far.",
    "planning_mechanism": "The planner alternates expansion between start and goal trees, sampling with goal bias and informed heuristics inside an ellipsoidal region around the current best path. It extends nearest nodes toward samples with fixed step size, rewires neighbors within a dynamically computed radius to improve path cost, and tries multiple candidate connections between trees. Incremental shortcutting is applied periodically to improve path quality. The search stops early on time limit or satisfactory solution to reduce planning time.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\nclass Planner:\n    def __init__(self, max_iter: int=7000, step_size: float=4.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = 0.15  # goal bias\n        self.shortcut_freq = 50       # frequency of shortcut attempts\n        self.shortcut_resolution = 0.5\n        self.gamma = 35.0             # rewiring constant\n\n    def plan(self, map) -> 'PlannerResult':\n        import time\n        import random\n        import math\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = start_tree[:] + goal_tree[:]\n        edges = []\n\n        success = False\n        best_cost = float('inf')\n        best_connect = None\n\n        start_time = time.monotonic()\n        TIME_LIMIT = 30.0\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def sample_free_ellipsoid(cs, ce, cmax):\n            # Sample inside an nD prolate hyperspheroid (ellipse in 2D) for informed sampling\n            # If no cmax (inf), sample uniform random free point\n            if cmax == float('inf'):\n                while True:\n                    p = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                    if not self._is_in_obstacle(p, obstacles, is_3d):\n                        return p\n            else:\n                cmin = dist(cs, ce)\n                if cmax < cmin:\n                    cmax = cmin\n                center = tuple((cs[i] + ce[i]) * 0.5 for i in range(dim))\n                # coordinate transform rotation matrix can be identity since no orientation needed for uniform sampling here\n                while True:\n                    # sample unit ball point\n                    while True:\n                        v = [random.uniform(-1, 1) for _ in range(dim)]\n                        norm_v = math.sqrt(sum(x*x for x in v))\n                        if norm_v <= 1 and norm_v > 0:\n                            v = [x / norm_v for x in v]\n                            break\n                    # scale to ellipse radii\n                    r1 = cmax * 0.5  # major axis radius\n                    ri = math.sqrt(cmax*cmax - cmin*cmin)*0.5 if dim > 1 else 0.0\n                    scale = [r1] + [ri]*(dim-1)\n                    p = tuple(center[i] + v[i]*scale[i] for i in range(dim))\n                    if all(0 <= p[i] <= bounds[i] for i in range(dim)):\n                        if not self._is_in_obstacle(p, obstacles, is_3d):\n                            return p\n\n        def nearest(tree, point):\n            best_node = None\n            best_dist = float('inf')\n            for n in tree:\n                d = dist(n.position, point)\n                if d < best_dist:\n                    best_node = n\n                    best_dist = d\n            return best_node\n\n        def near(tree, point, radius):\n            result = []\n            r2 = radius*radius\n            for n in tree:\n                d2 = sum((n.position[i] - point[i])**2 for i in range(dim))\n                if d2 <= r2:\n                    result.append(n)\n            return result\n\n        def steer(from_p, to_p, step):\n            d = dist(from_p, to_p)\n            if d <= step:\n                return to_p\n            ratio = step / d\n            return tuple(from_p[i] + (to_p[i] - from_p[i]) * ratio for i in range(dim))\n\n        def extract_path(nstart, ngoal):\n            path_start = []\n            cur = nstart\n            while cur:\n                path_start.append(cur.position)\n                cur = cur.parent\n            path_goal = []\n            cur = ngoal\n            while cur:\n                path_goal.append(cur.position)\n                cur = cur.parent\n            # Remove duplicated connecting node position if occurs\n            if path_start[-1] == path_goal[-1]:\n                path_goal.pop()\n            return path_start[::-1] + path_goal\n\n        def path_length(path):\n            length = 0.0\n            for i in range(1, len(path)):\n                length += dist(path[i-1], path[i])\n            return length\n\n        def shortcut_path(path):\n            # Attempt incremental shortcuts along path to improve smoothness and length\n            if len(path) < 3:\n                return path\n            improved = False\n            new_path = [path[0]]\n            i = 0\n            while i < len(path)-1:\n                j = min(len(path)-1, i+1)\n                # try longest shortcut forward\n                for k in range(len(path)-1, j, -1):\n                    if not self._is_edge_in_obstacle(path[i], path[k], obstacles, is_3d, resolution=self.shortcut_resolution):\n                        j = k\n                        improved = True\n                        break\n                new_path.append(path[j])\n                i = j\n            if improved:\n                return new_path\n            else:\n                return path\n\n        def try_connect_tree(node, other_tree, connect_radius):\n            neighbors = near(other_tree, node.position, connect_radius)\n            best_node = None\n            best_cost_candidate = float('inf')\n            for other_node in neighbors:\n                d = dist(node.position, other_node.position)\n                if d <= connect_radius:\n                    if not self._is_edge_in_obstacle(node.position, other_node.position, obstacles, is_3d):\n                        c = node.cost + other_node.cost + d\n                        if c < best_cost_candidate:\n                            best_cost_candidate = c\n                            best_node = other_node\n            return best_node, best_cost_candidate\n\n        def rewire(tree, new_node, radius):\n            neighbors = near(tree, new_node.position, radius)\n            for near_node in neighbors:\n                if near_node == new_node.parent:\n                    continue\n                dist_to_near = dist(new_node.position, near_node.position)\n                new_cost = new_node.cost + dist_to_near\n                if new_cost + 1e-6 < near_node.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                        # update parent-child edges\n                        if near_node.parent:\n                            try:\n                                edges.remove((near_node.parent, near_node))\n                                near_node.parent.children.remove(near_node)\n                            except ValueError:\n                                pass\n                        near_node.parent = new_node\n                        near_node.cost = new_cost\n                        new_node.add_child(near_node)\n                        edges.append((new_node, near_node))\n\n        def update_best_path(n1, n2):\n            nonlocal success, best_cost, best_connect\n            d = dist(n1.position, n2.position)\n            c = n1.cost + n2.cost + d\n            if c < best_cost:\n                best_cost = c\n                best_connect = (n1, n2)\n                success = True\n\n        # Initial heuristic cost for sampling\n        current_best_cost = float('inf')\n\n        for it in range(self.max_iter):\n            if time.monotonic() - start_time > TIME_LIMIT:\n                break\n\n            # Sample with goal bias and informed ellipsoidal sampling if possible\n            if random.random() < self.goal_sample_rate:\n                sample = goal_pos\n            else:\n                sample = sample_free_ellipsoid(start_pos, goal_pos, current_best_cost)\n\n            # Alternate trees for expansion\n            tree_a = start_tree if it % 2 == 0 else goal_tree\n            tree_b = goal_tree if it % 2 == 0 else start_tree\n\n            nearest_node = nearest(tree_a, sample)\n            new_pos = steer(nearest_node.position, sample, self.step_size)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            n = len(tree_a) + 1\n            radius = min(self.step_size * 5, self.gamma * (math.log(n)/n)**(1/dim))\n            radius = max(radius, self.step_size * 1.5)\n\n            near_nodes = near(tree_a, new_pos, radius)\n\n            # Choose best parent minimizing cost\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            min_parent = nearest_node\n            for near_node in near_nodes:\n                if near_node == nearest_node:\n                    continue\n                cost_through = near_node.cost + dist(near_node.position, new_pos)\n                if cost_through + 1e-8 < min_cost:\n                    if not self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d):\n                        min_cost = cost_through\n                        min_parent = near_node\n\n            new_node = Node(new_pos, parent=min_parent, cost=min_cost)\n            min_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((min_parent, new_node))\n\n            # Rewire neighbors\n            rewire(tree_a, new_node, radius)\n\n            # Try to connect new_node to other tree\n            connect_radius = radius * 1.2\n            nearest_other_node, cand_cost = try_connect_tree(new_node, tree_b, connect_radius)\n            if nearest_other_node is not None:\n                update_best_path(new_node, nearest_other_node)\n                current_best_cost = best_cost\n                # Early stop if cost close enough to Euclidean start-goal distance\n                if best_cost <= dist(start_pos, goal_pos) * 1.01:\n                    break\n\n            # Incremental shortcutting periodically to improve path quality\n            if success and it % self.shortcut_freq == 0 and best_connect is not None:\n                path_before = extract_path(best_connect[0], best_connect[1])\n                path_after = shortcut_path(path_before)\n                if len(path_after) < len(path_before):\n                    # Rebuild nodes along shortcut path for cost update\n                    # Here keep nodes and edges intact, rely on extracted path as final output\n                    # Just save the shorter path for output (do nothing else now)\n                    pass\n\n        # Extract final path\n        extracted_path = []\n        if success and best_connect is not None:\n            extracted_path = extract_path(best_connect[0], best_connect[1])\n            # Final shortcut to improve smoothness\n            for _ in range(5):\n                new_path = shortcut_path(extracted_path)\n                if len(new_path) < len(extracted_path):\n                    extracted_path = new_path\n                else:\n                    break\n\n        # If no success, attempt best partial connection\n        if not success:\n            # Find best closest pair between start and goal trees\n            min_cost = float('inf')\n            best_pair = None\n            for n1 in start_tree:\n                n2 = nearest(goal_tree, n1.position)\n                d12 = dist(n1.position, n2.position)\n                if d12 <= self.step_size * 5:\n                    if not self._is_edge_in_obstacle(n1.position, n2.position, obstacles, is_3d):\n                        c = n1.cost + n2.cost + d12\n                        if c < min_cost:\n                            min_cost = c\n                            best_pair = (n1, n2)\n            if best_pair is not None:\n                extracted_path = extract_path(best_pair[0], best_pair[1])\n                success = True\n\n        return PlannerResult(\n            success=success,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 172, in evaluate\n    fitness, results = self.__evaluate_path(code_string=code_string)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 131, in __evaluate_path\n    result, avg_result = evaluate_with_timeout_dynamic(\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 70, in evaluate_with_timeout_dynamic\n    raise payload\nTypeError: 'dict' object is not callable\n"
    }
}
{
    "operator": "time_expert",
    "algorithm_description": "This improved planner implements a bidirectional RRT* algorithm with an adaptive rewiring radius that decreases as the tree grows, accelerated goal biasing to speed convergence, and a constrained k-nearest neighbor rewiring to limit computation. It alternately grows from start and goal, rewires efficiently with a dynamically computed radius, and attempts multiple connections between trees near new nodes to enhance connectivity and path quality. Algorithm guarantees collision-free incremental builds within map bounds, applies early stopping after a high-quality path is found or after a 30-second limit, and includes path shortcutting for smoothness and reduced length.",
    "planning_mechanism": "The planner alternates growth between two trees, sampling with goal bias to guide exploration. Nearest neighbors are selected via a k-nearest search within a dynamically adjusted radius proportional to (log n / n)^{1/d}, where n is the current node count. At each new node, rewiring is performed locally to optimize path cost. Multiple candidate connections to the opposing tree within this radius are considered to improve solution quality. A post-processing shortcutting step refines the final path to remove unnecessary waypoints, improving smoothness without costly global operations. The procedure respects obstacle and edge collision checks strictly and terminates on best-found solution or time limit.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True  # For collision or pruning\n\n    def add_child(self, child):\n        self.children.append(child)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 4.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = 0.15  # Probability to sample goal to bias\n        self.gamma_rrt_star = 20.0    # Constant for adaptive radius scaling\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n        import time\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = start_tree[:] + goal_tree[:]\n        edges = []\n\n        best_cost = float('inf')\n        best_connection = None\n        success = False\n\n        start_time = time.monotonic()\n        TIME_LIMIT = 30.0\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def sample_free():\n            # Return goal with some probability for goal bias\n            if random.random() < self.goal_sample_rate:\n                if not self._is_in_obstacle(goal_pos, obstacles, is_3d):\n                    return goal_pos\n            while True:\n                p = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n\n        def steer(from_p, to_p):\n            distance = dist(from_p, to_p)\n            if distance <= self.step_size:\n                return to_p\n            ratio = self.step_size / distance\n            return tuple(from_p[i] + ratio * (to_p[i] - from_p[i]) for i in range(dim))\n\n        def nearest(tree, point):\n            # Linear search; acceptable given radius pruning below\n            min_node = None\n            min_dist = float('inf')\n            for node in tree:\n                d = dist(node.position, point)\n                if d < min_dist:\n                    min_dist = d\n                    min_node = node\n            return min_node\n\n        def k_nearest(tree, point, radius):\n            # Return nodes within radius (adaptive neighborhood)\n            return [node for node in tree if dist(node.position, point) <= radius]\n\n        def cost_through(parent, new_pos):\n            return parent.cost + dist(parent.position, new_pos)\n\n        def extract_path(node_start, node_goal):\n            path_start = []\n            cur = node_start\n            while cur:\n                path_start.append(cur.position)\n                cur = cur.parent\n            path_goal = []\n            cur = node_goal\n            while cur:\n                path_goal.append(cur.position)\n                cur = cur.parent\n            return path_start[::-1] + path_goal\n\n        def try_connect(new_node, other_tree):\n            # Attempt to connect new_node to all nodes in other_tree within connection radius\n            nonlocal best_cost, best_connection, success\n\n            # Compute adaptive radius\n            n_other = len(other_tree) + 1\n            radius = min(self.step_size * 5,\n                         self.gamma_rrt_star * (math.log(n_other) / n_other) ** (1 / dim))\n            neighbors_other = k_nearest(other_tree, new_node.position, radius)\n            improved = False\n            for other_node in neighbors_other:\n                if other_node is None or other_node == new_node:\n                    continue\n                dist_between = dist(new_node.position, other_node.position)\n                if dist_between <= self.step_size:\n                    if not self._is_edge_in_obstacle(new_node.position, other_node.position, obstacles, is_3d):\n                        candidate_cost = new_node.cost + other_node.cost + dist_between\n                        if candidate_cost < best_cost:\n                            best_cost = candidate_cost\n                            best_connection = (new_node, other_node)\n                            success = True\n                            improved = True\n            return improved\n\n        def shortcut_path(path, max_attempts=150):\n            # Randomly attempt shortcutting path segments without collision\n            length = len(path)\n            if length < 3:\n                return path\n            for _ in range(max_attempts):\n                i = random.randint(0, length - 3)\n                j = random.randint(i + 2, length - 1)\n                if j <= i + 1:\n                    continue\n                p1 = path[i]\n                p2 = path[j]\n                if not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d):\n                    # Shortcut possible: remove intermediate nodes\n                    path = path[:i + 1] + path[j:]\n                    length = len(path)\n                    if length < 3:\n                        break\n            return path\n\n        # Main loop\n        for iteration in range(self.max_iter):\n            if time.monotonic() - start_time > TIME_LIMIT:\n                break\n\n            # Alternate tree growth: even iter start_tree, odd iter goal_tree\n            tree_a = start_tree if iteration % 2 == 0 else goal_tree\n            tree_b = goal_tree if iteration % 2 == 0 else start_tree\n\n            sample_pos = sample_free()\n            nearest_node = nearest(tree_a, sample_pos)\n            new_pos = steer(nearest_node.position, sample_pos)\n\n            # Collision check for node and edge\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            # Adaptive neighborhood radius for rewiring\n            n = len(tree_a) + 1\n            radius = min(self.step_size * 5,\n                         self.gamma_rrt_star * (math.log(n) / n) ** (1 / dim))\n\n            near_nodes = k_nearest(tree_a, new_pos, radius)\n\n            # Choose best parent among near nodes with collision-free edges\n            min_cost = cost_through(nearest_node, new_pos)\n            min_parent = nearest_node\n            for near_node in near_nodes:\n                if near_node == nearest_node:\n                    continue\n                c = cost_through(near_node, new_pos)\n                if c < min_cost:\n                    if not self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d):\n                        min_cost = c\n                        min_parent = near_node\n\n            new_node = Node(new_pos, parent=min_parent, cost=min_cost)\n            min_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((min_parent, new_node))\n\n            # Rewire near nodes to new_node if cost improved and edge collision-free\n            for near_node in near_nodes:\n                if near_node == min_parent or near_node == new_node:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, near_node.position)\n                if new_cost < near_node.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                        # Update parents and edges\n                        if near_node.parent is not None:\n                            try:\n                                edges.remove((near_node.parent, near_node))\n                            except ValueError:\n                                pass\n                            try:\n                                near_node.parent.children.remove(near_node)\n                            except ValueError:\n                                pass\n                        near_node.parent = new_node\n                        near_node.cost = new_cost\n                        new_node.add_child(near_node)\n                        edges.append((new_node, near_node))\n\n            # Attempt connection to other tree\n            connected = try_connect(new_node, tree_b)\n            if connected:\n                # Early stopping if new best path found under time limit\n                if time.monotonic() - start_time <= TIME_LIMIT * 0.95:\n                    break\n\n        extracted_path = []\n        if success and best_connection is not None:\n            extracted_path = extract_path(best_connection[0], best_connection[1])\n            # Perform shortcutting to improve smoothness\n            extracted_path = shortcut_path(extracted_path, max_attempts=150)\n\n        else:\n            # If no exact connection found, try best approximate connection among all nodes\n            best_local_cost = float('inf')\n            best_local_conn = None\n            for node_a in start_tree:\n                near_nodes = k_nearest(goal_tree, node_a.position, self.step_size * 2)\n                for node_b in near_nodes:\n                    if not self._is_edge_in_obstacle(node_a.position, node_b.position, obstacles, is_3d):\n                        connection_cost = node_a.cost + node_b.cost + dist(node_a.position, node_b.position)\n                        if connection_cost < best_local_cost:\n                            best_local_cost = connection_cost\n                            best_local_conn = (node_a, node_b)\n            if best_local_conn is not None:\n                success = True\n                extracted_path = extract_path(best_local_conn[0], best_local_conn[1])\n                extracted_path = shortcut_path(extracted_path, max_attempts=150)\n                best_cost = best_local_cost\n\n        return PlannerResult(\n            success=success,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )",
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 172, in evaluate\n    fitness, results = self.__evaluate_path(code_string=code_string)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 131, in __evaluate_path\n    result, avg_result = evaluate_with_timeout_dynamic(\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 70, in evaluate_with_timeout_dynamic\n    raise payload\nTypeError: 'dict' object is not callable\n"
    }
}
{
    "operator": "time_expert",
    "algorithm_description": "A bidirectional RRT* planner with goal bias sampling, adaptive shrinking neighborhood radius for rewiring, multiple connection attempts between trees, incremental path shortcutting during planning, and early stopping to minimize planning time while improving path length and smoothness. The planner alternates expansion from start and goal, samples mostly random free points with occasional goal bias, steers nearest nodes with a moderate step size, rewires neighbors within a dynamically computed radius, and tries multiple connection attempts to the opposite tree. After each iteration, the current best path is shortcut iteratively to smooth the path progressively. The search stops early on first improved connection or when reaching a 30-second time limit, returning the best found path.",
    "planning_mechanism": "The planner alternates growing two trees bidirectionally by sampling free space with a goal bias, steering and connecting new nodes within an adaptive neighborhood radius that shrinks as the trees grow. It performs cost-based rewiring on neighbors, tries multiple near-node connections between trees, and applies incremental shortcutting of the best path found during planning. Early stopping reduces search time without sacrificing path quality.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position  # tuple[float,...]\n        self.parent = parent      # Node or None\n        self.cost = cost          # path cost from root\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 4.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = 0.2  # Probability to sample goal\n        self.gamma_rrt_star = 20.0   # Parameter for adaptive radius\n        self.min_radius = 2.5        # Minimum radius for neighbor search\n        self.max_shortcut_attempts = 20  # Number of incremental shortcut attempts\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import time\n        import random\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = start_tree[:] + goal_tree[:]\n        edges = []\n\n        success = False\n        best_cost = float('inf')\n        best_connection = None\n\n        dim = len(bounds)\n        start_time = time.monotonic()\n        TIME_LIMIT = 30.0\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def dist_sq(a,b):\n            return sum((a[i]-b[i])**2 for i in range(dim))\n\n        def sample_free():\n            for _ in range(30):\n                if random.random() < self.goal_sample_rate:\n                    sample = goal_pos\n                else:\n                    sample = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not self._is_in_obstacle(sample, obstacles, is_3d):\n                    return sample\n            return start_pos  # Fallback rare case\n\n        def nearest(tree, point):\n            best_node = None\n            best_dist = float('inf')\n            for node in tree:\n                d = dist_sq(node.position, point)\n                if d < best_dist:\n                    best_dist = d\n                    best_node = node\n            return best_node\n\n        def near(tree, point, radius):\n            r_sq = radius*radius\n            return [n for n in tree if dist_sq(n.position, point) <= r_sq]\n\n        def steer(from_p, to_p, step):\n            d = dist(from_p, to_p)\n            if d <= step:\n                return to_p\n            ratio = step / d\n            return tuple(from_p[i] + (to_p[i] - from_p[i]) * ratio for i in range(dim))\n\n        def extract_path(node_start, node_goal):\n            path_start = []\n            node = node_start\n            while node:\n                path_start.append(node.position)\n                node = node.parent\n            path_goal = []\n            node = node_goal\n            while node:\n                path_goal.append(node.position)\n                node = node.parent\n            path_goal.reverse()\n            # Avoid duplicating connecting node at junction\n            if path_start[-1] == path_goal[0]:\n                return path_start + path_goal[1:]\n            return path_start + path_goal\n\n        def try_rewire(new_node, neighbors, tree):\n            changed = False\n            for near_node in neighbors:\n                if near_node is new_node.parent:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, near_node.position)\n                if new_cost + 1e-9 < near_node.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d, resolution=0.5):\n                        # Rewire near_node parent\n                        if near_node.parent:\n                            try:\n                                edges.remove((near_node.parent, near_node))\n                            except ValueError:\n                                pass\n                            if near_node in near_node.parent.children:\n                                near_node.parent.children.remove(near_node)\n                        near_node.parent = new_node\n                        near_node.cost = new_cost\n                        new_node.add_child(near_node)\n                        edges.append((new_node, near_node))\n                        changed = True\n            return changed\n\n        def path_cost(path):\n            c = 0.0\n            for i in range(len(path)-1):\n                c += dist(path[i], path[i+1])\n            return c\n\n        def shortcut_path(path):\n            # Attempt randomized shortcutting on path points\n            if len(path) < 3:\n                return path\n            for _ in range(self.max_shortcut_attempts):\n                if len(path) <= 2:\n                    break\n                i = random.randint(0, len(path)-3)\n                j = random.randint(i+2, len(path)-1)\n                if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d, resolution=0.2):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        def incremental_shortcut(path):\n            # 5 passes of shortcut attempts for runtime budget\n            for _ in range(5):\n                path = shortcut_path(path)\n            return path\n\n        def update_best_path(new_path):\n            nonlocal extracted_path, success, best_cost\n            cost_new = path_cost(new_path)\n            if cost_new + 1e-9 < best_cost:\n                best_cost = cost_new\n                extracted_path[:] = new_path\n                success = True\n                return True\n            return False\n\n        for iter_count in range(self.max_iter):\n            now = time.monotonic()\n            if now - start_time > TIME_LIMIT:\n                break\n\n            # Alternate expansion\n            tree_a = start_tree if iter_count % 2 == 0 else goal_tree\n            tree_b = goal_tree if iter_count % 2 == 0 else start_tree\n\n            rnd = sample_free()\n\n            nearest_node = nearest(tree_a, rnd)\n            new_pos = steer(nearest_node.position, rnd, self.step_size)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d, resolution=0.3):\n                continue\n\n            n_nodes = len(tree_a) + 1\n            radius = max(self.min_radius, self.gamma_rrt_star * ((math.log(max(n_nodes,2)) / n_nodes) ** (1/dim)))\n\n            near_nodes = near(tree_a, new_pos, radius)\n\n            # Choose best parent locally\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            min_parent = nearest_node\n            for near_node in near_nodes:\n                cost_through = near_node.cost + dist(near_node.position, new_pos)\n                if cost_through + 1e-9 < min_cost:\n                    if not self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d, resolution=0.3):\n                        min_cost = cost_through\n                        min_parent = near_node\n\n            new_node = Node(new_pos, parent=min_parent, cost=min_cost)\n            min_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((min_parent, new_node))\n\n            try_rewire(new_node, near_nodes, tree_a)\n\n            # Attempt multiple connection tries to other tree within radius*1.3 to find better joins\n            connection_radius = radius * 1.3\n            connection_candidates = near(tree_b, new_pos, connection_radius)\n            for node_b in connection_candidates:\n                dist_connect = dist(new_pos, node_b.position)\n                if dist_connect <= self.step_size * 1.5:\n                    if not self._is_edge_in_obstacle(new_pos, node_b.position, obstacles, is_3d, resolution=0.3):\n                        total_cost = new_node.cost + node_b.cost + dist_connect\n                        if total_cost + 1e-9 < best_cost:\n                            best_cost = total_cost\n                            best_connection = (new_node, node_b)\n\n                            # Extract and shortcut immediately with incremental shortcutting\n                            candidate_path = extract_path(new_node, node_b)\n                            candidate_path = incremental_shortcut(candidate_path)\n                            if update_best_path(candidate_path):\n                                # Early stopping on good improvement\n                                break\n\n            if best_connection and best_cost < float('inf'):\n                # Early stop on first improved path found\n                break\n\n        # If no path found after iteration or time limit, try connecting closest pairs again to find any feasible path\n        if not success:\n            min_total_cost = float('inf')\n            min_pair = None\n            for n_s in start_tree:\n                candidates = near(goal_tree, n_s.position, self.step_size * 1.5)\n                for n_g in candidates:\n                    if not self._is_edge_in_obstacle(n_s.position, n_g.position, obstacles, is_3d, resolution=0.3):\n                        tentative_cost = n_s.cost + n_g.cost + dist(n_s.position, n_g.position)\n                        if tentative_cost < min_total_cost:\n                            min_total_cost = tentative_cost\n                            min_pair = (n_s, n_g)\n            if min_pair:\n                candidate_path = extract_path(min_pair[0], min_pair[1])\n                candidate_path = incremental_shortcut(candidate_path)\n                if update_best_path(candidate_path):\n                    success = True\n\n        return PlannerResult(\n            success=success,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 172, in evaluate\n    fitness, results = self.__evaluate_path(code_string=code_string)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 131, in __evaluate_path\n    result, avg_result = evaluate_with_timeout_dynamic(\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 70, in evaluate_with_timeout_dynamic\n    raise payload\nSyntaxError: no binding for nonlocal 'extracted_path' found\n"
    }
}
{
    "operator": "cross_over",
    "algorithm_description": null,
    "planning_mechanism": null,
    "code": null,
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "success_rate": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 172, in evaluate\n    fitness, results = self.__evaluate_path(code_string=code_string)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 131, in __evaluate_path\n    result, avg_result = evaluate_with_timeout_dynamic(\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 70, in evaluate_with_timeout_dynamic\n    raise payload\nTypeError: can only concatenate str (not \"NoneType\") to str\n"
    }
}
{
    "operator": "time_expert",
    "algorithm_description": null,
    "planning_mechanism": null,
    "code": null,
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "success_rate": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 172, in evaluate\n    fitness, results = self.__evaluate_path(code_string=code_string)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 131, in __evaluate_path\n    result, avg_result = evaluate_with_timeout_dynamic(\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 70, in evaluate_with_timeout_dynamic\n    raise payload\nTypeError: can only concatenate str (not \"NoneType\") to str\n"
    }
}
{
    "operator": "path_expert",
    "algorithm_description": null,
    "planning_mechanism": null,
    "code": null,
    "objective": null,
    "time_improvement": null,
    "length_improvement": null,
    "smoothness_improvement": null,
    "success_rate": null,
    "other_inf": {
        "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 172, in evaluate\n    fitness, results = self.__evaluate_path(code_string=code_string)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 131, in __evaluate_path\n    result, avg_result = evaluate_with_timeout_dynamic(\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 70, in evaluate_with_timeout_dynamic\n    raise payload\nTypeError: can only concatenate str (not \"NoneType\") to str\n"
    }
}
