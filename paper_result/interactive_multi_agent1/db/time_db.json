[
    {
        "operator": "m1",
        "algorithm_description": "This algorithm is a bidirectional RRT* planner enhanced with adaptive neighborhood radius based on the number of nodes to balance rewiring efficiency and exploration speed. It grows two trees (from start and goal) by sampling the space, extending towards samples, rewiring locally to optimize path cost, and attempts connections between trees to find a feasible path quickly. The rewiring radius shrinks with node count to focus optimization locally as the tree grows. Once a connection is achieved, it extracts the shortest path connecting start and goal. The planner respects collision constraints for nodes and edges, enforces map boundaries, and stops if time limit or iteration limit is reached, returning the best path found.",
        "planning_mechanism": "The planner alternates growing start and goal trees by sampling random free points, steering nearest nodes toward samples with fixed step size, rewiring nearby nodes within a dynamically computed radius to minimize path cost, and tries connecting the trees when a new node is added. The radius shrinks with tree size to keep rewiring efficient. The planning stops upon reaching max iterations or 30 seconds. Upon success or timeout, the best found path from the connected trees is extracted by traversing parent links to the roots, composing a continuous path between start and goal.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n        import time\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = start_tree[:] + goal_tree[:]\n        edges = []\n\n        success = False\n        best_cost = float('inf')\n        best_connect = None\n\n        start_time = time.monotonic()\n        TIME_LIMIT = 30.0\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def sample_free():\n            while True:\n                p = tuple(random.uniform(0, bounds[i]) for i in range(len(bounds)))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: dist(n.position, point))\n\n        def near(tree, point, radius):\n            return [node for node in tree if dist(node.position, point) <= radius]\n\n        def steer(from_p, to_p, step):\n            d = dist(from_p, to_p)\n            if d <= step:\n                return to_p\n            ratio = step / d\n            return tuple(from_p[i] + (to_p[i] - from_p[i]) * ratio for i in range(len(from_p)))\n\n        def path_cost(node):\n            return node.cost\n\n        def extract_path(node_start, node_goal):\n            path_start = []\n            cur = node_start\n            while cur:\n                path_start.append(cur.position)\n                cur = cur.parent\n            path_goal = []\n            cur = node_goal\n            while cur:\n                path_goal.append(cur.position)\n                cur = cur.parent\n            return path_start[::-1] + path_goal\n\n        # Maintain mapping from position to Node for quick reference if needed\n        for iter_count in range(self.max_iter):\n            if time.monotonic() - start_time > TIME_LIMIT:\n                break\n\n            # Alternate trees: odd iter grow start_tree, even iter grow goal_tree\n            tree_a = start_tree if iter_count % 2 == 0 else goal_tree\n            tree_b = goal_tree if iter_count % 2 == 0 else start_tree\n\n            sample = sample_free()\n\n            nearest_node = nearest(tree_a, sample)\n            new_pos = steer(nearest_node.position, sample, self.step_size)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            # Radius adapted as per RRT* theory: gamma*(log(n)/n)^{1/d}\n            n = len(tree_a) + 1\n            d = len(bounds)\n            gamma = 30.0  # Tuned constant for neighborhood radius\n            radius = min(self.step_size * 5, gamma * (math.log(n) / n) ** (1 / d))\n\n            near_nodes = near(tree_a, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            min_parent = nearest_node\n            # Find best parent among neighbors\n            for near_node in near_nodes:\n                cost_through_near = near_node.cost + dist(near_node.position, new_pos)\n                if cost_through_near < min_cost and not self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d):\n                    min_cost = cost_through_near\n                    min_parent = near_node\n\n            new_node = Node(new_pos, parent=min_parent, cost=min_cost)\n            min_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((min_parent, new_node))\n\n            # Rewire neighbors if better through new_node\n            for near_node in near_nodes:\n                if near_node == min_parent:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, near_node.position)\n                if new_cost < near_node.cost and not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                    if near_node.parent:\n                        try:\n                            edges.remove((near_node.parent, near_node))\n                        except ValueError:\n                            pass\n                        near_node.parent.children.remove(near_node)\n                    near_node.parent = new_node\n                    near_node.cost = new_cost\n                    new_node.add_child(near_node)\n                    edges.append((new_node, near_node))\n\n            # Attempt to connect to other tree\n            nearest_to_new_in_other = nearest(tree_b, new_node.position)\n            dist_between = dist(new_node.position, nearest_to_new_in_other.position)\n            if dist_between <= self.step_size:\n                if not self._is_edge_in_obstacle(new_node.position, nearest_to_new_in_other.position, obstacles, is_3d):\n                    # Connection found\n                    candidate_cost = new_node.cost + nearest_to_new_in_other.cost + dist_between\n                    if candidate_cost < best_cost:\n                        best_cost = candidate_cost\n                        best_connect = (new_node, nearest_to_new_in_other)\n                        success = True\n                        # Stop early on first solution\n                        break\n\n        extracted_path = []\n        if success and best_connect is not None:\n            extracted_path = extract_path(best_connect[0], best_connect[1])\n\n        # If no success but time/iter limit reached, try to find best partial connection\n        if not success:\n            # Attempt to find minimal-cost connection between trees\n            min_cost = float('inf')\n            best_pair = None\n            for n1 in start_tree:\n                # Nearest node in goal_tree\n                n2 = min(goal_tree, key=lambda node: dist(n1.position, node.position))\n                d12 = dist(n1.position, n2.position)\n                if d12 <= self.step_size:\n                    if not self._is_edge_in_obstacle(n1.position, n2.position, obstacles, is_3d):\n                        cost_sum = n1.cost + n2.cost + d12\n                        if cost_sum < min_cost:\n                            min_cost = cost_sum\n                            best_pair = (n1, n2)\n            if best_pair is not None:\n                extracted_path = extract_path(best_pair[0], best_pair[1])\n                success = True\n\n        return PlannerResult(\n            success=success,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
        "objective": -24.50215,
        "time_improvement": 67.0,
        "length_improvement": 6.0,
        "smoothness_improvement": 140.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.009191942214965821,
                "num_nodes_avg": 110.2,
                "path_length_avg": 170.91077029046983,
                "smoothness_avg": 0.01777274497333912,
                "success_improvement": 0.0,
                "time_improvement": 63.26946693101152,
                "length_improvement": 6.321098549329074,
                "smoothness_improvement": 178.1820529661874,
                "objective_score": 23.664409473731837
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.02384507656097412,
                "num_nodes_avg": 292.0,
                "path_length_avg": 282.72493325276366,
                "smoothness_avg": 0.008011301853497212,
                "success_improvement": 0.0,
                "time_improvement": 85.41712475015616,
                "length_improvement": 5.618279494235603,
                "smoothness_improvement": 106.13656699797079,
                "objective_score": 29.52678795657806
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.023160457611083984,
                "num_nodes_avg": 291.8,
                "path_length_avg": 141.37742625459262,
                "smoothness_avg": 0.018422059860500224,
                "success_improvement": 0.0,
                "time_improvement": 53.271010054655534,
                "length_improvement": 6.10384515129628,
                "smoothness_improvement": 134.3272416505493,
                "objective_score": 20.31524631542717
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "time_expert",
        "algorithm_description": "A bidirectional RRT* planner with adaptive neighborhood radius, efficient rewiring, and early stopping to minimize planning time and improve path quality. It grows two trees from start and goal by sampling free space, steering towards samples with fixed step size, and rewiring a shrinking neighborhood for path cost optimization. The planner attempts tree connection after each extension and returns the best path found within a 30-second limit.",
        "planning_mechanism": "A bidirectional RRT* planner alternates growing two trees by sampling, nearest node selection, steering, collision checks, and cost-based rewiring within an adaptively shrinking radius. It tries connecting the two trees whenever a new node is added, stopping early on the first improved connection. The adaptive radius balances exploration and efficient rewiring, reducing overhead and improving solution quality over time.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n        import time\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = start_tree[:] + goal_tree[:]\n        edges = []\n\n        success = False\n        best_cost = float('inf')\n        best_connect = None\n\n        start_time = time.monotonic()\n        TIME_LIMIT = 30.0\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def sample_free():\n            for _ in range(30):\n                p = tuple(random.uniform(0, bounds[i]) for i in range(len(bounds)))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n            # fallback: return start or goal to prevent infinite loop (rare)\n            return start_pos\n\n        def nearest(tree, point):\n            # Linear search; for improvement, can be replaced with spatial index\n            best_node = None\n            best_dist = float('inf')\n            for n in tree:\n                d = dist(n.position, point)\n                if d < best_dist:\n                    best_dist = d\n                    best_node = n\n            return best_node\n\n        def near(tree, point, radius):\n            r_sq = radius * radius\n            return [n for n in tree if (n.position[0] - point[0]) ** 2 + (n.position[1] - point[1]) ** 2 <= r_sq] if not is_3d else \\\n                   [n for n in tree if sum((n.position[i] - point[i]) ** 2 for i in range(3)) <= r_sq]\n\n        def steer(from_p, to_p, step):\n            d = dist(from_p, to_p)\n            if d <= step:\n                return to_p\n            ratio = step / d\n            return tuple(from_p[i] + (to_p[i] - from_p[i]) * ratio for i in range(len(from_p)))\n\n        def extract_path(n_start, n_goal):\n            path_start = []\n            curr = n_start\n            while curr is not None:\n                path_start.append(curr.position)\n                curr = curr.parent\n            path_goal = []\n            curr = n_goal\n            while curr is not None:\n                path_goal.append(curr.position)\n                curr = curr.parent\n            # Reverse start path and append goal path (connecting at the connecting edge)\n            return path_start[::-1] + path_goal\n\n        def cost_to_reach(node):\n            return node.cost\n\n        def try_rewire(new_node, neighbors, tree, obstacles, is_3d):\n            changed = False\n            for near_node in neighbors:\n                if near_node is new_node.parent:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, near_node.position)\n                if new_cost + 1e-9 < near_node.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                        # Rewire near_node\n                        if near_node.parent:\n                            try:\n                                edges.remove((near_node.parent, near_node))\n                            except ValueError:\n                                pass\n                            if near_node in near_node.parent.children:\n                                near_node.parent.children.remove(near_node)\n                        near_node.parent = new_node\n                        near_node.cost = new_cost\n                        new_node.add_child(near_node)\n                        edges.append((new_node, near_node))\n                        changed = True\n            return changed\n\n        def add_node(tree, new_node):\n            tree.append(new_node)\n            nodes.append(new_node)\n\n        gamma = 30.0\n        dim = len(bounds)\n\n        for iter_count in range(self.max_iter):\n            now = time.monotonic()\n            if now - start_time > TIME_LIMIT:\n                break\n\n            # Alternate tree growth\n            tree_a = start_tree if iter_count % 2 == 0 else goal_tree\n            tree_b = goal_tree if iter_count % 2 == 0 else start_tree\n\n            rnd = sample_free()\n\n            nearest_node = nearest(tree_a, rnd)\n            new_pos = steer(nearest_node.position, rnd, self.step_size)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            n_nodes = len(tree_a) + 1\n            radius = min(self.step_size * 5, gamma * (math.log(max(n_nodes, 2)) / n_nodes) ** (1 / dim))\n\n            near_nodes = near(tree_a, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            min_parent = nearest_node\n            for near_node in near_nodes:\n                cost_through = near_node.cost + dist(near_node.position, new_pos)\n                if cost_through + 1e-9 < min_cost:\n                    if not self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d):\n                        min_cost = cost_through\n                        min_parent = near_node\n\n            new_node = Node(new_pos, parent=min_parent, cost=min_cost)\n            min_parent.add_child(new_node)\n            add_node(tree_a, new_node)\n            edges.append((min_parent, new_node))\n\n            try_rewire(new_node, near_nodes, tree_a, obstacles, is_3d)\n\n            # Try connecting other tree near new_node\n            nearest_in_other = nearest(tree_b, new_node.position)\n            dist_connect = dist(new_node.position, nearest_in_other.position)\n            if dist_connect <= self.step_size:\n                if not self._is_edge_in_obstacle(new_node.position, nearest_in_other.position, obstacles, is_3d):\n                    total_cost = new_node.cost + nearest_in_other.cost + dist_connect\n                    if total_cost + 1e-9 < best_cost:\n                        best_cost = total_cost\n                        best_connect = (new_node, nearest_in_other)\n                        success = True\n                        # Early stop on first good solution to reduce planning time\n                        break\n\n        # Extract best path if found\n        if success and best_connect is not None:\n            extracted_path = extract_path(best_connect[0], best_connect[1])\n        else:\n            # No direct connection found in time, try minimal-cost pair and path extraction\n            min_cost_est = float('inf')\n            best_pair = None\n            for n1 in start_tree:\n                n2 = nearest(goal_tree, n1.position)\n                d12 = dist(n1.position, n2.position)\n                if d12 <= self.step_size:\n                    if not self._is_edge_in_obstacle(n1.position, n2.position, obstacles, is_3d):\n                        cost_sum = n1.cost + n2.cost + d12\n                        if cost_sum + 1e-9 < min_cost_est:\n                            min_cost_est = cost_sum\n                            best_pair = (n1, n2)\n            if best_pair is not None:\n                extracted_path = extract_path(best_pair[0], best_pair[1])\n                success = True\n            else:\n                extracted_path = []\n\n        return PlannerResult(\n            success=success,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
        "objective": -27.32825,
        "time_improvement": 72.0,
        "length_improvement": 8.0,
        "smoothness_improvement": 142.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.011930179595947266,
                "num_nodes_avg": 135.2,
                "path_length_avg": 171.34059103033889,
                "smoothness_avg": 0.01642005874301497,
                "success_improvement": 0.0,
                "time_improvement": 52.327609778218985,
                "length_improvement": 6.085506990861369,
                "smoothness_improvement": 157.00957605645047,
                "objective_score": 20.13463500826477
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.01886107921600342,
                "num_nodes_avg": 282.1,
                "path_length_avg": 270.38122584620703,
                "smoothness_avg": 0.008398311675666579,
                "success_improvement": 0.0,
                "time_improvement": 88.4651758369878,
                "length_improvement": 9.738964320462099,
                "smoothness_improvement": 116.09460847429625,
                "objective_score": 32.96340438574508
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.012389254570007325,
                "num_nodes_avg": 219.8,
                "path_length_avg": 136.44974335966273,
                "smoothness_avg": 0.019808586046500164,
                "success_improvement": 0.0,
                "time_improvement": 75.00319890246378,
                "length_improvement": 9.376577499064672,
                "smoothness_improvement": 151.9637523937513,
                "objective_score": 28.88672493214669
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "cross_over",
        "algorithm_description": "This algorithm implements a bidirectional, goal-biased RRT* planner with adaptive neighborhood radius rewiring, multi-candidate bidirectional connection attempts, and incremental path shortcutting applied during planning and after completion. It enforces a strict 30-second time limit and dynamically adjusts rewiring radius based on tree size and dimension to balance exploration and refinement efficiency. The planner samples with goal bias for faster convergence, alternates expanding start and goal trees, and progressively shortcuts the best found path to minimize length and improve smoothness. Early stopping occurs upon finding a better path.",
        "planning_mechanism": "The planner grows two trees alternately from start and goal positions, samples random points with a goal bias, and extends the nearest node towards samples with a fixed step size while respecting collision constraints. It rewires nearby nodes within an adaptively shrinking radius to optimize path costs. Multiple candidates from the opposite tree are tested for connection on each new node added, enabling early termination when better paths are found. Progressive shortcutting improves path smoothness and length during planning as well as post-planning. The search halts immediately if the 30-second limit is exceeded, returning the best path found so far.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n    def add_child(self, child):\n        self.children.append(child)\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\nclass Planner:\n    def __init__(self, max_iter: int=5000, step_size: float=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.time_limit = 30.0\n        self.goal_sample_rate = 0.15  # probability to sample goal\n\n    def plan(self, map) -> 'PlannerResult':\n        import time\n        import math\n        import random\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        # Tree nodes and edges\n        start_tree = [Node(start_pos, cost=0.0)]\n        goal_tree = [Node(goal_pos, cost=0.0)]\n        nodes = start_tree[:] + goal_tree[:]\n        edges = []\n\n        best_connection = None\n        best_cost = float('inf')\n        success = False\n        extracted_path = []\n\n        step = self.step_size\n        gamma = 35.0  # radius multiplier for rewiring (RRT* theory)\n\n        start_time = time.monotonic()\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def sample_free():\n            # goal bias sampling\n            if random.random() < self.goal_sample_rate:\n                return goal_pos\n            for _ in range(100):\n                p = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n            return goal_pos  # fallback\n\n        def nearest(tree, point):\n            best_node = None\n            best_d = float('inf')\n            for node in tree:\n                d = dist(node.position, point)\n                if d < best_d:\n                    best_node = node\n                    best_d = d\n            return best_node\n\n        def near(tree, point, radius):\n            neighbors = [(dist(n.position, point), n) for n in tree if dist(n.position, point) <= radius]\n            neighbors.sort(key=lambda x: x[0])\n            return [n[1] for n in neighbors]\n\n        def steer(from_p, to_p, max_step):\n            d = dist(from_p, to_p)\n            if d <= max_step:\n                return to_p\n            ratio = max_step / d\n            return tuple(from_p[i] + (to_p[i] - from_p[i]) * ratio for i in range(dim))\n\n        def extract_path(node_start, node_goal):\n            path_start = []\n            cur = node_start\n            while cur:\n                path_start.append(cur.position)\n                cur = cur.parent\n            path_start.reverse()\n            path_goal = []\n            cur = node_goal\n            while cur:\n                path_goal.append(cur.position)\n                cur = cur.parent\n            if path_goal and path_start and path_start[-1] == path_goal[0]:\n                path_goal = path_goal[1:]\n            return path_start + path_goal\n\n        def shortcut_path(path, max_attempts=50):\n            if len(path) < 3:\n                return path\n            for _ in range(max_attempts):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution=max(step*0.2, 0.2)):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        def try_connect(new_node, other_tree):\n            radius = step*2.5\n            candidates = near(other_tree, new_node.position, radius)\n            best_cand = None\n            best_local_cost = float('inf')\n            for node in candidates:\n                d12 = dist(new_node.position, node.position)\n                if d12 <= radius and not self._is_edge_in_obstacle(new_node.position, node.position, obstacles, is_3d, resolution=max(step*0.2, 0.2)):\n                    c = new_node.cost + d12 + node.cost\n                    if c < best_local_cost:\n                        best_local_cost = c\n                        best_cand = node\n            return best_cand, best_local_cost\n\n        def rewire(tree, new_node, neighbors):\n            for nbr in neighbors:\n                if nbr is new_node.parent:\n                    continue\n                cost_through = new_node.cost + dist(new_node.position, nbr.position)\n                if cost_through + 1e-9 < nbr.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, nbr.position, obstacles, is_3d, resolution=max(step*0.2, 0.2)):\n                        if nbr.parent:\n                            try:\n                                edges.remove((nbr.parent, nbr))\n                            except Exception:\n                                pass\n                            nbr.parent.remove_child(nbr)\n                        nbr.parent = new_node\n                        nbr.cost = cost_through\n                        new_node.add_child(nbr)\n                        edges.append((new_node, nbr))\n\n        iter_since_last_shortcut = 0\n        shortcut_interval = 75\n\n        for it in range(self.max_iter):\n            if time.monotonic() - start_time > self.time_limit:\n                break\n\n            tree_a = start_tree if (it % 2 == 0) else goal_tree\n            tree_b = goal_tree if (it % 2 == 0) else start_tree\n\n            sample = sample_free()\n            nearest_node = nearest(tree_a, sample)\n            new_pos = steer(nearest_node.position, sample, step)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d, resolution=max(step*0.2, 0.2)):\n                continue\n\n            n_nodes = len(tree_a) + 1\n            radius = gamma * ((math.log(n_nodes)/n_nodes) ** (1/dim)) if n_nodes > 1 else step*5\n            radius = min(radius, step*5)\n            if radius < step:\n                radius = step\n\n            neighbors = near(tree_a, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            min_parent = nearest_node\n            for nb in neighbors:\n                cost_cand = nb.cost + dist(nb.position, new_pos)\n                if cost_cand + 1e-9 < min_cost:\n                    if not self._is_edge_in_obstacle(nb.position, new_pos, obstacles, is_3d, resolution=max(step*0.2, 0.2)):\n                        min_cost = cost_cand\n                        min_parent = nb\n\n            new_node = Node(new_pos, parent=min_parent, cost=min_cost)\n            min_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((min_parent, new_node))\n\n            rewire(tree_a, new_node, neighbors)\n\n            conn_node, conn_cost = try_connect(new_node, tree_b)\n            if conn_node is not None and conn_cost + 1e-9 < best_cost:\n                best_cost = conn_cost\n                # Maintain start_tree node first in best_connection\n                best_connection = (new_node, conn_node) if it % 2 == 0 else (conn_node, new_node)\n                success = True\n                # Early termination on improved path\n                break\n\n            iter_since_last_shortcut += 1\n            if iter_since_last_shortcut >= shortcut_interval and success:\n                path_cur = extract_path(best_connection[0], best_connection[1])\n                path_short = shortcut_path(path_cur, max_attempts=25)\n                if len(path_short) < len(path_cur):\n                    extracted_path = path_short\n                    iter_since_last_shortcut = 0\n\n        if success and best_connection is not None:\n            extracted_path = extract_path(best_connection[0], best_connection[1])\n            extracted_path = shortcut_path(extracted_path, max_attempts=75)\n        elif not success:\n            # Try partial best connection if no success\n            best_partial_cost = float('inf')\n            best_pair = None\n            search_radius = step * 3.0\n            for n1 in start_tree:\n                candidates = near(goal_tree, n1.position, search_radius)\n                for n2 in candidates:\n                    d12 = dist(n1.position, n2.position)\n                    if d12 <= search_radius:\n                        if not self._is_edge_in_obstacle(n1.position, n2.position, obstacles, is_3d, resolution=max(step*0.2, 0.2)):\n                            cost_sum = n1.cost + n2.cost + d12\n                            if cost_sum + 1e-9 < best_partial_cost:\n                                best_partial_cost = cost_sum\n                                best_pair = (n1, n2)\n            if best_pair:\n                success = True\n                extracted_path = extract_path(best_pair[0], best_pair[1])\n                extracted_path = shortcut_path(extracted_path, max_attempts=75)\n\n        return PlannerResult(\n            success=success,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
        "objective": -40.41506,
        "time_improvement": 74.0,
        "length_improvement": 17.0,
        "smoothness_improvement": 1612.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.010355472564697266,
                "num_nodes_avg": 88.3,
                "path_length_avg": 158.02445292325712,
                "smoothness_avg": 0.04068830742889877,
                "success_improvement": 0.0,
                "time_improvement": 58.963282937365015,
                "length_improvement": 13.384293295064195,
                "smoothness_improvement": 536.8603673360356,
                "objective_score": 28.403862694928197
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.025506019592285156,
                "num_nodes_avg": 305.8,
                "path_length_avg": 239.66358035944714,
                "smoothness_avg": 0.11914932396717788,
                "success_improvement": 0.0,
                "time_improvement": 84.44192042954145,
                "length_improvement": 19.993398542344394,
                "smoothness_improvement": 2965.7979254646784,
                "objective_score": 52.15760488159246
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.010851669311523437,
                "num_nodes_avg": 173.2,
                "path_length_avg": 123.90215675117983,
                "smoothness_avg": 0.11268141879062014,
                "success_improvement": 0.0,
                "time_improvement": 77.97057173653472,
                "length_improvement": 17.710087072551893,
                "smoothness_improvement": 1333.2993297395258,
                "objective_score": 40.683720413189185
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "m3",
        "algorithm_description": "This algorithm implements a simplified bidirectional RRT planner focused on simplicity and generalization. It grows two trees alternately from start and goal positions by extending the nearest node toward randomly sampled free points with fixed step sizes. It attempts to connect the two trees directly at each iteration without rewiring or adaptive radius heuristics. The planner enforces strict collision checking on nodes and edges and stops early upon finding a successful path or reaching a 30-second limit. The best path found so far is always returned.",
        "planning_mechanism": "The planner alternates expansion between start and goal trees by sampling free points, steering nearest nodes toward samples, and adding new nodes if collision-free. At each insertion, it attempts to connect the other tree directly. It keeps track of the best connection and path cost, terminating early upon success or timeout.",
        "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent: Optional[\"Node\"]=None, cost: float=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children: List[\"Node\"] = []\n\n    def add_child(self, child: \"Node\"):\n        self.children.append(child)\n        child.parent = self\nclass Planner:\n    def __init__(self, max_iter: int=5000, step_size: float=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.time_limit = 30.0\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def in_obstacle(pos):\n            for o in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = o\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w_, h_ = o\n                    px, py = pos\n                    if x <= px <= x + w_ and y <= py <= y + h_:\n                        return True\n            return False\n\n        def edge_in_obstacle(a, b, resolution=1.0):\n            dist = math.dist(a, b)\n            steps = max(1, int(dist / resolution))\n            for i in range(steps + 1):\n                interp = tuple(a[d] + (b[d] - a[d]) * (i / steps) for d in range(dim))\n                if in_obstacle(interp):\n                    return True\n            return False\n\n        def steer(from_p, to_p):\n            dist = math.dist(from_p, to_p)\n            if dist <= self.step_size:\n                return to_p\n            r = self.step_size / dist\n            return tuple(from_p[i] + r * (to_p[i] - from_p[i]) for i in range(dim))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: math.dist(n.position, point))\n\n        def extract_path(n_start, n_goal):\n            path_start = []\n            cur = n_start\n            while cur:\n                path_start.append(cur.position)\n                cur = cur.parent\n            path_goal = []\n            cur = n_goal\n            while cur:\n                path_goal.append(cur.position)\n                cur = cur.parent\n            # Concatenate paths, avoid duplicate connecting node\n            return path_start[::-1] + path_goal\n\n        start_tree = [Node(start_pos, cost=0.0)]\n        goal_tree = [Node(goal_pos, cost=0.0)]\n        all_nodes = start_tree + goal_tree\n        edges = []\n\n        best_cost = float('inf')\n        best_pair: Optional[Tuple[Node, Node]] = None\n        success = False\n        result_path: List[Tuple[float, ...]] = []\n\n        start_time = time.monotonic()\n\n        for i in range(self.max_iter):\n            if (time.monotonic() - start_time) > self.time_limit:\n                break\n\n            tree_a, tree_b = (start_tree, goal_tree) if i % 2 == 0 else (goal_tree, start_tree)\n\n            # Sample free point with up to 30 attempts\n            for _ in range(30):\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not in_obstacle(sample):\n                    break\n            else:\n                continue  # failed to sample free after attempts\n\n            nearest_node = nearest(tree_a, sample)\n            new_pos = steer(nearest_node.position, sample)\n\n            if in_obstacle(new_pos) or edge_in_obstacle(nearest_node.position, new_pos):\n                continue\n\n            new_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            new_node = Node(new_pos, nearest_node, new_cost)\n            nearest_node.add_child(new_node)\n            tree_a.append(new_node)\n            all_nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n\n            nearest_other = nearest(tree_b, new_pos)\n            if not edge_in_obstacle(new_pos, nearest_other.position):\n                total_cost = new_node.cost + nearest_other.cost + math.dist(new_pos, nearest_other.position)\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pair = (new_node, nearest_other)\n                    edges.append((new_node, nearest_other))\n                    result_path = extract_path(new_node, nearest_other)\n                    success = True\n                    break\n\n        # If no direct connection found but some connection exists, return best found\n        if not success and best_pair:\n            result_path = extract_path(best_pair[0], best_pair[1])\n            success = True\n\n        return PlannerResult(\n            success=success,\n            path=result_path,\n            nodes=all_nodes,\n            edges=edges\n        )",
        "objective": -24.92759,
        "time_improvement": 82.0,
        "length_improvement": -0.0,
        "smoothness_improvement": 92.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.009375262260437011,
                "num_nodes_avg": 104.2,
                "path_length_avg": 186.86118029182813,
                "smoothness_avg": 0.011858695753358503,
                "success_improvement": 0.0,
                "time_improvement": 62.84766510017782,
                "length_improvement": -2.421573922836127,
                "smoothness_improvement": 85.61434011005716,
                "objective_score": 17.82942687690196
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.0108933687210083,
                "num_nodes_avg": 207.0,
                "path_length_avg": 301.1392049228708,
                "smoothness_avg": 0.007192541773967287,
                "success_improvement": 0.0,
                "time_improvement": 93.35529808018127,
                "length_improvement": -0.5289344146681318,
                "smoothness_improvement": 85.06928042261754,
                "objective_score": 28.11457517736659
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.0054740428924560545,
                "num_nodes_avg": 130.1,
                "path_length_avg": 146.4215367465422,
                "smoothness_avg": 0.01604222894735964,
                "success_improvement": 0.0,
                "time_improvement": 88.88742075079293,
                "length_improvement": 2.7537871372738185,
                "smoothness_improvement": 104.05596809624664,
                "objective_score": 28.8387783480834
            }
        ],
        "success_rate": 1.0
    }
]