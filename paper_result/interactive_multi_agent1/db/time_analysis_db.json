[
    {
        "parents": [
            "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 3.0, goal_sample_rate: float = 0.05):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map) -> PlannerResult:\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        root = Node(start_position)\n        nodes.append(root)\n\n        for _ in range(self.max_iter):\n            # Goal biasing\n            if random.random() < self.goal_sample_rate:\n                sample = goal_position\n            else:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n\n            # Find nearest node\n            nearest_node = min(nodes, key=lambda n: math.dist(n.position, sample))\n\n            # Steer\n            direction = tuple(sample[d] - nearest_node.position[d] for d in range(len(bounds)))\n            length = math.dist(nearest_node.position, sample)\n            if length == 0:\n                continue\n            unit = tuple(d / length for d in direction)\n            new_position = tuple(nearest_node.position[d] + unit[d] * min(self.step_size, length) for d in range(len(bounds)))\n\n            if self._is_in_obstacle(new_position, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_position, obstacles, is_3d):\n                continue\n\n            new_node = Node(new_position, parent=nearest_node, cost=nearest_node.cost + math.dist(nearest_node.position, new_position))\n            nearest_node.add_child(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n\n            # Check if goal reached\n            if math.dist(new_position, goal_position) <= self.step_size:\n                if not self._is_edge_in_obstacle(new_position, goal_position, obstacles, is_3d) and not self._is_in_obstacle(goal_position, obstacles, is_3d):\n                    goal_node = Node(goal_position, parent=new_node, cost=new_node.cost + math.dist(new_position, goal_position))\n                    new_node.add_child(goal_node)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    success_state = True\n                    break\n\n        if success_state:\n            path = []\n            node = nodes[-1]\n            while node:\n                path.append(node.position)\n                node = node.parent\n            extracted_path = path[::-1]\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n    ",
            "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, radius: float = 10.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.radius = radius\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n        nodes = []\n        edges = []\n        success_state = False\n        extracted_path = []\n\n        for iter in range(self.max_iter):\n            rand = self._sample_free(bounds, obstacles, is_3d)\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest = self._nearest(tree_a, rand)\n                new_pos = self._steer(nearest.position, rand, self.step_size)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                    continue\n\n                new_node = Node(new_pos)\n                near_nodes = self._near(tree_a, new_pos, self.radius)\n                min_cost = nearest.cost + self._distance(nearest.position, new_pos)\n                min_parent = nearest\n\n                for near in near_nodes:\n                    cost = near.cost + self._distance(near.position, new_pos)\n                    if cost < min_cost and not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d):\n                        min_cost = cost\n                        min_parent = near\n\n                new_node.parent = min_parent\n                new_node.cost = min_cost\n                min_parent.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((min_parent, new_node))\n\n                for near in near_nodes:\n                    if near == min_parent:\n                        continue\n                    new_cost = new_node.cost + self._distance(new_node.position, near.position)\n                    if new_cost < near.cost and not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                        if near.parent:\n                            edges.remove((near.parent, near))\n                        near.parent = new_node\n                        near.cost = new_cost\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n\n                connect_node = self._nearest(tree_b, new_node.position)\n                if self._distance(new_node.position, connect_node.position) < self.step_size and not self._is_edge_in_obstacle(new_node.position, connect_node.position, obstacles, is_3d):\n                    success_state = True\n                    extracted_path = self._extract_path(new_node, connect_node)\n                    return PlannerResult(True, extracted_path, start_tree + goal_tree, edges)\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        while True:\n            point = tuple(random.uniform(0, bounds[i]) for i in range(3 if is_3d else 2))\n            if not self._is_in_obstacle(point, obstacles, is_3d):\n                return point\n\n    def _nearest(self, tree, point):\n        return min(tree, key=lambda node: self._distance(node.position, point))\n\n    def _near(self, tree, point, radius):\n        return [node for node in tree if self._distance(node.position, point) <= radius]\n\n    def _steer(self, from_pos, to_pos, step_size):\n        dist = self._distance(from_pos, to_pos)\n        if dist <= step_size:\n            return to_pos\n        ratio = step_size / dist\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n    def _extract_path(self, node_a, node_b):\n        path_a = []\n        while node_a:\n            path_a.append(node_a.position)\n            node_a = node_a.parent\n        path_b = []\n        while node_b:\n            path_b.append(node_b.position)\n            node_b = node_b.parent\n        return list(reversed(path_a)) + path_b\n\n    def _distance(self, a, b):\n        return math.dist(a, b)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = self._distance(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n    "
        ],
        "offspring": {
            "operator": "m1",
            "algorithm_description": "This algorithm is a bidirectional RRT* planner enhanced with adaptive neighborhood radius based on the number of nodes to balance rewiring efficiency and exploration speed. It grows two trees (from start and goal) by sampling the space, extending towards samples, rewiring locally to optimize path cost, and attempts connections between trees to find a feasible path quickly. The rewiring radius shrinks with node count to focus optimization locally as the tree grows. Once a connection is achieved, it extracts the shortest path connecting start and goal. The planner respects collision constraints for nodes and edges, enforces map boundaries, and stops if time limit or iteration limit is reached, returning the best path found.",
            "planning_mechanism": "The planner alternates growing start and goal trees by sampling random free points, steering nearest nodes toward samples with fixed step size, rewiring nearby nodes within a dynamically computed radius to minimize path cost, and tries connecting the trees when a new node is added. The radius shrinks with tree size to keep rewiring efficient. The planning stops upon reaching max iterations or 30 seconds. Upon success or timeout, the best found path from the connected trees is extracted by traversing parent links to the roots, composing a continuous path between start and goal.",
            "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n        import time\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = start_tree[:] + goal_tree[:]\n        edges = []\n\n        success = False\n        best_cost = float('inf')\n        best_connect = None\n\n        start_time = time.monotonic()\n        TIME_LIMIT = 30.0\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def sample_free():\n            while True:\n                p = tuple(random.uniform(0, bounds[i]) for i in range(len(bounds)))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: dist(n.position, point))\n\n        def near(tree, point, radius):\n            return [node for node in tree if dist(node.position, point) <= radius]\n\n        def steer(from_p, to_p, step):\n            d = dist(from_p, to_p)\n            if d <= step:\n                return to_p\n            ratio = step / d\n            return tuple(from_p[i] + (to_p[i] - from_p[i]) * ratio for i in range(len(from_p)))\n\n        def path_cost(node):\n            return node.cost\n\n        def extract_path(node_start, node_goal):\n            path_start = []\n            cur = node_start\n            while cur:\n                path_start.append(cur.position)\n                cur = cur.parent\n            path_goal = []\n            cur = node_goal\n            while cur:\n                path_goal.append(cur.position)\n                cur = cur.parent\n            return path_start[::-1] + path_goal\n\n        # Maintain mapping from position to Node for quick reference if needed\n        for iter_count in range(self.max_iter):\n            if time.monotonic() - start_time > TIME_LIMIT:\n                break\n\n            # Alternate trees: odd iter grow start_tree, even iter grow goal_tree\n            tree_a = start_tree if iter_count % 2 == 0 else goal_tree\n            tree_b = goal_tree if iter_count % 2 == 0 else start_tree\n\n            sample = sample_free()\n\n            nearest_node = nearest(tree_a, sample)\n            new_pos = steer(nearest_node.position, sample, self.step_size)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            # Radius adapted as per RRT* theory: gamma*(log(n)/n)^{1/d}\n            n = len(tree_a) + 1\n            d = len(bounds)\n            gamma = 30.0  # Tuned constant for neighborhood radius\n            radius = min(self.step_size * 5, gamma * (math.log(n) / n) ** (1 / d))\n\n            near_nodes = near(tree_a, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            min_parent = nearest_node\n            # Find best parent among neighbors\n            for near_node in near_nodes:\n                cost_through_near = near_node.cost + dist(near_node.position, new_pos)\n                if cost_through_near < min_cost and not self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d):\n                    min_cost = cost_through_near\n                    min_parent = near_node\n\n            new_node = Node(new_pos, parent=min_parent, cost=min_cost)\n            min_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((min_parent, new_node))\n\n            # Rewire neighbors if better through new_node\n            for near_node in near_nodes:\n                if near_node == min_parent:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, near_node.position)\n                if new_cost < near_node.cost and not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                    if near_node.parent:\n                        try:\n                            edges.remove((near_node.parent, near_node))\n                        except ValueError:\n                            pass\n                        near_node.parent.children.remove(near_node)\n                    near_node.parent = new_node\n                    near_node.cost = new_cost\n                    new_node.add_child(near_node)\n                    edges.append((new_node, near_node))\n\n            # Attempt to connect to other tree\n            nearest_to_new_in_other = nearest(tree_b, new_node.position)\n            dist_between = dist(new_node.position, nearest_to_new_in_other.position)\n            if dist_between <= self.step_size:\n                if not self._is_edge_in_obstacle(new_node.position, nearest_to_new_in_other.position, obstacles, is_3d):\n                    # Connection found\n                    candidate_cost = new_node.cost + nearest_to_new_in_other.cost + dist_between\n                    if candidate_cost < best_cost:\n                        best_cost = candidate_cost\n                        best_connect = (new_node, nearest_to_new_in_other)\n                        success = True\n                        # Stop early on first solution\n                        break\n\n        extracted_path = []\n        if success and best_connect is not None:\n            extracted_path = extract_path(best_connect[0], best_connect[1])\n\n        # If no success but time/iter limit reached, try to find best partial connection\n        if not success:\n            # Attempt to find minimal-cost connection between trees\n            min_cost = float('inf')\n            best_pair = None\n            for n1 in start_tree:\n                # Nearest node in goal_tree\n                n2 = min(goal_tree, key=lambda node: dist(n1.position, node.position))\n                d12 = dist(n1.position, n2.position)\n                if d12 <= self.step_size:\n                    if not self._is_edge_in_obstacle(n1.position, n2.position, obstacles, is_3d):\n                        cost_sum = n1.cost + n2.cost + d12\n                        if cost_sum < min_cost:\n                            min_cost = cost_sum\n                            best_pair = (n1, n2)\n            if best_pair is not None:\n                extracted_path = extract_path(best_pair[0], best_pair[1])\n                success = True\n\n        return PlannerResult(\n            success=success,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
            "objective": -24.50215,
            "time_improvement": 67.0,
            "length_improvement": 6.0,
            "smoothness_improvement": 140.0,
            "other_inf": [
                {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.009191942214965821,
                    "num_nodes_avg": 110.2,
                    "path_length_avg": 170.91077029046983,
                    "smoothness_avg": 0.01777274497333912,
                    "success_improvement": 0.0,
                    "time_improvement": 63.26946693101152,
                    "length_improvement": 6.321098549329074,
                    "smoothness_improvement": 178.1820529661874,
                    "objective_score": 23.664409473731837
                },
                {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.02384507656097412,
                    "num_nodes_avg": 292.0,
                    "path_length_avg": 282.72493325276366,
                    "smoothness_avg": 0.008011301853497212,
                    "success_improvement": 0.0,
                    "time_improvement": 85.41712475015616,
                    "length_improvement": 5.618279494235603,
                    "smoothness_improvement": 106.13656699797079,
                    "objective_score": 29.52678795657806
                },
                {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.023160457611083984,
                    "num_nodes_avg": 291.8,
                    "path_length_avg": 141.37742625459262,
                    "smoothness_avg": 0.018422059860500224,
                    "success_improvement": 0.0,
                    "time_improvement": 53.271010054655534,
                    "length_improvement": 6.10384515129628,
                    "smoothness_improvement": 134.3272416505493,
                    "objective_score": 20.31524631542717
                }
            ],
            "success_rate": 1.0
        },
        "objective": 43.4,
        "analysis": "1. Summary of key changes:\n   - Offspring uses a bidirectional RRT* approach growing two trees with rewiring and adaptive neighborhood radius based on node count.\n   - Offspring incorporates dynamic neighborhood radius shrinking with the number of nodes, unlike fixed radius in parents.\n   - Offspring attempts early stopping upon finding a better connection and limits planning time explicitly.\n   - Offspring includes improved path cost tracking in rewiring for better path optimization.\n   - Parent #1 is unidirectional basic RRT without rewiring or advanced heuristics, and Parent #2 uses bidirectional RRT* with fixed radius rewiring.\n\n2. Primary contributors to the performance improvement:\n   - Adaptive neighborhood radius optimizing rewiring scope reduces unnecessary rewires, improving planning speed.\n   - Bidirectional growth with alternating tree expansion accelerates exploration and connection.\n   - Early stopping after finding better cost connections prevents excessive iterations.\n   - Cost-based rewiring improves path quality and reduces number of nodes over time.\n\n3. Expected mechanism of impact:\n   - Adaptive radius reduces computational overhead per new node by focusing rewiring only on relevant neighbors.\n   - Bidirectional search halves the exploration space, increasing convergence speed and reducing planning time.\n   - Early termination avoids extra computations once a high-quality path is found, saving time.\n   - Better path cost management improves node selection and rewiring efficiency, resulting in fewer unnecessary expansions and faster convergence."
    },
    {
        "parents": [
            "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n        import time\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = start_tree[:] + goal_tree[:]\n        edges = []\n\n        success = False\n        best_cost = float('inf')\n        best_connect = None\n\n        start_time = time.monotonic()\n        TIME_LIMIT = 30.0\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def sample_free():\n            while True:\n                p = tuple(random.uniform(0, bounds[i]) for i in range(len(bounds)))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: dist(n.position, point))\n\n        def near(tree, point, radius):\n            return [node for node in tree if dist(node.position, point) <= radius]\n\n        def steer(from_p, to_p, step):\n            d = dist(from_p, to_p)\n            if d <= step:\n                return to_p\n            ratio = step / d\n            return tuple(from_p[i] + (to_p[i] - from_p[i]) * ratio for i in range(len(from_p)))\n\n        def path_cost(node):\n            return node.cost\n\n        def extract_path(node_start, node_goal):\n            path_start = []\n            cur = node_start\n            while cur:\n                path_start.append(cur.position)\n                cur = cur.parent\n            path_goal = []\n            cur = node_goal\n            while cur:\n                path_goal.append(cur.position)\n                cur = cur.parent\n            return path_start[::-1] + path_goal\n\n        # Maintain mapping from position to Node for quick reference if needed\n        for iter_count in range(self.max_iter):\n            if time.monotonic() - start_time > TIME_LIMIT:\n                break\n\n            # Alternate trees: odd iter grow start_tree, even iter grow goal_tree\n            tree_a = start_tree if iter_count % 2 == 0 else goal_tree\n            tree_b = goal_tree if iter_count % 2 == 0 else start_tree\n\n            sample = sample_free()\n\n            nearest_node = nearest(tree_a, sample)\n            new_pos = steer(nearest_node.position, sample, self.step_size)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            # Radius adapted as per RRT* theory: gamma*(log(n)/n)^{1/d}\n            n = len(tree_a) + 1\n            d = len(bounds)\n            gamma = 30.0  # Tuned constant for neighborhood radius\n            radius = min(self.step_size * 5, gamma * (math.log(n) / n) ** (1 / d))\n\n            near_nodes = near(tree_a, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            min_parent = nearest_node\n            # Find best parent among neighbors\n            for near_node in near_nodes:\n                cost_through_near = near_node.cost + dist(near_node.position, new_pos)\n                if cost_through_near < min_cost and not self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d):\n                    min_cost = cost_through_near\n                    min_parent = near_node\n\n            new_node = Node(new_pos, parent=min_parent, cost=min_cost)\n            min_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((min_parent, new_node))\n\n            # Rewire neighbors if better through new_node\n            for near_node in near_nodes:\n                if near_node == min_parent:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, near_node.position)\n                if new_cost < near_node.cost and not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                    if near_node.parent:\n                        try:\n                            edges.remove((near_node.parent, near_node))\n                        except ValueError:\n                            pass\n                        near_node.parent.children.remove(near_node)\n                    near_node.parent = new_node\n                    near_node.cost = new_cost\n                    new_node.add_child(near_node)\n                    edges.append((new_node, near_node))\n\n            # Attempt to connect to other tree\n            nearest_to_new_in_other = nearest(tree_b, new_node.position)\n            dist_between = dist(new_node.position, nearest_to_new_in_other.position)\n            if dist_between <= self.step_size:\n                if not self._is_edge_in_obstacle(new_node.position, nearest_to_new_in_other.position, obstacles, is_3d):\n                    # Connection found\n                    candidate_cost = new_node.cost + nearest_to_new_in_other.cost + dist_between\n                    if candidate_cost < best_cost:\n                        best_cost = candidate_cost\n                        best_connect = (new_node, nearest_to_new_in_other)\n                        success = True\n                        # Stop early on first solution\n                        break\n\n        extracted_path = []\n        if success and best_connect is not None:\n            extracted_path = extract_path(best_connect[0], best_connect[1])\n\n        # If no success but time/iter limit reached, try to find best partial connection\n        if not success:\n            # Attempt to find minimal-cost connection between trees\n            min_cost = float('inf')\n            best_pair = None\n            for n1 in start_tree:\n                # Nearest node in goal_tree\n                n2 = min(goal_tree, key=lambda node: dist(n1.position, node.position))\n                d12 = dist(n1.position, n2.position)\n                if d12 <= self.step_size:\n                    if not self._is_edge_in_obstacle(n1.position, n2.position, obstacles, is_3d):\n                        cost_sum = n1.cost + n2.cost + d12\n                        if cost_sum < min_cost:\n                            min_cost = cost_sum\n                            best_pair = (n1, n2)\n            if best_pair is not None:\n                extracted_path = extract_path(best_pair[0], best_pair[1])\n                success = True\n\n        return PlannerResult(\n            success=success,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False"
        ],
        "offspring": {
            "operator": "time_expert",
            "algorithm_description": "A bidirectional RRT* planner with adaptive neighborhood radius, efficient rewiring, and early stopping to minimize planning time and improve path quality. It grows two trees from start and goal by sampling free space, steering towards samples with fixed step size, and rewiring a shrinking neighborhood for path cost optimization. The planner attempts tree connection after each extension and returns the best path found within a 30-second limit.",
            "planning_mechanism": "A bidirectional RRT* planner alternates growing two trees by sampling, nearest node selection, steering, collision checks, and cost-based rewiring within an adaptively shrinking radius. It tries connecting the two trees whenever a new node is added, stopping early on the first improved connection. The adaptive radius balances exploration and efficient rewiring, reducing overhead and improving solution quality over time.",
            "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n        import time\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = start_tree[:] + goal_tree[:]\n        edges = []\n\n        success = False\n        best_cost = float('inf')\n        best_connect = None\n\n        start_time = time.monotonic()\n        TIME_LIMIT = 30.0\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def sample_free():\n            for _ in range(30):\n                p = tuple(random.uniform(0, bounds[i]) for i in range(len(bounds)))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n            # fallback: return start or goal to prevent infinite loop (rare)\n            return start_pos\n\n        def nearest(tree, point):\n            # Linear search; for improvement, can be replaced with spatial index\n            best_node = None\n            best_dist = float('inf')\n            for n in tree:\n                d = dist(n.position, point)\n                if d < best_dist:\n                    best_dist = d\n                    best_node = n\n            return best_node\n\n        def near(tree, point, radius):\n            r_sq = radius * radius\n            return [n for n in tree if (n.position[0] - point[0]) ** 2 + (n.position[1] - point[1]) ** 2 <= r_sq] if not is_3d else \\\n                   [n for n in tree if sum((n.position[i] - point[i]) ** 2 for i in range(3)) <= r_sq]\n\n        def steer(from_p, to_p, step):\n            d = dist(from_p, to_p)\n            if d <= step:\n                return to_p\n            ratio = step / d\n            return tuple(from_p[i] + (to_p[i] - from_p[i]) * ratio for i in range(len(from_p)))\n\n        def extract_path(n_start, n_goal):\n            path_start = []\n            curr = n_start\n            while curr is not None:\n                path_start.append(curr.position)\n                curr = curr.parent\n            path_goal = []\n            curr = n_goal\n            while curr is not None:\n                path_goal.append(curr.position)\n                curr = curr.parent\n            # Reverse start path and append goal path (connecting at the connecting edge)\n            return path_start[::-1] + path_goal\n\n        def cost_to_reach(node):\n            return node.cost\n\n        def try_rewire(new_node, neighbors, tree, obstacles, is_3d):\n            changed = False\n            for near_node in neighbors:\n                if near_node is new_node.parent:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, near_node.position)\n                if new_cost + 1e-9 < near_node.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                        # Rewire near_node\n                        if near_node.parent:\n                            try:\n                                edges.remove((near_node.parent, near_node))\n                            except ValueError:\n                                pass\n                            if near_node in near_node.parent.children:\n                                near_node.parent.children.remove(near_node)\n                        near_node.parent = new_node\n                        near_node.cost = new_cost\n                        new_node.add_child(near_node)\n                        edges.append((new_node, near_node))\n                        changed = True\n            return changed\n\n        def add_node(tree, new_node):\n            tree.append(new_node)\n            nodes.append(new_node)\n\n        gamma = 30.0\n        dim = len(bounds)\n\n        for iter_count in range(self.max_iter):\n            now = time.monotonic()\n            if now - start_time > TIME_LIMIT:\n                break\n\n            # Alternate tree growth\n            tree_a = start_tree if iter_count % 2 == 0 else goal_tree\n            tree_b = goal_tree if iter_count % 2 == 0 else start_tree\n\n            rnd = sample_free()\n\n            nearest_node = nearest(tree_a, rnd)\n            new_pos = steer(nearest_node.position, rnd, self.step_size)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            n_nodes = len(tree_a) + 1\n            radius = min(self.step_size * 5, gamma * (math.log(max(n_nodes, 2)) / n_nodes) ** (1 / dim))\n\n            near_nodes = near(tree_a, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            min_parent = nearest_node\n            for near_node in near_nodes:\n                cost_through = near_node.cost + dist(near_node.position, new_pos)\n                if cost_through + 1e-9 < min_cost:\n                    if not self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d):\n                        min_cost = cost_through\n                        min_parent = near_node\n\n            new_node = Node(new_pos, parent=min_parent, cost=min_cost)\n            min_parent.add_child(new_node)\n            add_node(tree_a, new_node)\n            edges.append((min_parent, new_node))\n\n            try_rewire(new_node, near_nodes, tree_a, obstacles, is_3d)\n\n            # Try connecting other tree near new_node\n            nearest_in_other = nearest(tree_b, new_node.position)\n            dist_connect = dist(new_node.position, nearest_in_other.position)\n            if dist_connect <= self.step_size:\n                if not self._is_edge_in_obstacle(new_node.position, nearest_in_other.position, obstacles, is_3d):\n                    total_cost = new_node.cost + nearest_in_other.cost + dist_connect\n                    if total_cost + 1e-9 < best_cost:\n                        best_cost = total_cost\n                        best_connect = (new_node, nearest_in_other)\n                        success = True\n                        # Early stop on first good solution to reduce planning time\n                        break\n\n        # Extract best path if found\n        if success and best_connect is not None:\n            extracted_path = extract_path(best_connect[0], best_connect[1])\n        else:\n            # No direct connection found in time, try minimal-cost pair and path extraction\n            min_cost_est = float('inf')\n            best_pair = None\n            for n1 in start_tree:\n                n2 = nearest(goal_tree, n1.position)\n                d12 = dist(n1.position, n2.position)\n                if d12 <= self.step_size:\n                    if not self._is_edge_in_obstacle(n1.position, n2.position, obstacles, is_3d):\n                        cost_sum = n1.cost + n2.cost + d12\n                        if cost_sum + 1e-9 < min_cost_est:\n                            min_cost_est = cost_sum\n                            best_pair = (n1, n2)\n            if best_pair is not None:\n                extracted_path = extract_path(best_pair[0], best_pair[1])\n                success = True\n            else:\n                extracted_path = []\n\n        return PlannerResult(\n            success=success,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
            "objective": -27.32825,
            "time_improvement": 72.0,
            "length_improvement": 8.0,
            "smoothness_improvement": 142.0,
            "other_inf": [
                {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.011930179595947266,
                    "num_nodes_avg": 135.2,
                    "path_length_avg": 171.34059103033889,
                    "smoothness_avg": 0.01642005874301497,
                    "success_improvement": 0.0,
                    "time_improvement": 52.327609778218985,
                    "length_improvement": 6.085506990861369,
                    "smoothness_improvement": 157.00957605645047,
                    "objective_score": 20.13463500826477
                },
                {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.01886107921600342,
                    "num_nodes_avg": 282.1,
                    "path_length_avg": 270.38122584620703,
                    "smoothness_avg": 0.008398311675666579,
                    "success_improvement": 0.0,
                    "time_improvement": 88.4651758369878,
                    "length_improvement": 9.738964320462099,
                    "smoothness_improvement": 116.09460847429625,
                    "objective_score": 32.96340438574508
                },
                {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.012389254570007325,
                    "num_nodes_avg": 219.8,
                    "path_length_avg": 136.44974335966273,
                    "smoothness_avg": 0.019808586046500164,
                    "success_improvement": 0.0,
                    "time_improvement": 75.00319890246378,
                    "length_improvement": 9.376577499064672,
                    "smoothness_improvement": 151.9637523937513,
                    "objective_score": 28.88672493214669
                }
            ],
            "success_rate": 1.0
        },
        "objective": 41.199999999999996,
        "analysis": "1. Summary of key changes:\n   - The offspring algorithm includes a limited number (30) of sample retries before returning a fallback point, reducing infinite sampling loops.\n   - Rewiring incorporates a small numerical tolerance (1e-9) and prevents redundant edge removals more robustly.\n   - The radius calculation uses a safeguard with max(n_nodes, 2) to avoid log(1) or zero division.\n   - Early stopping occurs immediately upon finding a first improved connection to reduce unnecessary iterations.\n   - Near neighbor search in offspring uses squared distance checks for efficiency.\n   - Offspring rewiring is encapsulated into a dedicated function simplifying management and potentially reducing overhead.\n2. Primary contributors to the performance improvement:\n   - Early stopping reduces total computation time by halting search once a better solution is found.\n   - Sample_free() with retry limit prevents excessive attempts to sample free space, enhancing runtime consistency.\n   - Efficient squared distance checks and reorganized rewiring lead to faster neighbor searches and updates.\n3. Expected mechanism of impact:\n   - By bounding sampling attempts, the search avoids delays caused by repeated invalid samples near obstacles.\n   - Early stopping truncates the planning loop sooner, decreasing total runtime.\n   - Optimized near neighbor calculations and rewiring avoid unnecessary costly collision checks and data structure modifications, lowering CPU time per iteration."
    },
    {
        "parents": [
            "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n        import time\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = start_tree[:] + goal_tree[:]\n        edges = []\n\n        success = False\n        best_cost = float('inf')\n        best_connect = None\n\n        start_time = time.monotonic()\n        TIME_LIMIT = 30.0\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def sample_free():\n            while True:\n                p = tuple(random.uniform(0, bounds[i]) for i in range(len(bounds)))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: dist(n.position, point))\n\n        def near(tree, point, radius):\n            return [node for node in tree if dist(node.position, point) <= radius]\n\n        def steer(from_p, to_p, step):\n            d = dist(from_p, to_p)\n            if d <= step:\n                return to_p\n            ratio = step / d\n            return tuple(from_p[i] + (to_p[i] - from_p[i]) * ratio for i in range(len(from_p)))\n\n        def path_cost(node):\n            return node.cost\n\n        def extract_path(node_start, node_goal):\n            path_start = []\n            cur = node_start\n            while cur:\n                path_start.append(cur.position)\n                cur = cur.parent\n            path_goal = []\n            cur = node_goal\n            while cur:\n                path_goal.append(cur.position)\n                cur = cur.parent\n            return path_start[::-1] + path_goal\n\n        # Maintain mapping from position to Node for quick reference if needed\n        for iter_count in range(self.max_iter):\n            if time.monotonic() - start_time > TIME_LIMIT:\n                break\n\n            # Alternate trees: odd iter grow start_tree, even iter grow goal_tree\n            tree_a = start_tree if iter_count % 2 == 0 else goal_tree\n            tree_b = goal_tree if iter_count % 2 == 0 else start_tree\n\n            sample = sample_free()\n\n            nearest_node = nearest(tree_a, sample)\n            new_pos = steer(nearest_node.position, sample, self.step_size)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            # Radius adapted as per RRT* theory: gamma*(log(n)/n)^{1/d}\n            n = len(tree_a) + 1\n            d = len(bounds)\n            gamma = 30.0  # Tuned constant for neighborhood radius\n            radius = min(self.step_size * 5, gamma * (math.log(n) / n) ** (1 / d))\n\n            near_nodes = near(tree_a, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            min_parent = nearest_node\n            # Find best parent among neighbors\n            for near_node in near_nodes:\n                cost_through_near = near_node.cost + dist(near_node.position, new_pos)\n                if cost_through_near < min_cost and not self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d):\n                    min_cost = cost_through_near\n                    min_parent = near_node\n\n            new_node = Node(new_pos, parent=min_parent, cost=min_cost)\n            min_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((min_parent, new_node))\n\n            # Rewire neighbors if better through new_node\n            for near_node in near_nodes:\n                if near_node == min_parent:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, near_node.position)\n                if new_cost < near_node.cost and not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                    if near_node.parent:\n                        try:\n                            edges.remove((near_node.parent, near_node))\n                        except ValueError:\n                            pass\n                        near_node.parent.children.remove(near_node)\n                    near_node.parent = new_node\n                    near_node.cost = new_cost\n                    new_node.add_child(near_node)\n                    edges.append((new_node, near_node))\n\n            # Attempt to connect to other tree\n            nearest_to_new_in_other = nearest(tree_b, new_node.position)\n            dist_between = dist(new_node.position, nearest_to_new_in_other.position)\n            if dist_between <= self.step_size:\n                if not self._is_edge_in_obstacle(new_node.position, nearest_to_new_in_other.position, obstacles, is_3d):\n                    # Connection found\n                    candidate_cost = new_node.cost + nearest_to_new_in_other.cost + dist_between\n                    if candidate_cost < best_cost:\n                        best_cost = candidate_cost\n                        best_connect = (new_node, nearest_to_new_in_other)\n                        success = True\n                        # Stop early on first solution\n                        break\n\n        extracted_path = []\n        if success and best_connect is not None:\n            extracted_path = extract_path(best_connect[0], best_connect[1])\n\n        # If no success but time/iter limit reached, try to find best partial connection\n        if not success:\n            # Attempt to find minimal-cost connection between trees\n            min_cost = float('inf')\n            best_pair = None\n            for n1 in start_tree:\n                # Nearest node in goal_tree\n                n2 = min(goal_tree, key=lambda node: dist(n1.position, node.position))\n                d12 = dist(n1.position, n2.position)\n                if d12 <= self.step_size:\n                    if not self._is_edge_in_obstacle(n1.position, n2.position, obstacles, is_3d):\n                        cost_sum = n1.cost + n2.cost + d12\n                        if cost_sum < min_cost:\n                            min_cost = cost_sum\n                            best_pair = (n1, n2)\n            if best_pair is not None:\n                extracted_path = extract_path(best_pair[0], best_pair[1])\n                success = True\n\n        return PlannerResult(\n            success=success,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
            "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float = 0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children: List[Node] = []\n        self.valid = True\n    def add_child(self, child):\n        self.children.append(child)\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.time_limit = 30.0\n        self.goal_sample_rate = 0.15  # Controlled goal biasing\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = dim == 3\n\n        gamma_rrt_star = 35.0  # Tuned constant for neighborhood radius\n\n        # Initialize bidirectional trees: list of Node\n        start_tree = [Node(start_pos, cost=0.0)]\n        goal_tree = [Node(goal_pos, cost=0.0)]\n        nodes = start_tree[:] + goal_tree[:]\n        edges = []\n\n        best_connection = None  # tuple of (Node from start_tree, Node from goal_tree)\n        best_cost = float('inf')\n        success = False\n\n        step_size = self.step_size\n        start_time = time.monotonic()\n\n        def dist(a: Tuple[float, ...], b: Tuple[float, ...]) -> float:\n            return math.dist(a, b)\n\n        def sample_free() -> Tuple[float, ...]:\n            # Goal bias: sample goal with goal_sample_rate probability\n            if random.random() < self.goal_sample_rate:\n                return goal_pos\n            for _ in range(100):\n                p = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n            return goal_pos  # fallback\n\n        def nearest(tree: List[Node], point: Tuple[float, ...]) -> Node:\n            best_node = None\n            best_d = float('inf')\n            for node in tree:\n                d = dist(node.position, point)\n                if d < best_d:\n                    best_d = d\n                    best_node = node\n            return best_node\n\n        def near(tree: List[Node], point: Tuple[float, ...], radius: float) -> List[Node]:\n            neighbors = []\n            for node in tree:\n                d = dist(node.position, point)\n                if d <= radius:\n                    neighbors.append((d, node))\n            neighbors.sort(key=lambda x: x[0])\n            return [n[1] for n in neighbors]\n\n        def steer(from_p: Tuple[float, ...], to_p: Tuple[float, ...], max_step: float) -> Tuple[float, ...]:\n            d = dist(from_p, to_p)\n            if d <= max_step:\n                return to_p\n            ratio = max_step / d\n            return tuple(from_p[i] + (to_p[i] - from_p[i]) * ratio for i in range(dim))\n\n        def extract_path(n_start: Node, n_goal: Node) -> List[Tuple[float, ...]]:\n            path_start = []\n            cur = n_start\n            while cur is not None:\n                path_start.append(cur.position)\n                cur = cur.parent\n            path_start.reverse()\n            path_goal = []\n            cur = n_goal\n            while cur is not None:\n                path_goal.append(cur.position)\n                cur = cur.parent\n            # avoid duplicate connection node position\n            if path_goal and path_start and path_start[-1] == path_goal[0]:\n                path_goal = path_goal[1:]\n            return path_start + path_goal\n\n        def shortcut_path(path: List[Tuple[float, ...]], max_attempts=50) -> List[Tuple[float, ...]]:\n            # Progressive shortcutting: attempt random shortcuts to smooth path preserving collision constraints\n            if len(path) < 3:\n                return path\n            for _ in range(max_attempts):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1 = path[i]\n                p2 = path[j]\n                # Check if shortcut collision free\n                if not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution=max(self.step_size * 0.2, 0.2)):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        def try_connect(new_node: Node, other_tree: List[Node]) -> Tuple[Node, float]:\n            radius = step_size * 2.5\n            candidates = near(other_tree, new_node.position, radius)\n            best_cand = None\n            best_cost_local = float('inf')\n            for node in candidates:\n                dist_between = dist(new_node.position, node.position)\n                if dist_between <= radius and not self._is_edge_in_obstacle(new_node.position, node.position, obstacles, is_3d, resolution=max(step_size * 0.2, 0.2)):\n                    total_cost = new_node.cost + dist_between + node.cost\n                    if total_cost < best_cost_local:\n                        best_cost_local = total_cost\n                        best_cand = node\n            return best_cand, best_cost_local\n\n        def rewire(tree: List[Node], new_node: Node, neighbors: List[Node]) -> None:\n            for neighbor in neighbors:\n                if neighbor is new_node.parent:\n                    continue\n                cost_through = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_through + 1e-9 < neighbor.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d, resolution=max(step_size * 0.2, 0.2)):\n                        # rewire: switch parent\n                        if neighbor.parent:\n                            try:\n                                edges.remove((neighbor.parent, neighbor))\n                            except Exception:\n                                pass\n                            neighbor.parent.remove_child(neighbor)\n                        neighbor.parent = new_node\n                        neighbor.cost = cost_through\n                        new_node.add_child(neighbor)\n                        edges.append((new_node, neighbor))\n\n        iter_since_last_shortcut = 0\n        shortcut_interval = 75\n\n        for it in range(self.max_iter):\n            if time.monotonic() - start_time > self.time_limit:\n                break\n\n            tree_a = start_tree if it % 2 == 0 else goal_tree\n            tree_b = goal_tree if it % 2 == 0 else start_tree\n\n            sample = sample_free()\n            nearest_node = nearest(tree_a, sample)\n            new_pos = steer(nearest_node.position, sample, step_size)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d, resolution=max(step_size * 0.2, 0.2)):\n                continue\n\n            n_nodes = len(tree_a) + 1\n            radius = min(step_size * 5,\n                         gamma_rrt_star * ((math.log(n_nodes) / n_nodes) ** (1 / dim)))\n            if radius < step_size:\n                radius = step_size  # at least step size\n\n            neighbors = near(tree_a, new_pos, radius)\n\n            # Find best parent node (lowest cost + dist) collision safe\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            min_parent = nearest_node\n            for nb in neighbors:\n                cost_candidate = nb.cost + dist(nb.position, new_pos)\n                if cost_candidate + 1e-9 < min_cost:\n                    if not self._is_edge_in_obstacle(nb.position, new_pos, obstacles, is_3d, resolution=max(step_size * 0.2, 0.2)):\n                        min_cost = cost_candidate\n                        min_parent = nb\n\n            new_node = Node(new_pos, parent=min_parent, cost=min_cost)\n            min_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((min_parent, new_node))\n\n            rewire(tree_a, new_node, neighbors)\n\n            # Try connect new_node to other tree with multiple candidates\n            conn_node, conn_cost = try_connect(new_node, tree_b)\n            if conn_node is not None and conn_cost + 1e-9 < best_cost:\n                best_cost = conn_cost\n                best_connection = (new_node, conn_node) if it % 2 == 0 else (conn_node, new_node)\n                success = True\n                # Early stop on improved connection\n                break\n\n            # Periodic incremental shortcutting to improve intermediate path smoothness & length\n            iter_since_last_shortcut += 1\n            if iter_since_last_shortcut >= shortcut_interval and success:\n                path_cur = extract_path(best_connection[0], best_connection[1])\n                path_short = shortcut_path(path_cur, max_attempts=25)\n                # If shortcut reduces nodes substantially, update best path extracted immediately\n                if len(path_short) < len(path_cur):\n                    # Reset iter counter to avoid shortcutting excessive times\n                    iter_since_last_shortcut = 0\n                    extracted_path = path_short\n\n        extracted_path: List[Tuple[float, ...]] = []\n        if success and best_connection is not None:\n            extracted_path = extract_path(best_connection[0], best_connection[1])\n            extracted_path = shortcut_path(extracted_path, max_attempts=75)\n        else:\n            # If no success, try find best partial connection\n            best_partial_cost = float('inf')\n            best_pair = None\n            search_radius = step_size * 3.0\n            for n1 in start_tree:\n                candidates = near(goal_tree, n1.position, search_radius)\n                for n2 in candidates:\n                    d12 = dist(n1.position, n2.position)\n                    if d12 <= search_radius:\n                        if not self._is_edge_in_obstacle(n1.position, n2.position, obstacles, is_3d, resolution=max(step_size * 0.2, 0.2)):\n                            total_cost = n1.cost + n2.cost + d12\n                            if total_cost + 1e-9 < best_partial_cost:\n                                best_partial_cost = total_cost\n                                best_pair = (n1, n2)\n            if best_pair:\n                success = True\n                extracted_path = extract_path(best_pair[0], best_pair[1])\n                extracted_path = shortcut_path(extracted_path, max_attempts=75)\n\n        return PlannerResult(\n            success=success,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False"
        ],
        "offspring": {
            "operator": "cross_over",
            "algorithm_description": "This algorithm implements a bidirectional, goal-biased RRT* planner with adaptive neighborhood radius rewiring, multi-candidate bidirectional connection attempts, and incremental path shortcutting applied during planning and after completion. It enforces a strict 30-second time limit and dynamically adjusts rewiring radius based on tree size and dimension to balance exploration and refinement efficiency. The planner samples with goal bias for faster convergence, alternates expanding start and goal trees, and progressively shortcuts the best found path to minimize length and improve smoothness. Early stopping occurs upon finding a better path.",
            "planning_mechanism": "The planner grows two trees alternately from start and goal positions, samples random points with a goal bias, and extends the nearest node towards samples with a fixed step size while respecting collision constraints. It rewires nearby nodes within an adaptively shrinking radius to optimize path costs. Multiple candidates from the opposite tree are tested for connection on each new node added, enabling early termination when better paths are found. Progressive shortcutting improves path smoothness and length during planning as well as post-planning. The search halts immediately if the 30-second limit is exceeded, returning the best path found so far.",
            "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n    def add_child(self, child):\n        self.children.append(child)\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\nclass Planner:\n    def __init__(self, max_iter: int=5000, step_size: float=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.time_limit = 30.0\n        self.goal_sample_rate = 0.15  # probability to sample goal\n\n    def plan(self, map) -> 'PlannerResult':\n        import time\n        import math\n        import random\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        # Tree nodes and edges\n        start_tree = [Node(start_pos, cost=0.0)]\n        goal_tree = [Node(goal_pos, cost=0.0)]\n        nodes = start_tree[:] + goal_tree[:]\n        edges = []\n\n        best_connection = None\n        best_cost = float('inf')\n        success = False\n        extracted_path = []\n\n        step = self.step_size\n        gamma = 35.0  # radius multiplier for rewiring (RRT* theory)\n\n        start_time = time.monotonic()\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def sample_free():\n            # goal bias sampling\n            if random.random() < self.goal_sample_rate:\n                return goal_pos\n            for _ in range(100):\n                p = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n            return goal_pos  # fallback\n\n        def nearest(tree, point):\n            best_node = None\n            best_d = float('inf')\n            for node in tree:\n                d = dist(node.position, point)\n                if d < best_d:\n                    best_node = node\n                    best_d = d\n            return best_node\n\n        def near(tree, point, radius):\n            neighbors = [(dist(n.position, point), n) for n in tree if dist(n.position, point) <= radius]\n            neighbors.sort(key=lambda x: x[0])\n            return [n[1] for n in neighbors]\n\n        def steer(from_p, to_p, max_step):\n            d = dist(from_p, to_p)\n            if d <= max_step:\n                return to_p\n            ratio = max_step / d\n            return tuple(from_p[i] + (to_p[i] - from_p[i]) * ratio for i in range(dim))\n\n        def extract_path(node_start, node_goal):\n            path_start = []\n            cur = node_start\n            while cur:\n                path_start.append(cur.position)\n                cur = cur.parent\n            path_start.reverse()\n            path_goal = []\n            cur = node_goal\n            while cur:\n                path_goal.append(cur.position)\n                cur = cur.parent\n            if path_goal and path_start and path_start[-1] == path_goal[0]:\n                path_goal = path_goal[1:]\n            return path_start + path_goal\n\n        def shortcut_path(path, max_attempts=50):\n            if len(path) < 3:\n                return path\n            for _ in range(max_attempts):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution=max(step*0.2, 0.2)):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        def try_connect(new_node, other_tree):\n            radius = step*2.5\n            candidates = near(other_tree, new_node.position, radius)\n            best_cand = None\n            best_local_cost = float('inf')\n            for node in candidates:\n                d12 = dist(new_node.position, node.position)\n                if d12 <= radius and not self._is_edge_in_obstacle(new_node.position, node.position, obstacles, is_3d, resolution=max(step*0.2, 0.2)):\n                    c = new_node.cost + d12 + node.cost\n                    if c < best_local_cost:\n                        best_local_cost = c\n                        best_cand = node\n            return best_cand, best_local_cost\n\n        def rewire(tree, new_node, neighbors):\n            for nbr in neighbors:\n                if nbr is new_node.parent:\n                    continue\n                cost_through = new_node.cost + dist(new_node.position, nbr.position)\n                if cost_through + 1e-9 < nbr.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, nbr.position, obstacles, is_3d, resolution=max(step*0.2, 0.2)):\n                        if nbr.parent:\n                            try:\n                                edges.remove((nbr.parent, nbr))\n                            except Exception:\n                                pass\n                            nbr.parent.remove_child(nbr)\n                        nbr.parent = new_node\n                        nbr.cost = cost_through\n                        new_node.add_child(nbr)\n                        edges.append((new_node, nbr))\n\n        iter_since_last_shortcut = 0\n        shortcut_interval = 75\n\n        for it in range(self.max_iter):\n            if time.monotonic() - start_time > self.time_limit:\n                break\n\n            tree_a = start_tree if (it % 2 == 0) else goal_tree\n            tree_b = goal_tree if (it % 2 == 0) else start_tree\n\n            sample = sample_free()\n            nearest_node = nearest(tree_a, sample)\n            new_pos = steer(nearest_node.position, sample, step)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d, resolution=max(step*0.2, 0.2)):\n                continue\n\n            n_nodes = len(tree_a) + 1\n            radius = gamma * ((math.log(n_nodes)/n_nodes) ** (1/dim)) if n_nodes > 1 else step*5\n            radius = min(radius, step*5)\n            if radius < step:\n                radius = step\n\n            neighbors = near(tree_a, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            min_parent = nearest_node\n            for nb in neighbors:\n                cost_cand = nb.cost + dist(nb.position, new_pos)\n                if cost_cand + 1e-9 < min_cost:\n                    if not self._is_edge_in_obstacle(nb.position, new_pos, obstacles, is_3d, resolution=max(step*0.2, 0.2)):\n                        min_cost = cost_cand\n                        min_parent = nb\n\n            new_node = Node(new_pos, parent=min_parent, cost=min_cost)\n            min_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((min_parent, new_node))\n\n            rewire(tree_a, new_node, neighbors)\n\n            conn_node, conn_cost = try_connect(new_node, tree_b)\n            if conn_node is not None and conn_cost + 1e-9 < best_cost:\n                best_cost = conn_cost\n                # Maintain start_tree node first in best_connection\n                best_connection = (new_node, conn_node) if it % 2 == 0 else (conn_node, new_node)\n                success = True\n                # Early termination on improved path\n                break\n\n            iter_since_last_shortcut += 1\n            if iter_since_last_shortcut >= shortcut_interval and success:\n                path_cur = extract_path(best_connection[0], best_connection[1])\n                path_short = shortcut_path(path_cur, max_attempts=25)\n                if len(path_short) < len(path_cur):\n                    extracted_path = path_short\n                    iter_since_last_shortcut = 0\n\n        if success and best_connection is not None:\n            extracted_path = extract_path(best_connection[0], best_connection[1])\n            extracted_path = shortcut_path(extracted_path, max_attempts=75)\n        elif not success:\n            # Try partial best connection if no success\n            best_partial_cost = float('inf')\n            best_pair = None\n            search_radius = step * 3.0\n            for n1 in start_tree:\n                candidates = near(goal_tree, n1.position, search_radius)\n                for n2 in candidates:\n                    d12 = dist(n1.position, n2.position)\n                    if d12 <= search_radius:\n                        if not self._is_edge_in_obstacle(n1.position, n2.position, obstacles, is_3d, resolution=max(step*0.2, 0.2)):\n                            cost_sum = n1.cost + n2.cost + d12\n                            if cost_sum + 1e-9 < best_partial_cost:\n                                best_partial_cost = cost_sum\n                                best_pair = (n1, n2)\n            if best_pair:\n                success = True\n                extracted_path = extract_path(best_pair[0], best_pair[1])\n                extracted_path = shortcut_path(extracted_path, max_attempts=75)\n\n        return PlannerResult(\n            success=success,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
            "objective": -40.41506,
            "time_improvement": 74.0,
            "length_improvement": 17.0,
            "smoothness_improvement": 1612.0,
            "other_inf": [
                {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.010355472564697266,
                    "num_nodes_avg": 88.3,
                    "path_length_avg": 158.02445292325712,
                    "smoothness_avg": 0.04068830742889877,
                    "success_improvement": 0.0,
                    "time_improvement": 58.963282937365015,
                    "length_improvement": 13.384293295064195,
                    "smoothness_improvement": 536.8603673360356,
                    "objective_score": 28.403862694928197
                },
                {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.025506019592285156,
                    "num_nodes_avg": 305.8,
                    "path_length_avg": 239.66358035944714,
                    "smoothness_avg": 0.11914932396717788,
                    "success_improvement": 0.0,
                    "time_improvement": 84.44192042954145,
                    "length_improvement": 19.993398542344394,
                    "smoothness_improvement": 2965.7979254646784,
                    "objective_score": 52.15760488159246
                },
                {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.010851669311523437,
                    "num_nodes_avg": 173.2,
                    "path_length_avg": 123.90215675117983,
                    "smoothness_avg": 0.11268141879062014,
                    "success_improvement": 0.0,
                    "time_improvement": 77.97057173653472,
                    "length_improvement": 17.710087072551893,
                    "smoothness_improvement": 1333.2993297395258,
                    "objective_score": 40.683720413189185
                }
            ],
            "success_rate": 1.0
        },
        "objective": 41.6,
        "analysis": "1. Summary of key changes:\n   - Introduction of goal bias sampling (15% goal sampling rate) in offspring vs uniform random sampling in parents.\n   - Adaptive neighborhood radius based on tree size and dimension with more consistent radius lower bound equals step size.\n   - Frequent incremental path shortcutting during planning to smooth and reduce path length.\n   - Multiple candidate connections to the other tree for better path cost improvements and earlier termination.\n   - More refined and consistent collision checking resolution scaled by step size.\n\n2. Primary contributors to the performance improvement:\n   - Goal bias sampling effectively accelerates convergence towards goal, reducing planning time.\n   - Adaptive rewire radius and multi-candidate connection enable better and earlier path improvements.\n   - Incremental shortcutting enhances smoothness and path length without large extra compute.\n   - Improved collision checking resolution improves the balance between computational cost and path feasibility.\n\n3. Expected mechanism of impact:\n   - Goal biased sampling heuristically focuses sampling near the goal, reducing unnecessary exploratory expansions and accelerating connection.\n   - Adaptive radius rewiring ensures sufficient neighborhood for rewiring without excessive neighbors, improving optimization time and path quality.\n   - Incremental shortcutting reduces zig-zags and redundant nodes, lowering total cost and smoothing the path progressively during planning.\n   - Multiple connection attempts with rewiring increase chances of low-cost connections, enabling the planner to find better paths earlier and stop sooner."
    },
    {
        "parents": [
            "\nclass Node:\n    def __init__(self, position, parent=None, cost: float = 0.0):\n        self.position = position              # Tuple[float, ...]\n        self.parent: Optional[\"Node\"] = parent\n        self.cost: float = cost\n        self.children: List[\"Node\"] = []\n        self.valid = True\n\n    def add_child(self, child_node: \"Node\"):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n\nclass Planner:\n    def __init__(\n        self,\n        max_iter: int = 5000,\n        step_size: float = 5.0,\n        gamma_rrt_star: float = 50.0,\n        max_radius: float = 60.0,\n    ):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.gamma_rrt_star = gamma_rrt_star\n        self.max_radius = max_radius\n\n    # ======================= Public API =======================\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        start_root = Node(start_position, parent=None, cost=0.0)\n        goal_root  = Node(goal_position,  parent=None, cost=0.0)\n        nodes.extend([start_root, goal_root])\n\n        tree_a: List[Node] = [start_root]\n        tree_b: List[Node] = [goal_root]\n\n        for _ in range(self.max_iter):\n            rand_point = self._sample_free(bounds, obstacles, is_3d)\n\n            new_a = self._extend_and_rewire(tree_a, rand_point, obstacles, is_3d, nodes, edges, bounds)\n            if new_a is None:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            new_b = self._connect_and_rewire(tree_b, new_a, obstacles, is_3d, nodes, edges, bounds)\n            if new_b:\n                success_state = True\n                path_a = new_a.path_from_root()\n                path_b = new_b.path_from_root()\n                if path_a and path_b and path_a[-1] == path_b[-1]:\n                    path_b = path_b[:-1]\n                extracted_path = path_a + path_b[::-1]\n                break\n\n            tree_a, tree_b = tree_b, tree_a\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        while True:\n            p = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    def _nearest(self, tree: List[Node], point):\n        return min(tree, key=lambda node: math.dist(node.position, point))\n\n    def _steer(self, from_pos, to_pos):\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _near_nodes(self, tree: List[Node], position, bounds) -> List[Node]:\n        n = max(1, len(tree))\n        d = len(position)\n        # \uacf5\uac04 \uc2a4\ucf00\uc77c\uc744 \uac04\ub2e8\ud788 bounds\ub85c \ucd94\uc815 (\uc815\ubc00 X, \uc2e4\uc6a9\uc801)\n        scale = max(1.0, sum(bounds) / d)\n        r_theory = self.gamma_rrt_star * ((math.log(n + 1) / (n + 1)) ** (1.0 / d))\n        radius = max(self.step_size * 2.0, min(self.max_radius, r_theory * 0.5 + scale * 0.02))\n        return [node for node in tree if math.dist(node.position, position) <= radius]\n\n    def _choose_parent_and_add(self, tree, new_pos, obstacles, is_3d, nodes, edges, bounds):\n        nearest = self._nearest(tree, new_pos)\n        neighbors = self._near_nodes(tree, new_pos, bounds)\n\n        min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n        best_parent = nearest\n\n        for nb in neighbors:\n            if not self._is_edge_in_obstacle(nb.position, new_pos, obstacles, is_3d):\n                cand = nb.cost + math.dist(nb.position, new_pos)\n                if cand < min_cost:\n                    min_cost = cand\n                    best_parent = nb\n\n        new_node = Node(new_pos, parent=None, cost=min_cost)\n        best_parent.add_child(new_node)\n        tree.append(new_node)\n        nodes.append(new_node)\n        edges.append((best_parent, new_node))\n        return new_node, neighbors\n\n    def _rewire_from(self, pivot: Node, neighbors: List[Node], obstacles, is_3d, edges):\n        for nb in neighbors:\n            if not self._is_edge_in_obstacle(pivot.position, nb.position, obstacles, is_3d):\n                new_cost = pivot.cost + math.dist(pivot.position, nb.position)\n                if new_cost + 1e-12 < nb.cost:  # \uc791\uc740 \uc218\uce58 \ubc84\ud37c\n                    if nb.parent is not None:\n                        try:\n                            edges.remove((nb.parent, nb))\n                        except ValueError:\n                            pass\n                        if nb in nb.parent.children:\n                            nb.parent.children.remove(nb)\n                    pivot.add_child(nb)\n                    nb.cost = new_cost\n                    edges.append((pivot, nb))\n\n    def _extend_and_rewire(self, tree, sample_point, obstacles, is_3d, nodes, edges, bounds):\n        nearest = self._nearest(tree, sample_point)\n        new_pos = self._steer(nearest.position, sample_point)\n\n        if self._is_in_obstacle(new_pos, obstacles, is_3d):\n            return None\n        if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n            return None\n\n        new_node, neighbors = self._choose_parent_and_add(tree, new_pos, obstacles, is_3d, nodes, edges, bounds)\n        self._rewire_from(new_node, neighbors, obstacles, is_3d, edges)\n        return new_node\n\n    def _connect_and_rewire(self, tree, target_node: Node, obstacles, is_3d, nodes, edges, bounds):\n        nearest = self._nearest(tree, target_node.position)\n\n        while True:\n            new_pos = self._steer(nearest.position, target_node.position)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                return None\n\n            connect_node, neighbors = self._choose_parent_and_add(tree, new_pos, obstacles, is_3d, nodes, edges, bounds)\n            self._rewire_from(connect_node, neighbors, obstacles, is_3d, edges)\n\n            if math.dist(connect_node.position, target_node.position) <= self.step_size:\n                if (not self._is_edge_in_obstacle(connect_node.position, target_node.position, obstacles, is_3d) and\n                    not self._is_in_obstacle(target_node.position, obstacles, is_3d)):\n                    final_node = Node(target_node.position, parent=None, cost=connect_node.cost + math.dist(connect_node.position, target_node.position))\n                    connect_node.add_child(final_node)\n                    tree.append(final_node)\n                    nodes.append(final_node)\n                    edges.append((connect_node, final_node))\n                    return final_node\n                else:\n                    return None\n\n            nearest = connect_node\n\n        \n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n        \n        \n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n",
            "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.time_limit = 30.0\n\n    def plan(self, map):\n        import time\n        import math\n        import random\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def in_obstacle(pos):\n            for o in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = o\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w_, h_ = o\n                    px, py = pos\n                    if x <= px <= x + w_ and y <= py <= y + h_:\n                        return True\n            return False\n\n        def edge_in_obstacle(a, b, resolution=1.0):\n            dist = math.dist(a, b)\n            steps = max(1, int(dist / resolution))\n            for i in range(steps + 1):\n                interp = tuple(a[d] + (b[d] - a[d]) * (i / steps) for d in range(dim))\n                if in_obstacle(interp):\n                    return True\n            return False\n\n        def steer(from_p, to_p):\n            dist = math.dist(from_p, to_p)\n            if dist <= self.step_size:\n                return to_p\n            r = self.step_size / dist\n            return tuple(from_p[i] + r * (to_p[i] - from_p[i]) for i in range(dim))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: math.dist(n.position, point))\n\n        def extract_path(node_start, node_goal):\n            path_start = []\n            cur = node_start\n            while cur is not None:\n                path_start.append(cur.position)\n                cur = cur.parent\n            path_goal = []\n            cur = node_goal\n            while cur is not None:\n                path_goal.append(cur.position)\n                cur = cur.parent\n            return path_start[::-1] + path_goal\n\n        start_tree = [Node(start_pos, cost=0.0)]\n        goal_tree = [Node(goal_pos, cost=0.0)]\n        all_nodes = start_tree + goal_tree\n        edges = []\n\n        best_cost = float('inf')\n        best_pair = None\n        success = False\n        result_path = []\n\n        start_time = time.monotonic()\n\n        for i in range(self.max_iter):\n            if time.monotonic() - start_time > self.time_limit:\n                break\n\n            tree_a, tree_b = (start_tree, goal_tree) if i % 2 == 0 else (goal_tree, start_tree)\n\n            # sample free point\n            for _ in range(100):  # limit attempts to avoid infinite loop\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not in_obstacle(sample):\n                    break\n            else:\n                continue  # failed to sample free point; skip iteration\n\n            nearest_node = nearest(tree_a, sample)\n            new_pos = steer(nearest_node.position, sample)\n\n            if in_obstacle(new_pos) or edge_in_obstacle(nearest_node.position, new_pos):\n                continue\n\n            new_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            new_node = Node(new_pos, nearest_node, new_cost)\n            nearest_node.add_child(new_node)\n            tree_a.append(new_node)\n            all_nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n\n            nearest_other = nearest(tree_b, new_pos)\n            if not edge_in_obstacle(new_pos, nearest_other.position):\n                total_cost = new_node.cost + nearest_other.cost + math.dist(new_pos, nearest_other.position)\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pair = (new_node, nearest_other)\n                    edges.append((new_node, nearest_other))\n                    result_path = extract_path(new_node, nearest_other)\n                    success = True\n                    break\n\n        if not success and best_pair:\n            result_path = extract_path(best_pair[0], best_pair[1])\n            success = True\n\n        return PlannerResult(\n            success=success,\n            path=result_path,\n            nodes=all_nodes,\n            edges=edges\n        )"
        ],
        "offspring": {
            "operator": "m3",
            "algorithm_description": "This algorithm implements a simplified bidirectional RRT planner focused on simplicity and generalization. It grows two trees alternately from start and goal positions by extending the nearest node toward randomly sampled free points with fixed step sizes. It attempts to connect the two trees directly at each iteration without rewiring or adaptive radius heuristics. The planner enforces strict collision checking on nodes and edges and stops early upon finding a successful path or reaching a 30-second limit. The best path found so far is always returned.",
            "planning_mechanism": "The planner alternates expansion between start and goal trees by sampling free points, steering nearest nodes toward samples, and adding new nodes if collision-free. At each insertion, it attempts to connect the other tree directly. It keeps track of the best connection and path cost, terminating early upon success or timeout.",
            "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent: Optional[\"Node\"]=None, cost: float=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children: List[\"Node\"] = []\n\n    def add_child(self, child: \"Node\"):\n        self.children.append(child)\n        child.parent = self\nclass Planner:\n    def __init__(self, max_iter: int=5000, step_size: float=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.time_limit = 30.0\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def in_obstacle(pos):\n            for o in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = o\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w_, h_ = o\n                    px, py = pos\n                    if x <= px <= x + w_ and y <= py <= y + h_:\n                        return True\n            return False\n\n        def edge_in_obstacle(a, b, resolution=1.0):\n            dist = math.dist(a, b)\n            steps = max(1, int(dist / resolution))\n            for i in range(steps + 1):\n                interp = tuple(a[d] + (b[d] - a[d]) * (i / steps) for d in range(dim))\n                if in_obstacle(interp):\n                    return True\n            return False\n\n        def steer(from_p, to_p):\n            dist = math.dist(from_p, to_p)\n            if dist <= self.step_size:\n                return to_p\n            r = self.step_size / dist\n            return tuple(from_p[i] + r * (to_p[i] - from_p[i]) for i in range(dim))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: math.dist(n.position, point))\n\n        def extract_path(n_start, n_goal):\n            path_start = []\n            cur = n_start\n            while cur:\n                path_start.append(cur.position)\n                cur = cur.parent\n            path_goal = []\n            cur = n_goal\n            while cur:\n                path_goal.append(cur.position)\n                cur = cur.parent\n            # Concatenate paths, avoid duplicate connecting node\n            return path_start[::-1] + path_goal\n\n        start_tree = [Node(start_pos, cost=0.0)]\n        goal_tree = [Node(goal_pos, cost=0.0)]\n        all_nodes = start_tree + goal_tree\n        edges = []\n\n        best_cost = float('inf')\n        best_pair: Optional[Tuple[Node, Node]] = None\n        success = False\n        result_path: List[Tuple[float, ...]] = []\n\n        start_time = time.monotonic()\n\n        for i in range(self.max_iter):\n            if (time.monotonic() - start_time) > self.time_limit:\n                break\n\n            tree_a, tree_b = (start_tree, goal_tree) if i % 2 == 0 else (goal_tree, start_tree)\n\n            # Sample free point with up to 30 attempts\n            for _ in range(30):\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not in_obstacle(sample):\n                    break\n            else:\n                continue  # failed to sample free after attempts\n\n            nearest_node = nearest(tree_a, sample)\n            new_pos = steer(nearest_node.position, sample)\n\n            if in_obstacle(new_pos) or edge_in_obstacle(nearest_node.position, new_pos):\n                continue\n\n            new_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            new_node = Node(new_pos, nearest_node, new_cost)\n            nearest_node.add_child(new_node)\n            tree_a.append(new_node)\n            all_nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n\n            nearest_other = nearest(tree_b, new_pos)\n            if not edge_in_obstacle(new_pos, nearest_other.position):\n                total_cost = new_node.cost + nearest_other.cost + math.dist(new_pos, nearest_other.position)\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pair = (new_node, nearest_other)\n                    edges.append((new_node, nearest_other))\n                    result_path = extract_path(new_node, nearest_other)\n                    success = True\n                    break\n\n        # If no direct connection found but some connection exists, return best found\n        if not success and best_pair:\n            result_path = extract_path(best_pair[0], best_pair[1])\n            success = True\n\n        return PlannerResult(\n            success=success,\n            path=result_path,\n            nodes=all_nodes,\n            edges=edges\n        )",
            "objective": -24.92759,
            "time_improvement": 82.0,
            "length_improvement": -0.0,
            "smoothness_improvement": 92.0,
            "other_inf": [
                {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.009375262260437011,
                    "num_nodes_avg": 104.2,
                    "path_length_avg": 186.86118029182813,
                    "smoothness_avg": 0.011858695753358503,
                    "success_improvement": 0.0,
                    "time_improvement": 62.84766510017782,
                    "length_improvement": -2.421573922836127,
                    "smoothness_improvement": 85.61434011005716,
                    "objective_score": 17.82942687690196
                },
                {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.0108933687210083,
                    "num_nodes_avg": 207.0,
                    "path_length_avg": 301.1392049228708,
                    "smoothness_avg": 0.007192541773967287,
                    "success_improvement": 0.0,
                    "time_improvement": 93.35529808018127,
                    "length_improvement": -0.5289344146681318,
                    "smoothness_improvement": 85.06928042261754,
                    "objective_score": 28.11457517736659
                },
                {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.0054740428924560545,
                    "num_nodes_avg": 130.1,
                    "path_length_avg": 146.4215367465422,
                    "smoothness_avg": 0.01604222894735964,
                    "success_improvement": 0.0,
                    "time_improvement": 88.88742075079293,
                    "length_improvement": 2.7537871372738185,
                    "smoothness_improvement": 104.05596809624664,
                    "objective_score": 28.8387783480834
                }
            ],
            "success_rate": 1.0
        },
        "objective": 48.4,
        "analysis": "1. Summary of key changes:\n   - Removed rewiring and adaptive radius computations, simplifying the tree expansion and connection logic.\n   - Limited sampling attempts per iteration (30 versus unlimited or 100 in parents) to avoid excessive computation.\n   - Introduced a strict 30-second time limit enforced with timing checks inside the planning loop.\n   - Simplified nearest neighbor searches without additional neighbor sets for rewiring.\n   - Eliminated complex edge rewiring and parent updates to reduce overhead.\n\n2. Primary contributors to the performance improvement:\n   - Reduced computational overhead by removing rewiring operations.\n   - Time limiting with early stopping prevents wasted iterations.\n   - Simplified sampling and connection procedures streamline iteration efficiency.\n   - Avoidance of complex data structures leading to faster nearest neighbor evaluations per iteration.\n\n3. Expected mechanism of impact:\n   - Less computational complexity per iteration allows more iterations or faster completion within the time limit.\n   - Early success detection and early stopping reduce unnecessary computations.\n   - Simplified data and control flow minimize Python overhead and memory usage.\n   - These factors together dramatically accelerate planning times despite minor or negative impact on path quality metrics."
    }
]