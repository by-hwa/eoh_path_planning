[
    {
        "operator": "m1",
        "algorithm_description": "This algorithm is a bidirectional RRT* planner enhanced with adaptive neighborhood radius based on the number of nodes to balance rewiring efficiency and exploration speed. It grows two trees (from start and goal) by sampling the space, extending towards samples, rewiring locally to optimize path cost, and attempts connections between trees to find a feasible path quickly. The rewiring radius shrinks with node count to focus optimization locally as the tree grows. Once a connection is achieved, it extracts the shortest path connecting start and goal. The planner respects collision constraints for nodes and edges, enforces map boundaries, and stops if time limit or iteration limit is reached, returning the best path found.",
        "planning_mechanism": "The planner alternates growing start and goal trees by sampling random free points, steering nearest nodes toward samples with fixed step size, rewiring nearby nodes within a dynamically computed radius to minimize path cost, and tries connecting the trees when a new node is added. The radius shrinks with tree size to keep rewiring efficient. The planning stops upon reaching max iterations or 30 seconds. Upon success or timeout, the best found path from the connected trees is extracted by traversing parent links to the roots, composing a continuous path between start and goal.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n        import time\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = start_tree[:] + goal_tree[:]\n        edges = []\n\n        success = False\n        best_cost = float('inf')\n        best_connect = None\n\n        start_time = time.monotonic()\n        TIME_LIMIT = 30.0\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def sample_free():\n            while True:\n                p = tuple(random.uniform(0, bounds[i]) for i in range(len(bounds)))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: dist(n.position, point))\n\n        def near(tree, point, radius):\n            return [node for node in tree if dist(node.position, point) <= radius]\n\n        def steer(from_p, to_p, step):\n            d = dist(from_p, to_p)\n            if d <= step:\n                return to_p\n            ratio = step / d\n            return tuple(from_p[i] + (to_p[i] - from_p[i]) * ratio for i in range(len(from_p)))\n\n        def path_cost(node):\n            return node.cost\n\n        def extract_path(node_start, node_goal):\n            path_start = []\n            cur = node_start\n            while cur:\n                path_start.append(cur.position)\n                cur = cur.parent\n            path_goal = []\n            cur = node_goal\n            while cur:\n                path_goal.append(cur.position)\n                cur = cur.parent\n            return path_start[::-1] + path_goal\n\n        # Maintain mapping from position to Node for quick reference if needed\n        for iter_count in range(self.max_iter):\n            if time.monotonic() - start_time > TIME_LIMIT:\n                break\n\n            # Alternate trees: odd iter grow start_tree, even iter grow goal_tree\n            tree_a = start_tree if iter_count % 2 == 0 else goal_tree\n            tree_b = goal_tree if iter_count % 2 == 0 else start_tree\n\n            sample = sample_free()\n\n            nearest_node = nearest(tree_a, sample)\n            new_pos = steer(nearest_node.position, sample, self.step_size)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            # Radius adapted as per RRT* theory: gamma*(log(n)/n)^{1/d}\n            n = len(tree_a) + 1\n            d = len(bounds)\n            gamma = 30.0  # Tuned constant for neighborhood radius\n            radius = min(self.step_size * 5, gamma * (math.log(n) / n) ** (1 / d))\n\n            near_nodes = near(tree_a, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            min_parent = nearest_node\n            # Find best parent among neighbors\n            for near_node in near_nodes:\n                cost_through_near = near_node.cost + dist(near_node.position, new_pos)\n                if cost_through_near < min_cost and not self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d):\n                    min_cost = cost_through_near\n                    min_parent = near_node\n\n            new_node = Node(new_pos, parent=min_parent, cost=min_cost)\n            min_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((min_parent, new_node))\n\n            # Rewire neighbors if better through new_node\n            for near_node in near_nodes:\n                if near_node == min_parent:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, near_node.position)\n                if new_cost < near_node.cost and not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                    if near_node.parent:\n                        try:\n                            edges.remove((near_node.parent, near_node))\n                        except ValueError:\n                            pass\n                        near_node.parent.children.remove(near_node)\n                    near_node.parent = new_node\n                    near_node.cost = new_cost\n                    new_node.add_child(near_node)\n                    edges.append((new_node, near_node))\n\n            # Attempt to connect to other tree\n            nearest_to_new_in_other = nearest(tree_b, new_node.position)\n            dist_between = dist(new_node.position, nearest_to_new_in_other.position)\n            if dist_between <= self.step_size:\n                if not self._is_edge_in_obstacle(new_node.position, nearest_to_new_in_other.position, obstacles, is_3d):\n                    # Connection found\n                    candidate_cost = new_node.cost + nearest_to_new_in_other.cost + dist_between\n                    if candidate_cost < best_cost:\n                        best_cost = candidate_cost\n                        best_connect = (new_node, nearest_to_new_in_other)\n                        success = True\n                        # Stop early on first solution\n                        break\n\n        extracted_path = []\n        if success and best_connect is not None:\n            extracted_path = extract_path(best_connect[0], best_connect[1])\n\n        # If no success but time/iter limit reached, try to find best partial connection\n        if not success:\n            # Attempt to find minimal-cost connection between trees\n            min_cost = float('inf')\n            best_pair = None\n            for n1 in start_tree:\n                # Nearest node in goal_tree\n                n2 = min(goal_tree, key=lambda node: dist(n1.position, node.position))\n                d12 = dist(n1.position, n2.position)\n                if d12 <= self.step_size:\n                    if not self._is_edge_in_obstacle(n1.position, n2.position, obstacles, is_3d):\n                        cost_sum = n1.cost + n2.cost + d12\n                        if cost_sum < min_cost:\n                            min_cost = cost_sum\n                            best_pair = (n1, n2)\n            if best_pair is not None:\n                extracted_path = extract_path(best_pair[0], best_pair[1])\n                success = True\n\n        return PlannerResult(\n            success=success,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
        "objective": -24.50215,
        "time_improvement": 67.0,
        "length_improvement": 6.0,
        "smoothness_improvement": 140.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.009191942214965821,
                "num_nodes_avg": 110.2,
                "path_length_avg": 170.91077029046983,
                "smoothness_avg": 0.01777274497333912,
                "success_improvement": 0.0,
                "time_improvement": 63.26946693101152,
                "length_improvement": 6.321098549329074,
                "smoothness_improvement": 178.1820529661874,
                "objective_score": 23.664409473731837
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.02384507656097412,
                "num_nodes_avg": 292.0,
                "path_length_avg": 282.72493325276366,
                "smoothness_avg": 0.008011301853497212,
                "success_improvement": 0.0,
                "time_improvement": 85.41712475015616,
                "length_improvement": 5.618279494235603,
                "smoothness_improvement": 106.13656699797079,
                "objective_score": 29.52678795657806
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.023160457611083984,
                "num_nodes_avg": 291.8,
                "path_length_avg": 141.37742625459262,
                "smoothness_avg": 0.018422059860500224,
                "success_improvement": 0.0,
                "time_improvement": 53.271010054655534,
                "length_improvement": 6.10384515129628,
                "smoothness_improvement": 134.3272416505493,
                "objective_score": 20.31524631542717
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "m2",
        "algorithm_description": "This algorithm is a bidirectional RRT* variant that grows two trees from the start and goal positions in an alternating manner. It features adaptive neighborhood radius shrinking with node count to efficiently perform rewiring, improving path quality and smoothness. The planner attempts to connect trees via cost-optimizing new edges, rewires neighbors to reduce path costs, and employs early stopping upon finding a feasible path or reaching a 30-second time limit. Nodes and edges are maintained coherently, and collision checks are consistently enforced to guarantee safe navigation.",
        "planning_mechanism": "The planner alternately samples points in free space, extends the nearest node in one tree toward the sample with fixed step size if collision-free, then searches neighbors in an adaptive radius for rewiring to improve local path costs. After each extension, an attempt is made to connect the other tree toward the new node; if successful, the overall path is updated. The neighborhood radius adapts dynamically based on node count and dimension. The procedure stops when a connection is found or when 30 seconds have elapsed, returning the best path found.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Cost from root\n        self.children = []\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 4.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map) -> 'PlannerResult':\n        import math, random, time\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        start_root = Node(start_pos)\n        goal_root = Node(goal_pos)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n\n        nodes = [start_root, goal_root]\n        edges = []\n        best_pair = None\n        best_cost = float('inf')\n\n        start_time = time.monotonic()\n        TIME_LIMIT = 30.0\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            ratio = self.step_size / d\n            return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(dim))\n\n        def neighbors(tree, new_node, radius):\n            result = []\n            for node in tree:\n                if dist(node.position, new_node.position) <= radius:\n                    result.append(node)\n            return result\n\n        def rewire(tree, new_node, radius):\n            nonlocal edges\n            for near_node in neighbors(tree, new_node, radius):\n                if near_node is new_node.parent:\n                    continue\n                if self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, near_node.position)\n                if new_cost < near_node.cost:\n                    # Rewire near_node to new_node\n                    if near_node.parent:\n                        if (near_node.parent, near_node) in edges:\n                            edges.remove((near_node.parent, near_node))\n                        near_node.parent.children.remove(near_node)\n                    near_node.parent = new_node\n                    new_node.children.append(near_node)\n                    near_node.cost = new_cost\n                    edges.append((new_node, near_node))\n\n        def try_connect(tree, node_other):\n            nonlocal edges, nodes\n            nearest = min(tree, key=lambda n: dist(n.position, node_other.position))\n            direction = node_other.position\n            extend_pos = steer(nearest.position, direction)\n            if self._is_in_obstacle(extend_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(nearest.position, extend_pos, obstacles, is_3d):\n                return None\n            new_node = Node(extend_pos, parent=nearest, cost=nearest.cost + dist(nearest.position, extend_pos))\n            nearest.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest, new_node))\n            # If close enough to node_other, try final connection\n            if dist(new_node.position, node_other.position) <= self.step_size:\n                if not self._is_edge_in_obstacle(new_node.position, node_other.position, obstacles, is_3d):\n                    final_node = Node(node_other.position, parent=new_node, cost=new_node.cost + dist(new_node.position, node_other.position))\n                    new_node.add_child(final_node)\n                    tree.append(final_node)\n                    nodes.append(final_node)\n                    edges.append((new_node, final_node))\n                    return final_node\n            return None\n\n        def construct_path(node_start, node_goal):\n            path_start = node_start.path_from_root()\n            path_goal = node_goal.path_from_root()\n            return path_start + path_goal[::-1]\n\n        # Parameters for adaptive radius: gamma * (log(n)/n)^{1/d}\n        gamma_rrt_star = 50.0\n        n_nodes_total = 2\n\n        current_tree = 0\n        for i in range(self.max_iter):\n            if (time.monotonic() - start_time) > TIME_LIMIT:\n                break\n            # Sample random free point\n            while True:\n                if is_3d:\n                    sample = tuple(random.uniform(0, bounds[j]) for j in range(3))\n                else:\n                    sample = tuple(random.uniform(0, bounds[j]) for j in range(2))\n                if not self._is_in_obstacle(sample, obstacles, is_3d):\n                    break\n            # Grow one tree\n            tree_a = tree_start if current_tree == 0 else tree_goal\n            tree_b = tree_goal if current_tree == 0 else tree_start\n\n            nearest = min(tree_a, key=lambda n: dist(n.position, sample))\n            new_pos = steer(nearest.position, sample)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                current_tree = 1 - current_tree\n                continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                current_tree = 1 - current_tree\n                continue\n\n            new_node = Node(new_pos, parent=nearest, cost=nearest.cost + dist(nearest.position, new_pos))\n            nearest.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest, new_node))\n            n_nodes_total += 1\n\n            # Adaptive radius calculation for rewiring\n            radius = gamma_rrt_star * (math.log(n_nodes_total) / n_nodes_total)**(1/dim) if n_nodes_total > 1 else self.step_size\n\n            # Rewire neighbors in tree_a\n            rewire(tree_a, new_node, radius)\n\n            # Try to connect other tree to new_node\n            connected_node = try_connect(tree_b, new_node)\n            if connected_node:\n                cost_candidate = new_node.cost + connected_node.cost\n                if cost_candidate < best_cost:\n                    best_cost = cost_candidate\n                    best_pair = (new_node, connected_node)\n                    # Early stopping upon first connection improving cost to encourage speed\n                    success_state = True\n                    extracted_path = construct_path(new_node, connected_node)\n                    break\n\n            current_tree = 1 - current_tree\n\n        # If no full connection found, attempt best partial connection to improve robustness\n        if not 'success_state' in locals() or not success_state:\n            best_pair = None\n            best_cost = float('inf')\n            for na in tree_start:\n                for nb in tree_goal:\n                    d = dist(na.position, nb.position)\n                    if d < best_cost:\n                        if not self._is_edge_in_obstacle(na.position, nb.position, obstacles, is_3d):\n                            best_cost = d\n                            best_pair = (na, nb)\n            if best_pair is not None:\n                success_state = False\n                extracted_path = construct_path(best_pair[0], best_pair[1])\n            else:\n                extracted_path = []\n\n        return PlannerResult(\n            success=success_state if 'success_state' in locals() else False,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
        "objective": -9.99314,
        "time_improvement": 33.0,
        "length_improvement": -0.0,
        "smoothness_improvement": 48.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.021655726432800292,
                "num_nodes_avg": 116.5,
                "path_length_avg": 181.03698566675305,
                "smoothness_avg": 0.009696583960183152,
                "success_improvement": 0.0,
                "time_improvement": 13.464819809477351,
                "length_improvement": 0.770759441437284,
                "smoothness_improvement": 51.77259544595633,
                "objective_score": 4.760764584935357
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.040307927131652835,
                "num_nodes_avg": 323.0,
                "path_length_avg": 297.80858302085164,
                "smoothness_avg": 0.0056680322890130495,
                "success_improvement": 0.0,
                "time_improvement": 75.34897942400752,
                "length_improvement": 0.5829230428618484,
                "smoothness_improvement": 45.842553314946905,
                "objective_score": 23.1836604194941
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.044866204261779785,
                "num_nodes_avg": 359.9,
                "path_length_avg": 153.18917956526434,
                "smoothness_avg": 0.011579448425289896,
                "success_improvement": 0.0,
                "time_improvement": 9.477073249574998,
                "length_improvement": -1.74095898240107,
                "smoothness_improvement": 47.28972926371222,
                "objective_score": 2.0349952317504183
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "m2",
        "algorithm_description": "This algorithm is an enhanced bidirectional RRT* planner with an adaptive rewiring radius that shrinks with the number of nodes and problem dimension. It alternates expanding two trees from start and goal by sampling collision-free points and steering toward samples with tunable step size. The planner rewires neighbors within an adaptive radius per iteration to locally optimize path cost and attempts incremental collision-checked connections between trees. Early stopping triggers when a better connecting path is found or after 30 seconds. The code efficiently maintains parent-child relations, avoids redundant rewiring, and returns the best path found so far.",
        "planning_mechanism": "The planner grows two trees alternately by sampling feasible points inside map bounds, extending nearest nodes toward samples with a controlled step size, and rewiring nodes in a decreasing adaptive neighborhood radius based on the logarithm of node count and dimensionality. After each extension, it tries to connect the other tree via incremental steps while verifying collision-free edges. It tracks the best connecting path and stops either on timeout or when improvement is found, returning the best discovered path, nodes, and edges.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return list(reversed(path))\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=4.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map):\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        import time\n        import math\n        import random\n\n        TIME_LIMIT = 30.0\n        gamma_rrt_star = 20.0  # Tuned constant for rewiring radius (reduced slightly from 30.0)\n        resolution = max(0.3, self.step_size * 0.1)  # Collision checking resolution\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_p, to_p, step):\n            d = dist(from_p, to_p)\n            if d <= step:\n                return to_p\n            ratio = step / d if d > 0 else 0\n            return tuple(from_p[i] + (to_p[i] - from_p[i]) * ratio for i in range(dim))\n\n        def is_in_bounds(p):\n            return all(0 <= p[i] <= bounds[i] for i in range(dim))\n\n        def sample_free():\n            for _ in range(30):  # capped attempts to find free sample\n                point = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not self._is_in_obstacle(point, obstacles, is_3d):\n                    return point\n            # fallback to start or goal in unlikely event\n            return random.choice([start_pos, goal_pos])\n\n        def nearest(tree, point):\n            best_node = None\n            best_dist = float('inf')\n            for node in tree:\n                d = dist(node.position, point)\n                if d < best_dist:\n                    best_dist = d\n                    best_node = node\n            return best_node\n\n        def near(tree, point, radius):\n            return [node for node in tree if dist(node.position, point) <= radius]\n\n        def valid_node(p):\n            return is_in_bounds(p) and (not self._is_in_obstacle(p, obstacles, is_3d))\n\n        def valid_edge(f_p, t_p):\n            return not self._is_edge_in_obstacle(f_p, t_p, obstacles, is_3d, resolution)\n\n        def insert_node(tree, parent, pos):\n            cost = parent.cost + dist(parent.position, pos)\n            new_node = Node(pos, parent, cost)\n            parent.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((parent, new_node))\n            return new_node\n\n        def propagate_cost_updates(node):\n            stack = [node]\n            while stack:\n                current = stack.pop()\n                for child in current.children:\n                    new_cost = current.cost + dist(current.position, child.position)\n                    if abs(new_cost - child.cost) > 1e-9:\n                        child.cost = new_cost\n                        stack.append(child)\n\n        def try_rewire(tree, new_node, radius):\n            near_nodes = near(tree, new_node.position, radius)\n            for near_node in near_nodes:\n                if near_node is new_node or near_node is new_node.parent:\n                    continue\n                cost_through_new = new_node.cost + dist(new_node.position, near_node.position)\n                if cost_through_new + 1e-9 < near_node.cost:\n                    if valid_edge(new_node.position, near_node.position):\n                        # Rewire near_node\n                        if near_node.parent:\n                            try:\n                                edges.remove((near_node.parent, near_node))\n                                near_node.parent.children.remove(near_node)\n                            except ValueError:\n                                pass\n                        near_node.parent = new_node\n                        near_node.cost = cost_through_new\n                        new_node.children.append(near_node)\n                        edges.append((new_node, near_node))\n                        propagate_cost_updates(near_node)\n\n        def try_connect(other_tree, target_node):\n            nearest_node = nearest(other_tree, target_node.position)\n            current = nearest_node\n            while True:\n                new_pos = steer(current.position, target_node.position, self.step_size)\n                if not valid_node(new_pos) or not valid_edge(current.position, new_pos):\n                    return None\n                new_node = insert_node(other_tree, current, new_pos)\n                current = new_node\n                if dist(current.position, target_node.position) <= self.step_size:\n                    if valid_edge(current.position, target_node.position):\n                        final_node = insert_node(other_tree, current, target_node.position)\n                        return final_node\n                    else:\n                        return None\n\n        def extract_path(n_start, n_goal):\n            path_start = n_start.path_from_root()\n            path_goal = n_goal.path_from_root()\n            return path_start + path_goal[::-1]\n\n        tree_start = [Node(start_pos)]\n        tree_goal = [Node(goal_pos)]\n        nodes = tree_start + tree_goal\n        edges = []\n\n        best_path = []\n        best_cost = float('inf')\n        success = False\n\n        start_time = time.monotonic()\n        iteration = 0\n        current_tree_idx = 0  # alternate expansions 0: start tree, 1: goal tree\n\n        while True:\n            if time.monotonic() - start_time > TIME_LIMIT:\n                break\n            if iteration >= self.max_iter:\n                break\n\n            sample = sample_free()\n            tree_a = tree_start if current_tree_idx == 0 else tree_goal\n            tree_b = tree_goal if current_tree_idx == 0 else tree_start\n\n            nearest_node = nearest(tree_a, sample)\n            new_pos = steer(nearest_node.position, sample, self.step_size)\n            if not valid_node(new_pos) or not valid_edge(nearest_node.position, new_pos):\n                current_tree_idx = 1 - current_tree_idx\n                iteration += 1\n                continue\n\n            new_node = insert_node(tree_a, nearest_node, new_pos)\n            iteration += 1\n\n            n_total = len(nodes)\n            radius = min(gamma_rrt_star * (math.log(n_total) / n_total) ** (1 / dim), self.step_size * 5) if n_total > 1 else self.step_size * 2\n\n            try_rewire(tree_a, new_node, radius)\n\n            connected_node = try_connect(tree_b, new_node)\n            if connected_node is not None:\n                path_cost = new_node.cost + connected_node.cost\n                if path_cost < best_cost:\n                    best_cost = path_cost\n                    best_path = extract_path(new_node, connected_node)\n                    success = True\n                    # Early stopping on improvement\n                    break\n\n            current_tree_idx = 1 - current_tree_idx\n\n        # If no success, try best partial connection\n        if not success:\n            best_pair = None\n            min_dist = float('inf')\n            for ns in tree_start:\n                for ng in tree_goal:\n                    d = dist(ns.position, ng.position)\n                    if d < min_dist and valid_edge(ns.position, ng.position):\n                        min_dist = d\n                        best_pair = (ns, ng)\n            if best_pair:\n                best_path = extract_path(best_pair[0], best_pair[1])\n                success = False\n            else:\n                best_path = []\n\n        return PlannerResult(success=success, path=best_path, nodes=nodes, edges=edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
        "objective": -18.14298,
        "time_improvement": 61.0,
        "length_improvement": -0.0,
        "smoothness_improvement": 32.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.007362580299377442,
                "num_nodes_avg": 95.5,
                "path_length_avg": 183.83010688030691,
                "smoothness_avg": 0.008450245792922445,
                "success_improvement": 0.0,
                "time_improvement": 70.57950400089936,
                "length_improvement": -0.7601945555495325,
                "smoothness_improvement": 32.26469666167757,
                "objective_score": 20.879057950248477
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.0193403959274292,
                "num_nodes_avg": 300.1,
                "path_length_avg": 293.427148226809,
                "smoothness_avg": 0.005154294392493812,
                "success_improvement": 0.0,
                "time_improvement": 88.1720412861293,
                "length_improvement": 2.0455720897213316,
                "smoothness_improvement": 32.6237072070568,
                "objective_score": 27.842074175706873
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.037999963760375975,
                "num_nodes_avg": 381.1,
                "path_length_avg": 154.20894043648855,
                "smoothness_avg": 0.01037109821332213,
                "success_improvement": 0.0,
                "time_improvement": 23.33053369238007,
                "length_improvement": -2.4182355972737124,
                "smoothness_improvement": 31.91960375861711,
                "objective_score": 5.707816768142878
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "e2",
        "algorithm_description": "A hybrid bidirectional RRT*-inspired planner that utilizes adaptive neighborhood radius rewiring, goal bias sampling, multi-candidate connection attempts, and incremental cost-based rewiring for improving planning efficiency, path length, and smoothness. The planner alternates tree expansions from start and goal, applies spatial pruning by dynamically shrinking the radius based on tree cardinality and dimension to focus rewiring on relevant neighbors, uses early stopping upon improved connection, and performs lightweight path shortcutting for smoothing while maintaining collision safety.",
        "planning_mechanism": "The planner maintains two trees growing bidirectionally, samples with a goal bias to efficiently explore near the goal, steers nearest nodes toward samples with a fixed step size, and rewires neighbors dynamically by considering cost improvements confined to an adaptively shrinking radius to optimize path quality and minimize overhead. Each iteration tries multiple candidate nodes to connect the two trees, favoring lower-cost connections and terminating early when a high-quality path is found or time limit exceeded. The final path undergoes fast shortcutting to reduce unnecessary waypoints while preserving collision-freeness and smoothness.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0, goal_sample_rate: float=0.15):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.time_limit = 30.0\n\n    def plan(self, map):\n        import time\n        import math\n        import random\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n        gamma_rrt_star = 50.0  # Controls neighborhood radius scaling for rewiring\n\n        start_tree = [Node(start_pos, cost=0.0)]\n        goal_tree = [Node(goal_pos, cost=0.0)]\n        nodes = start_tree[:] + goal_tree[:]\n        edges = []\n\n        best_connection = None\n        best_cost = float('inf')\n        success = False\n\n        # Precompute squared step size for efficiency\n        step_size = self.step_size\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def sample_free():\n            # Goal biasing: sample goal with probability goal_sample_rate\n            if random.random() < self.goal_sample_rate:\n                return goal_pos\n            for _ in range(100):\n                p = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n            # Fallback in rare case no free sample found\n            return goal_pos\n\n        def nearest(tree, point):\n            # Linear nearest (can be improved with spatial DS, not requested)\n            best_node = None\n            best_dist = float('inf')\n            for node in tree:\n                d = dist(node.position, point)\n                if d < best_dist:\n                    best_node = node\n                    best_dist = d\n            return best_node\n\n        def near(tree, point, radius):\n            neighbors = []\n            for node in tree:\n                d = dist(node.position, point)\n                if d <= radius:\n                    neighbors.append((d, node))\n            neighbors.sort(key=lambda x: x[0])\n            return [nd[1] for nd in neighbors]\n\n        def steer(from_p, to_p, max_step):\n            d = dist(from_p, to_p)\n            if d <= max_step:\n                return to_p\n            ratio = max_step / d\n            return tuple(from_p[i] + (to_p[i] - from_p[i]) * ratio for i in range(dim))\n\n        def extract_path(node_from_start, node_from_goal):\n            path_start = []\n            cur = node_from_start\n            while cur:\n                path_start.append(cur.position)\n                cur = cur.parent\n            path_goal = []\n            cur = node_from_goal\n            while cur:\n                path_goal.append(cur.position)\n                cur = cur.parent\n            return path_start[::-1] + path_goal\n\n        def shortcut_path(path):\n            # Lightweight shortcutting: tries up to 100 random shortcuts to smooth path while collision-free\n            max_attempts = 100\n            if len(path) < 3:\n                return path\n            for _ in range(max_attempts):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d):\n                    # Remove intermediate nodes between i and j\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        def try_connect(node, other_tree):\n            # Try multiple connection candidates from other_tree within radius around node.position\n            radius = step_size * 2.0\n            candidates = near(other_tree, node.position, radius)\n            best_node = None\n            best_cost_local = float('inf')\n            for cnode in candidates:\n                d = dist(node.position, cnode.position)\n                if d <= radius and not self._is_edge_in_obstacle(node.position, cnode.position, obstacles, is_3d):\n                    total_cost = node.cost + cnode.cost + d\n                    if total_cost < best_cost_local:\n                        best_cost_local = total_cost\n                        best_node = cnode\n            return best_node, best_cost_local\n\n        start_time = time.monotonic()\n\n        for it in range(self.max_iter):\n            if time.monotonic() - start_time > self.time_limit:\n                break\n\n            # Alternate expansion between start and goal trees\n            tree_a = start_tree if it % 2 == 0 else goal_tree\n            tree_b = goal_tree if it % 2 == 0 else start_tree\n\n            sample = sample_free()\n            nearest_node = nearest(tree_a, sample)\n            new_pos = steer(nearest_node.position, sample, step_size)\n\n            # Node collision check\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n\n            # Edge collision check\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            # Adaptive rewiring radius\n            n_nodes = len(tree_a) + 1\n            radius = min(step_size * 5, gamma_rrt_star * (math.log(n_nodes) / n_nodes) ** (1 / dim))\n\n            near_nodes = near(tree_a, new_pos, radius)\n\n            # Choose best parent minimizing cost + dist\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            min_parent = nearest_node\n            for near_node in near_nodes:\n                # Check cost through near_node and collision with near_node->new_pos\n                cost_through = near_node.cost + dist(near_node.position, new_pos)\n                if cost_through < min_cost:\n                    if not self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d):\n                        min_cost = cost_through\n                        min_parent = near_node\n\n            new_node = Node(new_pos, parent=min_parent, cost=min_cost)\n            min_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((min_parent, new_node))\n\n            # Rewire neighbors to new_node if cost improves and edge is collision-free\n            for near_node in near_nodes:\n                if near_node == min_parent:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, near_node.position)\n                if new_cost < near_node.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                        # Remove old edge\n                        if near_node.parent:\n                            try:\n                                edges.remove((near_node.parent, near_node))\n                            except ValueError:\n                                pass\n                            near_node.parent.remove_child(near_node)\n                        # Update parent and cost\n                        near_node.parent = new_node\n                        near_node.cost = new_cost\n                        new_node.add_child(near_node)\n                        edges.append((new_node, near_node))\n\n            # Attempt to connect newly added node to other tree candidates\n            conn_node, conn_cost = try_connect(new_node, tree_b)\n            if conn_node and conn_cost < best_cost:\n                best_cost = conn_cost\n                best_connection = (new_node, conn_node)\n                success = True\n                # Early stopping on improved path\n                break\n\n        extracted_path = []\n        if success and best_connection:\n            extracted_path = extract_path(best_connection[0], best_connection[1])\n            extracted_path = shortcut_path(extracted_path)\n        else:\n            # Attempt to find best partial connection on timeout or failure\n            min_cost = float('inf')\n            best_pair = None\n            for n1 in start_tree:\n                candidates = near(goal_tree, n1.position, step_size * 2.0)\n                for n2 in candidates:\n                    dist12 = dist(n1.position, n2.position)\n                    if dist12 <= step_size * 2.0:\n                        if not self._is_edge_in_obstacle(n1.position, n2.position, obstacles, is_3d):\n                            total_cost = n1.cost + n2.cost + dist12\n                            if total_cost < min_cost:\n                                min_cost = total_cost\n                                best_pair = (n1, n2)\n            if best_pair:\n                extracted_path = extract_path(best_pair[0], best_pair[1])\n                extracted_path = shortcut_path(extracted_path)\n                success = True\n\n        return PlannerResult(\n            success=success,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(\n                from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps)\n                for d in range(len(from_pos))\n            )\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
        "objective": -33.09257,
        "time_improvement": 56.0,
        "length_improvement": 16.0,
        "smoothness_improvement": 1398.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.01958200931549072,
                "num_nodes_avg": 140.8,
                "path_length_avg": 166.35481911674003,
                "smoothness_avg": 0.044027487308021036,
                "success_improvement": 0.0,
                "time_improvement": 21.75128782371844,
                "length_improvement": 8.818287581316609,
                "smoothness_improvement": 589.1257835894651,
                "objective_score": 14.761987813852823
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.026345157623291017,
                "num_nodes_avg": 303.5,
                "path_length_avg": 235.08654885206815,
                "smoothness_avg": 0.08998220763376255,
                "success_improvement": 0.0,
                "time_improvement": 83.88815627932586,
                "length_improvement": 21.521343402054775,
                "smoothness_improvement": 2215.3070139811657,
                "objective_score": 49.15578799493645
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.0191939115524292,
                "num_nodes_avg": 244.3,
                "path_length_avg": 125.39778779809066,
                "smoothness_avg": 0.11710275866810149,
                "success_improvement": 0.0,
                "time_improvement": 61.27399056588344,
                "length_improvement": 16.71676014549089,
                "smoothness_improvement": 1389.538446631726,
                "objective_score": 35.359945490218195
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "path_expert",
        "algorithm_description": "A bidirectional RRT* planner with goal bias and dynamically shrinking rewiring radius, improved parent selection via cost+distance heuristic, adaptive neighborhood rewiring focused on cost reduction, early connection attempts, and path shortcutting for minimal length under a hard 30s time limit.",
        "planning_mechanism": "The planner alternately grows start and goal trees using random sampling with goal bias, steering with fixed step size, and rewiring neighbors within a logarithmically shrinking radius for cost efficiency. It attempts early connection between trees by checking neighbors within an adaptive radius, selects parents minimizing cost-to-node plus distance heuristic, rewires incrementally to reduce path cost, and extracts and shortcuts the best path found periodically or on termination, always respecting collision constraints and bounds.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\nclass Planner:\n    def __init__(self, max_iter: int = 6000, step_size: float = 4.5, goal_sample_rate: float = 0.2):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.time_limit = 30.0\n\n    def plan(self, map):\n        import time\n        import random\n        import math\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        start_tree = [Node(start_pos, cost=0.0)]\n        goal_tree = [Node(goal_pos, cost=0.0)]\n        nodes = start_tree[:] + goal_tree[:]\n        edges = []\n\n        best_connection = None\n        best_cost = float('inf')\n        success = False\n        extracted_path = []\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def sample_free():\n            for _ in range(30):\n                if random.random() < self.goal_sample_rate:\n                    p = goal_pos\n                else:\n                    p = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n            return goal_pos\n\n        def nearest(tree, point):\n            best_node = None\n            best_dist = float('inf')\n            for node in tree:\n                d = dist(node.position, point)\n                if d < best_dist:\n                    best_node = node\n                    best_dist = d\n            return best_node\n\n        def near(tree, point, radius):\n            r_sq = radius * radius\n            neighbors = []\n            for node in tree:\n                d_sq = sum((node.position[i] - point[i])**2 for i in range(dim))\n                if d_sq <= r_sq:\n                    neighbors.append((math.sqrt(d_sq), node))\n            neighbors.sort(key=lambda x: x[0])\n            return [n[1] for n in neighbors]\n\n        def steer(from_p, to_p, max_step):\n            d = dist(from_p, to_p)\n            if d <= max_step:\n                return to_p\n            ratio = max_step / d\n            return tuple(from_p[i] + ratio * (to_p[i] - from_p[i]) for i in range(dim))\n\n        def extract_path(n_start, n_goal):\n            path_start = []\n            cur = n_start\n            while cur:\n                path_start.append(cur.position)\n                cur = cur.parent\n            path_goal = []\n            cur = n_goal\n            while cur:\n                path_goal.append(cur.position)\n                cur = cur.parent\n            return path_start[::-1] + path_goal\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            for _ in range(75):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        def try_connect(node, other_tree, radius):\n            candidates = near(other_tree, node.position, radius)\n            best_node = None\n            best_cost_local = float('inf')\n            for cnode in candidates:\n                d = dist(node.position, cnode.position)\n                if d <= radius and not self._is_edge_in_obstacle(node.position, cnode.position, obstacles, is_3d):\n                    total_cost = node.cost + cnode.cost + d\n                    if total_cost < best_cost_local:\n                        best_cost_local = total_cost\n                        best_node = cnode\n            return best_node, best_cost_local\n\n        start_time = time.monotonic()\n\n        for it in range(self.max_iter):\n            current_time = time.monotonic()\n            if current_time - start_time > self.time_limit:\n                break\n\n            tree_a = start_tree if it % 2 == 0 else goal_tree\n            tree_b = goal_tree if it % 2 == 0 else start_tree\n\n            sample = sample_free()\n            nearest_node = nearest(tree_a, sample)\n            new_pos = steer(nearest_node.position, sample, self.step_size)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            n_nodes = len(tree_a) + 1\n            gamma = 30.0  # radius scaling coefficient\n            radius = min(self.step_size * 5.5, gamma * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim)))\n\n            near_nodes = near(tree_a, new_pos, radius)\n\n            # Select parent that minimizes cost-to-node + dist heuristic\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            min_parent = nearest_node\n            for near_node in near_nodes:\n                cost_through = near_node.cost + dist(near_node.position, new_pos)\n                if cost_through < min_cost:\n                    if not self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d):\n                        min_cost = cost_through\n                        min_parent = near_node\n\n            new_node = Node(new_pos, parent=min_parent, cost=min_cost)\n            min_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((min_parent, new_node))\n\n            # Rewire neighbors to new node if cost improves and edge collision free\n            for near_node in near_nodes:\n                if near_node == min_parent:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, near_node.position)\n                if new_cost < near_node.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                        if near_node.parent:\n                            try:\n                                edges.remove((near_node.parent, near_node))\n                            except ValueError:\n                                pass\n                            near_node.parent.remove_child(near_node)\n                        near_node.parent = new_node\n                        near_node.cost = new_cost\n                        new_node.add_child(near_node)\n                        edges.append((new_node, near_node))\n\n            # Attempt connection to other tree within adaptive radius\n            connect_radius = self.step_size * 3.2\n            conn_node, conn_cost = try_connect(new_node, tree_b, connect_radius)\n            if conn_node and conn_cost < best_cost:\n                best_cost = conn_cost\n                best_connection = (new_node, conn_node)\n                success = True\n                # Early stop for improved path\n                break\n\n            # Periodically shortcut best path if improvement found\n            if success and it % 120 == 0 and best_connection:\n                path = extract_path(best_connection[0], best_connection[1])\n                shortcut = shortcut_path(path)\n                new_length = sum(dist(shortcut[i], shortcut[i+1]) for i in range(len(shortcut)-1))\n                if new_length + 1e-5 < best_cost:\n                    best_cost = new_length\n                    extracted_path = shortcut\n                else:\n                    extracted_path = path\n\n        if success and best_connection:\n            extracted_path = extract_path(best_connection[0], best_connection[1])\n            extracted_path = shortcut_path(extracted_path)\n        else:\n            # Fallback: find best cross-tree pair and shortcut fallback path\n            best_pair = None\n            min_total_cost = float('inf')\n            for n1 in start_tree:\n                near_goal_cands = near(goal_tree, n1.position, self.step_size * 3.2)\n                for n2 in near_goal_cands:\n                    d12 = dist(n1.position, n2.position)\n                    if d12 <= self.step_size * 3.2 and not self._is_edge_in_obstacle(n1.position, n2.position, obstacles, is_3d):\n                        total_c = n1.cost + n2.cost + d12\n                        if total_c < min_total_cost:\n                            min_total_cost = total_c\n                            best_pair = (n1, n2)\n            if best_pair:\n                extracted_path = extract_path(best_pair[0], best_pair[1])\n                extracted_path = shortcut_path(extracted_path)\n                success = True\n\n        return PlannerResult(\n            success=success,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
        "objective": -27.40187,
        "time_improvement": 38.0,
        "length_improvement": 16.0,
        "smoothness_improvement": 1257.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.02119297981262207,
                "num_nodes_avg": 152.1,
                "path_length_avg": 163.87341701691048,
                "smoothness_avg": 0.04087808433626587,
                "success_improvement": 0.0,
                "time_improvement": 15.313931742246611,
                "length_improvement": 10.17838339256568,
                "smoothness_improvement": 539.830788043481,
                "objective_score": 13.400363498430796
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.057435345649719236,
                "num_nodes_avg": 355.1,
                "path_length_avg": 241.9364752247091,
                "smoothness_avg": 0.07969677886958462,
                "success_improvement": 0.0,
                "time_improvement": 64.87440590095132,
                "length_improvement": 19.23464081466865,
                "smoothness_improvement": 1950.6555235839744,
                "objective_score": 40.756383877006456
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.03343057632446289,
                "num_nodes_avg": 235.3,
                "path_length_avg": 120.76782331760107,
                "smoothness_avg": 0.10863055365717608,
                "success_improvement": 0.0,
                "time_improvement": 32.549818696791185,
                "length_improvement": 19.79176209821548,
                "smoothness_improvement": 1281.7726242458787,
                "objective_score": 28.048865989196038
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "cross_over",
        "algorithm_description": "An optimized bidirectional RRT*-based planner incorporating goal biasing, dynamic adaptive rewiring radius, efficient incremental collision checking with adaptive resolution, and iterative shortcutting for path smoothing. The algorithm uses alternating tree expansions with improved nearest neighbor searches and multiple candidate connections to accelerate convergence, maintaining a strict 30-second limit. Continuous path cost tracking and rewiring ensure near-optimal path lengths while lightweight shortcutting improves smoothness and reduces unnecessary waypoints. Early termination on time or successful path discovery guarantees computational efficiency.",
        "planning_mechanism": "The planner grows two trees from start and goal, sampling mostly free space with goal bias. It extends nodes toward samples using a fine step size, rewires nearby nodes within a dynamically shrinking neighborhood radius computed from node count and dimension, attempts multiple connection candidates between trees, and upon connection applies iterative shortcutting. Collision checks adapt resolution based on edge length for efficiency. The planner updates best path continuously and returns the best feasible path if time expires.",
        "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children: List[Node] = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=4.0, goal_sample_rate: float=0.2):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.time_limit = 30.0\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        start_tree = [Node(start_pos, cost=0.0)]\n        goal_tree = [Node(goal_pos, cost=0.0)]\n        nodes = start_tree[:] + goal_tree[:]\n        edges = []\n\n        gamma_rrt_star = 20.0  # Smaller gamma for adaptive radius to reduce neighbor overhead\n\n        success = False\n        best_cost = float('inf')\n        best_connection = None\n        extracted_path: List[Tuple[float,...]] = []\n\n        step_size = self.step_size\n\n        def dist(a, b):\n            # Euclidean distance\n            return math.dist(a, b)\n\n        def sample_free():\n            # Goal biasing sampler with max 30 attempts\n            if random.random() < self.goal_sample_rate:\n                return goal_pos\n            for _ in range(30):\n                p = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n            return goal_pos  # fallback\n\n        def nearest(tree, point):\n            min_node = None\n            min_dist = float('inf')\n            for node in tree:\n                d = dist(node.position, point)\n                if d < min_dist:\n                    min_dist = d\n                    min_node = node\n            return min_node\n\n        def near(tree, point, radius):\n            neighbors = []\n            for node in tree:\n                d = dist(node.position, point)\n                if d <= radius:\n                    neighbors.append((d, node))\n            neighbors.sort(key=lambda x: x[0])\n            return [n[1] for n in neighbors]\n\n        def steer(from_p, to_p, max_step):\n            d = dist(from_p, to_p)\n            if d <= max_step:\n                return to_p\n            ratio = max_step / d\n            return tuple(from_p[i] + (to_p[i] - from_p[i]) * ratio for i in range(dim))\n\n        def extract_path(node_start, node_goal):\n            # Trace back parents from start node to root\n            path_start = []\n            c = node_start\n            while c is not None:\n                path_start.append(c.position)\n                c = c.parent\n            # Trace back parents from goal node to root\n            path_goal = []\n            c = node_goal\n            while c is not None:\n                path_goal.append(c.position)\n                c = c.parent\n            return path_start[::-1] + path_goal\n\n        def shortcut_path(path):\n            # Iterative shortcutting tries 100 times to connect random pairs with collision-free edges\n            if len(path) < 3:\n                return path\n            for _ in range(100):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d,\n                        resolution=max(0.1,self.step_size*0.05)):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        def adaptive_edge_resolution(p1, p2):\n            # Edge collision check resolution adapts from edge length, min 0.1, max step_size/3\n            length = dist(p1, p2)\n            return max(0.1, min(self.step_size/3, length/10))\n\n        def try_connect(new_node, other_tree):\n            # Get multiple near candidates in other tree within connection radius\n            connection_radius = self.step_size * 2.5\n            candidates = near(other_tree, new_node.position, connection_radius)\n            best_node = None\n            best_cost_local = float('inf')\n            for cnode in candidates:\n                d = dist(new_node.position, cnode.position)\n                if d <= connection_radius:\n                    if not self._is_edge_in_obstacle(new_node.position, cnode.position, obstacles, is_3d,\n                                                    resolution=adaptive_edge_resolution(new_node.position,cnode.position)):\n                        total_cost = new_node.cost + cnode.cost + d\n                        if total_cost < best_cost_local:\n                            best_cost_local = total_cost\n                            best_node = cnode\n            return best_node, best_cost_local\n\n        start_time = time.monotonic()\n        for iter_count in range(self.max_iter):\n            if time.monotonic() - start_time > self.time_limit:\n                break\n\n            # Alternate tree growth\n            tree_a = start_tree if iter_count % 2 == 0 else goal_tree\n            tree_b = goal_tree if iter_count % 2 == 0 else start_tree\n\n            sample = sample_free()\n            nearest_node = nearest(tree_a, sample)\n            new_pos = steer(nearest_node.position, sample, step_size)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d,\n                                         resolution=adaptive_edge_resolution(nearest_node.position, new_pos)):\n                continue\n\n            n_nodes = len(tree_a) + 1\n            radius = min(step_size * 5, gamma_rrt_star * (math.log(n_nodes) / n_nodes) ** (1/dim))\n\n            near_nodes = near(tree_a, new_pos, radius)\n\n            # Choose best parent (minimum cost)\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            min_parent = nearest_node\n            for near_node in near_nodes:\n                cost_through = near_node.cost + dist(near_node.position, new_pos)\n                if cost_through < min_cost:\n                    if not self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d,\n                                                    resolution=adaptive_edge_resolution(near_node.position,new_pos)):\n                        min_cost = cost_through\n                        min_parent = near_node\n\n            new_node = Node(new_pos, parent=min_parent, cost=min_cost)\n            min_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((min_parent, new_node))\n\n            # Rewire neighbors with better cost paths\n            for near_node in near_nodes:\n                if near_node == min_parent:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, near_node.position)\n                if new_cost < near_node.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d,\n                                                    resolution=adaptive_edge_resolution(new_node.position, near_node.position)):\n                        # Remove old edge safely\n                        if near_node.parent:\n                            try:\n                                edges.remove((near_node.parent, near_node))\n                            except ValueError:\n                                pass\n                            near_node.parent.remove_child(near_node)\n                        near_node.parent = new_node\n                        near_node.cost = new_cost\n                        new_node.add_child(near_node)\n                        edges.append((new_node, near_node))\n\n            # Attempt multiple candidate connection to other tree\n            conn_node, conn_cost = try_connect(new_node, tree_b)\n            if conn_node and conn_cost < best_cost:\n                best_cost = conn_cost\n                best_connection = (new_node, conn_node)\n                success = True\n                # Early stopping here for efficiency\n                break\n\n        if success and best_connection is not None:\n            path = extract_path(best_connection[0], best_connection[1])\n            path = shortcut_path(path)\n            extracted_path = path\n        else:\n            # Attempt best partial connection on timeout or failure\n            min_cost = float('inf')\n            best_pair = None\n            for n1 in start_tree:\n                candidates = near(goal_tree, n1.position, step_size * 2.5)\n                for n2 in candidates:\n                    d12 = dist(n1.position, n2.position)\n                    if d12 <= step_size * 2.5:\n                        if not self._is_edge_in_obstacle(n1.position, n2.position, obstacles, is_3d,\n                                                        resolution=adaptive_edge_resolution(n1.position, n2.position)):\n                            total_cost = n1.cost + n2.cost + d12\n                            if total_cost < min_cost:\n                                min_cost = total_cost\n                                best_pair = (n1, n2)\n            if best_pair is not None:\n                path = extract_path(best_pair[0], best_pair[1])\n                path = shortcut_path(path)\n                extracted_path = path\n                success = True\n\n        return PlannerResult(\n            success=success,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
        "objective": -21.99245,
        "time_improvement": 20.0,
        "length_improvement": 14.0,
        "smoothness_improvement": 1523.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.03138778209686279,
                "num_nodes_avg": 163.2,
                "path_length_avg": 167.21015564949224,
                "smoothness_avg": 0.04103033539568809,
                "success_improvement": 0.0,
                "time_improvement": -25.423979101386283,
                "length_improvement": 8.349464074040423,
                "smoothness_improvement": 542.213847741906,
                "objective_score": 0.09355395271789968
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.053638553619384764,
                "num_nodes_avg": 436.8,
                "path_length_avg": 246.5065194564645,
                "smoothness_avg": 0.10805898201144767,
                "success_improvement": 0.0,
                "time_improvement": 67.19640073231147,
                "length_improvement": 17.709028508679005,
                "smoothness_improvement": 2680.435438893309,
                "objective_score": 44.18651451936739
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.040125346183776854,
                "num_nodes_avg": 359.0,
                "path_length_avg": 127.36695570951193,
                "smoothness_avg": 0.11382510858983455,
                "success_improvement": 0.0,
                "time_improvement": 19.042320758038862,
                "length_improvement": 15.40893258042441,
                "smoothness_improvement": 1347.8469795671333,
                "objective_score": 21.69729067350197
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "m3",
        "algorithm_description": "Simplified bidirectional RRT* with adaptive radius and early termination under strict time limit, emphasizing efficient incremental rewiring for path quality and smoothness without complex data structures. It grows two trees alternately, samples with goal bias, connects trees on proximity, and returns the best discovered path promptly.",
        "planning_mechanism": "The planner grows two RRT* trees from start and goal, alternating expansions each iteration. It samples points biasing toward start or goal, steers new nodes with fixed step size, verifies collision-free extension, and rewires neighbors within an adaptive radius that shrinks logarithmically as the tree grows to incrementally improve path cost. When a connection between trees is found, it extracts the combined path, updating best path cost and enabling early stopping on timeout or success. The design avoids complex k-d tree structures favoring simplicity and clear data coherence for robust performance and smooth paths.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n    def add_child(self, child):\n        self.children.append(child)\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\nclass Planner:\n    def __init__(self, max_iter: int=10000, step_size: float=4.5, goal_sample_rate: float=0.2):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.time_limit = 30.0\n\n    def plan(self, map) -> 'PlannerResult':\n        import time, math, random\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = dim == 3\n\n        def dist(a,b): return math.dist(a,b)\n\n        def steer(from_p, to_p, max_step):\n            d = dist(from_p, to_p)\n            if d <= max_step:\n                return to_p\n            ratio = max_step/d\n            return tuple(from_p[i] + ratio*(to_p[i]-from_p[i]) for i in range(dim))\n\n        def in_obstacle(p):\n            for o in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d_ = o\n                    px,py,pz = p\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d_:\n                        return True\n                else:\n                    x,y,w,h = o\n                    px,py = p\n                    if x <= px <= x+w and y <= py <= y+h:\n                        return True\n            return False\n\n        def edge_in_obstacle(a,b, resolution=1.0):\n            length = dist(a,b)\n            steps = max(1,int(length/resolution))\n            for i in range(steps+1):\n                interp = tuple(a[d] + (b[d]-a[d])*(i/steps) for d in range(dim))\n                if in_obstacle(interp):\n                    return True\n            return False\n\n        def extract_path(node_start, node_goal):\n            path_start = []\n            cur = node_start\n            while cur:\n                path_start.append(cur.position)\n                cur = cur.parent\n            path_goal = []\n            cur = node_goal\n            while cur:\n                path_goal.append(cur.position)\n                cur = cur.parent\n            return path_start[::-1] + path_goal\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes_all = start_tree + goal_tree\n        edges = []\n\n        best_cost = float('inf')\n        best_pair = None\n        best_path = []\n        start_time = time.monotonic()\n        success = False\n\n        def rewire(tree, new_node, radius):\n            for node in tree:\n                if node == new_node.parent:\n                    continue\n                if dist(node.position, new_node.position) <= radius:\n                    if not edge_in_obstacle(node.position, new_node.position):\n                        new_cost = new_node.cost + dist(new_node.position, node.position)\n                        if new_cost < node.cost:\n                            node.update_parent(new_node, new_cost)\n\n        for iter in range(self.max_iter):\n            if time.monotonic() - start_time > self.time_limit:\n                break\n\n            # Alternate trees\n            tree_a, tree_b = (start_tree, goal_tree) if iter % 2 == 0 else (goal_tree, start_tree)\n\n            # Sample point with goal bias\n            if random.random() < self.goal_sample_rate:\n                sample = goal_pos if tree_a is start_tree else start_pos\n            else:\n                sample = tuple(random.uniform(0,bounds[i]) for i in range(dim))\n            if in_obstacle(sample):\n                continue\n\n            # Find nearest node in tree_a\n            nearest_node = min(tree_a, key=lambda n: dist(n.position, sample))\n\n            new_pos = steer(nearest_node.position, sample, self.step_size)\n            if in_obstacle(new_pos) or edge_in_obstacle(nearest_node.position, new_pos):\n                continue\n\n            new_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            new_node = Node(new_pos, nearest_node, new_cost)\n            nearest_node.add_child(new_node)\n            tree_a.append(new_node)\n            nodes_all.append(new_node)\n            edges.append((nearest_node, new_node))\n\n            n = len(tree_a)\n            if n > 1:\n                radius = min(self.step_size*10, 50.0*(math.log(n)/n)**(1/dim))\n            else:\n                radius = self.step_size*10\n\n            rewire(tree_a, new_node, radius)\n\n            # Attempt connect to nearest in tree_b\n            nearest_b = min(tree_b, key=lambda n: dist(n.position, new_node.position))\n            d_connect = dist(new_node.position, nearest_b.position)\n            if d_connect <= radius and not edge_in_obstacle(new_node.position, nearest_b.position):\n                candidate_cost = new_node.cost + nearest_b.cost + d_connect\n                if candidate_cost < best_cost:\n                    best_cost = candidate_cost\n                    best_pair = (new_node, nearest_b)\n                    best_path = extract_path(new_node, nearest_b)\n                    success = True\n                    # Early stop if time permits\n                    if time.monotonic() - start_time < self.time_limit:\n                        break\n\n        if not success and best_pair:\n            success = True\n            best_path = extract_path(best_pair[0], best_pair[1])\n\n        return PlannerResult(\n            success=success,\n            path=best_path,\n            nodes=nodes_all,\n            edges=edges\n        )",
        "objective": -4.80217,
        "time_improvement": 11.0,
        "length_improvement": 2.0,
        "smoothness_improvement": 80.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.025905537605285644,
                "num_nodes_avg": 103.2,
                "path_length_avg": 186.43443865140586,
                "smoothness_avg": 0.011215328160971866,
                "success_improvement": 0.0,
                "time_improvement": -3.517209250037397,
                "length_improvement": -2.1876700675666534,
                "smoothness_improvement": 75.54424019411815,
                "objective_score": -1.99004361458062
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.042244887351989745,
                "num_nodes_avg": 293.0,
                "path_length_avg": 289.89229641294116,
                "smoothness_avg": 0.007194548032517685,
                "success_improvement": 0.0,
                "time_improvement": 74.16439739153408,
                "length_improvement": 3.225607370258463,
                "smoothness_improvement": 85.1209029001689,
                "objective_score": 24.610288154116144
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.06879181861877441,
                "num_nodes_avg": 414.5,
                "path_length_avg": 142.9655454944509,
                "smoothness_avg": 0.014080566196035505,
                "success_improvement": 0.0,
                "time_improvement": -38.795711835169456,
                "length_improvement": 5.049091970294054,
                "smoothness_improvement": 79.1037626942862,
                "objective_score": -8.213739554902972
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "m1",
        "algorithm_description": "An enhanced bidirectional RRT* planner with adaptive neighborhood radius, efficient rewiring, improved goal bias, and periodic path shortcutting to optimize planning time, path length, and smoothness within a strict time limit. It alternates expanding two trees from start and goal with dynamic radius scaling based on tree size, performs cost-based rewiring, tries multiple candidate connections per iteration with early termination on improvement, and continuously refines the best path through shortcutting.",
        "planning_mechanism": "A bidirectional RRT* alternates tree expansions with adaptive neighborhood search and rewiring radius based on logarithmic scaling of the number of nodes and problem dimension. Sampling uses enhanced goal bias to accelerate convergence. Connecting the two trees employs multi-candidate cost-based edge selection. The algorithm interrupts early after strong improvements or after a 30-second time budget, returning the best path found. Periodic shortcutting improves smoothness and shortens paths incrementally, avoiding excessive computation while maintaining high-quality solutions.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\nclass Planner:\n    def __init__(self, max_iter: int = 6000, step_size: float = 4.5, goal_sample_rate: float = 0.20):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.time_limit = 30.0  # Hard time limit in seconds\n\n    def plan(self, map):\n        import time\n        import math\n        import random\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        gamma_rrt_star = 30.0  # Radius coefficient tuned for improved smoothness\n\n        start_tree = [Node(start_pos, cost=0.0)]\n        goal_tree = [Node(goal_pos, cost=0.0)]\n        nodes = start_tree[:] + goal_tree[:]\n        edges = []\n\n        best_connection = None\n        best_cost = float('inf')\n        success = False\n        found_improvement = False\n\n        start_time = time.monotonic()\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def sample_free():\n            # Enhanced goal bias with moderate attempts for efficiency\n            if random.random() < self.goal_sample_rate:\n                return goal_pos\n            for _ in range(30):\n                p = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n            return goal_pos  # Fallback if no free point found\n\n        def nearest(tree, point):\n            best_node = None\n            best_dist = float('inf')\n            for node in tree:\n                d = dist(node.position, point)\n                if d < best_dist:\n                    best_node = node\n                    best_dist = d\n            return best_node\n\n        def near(tree, point, radius):\n            radius_sq = radius * radius\n            neighbors = []\n            for node in tree:\n                # squared distance for efficiency\n                sq_dist = 0.0\n                for i in range(dim):\n                    diff = node.position[i] - point[i]\n                    sq_dist += diff * diff\n                    if sq_dist > radius_sq:\n                        break\n                if sq_dist <= radius_sq:\n                    neighbors.append((sq_dist, node))\n            neighbors.sort(key=lambda x: x[0])\n            return [nd[1] for nd in neighbors]\n\n        def steer(from_p, to_p, max_step):\n            d = dist(from_p, to_p)\n            if d <= max_step:\n                return to_p\n            ratio = max_step / d\n            return tuple(from_p[i] + (to_p[i] - from_p[i]) * ratio for i in range(dim))\n\n        def extract_path(node_start, node_goal):\n            path_start = []\n            cur = node_start\n            while cur is not None:\n                path_start.append(cur.position)\n                cur = cur.parent\n            path_goal = []\n            cur = node_goal\n            while cur is not None:\n                path_goal.append(cur.position)\n                cur = cur.parent\n            return path_start[::-1] + path_goal\n\n        def shortcut_path(path):\n            max_attempts = 80\n            if len(path) < 3:\n                return path\n            for _ in range(max_attempts):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        def try_connect(node, other_tree, radius):\n            candidates = near(other_tree, node.position, radius)\n            best_node = None\n            best_cost_local = float('inf')\n            for cnode in candidates:\n                d = dist(node.position, cnode.position)\n                if d <= radius and not self._is_edge_in_obstacle(node.position, cnode.position, obstacles, is_3d):\n                    total_cost = node.cost + cnode.cost + d\n                    if total_cost < best_cost_local:\n                        best_cost_local = total_cost\n                        best_node = cnode\n            return best_node, best_cost_local\n\n        for it in range(self.max_iter):\n            current_time = time.monotonic()\n            if current_time - start_time > self.time_limit:\n                break\n\n            # Alternate expansion\n            if it % 2 == 0:\n                tree_a, tree_b = start_tree, goal_tree\n            else:\n                tree_a, tree_b = goal_tree, start_tree\n\n            sample = sample_free()\n            nearest_node = nearest(tree_a, sample)\n            new_pos = steer(nearest_node.position, sample, self.step_size)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            n_nodes = len(tree_a) + 1\n            radius = min(self.step_size * 4.5, gamma_rrt_star * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim)))\n\n            near_nodes = near(tree_a, new_pos, radius)\n\n            # Find best parent node (lowest cost)\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            min_parent = nearest_node\n            for near_node in near_nodes:\n                cost_through = near_node.cost + dist(near_node.position, new_pos)\n                if cost_through < min_cost:\n                    if not self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d):\n                        min_cost = cost_through\n                        min_parent = near_node\n\n            new_node = Node(new_pos, parent=min_parent, cost=min_cost)\n            min_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((min_parent, new_node))\n\n            # Rewire neighbors incrementally\n            for near_node in near_nodes:\n                if near_node is min_parent:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, near_node.position)\n                if new_cost < near_node.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                        if near_node.parent:\n                            try:\n                                edges.remove((near_node.parent, near_node))\n                            except ValueError:\n                                pass\n                            near_node.parent.remove_child(near_node)\n                        near_node.parent = new_node\n                        near_node.cost = new_cost\n                        new_node.add_child(near_node)\n                        edges.append((new_node, near_node))\n\n            # Attempt multi-candidate tree connection\n            connect_radius = self.step_size * 3.2\n            conn_node, conn_cost = try_connect(new_node, tree_b, connect_radius)\n            if conn_node is not None and conn_cost < best_cost:\n                best_cost = conn_cost\n                best_connection = (new_node, conn_node)\n                success = True\n                found_improvement = True\n                # Early stop on improvement\n                break\n\n            # Periodic path shortcutting to improve smoothness & length\n            if found_improvement and (it % 120 == 0) and best_connection is not None:\n                path = extract_path(best_connection[0], best_connection[1])\n                shortcut = shortcut_path(path)\n                shortcut_len = sum(dist(shortcut[i], shortcut[i + 1]) for i in range(len(shortcut) - 1))\n                if shortcut_len + 1e-5 < best_cost:\n                    best_cost = shortcut_len\n                    extracted_path = shortcut\n                else:\n                    extracted_path = path\n\n        # Final path extraction and shortcutting if success\n        if success and best_connection is not None:\n            path = extract_path(best_connection[0], best_connection[1])\n            extracted_path = shortcut_path(path)\n        else:\n            # Fallback: find best pair bridging trees if no direct connection found\n            best_pair = None\n            min_total_cost = float('inf')\n            for n1 in start_tree:\n                near_goal_candidates = near(goal_tree, n1.position, self.step_size * 3.2)\n                for n2 in near_goal_candidates:\n                    d12 = dist(n1.position, n2.position)\n                    if d12 <= self.step_size * 3.2 and not self._is_edge_in_obstacle(n1.position, n2.position, obstacles, is_3d):\n                        total_c = n1.cost + n2.cost + d12\n                        if total_c < min_total_cost:\n                            min_total_cost = total_c\n                            best_pair = (n1, n2)\n            if best_pair:\n                path = extract_path(best_pair[0], best_pair[1])\n                extracted_path = shortcut_path(path)\n                success = True\n            else:\n                extracted_path = []\n\n        return PlannerResult(\n            success=success,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
        "objective": -33.36919,
        "time_improvement": 57.0,
        "length_improvement": 15.0,
        "smoothness_improvement": 1442.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.014020967483520507,
                "num_nodes_avg": 122.0,
                "path_length_avg": 168.85621197856955,
                "smoothness_avg": 0.04592179710711396,
                "success_improvement": 0.0,
                "time_improvement": 43.972927835189054,
                "length_improvement": 7.44723451664146,
                "smoothness_improvement": 618.7758455048379,
                "objective_score": 20.754098288065784
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.039501094818115236,
                "num_nodes_avg": 363.8,
                "path_length_avg": 236.27330058206434,
                "smoothness_avg": 0.10265783372398023,
                "success_improvement": 0.0,
                "time_improvement": 75.84241189195431,
                "length_improvement": 21.125171515827486,
                "smoothness_improvement": 2541.460003166907,
                "objective_score": 48.13512649291732
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.02402009963989258,
                "num_nodes_avg": 264.6,
                "path_length_avg": 125.65554175248053,
                "smoothness_avg": 0.09952911323688463,
                "success_improvement": 0.0,
                "time_improvement": 51.53657956993282,
                "length_improvement": 16.545572241909497,
                "smoothness_improvement": 1166.002973898222,
                "objective_score": 31.21833208561665
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "time_expert",
        "algorithm_description": "A bidirectional RRT* planner with adaptive neighborhood radius, efficient rewiring, and early stopping to minimize planning time and improve path quality. It grows two trees from start and goal by sampling free space, steering towards samples with fixed step size, and rewiring a shrinking neighborhood for path cost optimization. The planner attempts tree connection after each extension and returns the best path found within a 30-second limit.",
        "planning_mechanism": "A bidirectional RRT* planner alternates growing two trees by sampling, nearest node selection, steering, collision checks, and cost-based rewiring within an adaptively shrinking radius. It tries connecting the two trees whenever a new node is added, stopping early on the first improved connection. The adaptive radius balances exploration and efficient rewiring, reducing overhead and improving solution quality over time.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n        import time\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = start_tree[:] + goal_tree[:]\n        edges = []\n\n        success = False\n        best_cost = float('inf')\n        best_connect = None\n\n        start_time = time.monotonic()\n        TIME_LIMIT = 30.0\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def sample_free():\n            for _ in range(30):\n                p = tuple(random.uniform(0, bounds[i]) for i in range(len(bounds)))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n            # fallback: return start or goal to prevent infinite loop (rare)\n            return start_pos\n\n        def nearest(tree, point):\n            # Linear search; for improvement, can be replaced with spatial index\n            best_node = None\n            best_dist = float('inf')\n            for n in tree:\n                d = dist(n.position, point)\n                if d < best_dist:\n                    best_dist = d\n                    best_node = n\n            return best_node\n\n        def near(tree, point, radius):\n            r_sq = radius * radius\n            return [n for n in tree if (n.position[0] - point[0]) ** 2 + (n.position[1] - point[1]) ** 2 <= r_sq] if not is_3d else \\\n                   [n for n in tree if sum((n.position[i] - point[i]) ** 2 for i in range(3)) <= r_sq]\n\n        def steer(from_p, to_p, step):\n            d = dist(from_p, to_p)\n            if d <= step:\n                return to_p\n            ratio = step / d\n            return tuple(from_p[i] + (to_p[i] - from_p[i]) * ratio for i in range(len(from_p)))\n\n        def extract_path(n_start, n_goal):\n            path_start = []\n            curr = n_start\n            while curr is not None:\n                path_start.append(curr.position)\n                curr = curr.parent\n            path_goal = []\n            curr = n_goal\n            while curr is not None:\n                path_goal.append(curr.position)\n                curr = curr.parent\n            # Reverse start path and append goal path (connecting at the connecting edge)\n            return path_start[::-1] + path_goal\n\n        def cost_to_reach(node):\n            return node.cost\n\n        def try_rewire(new_node, neighbors, tree, obstacles, is_3d):\n            changed = False\n            for near_node in neighbors:\n                if near_node is new_node.parent:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, near_node.position)\n                if new_cost + 1e-9 < near_node.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                        # Rewire near_node\n                        if near_node.parent:\n                            try:\n                                edges.remove((near_node.parent, near_node))\n                            except ValueError:\n                                pass\n                            if near_node in near_node.parent.children:\n                                near_node.parent.children.remove(near_node)\n                        near_node.parent = new_node\n                        near_node.cost = new_cost\n                        new_node.add_child(near_node)\n                        edges.append((new_node, near_node))\n                        changed = True\n            return changed\n\n        def add_node(tree, new_node):\n            tree.append(new_node)\n            nodes.append(new_node)\n\n        gamma = 30.0\n        dim = len(bounds)\n\n        for iter_count in range(self.max_iter):\n            now = time.monotonic()\n            if now - start_time > TIME_LIMIT:\n                break\n\n            # Alternate tree growth\n            tree_a = start_tree if iter_count % 2 == 0 else goal_tree\n            tree_b = goal_tree if iter_count % 2 == 0 else start_tree\n\n            rnd = sample_free()\n\n            nearest_node = nearest(tree_a, rnd)\n            new_pos = steer(nearest_node.position, rnd, self.step_size)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            n_nodes = len(tree_a) + 1\n            radius = min(self.step_size * 5, gamma * (math.log(max(n_nodes, 2)) / n_nodes) ** (1 / dim))\n\n            near_nodes = near(tree_a, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            min_parent = nearest_node\n            for near_node in near_nodes:\n                cost_through = near_node.cost + dist(near_node.position, new_pos)\n                if cost_through + 1e-9 < min_cost:\n                    if not self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d):\n                        min_cost = cost_through\n                        min_parent = near_node\n\n            new_node = Node(new_pos, parent=min_parent, cost=min_cost)\n            min_parent.add_child(new_node)\n            add_node(tree_a, new_node)\n            edges.append((min_parent, new_node))\n\n            try_rewire(new_node, near_nodes, tree_a, obstacles, is_3d)\n\n            # Try connecting other tree near new_node\n            nearest_in_other = nearest(tree_b, new_node.position)\n            dist_connect = dist(new_node.position, nearest_in_other.position)\n            if dist_connect <= self.step_size:\n                if not self._is_edge_in_obstacle(new_node.position, nearest_in_other.position, obstacles, is_3d):\n                    total_cost = new_node.cost + nearest_in_other.cost + dist_connect\n                    if total_cost + 1e-9 < best_cost:\n                        best_cost = total_cost\n                        best_connect = (new_node, nearest_in_other)\n                        success = True\n                        # Early stop on first good solution to reduce planning time\n                        break\n\n        # Extract best path if found\n        if success and best_connect is not None:\n            extracted_path = extract_path(best_connect[0], best_connect[1])\n        else:\n            # No direct connection found in time, try minimal-cost pair and path extraction\n            min_cost_est = float('inf')\n            best_pair = None\n            for n1 in start_tree:\n                n2 = nearest(goal_tree, n1.position)\n                d12 = dist(n1.position, n2.position)\n                if d12 <= self.step_size:\n                    if not self._is_edge_in_obstacle(n1.position, n2.position, obstacles, is_3d):\n                        cost_sum = n1.cost + n2.cost + d12\n                        if cost_sum + 1e-9 < min_cost_est:\n                            min_cost_est = cost_sum\n                            best_pair = (n1, n2)\n            if best_pair is not None:\n                extracted_path = extract_path(best_pair[0], best_pair[1])\n                success = True\n            else:\n                extracted_path = []\n\n        return PlannerResult(\n            success=success,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
        "objective": -27.32825,
        "time_improvement": 72.0,
        "length_improvement": 8.0,
        "smoothness_improvement": 142.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.011930179595947266,
                "num_nodes_avg": 135.2,
                "path_length_avg": 171.34059103033889,
                "smoothness_avg": 0.01642005874301497,
                "success_improvement": 0.0,
                "time_improvement": 52.327609778218985,
                "length_improvement": 6.085506990861369,
                "smoothness_improvement": 157.00957605645047,
                "objective_score": 20.13463500826477
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.01886107921600342,
                "num_nodes_avg": 282.1,
                "path_length_avg": 270.38122584620703,
                "smoothness_avg": 0.008398311675666579,
                "success_improvement": 0.0,
                "time_improvement": 88.4651758369878,
                "length_improvement": 9.738964320462099,
                "smoothness_improvement": 116.09460847429625,
                "objective_score": 32.96340438574508
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.012389254570007325,
                "num_nodes_avg": 219.8,
                "path_length_avg": 136.44974335966273,
                "smoothness_avg": 0.019808586046500164,
                "success_improvement": 0.0,
                "time_improvement": 75.00319890246378,
                "length_improvement": 9.376577499064672,
                "smoothness_improvement": 151.9637523937513,
                "objective_score": 28.88672493214669
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "m3",
        "algorithm_description": "This algorithm implements a simplified bidirectional RRT* planner featuring adaptive neighborhood rewiring with logarithmic radius scaling and early stopping upon path connection. It alternates expansions from start and goal trees, samples free points with goal biasing, and uses direct nearest neighbor search for simplicity. Collision checks are enforced on nodes and edges, and the best path found so far is returned when time expires or a solution is found. The rewire step improves path length and smoothness without complex data structures, balancing performance and solution quality.",
        "planning_mechanism": "The planner grows two trees alternately from start and goal positions by sampling points with goal biasing, extends nearest nodes towards samples using fixed step sizes, then rewires neighbors within an adaptive radius to lower costs. Upon each new node, it tries to connect to the opposite tree. Search halts upon a successful connection or 30 seconds timeout, returning the best found path.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position            # Tuple[float, ...]\n        self.parent = parent                # Node or None\n        self.cost = cost                    # path cost from root\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is not None:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=5.0, goal_sample_rate=0.1):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.time_limit = 30.0\n\n    def plan(self, map):\n        import time\n        import math\n        import random\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w_, h_ = obs\n                    px, py = pos\n                    if x <= px <= x + w_ and y <= py <= y + h_:\n                        return True\n            return False\n\n        def edge_in_obstacle(a, b, resolution=1.0):\n            dist_ab = math.dist(a, b)\n            steps = max(1, int(dist_ab / resolution))\n            for i in range(steps + 1):\n                interp = tuple(a[d] + (b[d] - a[d]) * i / steps for d in range(dim))\n                if in_obstacle(interp):\n                    return True\n            return False\n\n        def steer(from_pos, to_pos):\n            dist_ = math.dist(from_pos, to_pos)\n            if dist_ <= self.step_size:\n                return to_pos\n            scale = self.step_size / dist_\n            return tuple(from_pos[d] + scale * (to_pos[d] - from_pos[d]) for d in range(dim))\n\n        def nearest(nodes, point):\n            # Linear search - simpler, small cost at typical iteration counts\n            best = None\n            best_dist = float('inf')\n            for node in nodes:\n                d = math.dist(node.position, point)\n                if d < best_dist:\n                    best = node\n                    best_dist = d\n            return best\n\n        def radius_neighbor(nodes, point, radius):\n            neighbors = []\n            r2 = radius*radius\n            for node in nodes:\n                # squared distance for efficiency\n                sq_dist = 0.0\n                for i in range(dim):\n                    diff = node.position[i] - point[i]\n                    sq_dist += diff*diff\n                    if sq_dist > r2:\n                        break\n                else:\n                    neighbors.append(node)\n            return neighbors\n\n        def extract_path(node_start, node_goal):\n            path_start = []\n            cur = node_start\n            while cur is not None:\n                path_start.append(cur.position)\n                cur = cur.parent\n            path_goal = []\n            cur = node_goal\n            while cur is not None:\n                path_goal.append(cur.position)\n                cur = cur.parent\n            return path_start[::-1] + path_goal\n\n        def propagate_cost_to_children(node):\n            for c in node.children:\n                new_cost = node.cost + math.dist(node.position, c.position)\n                if new_cost + 1e-9 < c.cost:  # small tolerance to prevent oscillations\n                    c.update_parent(node, new_cost)\n                    propagate_cost_to_children(c)\n\n        def rewire(tree_nodes, new_node):\n            n_nodes = max(len(tree_nodes), 2)  # avoid zero or one for log\n            gamma = 2 * (1 + 1/dim)**(1/dim) * ( (20.0**dim / math.pi)**(1/dim) )  # constant factor\n            radius = min(self.step_size * 10, gamma * ((math.log(n_nodes) / n_nodes)**(1/dim)) )\n            neighbors = radius_neighbor(tree_nodes, new_node.position, radius)\n            for nbr in neighbors:\n                if nbr is new_node.parent:\n                    continue\n                if not edge_in_obstacle(new_node.position, nbr.position):\n                    potential_cost = new_node.cost + math.dist(new_node.position, nbr.position)\n                    if potential_cost + 1e-9 < nbr.cost:\n                        nbr.update_parent(new_node, potential_cost)\n                        propagate_cost_to_children(nbr)\n\n        start_tree = [Node(start_pos, cost=0.0)]\n        goal_tree = [Node(goal_pos, cost=0.0)]\n        all_nodes = start_tree + goal_tree\n        edges = []\n\n        best_cost = float('inf')\n        best_pair = None\n        success = False\n        result_path = []\n\n        start_time = time.monotonic()\n\n        for i in range(self.max_iter):\n            if time.monotonic() - start_time > self.time_limit:\n                break\n\n            tree_a, tree_b = (start_tree, goal_tree) if i % 2 == 0 else (goal_tree, start_tree)\n\n            if random.random() < self.goal_sample_rate:\n                sample = goal_pos if tree_a is start_tree else start_pos\n            else:\n                # Sample free with limited retries\n                sample = None\n                for _ in range(30):\n                    s = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not in_obstacle(s):\n                        sample = s\n                        break\n                if sample is None:\n                    continue\n\n            nearest_node = nearest(tree_a, sample)\n            if nearest_node is None:\n                continue\n\n            new_pos = steer(nearest_node.position, sample)\n            if in_obstacle(new_pos):\n                continue\n            if edge_in_obstacle(nearest_node.position, new_pos):\n                continue\n\n            new_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            new_node = Node(new_pos, nearest_node, new_cost)\n            nearest_node.add_child(new_node)\n            tree_a.append(new_node)\n            all_nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n\n            rewire(tree_a, new_node)\n\n            nearest_other = nearest(tree_b, new_pos)\n            if nearest_other is not None:\n                if not edge_in_obstacle(new_pos, nearest_other.position):\n                    total_cost = new_node.cost + nearest_other.cost + math.dist(new_pos, nearest_other.position)\n                    if total_cost + 1e-9 < best_cost:\n                        best_cost = total_cost\n                        best_pair = (new_node, nearest_other)\n                        edges.append((new_node, nearest_other))\n                        result_path = extract_path(new_node, nearest_other)\n                        success = True\n                        break\n\n        if not success and best_pair is not None:\n            result_path = extract_path(best_pair[0], best_pair[1])\n            success = True\n\n        return PlannerResult(\n            success=success,\n            path=result_path,\n            nodes=all_nodes,\n            edges=edges\n        )",
        "objective": -18.77815,
        "time_improvement": 61.0,
        "length_improvement": 0.0,
        "smoothness_improvement": 88.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.014551639556884766,
                "num_nodes_avg": 100.5,
                "path_length_avg": 180.47607122089238,
                "smoothness_avg": 0.011967746098343867,
                "success_improvement": 0.0,
                "time_improvement": 41.852389250018334,
                "length_improvement": 1.0782055374717003,
                "smoothness_improvement": 87.32121481569246,
                "objective_score": 13.639246171566983
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.02003800868988037,
                "num_nodes_avg": 233.7,
                "path_length_avg": 296.6714701762844,
                "smoothness_avg": 0.007355894941360163,
                "success_improvement": 0.0,
                "time_improvement": 87.74540395235893,
                "length_improvement": 0.9625240403568615,
                "smoothness_improvement": 89.27247507816692,
                "objective_score": 27.347497985312625
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.0231964111328125,
                "num_nodes_avg": 258.0,
                "path_length_avg": 153.18908240188344,
                "smoothness_avg": 0.014665091071115782,
                "success_improvement": 0.0,
                "time_improvement": 53.19846952961221,
                "length_improvement": -1.740894451109899,
                "smoothness_improvement": 86.53887596016907,
                "objective_score": 15.347698568018568
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "time_expert",
        "algorithm_description": "This algorithm implements an adaptive bidirectional RRT* planner that efficiently alternates growth between start and goal trees, using goal bias sampling, dynamically shrinking rewiring radius based on tree size and problem dimension, and fast squared-distance computations. It enforces strict collision checks for nodes and edges, employs limited retries to avoid excessive sampling attempts, and performs periodic shortcutting to smooth and shorten the path. Early stopping is triggered upon finding improved solutions for reduced runtime. The algorithm respects a 30-second wall-clock time limit, returning the best path found so far.",
        "planning_mechanism": "The planner alternates growing start and goal trees by sampling with goal bias, extends nearest nodes toward samples using fixed step sizes, rewires neighbors within an adaptively calculated radius to minimize path cost, tries to connect the two trees upon adding new nodes, and periodically applies shortcutting to smooth the path. Sampling is retried up to a fixed number of attempts to avoid delays. The search stops early once a better connection is found or if time expires, and the best path is extracted from the connected nodes.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position       # Tuple[float, ...]\n        self.parent = parent           # Node or None\n        self.cost = cost               # Cost from start (or tree root)\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = 0.1    # Probability to sample goal\n        self.max_sample_attempts = 30  # Max tries to sample free point\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = start_tree[:] + goal_tree[:]\n        edges = []\n\n        success = False\n        best_cost = float('inf')\n        best_connection = None\n\n        start_time = time.monotonic()\n        TIME_LIMIT = 30.0\n        step = self.step_size\n\n        def dist_sq(a, b):\n            return sum((a[i] - b[i])**2 for i in range(dim))\n\n        def dist(a, b):\n            return math.sqrt(dist_sq(a, b))\n\n        def sample_free():\n            for _ in range(self.max_sample_attempts):\n                if random.random() < self.goal_sample_rate:\n                    if not self._is_in_obstacle(goal_pos, obstacles, is_3d):\n                        return goal_pos\n                p = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n            # Fallback: sample center of map if no free sample found\n            fallback = tuple(b/2 for b in bounds)\n            if not self._is_in_obstacle(fallback, obstacles, is_3d):\n                return fallback\n            # Otherwise just return goal (risky but fallback)\n            return goal_pos\n\n        def nearest(tree, point):\n            # Return node with min dist squared\n            best = None\n            best_d = float('inf')\n            for node in tree:\n                d = dist_sq(node.position, point)\n                if d < best_d:\n                    best = node\n                    best_d = d\n            return best\n\n        def near(tree, point, radius):\n            radius_sq = radius * radius\n            return [node for node in tree if dist_sq(node.position, point) <= radius_sq]\n\n        def steer(from_p, to_p, step_sz):\n            d = dist(from_p, to_p)\n            if d <= step_sz:\n                return to_p\n            ratio = step_sz / d\n            return tuple(from_p[i] + (to_p[i] - from_p[i]) * ratio for i in range(dim))\n\n        def can_connect(a, b):\n            # Check node collision\n            if self._is_in_obstacle(b, obstacles, is_3d):\n                return False\n            # Edge collision\n            if self._is_edge_in_obstacle(a, b, obstacles, is_3d, resolution=step/5):\n                return False\n            return True\n\n        def extract_path(node_start, node_goal):\n            path_start = []\n            cur = node_start\n            while cur:\n                path_start.append(cur.position)\n                cur = cur.parent\n            path_goal = []\n            cur = node_goal\n            while cur:\n                path_goal.append(cur.position)\n                cur = cur.parent\n            return path_start[::-1] + path_goal\n\n        def shortcut_path(path):\n            if len(path) <= 2:\n                return path\n            new_path = [path[0]]\n            i = 0\n            while i < len(path)-1:\n                j = len(path)-1\n                while j > i+1:\n                    if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d, resolution=step/10):\n                        break\n                    j -= 1\n                new_path.append(path[j])\n                i = j\n            return new_path\n\n        def rewire(tree, new_node, near_nodes):\n            for near_node in near_nodes:\n                if near_node is new_node.parent:\n                    continue\n                dist_new_to_near = dist(new_node.position, near_node.position)\n                new_cost = new_node.cost + dist_new_to_near\n                if new_cost + 1e-9 < near_node.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d, resolution=step/5):\n                        # Remove old edge if any\n                        if near_node.parent:\n                            try:\n                                edges.remove((near_node.parent, near_node))\n                                near_node.parent.children.remove(near_node)\n                            except Exception:\n                                pass\n                        near_node.parent = new_node\n                        near_node.cost = new_cost\n                        new_node.add_child(near_node)\n                        edges.append((new_node, near_node))\n\n        iteration = 0\n        last_improvement_time = start_time\n\n        while iteration < self.max_iter:\n            iteration += 1\n            current_time = time.monotonic()\n            if current_time - start_time > TIME_LIMIT:\n                break\n\n            # Alternate trees\n            tree_a = start_tree if iteration % 2 == 0 else goal_tree\n            tree_b = goal_tree if iteration % 2 == 0 else start_tree\n\n            sample = sample_free()\n\n            nearest_node = nearest(tree_a, sample)\n            new_pos = steer(nearest_node.position, sample, step)\n            if not can_connect(nearest_node.position, new_pos):\n                continue\n\n            n_tree = len(tree_a) + 1\n            radius_gamma = 30.0\n            radius = min(step*5, radius_gamma * (math.log(max(n_tree,2)) / n_tree)**(1/dim))\n\n            near_nodes = near(tree_a, new_pos, radius)\n\n            # Choose best parent among near\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            min_parent = nearest_node\n            for near_node in near_nodes:\n                cost_through = near_node.cost + dist(near_node.position, new_pos)\n                if cost_through + 1e-9 < min_cost:\n                    if not self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d, resolution=step/5):\n                        min_cost = cost_through\n                        min_parent = near_node\n\n            new_node = Node(new_pos, parent=min_parent, cost=min_cost)\n            min_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((min_parent, new_node))\n\n            rewire(tree_a, new_node, near_nodes)\n\n            # Attempt to connect tree_b nodes near new_node within radius\n            connection_radius = radius\n            candidates = near(tree_b, new_node.position, connection_radius)\n\n            improved = False\n            for other_node in candidates:\n                dist_btw = dist(new_node.position, other_node.position)\n                if dist_btw <= step and can_connect(new_node.position, other_node.position):\n                    total_cost = new_node.cost + other_node.cost + dist_btw\n                    if total_cost + 1e-9 < best_cost:\n                        best_cost = total_cost\n                        best_connection = (new_node, other_node)\n                        success = True\n                        improved = True\n                        # Early stopping on improved path\n                        break\n            if improved:\n                break\n\n            # Periodically shortcut best path found so far to improve smoothness\n            if success and (iteration % 100 == 0 or (current_time - last_improvement_time > 3.0)):\n                path = extract_path(best_connection[0], best_connection[1])\n                path = shortcut_path(path)\n                last_improvement_time = current_time\n                # Update best path by reconnecting nodes on the shortcut path is skipped (no tree change)\n                extracted_path = path\n\n        # Extract final path if found\n        if success and best_connection is not None:\n            path = extract_path(best_connection[0], best_connection[1])\n            path = shortcut_path(path)\n            extracted_path = path\n        else:\n            # Try best partial connection if no full success\n            best_partial_cost = float('inf')\n            best_pair = None\n            for n1 in start_tree:\n                candidate_nodes = near(goal_tree, n1.position, step)\n                for n2 in candidate_nodes:\n                    if can_connect(n1.position, n2.position):\n                        cost_sum = n1.cost + n2.cost + dist(n1.position, n2.position)\n                        if cost_sum < best_partial_cost:\n                            best_partial_cost = cost_sum\n                            best_pair = (n1, n2)\n            if best_pair:\n                path = extract_path(best_pair[0], best_pair[1])\n                path = shortcut_path(path)\n                extracted_path = path\n                success = True\n\n        return PlannerResult(\n            success=success,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
        "objective": -19.61827,
        "time_improvement": 7.0,
        "length_improvement": 13.0,
        "smoothness_improvement": 1889.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.04089529514312744,
                "num_nodes_avg": 172.9,
                "path_length_avg": 173.05249817668198,
                "smoothness_avg": 0.0483909382268577,
                "success_improvement": 0.0,
                "time_improvement": -63.41551714446586,
                "length_improvement": 5.147183557046054,
                "smoothness_improvement": 657.423265854588,
                "objective_score": -12.649228679839187
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.0705744743347168,
                "num_nodes_avg": 306.1,
                "path_length_avg": 238.60531980912498,
                "smoothness_avg": 0.12771648262552357,
                "success_improvement": 0.0,
                "time_improvement": 56.83894105289312,
                "length_improvement": 20.34667637438295,
                "smoothness_improvement": 3186.237088418874,
                "objective_score": 45.190873582592076
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.035701656341552736,
                "num_nodes_avg": 210.4,
                "path_length_avg": 128.45622431239354,
                "smoothness_avg": 0.1511263515170401,
                "success_improvement": 0.0,
                "time_improvement": 27.967643462357326,
                "length_improvement": 14.68549223978742,
                "smoothness_improvement": 1822.3160363098355,
                "objective_score": 26.31316856412883
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "cross_over",
        "algorithm_description": "This algorithm implements a bidirectional, goal-biased RRT* planner with adaptive neighborhood radius rewiring, multi-candidate bidirectional connection attempts, and incremental path shortcutting applied during planning and after completion. It enforces a strict 30-second time limit and dynamically adjusts rewiring radius based on tree size and dimension to balance exploration and refinement efficiency. The planner samples with goal bias for faster convergence, alternates expanding start and goal trees, and progressively shortcuts the best found path to minimize length and improve smoothness. Early stopping occurs upon finding a better path.",
        "planning_mechanism": "The planner grows two trees alternately from start and goal positions, samples random points with a goal bias, and extends the nearest node towards samples with a fixed step size while respecting collision constraints. It rewires nearby nodes within an adaptively shrinking radius to optimize path costs. Multiple candidates from the opposite tree are tested for connection on each new node added, enabling early termination when better paths are found. Progressive shortcutting improves path smoothness and length during planning as well as post-planning. The search halts immediately if the 30-second limit is exceeded, returning the best path found so far.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n    def add_child(self, child):\n        self.children.append(child)\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\nclass Planner:\n    def __init__(self, max_iter: int=5000, step_size: float=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.time_limit = 30.0\n        self.goal_sample_rate = 0.15  # probability to sample goal\n\n    def plan(self, map) -> 'PlannerResult':\n        import time\n        import math\n        import random\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        # Tree nodes and edges\n        start_tree = [Node(start_pos, cost=0.0)]\n        goal_tree = [Node(goal_pos, cost=0.0)]\n        nodes = start_tree[:] + goal_tree[:]\n        edges = []\n\n        best_connection = None\n        best_cost = float('inf')\n        success = False\n        extracted_path = []\n\n        step = self.step_size\n        gamma = 35.0  # radius multiplier for rewiring (RRT* theory)\n\n        start_time = time.monotonic()\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def sample_free():\n            # goal bias sampling\n            if random.random() < self.goal_sample_rate:\n                return goal_pos\n            for _ in range(100):\n                p = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n            return goal_pos  # fallback\n\n        def nearest(tree, point):\n            best_node = None\n            best_d = float('inf')\n            for node in tree:\n                d = dist(node.position, point)\n                if d < best_d:\n                    best_node = node\n                    best_d = d\n            return best_node\n\n        def near(tree, point, radius):\n            neighbors = [(dist(n.position, point), n) for n in tree if dist(n.position, point) <= radius]\n            neighbors.sort(key=lambda x: x[0])\n            return [n[1] for n in neighbors]\n\n        def steer(from_p, to_p, max_step):\n            d = dist(from_p, to_p)\n            if d <= max_step:\n                return to_p\n            ratio = max_step / d\n            return tuple(from_p[i] + (to_p[i] - from_p[i]) * ratio for i in range(dim))\n\n        def extract_path(node_start, node_goal):\n            path_start = []\n            cur = node_start\n            while cur:\n                path_start.append(cur.position)\n                cur = cur.parent\n            path_start.reverse()\n            path_goal = []\n            cur = node_goal\n            while cur:\n                path_goal.append(cur.position)\n                cur = cur.parent\n            if path_goal and path_start and path_start[-1] == path_goal[0]:\n                path_goal = path_goal[1:]\n            return path_start + path_goal\n\n        def shortcut_path(path, max_attempts=50):\n            if len(path) < 3:\n                return path\n            for _ in range(max_attempts):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution=max(step*0.2, 0.2)):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        def try_connect(new_node, other_tree):\n            radius = step*2.5\n            candidates = near(other_tree, new_node.position, radius)\n            best_cand = None\n            best_local_cost = float('inf')\n            for node in candidates:\n                d12 = dist(new_node.position, node.position)\n                if d12 <= radius and not self._is_edge_in_obstacle(new_node.position, node.position, obstacles, is_3d, resolution=max(step*0.2, 0.2)):\n                    c = new_node.cost + d12 + node.cost\n                    if c < best_local_cost:\n                        best_local_cost = c\n                        best_cand = node\n            return best_cand, best_local_cost\n\n        def rewire(tree, new_node, neighbors):\n            for nbr in neighbors:\n                if nbr is new_node.parent:\n                    continue\n                cost_through = new_node.cost + dist(new_node.position, nbr.position)\n                if cost_through + 1e-9 < nbr.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, nbr.position, obstacles, is_3d, resolution=max(step*0.2, 0.2)):\n                        if nbr.parent:\n                            try:\n                                edges.remove((nbr.parent, nbr))\n                            except Exception:\n                                pass\n                            nbr.parent.remove_child(nbr)\n                        nbr.parent = new_node\n                        nbr.cost = cost_through\n                        new_node.add_child(nbr)\n                        edges.append((new_node, nbr))\n\n        iter_since_last_shortcut = 0\n        shortcut_interval = 75\n\n        for it in range(self.max_iter):\n            if time.monotonic() - start_time > self.time_limit:\n                break\n\n            tree_a = start_tree if (it % 2 == 0) else goal_tree\n            tree_b = goal_tree if (it % 2 == 0) else start_tree\n\n            sample = sample_free()\n            nearest_node = nearest(tree_a, sample)\n            new_pos = steer(nearest_node.position, sample, step)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d, resolution=max(step*0.2, 0.2)):\n                continue\n\n            n_nodes = len(tree_a) + 1\n            radius = gamma * ((math.log(n_nodes)/n_nodes) ** (1/dim)) if n_nodes > 1 else step*5\n            radius = min(radius, step*5)\n            if radius < step:\n                radius = step\n\n            neighbors = near(tree_a, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            min_parent = nearest_node\n            for nb in neighbors:\n                cost_cand = nb.cost + dist(nb.position, new_pos)\n                if cost_cand + 1e-9 < min_cost:\n                    if not self._is_edge_in_obstacle(nb.position, new_pos, obstacles, is_3d, resolution=max(step*0.2, 0.2)):\n                        min_cost = cost_cand\n                        min_parent = nb\n\n            new_node = Node(new_pos, parent=min_parent, cost=min_cost)\n            min_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((min_parent, new_node))\n\n            rewire(tree_a, new_node, neighbors)\n\n            conn_node, conn_cost = try_connect(new_node, tree_b)\n            if conn_node is not None and conn_cost + 1e-9 < best_cost:\n                best_cost = conn_cost\n                # Maintain start_tree node first in best_connection\n                best_connection = (new_node, conn_node) if it % 2 == 0 else (conn_node, new_node)\n                success = True\n                # Early termination on improved path\n                break\n\n            iter_since_last_shortcut += 1\n            if iter_since_last_shortcut >= shortcut_interval and success:\n                path_cur = extract_path(best_connection[0], best_connection[1])\n                path_short = shortcut_path(path_cur, max_attempts=25)\n                if len(path_short) < len(path_cur):\n                    extracted_path = path_short\n                    iter_since_last_shortcut = 0\n\n        if success and best_connection is not None:\n            extracted_path = extract_path(best_connection[0], best_connection[1])\n            extracted_path = shortcut_path(extracted_path, max_attempts=75)\n        elif not success:\n            # Try partial best connection if no success\n            best_partial_cost = float('inf')\n            best_pair = None\n            search_radius = step * 3.0\n            for n1 in start_tree:\n                candidates = near(goal_tree, n1.position, search_radius)\n                for n2 in candidates:\n                    d12 = dist(n1.position, n2.position)\n                    if d12 <= search_radius:\n                        if not self._is_edge_in_obstacle(n1.position, n2.position, obstacles, is_3d, resolution=max(step*0.2, 0.2)):\n                            cost_sum = n1.cost + n2.cost + d12\n                            if cost_sum + 1e-9 < best_partial_cost:\n                                best_partial_cost = cost_sum\n                                best_pair = (n1, n2)\n            if best_pair:\n                success = True\n                extracted_path = extract_path(best_pair[0], best_pair[1])\n                extracted_path = shortcut_path(extracted_path, max_attempts=75)\n\n        return PlannerResult(\n            success=success,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
        "objective": -40.41506,
        "time_improvement": 74.0,
        "length_improvement": 17.0,
        "smoothness_improvement": 1612.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.010355472564697266,
                "num_nodes_avg": 88.3,
                "path_length_avg": 158.02445292325712,
                "smoothness_avg": 0.04068830742889877,
                "success_improvement": 0.0,
                "time_improvement": 58.963282937365015,
                "length_improvement": 13.384293295064195,
                "smoothness_improvement": 536.8603673360356,
                "objective_score": 28.403862694928197
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.025506019592285156,
                "num_nodes_avg": 305.8,
                "path_length_avg": 239.66358035944714,
                "smoothness_avg": 0.11914932396717788,
                "success_improvement": 0.0,
                "time_improvement": 84.44192042954145,
                "length_improvement": 19.993398542344394,
                "smoothness_improvement": 2965.7979254646784,
                "objective_score": 52.15760488159246
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.010851669311523437,
                "num_nodes_avg": 173.2,
                "path_length_avg": 123.90215675117983,
                "smoothness_avg": 0.11268141879062014,
                "success_improvement": 0.0,
                "time_improvement": 77.97057173653472,
                "length_improvement": 17.710087072551893,
                "smoothness_improvement": 1333.2993297395258,
                "objective_score": 40.683720413189185
            }
        ],
        "success_rate": 1.0
    }
]