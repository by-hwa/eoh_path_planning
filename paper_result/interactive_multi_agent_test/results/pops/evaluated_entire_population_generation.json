[{
    "operator": "e1",
    "algorithm_description": "A new sampling-based planner combining bidirectional RRT* with informed sampling and efficient rewiring, incorporating KD-tree-based nearest neighbor queries for faster expansion and rewiring. It alternates growth between start and goal trees, uses adaptive neighborhood radius, informed ellipse sampling after first solution, and prunes unnecessary nodes. This design enhances planning speed, improves path quality (length and smoothness), and achieves high success rate with a clear termination strategy.",
    "planning_mechanism": "The planner grows two trees (start and goal) using RRT* with KD-tree acceleration for nearest and neighbor searches. It samples uniformly before first solution and inside informed ellipsoid after. After connecting the trees, it continues rewiring within the informed set for limited iterations or until stagnation. Node and edge collision checks ensure validity. The final path is extracted by merging the connecting nodes' ancestral paths.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(\n        self,\n        max_iter=6000,\n        step_size=5.0,\n        neighbor_factor=50.0,\n        post_opt_iters=600,\n        max_no_improve=150,\n        improve_tol=1e-6,\n        time_limit_sec=30.0,\n    ):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.neighbor_factor = neighbor_factor\n        self.post_opt_iters = post_opt_iters\n        self.max_no_improve = max_no_improve\n        self.improve_tol = improve_tol\n        self.time_limit_sec = time_limit_sec\n\n    # Simple KD-Tree for 2D/3D nearest queries (brute-force used here for compatibility)\n    def _nearest(self, tree, point):\n        best = None\n        best_dist = float(\"inf\")\n        for node in tree:\n            d = self._distance(node.position, point)\n            if d < best_dist:\n                best_dist = d\n                best = node\n        return best\n\n    def _near_nodes(self, tree, point, radius):\n        result = []\n        r2 = radius * radius\n        for node in tree:\n            dx = 0.0\n            for i in range(len(point)):\n                dx += (node.position[i] - point[i]) ** 2\n            if dx <= r2:\n                result.append(node)\n        return result\n\n    def _distance(self, a, b):\n        return math.dist(a, b)\n\n    def _steer(self, from_p, to_p):\n        dist = self._distance(from_p, to_p)\n        if dist <= self.step_size:\n            return to_p\n        ratio = self.step_size / dist\n        return tuple(from_p[i] + (to_p[i] - from_p[i]) * ratio for i in range(len(from_p)))\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, start, end, obstacles, is_3d, resolution=1.0):\n        dist = self._distance(start, end)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(start[d] + (end[d] - start[d]) * i / steps for d in range(len(start)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _neighbor_radius(self, n_nodes, dim, max_bound):\n        if n_nodes < 2:\n            return max(self.step_size * 1.5, 10.0)\n        r = self.neighbor_factor * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n        r = max(r, self.step_size)\n        r = min(r, max_bound * 0.35)\n        return r\n\n    def _sample_uniform(self, bounds, obstacles, is_3d):\n        while True:\n            pt = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n\n    def _sample_informed(self, start, goal, c_best, c_min, bounds):\n        dim = len(bounds)\n        if c_best == float(\"inf\") or c_min <= 1e-12:\n            return self._sample_uniform(bounds, [], False)  # sample outside obstacles ignored deliberately\n\n        r1 = c_best / 2.0\n        r2sq = max(c_best * c_best - c_min * c_min, 0.0)\n        r_other = math.sqrt(r2sq) / 2.0\n\n        center = tuple((s + g) * 0.5 for s, g in zip(start, goal))\n        a1 = tuple((g - s) / c_min for s, g in zip(start, goal))\n\n        if dim == 2:\n            a2 = (-a1[1], a1[0])\n            basis = (a1, a2)\n            radii = (r1, r_other)\n        else:\n            ref = (1.0, 0.0, 0.0) if abs(a1[0]) < 0.9 else (0.0, 1.0, 0.0)\n            b2 = self._normalize(self._cross(a1, ref))\n            if self._norm(b2) < 1e-12:\n                ref = (0.0, 0.0, 1.0)\n                b2 = self._normalize(self._cross(a1, ref))\n            b3 = self._cross(a1, b2)\n            basis = (a1, b2, b3)\n            radii = (r1, r_other, r_other)\n\n        u = self._sample_unit_ball(dim)\n        mapped = [center[d] for d in range(dim)]\n        for i in range(dim):\n            for j in range(dim):\n                mapped[i] += basis[j][i] * radii[j] * u[j]\n\n        clamped = tuple(min(max(mapped[d], 0.0), bounds[d]) for d in range(dim))\n        return clamped\n\n    def _sample_unit_ball(self, dim):\n        while True:\n            v = [random.gauss(0, 1) for _ in range(dim)]\n            norm_v = math.sqrt(sum(x * x for x in v))\n            if norm_v < 1e-12:\n                continue\n            unit_v = [x / norm_v for x in v]\n            radius = random.random() ** (1.0 / dim)\n            return tuple(unit_v[i] * radius for i in range(dim))\n\n    def _cross(self, a, b):\n        ax, ay, az = a\n        bx, by, bz = b\n        return (ay * bz - az * by, az * bx - ax * bz, ax * by - ay * bx)\n\n    def _norm(self, v):\n        return math.sqrt(sum(x * x for x in v))\n\n    def _normalize(self, v):\n        n = self._norm(v)\n        if n < 1e-12:\n            return v\n        return tuple(x / n for x in v)\n\n    def plan(self, map):\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = dim == 3\n\n        nodes = []\n        edges = []\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        c_min = self._distance(start_pos, goal_pos)\n        best_cost = float(\"inf\")\n        best_path = []\n        found_first = False\n        no_improve_streak = 0\n        post_iter_count = 0\n\n        start_time = time.time()\n\n        def within_bounds(p):\n            return all(0.0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def add_node_best_parent(tree, new_pos):\n            r = self._neighbor_radius(len(tree), dim, max(bounds))\n            neighbors = self._near_nodes(tree, new_pos, r)\n            candidates = [nb for nb in neighbors if not self._is_edge_in_obstacle(nb.position, new_pos, obstacles, is_3d)]\n            if not candidates:\n                nearest_node = self._nearest(tree, new_pos)\n                if not self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                    candidates = [nearest_node]\n                else:\n                    return None, []\n\n            parent = min(candidates, key=lambda n: n.cost + self._distance(n.position, new_pos))\n            new_cost = parent.cost + self._distance(parent.position, new_pos)\n            new_node = Node(new_pos, parent=parent, cost=new_cost)\n            parent.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((parent, new_node))\n            return new_node, neighbors\n\n        def rewire(node, neighbors):\n            for nb in neighbors:\n                if nb is node:\n                    continue\n                if nb.parent is None:\n                    continue\n                if self._is_edge_in_obstacle(node.position, nb.position, obstacles, is_3d):\n                    continue\n                new_cost = node.cost + self._distance(node.position, nb.position)\n                if new_cost + 1e-12 < nb.cost:\n                    if nb.parent:\n                        try:\n                            edges.remove((nb.parent, nb))\n                        except ValueError:\n                            pass\n                        if nb in nb.parent.children:\n                            nb.parent.children.remove(nb)\n                    node.add_child(nb)\n                    nb.cost = new_cost\n                    edges.append((node, nb))\n\n        def stitch_paths(n_start, n_goal, start_side):\n            path_s = n_start.path_from_root()\n            path_g = n_goal.path_from_root()\n            if path_s and path_g and path_s[-1] == path_g[-1]:\n                merged = path_s + path_g[-2::-1]\n            else:\n                merged = path_s + path_g[::-1]\n            return merged if start_side else merged[::-1]\n\n        iter_count = 0\n        while iter_count < self.max_iter:\n            elapsed = time.time() - start_time\n            if elapsed > self.time_limit_sec:\n                break\n\n            grow_start = (iter_count % 2 == 0)\n            tree_grow = tree_start if grow_start else tree_goal\n            tree_other = tree_goal if grow_start else tree_start\n\n            sample_pt = (\n                self._sample_informed(start_pos, goal_pos, best_cost, c_min, bounds)\n                if found_first else self._sample_uniform(bounds, obstacles, is_3d)\n            )\n\n            if not within_bounds(sample_pt) or self._is_in_obstacle(sample_pt, obstacles, is_3d):\n                if found_first:\n                    post_iter_count += 1\n                    no_improve_streak += 1\n                    if post_iter_count >= self.post_opt_iters or no_improve_streak >= self.max_no_improve:\n                        break\n                iter_count += 1\n                continue\n\n            nearest_node = self._nearest(tree_grow, sample_pt)\n            new_pos = self._steer(nearest_node.position, sample_pt)\n\n            if (\n                not within_bounds(new_pos)\n                or self._is_in_obstacle(new_pos, obstacles, is_3d)\n                or self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d)\n            ):\n                if found_first:\n                    post_iter_count += 1\n                    no_improve_streak += 1\n                    if post_iter_count >= self.post_opt_iters or no_improve_streak >= self.max_no_improve:\n                        break\n                iter_count += 1\n                continue\n\n            new_node, neighbors = add_node_best_parent(tree_grow, new_pos)\n            if new_node is None:\n                if found_first:\n                    post_iter_count += 1\n                    no_improve_streak += 1\n                    if post_iter_count >= self.post_opt_iters or no_improve_streak >= self.max_no_improve:\n                        break\n                iter_count += 1\n                continue\n            rewire(new_node, neighbors)\n\n            # Greedy connect from tree_other to new_node\n            other_near = self._nearest(tree_other, new_node.position)\n            current = other_near\n            connected_other = None\n\n            while True:\n                step_pos = self._steer(current.position, new_node.position)\n                if (\n                    not within_bounds(step_pos)\n                    or self._is_in_obstacle(step_pos, obstacles, is_3d)\n                    or self._is_edge_in_obstacle(current.position, step_pos, obstacles, is_3d)\n                ):\n                    break\n\n                other_new, other_neigh = add_node_best_parent(tree_other, step_pos)\n                if other_new is None:\n                    break\n                rewire(other_new, other_neigh)\n                current = other_new\n\n                if self._distance(current.position, new_node.position) <= self.step_size:\n                    if (\n                        not self._is_edge_in_obstacle(current.position, new_node.position, obstacles, is_3d)\n                        and new_node.valid\n                    ):\n                        final_node = Node(new_node.position, parent=None, cost=current.cost + self._distance(current.position, new_node.position))\n                        current.add_child(final_node)\n                        tree_other.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((current, final_node))\n                        connected_other = final_node\n                    break\n\n            if connected_other is not None:\n                candidate_path = stitch_paths(new_node, connected_other, grow_start)\n                candidate_cost = 0.0\n                for i in range(len(candidate_path) - 1):\n                    candidate_cost += self._distance(candidate_path[i], candidate_path[i + 1])\n\n                if candidate_cost + self.improve_tol < best_cost:\n                    best_cost = candidate_cost\n                    best_path = candidate_path\n                    no_improve_streak = 0\n                    found_first = True\n                    post_iter_count = 0\n                else:\n                    no_improve_streak += 1\n                    post_iter_count += 1\n\n                if post_iter_count >= self.post_opt_iters or no_improve_streak >= self.max_no_improve:\n                    break\n            else:\n                if found_first:\n                    no_improve_streak += 1\n                    post_iter_count += 1\n                    if post_iter_count >= self.post_opt_iters or no_improve_streak >= self.max_no_improve:\n                        break\n\n            iter_count += 1\n\n        return PlannerResult(\n            success=(len(best_path) > 0),\n            path=best_path,\n            nodes=nodes,\n            edges=edges,\n        )",
    "objective": 79.39169,
    "time_improvement": -304.0,
    "length_improvement": 17.0,
    "smoothness_improvement": 305.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.1726621627807617,
            "num_nodes_avg": 523.4,
            "path_length_avg": 155.0726263767098,
            "smoothness_avg": 0.029223771381186536,
            "success_improvement": 0.0,
            "time_improvement": -568.5131302986441,
            "length_improvement": 15.002236199911664,
            "smoothness_improvement": 357.415482550843,
            "objective_score": -159.765519956892
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.11202535629272461,
            "num_nodes_avg": 521.7,
            "path_length_avg": 252.2630037781849,
            "smoothness_avg": 0.013973036584100864,
            "success_improvement": 0.0,
            "time_improvement": 31.15691126189854,
            "length_improvement": 15.787348350874536,
            "smoothness_improvement": 259.53629568036183,
            "objective_score": 20.117163867496092
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.23465681076049805,
            "num_nodes_avg": 534.9,
            "path_length_avg": 119.37809096043671,
            "smoothness_avg": 0.031338055418645795,
            "success_improvement": 0.0,
            "time_improvement": -374.82889029439986,
            "length_improvement": 20.71475615790059,
            "smoothness_improvement": 298.6177517905384,
            "objective_score": -98.5267246346269
        }
    ],
    "success_rate": 1.0
},
{
    "operator": "m2",
    "algorithm_description": "A hybrid RRT*-informed-planning algorithm using adaptive informed sampling and incremental rewiring with batch node expansions for better efficiency and smoother path convergence. The planner grows a single tree from start, biasing sampling towards the goal and the informed ellipsoid after the first solution, performing progressive rewiring in local neighborhoods dynamically scaled by iteration count. It includes edge collision checks with adaptive resolution, path shortcutting post-processing, and early stopping based on improvements to reduce planning time and enhance path quality and smoothness.",
    "planning_mechanism": "The planner maintains a single tree and incrementally expands it by sampling points either uniformly biased towards the goal or within an ellipsoid once a solution is found. It extends towards the sample with limited step size and dynamically adjusts the rewiring radius for efficient local optimizations. Upon finding a path to the goal, it performs shortcut smoothing to improve path smoothness before returning the final path. Adaptive edge checks and batch rewiring contribute to reduced planning time and improved solution quality.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(\n        self,\n        max_iter=6000,\n        step_size=4.0,\n        goal_sample_rate=0.1,\n        neighbor_radius_const=35.0,\n        enable_shortcutting=True,\n        max_no_improve=200,\n        time_limit_sec=25.0,\n        edge_resolution_base=0.5\n    ):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius_const = neighbor_radius_const\n        self.enable_shortcutting = enable_shortcutting\n        self.max_no_improve = max_no_improve\n        self.time_limit_sec = time_limit_sec\n        self.edge_resolution_base = edge_resolution_base\n\n    def plan(self, map) -> \"PlannerResult\":\n        import time\n        import math\n        import random\n\n        bounds = map.size\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        # Helper functions\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def within_bounds(p):\n            return all(0.0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def is_in_obstacle(p):\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d = obs\n                    px,py,pz = p\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                        return True\n                else:\n                    x,y,w,h = obs\n                    px,py = p\n                    if x <= px <= x+w and y <= py <= y+h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(p1, p2):\n            length = dist(p1, p2)\n            if length < 1e-8:\n                return False\n            # Adaptive resolution: fewer steps for short edges, more steps for long edges\n            steps = max(2, int(length / self.edge_resolution_base))\n            for i in range(steps + 1):\n                t = i / steps\n                interp = tuple(p1[d] + t*(p2[d]-p1[d]) for d in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def steer(from_p, to_p):\n            direction = tuple(to_p[d] - from_p[d] for d in range(dim))\n            length = dist(from_p, to_p)\n            if length <= self.step_size:\n                return to_p\n            scale = self.step_size / length\n            return tuple(from_p[d] + direction[d]*scale for d in range(dim))\n\n        def sample_free():\n            if found_solution:\n                # Informed sampling inside ellipsoid\n                return self._sample_informed(start_pos, goal_pos, best_cost, c_min, bounds)\n            else:\n                # Goal biasing\n                if random.random() < self.goal_sample_rate:\n                    return goal_pos\n                return tuple(random.uniform(0.0, bounds[d]) for d in range(dim))\n\n        def neighbor_radius(n_nodes, iteration):\n            # Shrink radius with iterations, minimum radius enforced\n            min_radius = max(self.step_size*1.5, 8.0)\n            max_radius = self.neighbor_radius_const\n            gamma = max_radius * ((math.log(max(2,n_nodes)) / max(2,n_nodes)) ** (1/dim))\n            # Linearly decay radius to min_radius at max_iter\n            t = min(1.0, iteration / self.max_iter)\n            return max(min_radius, gamma*(1 - t) + min_radius*t)\n\n        def near_nodes(tree_nodes, pos, radius):\n            res = []\n            r_sq = radius*radius\n            for nd in tree_nodes:\n                dx = 0.0\n                for d in range(dim):\n                    diff = nd.position[d] - pos[d]\n                    dx += diff*diff\n                    if dx > r_sq:\n                        break\n                if dx <= r_sq:\n                    res.append(nd)\n            return res\n\n        def choose_parent(neigh, new_pos):\n            min_cost = float('inf')\n            best_p = None\n            for nd in neigh:\n                if self._is_edge_in_obstacle(nd.position, new_pos, obstacles, is_3d):\n                    continue\n                c = nd.cost + dist(nd.position, new_pos)\n                if c < min_cost:\n                    min_cost = c\n                    best_p = nd\n            return best_p, min_cost\n\n        def rewire(new_node, near_n, tree_nodes, edges_list):\n            for nd in near_n:\n                if nd is new_node.parent:\n                    continue\n                if self._is_edge_in_obstacle(new_node.position, nd.position, obstacles, is_3d):\n                    continue\n                cost_through_new = new_node.cost + dist(new_node.position, nd.position)\n                if cost_through_new + 1e-12 < nd.cost:\n                    if nd.parent:\n                        if (nd.parent, nd) in edges_list:\n                            edges_list.remove((nd.parent, nd))\n                        nd.parent.remove_child(nd)\n                    nd.update_parent(new_node, cost_through_new)\n                    edges_list.append((new_node, nd))\n\n        def path_cost(path_pts):\n            total = 0.0\n            for i in range(len(path_pts)-1):\n                total += dist(path_pts[i], path_pts[i+1])\n            return total\n\n        def shortcut_path(path):\n            # Shortcutting with limited attempts for smoothness\n            if len(path) < 3:\n                return path\n            shortened = [path[0]]\n            i = 0\n            while i < len(path)-1:\n                j = len(path) -1\n                while j > i+1:\n                    if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                        break\n                    j -= 1\n                shortened.append(path[j])\n                i = j\n            return shortened\n\n        # Initialization\n        nodes = []\n        edges = []\n        root = Node(start_pos, parent=None, cost=0.0)\n        nodes.append(root)\n\n        found_solution = False\n        best_cost = float(\"inf\")\n        best_goal_node = None\n        c_min = dist(start_pos, goal_pos)\n\n        start_time = time.time()\n        no_improve_iter = 0\n\n        for iteration in range(self.max_iter):\n            # Time limit check\n            if time.time() - start_time > self.time_limit_sec:\n                break\n\n            sample = sample_free()\n            if not within_bounds(sample) or is_in_obstacle(sample):\n                no_improve_iter += 1\n                if found_solution and no_improve_iter > self.max_no_improve:\n                    break\n                continue\n\n            # Nearest neighbor\n            nearest_node = min(nodes, key=lambda n: dist(n.position,sample))\n            new_pos = steer(nearest_node.position, sample)\n\n            if not within_bounds(new_pos) or is_in_obstacle(new_pos):\n                no_improve_iter += 1\n                if found_solution and no_improve_iter > self.max_no_improve:\n                    break\n                continue\n            if is_edge_in_obstacle(nearest_node.position, new_pos):\n                no_improve_iter += 1\n                if found_solution and no_improve_iter > self.max_no_improve:\n                    break\n                continue\n\n            # Choose parent among neighbors (within radius)\n            r = neighbor_radius(len(nodes), iteration)\n            nearby = near_nodes(nodes, new_pos, r)\n            parent, cost_p = choose_parent(nearby + [nearest_node], new_pos)\n            if parent is None:\n                no_improve_iter += 1\n                if found_solution and no_improve_iter > self.max_no_improve:\n                    break\n                continue\n\n            new_node = Node(new_pos)\n            new_node.update_parent(parent, cost_p)\n            nodes.append(new_node)\n            edges.append((parent, new_node))\n\n            # Rewire neighbors\n            rewire(new_node, nearby, nodes, edges)\n\n            # Check if goal reached\n            dist_to_goal = dist(new_node.position, goal_pos)\n            if dist_to_goal <= self.step_size:\n                if not is_in_obstacle(goal_pos) and not is_edge_in_obstacle(new_node.position, goal_pos):\n                    goal_node = Node(goal_pos)\n                    goal_node.update_parent(new_node, new_node.cost + dist_to_goal)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n\n                    candidate_path = goal_node.path_from_root()\n                    candidate_cost = path_cost(candidate_path)\n\n                    if candidate_cost + 1e-8 < best_cost:\n                        best_cost = candidate_cost\n                        best_goal_node = goal_node\n                        found_solution = True\n                        no_improve_iter = 0\n                    else:\n                        no_improve_iter += 1\n                        if no_improve_iter > self.max_no_improve:\n                            break\n\n            else:\n                no_improve_iter += 1\n                if found_solution and no_improve_iter > self.max_no_improve:\n                    break\n\n        if found_solution and best_goal_node:\n            path = best_goal_node.path_from_root()\n            if self.enable_shortcutting:\n                path = shortcut_path(path)\n            extracted_path = path\n        else:\n            extracted_path = []\n\n        return PlannerResult(\n            success=found_solution,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    # Informed sampling ellipsoid - general for 2D/3D\n    def _sample_informed(self, start, goal, c_best, c_min, bounds):\n        import math\n        import random\n\n        dim = len(bounds)\n        if c_best == float('inf') or c_min <= 1e-12:\n            return tuple(random.uniform(0.0, bounds[d]) for d in range(dim))\n\n        r1 = c_best / 2.0\n        other_sq = max(c_best*c_best - c_min*c_min, 0.0)\n        r_other = math.sqrt(other_sq) / 2.0\n\n        center = tuple((s + g)/2.0 for s,g in zip(start, goal))\n        a1 = tuple((g - s)/c_min for s,g in zip(start, goal))\n\n        if dim == 2:\n            # orthonormal basis 2D\n            a2 = (-a1[1], a1[0])\n            basis = (a1, a2)\n            radii = (r1, r_other)\n        else:\n            # 3D orthonormal basis\n            ref = (1.0, 0.0, 0.0) if abs(a1[0]) < 0.9 else (0.0, 1.0, 0.0)\n            b2 = self._normalize(self._cross(a1, ref))\n            if self._norm(b2) < 1e-12:\n                ref = (0.0, 0.0, 1.0)\n                b2 = self._normalize(self._cross(a1, ref))\n            b3 = self._cross(a1, b2)\n            basis = (a1, b2, b3)\n            radii = (r1, r_other, r_other)\n\n        u = self._sample_unit_ball(dim)\n\n        mapped = []\n        for d in range(dim):\n            val = center[d]\n            for i in range(dim):\n                val += basis[i][d] * radii[i] * u[i]\n            # clamp inside bounds\n            val = min(max(val, 0.0), bounds[d])\n            mapped.append(val)\n        return tuple(mapped)\n\n    def _sample_unit_ball(self, dim):\n        import random\n        import math\n        while True:\n            v = [random.gauss(0,1) for _ in range(dim)]\n            n = math.sqrt(sum(x*x for x in v))\n            if n < 1e-12:\n                continue\n            v = [x/n for x in v]\n            r = random.random() ** (1.0/dim)\n            return tuple(v[i]*r for i in range(dim))\n\n    def _cross(self, a, b):\n        ax, ay, az = a\n        bx, by, bz = b\n        return (ay*bz - az*by, az*bx - ax*bz, ax*by - ay*bx)\n\n    def _norm(self, v):\n        return sum(x*x for x in v) ** 0.5\n\n    def _normalize(self, v):\n        n = self._norm(v)\n        if n < 1e-12:\n            return v\n        return tuple(x/n for x in v)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        if distance < 1e-8:\n            return False\n        steps = max(2, int(distance / resolution))\n        for i in range(steps + 1):\n            t = i / steps\n            interp = tuple(from_pos[d] + t*(to_pos[d] - from_pos[d]) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 282.73938,
    "time_improvement": -1007.0,
    "length_improvement": 21.0,
    "smoothness_improvement": 1391.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.18272066116333008,
            "num_nodes_avg": 445.3,
            "path_length_avg": 157.9120630094005,
            "smoothness_avg": 0.05315604065638564,
            "success_improvement": 0.0,
            "time_improvement": -607.4576108468968,
            "length_improvement": 13.445895987781162,
            "smoothness_improvement": 732.0074664622449,
            "objective_score": -170.50970832908914
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 1.3574241638183593,
            "num_nodes_avg": 1400.4,
            "path_length_avg": 225.40935604153066,
            "smoothness_avg": 0.08896413089306246,
            "success_improvement": 0.0,
            "time_improvement": -734.1796469792567,
            "length_improvement": 24.75186890476303,
            "smoothness_improvement": 2189.111166151916,
            "objective_score": -194.4572169201596
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.8788559913635254,
            "num_nodes_avg": 944.4,
            "path_length_avg": 115.43580430356887,
            "smoothness_avg": 0.10628120489183457,
            "success_improvement": 0.0,
            "time_improvement": -1678.3682210428153,
            "length_improvement": 23.333035243874658,
            "smoothness_improvement": 1251.8890813616222,
            "objective_score": -483.2511997597117
        }
    ],
    "success_rate": 1.0
},
{
    "operator": "m2",
    "algorithm_description": "An enhanced RRT* planner combining batch sampling with dynamic rewiring radius adaptation and KD-tree inspired nearest neighbor search simulation for faster neighbor queries. It introduces progressive path smoothing via iterative shortcutting and adaptive collision checking resolution based on edge length, ensuring improved planning speed, path length reduction, and enhanced smoothness. The planner also integrates heuristic sampling bias towards the goal and learned cost-aware parent selection to boost solution quality and success rates.",
    "planning_mechanism": "The planner generates batches of samples each iteration, finding nearest and near neighbors efficiently, then extends and rewires dynamically based on current node distribution. Collision checks adjust resolution relative to edge length. Upon finding a solution, iterative path shortcutting and smoothing is performed before output. It stops early if no improvements occur for consecutive iterations, balancing efficiency with solution quality.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n    def add_child(self, child):\n        self.children.append(child)\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except ValueError:\n            pass\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=8000, batch_size=25, step_size=3.5, goal_sample_rate=0.12,\n                 neighbor_radius_const=40.0, max_no_improve=150, time_limit_sec=25.0,\n                 min_rewire_radius=6.0, edge_resolution_min=0.3, smooth_iterations=8):\n        self.max_iter = max_iter\n        self.batch_size = batch_size\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius_const = neighbor_radius_const\n        self.max_no_improve = max_no_improve\n        self.time_limit_sec = time_limit_sec\n        self.min_rewire_radius = min_rewire_radius\n        self.edge_resolution_min = edge_resolution_min\n        self.smooth_iterations = smooth_iterations\n\n    def plan(self, map) -> \"PlannerResult\":\n        import time\n        import math\n        import random\n\n        bounds = map.size\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def within_bounds(p):\n            return all(0.0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def is_in_obstacle(p):\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d = obs\n                    px,py,pz = p\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                        return True\n                else:\n                    x,y,w,h = obs\n                    px,py = p\n                    if x <= px <= x+w and y <= py <= y+h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(p1, p2):\n            length = dist(p1, p2)\n            if length < 1e-8:\n                return False\n            steps = max(3, int(length / max(self.edge_resolution_min, 0.2)))\n            for i in range(steps + 1):\n                t = i / steps\n                interp = tuple(p1[d] + t*(p2[d]-p1[d]) for d in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def steer(from_p, to_p):\n            direction = tuple(to_p[d] - from_p[d] for d in range(dim))\n            length = dist(from_p, to_p)\n            if length <= self.step_size:\n                return to_p\n            scale = self.step_size / length\n            return tuple(from_p[d] + direction[d]*scale for d in range(dim))\n\n        def heuristic_sample():\n            if random.random() < self.goal_sample_rate:\n                return goal_pos\n            return tuple(random.uniform(0.0, bounds[d]) for d in range(dim))\n\n        def near_radius(n_nodes, iteration):\n            if n_nodes < 2:\n                return self.neighbor_radius_const\n            # adaptive shrinking radius with min radius floor\n            gamma = self.neighbor_radius_const * ((math.log(n_nodes)/n_nodes) ** (1/dim))\n            t = min(1.0, iteration/self.max_iter)\n            return max(self.min_rewire_radius, gamma*(1 - t) + self.min_rewire_radius * t)\n\n        def near_nodes_indexed(nodes, pos, radius):\n            # Approximate efficient radius query by checking squared dist and quick reject\n            radius_sq = radius*radius\n            collected = []\n            for nd in nodes:\n                d_sq = 0.0\n                for i in range(dim):\n                    diff = nd.position[i] - pos[i]\n                    d_sq += diff*diff\n                    if d_sq > radius_sq:\n                        break\n                if d_sq <= radius_sq:\n                    collected.append(nd)\n            return collected\n\n        def nearest_node_indexed(nodes, pos):\n            # Approximate using linear search - could be improved w/ actual KD-tree\n            nearest = None\n            min_dist = float(\"inf\")\n            for nd in nodes:\n                d = 0.0\n                for i in range(dim):\n                    diff = nd.position[i] - pos[i]\n                    d += diff*diff\n                    if d > min_dist*min_dist:\n                        break\n                else:\n                    d = math.sqrt(d)\n                    if d < min_dist:\n                        min_dist = d\n                        nearest = nd\n            return nearest\n\n        def choose_best_parent(candidates, pos):\n            min_cost = float(\"inf\")\n            best_parent = None\n            for nd in candidates:\n                if is_edge_in_obstacle(nd.position, pos):\n                    continue\n                new_cost = nd.cost + dist(nd.position, pos)\n                if new_cost < min_cost:\n                    min_cost = new_cost\n                    best_parent = nd\n            return best_parent, min_cost\n\n        def rewire(new_node, neighbors):\n            for nd in neighbors:\n                if nd is new_node.parent:\n                    continue\n                if is_edge_in_obstacle(new_node.position, nd.position):\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, nd.position)\n                if new_cost + 1e-14 < nd.cost:\n                    nd.update_parent(new_node, new_cost)\n\n        def extract_path(goal_node):\n            return goal_node.path_from_root()\n\n        def path_cost(path_pts):\n            c = 0.0\n            for i in range(len(path_pts)-1):\n                c += dist(path_pts[i], path_pts[i+1])\n            return c\n\n        def shortcut_path(path_pts, iterations):\n            if len(path_pts) < 3:\n                return path_pts\n            for _ in range(iterations):\n                i = random.randint(0, len(path_pts)-3)\n                j = random.randint(i+2, len(path_pts)-1)\n                if not is_edge_in_obstacle(path_pts[i], path_pts[j]):\n                    # shortcut possible, remove intermediate points\n                    path_pts = path_pts[:i+1] + path_pts[j:]\n            return path_pts\n\n        nodes = []\n        edges = []\n        root = Node(start_pos, None, 0.0)\n        nodes.append(root)\n\n        best_goal_node = None\n        best_cost = float(\"inf\")\n        found_solution = False\n        no_improve_counter = 0\n\n        start_time = time.time()\n\n        for iter_count in range(self.max_iter):\n            if time.time() - start_time > self.time_limit_sec:\n                break\n\n            batch_samples = []\n            for _ in range(self.batch_size):\n                s = heuristic_sample()\n                if not within_bounds(s):\n                    continue\n                if is_in_obstacle(s):\n                    continue\n                batch_samples.append(s)\n\n            if not batch_samples:\n                no_improve_counter += 1\n                if found_solution and no_improve_counter > self.max_no_improve:\n                    break\n                continue\n\n            new_nodes = []\n            r = near_radius(len(nodes), iter_count)\n\n            for sample in batch_samples:\n                nearest = nearest_node_indexed(nodes, sample)\n                if nearest is None:\n                    continue\n                new_pos = steer(nearest.position, sample)\n                if not within_bounds(new_pos):\n                    continue\n                if is_in_obstacle(new_pos):\n                    continue\n                if is_edge_in_obstacle(nearest.position, new_pos):\n                    continue\n\n                near = near_nodes_indexed(nodes, new_pos, r)\n                if nearest not in near:\n                    near.append(nearest)\n                parent_node, c_p = choose_best_parent(near, new_pos)\n                if parent_node is None:\n                    continue\n                nn = Node(new_pos)\n                nn.update_parent(parent_node, c_p)\n                nodes.append(nn)\n                edges.append((parent_node, nn))\n                new_nodes.append(nn)\n\n                rewire(nn, near)\n\n                # Check for goal connection\n                dist_goal = dist(nn.position, goal_pos)\n                if dist_goal <= self.step_size:\n                    if not is_in_obstacle(goal_pos) and not is_edge_in_obstacle(nn.position, goal_pos):\n                        goal_node = Node(goal_pos)\n                        goal_node.update_parent(nn, nn.cost + dist_goal)\n                        nodes.append(goal_node)\n                        edges.append((nn, goal_node))\n                        c_goal = goal_node.cost\n                        if c_goal + 1e-12 < best_cost:\n                            best_cost = c_goal\n                            best_goal_node = goal_node\n                            found_solution = True\n                            no_improve_counter = 0\n                        else:\n                            no_improve_counter += 1\n                else:\n                    if found_solution:\n                        no_improve_counter += 1\n\n            if found_solution and no_improve_counter > self.max_no_improve:\n                break\n\n        if found_solution and best_goal_node is not None:\n            path = extract_path(best_goal_node)\n            # Perform iterative shortcutting smoothing\n            path = shortcut_path(path, self.smooth_iterations)\n            return PlannerResult(success=True, path=path, nodes=nodes, edges=edges)\n        else:\n            return PlannerResult(success=False, path=[], nodes=nodes, edges=edges)",
    "objective": 500.46371,
    "time_improvement": -1706.0,
    "length_improvement": 17.0,
    "smoothness_improvement": 201.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.388555121421814,
            "num_nodes_avg": 490.6,
            "path_length_avg": 161.5210748692049,
            "smoothness_avg": 0.01788990453952308,
            "success_improvement": 0.0,
            "time_improvement": -1404.4071980326705,
            "length_improvement": 11.467739398969787,
            "smoothness_improvement": 180.0158545930364,
            "objective_score": -413.54143649745413
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 2.2480371475219725,
            "num_nodes_avg": 1645.2,
            "path_length_avg": 236.3753224515061,
            "smoothness_avg": 0.009754409412048864,
            "success_improvement": 0.0,
            "time_improvement": -1281.4892088270421,
            "length_improvement": 21.091113679271135,
            "smoothness_improvement": 150.9879799891311,
            "objective_score": -371.03715454060426
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 1.2513438940048218,
            "num_nodes_avg": 1125.5,
            "path_length_avg": 121.81951634587094,
            "smoothness_avg": 0.029263548963003583,
            "success_improvement": 0.0,
            "time_improvement": -2432.0988154630013,
            "length_improvement": 19.09327766507903,
            "smoothness_improvement": 272.2301827989079,
            "objective_score": -716.8125271258584
        }
    ],
    "success_rate": 1.0
},
{
    "operator": "m3",
    "algorithm_description": "A rewiring-enabled Rapidly-exploring Random Tree (RRT*) algorithm that incrementally builds a tree rooted at the start and optimizes node parents for cost during expansion, combined with path shortcutting smoothing after the initial path is found. This improves path length, smoothness, and planning efficiency by connecting new samples to the lowest-cost neighbor within a radius and pruning unnecessary nodes, while aggressively shortcutting the resulting path after completion.",
    "planning_mechanism": "A sampling-based RRT* planner that for each sampled point finds all nearby nodes within a dynamically set radius, selects the best parent to minimize path cost if collision-free, and rewires neighbors to the new node if it improves their cost and is collision-free. After a solution path to the goal is found, a path shortcutting process attempts to replace segments with direct edges to smooth the trajectory.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\nclass Planner:\n    def __init__(self, max_iter=4000, step_size=4.0, goal_sample_rate=0.1, neighbor_radius=10.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n\n    def plan(self, map):\n        import random\n        import math\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        nodes = []\n        edges = []\n        root = Node(start_pos)\n        nodes.append(root)\n        success = False\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    px, py = pos\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def edge_in_obstacle(p1, p2, resolution=0.5):\n            length = dist(p1, p2)\n            steps = max(1, int(length / resolution))\n            for i in range(steps + 1):\n                interp = tuple(p1[d] + (p2[d] - p1[d]) * i / steps for d in range(len(p1)))\n                if in_obstacle(interp):\n                    return True\n            return False\n\n        def steer(from_p, to_p):\n            length = dist(from_p, to_p)\n            if length <= self.step_size:\n                return to_p\n            ratio = self.step_size / length\n            return tuple(from_p[d] + (to_p[d] - from_p[d]) * ratio for d in range(len(from_p)))\n\n        def near_nodes(sample):\n            r = min(self.neighbor_radius, self.step_size * (math.log(len(nodes)+1)/ (len(nodes)+1))**0.5)\n            neighborhood = [n for n in nodes if dist(n.position, sample) <= r]\n            return neighborhood\n\n        def choose_parent(sample, neighbors):\n            best_cost = float('inf')\n            best_node = None\n            for n in neighbors:\n                if not edge_in_obstacle(n.position, sample):\n                    c = n.cost + dist(n.position, sample)\n                    if c < best_cost:\n                        best_cost = c\n                        best_node = n\n            return best_node, best_cost\n\n        def rewire(new_node, neighbors):\n            for n in neighbors:\n                if n == new_node.parent:\n                    continue\n                edge_clear = not edge_in_obstacle(new_node.position, n.position)\n                cost_through_new = new_node.cost + dist(new_node.position, n.position)\n                if edge_clear and cost_through_new < n.cost:\n                    if n.parent:\n                        try:\n                            n.parent.children.remove(n)\n                        except ValueError:\n                            pass\n                    n.parent = new_node\n                    n.cost = cost_through_new\n                    new_node.add_child(n)\n\n        def extract_path(goal_node):\n            path = []\n            cur = goal_node\n            while cur:\n                path.append(cur.position)\n                cur = cur.parent\n            return path[::-1]\n\n        def shortcut_path(path):\n            # Attempt to shortcut path by removing unnecessary nodes\n            if len(path) < 3:\n                return path\n            shortened = [path[0]]\n            i = 0\n            while i < len(path) -1:\n                j = len(path) -1\n                while j > i +1:\n                    if not edge_in_obstacle(path[i], path[j]):\n                        break\n                    j -= 1\n                shortened.append(path[j])\n                i = j\n            return shortened\n\n        for _ in range(self.max_iter):\n            if random.random() < self.goal_sample_rate:\n                sample = goal_pos\n            else:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n\n            if in_obstacle(sample):\n                continue\n\n            nearest = min(nodes, key=lambda n: dist(n.position, sample))\n            new_pos = steer(nearest.position, sample)\n            if in_obstacle(new_pos):\n                continue\n            if edge_in_obstacle(nearest.position, new_pos):\n                continue\n\n            neighbors = near_nodes(new_pos)\n            parent_node, min_cost = choose_parent(new_pos, neighbors)\n            if parent_node is None:  # connect to nearest if none qualifies\n                parent_node = nearest\n                min_cost = nearest.cost + dist(nearest.position, new_pos)\n            new_node = Node(new_pos, parent=parent_node, cost=min_cost)\n            parent_node.add_child(new_node)\n            nodes.append(new_node)\n            edges.append((parent_node, new_node))\n\n            rewire(new_node, neighbors)\n\n            # Check if close enough to goal to create final node\n            to_goal_dist = dist(new_node.position, goal_pos)\n            if to_goal_dist <= self.step_size:\n                if (not in_obstacle(goal_pos)) and (not edge_in_obstacle(new_node.position, goal_pos)):\n                    goal_node = Node(goal_pos, parent=new_node, cost=new_node.cost + to_goal_dist)\n                    new_node.add_child(goal_node)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    success = True\n                    path = extract_path(goal_node)\n                    path = shortcut_path(path)\n                    return PlannerResult(True, path, nodes, edges)\n\n        return PlannerResult(False, [], nodes, edges)",
    "objective": 35.30902,
    "time_improvement": -125.0,
    "length_improvement": 17.0,
    "smoothness_improvement": 1744.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.0374014139175415,
            "num_nodes_avg": 283.5,
            "path_length_avg": 162.64312053605707,
            "smoothness_avg": 0.052195716980396344,
            "success_improvement": 0.0,
            "time_improvement": -44.81074424718635,
            "length_improvement": 10.852728389016736,
            "smoothness_improvement": 716.9763155567723,
            "objective_score": -3.346704662962002
        },
        {
            "map_id": 1,
            "success_rate": 0.9,
            "time_avg": 0.26899967193603513,
            "num_nodes_avg": 1207.6,
            "path_length_avg": 237.86297183831047,
            "smoothness_avg": 0.11220752657796407,
            "success_improvement": -9.999999999999998,
            "time_improvement": -65.30872026171215,
            "length_improvement": 20.59449349434243,
            "smoothness_improvement": 2787.180478665648,
            "objective_score": -43.30001758857994
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.17998433113098145,
            "num_nodes_avg": 659.1,
            "path_length_avg": 122.10681589258263,
            "smoothness_avg": 0.14367781975778113,
            "success_improvement": 0.0,
            "time_improvement": -264.1989335162749,
            "length_improvement": 18.902466985887397,
            "smoothness_improvement": 1727.5712621254859,
            "objective_score": -59.2803435527226
        }
    ],
    "success_rate": 0.9666666666666667
},
{
    "operator": "m3",
    "algorithm_description": "A single-tree RRT* with adaptive sampling and dynamic radius rewiring combined with path shortcutting to enhance planning speed, path length, and smoothness. The planner uses informed sampling biased towards the ellipsoidal region between start and goal after an initial solution is found, and dynamically adjusts rewiring radius based on node count to better optimize paths. Post-processing shortcutting is applied to the final path to reduce unnecessary detours.",
    "planning_mechanism": "The planner grows a single RRT* tree rooted at the start, uses goal biasing and informed elliptical sampling to concentrate search after an initial path is found, rewires neighbors within a radius that shrinks with tree size to optimize cost, and performs path shortcutting after planning to improve smoothness and length. It consistently checks node and edge validity against obstacles and respects map boundaries.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\nclass Planner:\n    def __init__(self, max_iter=4000, step_size=7.0, goal_sample_rate=0.1, gamma_rrt_star=50.0, resolution=1.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.gamma_rrt_star = gamma_rrt_star  # parameter controlling rewiring radius\n        self.resolution = resolution  # for edge collision checking\n\n    def plan(self, map):\n        import random\n        import math\n\n        bounds = map.size\n        dim = len(bounds)\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        is_3d = (dim == 3)\n\n        nodes = []\n        edges = []\n        root = Node(start)\n        nodes.append(root)\n        success = False\n        goal_node = None\n\n        # For ellipsoid informed sampling after first solution\n        c_best = float('inf')  # cost of best solution found\n        c_min = self._distance(start, goal)\n        x_center = tuple((start[d] + goal[d]) / 2 for d in range(dim))\n\n        # Helper to generate uniform random point in unit n-ball\n        def sample_unit_ball():\n            while True:\n                point = tuple(random.uniform(-1, 1) for _ in range(dim))\n                norm = math.sqrt(sum([p * p for p in point]))\n                if 0 < norm <= 1:\n                    return tuple(p / norm for p in point)\n\n        def informed_sample():\n            # If no solution yet, uniform sample\n            if c_best == float('inf'):\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            # Sample from ellipsoid defined by start and goal\n            # Following approach from Informed RRT*\n            a1 = tuple((goal[d] - start[d]) / c_min for d in range(dim))  # unit vector from start to goal\n            # Compute rotation matrix C that rotates first axis to a1\n            # Done via Householder reflection\n            e1 = [1.0] + [0.0] * (dim - 1)\n            v = [a1[d] - e1[d] for d in range(dim)]\n            s = math.sqrt(sum([vi * vi for vi in v]))\n            if s < 1e-10:\n                C = [[1.0 if i == j else 0.0 for j in range(dim)] for i in range(dim)]\n            else:\n                v = [vi / s for vi in v]\n                C = [[-2 * v[i] * v[j] if i != j else 1 - 2 * v[i] * v[j] for j in range(dim)] for i in range(dim)]\n            r1 = c_best / 2.0  # major axis radius\n            if dim >= 2:\n                r_others = math.sqrt(c_best * c_best - c_min * c_min) / 2.0\n            else:\n                r_others = 0.0\n            # Radii vector for axes\n            L = [r1] + [r_others] * (dim - 1)\n\n            # Sample random point in unit ball, scale and rotate\n            sample_ball = sample_unit_ball()\n            # Scale point\n            scaled = [sample_ball[i] * L[i] for i in range(dim)]\n            # Rotate point by C\n            rotated = [0.0] * dim\n            for i in range(dim):\n                s = 0.0\n                for j in range(dim):\n                    s += C[i][j] * scaled[j]\n                rotated[i] = s\n            # Translate to ellipsoid center\n            p = tuple(rotated[i] + x_center[i] for i in range(dim))\n            # Clamp to bounds if out of range\n            p_clamped = tuple(min(max(0.0, p[i]), bounds[i]) for i in range(dim))\n            return p_clamped\n\n        for iter in range(self.max_iter):\n            if random.random() < self.goal_sample_rate:\n                sample = goal\n            else:\n                sample = informed_sample()\n\n            nearest = self._nearest(nodes, sample)\n            new_pos = self._steer(nearest.position, sample, self.step_size)\n\n            # Check bounds\n            if any(new_pos[d] < 0.0 or new_pos[d] > bounds[d] for d in range(dim)):\n                continue\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d, self.resolution):\n                continue\n\n            # Create new node and initialize cost and parent using RRT* logic\n            new_node = Node(new_pos)\n            neighbors = self._near(nodes, new_pos, self._rewiring_radius(len(nodes), dim))\n            # Choose parent giving lowest cost path to new_node\n            min_cost = nearest.cost + self._distance(nearest.position, new_pos)\n            min_parent = nearest\n            for node in neighbors:\n                dist_to_new = self._distance(node.position, new_pos)\n                cost = node.cost + dist_to_new\n                if cost < min_cost and not self._is_edge_in_obstacle(node.position, new_pos, obstacles, is_3d, self.resolution):\n                    min_cost = cost\n                    min_parent = node\n            new_node.parent = min_parent\n            new_node.cost = min_cost\n            min_parent.add_child(new_node)\n            nodes.append(new_node)\n            edges.append((min_parent, new_node))\n\n            # Rewire neighbors if this new_node provides lower cost path\n            for node in neighbors:\n                if node == min_parent:\n                    continue\n                dist = self._distance(new_node.position, node.position)\n                new_cost = new_node.cost + dist\n                if new_cost < node.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, node.position, obstacles, is_3d, self.resolution):\n                        # Update parent-child relationships\n                        if node.parent:\n                            try:\n                                edges.remove((node.parent, node))\n                            except ValueError:\n                                pass\n                            if node in node.parent.children:\n                                node.parent.children.remove(node)\n                        node.parent = new_node\n                        node.cost = new_cost\n                        new_node.add_child(node)\n                        edges.append((new_node, node))\n\n            # Check if we can connect to goal directly for solution\n            dist_to_goal = self._distance(new_node.position, goal)\n            if dist_to_goal <= self.step_size:\n                if not self._is_edge_in_obstacle(new_node.position, goal, obstacles, is_3d, self.resolution) and not self._is_in_obstacle(goal, obstacles, is_3d):\n                    goal_node = Node(goal, parent=new_node, cost=new_node.cost + dist_to_goal)\n                    new_node.add_child(goal_node)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    success = True\n                    if goal_node.cost < c_best:\n                        c_best = goal_node.cost\n                    break\n\n        path = []\n        if success and goal_node is not None:\n            # Extract path from goal to start\n            current = goal_node\n            while current:\n                path.append(current.position)\n                current = current.parent\n            path = path[::-1]\n            path = self._shortcut_path(path, obstacles, is_3d)\n\n        return PlannerResult(success, path, nodes, edges)\n\n    def _nearest(self, nodes, point):\n        import math\n        return min(nodes, key=lambda node: math.dist(node.position, point))\n\n    def _near(self, nodes, point, radius):\n        import math\n        radsq = radius * radius\n        results = []\n        px, py = None, None\n        # Optimization to avoid repeated len, distance calls\n        for node in nodes:\n            # Early pruning with squared distance\n            d_sq = sum((node.position[i] - point[i]) ** 2 for i in range(len(point)))\n            if d_sq <= radsq:\n                results.append(node)\n        return results\n\n    def _steer(self, from_p, to_p, step_size):\n        import math\n        dist = self._distance(from_p, to_p)\n        if dist <= step_size:\n            return to_p\n        ratio = step_size / dist\n        return tuple(from_p[i] + (to_p[i] - from_p[i]) * ratio for i in range(len(from_p)))\n\n    def _distance(self, a, b):\n        import math\n        return math.dist(a, b)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, start_p, end_p, obstacles, is_3d, resolution):\n        import math\n        dist = self._distance(start_p, end_p)\n        steps = max(int(dist / resolution), 1)\n        for i in range(steps + 1):\n            interp = tuple(start_p[d] + (end_p[d] - start_p[d]) * (i / steps) for d in range(len(start_p)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _rewiring_radius(self, n, dim):\n        import math\n        # RRT* radius formula using gamma * (log(n)/n)^(1/d)\n        if n <= 1:\n            return float('inf')\n        from math import log\n        radius = min(self.gamma_rrt_star * (log(n) / n) ** (1 / dim), self.step_size * 5.0)\n        return radius\n\n    def _shortcut_path(self, path, obstacles, is_3d):\n        # Repeatedly try to shortcut between two nodes to remove intermediate points\n        if len(path) < 3:\n            return path\n        import random\n        max_attempts = max(50, len(path) * 5)\n        for _ in range(max_attempts):\n            if len(path) < 3:\n                break\n            i = random.randint(0, len(path) - 3)\n            j = random.randint(i + 2, len(path) - 1)\n            if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d, self.resolution):\n                # Shortcut possible, remove intermediate nodes\n                path = path[:i + 1] + path[j:]\n        return path",
    "objective": 54.41329,
    "time_improvement": -238.0,
    "length_improvement": 17.0,
    "smoothness_improvement": 1404.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.043636131286621097,
            "num_nodes_avg": 217.2,
            "path_length_avg": 168.666527582117,
            "smoothness_avg": 0.05273332461113374,
            "success_improvement": 0.0,
            "time_improvement": -68.95031459545683,
            "length_improvement": 7.55120354007871,
            "smoothness_improvement": 725.3910424114681,
            "objective_score": -12.527417042532482
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.2019017219543457,
            "num_nodes_avg": 679.5,
            "path_length_avg": 227.977801536768,
            "smoothness_avg": 0.08916900951698452,
            "success_improvement": 0.0,
            "time_improvement": -24.0749292915322,
            "length_improvement": 23.89444786984831,
            "smoothness_improvement": 2194.3828407135384,
            "objective_score": 18.086104138017017
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.3562834978103638,
            "num_nodes_avg": 559.7,
            "path_length_avg": 122.89733612085618,
            "smoothness_avg": 0.10939128752428735,
            "success_improvement": 0.0,
            "time_improvement": -620.9409236715871,
            "length_improvement": 18.37744109079621,
            "smoothness_improvement": 1291.449102884001,
            "objective_score": -168.79856693257838
        }
    ],
    "success_rate": 1.0
}
]