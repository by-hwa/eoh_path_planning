{
     "operator": "m3",
     "algorithm_description": "An improved bidirectional RRT* variant with simplified adaptive neighborhood radius, consistent incremental rewiring, and combined informed plus uniform sampling for balanced exploration. The planner applies strict collision checks on nodes and edges, optimizes parent selection to minimize path cost, and attempts connection between trees after each insertion. It leverages a unified rewiring radius calculation based on node density and iteration progress, integrates early stopping on improvement stagnation, and performs lightweight post-processing shortcutting to improve path quality and smoothness, achieving efficient planning, shorter path length, and smoother results while maintaining robustness and simplicity.",
     "planning_mechanism": "The planner grows two trees from start and goal positions in alternating iterations, sampling points biased towards an ellipsoidal informed subset once a solution is found to focus search. Nodes are added by steering towards samples within step size, selecting parents from neighbors that reduce path cost and maintain collision-free edges. Rewiring is done on neighbors with a unified adaptive radius that shrinks according to node count and iteration to refine local connectivity. After each added node, the planner attempts to connect the two trees to find feasible paths that are combined to update the best solution. Early stopping terminates planning after a number of iterations without improvement. A final random shortcutting pass reduces unnecessary detours for improved smoothness.",
     "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self,\n                 max_iter=4000,\n                 step_size=5.0,\n                 max_radius=25.0,\n                 min_radius=5.0,\n                 max_no_improve=60,\n                 shortcut_iter=120):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.max_radius = max_radius\n        self.min_radius = min_radius\n        self.max_no_improve = max_no_improve\n        self.shortcut_iter = shortcut_iter\n\n    def plan(self, map):\n        import math\n        import random\n        import time\n\n        bounds = map.size\n        dim = len(bounds)\n        start_pos = tuple(map.start)\n        goal_pos = tuple(map.goal)\n        obstacles = map.obstacles\n        is_3d = (dim == 3)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def in_obstacle(p):\n            px, py, pz = (p + (0, 0, 0))[:3]\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def edge_in_obstacle(a, b, res=1.0):\n            dist_ab = math.dist(a, b)\n            if dist_ab < 1e-12:\n                return False\n            steps = max(2, int(dist_ab / res))\n            for i in range(steps + 1):\n                interp = tuple(a[d] + (b[d] - a[d]) * i / steps for d in range(dim))\n                if in_obstacle(interp):\n                    return True\n            return False\n\n        def steer(frm, to):\n            dist_frm_to = math.dist(frm, to)\n            if dist_frm_to <= self.step_size:\n                return to\n            ratio = self.step_size / dist_frm_to\n            return tuple(frm[d] + (to[d] - frm[d]) * ratio for d in range(dim))\n\n        def adaptive_radius(node_count, iteration):\n            # Unified radius shrinking with node count and iteration progress\n            if node_count <= 1:\n                return self.max_radius\n            import math\n            gamma = self.max_radius\n            r = gamma * (math.log(node_count) / node_count) ** (1 / dim)\n            decay = max(self.min_radius / gamma, 1.0 - 0.95 * (iteration / self.max_iter))\n            return max(self.min_radius, min(r * decay, self.max_radius))\n\n        def neighbors(tree, point, radius):\n            radius_sq = radius * radius\n            res = []\n            px = point\n            for node in tree:\n                d_sq = 0.0\n                for i_ in range(dim):\n                    diff = node.position[i_] - px[i_]\n                    d_sq += diff * diff\n                    if d_sq > radius_sq:\n                        break\n                else:\n                    res.append(node)\n            return res\n\n        def choose_parent(tree, new_pos, iter_i):\n            n_nodes = len(tree)\n            r = adaptive_radius(n_nodes, iter_i)\n            nbrs = neighbors(tree, new_pos, r)\n            # filter valid parents with collision-free edge\n            valid_parents = []\n            for n in nbrs:\n                if edge_in_obstacle(n.position, new_pos):\n                    continue\n                valid_parents.append(n)\n            if not valid_parents:\n                # fallback: find nearest node with collision-free edge\n                nearest = None\n                nearest_dist = float('inf')\n                for n in tree:\n                    d = math.dist(n.position, new_pos)\n                    if d < nearest_dist and not edge_in_obstacle(n.position, new_pos):\n                        nearest = n\n                        nearest_dist = d\n                if nearest is None:\n                    return None, []\n                best_parent = nearest\n                cost = best_parent.cost + nearest_dist\n                new_node = Node(new_pos, parent=best_parent, cost=cost)\n                best_parent.add_child(new_node)\n                tree.append(new_node)\n                return new_node, []\n            # select parent minimizing cost\n            best_parent = None\n            min_cost = float('inf')\n            for p in valid_parents:\n                c = p.cost + math.dist(p.position, new_pos)\n                if c < min_cost:\n                    min_cost = c\n                    best_parent = p\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree.append(new_node)\n            return new_node, valid_parents\n\n        def rewire(pivot, nbrs):\n            for nb in nbrs:\n                if nb == pivot.parent:\n                    continue\n                dist_pivot_nb = math.dist(pivot.position, nb.position)\n                new_cost = pivot.cost + dist_pivot_nb\n                if new_cost + 1e-12 < nb.cost:\n                    if edge_in_obstacle(pivot.position, nb.position):\n                        continue\n                    # Rewire parent-child\n                    if nb.parent is not None:\n                        nb.parent.remove_child(nb)\n                    pivot.add_child(nb)\n                    nb.cost = new_cost\n\n        def attempt_connect(tree_from, node_to_connect):\n            if not tree_from:\n                return None\n            nearest = min(tree_from, key=lambda n: math.dist(n.position, node_to_connect.position))\n            dist_near = math.dist(nearest.position, node_to_connect.position)\n            if dist_near <= self.step_size:\n                if edge_in_obstacle(nearest.position, node_to_connect.position) or in_obstacle(node_to_connect.position):\n                    return None\n                new_node = Node(node_to_connect.position, parent=nearest, cost=nearest.cost + dist_near)\n                nearest.add_child(new_node)\n                tree_from.append(new_node)\n                return new_node\n            # incremental steering towards target\n            current = nearest\n            steps = int(math.ceil(dist_near / self.step_size))\n            for _ in range(steps):\n                new_pos = steer(current.position, node_to_connect.position)\n                if not in_bounds(new_pos) or in_obstacle(new_pos) or edge_in_obstacle(current.position, new_pos):\n                    return None\n                new_node = Node(new_pos, parent=current, cost=current.cost + math.dist(current.position, new_pos))\n                current.add_child(new_node)\n                tree_from.append(new_node)\n                current = new_node\n                if math.dist(current.position, node_to_connect.position) <= self.step_size:\n                    if edge_in_obstacle(current.position, node_to_connect.position) or in_obstacle(node_to_connect.position):\n                        return None\n                    final_node = Node(node_to_connect.position, parent=current,\n                                      cost=current.cost + math.dist(current.position, node_to_connect.position))\n                    current.add_child(final_node)\n                    tree_from.append(final_node)\n                    return final_node\n            return None\n\n        def sample_uniform():\n            return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        def sample_informed(c_best, c_min):\n            if c_best == float('inf') or c_min < 1e-12:\n                return sample_uniform()\n            center = tuple((start_pos[d] + goal_pos[d]) / 2 for d in range(dim))\n            unit_dir = []\n            for d in range(dim):\n                unit_dir.append((goal_pos[d] - start_pos[d]) / c_min)\n            r1 = c_best * 0.5\n            val = max(c_best * c_best - c_min * c_min, 0.0)\n            r_other = math.sqrt(val) * 0.5\n\n            if dim == 2:\n                a1 = unit_dir\n                a2 = (-a1[1], a1[0])\n                basis = (a1, a2)\n                radii = (r1, r_other)\n            else:\n                def cross(u, v):\n                    return (u[1] * v[2] - u[2] * v[1], u[2] * v[0] - u[0] * v[2], u[0] * v[1] - u[1] * v[0])\n\n                def norm(v):\n                    return math.sqrt(sum(x * x for x in v))\n\n                a1 = unit_dir\n                ref = (1, 0, 0) if abs(a1[0]) < 0.9 else (0, 1, 0)\n                b2 = cross(a1, ref)\n                n_b2 = norm(b2)\n                if n_b2 < 1e-12:\n                    ref = (0, 0, 1)\n                    b2 = cross(a1, ref)\n                    n_b2 = norm(b2)\n                b2 = tuple(x / n_b2 for x in b2)\n                b3 = cross(a1, b2)\n                basis = (a1, b2, b3)\n                radii = (r1, r_other, r_other)\n\n            def sample_unit_ball(dim):\n                while True:\n                    vec = [random.gauss(0, 1) for _ in range(dim)]\n                    nrm = math.sqrt(sum(v * v for v in vec))\n                    if nrm < 1e-12:\n                        continue\n                    vec = [v / nrm for v in vec]\n                    r = random.random() ** (1 / dim)\n                    return [v * r for v in vec]\n\n            u = sample_unit_ball(dim)\n            mapped = []\n            for d in range(dim):\n                val = center[d]\n                for i in range(dim):\n                    val += basis[i][d] * radii[i] * u[i]\n                val = max(0.0, min(val, bounds[d]))\n                mapped.append(val)\n            return tuple(mapped)\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path[:]\n            path = list(path)\n            for _ in range(self.shortcut_iter):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if not edge_in_obstacle(path[i], path[j]):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        best_path = []\n        best_cost = float('inf')\n        c_min = math.dist(start_pos, goal_pos)\n        found_solution = False\n        no_improve_count = 0\n\n        start_time = time.time()\n\n        for iter_i in range(self.max_iter):\n            if found_solution:\n                sample = sample_informed(best_cost, c_min)\n                # Occasionally sample uniform to avoid local minima\n                if random.random() < 0.15:\n                    sample = sample_uniform()\n            else:\n                sample = sample_uniform()\n\n            if not in_bounds(sample) or in_obstacle(sample):\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n                continue\n\n            tree_a, tree_b = (start_tree, goal_tree) if iter_i % 2 == 0 else (goal_tree, start_tree)\n\n            nearest_n = min(tree_a, key=lambda n: math.dist(n.position, sample))\n            new_pos = steer(nearest_n.position, sample)\n            if not in_bounds(new_pos) or in_obstacle(new_pos) or edge_in_obstacle(nearest_n.position, new_pos):\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n                continue\n\n            new_node, nbrs = choose_parent(tree_a, new_pos, iter_i)\n            if new_node is None:\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n                continue\n\n            rewire(new_node, nbrs)\n            nodes.append(new_node)\n            if new_node.parent:\n                edges.append((new_node.parent, new_node))\n\n            connect_node = attempt_connect(tree_b, new_node)\n            if connect_node is not None:\n                if iter_i % 2 == 0:\n                    path_a = new_node.path_from_root()\n                    path_b = connect_node.path_from_root()\n                else:\n                    path_a = connect_node.path_from_root()\n                    path_b = new_node.path_from_root()\n                if path_a and path_b and path_a[-1] == path_b[-1]:\n                    candidate_path = path_a + path_b[-2::-1]\n                else:\n                    candidate_path = path_a + path_b[::-1]\n\n                total_cost = 0.0\n                for i in range(len(candidate_path) - 1):\n                    total_cost += math.dist(candidate_path[i], candidate_path[i + 1])\n\n                if total_cost + 1e-9 < best_cost:\n                    best_cost = total_cost\n                    best_path = candidate_path\n                    found_solution = True\n                    no_improve_count = 0\n                else:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n            else:\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n\n        if found_solution and len(best_path) >= 3:\n            best_path = shortcut_path(best_path)\n\n        return PlannerResult(success=found_solution, path=best_path, nodes=nodes, edges=edges)",
     "objective": -32.09066,
     "time_improvement": 51.0,
     "length_improvement": 17.0,
     "smoothness_improvement": 1354.0,
     "other_inf": [
          {
               "map_id": 0,
               "success_rate": 1.0,
               "time_avg": 0.017293906211853026,
               "num_nodes_avg": 91.5,
               "path_length_avg": 161.730924310866,
               "smoothness_avg": 0.042930783900201136,
               "success_improvement": 0.0,
               "time_improvement": 28.788981008339842,
               "length_improvement": 11.352717594718152,
               "smoothness_improvement": 571.9599937275159,
               "objective_score": 18.308124827970424
          },
          {
               "map_id": 1,
               "success_rate": 1.0,
               "time_avg": 0.03642895221710205,
               "num_nodes_avg": 225.4,
               "path_length_avg": 238.2939143004422,
               "smoothness_avg": 0.0897730230727014,
               "success_improvement": 0.0,
               "time_improvement": 77.4385205476863,
               "length_improvement": 20.450632496491846,
               "smoothness_improvement": 2209.924544555513,
               "objective_score": 46.551558384978556
          },
          {
               "map_id": 2,
               "success_rate": 1.0,
               "time_avg": 0.02602849006652832,
               "num_nodes_avg": 208.0,
               "path_length_avg": 123.50286586657371,
               "smoothness_avg": 0.10841836272819716,
               "success_improvement": 0.0,
               "time_improvement": 47.439204641197854,
               "length_improvement": 17.97527706591856,
               "smoothness_improvement": 1279.073571291572,
               "objective_score": 31.41229548836835
          }
     ],
     "success_rate": 1.0
}