{
     "operator": "m3",
     "algorithm_description": "A simplified bidirectional RRT* planner with adaptive neighborhood radius, heuristic-informed sampling inside ellipsoidal bounds after first solution, and efficient rewiring that balances exploration and refinement. The algorithm alternates expansions between start and goal trees, prunes via cost-aware rewiring with radius scaled to tree size, and performs iterative shortcut smoothing on the result to improve path length and smoothness while limiting planning time with stagnation-based early stopping.",
     "planning_mechanism": "This planner grows two trees from start and goal, samples points uniformly initially, and after first solution focuses samples inside a heuristic ellipsoid bounding shorter solutions. Nodes are added using a steer function, parents are chosen among neighbors within a radius that decays adaptively with iteration count and tree size, and rewiring lowers path costs. Connection attempts bridge trees incrementally. Post planning applies iterative shortcut smoothing removing redundant points and reducing unnecessary detours, producing shorter, smoother paths faster than naive RRT*.",
     "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=4000, step_size=6.0, radius_max=25.0, radius_min=7.0, no_improve_limit=60, time_limit=25.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.radius_max = radius_max\n        self.radius_min = radius_min\n        self.no_improve_limit = no_improve_limit\n        self.time_limit = time_limit\n\n    def plan(self, map):\n        import time\n        import math\n        import random\n\n        bounds = map.size\n        dim = len(bounds)\n        start = tuple(map.start)\n        goal = tuple(map.goal)\n        obstacles = map.obstacles\n        is_3d = (dim == 3)\n\n        def in_bounds(p):\n            return all(0.0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def in_obstacle(p):\n            px, py, pz = (p + (0, 0, 0))[:3]\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    if x <= px <= x+w and y <= py <= y+h:\n                        return True\n            return False\n\n        def edge_in_obstacle(a, b, resolution=1.0):\n            dist = math.dist(a,b)\n            if dist < 1e-12:\n                return False\n            steps = max(3, int(dist/resolution))\n            for i in range(steps+1):\n                pt = tuple(a[d] + (b[d]-a[d]) * i/steps for d in range(dim))\n                if in_obstacle(pt):\n                    return True\n            return False\n\n        def steer(frm, to):\n            dist = math.dist(frm, to)\n            if dist <= self.step_size:\n                return to\n            ratio = self.step_size / dist\n            return tuple(frm[d] + (to[d]-frm[d]) * ratio for d in range(dim))\n\n        def adaptive_radius(n_nodes, iter_i):\n            if n_nodes < 2:\n                return self.radius_max\n            r = self.radius_max * ((math.log(n_nodes) / n_nodes) ** (1/dim))\n            decay = max(self.radius_min / self.radius_max, 1.0 - 0.9 * (iter_i / self.max_iter))\n            return max(self.radius_min, min(r * decay, self.radius_max))\n\n        def neighbors(tree, pos, radius):\n            r_sq = radius * radius\n            res = []\n            for node in tree:\n                d_sq = 0.0\n                for i in range(dim):\n                    diff = node.position[i] - pos[i]\n                    d_sq += diff*diff\n                    if d_sq > r_sq:\n                        break\n                else:\n                    res.append(node)\n            return res\n\n        def choose_parent(tree, new_pos, iter_i):\n            radius = adaptive_radius(len(tree), iter_i)\n            nbrs = neighbors(tree, new_pos, radius)\n            valid_parents = [n for n in nbrs if not edge_in_obstacle(n.position, new_pos)]\n            if not valid_parents:\n                # fallback nearest with collision\n                nearest = min((n for n in tree if not edge_in_obstacle(n.position, new_pos)), key=lambda n: math.dist(n.position, new_pos), default=None)\n                if nearest is None:\n                    return None, []\n                c = nearest.cost + math.dist(nearest.position, new_pos)\n                new_node = Node(new_pos, parent=nearest, cost=c)\n                nearest.add_child(new_node)\n                tree.append(new_node)\n                return new_node, []\n            best_parent = min(valid_parents, key=lambda n: n.cost + math.dist(n.position, new_pos))\n            c = best_parent.cost + math.dist(best_parent.position, new_pos)\n            new_node = Node(new_pos, parent=best_parent, cost=c)\n            best_parent.add_child(new_node)\n            tree.append(new_node)\n            return new_node, valid_parents\n\n        def rewire(pivot, nbrs):\n            for nb in nbrs:\n                if nb == pivot.parent:\n                    continue\n                dist_p = math.dist(pivot.position, nb.position)\n                new_cost = pivot.cost + dist_p\n                if new_cost + 1e-10 < nb.cost and not edge_in_obstacle(pivot.position, nb.position):\n                    if nb.parent:\n                        nb.parent.remove_child(nb)\n                    pivot.add_child(nb)\n                    nb.cost = new_cost\n\n        def attempt_connect(tree, target_node):\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda n: math.dist(n.position, target_node.position))\n            dist = math.dist(nearest.position, target_node.position)\n            if dist <= self.step_size:\n                if edge_in_obstacle(nearest.position, target_node.position) or in_obstacle(target_node.position):\n                    return None\n                new_node = Node(target_node.position, parent=nearest, cost=nearest.cost + dist)\n                nearest.add_child(new_node)\n                tree.append(new_node)\n                return new_node\n            current = nearest\n            steps = int(math.ceil(dist / self.step_size))\n            for _ in range(steps):\n                new_pos = steer(current.position, target_node.position)\n                if not in_bounds(new_pos) or in_obstacle(new_pos) or edge_in_obstacle(current.position, new_pos):\n                    return None\n                new_node = Node(new_pos, parent=current, cost=current.cost + math.dist(current.position, new_pos))\n                current.add_child(new_node)\n                tree.append(new_node)\n                current = new_node\n                if math.dist(current.position, target_node.position) <= self.step_size:\n                    if edge_in_obstacle(current.position, target_node.position) or in_obstacle(target_node.position):\n                        return None\n                    final_node = Node(target_node.position, parent=current, cost=current.cost + math.dist(current.position, target_node.position))\n                    current.add_child(final_node)\n                    tree.append(final_node)\n                    return final_node\n            return None\n\n        def sample_uniform():\n            return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        def sample_informed(c_best, c_min):\n            if c_best == float('inf') or c_min < 1e-12:\n                return sample_uniform()\n            center = tuple((start[d]+goal[d])*0.5 for d in range(dim))\n            unit_vec = []\n            for d in range(dim):\n                unit_vec.append((goal[d] - start[d]) / c_min)\n            r1 = c_best * 0.5\n            val = max(c_best*c_best - c_min*c_min, 0.0)\n            r_other = math.sqrt(val)*0.5\n\n            if dim == 2:\n                a1 = unit_vec\n                a2 = (-a1[1], a1[0])\n                basis = (a1, a2)\n                radii = (r1, r_other)\n            else:\n                def cross(u,v):\n                    return (u[1]*v[2]-u[2]*v[1], u[2]*v[0]-u[0]*v[2], u[0]*v[1]-u[1]*v[0])\n                def norm(v):\n                    return math.sqrt(sum(x*x for x in v))\n                a1 = unit_vec\n                ref = (1,0,0) if abs(a1[0]) < 0.9 else (0,1,0)\n                b2 = cross(a1, ref)\n                nb2 = norm(b2)\n                if nb2 < 1e-12:\n                    ref = (0,0,1)\n                    b2 = cross(a1, ref)\n                    nb2 = norm(b2)\n                b2 = tuple(x/nb2 for x in b2)\n                b3 = cross(a1,b2)\n                basis = (a1,b2,b3)\n                radii = (r1,r_other,r_other)\n\n            def sample_unit_ball(ndim):\n                while True:\n                    vec = [random.gauss(0,1) for _ in range(ndim)]\n                    nrm = math.sqrt(sum(v*v for v in vec))\n                    if nrm < 1e-12:\n                        continue\n                    vec = [v/nrm for v in vec]\n                    r = random.random()**(1/ndim)\n                    return [v*r for v in vec]\n\n            u = sample_unit_ball(dim)\n            mapped = []\n            for d in range(dim):\n                v = center[d]\n                for i in range(dim):\n                    v += basis[i][d]*radii[i]*u[i]\n                # Clamp to bounds\n                v = max(0.0, min(bounds[d], v))\n                mapped.append(v)\n            return tuple(mapped)\n\n        def shortcut_smooth(path, iterations=3):\n            if len(path) < 3:\n                return path[:]\n            for _ in range(iterations):\n                i = 0\n                while i < len(path)-2:\n                    if not edge_in_obstacle(path[i], path[i+2]):\n                        del path[i+1]\n                    else:\n                        i += 1\n            return path\n\n        start_node = Node(start, cost=0.0)\n        goal_node = Node(goal, cost=0.0)\n        start_tree = [start_node]\n        goal_tree = [goal_node]\n        nodes = [start_node, goal_node]\n        edges = []\n\n        best_path = []\n        best_cost = float('inf')\n        c_min = math.dist(start, goal)\n        found = False\n        no_improve = 0\n        t_start = time.time()\n\n        for i in range(self.max_iter):\n            if time.time() - t_start > self.time_limit:\n                break\n            if found:\n                sample = sample_informed(best_cost, c_min)\n                if random.random() < 0.1:\n                    sample = sample_uniform()\n            else:\n                sample = sample_uniform()\n\n            if not in_bounds(sample) or in_obstacle(sample):\n                if found:\n                    no_improve += 1\n                    if no_improve >= self.no_improve_limit:\n                        break\n                continue\n\n            tree_a, tree_b = (start_tree, goal_tree) if i%2 == 0 else (goal_tree, start_tree)\n\n            near = min(tree_a, key=lambda n: math.dist(n.position, sample))\n            new_pos = steer(near.position, sample)\n\n            if (not in_bounds(new_pos)) or in_obstacle(new_pos) or edge_in_obstacle(near.position, new_pos):\n                if found:\n                    no_improve += 1\n                    if no_improve >= self.no_improve_limit:\n                        break\n                continue\n\n            new_node, nbrs = choose_parent(tree_a, new_pos, i)\n            if new_node is None:\n                if found:\n                    no_improve += 1\n                    if no_improve >= self.no_improve_limit:\n                        break\n                continue\n\n            rewire(new_node, nbrs)\n            nodes.append(new_node)\n            if new_node.parent:\n                edges.append((new_node.parent, new_node))\n\n            connected = attempt_connect(tree_b, new_node)\n            if connected:\n                if i % 2 == 0:\n                    path1 = new_node.path_from_root()\n                    path2 = connected.path_from_root()\n                else:\n                    path1 = connected.path_from_root()\n                    path2 = new_node.path_from_root()\n                if path1 and path2 and path1[-1] == path2[-1]:\n                    candidate = path1 + path2[-2::-1]\n                else:\n                    candidate = path1 + path2[::-1]\n\n                cost_path = 0.0\n                for j in range(len(candidate)-1):\n                    cost_path += math.dist(candidate[j], candidate[j+1])\n\n                if cost_path + 1e-9 < best_cost:\n                    best_path = candidate\n                    best_cost = cost_path\n                    found = True\n                    no_improve = 0\n                else:\n                    no_improve += 1\n                    if no_improve >= self.no_improve_limit:\n                        break\n            else:\n                if found:\n                    no_improve += 1\n                    if no_improve >= self.no_improve_limit:\n                        break\n\n        if found and len(best_path) >= 3:\n            best_path = shortcut_smooth(best_path, iterations=5)\n\n        return PlannerResult(success=found, path=best_path, nodes=nodes, edges=edges)",
     "objective": -37.48589,
     "time_improvement": 65.0,
     "length_improvement": 16.0,
     "smoothness_improvement": 1704.0,
     "other_inf": [
          {
               "map_id": 0,
               "success_rate": 1.0,
               "time_avg": 0.015254044532775879,
               "num_nodes_avg": 101.3,
               "path_length_avg": 165.81254021340436,
               "smoothness_avg": 0.05533273154630356,
               "success_improvement": 0.0,
               "time_improvement": 37.18850781215486,
               "length_improvement": 9.115519241194,
               "smoothness_improvement": 766.0774056493822,
               "objective_score": 20.45625091660977
          },
          {
               "map_id": 1,
               "success_rate": 1.0,
               "time_avg": 0.021648097038269042,
               "num_nodes_avg": 222.5,
               "path_length_avg": 236.7791727604512,
               "smoothness_avg": 0.1135825828084687,
               "success_improvement": 0.0,
               "time_improvement": 86.59272181094168,
               "length_improvement": 20.956296821958638,
               "smoothness_improvement": 2822.561665889502,
               "objective_score": 52.6644029659052
          },
          {
               "map_id": 2,
               "success_rate": 1.0,
               "time_avg": 0.01422429084777832,
               "num_nodes_avg": 175.1,
               "path_length_avg": 124.63481867684409,
               "smoothness_avg": 0.1276752449373225,
               "success_improvement": 0.0,
               "time_improvement": 71.27608868346934,
               "length_improvement": 17.223487907137493,
               "smoothness_improvement": 1524.0196915964568,
               "objective_score": 39.337017807305585
          }
     ],
     "success_rate": 1.0
}