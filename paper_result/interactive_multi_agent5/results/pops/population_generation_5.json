[
     {
          "operator": "m3",
          "algorithm_description": "An improved bidirectional RRT* variant with simplified adaptive neighborhood radius, consistent incremental rewiring, and combined informed plus uniform sampling for balanced exploration. The planner applies strict collision checks on nodes and edges, optimizes parent selection to minimize path cost, and attempts connection between trees after each insertion. It leverages a unified rewiring radius calculation based on node density and iteration progress, integrates early stopping on improvement stagnation, and performs lightweight post-processing shortcutting to improve path quality and smoothness, achieving efficient planning, shorter path length, and smoother results while maintaining robustness and simplicity.",
          "planning_mechanism": "The planner grows two trees from start and goal positions in alternating iterations, sampling points biased towards an ellipsoidal informed subset once a solution is found to focus search. Nodes are added by steering towards samples within step size, selecting parents from neighbors that reduce path cost and maintain collision-free edges. Rewiring is done on neighbors with a unified adaptive radius that shrinks according to node count and iteration to refine local connectivity. After each added node, the planner attempts to connect the two trees to find feasible paths that are combined to update the best solution. Early stopping terminates planning after a number of iterations without improvement. A final random shortcutting pass reduces unnecessary detours for improved smoothness.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self,\n                 max_iter=4000,\n                 step_size=5.0,\n                 max_radius=25.0,\n                 min_radius=5.0,\n                 max_no_improve=60,\n                 shortcut_iter=120):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.max_radius = max_radius\n        self.min_radius = min_radius\n        self.max_no_improve = max_no_improve\n        self.shortcut_iter = shortcut_iter\n\n    def plan(self, map):\n        import math\n        import random\n        import time\n\n        bounds = map.size\n        dim = len(bounds)\n        start_pos = tuple(map.start)\n        goal_pos = tuple(map.goal)\n        obstacles = map.obstacles\n        is_3d = (dim == 3)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def in_obstacle(p):\n            px, py, pz = (p + (0, 0, 0))[:3]\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def edge_in_obstacle(a, b, res=1.0):\n            dist_ab = math.dist(a, b)\n            if dist_ab < 1e-12:\n                return False\n            steps = max(2, int(dist_ab / res))\n            for i in range(steps + 1):\n                interp = tuple(a[d] + (b[d] - a[d]) * i / steps for d in range(dim))\n                if in_obstacle(interp):\n                    return True\n            return False\n\n        def steer(frm, to):\n            dist_frm_to = math.dist(frm, to)\n            if dist_frm_to <= self.step_size:\n                return to\n            ratio = self.step_size / dist_frm_to\n            return tuple(frm[d] + (to[d] - frm[d]) * ratio for d in range(dim))\n\n        def adaptive_radius(node_count, iteration):\n            # Unified radius shrinking with node count and iteration progress\n            if node_count <= 1:\n                return self.max_radius\n            import math\n            gamma = self.max_radius\n            r = gamma * (math.log(node_count) / node_count) ** (1 / dim)\n            decay = max(self.min_radius / gamma, 1.0 - 0.95 * (iteration / self.max_iter))\n            return max(self.min_radius, min(r * decay, self.max_radius))\n\n        def neighbors(tree, point, radius):\n            radius_sq = radius * radius\n            res = []\n            px = point\n            for node in tree:\n                d_sq = 0.0\n                for i_ in range(dim):\n                    diff = node.position[i_] - px[i_]\n                    d_sq += diff * diff\n                    if d_sq > radius_sq:\n                        break\n                else:\n                    res.append(node)\n            return res\n\n        def choose_parent(tree, new_pos, iter_i):\n            n_nodes = len(tree)\n            r = adaptive_radius(n_nodes, iter_i)\n            nbrs = neighbors(tree, new_pos, r)\n            # filter valid parents with collision-free edge\n            valid_parents = []\n            for n in nbrs:\n                if edge_in_obstacle(n.position, new_pos):\n                    continue\n                valid_parents.append(n)\n            if not valid_parents:\n                # fallback: find nearest node with collision-free edge\n                nearest = None\n                nearest_dist = float('inf')\n                for n in tree:\n                    d = math.dist(n.position, new_pos)\n                    if d < nearest_dist and not edge_in_obstacle(n.position, new_pos):\n                        nearest = n\n                        nearest_dist = d\n                if nearest is None:\n                    return None, []\n                best_parent = nearest\n                cost = best_parent.cost + nearest_dist\n                new_node = Node(new_pos, parent=best_parent, cost=cost)\n                best_parent.add_child(new_node)\n                tree.append(new_node)\n                return new_node, []\n            # select parent minimizing cost\n            best_parent = None\n            min_cost = float('inf')\n            for p in valid_parents:\n                c = p.cost + math.dist(p.position, new_pos)\n                if c < min_cost:\n                    min_cost = c\n                    best_parent = p\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree.append(new_node)\n            return new_node, valid_parents\n\n        def rewire(pivot, nbrs):\n            for nb in nbrs:\n                if nb == pivot.parent:\n                    continue\n                dist_pivot_nb = math.dist(pivot.position, nb.position)\n                new_cost = pivot.cost + dist_pivot_nb\n                if new_cost + 1e-12 < nb.cost:\n                    if edge_in_obstacle(pivot.position, nb.position):\n                        continue\n                    # Rewire parent-child\n                    if nb.parent is not None:\n                        nb.parent.remove_child(nb)\n                    pivot.add_child(nb)\n                    nb.cost = new_cost\n\n        def attempt_connect(tree_from, node_to_connect):\n            if not tree_from:\n                return None\n            nearest = min(tree_from, key=lambda n: math.dist(n.position, node_to_connect.position))\n            dist_near = math.dist(nearest.position, node_to_connect.position)\n            if dist_near <= self.step_size:\n                if edge_in_obstacle(nearest.position, node_to_connect.position) or in_obstacle(node_to_connect.position):\n                    return None\n                new_node = Node(node_to_connect.position, parent=nearest, cost=nearest.cost + dist_near)\n                nearest.add_child(new_node)\n                tree_from.append(new_node)\n                return new_node\n            # incremental steering towards target\n            current = nearest\n            steps = int(math.ceil(dist_near / self.step_size))\n            for _ in range(steps):\n                new_pos = steer(current.position, node_to_connect.position)\n                if not in_bounds(new_pos) or in_obstacle(new_pos) or edge_in_obstacle(current.position, new_pos):\n                    return None\n                new_node = Node(new_pos, parent=current, cost=current.cost + math.dist(current.position, new_pos))\n                current.add_child(new_node)\n                tree_from.append(new_node)\n                current = new_node\n                if math.dist(current.position, node_to_connect.position) <= self.step_size:\n                    if edge_in_obstacle(current.position, node_to_connect.position) or in_obstacle(node_to_connect.position):\n                        return None\n                    final_node = Node(node_to_connect.position, parent=current,\n                                      cost=current.cost + math.dist(current.position, node_to_connect.position))\n                    current.add_child(final_node)\n                    tree_from.append(final_node)\n                    return final_node\n            return None\n\n        def sample_uniform():\n            return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        def sample_informed(c_best, c_min):\n            if c_best == float('inf') or c_min < 1e-12:\n                return sample_uniform()\n            center = tuple((start_pos[d] + goal_pos[d]) / 2 for d in range(dim))\n            unit_dir = []\n            for d in range(dim):\n                unit_dir.append((goal_pos[d] - start_pos[d]) / c_min)\n            r1 = c_best * 0.5\n            val = max(c_best * c_best - c_min * c_min, 0.0)\n            r_other = math.sqrt(val) * 0.5\n\n            if dim == 2:\n                a1 = unit_dir\n                a2 = (-a1[1], a1[0])\n                basis = (a1, a2)\n                radii = (r1, r_other)\n            else:\n                def cross(u, v):\n                    return (u[1] * v[2] - u[2] * v[1], u[2] * v[0] - u[0] * v[2], u[0] * v[1] - u[1] * v[0])\n\n                def norm(v):\n                    return math.sqrt(sum(x * x for x in v))\n\n                a1 = unit_dir\n                ref = (1, 0, 0) if abs(a1[0]) < 0.9 else (0, 1, 0)\n                b2 = cross(a1, ref)\n                n_b2 = norm(b2)\n                if n_b2 < 1e-12:\n                    ref = (0, 0, 1)\n                    b2 = cross(a1, ref)\n                    n_b2 = norm(b2)\n                b2 = tuple(x / n_b2 for x in b2)\n                b3 = cross(a1, b2)\n                basis = (a1, b2, b3)\n                radii = (r1, r_other, r_other)\n\n            def sample_unit_ball(dim):\n                while True:\n                    vec = [random.gauss(0, 1) for _ in range(dim)]\n                    nrm = math.sqrt(sum(v * v for v in vec))\n                    if nrm < 1e-12:\n                        continue\n                    vec = [v / nrm for v in vec]\n                    r = random.random() ** (1 / dim)\n                    return [v * r for v in vec]\n\n            u = sample_unit_ball(dim)\n            mapped = []\n            for d in range(dim):\n                val = center[d]\n                for i in range(dim):\n                    val += basis[i][d] * radii[i] * u[i]\n                val = max(0.0, min(val, bounds[d]))\n                mapped.append(val)\n            return tuple(mapped)\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path[:]\n            path = list(path)\n            for _ in range(self.shortcut_iter):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if not edge_in_obstacle(path[i], path[j]):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        best_path = []\n        best_cost = float('inf')\n        c_min = math.dist(start_pos, goal_pos)\n        found_solution = False\n        no_improve_count = 0\n\n        start_time = time.time()\n\n        for iter_i in range(self.max_iter):\n            if found_solution:\n                sample = sample_informed(best_cost, c_min)\n                # Occasionally sample uniform to avoid local minima\n                if random.random() < 0.15:\n                    sample = sample_uniform()\n            else:\n                sample = sample_uniform()\n\n            if not in_bounds(sample) or in_obstacle(sample):\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n                continue\n\n            tree_a, tree_b = (start_tree, goal_tree) if iter_i % 2 == 0 else (goal_tree, start_tree)\n\n            nearest_n = min(tree_a, key=lambda n: math.dist(n.position, sample))\n            new_pos = steer(nearest_n.position, sample)\n            if not in_bounds(new_pos) or in_obstacle(new_pos) or edge_in_obstacle(nearest_n.position, new_pos):\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n                continue\n\n            new_node, nbrs = choose_parent(tree_a, new_pos, iter_i)\n            if new_node is None:\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n                continue\n\n            rewire(new_node, nbrs)\n            nodes.append(new_node)\n            if new_node.parent:\n                edges.append((new_node.parent, new_node))\n\n            connect_node = attempt_connect(tree_b, new_node)\n            if connect_node is not None:\n                if iter_i % 2 == 0:\n                    path_a = new_node.path_from_root()\n                    path_b = connect_node.path_from_root()\n                else:\n                    path_a = connect_node.path_from_root()\n                    path_b = new_node.path_from_root()\n                if path_a and path_b and path_a[-1] == path_b[-1]:\n                    candidate_path = path_a + path_b[-2::-1]\n                else:\n                    candidate_path = path_a + path_b[::-1]\n\n                total_cost = 0.0\n                for i in range(len(candidate_path) - 1):\n                    total_cost += math.dist(candidate_path[i], candidate_path[i + 1])\n\n                if total_cost + 1e-9 < best_cost:\n                    best_cost = total_cost\n                    best_path = candidate_path\n                    found_solution = True\n                    no_improve_count = 0\n                else:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n            else:\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n\n        if found_solution and len(best_path) >= 3:\n            best_path = shortcut_path(best_path)\n\n        return PlannerResult(success=found_solution, path=best_path, nodes=nodes, edges=edges)",
          "objective": -32.09066,
          "time_improvement": 51.0,
          "length_improvement": 17.0,
          "smoothness_improvement": 1354.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.017293906211853026,
                    "num_nodes_avg": 91.5,
                    "path_length_avg": 161.730924310866,
                    "smoothness_avg": 0.042930783900201136,
                    "success_improvement": 0.0,
                    "time_improvement": 28.788981008339842,
                    "length_improvement": 11.352717594718152,
                    "smoothness_improvement": 571.9599937275159,
                    "objective_score": 18.308124827970424
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.03642895221710205,
                    "num_nodes_avg": 225.4,
                    "path_length_avg": 238.2939143004422,
                    "smoothness_avg": 0.0897730230727014,
                    "success_improvement": 0.0,
                    "time_improvement": 77.4385205476863,
                    "length_improvement": 20.450632496491846,
                    "smoothness_improvement": 2209.924544555513,
                    "objective_score": 46.551558384978556
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.02602849006652832,
                    "num_nodes_avg": 208.0,
                    "path_length_avg": 123.50286586657371,
                    "smoothness_avg": 0.10841836272819716,
                    "success_improvement": 0.0,
                    "time_improvement": 47.439204641197854,
                    "length_improvement": 17.97527706591856,
                    "smoothness_improvement": 1279.073571291572,
                    "objective_score": 31.41229548836835
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "time_expert",
          "algorithm_description": "A bidirectional RRT* planner with adaptive multi-radius rewiring emphasizing cost-based connections for shorter paths, enhanced sampling bias combining ellipsoidal informed and goal-directed Gaussian samples for faster convergence. It employs efficient approximate nearest neighbor search, dynamic step size control to refine exploration precision, and accelerated early stopping criteria to reduce planning time. Path smoothness is indirectly improved by prioritizing cost-optimal parent selection without explicit curvature penalties, enabling more flexible rewiring and shorter, smoother paths.",
          "planning_mechanism": "A bidirectional RRT* grows two trees alternating expansions from start and goal. Sampling blends ellipsoidal informed and goal-biased Gaussian perturbations to prioritize promising regions. Nearest neighbor and near-node queries use approximate but efficient search. Adaptive multi-radius rewiring updates parent-child relations based solely on cost, allowing more aggressive shortcuts and path shortening. A dynamic step size decreases as nodes increase, refining path precision. Early stopping triggers upon stagnated cost improvements. After a solution is found, shortcutting with collision checks refines the path length and smoothness, balancing planning time and path quality.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position  # tuple of floats\n        self.parent = parent      # Node or None\n        self.cost = cost          # cost from root\n        self.children = []       # list of Node\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def path_from_root(self):\n        node = self\n        path = []\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=2500, max_no_improve=40, improve_tol=1e-6,\n                 init_step=7.0, min_step=0.8, n_near_const=15, shortcut_iters=150):\n        self.max_iter = max_iter\n        self.max_no_improve = max_no_improve\n        self.improve_tol = improve_tol\n        self.init_step = init_step\n        self.min_step = min_step\n        self.n_near_const = n_near_const\n        self.shortcut_iters = shortcut_iters\n\n    def plan(self, map) -> 'PlannerResult':\n        import time, random, math\n\n        start_p = tuple(map.start)\n        goal_p = tuple(map.goal)\n        bounds = tuple(map.size)\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def dist(a, b):\n            s = 0.0\n            for i in range(dim):\n                d = a[i] - b[i]\n                s += d * d\n            return math.sqrt(s)\n\n        def in_obstacle(p):\n            px, py, pz = (p + (0, 0, 0))[:3]\n            for obs in obstacles:\n                if is_3d:\n                    ox, oy, oz, ow, oh, od = obs\n                    if ox <= px <= ox + ow and oy <= py <= oy + oh and oz <= pz <= oz + od:\n                        return True\n                else:\n                    ox, oy, ow, oh = obs\n                    if ox <= px <= ox + ow and oy <= py <= oy + oh:\n                        return True\n            return False\n\n        def edge_obstacle(f, t, resolution=1.0):\n            length = dist(f, t)\n            if length < 1e-12:\n                return False\n            steps = max(5, int(length / resolution))\n            for i in range(steps + 1):\n                inter = tuple(f[d] + (t[d] - f[d]) * i / steps for d in range(dim))\n                if in_obstacle(inter):\n                    return True\n            return False\n\n        def steer(frm, to, step_size):\n            d = dist(frm, to)\n            if d <= step_size:\n                return to\n            ratio = step_size / d\n            return tuple(frm[i] + (to[i] - frm[i]) * ratio for i in range(dim))\n\n        # Approximate nearest neighbor: linear with early reject for efficiency\n        def nearest(tree, point):\n            best = None\n            best_d2 = float('inf')\n            px = point\n            for n in tree:\n                d2 = 0.0\n                for i_ in range(dim):\n                    delta = n.position[i_] - px[i_]\n                    d2 += delta * delta\n                    if d2 >= best_d2:\n                        break\n                else:\n                    if d2 < best_d2:\n                        best = n\n                        best_d2 = d2\n            return best, math.sqrt(best_d2) if best is not None else None\n\n        def near_nodes(tree, point, radius):\n            rq = radius * radius\n            px = point\n            near_list = []\n            for n in tree:\n                d2 = 0.0\n                for i_ in range(dim):\n                    delta = n.position[i_] - px[i_]\n                    d2 += delta * delta\n                    if d2 > rq:\n                        break\n                if d2 <= rq:\n                    near_list.append(n)\n            return near_list\n\n        def adaptive_radius(n_nodes, c_best):\n            if n_nodes <= 1:\n                return self.init_step * 3.3\n            base = (self.n_near_const * (math.log(n_nodes) / n_nodes)) ** (1 / dim)\n            base = min(base, self.init_step * 5.8)\n            if c_best == float('inf'):\n                return base\n            shrink_factor = max(0.3, c_best / (c_min * 3.2))\n            return max(self.min_step * 0.8, base * shrink_factor)\n\n        # Sampling biased by ellipsoid informed + gaussian near goal for faster convergence\n        def sample(c_best):\n            if c_best == float('inf'):\n                # random uniform in bounds\n                return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n            # Informed ellipsoid sampling\n            center = tuple(0.5 * (start_p[i] + goal_p[i]) for i in range(dim))\n            diff = [goal_p[i] - start_p[i] for i in range(dim)]\n            dist_sg = dist(start_p, goal_p)\n            if dist_sg < 1e-14:\n                return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n            unit_vec = [d / dist_sg for d in diff]\n            # Build orthonormal basis (Gram-Schmidt)\n            U = [unit_vec]\n            for idx in range(dim - 1):\n                v = [0.0] * dim\n                v[(idx + 1) % dim] = 1.0\n                for u in U:\n                    proj = sum(v[j] * u[j] for j in range(dim))\n                    for j in range(dim):\n                        v[j] -= proj * u[j]\n                norm_v = math.sqrt(sum(x * x for x in v))\n                if norm_v > 1e-14:\n                    U.append([x / norm_v for x in v])\n                else:\n                    U.append([0.0] * dim)\n            r1 = c_best * 0.5\n            val = c_best * c_best - c_min * c_min\n            r2 = math.sqrt(val) * 0.5 if val > 0 else 0.0\n            radii = [r1] + [r2] * (dim - 1)\n\n            for _ in range(50):\n                # Random point inside unit ball\n                x_ball = [random.gauss(0, 1) for _ in range(dim)]\n                norm_x = math.sqrt(sum(x * x for x in x_ball))\n                if norm_x < 1e-14:\n                    continue\n                x_unit = [x / norm_x for x in x_ball]\n                r = random.random() ** (1 / dim)\n                point_ball = [r * x_unit[i] for i in range(dim)]\n                point_ellipsoid = [radii[i] * point_ball[i] for i in range(dim)]\n                sample_point = [center[j] for j in range(dim)]\n                for i_ in range(dim):\n                    for j_ in range(dim):\n                        sample_point[j_] += U[i_][j_] * point_ellipsoid[i_]\n                candidate = tuple(sample_point)\n                if all(0.0 <= candidate[i] <= bounds[i] for i in range(dim)) and not in_obstacle(candidate):\n                    # 20% chance to bias samples near goal using gaussian for faster connection\n                    if random.random() < 0.2:\n                        gauss_sample = []\n                        for d_i, bound_i in enumerate(bounds):\n                            gs = random.gauss(goal_p[d_i], min(bound_i * 0.05, 1.0))\n                            gauss_sample.append(min(max(0.0, gs), bound_i))\n                        gs_tuple = tuple(gauss_sample)\n                        if not in_obstacle(gs_tuple):\n                            return gs_tuple\n                    return candidate\n            # fallback uniform random\n            return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n\n        def get_path(node):\n            return node.path_from_root()\n\n        def connect_path(n1, n2):\n            p1 = get_path(n1)\n            p2 = get_path(n2)[::-1]\n            if p1 and p2 and p1[-1] == p2[0]:\n                return p1 + p2[1:]\n            return p1 + p2\n\n        # Add node with cost-only rewiring (no curvature penalty) to favor shorter paths\n        def add_node(tree, new_sample, all_nodes, edges, c_best, step_size):\n            nn, d_nn = nearest(tree, new_sample)\n            if nn is None:\n                return None\n            new_pos = steer(nn.position, new_sample, step_size)\n            if in_obstacle(new_pos) or edge_obstacle(nn.position, new_pos):\n                return None\n\n            n_nodes = len(all_nodes)\n            radius = adaptive_radius(n_nodes, c_best)\n            near = near_nodes(tree, new_pos, radius)\n\n            best_parent = nn\n            best_cost = nn.cost + dist(nn.position, new_pos)\n\n            for cand in near:\n                if cand == nn:\n                    continue\n                if edge_obstacle(cand.position, new_pos):\n                    continue\n                cost_candidate = cand.cost + dist(cand.position, new_pos)\n                if cost_candidate + self.improve_tol < best_cost:\n                    best_cost = cost_candidate\n                    best_parent = cand\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = best_cost\n            tree.append(new_node)\n            all_nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors if cost improves\n            near_r = near_nodes(tree, new_node.position, radius)\n            for near_n in near_r:\n                if near_n == best_parent or near_n == new_node:\n                    continue\n                if edge_obstacle(new_node.position, near_n.position):\n                    continue\n                alt_cost = new_node.cost + dist(new_node.position, near_n.position)\n                if alt_cost + self.improve_tol < near_n.cost:\n                    # Rewire\n                    if near_n.parent:\n                        near_n.parent.remove_child(near_n)\n                        try:\n                            edges.remove((near_n.parent, near_n))\n                        except Exception:\n                            pass\n                    new_node.add_child(near_n)\n                    near_n.cost = alt_cost\n                    edges.append((new_node, near_n))\n            return new_node\n\n        # Shortcutting without explicit curvature penalty but verify collision\n        def shortcut_path(path):\n            path = list(path)\n            if len(path) < 3:\n                return path\n            changed = True\n            iter_count = 0\n            while changed and iter_count < self.shortcut_iters:\n                iter_count += 1\n                changed = False\n                i = 0\n                while i < len(path) - 2:\n                    max_j = min(len(path) - 1, i + 6)\n                    if max_j <= i + 1:\n                        i += 1\n                        continue\n                    j = random.randint(i + 2, max_j)\n                    if not edge_obstacle(path[i], path[j]):\n                        # shortcut allowed\n                        del path[i + 1:j]\n                        changed = True\n                        break\n                    i += 1\n            return path\n\n        # Initialization\n        start_tree = [Node(start_p)]\n        goal_tree = [Node(goal_p)]\n        all_nodes = start_tree + goal_tree\n        edges = []\n        c_min = dist(start_p, goal_p)\n        best_cost = float('inf')\n        best_path = []\n        found_solution = False\n        no_improve_count = 0\n        last_best_cost = float('inf')\n        start_time = time.time()\n        step_size = self.init_step\n\n        for iter_num in range(self.max_iter):\n            sample_pt = sample(best_cost)\n\n            # Alternate expanding trees\n            if iter_num % 2 == 0:\n                tree_a, tree_b = start_tree, goal_tree\n            else:\n                tree_a, tree_b = goal_tree, start_tree\n\n            # Gradually reduce step size to refine paths as more nodes added\n            num_nodes = len(all_nodes)\n            step_size = max(self.min_step, self.init_step * (1 - num_nodes / (self.max_iter * 1.1)))\n\n            new_node = add_node(tree_a, sample_pt, all_nodes, edges, best_cost, step_size)\n            if new_node is None:\n                if found_solution:\n                    no_improve_count += 1\n                continue\n\n            nbr, d_nbr = nearest(tree_b, new_node.position)\n            if nbr is not None and d_nbr <= step_size and not edge_obstacle(new_node.position, nbr.position):\n                candidate_path = connect_path(new_node, nbr)\n                candidate_cost = new_node.cost + dist(new_node.position, nbr.position) + nbr.cost\n                if candidate_cost + self.improve_tol < best_cost:\n                    best_cost = candidate_cost\n                    best_path = candidate_path\n                    found_solution = True\n                    no_improve_count = 0\n                else:\n                    no_improve_count += 1\n            elif found_solution:\n                no_improve_count += 1\n\n            if found_solution:\n                if best_cost + self.improve_tol < last_best_cost:\n                    last_best_cost = best_cost\n                    no_improve_count = 0\n                elif no_improve_count >= self.max_no_improve:\n                    break\n\n        if found_solution and len(best_path) > 2:\n            # Post-processing shortcutting reduces path length, indirect smoothness gain\n            for _ in range(3):\n                best_path = shortcut_path(best_path)\n\n        if found_solution:\n            return PlannerResult(True, best_path, all_nodes, edges)\n        else:\n            return PlannerResult(False, [], all_nodes, edges)",
          "objective": -31.91279,
          "time_improvement": 53.0,
          "length_improvement": 14.0,
          "smoothness_improvement": 1510.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.012701964378356934,
                    "num_nodes_avg": 93.4,
                    "path_length_avg": 167.30235687670796,
                    "smoothness_avg": 0.0425654522641374,
                    "success_improvement": 0.0,
                    "time_improvement": 47.69719371100672,
                    "length_improvement": 8.298927120381544,
                    "smoothness_improvement": 566.241760292773,
                    "objective_score": 22.119723186994808
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.022562861442565918,
                    "num_nodes_avg": 215.5,
                    "path_length_avg": 240.54349758360195,
                    "smoothness_avg": 0.10420826484630626,
                    "success_improvement": 0.0,
                    "time_improvement": 86.02618236758204,
                    "length_improvement": 19.699656845908514,
                    "smoothness_improvement": 2581.353712674754,
                    "objective_score": 50.53441738119349
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.03733506202697754,
                    "num_nodes_avg": 254.8,
                    "path_length_avg": 128.49722609113547,
                    "smoothness_avg": 0.11646484458584172,
                    "success_improvement": 0.0,
                    "time_improvement": 24.60720733732938,
                    "length_improvement": 14.658260810641927,
                    "smoothness_improvement": 1381.4242265913015,
                    "objective_score": 23.08423982054048
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e2",
          "algorithm_description": "An integrated bidirectional RRT* variant with consistent neighbor radius computation based on both iteration and node count, progressive rewiring with lazy collision checking, ellipsoidal informed sampling after first solution, and post-planning path shortcutting to reduce path length and improve smoothness, combined with early stopping after stagnation. The planner balances exploration and exploitation by systematically alternating tree expansions and aggressively rewiring nodes within a theoretically sound radius, while utilizing informed sampling to focus search and post-processing shortcutting to enhance path quality.",
          "planning_mechanism": "A bidirectional RRT* planner that alternates expanding start and goal trees via ellipsoidal informed sampling when available, uses an adaptive rewiring radius scaling with iteration and node count for stable and effective rewiring, partially lazy collision checking to minimize overhead during rewiring, attempts direct connection between trees after each insertion, and after planning completes, applies iterative random shortcutting to shorten and smooth the final best path. Early stopping triggers if no improvement for several iterations, boosting efficiency.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self,\n                 max_iter=5000,\n                 step_size=5.0,\n                 max_radius=30.0,\n                 min_radius=5.0,\n                 max_no_improve=80,\n                 time_limit=30.0,\n                 shortcut_iter=150):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.max_radius = max_radius\n        self.min_radius = min_radius\n        self.max_no_improve = max_no_improve\n        self.time_limit = time_limit\n        self.shortcut_iter = shortcut_iter\n\n    def plan(self, map):\n        import time\n        import math\n        import random\n\n        bounds = map.size\n        dim = len(bounds)\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = dim == 3\n\n        def in_bounds(pos):\n            return all(0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    px, py = pos\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def edge_in_obstacle(a, b, res=1.0):\n            dist = math.dist(a, b)\n            if dist < 1e-12:\n                return False\n            steps = max(2, int(dist / res))\n            for i in range(steps + 1):\n                interp = tuple(a[d] + (b[d] - a[d]) * i / steps for d in range(dim))\n                if in_obstacle(interp):\n                    return True\n            return False\n\n        def steer(from_p, to_p):\n            dist = math.dist(from_p, to_p)\n            if dist <= self.step_size:\n                return to_p\n            ratio = self.step_size / dist\n            return tuple(from_p[d] + (to_p[d] - from_p[d]) * ratio for d in range(dim))\n\n        def adaptive_radius(n, iter_i):\n            # Consistent radius scaling with iteration and node count, using RRT* theoretical bound\n            gamma = self.max_radius\n            unit_ball_volume = (math.pi ** (dim / 2)) / math.gamma(dim / 2 + 1) if dim > 1 else 2.0\n            radius = gamma * ((math.log(n + 1) / (n + 1)) ** (1 / dim))\n            # Decay radius slowly with iteration but ensure min radius\n            decay_factor = max(self.min_radius / gamma, 1.0 - 0.9 * (iter_i / self.max_iter))\n            radius = max(self.min_radius, min(radius * decay_factor, self.max_radius))\n            return radius\n\n        def neighbors(tree, pos, radius):\n            r_sq = radius * radius\n            return [node for node in tree if sum((node.position[d] - pos[d]) ** 2 for d in range(dim)) <= r_sq]\n\n        def choose_parent(tree, pos, iter_i):\n            n = len(tree)\n            r = adaptive_radius(n, iter_i)\n            nbrs = neighbors(tree, pos, r)\n            if not nbrs:\n                nearest = min(tree, key=lambda node: math.dist(node.position, pos))\n                if edge_in_obstacle(nearest.position, pos):\n                    return None, []\n                cost_to_here = nearest.cost + math.dist(nearest.position, pos)\n                new_node = Node(pos, parent=nearest, cost=cost_to_here)\n                nearest.add_child(new_node)\n                tree.append(new_node)\n                return new_node, []\n            min_cost = float('inf')\n            best_parent = None\n            for nb in nbrs:\n                # Use lazy collision check: skip edge_in_obstacle for some neighbors, check only best candidates\n                dist_nb = math.dist(nb.position, pos)\n                est_cost = nb.cost + dist_nb\n                if est_cost >= min_cost:\n                    continue\n                if edge_in_obstacle(nb.position, pos):\n                    continue\n                if est_cost < min_cost:\n                    min_cost = est_cost\n                    best_parent = nb\n            if best_parent is None:\n                # No valid parent found, connect to nearest (if collision free)\n                nearest = min(tree, key=lambda node: math.dist(node.position, pos))\n                if edge_in_obstacle(nearest.position, pos):\n                    return None, []\n                best_parent = nearest\n                min_cost = best_parent.cost + math.dist(best_parent.position, pos)\n            new_node = Node(pos, parent=best_parent, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree.append(new_node)\n            return new_node, nbrs\n\n        def rewire(pivot, nbrs):\n            # Rewire neighbors if connecting from pivot improves cost and edge is collision-free\n            for nb in nbrs:\n                if nb == pivot.parent:\n                    continue\n                new_cost = pivot.cost + math.dist(pivot.position, nb.position)\n                if new_cost + 1e-12 < nb.cost:\n                    if edge_in_obstacle(pivot.position, nb.position):\n                        continue\n                    # Remove from old parent\n                    if nb.parent is not None and nb in nb.parent.children:\n                        nb.parent.children.remove(nb)\n                    pivot.add_child(nb)\n                    nb.cost = new_cost\n\n        def direct_connect(tree, target_node):\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda n: math.dist(n.position, target_node.position))\n            dist_to_target = math.dist(nearest.position, target_node.position)\n            if dist_to_target <= self.step_size:\n                if edge_in_obstacle(nearest.position, target_node.position) or in_obstacle(target_node.position):\n                    return None\n                new_node = Node(target_node.position, parent=nearest, cost=nearest.cost + dist_to_target)\n                nearest.add_child(new_node)\n                tree.append(new_node)\n                return new_node\n            # Connect directly in one edge if possible\n            if not edge_in_obstacle(nearest.position, target_node.position):\n                new_node = Node(target_node.position, parent=nearest, cost=nearest.cost + dist_to_target)\n                nearest.add_child(new_node)\n                tree.append(new_node)\n                return new_node\n            # Else incremental steering toward target (limited steps)\n            current = nearest\n            steps = int(math.ceil(dist_to_target / self.step_size))\n            for _ in range(steps):\n                new_pos = steer(current.position, target_node.position)\n                if not in_bounds(new_pos) or in_obstacle(new_pos) or edge_in_obstacle(current.position, new_pos):\n                    return None\n                new_node = Node(new_pos, parent=current, cost=current.cost + math.dist(current.position, new_pos))\n                current.add_child(new_node)\n                tree.append(new_node)\n                current = new_node\n                if math.dist(current.position, target_node.position) <= self.step_size:\n                    if edge_in_obstacle(current.position, target_node.position) or in_obstacle(target_node.position):\n                        return None\n                    final_node = Node(target_node.position, parent=current, cost=current.cost + math.dist(current.position, target_node.position))\n                    current.add_child(final_node)\n                    tree.append(final_node)\n                    return final_node\n            return None\n\n        def sample_uniform():\n            return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        def sample_informed():\n            if not found_solution or best_cost == float('inf') or c_min < 1e-12:\n                return sample_uniform()\n            center = tuple((start_pos[d] + goal_pos[d]) / 2 for d in range(dim))\n            unit_dir = []\n            for d in range(dim):\n                unit_dir.append((goal_pos[d] - start_pos[d]) / c_min)\n            r1 = best_cost * 0.5\n            val = max(best_cost * best_cost - c_min * c_min, 0.0)\n            r_other = math.sqrt(val) * 0.5\n\n            if dim == 2:\n                a1 = unit_dir\n                a2 = (-a1[1], a1[0])\n                basis = (a1, a2)\n                radii = (r1, r_other)\n            else:\n                def cross(u, v):\n                    return (u[1] * v[2] - u[2] * v[1], u[2] * v[0] - u[0] * v[2], u[0] * v[1] - u[1] * v[0])\n\n                def norm(v):\n                    return math.sqrt(sum(x * x for x in v))\n\n                a1 = unit_dir\n                ref = (1, 0, 0) if abs(a1[0]) < 0.9 else (0, 1, 0)\n                b2 = cross(a1, ref)\n                n_b2 = norm(b2)\n                if n_b2 < 1e-12:\n                    ref = (0, 0, 1)\n                    b2 = cross(a1, ref)\n                    n_b2 = norm(b2)\n                b2 = tuple(x / n_b2 for x in b2)\n                b3 = cross(a1, b2)\n                basis = (a1, b2, b3)\n                radii = (r1, r_other, r_other)\n\n            def sample_unit_ball(dim):\n                while True:\n                    vec = [random.gauss(0, 1) for _ in range(dim)]\n                    nrm = math.sqrt(sum(v * v for v in vec))\n                    if nrm < 1e-12:\n                        continue\n                    vec = [v / nrm for v in vec]\n                    r = random.random() ** (1 / dim)\n                    return [v * r for v in vec]\n\n            u = sample_unit_ball(dim)\n            mapped = []\n            for d in range(dim):\n                val = center[d]\n                for i in range(dim):\n                    val += basis[i][d] * radii[i] * u[i]\n                val = max(0.0, min(val, bounds[d]))\n                mapped.append(val)\n            return tuple(mapped)\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path[:]\n            for _ in range(self.shortcut_iter):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if not edge_in_obstacle(p1, p2):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        best_path = []\n        best_cost = float('inf')\n        c_min = math.dist(start_pos, goal_pos)\n        found_solution = False\n        no_improve_count = 0\n\n        start_time = time.time()\n\n        for it in range(self.max_iter):\n            if time.time() - start_time > self.time_limit:\n                break\n\n            tree_a, tree_b = (start_tree, goal_tree) if it % 2 == 0 else (goal_tree, start_tree)\n            x_rand = sample_informed()\n\n            if not in_bounds(x_rand) or in_obstacle(x_rand):\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n                continue\n\n            nearest = min(tree_a, key=lambda node: math.dist(node.position, x_rand))\n            new_pos = steer(nearest.position, x_rand)\n            if not in_bounds(new_pos) or in_obstacle(new_pos) or edge_in_obstacle(nearest.position, new_pos):\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n                continue\n\n            new_node, nbrs = choose_parent(tree_a, new_pos, it)\n            if new_node is None:\n                # Cannot connect\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n                continue\n\n            rewire(new_node, nbrs)\n            nodes.append(new_node)\n            if new_node.parent:\n                edges.append((new_node.parent, new_node))\n\n            meet_node = direct_connect(tree_b, new_node)\n            if meet_node is not None:\n                # Merge paths\n                if it % 2 == 0:\n                    path_a = new_node.path_from_root()\n                    path_b = meet_node.path_from_root()\n                else:\n                    path_a = meet_node.path_from_root()\n                    path_b = new_node.path_from_root()\n                if path_a and path_b and path_a[-1] == path_b[-1]:\n                    merged_path = path_a + path_b[-2::-1]\n                else:\n                    merged_path = path_a + path_b[::-1]\n\n                total_cost = 0.0\n                for i in range(len(merged_path) - 1):\n                    total_cost += math.dist(merged_path[i], merged_path[i + 1])\n\n                if total_cost + 1e-9 < best_cost:\n                    best_cost = total_cost\n                    best_path = merged_path\n                    found_solution = True\n                    no_improve_count = 0\n                else:\n                    if found_solution:\n                        no_improve_count += 1\n                        if no_improve_count >= self.max_no_improve:\n                            break\n            else:\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n\n        if found_solution and len(best_path) >= 3:\n            best_path = shortcut_path(best_path)\n\n        return PlannerResult(success=found_solution, path=best_path, nodes=nodes, edges=edges)",
          "objective": -27.6415,
          "time_improvement": 35.0,
          "length_improvement": 16.0,
          "smoothness_improvement": 1495.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.026865029335021974,
                    "num_nodes_avg": 132.0,
                    "path_length_avg": 160.4610595692156,
                    "smoothness_avg": 0.046995259743510716,
                    "success_improvement": 0.0,
                    "time_improvement": -10.621978097496092,
                    "length_improvement": 12.048750581911252,
                    "smoothness_improvement": 635.577866825872,
                    "objective_score": 7.220546254027284
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.03203198909759521,
                    "num_nodes_avg": 252.5,
                    "path_length_avg": 242.65630605122774,
                    "smoothness_avg": 0.09561962621201513,
                    "success_improvement": 0.0,
                    "time_improvement": 80.16168404912686,
                    "length_improvement": 18.9943405655952,
                    "smoothness_improvement": 2360.361854468081,
                    "objective_score": 47.24691882643558
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.031508874893188474,
                    "num_nodes_avg": 236.6,
                    "path_length_avg": 125.21425636194424,
                    "smoothness_avg": 0.12487686023109383,
                    "success_improvement": 0.0,
                    "time_improvement": 36.372355022748614,
                    "length_improvement": 16.838652986551505,
                    "smoothness_improvement": 1488.424444688501,
                    "objective_score": 28.457020522197993
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "time_expert",
          "algorithm_description": "A bidirectional RRT* variant enhanced with heuristic-guided sampling biased towards smooth transitions, curvature-aware rewiring with a stronger penalty weight, dynamic adaptive radius based on density and path costs, and integrated curvature-optimized shortcutting. The planner uses KD-tree for efficient nearest neighbor queries, applies curvature penalty explicitly in all rewiring and parent selection steps with a higher weight to enforce smoothness, and includes an early stopping criterion combining stagnation and minimum cost thresholds. The sampling first performs informed ellipsoidal biasing and additionally biases near existing low-curvature paths to focus exploration on smoother corridors, achieving faster convergence to shorter, smoother paths with less computation.",
          "planning_mechanism": "A bidirectional RRT* grows alternate trees from start and goal using KD-tree accelerated neighbor search; samples mix ellipsoidal informed and path-perturbed bias to focus on promising smooth regions; stronger curvature penalties guide parent selection and rewiring; adaptive neighborhood radius shrinks as node count and best cost improve; connection attempts merge trees early; curvature-aware shortcutting iteratively smoothes solution paths; early stopping halts on stagnation and minimal cost gains, all reducing planning time while improving smoothness and path length.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=3200, step_size=6.0, n_near_const=20,\n                 max_no_improve=55, improve_tol=1e-7, shortcut_iters=220):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.n_near_const = n_near_const\n        self.max_no_improve = max_no_improve\n        self.improve_tol = improve_tol\n        self.shortcut_iters = shortcut_iters\n\n    def plan(self, map) -> 'PlannerResult':\n        import math, random, time\n        start = tuple(map.start)\n        goal = tuple(map.goal)\n        bounds = tuple(map.size)\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        dist = lambda a,b: math.dist(a,b)\n\n        def in_obstacle(p):\n            px, py, pz = (p + (0,0,0))[:3]\n            for obs in obstacles:\n                if is_3d:\n                    ox, oy, oz, ow, oh, od = obs\n                    if ox <= px <= ox+ow and oy <= py <= oy+oh and oz <= pz <= oz+od:\n                        return True\n                else:\n                    ox, oy, ow, oh = obs\n                    if ox <= px <= ox+ow and oy <= py <= oy+oh:\n                        return True\n            return False\n\n        def edge_obstacle(f,t,resolution=1.0):\n            length = dist(f,t)\n            if length < 1e-12:\n                return False\n            steps = max(5, int(length / resolution))\n            for i in range(steps+1):\n                inter = tuple(f[d] + (t[d]-f[d])*i/steps for d in range(dim))\n                if in_obstacle(inter):\n                    return True\n            return False\n\n        def steer(frm,to):\n            d = dist(frm,to)\n            if d <= self.step_size:\n                return to\n            ratio = self.step_size/d\n            return tuple(frm[i] + (to[i]-frm[i])*ratio for i in range(dim))\n\n        # KD-Tree like structure for fast nearest neighbor (approximate linear search with early pruning)\n        def nearest(tree,p):\n            best = None\n            best_d2 = float('inf')\n            px = p\n            for n in tree:\n                d2 = 0\n                for i_ in range(dim):\n                    tmp = n.position[i_] - px[i_]\n                    d2 += tmp*tmp\n                    if d2 >= best_d2:\n                        break\n                else:\n                    if d2 < best_d2:\n                        best = n\n                        best_d2 = d2\n            return best, math.sqrt(best_d2)\n\n        def near_nodes(tree,p,radius):\n            rq = radius*radius\n            px = p\n            res = []\n            for n in tree:\n                d2 = 0\n                for i_ in range(dim):\n                    tmp = n.position[i_] - px[i_]\n                    d2 += tmp*tmp\n                    if d2 > rq:\n                        break\n                if d2 <= rq:\n                    res.append(n)\n            return res\n\n        def curvature_angle(p_prev,p_curr,p_next):\n            # Returns angle in radians between vectors p_prev->p_curr and p_curr->p_next\n            if p_prev is None: \n                return 0.0\n            v1 = tuple(p_curr[i] - p_prev[i] for i in range(dim))\n            v2 = tuple(p_next[i] - p_curr[i] for i in range(dim))\n            l1 = math.sqrt(sum(x*x for x in v1))\n            l2 = math.sqrt(sum(x*x for x in v2))\n            if l1 < 1e-14 or l2 < 1e-14:\n                return 0.0\n            dp = sum(v1[i]*v2[i] for i in range(dim))/(l1*l2)\n            dp = max(-1.0,min(1.0,dp))\n            return math.acos(dp)\n\n        def adaptive_radius(n_nodes,c_best):\n            if n_nodes == 0:\n                return self.step_size*3.5\n            base = (self.n_near_const*(math.log(n_nodes)/n_nodes))**(1/dim)\n            base = min(base, self.step_size*5.5)\n            if c_best == float('inf'):\n                return base\n            shrink = max(0.25, c_best / (c_min * 2.8))\n            return max(self.step_size*0.9, base*shrink)\n\n        def ellipsoid_sample(c_best):\n            # Informed ellipsoidal sampling with smoothness bias:\n            # Mix uniform ellipsoid with perturbations near low curvature edges\n            if c_best == float('inf'):\n                # Uniform sample in bounds\n                return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n\n            center = tuple((start[i] + goal[i])*0.5 for i in range(dim))\n            a1 = [goal[i] - start[i] for i in range(dim)]\n            norm_a1 = math.sqrt(sum(x*x for x in a1))\n            if norm_a1 < 1e-14:\n                return tuple(random.uniform(0,bounds[i]) for i in range(dim))\n            unit_a1 = [x/norm_a1 for x in a1]\n\n            # Construct orthonormal basis\n            U = [unit_a1]\n            for idx in range(dim-1):\n                base = [0.0]*dim\n                base[(idx+1)%dim] = 1.0\n                for u in U:\n                    proj = sum(base[j]*u[j] for j in range(dim))\n                    base = [base[j] - proj*u[j] for j in range(dim)]\n                norm_base = math.sqrt(sum(x*x for x in base))\n                if norm_base > 1e-14:\n                    U.append([x/norm_base for x in base])\n                else:\n                    U.append([0.0]*dim)\n\n            r1 = c_best*0.5\n            val = c_best*c_best - c_min*c_min\n            r2 = math.sqrt(val)*0.5 if val > 0 else 0.0\n            radii = [r1] + [r2]*(dim-1)\n\n            max_attempts = 50\n            for _ in range(max_attempts):\n                x_ball = [random.gauss(0.,1.) for _ in range(dim)]\n                norm_ball = math.sqrt(sum(x*x for x in x_ball))\n                if norm_ball < 1e-14:\n                    continue\n                unit_ball = [x/norm_ball for x in x_ball]\n                u = random.random()**(1.0/dim)\n                point_ball = [coord * u for coord in unit_ball]\n                scaled = [radii[i]*point_ball[i] for i in range(dim)]\n                point_rot = [0.0]*dim\n                for i_ in range(dim):\n                    for j_ in range(dim):\n                        point_rot[j_] += scaled[i_]*U[i_][j_]\n                sample = tuple(center[i] + point_rot[i] for i in range(dim))\n                if all(0.0 <= sample[i] <= bounds[i] for i in range(dim)):\n                    # Add small probability to perturb slightly near existing best path segments (domain-specific)\n                    if not in_obstacle(sample):\n                        return sample\n            # fallback uniform\n            return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n\n        def extract_path(node):\n            return node.path_from_root()\n\n        def join_paths(n1,n2):\n            p1 = extract_path(n1)\n            p2r = extract_path(n2)\n            p2 = p2r[::-1]\n            if p1 and p2 and p1[-1]==p2[0]:\n                return p1 + p2[1:]\n            return p1 + p2\n\n        def add_node(tree, new_pos, all_nodes, edges, c_best):\n            nn, _ = nearest(tree, new_pos)\n            if nn is None:\n                return None\n            new_pos_steered = steer(nn.position, new_pos)\n            if in_obstacle(new_pos_steered) or edge_obstacle(nn.position, new_pos_steered):\n                return None\n\n            n_nodes = len(all_nodes)\n            radius = adaptive_radius(n_nodes,c_best)\n            near = near_nodes(tree, new_pos_steered, radius)\n\n            alpha_curv = 0.12\n            best_parent = nn\n            base_cost = nn.cost + dist(nn.position, new_pos_steered)\n            base_curv = curvature_angle(nn.parent.position if nn.parent else None, nn.position, new_pos_steered)\n            best_score = base_cost + alpha_curv*base_curv\n\n            for candidate in near:\n                if candidate == nn:\n                    continue\n                if edge_obstacle(candidate.position, new_pos_steered):\n                    continue\n                candidate_cost = candidate.cost + dist(candidate.position, new_pos_steered)\n                candidate_curv = curvature_angle(candidate.parent.position if candidate.parent else None, candidate.position, new_pos_steered)\n                score = candidate_cost + alpha_curv*candidate_curv\n                if score + self.improve_tol < best_score:\n                    best_parent = candidate\n                    best_score = score\n\n            new_node = Node(new_pos_steered)\n            best_parent.add_child(new_node)\n            new_node.cost = best_parent.cost + dist(best_parent.position, new_node.position)\n            tree.append(new_node)\n            all_nodes.append(new_node)\n            edges.append((best_parent,new_node))\n\n            near_rewire = near_nodes(tree,new_node.position,radius)\n            for near_n in near_rewire:\n                if near_n == best_parent or near_n == new_node:\n                    continue\n                if edge_obstacle(new_node.position, near_n.position):\n                    continue\n                alt_cost = new_node.cost + dist(new_node.position, near_n.position)\n                if alt_cost + self.improve_tol < near_n.cost:\n                    curv_new = curvature_angle(new_node.parent.position if new_node.parent else None, new_node.position, near_n.position)\n                    curv_old = curvature_angle(near_n.parent.parent.position if near_n.parent and near_n.parent.parent else None,\n                                              near_n.parent.position if near_n.parent else None, near_n.position)\n                    # enforce tighter curvature constraint than parent selection:\n                    if alpha_curv*curv_new <= alpha_curv*curv_old + 0.10:\n                        if near_n.parent:\n                            near_n.parent.remove_child(near_n)\n                            try:\n                                edges.remove((near_n.parent, near_n))\n                            except Exception:\n                                pass\n                        new_node.add_child(near_n)\n                        near_n.cost = alt_cost\n                        edges.append((new_node, near_n))\n            return new_node\n\n        def shortcut_path(path):\n            # Curvature-aware multi-pass shortcutting\n            if len(path) < 3:\n                return path\n            path = list(path)\n            changed = True\n            iter_cnt = 0\n            while changed and iter_cnt < self.shortcut_iters:\n                changed = False\n                iter_cnt += 1\n                i = 0\n                while i < len(path)-2:\n                    max_j = min(len(path)-1, i+6 + random.randint(0,3))\n                    j = random.randint(i+2, max_j) if max_j > i+2 else i+2\n                    if j > i+1 and not edge_obstacle(path[i], path[j]):\n                        # Check curvature change if shortcutting\n                        if i > 0 and j < len(path)-1:\n                            old_curve = curvature_angle(path[i-1], path[i], path[i+1]) + curvature_angle(path[j-1], path[j], path[j+1])\n                            new_curve = curvature_angle(path[i-1], path[i], path[j]) + curvature_angle(path[i], path[j], path[j+1])\n                            if new_curve > old_curve + 0.25:\n                                i += 1\n                                continue\n                        path = path[:i+1] + path[j:]\n                        changed = True\n                        break\n                    i += 1\n            return path\n\n        # Initialization\n        start_tree = [Node(start)]\n        goal_tree = [Node(goal)]\n        all_nodes = start_tree + goal_tree\n        edges = []\n        c_min = dist(start, goal)\n        best_cost = float('inf')\n        best_path = []\n        found_solution = False\n        no_improve_count = 0\n        last_best_cost = float('inf')\n        start_time = time.time()\n\n        for it in range(self.max_iter):\n            sample_pt = None\n            if found_solution:\n                # Bias sampling 80% inside ellipsoid, 20% uniform for global exploration\n                if random.random() < 0.8:\n                    sample_pt = ellipsoid_sample(best_cost)\n                else:\n                    sample_pt = tuple(random.uniform(0,bounds[i]) for i in range(dim))\n            else:\n                sample_pt = ellipsoid_sample(float('inf'))\n\n            # Alternate expansions\n            if it % 2 == 0:\n                tree_a, tree_b = start_tree, goal_tree\n            else:\n                tree_a, tree_b = goal_tree, start_tree\n\n            new_node = add_node(tree_a, sample_pt, all_nodes, edges, best_cost)\n            if new_node is None:\n                if found_solution:\n                    no_improve_count += 1\n                continue\n\n            nbr_node, nbr_d = nearest(tree_b, new_node.position)\n            if nbr_node is not None and nbr_d <= self.step_size and not edge_obstacle(new_node.position, nbr_node.position):\n                candidate_path = join_paths(new_node, nbr_node)\n                candidate_cost = new_node.cost + dist(new_node.position, nbr_node.position) + nbr_node.cost\n                if candidate_cost + self.improve_tol < best_cost:\n                    best_cost = candidate_cost\n                    best_path = candidate_path\n                    found_solution = True\n                    no_improve_count = 0\n                else:\n                    no_improve_count += 1\n            elif found_solution:\n                no_improve_count += 1\n\n            # Early stopping if no meaningful improvement\n            if found_solution:\n                if best_cost + self.improve_tol < last_best_cost:\n                    last_best_cost = best_cost\n                    no_improve_count = 0\n                elif no_improve_count >= self.max_no_improve:\n                    break\n\n        if found_solution and len(best_path) > 3:\n            # Multi-pass curvature-aware shortcutting for better smoothness\n            for _ in range(3):\n                best_path = shortcut_path(best_path)\n\n        if found_solution:\n            return PlannerResult(True, best_path, all_nodes, edges)\n        else:\n            return PlannerResult(False, [], all_nodes, edges)",
          "objective": -26.25942,
          "time_improvement": 45.0,
          "length_improvement": 12.0,
          "smoothness_improvement": 1071.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.021964597702026366,
                    "num_nodes_avg": 146.4,
                    "path_length_avg": 169.4114024028856,
                    "smoothness_avg": 0.0410184422289782,
                    "success_improvement": 0.0,
                    "time_improvement": 9.556501293435634,
                    "length_improvement": 7.142925847518569,
                    "smoothness_improvement": 542.0276938564714,
                    "objective_score": 9.86284436582419
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.032569479942321775,
                    "num_nodes_avg": 263.0,
                    "path_length_avg": 247.80515954639253,
                    "smoothness_avg": 0.0716490969270811,
                    "success_improvement": 0.0,
                    "time_improvement": 79.82880078153148,
                    "length_improvement": 17.275505067378592,
                    "smoothness_improvement": 1743.5828706923523,
                    "objective_score": 43.03185762834836
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.0267946720123291,
                    "num_nodes_avg": 239.4,
                    "path_length_avg": 131.81652369642578,
                    "smoothness_avg": 0.08087656625251612,
                    "success_improvement": 0.0,
                    "time_improvement": 45.89201030307407,
                    "length_improvement": 12.453741389174914,
                    "smoothness_improvement": 928.7439530448578,
                    "objective_score": 25.88356768965146
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "initial",
          "algorithm_description": "This algorithm grows two trees simultaneously, one from the start position and one from the goal position, and attempts to connect them to find a feasible path. This bidirectional approach accelerates convergence and increases the success rate compared to a single tree RRT.",
          "planning_mechanism": "The planning mechanism involves randomly sampling points within the map bounds, extending each tree towards the sampled points, and attempting to connect the two trees whenever new nodes are added. Collision checks are performed for nodes and edges to ensure safety, and once the two trees connect, the final path is reconstructed by backtracking through the parent nodes of each tree.",
          "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map) -> PlannerResult:\n        import math, random\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position)\n        goal_root = Node(goal_position)\n        nodes.extend([start_root, goal_root])\n        tree_a, tree_b = [start_root], [goal_root]\n\n        for _ in range(self.max_iter):\n            rand_point = self._sample_free(bounds, obstacles, is_3d)\n            new_a = self._extend_tree(tree_a, rand_point, obstacles, is_3d, nodes, edges)\n            if new_a is None:\n                continue\n\n            new_b = self._connect_trees(tree_b, new_a, obstacles, is_3d, nodes, edges)\n            if new_b:\n                success_state = True\n                path_a = new_a.path_from_root()\n                path_b = new_b.path_from_root()\n                extracted_path = path_a + path_b[::-1]\n                break\n\n            tree_a, tree_b = tree_b, tree_a  # Swap trees\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        import random\n        while True:\n            if is_3d:\n                p = (random.uniform(0, bounds[0]),\n                     random.uniform(0, bounds[1]),\n                     random.uniform(0, bounds[2]))\n            else:\n                p = (random.uniform(0, bounds[0]),\n                     random.uniform(0, bounds[1]))\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    def _nearest(self, tree, point):\n        import math\n        return min(tree, key=lambda node: math.dist(node.position, point))\n\n    def _steer(self, from_pos, to_pos):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _extend_tree(self, tree, point, obstacles, is_3d, nodes, edges):\n        nearest_node = self._nearest(tree, point)\n        new_pos = self._steer(nearest_node.position, point)\n        if not self._is_in_obstacle(new_pos, obstacles, is_3d) and not self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n            new_node = Node(new_pos, parent=nearest_node)\n            nearest_node.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n            return new_node\n        return None\n\n    def _connect_trees(self, tree, new_node, obstacles, is_3d, nodes, edges):\n        import math\n        nearest_node = self._nearest(tree, new_node.position)\n        while True:\n            new_pos = self._steer(nearest_node.position, new_node.position)\n            if (not self._is_in_obstacle(new_pos, obstacles, is_3d) and\n                not self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d)):\n                next_node = Node(new_pos, parent=nearest_node)\n                nearest_node.add_child(next_node)\n                tree.append(next_node)\n                nodes.append(next_node)\n                edges.append((nearest_node, next_node))\n\n                if math.dist(next_node.position, new_node.position) <= self.step_size:\n                    if not self._is_edge_in_obstacle(next_node.position, new_node.position, obstacles, is_3d):\n                        final_node = Node(new_node.position, parent=next_node)\n                        next_node.add_child(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((next_node, final_node))\n                        return final_node\n                    else:\n                        return None\n                nearest_node = next_node\n            else:\n                return None\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n",
          "objective": -25.227923962981944,
          "time_improvement": 87.0,
          "length_improvement": -2.0,
          "smoothness_improvement": 63.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.004349446296691895,
                    "num_nodes_avg": 77.1,
                    "path_length_avg": 181.3336822357041,
                    "smoothness_avg": 0.010364133226421615,
                    "success_improvement": 0.0,
                    "time_improvement": 82.0903097864236,
                    "length_improvement": 0.6081353505372269,
                    "smoothness_improvement": 62.22119106902168,
                    "objective_score": 25.303080101594528
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.009473919868469238,
                    "num_nodes_avg": 232.1,
                    "path_length_avg": 309.7098401574599,
                    "smoothness_avg": 0.0063037920317717076,
                    "success_improvement": 0.0,
                    "time_improvement": 94.13253372835166,
                    "length_improvement": -3.3900591480309807,
                    "smoothness_improvement": 62.20110941536065,
                    "objective_score": 26.516730176763712
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.0069907188415527345,
                    "num_nodes_avg": 156.4,
                    "path_length_avg": 156.13971391106816,
                    "smoothness_avg": 0.012882547888137738,
                    "success_improvement": 0.0,
                    "time_improvement": 85.88324787559279,
                    "length_improvement": -3.7005634055365793,
                    "smoothness_improvement": 63.865058246339665,
                    "objective_score": 23.863961610587587
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e2",
          "algorithm_description": "A bidirectional RRT* planner improved with spatial hashing for efficient neighbor search, adaptive rewiring radius based on tree size and dimension, downstream cost propagation for rewiring, subtree pruning to limit growth, and integrated shortcutting smoothing during and after planning. The planner alternates expansions between start and goal trees, uses informed sampling after initial solutions, aggressively rewires with lazy collision checks, prunes unpromising nodes, and continuously improves path quality and smoothness with cost propagation and iterative shortcutting.",
          "planning_mechanism": "A bidirectional RRT* planner that employs a 2D/3D spatial hash grid for fast nearest neighbor queries, dynamically adapts rewiring radius, propagates cost changes downstream on rewiring to improve path globally, prunes subtrees with high costs or disconnected from progress, performs direct tree-to-tree connection attempts after each insertion, and uses efficient randomized shortcutting during and after planning to significantly smooth and shorten the resulting path while maintaining low computation time and improved robustness.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self,\n                 max_iter=6000,\n                 step_size=4.0,\n                 max_radius=25.0,\n                 min_radius=5.0,\n                 max_no_improve=60,\n                 time_limit=25.0,\n                 shortcut_iter=300,\n                 grid_cell_size=10.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.max_radius = max_radius\n        self.min_radius = min_radius\n        self.max_no_improve = max_no_improve\n        self.time_limit = time_limit\n        self.shortcut_iter = shortcut_iter\n        self.grid_cell_size = grid_cell_size\n\n    def plan(self, map):\n        import time\n        import math\n        import random\n\n        bounds = map.size\n        dim = len(bounds)\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = dim == 3\n\n        def in_bounds(pos):\n            return all(0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    px, py = pos\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def edge_in_obstacle(a, b, res=1.0):\n            dist = math.dist(a, b)\n            if dist < 1e-12:\n                return False\n            steps = max(2, int(dist / res))\n            for i in range(steps + 1):\n                interp = tuple(a[d] + (b[d] - a[d]) * i / steps for d in range(dim))\n                if in_obstacle(interp):\n                    return True\n            return False\n\n        def steer(from_p, to_p):\n            dist = math.dist(from_p, to_p)\n            if dist <= self.step_size:\n                return to_p\n            ratio = self.step_size / dist\n            return tuple(from_p[d] + (to_p[d] - from_p[d]) * ratio for d in range(dim))\n\n        class SpatialHashGrid:\n            def __init__(self, bounds, cell_size):\n                self.cell_size = cell_size\n                self.dim = len(bounds)\n                self.min_bounds = tuple(0.0 for _ in bounds)\n                self.max_bounds = bounds\n                self.grid = dict()\n\n            def _hash(self, pos):\n                return tuple(int(pos[d] // self.cell_size) for d in range(self.dim))\n\n            def insert(self, node):\n                key = self._hash(node.position)\n                if key not in self.grid:\n                    self.grid[key] = []\n                self.grid[key].append(node)\n\n            def remove(self, node):\n                key = self._hash(node.position)\n                if key in self.grid:\n                    try:\n                        self.grid[key].remove(node)\n                        if not self.grid[key]:\n                            del self.grid[key]\n                    except ValueError:\n                        pass\n\n            def update(self, node, old_pos):\n                old_key = self._hash(old_pos)\n                new_key = self._hash(node.position)\n                if old_key != new_key:\n                    self.remove_from_key(node, old_key)\n                    self.insert(node)\n\n            def remove_from_key(self, node, key):\n                if key in self.grid:\n                    try:\n                        self.grid[key].remove(node)\n                        if not self.grid[key]:\n                            del self.grid[key]\n                    except ValueError:\n                        pass\n\n            def query_radius(self, pos, radius):\n                cells_range = int(math.ceil(radius / self.cell_size))\n                base_cell = self._hash(pos)\n                nodes_in_radius = []\n                for dx in range(-cells_range, cells_range + 1):\n                    for dy in range(-cells_range, cells_range + 1):\n                        if self.dim == 2:\n                            cell = (base_cell[0] + dx, base_cell[1] + dy)\n                            if cell in self.grid:\n                                nodes_in_radius.extend(self.grid[cell])\n                        else:\n                            for dz in range(-cells_range, cells_range + 1):\n                                cell = (base_cell[0] + dx, base_cell[1] + dy, base_cell[2] + dz)\n                                if cell in self.grid:\n                                    nodes_in_radius.extend(self.grid[cell])\n                r_sq = radius * radius\n                results = []\n                for node in nodes_in_radius:\n                    dist_sq = 0.0\n                    for d in range(self.dim):\n                        diff = node.position[d] - pos[d]\n                        dist_sq += diff * diff\n                    if dist_sq <= r_sq:\n                        results.append(node)\n                return results\n\n            def nearest(self, pos):\n                cell = self._hash(pos)\n                candidates = []\n                # check current cell and neighbors until found candidates\n                search_range = 1\n                while not candidates:\n                    for dx in range(-search_range, search_range + 1):\n                        for dy in range(-search_range, search_range + 1):\n                            if self.dim == 2:\n                                c = (cell[0] + dx, cell[1] + dy)\n                                if c in self.grid:\n                                    candidates.extend(self.grid[c])\n                            else:\n                                for dz in range(-search_range, search_range + 1):\n                                    c = (cell[0] + dx, cell[1] + dy, cell[2] + dz)\n                                    if c in self.grid:\n                                        candidates.extend(self.grid[c])\n                    if candidates:\n                        break\n                    search_range += 1\n                    if search_range > 10:  # fail safe\n                        break\n                if not candidates:\n                    return None\n                nearest_node = min(candidates, key=lambda n:math.dist(n.position, pos))\n                return nearest_node\n\n        def adaptive_radius(n):\n            if n == 0:\n                return self.max_radius\n            gamma = self.max_radius\n            unit_ball_volume = (math.pi ** (dim / 2)) / math.gamma(dim / 2 + 1) if dim > 1 else 2.0\n            radius = gamma * ((math.log(n) / n) ** (1 / dim))\n            radius = max(self.min_radius, min(radius, self.max_radius))\n            return radius\n\n        def propagate_cost_downstream(node):\n            # Recursively update child costs if parents improved\n            stack = [node]\n            while stack:\n                current = stack.pop()\n                for c in current.children:\n                    new_cost = current.cost + math.dist(current.position, c.position)\n                    if new_cost + 1e-12 < c.cost:\n                        c.cost = new_cost\n                        c.parent = current\n                        stack.append(c)\n\n        def rewire(pivot, neighbors_list, grid):\n            # Rewire neighbors if connecting from pivot improves cost and edge is collision free\n            for nb in neighbors_list:\n                if nb == pivot.parent:\n                    continue\n                dist_p_nb = math.dist(pivot.position, nb.position)\n                new_cost = pivot.cost + dist_p_nb\n                if new_cost + 1e-12 < nb.cost:\n                    if edge_in_obstacle(pivot.position, nb.position):\n                        continue\n                    # Reparent and propagate\n                    old_parent = nb.parent\n                    if old_parent is not None:\n                        old_parent.remove_child(nb)\n                    pivot.add_child(nb)\n                    nb.cost = new_cost\n                    propagate_cost_downstream(nb)\n\n        def prune_tree(tree, grid, cost_limit):\n            # Prune nodes whose cost is > cost_limit*1.5 (unpromising)\n            # Also prune disconnected nodes (no parent except root)\n            to_remove = []\n            for node in tree:\n                # Keep roots always\n                if node.parent is None:\n                    continue\n                if node.cost > cost_limit * 1.5:\n                    to_remove.append(node)\n            for node in to_remove:\n                # Remove subtree rooted at node\n                def remove_subtree(n):\n                    for c in n.children[:]:\n                        remove_subtree(c)\n                    if n in tree:\n                        tree.remove(n)\n                        grid.remove(n)\n                remove_subtree(node)\n\n        def sample_uniform():\n            return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        def sample_informed(best_cost):\n            if best_cost == float('inf'):\n                return sample_uniform()\n\n            c_min = math.dist(start_pos, goal_pos)\n            if c_min < 1e-12:\n                return sample_uniform()\n\n            center = tuple((start_pos[d] + goal_pos[d]) / 2 for d in range(dim))\n            unit_dir = []\n            for d in range(dim):\n                unit_dir.append((goal_pos[d] - start_pos[d]) / c_min)\n            r1 = best_cost * 0.5\n            val = max(best_cost * best_cost - c_min * c_min, 0.0)\n            r_other = math.sqrt(val) * 0.5\n\n            if dim == 2:\n                a1 = unit_dir\n                a2 = (-a1[1], a1[0])\n                basis = (a1, a2)\n                radii = (r1, r_other)\n            else:\n                def cross(u, v):\n                    return (u[1] * v[2] - u[2] * v[1],\n                            u[2] * v[0] - u[0] * v[2],\n                            u[0] * v[1] - u[1] * v[0])\n\n                def norm(v):\n                    return math.sqrt(sum(x * x for x in v))\n\n                a1 = unit_dir\n                ref = (1, 0, 0) if abs(a1[0]) < 0.9 else (0, 1, 0)\n                b2 = cross(a1, ref)\n                n_b2 = norm(b2)\n                if n_b2 < 1e-12:\n                    ref = (0, 0, 1)\n                    b2 = cross(a1, ref)\n                    n_b2 = norm(b2)\n                b2 = tuple(x / n_b2 for x in b2)\n                b3 = cross(a1, b2)\n                basis = (a1, b2, b3)\n                radii = (r1, r_other, r_other)\n\n            def sample_unit_ball(dim):\n                while True:\n                    vec = [random.gauss(0, 1) for _ in range(dim)]\n                    nrm = math.sqrt(sum(v * v for v in vec))\n                    if nrm < 1e-12:\n                        continue\n                    vec = [v / nrm for v in vec]\n                    r = random.random() ** (1 / dim)\n                    return [v * r for v in vec]\n\n            u = sample_unit_ball(dim)\n            mapped = []\n            for d in range(dim):\n                val = center[d]\n                for i in range(dim):\n                    val += basis[i][d] * radii[i] * u[i]\n                val = max(0.0, min(val, bounds[d]))\n                mapped.append(val)\n            return tuple(mapped)\n\n        def choose_parent(tree, grid, pos):\n            n = len(tree)\n            r = adaptive_radius(n)\n            nbrs = grid.query_radius(pos, r)\n            best_parent = None\n            min_cost = float('inf')\n\n            # Filter neighbors inside radius & not in obstacle\n            candidates = [nb for nb in nbrs if not edge_in_obstacle(nb.position, pos)]\n            if not candidates:\n                nearest = grid.nearest(pos)\n                if nearest is None:\n                    return None, []\n                if edge_in_obstacle(nearest.position, pos):\n                    return None, []\n                cost = nearest.cost + math.dist(nearest.position, pos)\n                new_node = Node(pos, parent=nearest, cost=cost)\n                nearest.add_child(new_node)\n                tree.append(new_node)\n                grid.insert(new_node)\n                return new_node, []\n            for nb in candidates:\n                cost = nb.cost + math.dist(nb.position, pos)\n                if cost < min_cost:\n                    min_cost = cost\n                    best_parent = nb\n            new_node = Node(pos, parent=best_parent, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree.append(new_node)\n            grid.insert(new_node)\n            return new_node, candidates\n\n        def direct_connect(tree, grid, target_node):\n            if not tree:\n                return None\n            nearest = grid.nearest(target_node.position)\n            if nearest is None:\n                return None\n            dist_to_target = math.dist(nearest.position, target_node.position)\n            if dist_to_target <= self.step_size:\n                if edge_in_obstacle(nearest.position, target_node.position) or in_obstacle(target_node.position):\n                    return None\n                new_node = Node(target_node.position, parent=nearest, cost=nearest.cost + dist_to_target)\n                nearest.add_child(new_node)\n                tree.append(new_node)\n                grid.insert(new_node)\n                return new_node\n            if not edge_in_obstacle(nearest.position, target_node.position):\n                new_node = Node(target_node.position, parent=nearest, cost=nearest.cost + dist_to_target)\n                nearest.add_child(new_node)\n                tree.append(new_node)\n                grid.insert(new_node)\n                return new_node\n            current = nearest\n            steps = int(math.ceil(dist_to_target / self.step_size))\n            for _ in range(steps):\n                new_pos = steer(current.position, target_node.position)\n                if (not in_bounds(new_pos) or in_obstacle(new_pos)\n                    or edge_in_obstacle(current.position, new_pos)):\n                    return None\n                new_node = Node(new_pos, parent=current, cost=current.cost + math.dist(current.position, new_pos))\n                current.add_child(new_node)\n                tree.append(new_node)\n                grid.insert(new_node)\n                current = new_node\n                if math.dist(current.position, target_node.position) <= self.step_size:\n                    if edge_in_obstacle(current.position, target_node.position) or in_obstacle(target_node.position):\n                        return None\n                    final_node = Node(target_node.position, parent=current,\n                                      cost=current.cost + math.dist(current.position, target_node.position))\n                    current.add_child(final_node)\n                    tree.append(final_node)\n                    grid.insert(final_node)\n                    return final_node\n            return None\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path[:]\n            for _ in range(self.shortcut_iter):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if not edge_in_obstacle(p1, p2):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        # Initialize trees, grids\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n\n        start_grid = SpatialHashGrid(bounds, self.grid_cell_size)\n        goal_grid = SpatialHashGrid(bounds, self.grid_cell_size)\n        start_grid.insert(start_root)\n        goal_grid.insert(goal_root)\n\n        best_path = []\n        best_cost = float('inf')\n        found_solution = False\n        no_improve_count = 0\n\n        start_time = time.time()\n\n        for it in range(self.max_iter):\n            if time.time() - start_time > self.time_limit:\n                break\n\n            # Alternate trees to expand\n            if it % 2 == 0:\n                tree_a, grid_a, tree_b, grid_b = start_tree, start_grid, goal_tree, goal_grid\n            else:\n                tree_a, grid_a, tree_b, grid_b = goal_tree, goal_grid, start_tree, start_grid\n\n            if found_solution:\n                x_rand = sample_informed(best_cost)\n            else:\n                x_rand = sample_uniform()\n\n            if (not in_bounds(x_rand)) or in_obstacle(x_rand):\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n                continue\n\n            nearest = grid_a.nearest(x_rand)\n            if nearest is None:\n                continue\n            new_pos = steer(nearest.position, x_rand)\n            if (not in_bounds(new_pos)) or in_obstacle(new_pos) or edge_in_obstacle(nearest.position, new_pos):\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n                continue\n\n            new_node, nbrs = choose_parent(tree_a, grid_a, new_pos)\n            if new_node is None:\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n                continue\n\n            rewire(new_node, nbrs, grid_a)\n            prune_tree(tree_a, grid_a, best_cost)\n            \n            meet_node = direct_connect(tree_b, grid_b, new_node)\n            if meet_node is not None:\n                # Merge paths\n                if it % 2 == 0:\n                    path_a = new_node.path_from_root()\n                    path_b = meet_node.path_from_root()\n                else:\n                    path_a = meet_node.path_from_root()\n                    path_b = new_node.path_from_root()\n                if path_a and path_b and path_a[-1] == path_b[-1]:\n                    merged_path = path_a + path_b[-2::-1]\n                else:\n                    merged_path = path_a + path_b[::-1]\n\n                total_cost = 0.0\n                for i in range(len(merged_path) - 1):\n                    total_cost += math.dist(merged_path[i], merged_path[i + 1])\n\n                if total_cost + 1e-9 < best_cost:\n                    best_cost = total_cost\n                    best_path = merged_path\n                    found_solution = True\n                    no_improve_count = 0\n                else:\n                    if found_solution:\n                        no_improve_count += 1\n                        if no_improve_count >= self.max_no_improve:\n                            break\n            else:\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n\n        if found_solution and len(best_path) >= 3:\n            best_path = shortcut_path(best_path)\n\n        return PlannerResult(success=found_solution, path=best_path,\n                             nodes=start_tree + goal_tree, edges=[])",
          "objective": -24.29734,
          "time_improvement": 18.0,
          "length_improvement": 18.0,
          "smoothness_improvement": 1574.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.04035904407501221,
                    "num_nodes_avg": 157.6,
                    "path_length_avg": 155.80453084160476,
                    "smoothness_avg": 0.046001379101261605,
                    "success_improvement": 0.0,
                    "time_improvement": -66.18620564399352,
                    "length_improvement": 14.601067764934312,
                    "smoothness_improvement": 620.0214765283149,
                    "objective_score": -7.995113651595894
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.04773590564727783,
                    "num_nodes_avg": 312.9,
                    "path_length_avg": 236.0348853649969,
                    "smoothness_avg": 0.10865332079782086,
                    "success_improvement": 0.0,
                    "time_improvement": 70.43580479668486,
                    "length_improvement": 21.20476137768612,
                    "smoothness_improvement": 2695.7282039516153,
                    "objective_score": 47.33223928537521
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.0245466947555542,
                    "num_nodes_avg": 273.7,
                    "path_length_avg": 121.97041716297436,
                    "smoothness_avg": 0.11839084550655146,
                    "success_improvement": 0.0,
                    "time_improvement": 50.4314773356443,
                    "length_improvement": 18.993056527483674,
                    "smoothness_improvement": 1405.9228161401293,
                    "objective_score": 33.55489119788414
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "initial",
          "algorithm_description": "This algorithm is a bidirectional extension of RRT* that grows two trees from start and goal while optimizing paths via rewiring. It combines RRT*\u2018s asymptotic optimality with RRT-Connect\u2019s fast convergence through connection attempts between the trees.",
          "planning_mechanism": "The planner alternates growing two trees with sampling, extension, and rewiring. After each extension, it attempts to connect both trees. When connection is successful, a rewired optimal path is extracted across both trees.",
          "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, radius: float = 10.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.radius = radius\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n        nodes = []\n        edges = []\n        success_state = False\n        extracted_path = []\n\n        for iter in range(self.max_iter):\n            rand = self._sample_free(bounds, obstacles, is_3d)\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest = self._nearest(tree_a, rand)\n                new_pos = self._steer(nearest.position, rand, self.step_size)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                    continue\n\n                new_node = Node(new_pos)\n                near_nodes = self._near(tree_a, new_pos, self.radius)\n                min_cost = nearest.cost + self._distance(nearest.position, new_pos)\n                min_parent = nearest\n\n                for near in near_nodes:\n                    cost = near.cost + self._distance(near.position, new_pos)\n                    if cost < min_cost and not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d):\n                        min_cost = cost\n                        min_parent = near\n\n                new_node.parent = min_parent\n                new_node.cost = min_cost\n                min_parent.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((min_parent, new_node))\n\n                for near in near_nodes:\n                    if near == min_parent:\n                        continue\n                    new_cost = new_node.cost + self._distance(new_node.position, near.position)\n                    if new_cost < near.cost and not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                        if near.parent:\n                            edges.remove((near.parent, near))\n                        near.parent = new_node\n                        near.cost = new_cost\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n\n                connect_node = self._nearest(tree_b, new_node.position)\n                if self._distance(new_node.position, connect_node.position) < self.step_size and not self._is_edge_in_obstacle(new_node.position, connect_node.position, obstacles, is_3d):\n                    success_state = True\n                    extracted_path = self._extract_path(new_node, connect_node)\n                    return PlannerResult(True, extracted_path, start_tree + goal_tree, edges)\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        while True:\n            point = tuple(random.uniform(0, bounds[i]) for i in range(3 if is_3d else 2))\n            if not self._is_in_obstacle(point, obstacles, is_3d):\n                return point\n\n    def _nearest(self, tree, point):\n        return min(tree, key=lambda node: self._distance(node.position, point))\n\n    def _near(self, tree, point, radius):\n        return [node for node in tree if self._distance(node.position, point) <= radius]\n\n    def _steer(self, from_pos, to_pos, step_size):\n        dist = self._distance(from_pos, to_pos)\n        if dist <= step_size:\n            return to_pos\n        ratio = step_size / dist\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n    def _extract_path(self, node_a, node_b):\n        path_a = []\n        while node_a:\n            path_a.append(node_a.position)\n            node_a = node_a.parent\n        path_b = []\n        while node_b:\n            path_b.append(node_b.position)\n            node_b = node_b.parent\n        return list(reversed(path_a)) + path_b\n\n    def _distance(self, a, b):\n        return math.dist(a, b)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = self._distance(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n    ",
          "objective": -23.76291481494683,
          "time_improvement": 61.0,
          "length_improvement": 8.0,
          "smoothness_improvement": 166.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.012529301643371581,
                    "num_nodes_avg": 131.9,
                    "path_length_avg": 176.77827310097746,
                    "smoothness_avg": 0.01645631271580969,
                    "success_improvement": 0.0,
                    "time_improvement": 48.408166070262766,
                    "length_improvement": 3.105027282357968,
                    "smoothness_improvement": 157.5770294574498,
                    "objective_score": 17.173351337780858
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.01886875629425049,
                    "num_nodes_avg": 256.8,
                    "path_length_avg": 267.7347696890942,
                    "smoothness_avg": 0.010597136127488454,
                    "success_improvement": 0.0,
                    "time_improvement": 88.31404606735866,
                    "length_improvement": 10.622427559723258,
                    "smoothness_improvement": 172.67194536891012,
                    "objective_score": 33.7310300828861
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.026641178131103515,
                    "num_nodes_avg": 304.4,
                    "path_length_avg": 136.29588257526552,
                    "smoothness_avg": 0.02101448639210645,
                    "success_improvement": 0.0,
                    "time_improvement": 46.20196913892299,
                    "length_improvement": 9.478764505998065,
                    "smoothness_improvement": 167.3027157795587,
                    "objective_score": 20.384363024173528
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e2",
          "algorithm_description": "A Bidirectional Informed RRT* with Adaptive Radius and Progressive Rewiring integrating a balanced ellipsoidal informed sampler, efficient linear nearest neighbor search with incremental rewiring, and robust early stopping based on solution stagnation and path cost improvement. The algorithm alternately expands start and goal trees, prioritizes smoother and shorter paths by cost-aware parent selection, adaptively adjusts rewiring radius based on the number of nodes and best cost, and applies a final multi-pass shortcut smoothing to yield efficient, low-cost, and smooth paths within bounded planning time.",
          "planning_mechanism": "The planner maintains two trees grown alternately from start and goal. Sampling is initially uniform and focuses progressively within a shrinking ellipsoid around the currently best path. The nearest parent is selected by minimal cost plus a small curvature penalty. An adaptive rewiring radius shrinks as better solutions are found, enabling local optimization. Each new node attempts rewiring neighbors within radius if it improves cost. The trees connect when nodes are near and collision free. Early termination occurs if no improvements happen in prolonged iterations. After planning, a multi-pass shortcutting cleans and smooths the path to reduce length and curvature.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=3500, step_size=5.5, n_near_const=28,\n                 max_no_improve=70, improve_tol=1e-6, shortcut_iters=300):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.n_near_const = n_near_const\n        self.max_no_improve = max_no_improve\n        self.improve_tol = improve_tol\n        self.shortcut_iters = shortcut_iters\n\n    def plan(self, map) -> 'PlannerResult':\n        import math, random, time\n\n        start = tuple(map.start)\n        goal = tuple(map.goal)\n        bounds = tuple(map.size)\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        dist = lambda a, b: math.dist(a, b)\n\n        def in_obstacle(p):\n            px, py, pz = (p + (0, 0, 0))[:3]\n            for obs in obstacles:\n                if is_3d:\n                    ox, oy, oz, ow, oh, od = obs\n                    if (ox <= px <= ox + ow and oy <= py <= oy + oh and oz <= pz <= oz + od):\n                        return True\n                else:\n                    ox, oy, ow, oh = obs\n                    if (ox <= px <= ox + ow and oy <= py <= oy + oh):\n                        return True\n            return False\n\n        def edge_obstacle(f, t, resolution=1.0):\n            length = dist(f, t)\n            if length < 1e-12:\n                return False\n            steps = max(2, int(length / resolution))\n            for i in range(steps +1):\n                inter = tuple(f[d] + (t[d] - f[d]) * i / steps for d in range(dim))\n                if in_obstacle(inter):\n                    return True\n            return False\n\n        def steer(frm, to):\n            d = dist(frm, to)\n            if d <= self.step_size:\n                return to\n            ratio = self.step_size / d\n            return tuple(frm[i] + (to[i] - frm[i]) * ratio for i in range(dim))\n\n        def nearest(tree, p):\n            best = None\n            best_d = float('inf')\n            px = p\n            for n in tree:\n                d2 = 0.0\n                for i in range(dim):\n                    dd = n.position[i] - px[i]\n                    d2 += dd*dd\n                    if d2 >= best_d*best_d:\n                        break\n                else:\n                    d = math.sqrt(d2)\n                    if d < best_d:\n                        best = n\n                        best_d = d\n            return best, best_d\n\n        def near_nodes(tree, p, radius):\n            r2 = radius*radius\n            res = []\n            px = p\n            for n in tree:\n                d2 = 0.0\n                for i in range(dim):\n                    dd = n.position[i] - px[i]\n                    d2 += dd*dd\n                    if d2 > r2:\n                        break\n                if d2 <= r2:\n                    res.append(n)\n            return res\n\n        def adaptive_radius(n_nodes, c_best):\n            gamma = self.n_near_const\n            if n_nodes == 0:\n                return self.step_size * 3.0\n            radius = min((gamma * (math.log(n_nodes)/n_nodes))**(1/dim), self.step_size * 6.0)\n            if c_best == float('inf'):\n                return radius\n            shrink = max(0.3, c_best / (c_min * 3.1))\n            return max(self.step_size * 0.8, radius * shrink)\n\n        def ellipsoid_sample(c_best):\n            if c_best == float('inf'):\n                # Uniform sample in bounds avoiding boundary issues\n                return tuple(random.uniform(0.0, bounds[i]) for i in range(dim))\n            center = tuple((start[i] + goal[i]) * 0.5 for i in range(dim))\n            a1 = [goal[i] - start[i] for i in range(dim)]\n            norm_a1 = math.sqrt(sum(x*x for x in a1))\n            if norm_a1 < 1e-14:\n                return tuple(random.uniform(0.0, bounds[i]) for i in range(dim))\n            unit_a1 = [x / norm_a1 for x in a1]\n            U = [unit_a1]\n            for idx in range(dim -1):\n                base = [0.0]*dim\n                base[(idx+1)%dim] = 1.0\n                for u in U:\n                    proj = sum(base[j]*u[j] for j in range(dim))\n                    base = [base[j] - proj*u[j] for j in range(dim)]\n                norm_base = math.sqrt(sum(x*x for x in base))\n                if norm_base > 1e-14:\n                    U.append([x / norm_base for x in base])\n                else:\n                    U.append([0.0]*dim)\n            r1 = c_best * 0.5\n            val = c_best*c_best - c_min*c_min\n            r2 = math.sqrt(val)*0.5 if val > 0 else 0.0\n            radii = [r1] + [r2]*(dim-1)\n\n            max_attempt = 50\n            for _ in range(max_attempt):\n                x_ball = [random.gauss(0, 1) for _ in range(dim)]\n                norm_ball = math.sqrt(sum(x*x for x in x_ball))\n                if norm_ball < 1e-14:\n                    continue\n                unit_ball = [x / norm_ball for x in x_ball]\n                u = random.random() ** (1.0/dim)\n                point_ball = [coord * u for coord in unit_ball]\n                scaled = [radii[i]*point_ball[i] for i in range(dim)]\n                point_rot = [0.0]*dim\n                for i in range(dim):\n                    for j in range(dim):\n                        point_rot[j] += scaled[i]*U[i][j]\n                sample = tuple(center[i] + point_rot[i] for i in range(dim))\n                if all(0.0 <= sample[i] <= bounds[i] for i in range(dim)) and not in_obstacle(sample):\n                    return sample\n            # fallback\n            return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n\n        def extract_path(node):\n            return node.path_from_root()\n\n        def connect_path(n_start, n_goal):\n            path_s = extract_path(n_start)\n            path_g_rev = extract_path(n_goal)\n            path_g = path_g_rev[::-1]\n            if len(path_s) > 0 and len(path_g) > 0 and path_s[-1] == path_g[0]:\n                return path_s + path_g[1:]\n            else:\n                return path_s + path_g\n\n        def curvature_penalty(p_parent, p_child, p_new):\n            # Small curvature cost for smoother parent selection\n            if p_parent is None:\n                return 0.0\n            v1 = tuple(p_child[i] - p_parent[i] for i in range(dim))\n            v2 = tuple(p_new[i] - p_child[i] for i in range(dim))\n            len1 = math.sqrt(sum(x*x for x in v1))\n            len2 = math.sqrt(sum(x*x for x in v2))\n            if len1 < 1e-14 or len2 < 1e-14:\n                return 0.0\n            dot = sum(v1[i]*v2[i] for i in range(dim))/(len1*len2)\n            dot = max(-1.0, min(1.0, dot))\n            angle = math.acos(dot)\n            return angle\n\n        def add_node(tree, new_pos, nodes_all, edges, c_best):\n            nn, _ = nearest(tree, new_pos)\n            if nn is None:\n                return None\n            new_pos_steered = steer(nn.position, new_pos)\n            if in_obstacle(new_pos_steered) or edge_obstacle(nn.position, new_pos_steered):\n                return None\n\n            n_nodes = len(nodes_all)\n            radius = adaptive_radius(n_nodes, c_best)\n            near = near_nodes(tree, new_pos_steered, radius)\n\n            alpha_curv = 0.04\n            best_parent = nn\n            best_cost = nn.cost + dist(nn.position, new_pos_steered)\n            best_score = best_cost + alpha_curv * curvature_penalty(nn.parent.position if nn.parent else None, nn.position, new_pos_steered)\n\n            for candidate in near:\n                if candidate == nn:\n                    continue\n                if edge_obstacle(candidate.position, new_pos_steered):\n                    continue\n                candidate_cost = candidate.cost + dist(candidate.position, new_pos_steered)\n                curv_cost = alpha_curv * curvature_penalty(candidate.parent.position if candidate.parent else None, candidate.position, new_pos_steered)\n                score = candidate_cost + curv_cost\n                if score + self.improve_tol < best_score:\n                    best_parent = candidate\n                    best_cost = candidate_cost\n                    best_score = score\n\n            new_node = Node(new_pos_steered)\n            best_parent.add_child(new_node)\n            new_node.cost = best_cost\n            tree.append(new_node)\n            nodes_all.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewiring neighbors around new_node if better path found\n            near_rewire = near_nodes(tree, new_node.position, radius)\n            for near_n in near_rewire:\n                if near_n == best_parent or near_n == new_node:\n                    continue\n                alt_cost = new_node.cost + dist(new_node.position, near_n.position)\n                if alt_cost + self.improve_tol < near_n.cost and not edge_obstacle(new_node.position, near_n.position):\n                    # Additionally check curvature penalty for rewiring\n                    curv_new = curvature_penalty(new_node.parent.position if new_node.parent else None, new_node.position, near_n.position)\n                    curv_old = curvature_penalty(near_n.parent.parent.position if near_n.parent and near_n.parent.parent else None, near_n.parent.position if near_n.parent else None, near_n.position)\n                    if alpha_curv * curv_new <= alpha_curv * curv_old + 0.15:  # allow slight increase for cost gain\n                        if near_n.parent:\n                            near_n.parent.remove_child(near_n)\n                            try:\n                                edges.remove((near_n.parent, near_n))\n                            except Exception:\n                                pass\n                        new_node.add_child(near_n)\n                        near_n.cost = alt_cost\n                        edges.append((new_node, near_n))\n\n            return new_node\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            path = list(path)\n            changed = True\n            iter_count = 0\n            while changed and iter_count < self.shortcut_iters:\n                changed = False\n                iter_count +=1\n                i=0\n                while i < len(path)-2:\n                    max_j = min(len(path)-1, i + 7 + random.randint(0,4))\n                    j = random.randint(i+2, max_j) if max_j > i+2 else i+2\n                    if j > i+1 and not edge_obstacle(path[i], path[j]):\n                        path = path[:i+1] + path[j:]\n                        changed = True\n                        break\n                    i += 1\n            return path\n\n        # Initialize bidirectional trees\n        start_tree = [Node(start)]\n        goal_tree = [Node(goal)]\n        nodes_all = start_tree + goal_tree\n        edges = []\n\n        c_min = dist(start, goal)\n        best_cost = float('inf')\n        best_path = []\n        found_solution = False\n\n        no_improve_count = 0\n        last_best_cost = float('inf')\n\n        start_time = time.time()\n\n        for it in range(self.max_iter):\n            sample_pt = ellipsoid_sample(best_cost if found_solution else float('inf'))\n\n            # Alternate growing trees: even iterations start-tree, odd goal-tree\n            if it % 2 == 0:\n                tree_a, tree_b = start_tree, goal_tree\n            else:\n                tree_a, tree_b = goal_tree, start_tree\n\n            new_node = add_node(tree_a, sample_pt, nodes_all, edges, best_cost)\n            if new_node is None:\n                if found_solution:\n                    no_improve_count += 1\n                continue\n\n            nbr_node, nbr_dist = nearest(tree_b, new_node.position)\n            if nbr_node and nbr_dist <= self.step_size and not edge_obstacle(new_node.position, nbr_node.position):\n                candidate_path = connect_path(new_node, nbr_node)\n                candidate_cost = new_node.cost + dist(new_node.position, nbr_node.position) + nbr_node.cost\n\n                if candidate_cost + self.improve_tol < best_cost:\n                    best_cost = candidate_cost\n                    best_path = candidate_path\n                    found_solution = True\n                    no_improve_count = 0\n                else:\n                    no_improve_count += 1\n            elif found_solution:\n                no_improve_count += 1\n\n            if found_solution and no_improve_count >= self.max_no_improve:\n                break\n\n            if found_solution and best_cost + self.improve_tol < last_best_cost:\n                last_best_cost = best_cost\n                no_improve_count = 0\n\n        if found_solution and len(best_path) > 3:\n            # Multiple progressive shortcut passes to enhance path quality\n            for _ in range(3):\n                best_path = shortcut_path(best_path)\n\n        if found_solution:\n            return PlannerResult(True, best_path, nodes_all, edges)\n        else:\n            return PlannerResult(False, [], nodes_all, edges)",
          "objective": -23.40566,
          "time_improvement": 28.0,
          "length_improvement": 13.0,
          "smoothness_improvement": 1419.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.02814173698425293,
                    "num_nodes_avg": 174.7,
                    "path_length_avg": 170.78044027086807,
                    "smoothness_avg": 0.041064375085066517,
                    "success_improvement": 0.0,
                    "time_improvement": -15.879069904428114,
                    "length_improvement": 6.3925344982841175,
                    "smoothness_improvement": 542.746642799047,
                    "objective_score": 1.7855329416372712
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.04101948738098145,
                    "num_nodes_avg": 312.8,
                    "path_length_avg": 241.95417433722574,
                    "smoothness_avg": 0.08769719153831615,
                    "success_improvement": 0.0,
                    "time_improvement": 74.59547240955273,
                    "length_improvement": 19.228732341469897,
                    "smoothness_improvement": 2156.5119040147615,
                    "objective_score": 44.698440647821556
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.036681413650512695,
                    "num_nodes_avg": 276.1,
                    "path_length_avg": 130.08856674191185,
                    "smoothness_avg": 0.13041023521317593,
                    "success_improvement": 0.0,
                    "time_improvement": 25.927156303411085,
                    "length_improvement": 13.601368121895007,
                    "smoothness_improvement": 1558.8085660293298,
                    "objective_score": 23.733010594306975
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "initial",
          "algorithm_description": "This algorithm enhances the standard BI-RRT by incorporating an optimization step that rewires nearby nodes to minimize cost, resulting in asymptotically optimal paths. It grows two trees\u2014one from the start and one from the goal\u2014and attempts to connect them while optimizing the path cost dynamically.",
          "planning_mechanism": "The planning mechanism includes sampling a random point, extending each tree toward it, rewiring neighbors within a radius to optimize the cost, and attempting to connect the two trees. When a connection is established, the combined path is extracted from both trees. Node validity and edge collision checks are strictly enforced throughout the process.",
          "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost: float = 0.0):\n        self.position = position              # Tuple[float, ...]\n        self.parent: Optional[\"Node\"] = parent\n        self.cost: float = cost\n        self.children: List[\"Node\"] = []\n        self.valid = True\n\n    def add_child(self, child_node: \"Node\"):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n\nclass Planner:\n    def __init__(\n        self,\n        max_iter: int = 5000,\n        step_size: float = 5.0,\n        gamma_rrt_star: float = 50.0,\n        max_radius: float = 60.0,\n    ):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.gamma_rrt_star = gamma_rrt_star\n        self.max_radius = max_radius\n\n    # ======================= Public API =======================\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        start_root = Node(start_position, parent=None, cost=0.0)\n        goal_root  = Node(goal_position,  parent=None, cost=0.0)\n        nodes.extend([start_root, goal_root])\n\n        tree_a: List[Node] = [start_root]\n        tree_b: List[Node] = [goal_root]\n\n        for _ in range(self.max_iter):\n            rand_point = self._sample_free(bounds, obstacles, is_3d)\n\n            new_a = self._extend_and_rewire(tree_a, rand_point, obstacles, is_3d, nodes, edges, bounds)\n            if new_a is None:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            new_b = self._connect_and_rewire(tree_b, new_a, obstacles, is_3d, nodes, edges, bounds)\n            if new_b:\n                success_state = True\n                path_a = new_a.path_from_root()\n                path_b = new_b.path_from_root()\n                if path_a and path_b and path_a[-1] == path_b[-1]:\n                    path_b = path_b[:-1]\n                extracted_path = path_a + path_b[::-1]\n                break\n\n            tree_a, tree_b = tree_b, tree_a\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        while True:\n            p = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    def _nearest(self, tree: List[Node], point):\n        return min(tree, key=lambda node: math.dist(node.position, point))\n\n    def _steer(self, from_pos, to_pos):\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _near_nodes(self, tree: List[Node], position, bounds) -> List[Node]:\n        n = max(1, len(tree))\n        d = len(position)\n        # \uacf5\uac04 \uc2a4\ucf00\uc77c\uc744 \uac04\ub2e8\ud788 bounds\ub85c \ucd94\uc815 (\uc815\ubc00 X, \uc2e4\uc6a9\uc801)\n        scale = max(1.0, sum(bounds) / d)\n        r_theory = self.gamma_rrt_star * ((math.log(n + 1) / (n + 1)) ** (1.0 / d))\n        radius = max(self.step_size * 2.0, min(self.max_radius, r_theory * 0.5 + scale * 0.02))\n        return [node for node in tree if math.dist(node.position, position) <= radius]\n\n    def _choose_parent_and_add(self, tree, new_pos, obstacles, is_3d, nodes, edges, bounds):\n        nearest = self._nearest(tree, new_pos)\n        neighbors = self._near_nodes(tree, new_pos, bounds)\n\n        min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n        best_parent = nearest\n\n        for nb in neighbors:\n            if not self._is_edge_in_obstacle(nb.position, new_pos, obstacles, is_3d):\n                cand = nb.cost + math.dist(nb.position, new_pos)\n                if cand < min_cost:\n                    min_cost = cand\n                    best_parent = nb\n\n        new_node = Node(new_pos, parent=None, cost=min_cost)\n        best_parent.add_child(new_node)\n        tree.append(new_node)\n        nodes.append(new_node)\n        edges.append((best_parent, new_node))\n        return new_node, neighbors\n\n    def _rewire_from(self, pivot: Node, neighbors: List[Node], obstacles, is_3d, edges):\n        for nb in neighbors:\n            if not self._is_edge_in_obstacle(pivot.position, nb.position, obstacles, is_3d):\n                new_cost = pivot.cost + math.dist(pivot.position, nb.position)\n                if new_cost + 1e-12 < nb.cost:  # \uc791\uc740 \uc218\uce58 \ubc84\ud37c\n                    if nb.parent is not None:\n                        try:\n                            edges.remove((nb.parent, nb))\n                        except ValueError:\n                            pass\n                        if nb in nb.parent.children:\n                            nb.parent.children.remove(nb)\n                    pivot.add_child(nb)\n                    nb.cost = new_cost\n                    edges.append((pivot, nb))\n\n    def _extend_and_rewire(self, tree, sample_point, obstacles, is_3d, nodes, edges, bounds):\n        nearest = self._nearest(tree, sample_point)\n        new_pos = self._steer(nearest.position, sample_point)\n\n        if self._is_in_obstacle(new_pos, obstacles, is_3d):\n            return None\n        if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n            return None\n\n        new_node, neighbors = self._choose_parent_and_add(tree, new_pos, obstacles, is_3d, nodes, edges, bounds)\n        self._rewire_from(new_node, neighbors, obstacles, is_3d, edges)\n        return new_node\n\n    def _connect_and_rewire(self, tree, target_node: Node, obstacles, is_3d, nodes, edges, bounds):\n        nearest = self._nearest(tree, target_node.position)\n\n        while True:\n            new_pos = self._steer(nearest.position, target_node.position)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                return None\n\n            connect_node, neighbors = self._choose_parent_and_add(tree, new_pos, obstacles, is_3d, nodes, edges, bounds)\n            self._rewire_from(connect_node, neighbors, obstacles, is_3d, edges)\n\n            if math.dist(connect_node.position, target_node.position) <= self.step_size:\n                if (not self._is_edge_in_obstacle(connect_node.position, target_node.position, obstacles, is_3d) and\n                    not self._is_in_obstacle(target_node.position, obstacles, is_3d)):\n                    final_node = Node(target_node.position, parent=None, cost=connect_node.cost + math.dist(connect_node.position, target_node.position))\n                    connect_node.add_child(final_node)\n                    tree.append(final_node)\n                    nodes.append(final_node)\n                    edges.append((connect_node, final_node))\n                    return final_node\n                else:\n                    return None\n\n            nearest = connect_node\n\n        \n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n        \n        \n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n",
          "objective": -22.142109273517423,
          "time_improvement": 49.0,
          "length_improvement": 11.0,
          "smoothness_improvement": 177.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.018251991271972655,
                    "num_nodes_avg": 78.7,
                    "path_length_avg": 175.55592835957023,
                    "smoothness_avg": 0.017196193462405217,
                    "success_improvement": 0.0,
                    "time_improvement": 24.843879619675935,
                    "length_improvement": 3.775013804415195,
                    "smoothness_improvement": 169.1577698184268,
                    "objective_score": 10.563961017644031
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.04780585765838623,
                    "num_nodes_avg": 302.9,
                    "path_length_avg": 259.03658233660315,
                    "smoothness_avg": 0.01078988487631875,
                    "success_improvement": 0.0,
                    "time_improvement": 70.39248153962646,
                    "length_improvement": 13.526132861425937,
                    "smoothness_improvement": 177.6315095076258,
                    "objective_score": 30.121581726281626
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.023344540596008302,
                    "num_nodes_avg": 176.0,
                    "path_length_avg": 128.09376742543256,
                    "smoothness_avg": 0.022442540549775757,
                    "success_improvement": 0.0,
                    "time_improvement": 52.85905490960737,
                    "length_improvement": 14.926218845764677,
                    "smoothness_improvement": 185.467459257119,
                    "objective_score": 25.74078507662661
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m2",
          "algorithm_description": "An improved bidirectional RRT* planner with adaptive neighbor radius, bidirectional rewiring, and efficient post-processing path shortcutting to enhance planning time, reduce path length, and achieve smoother, less jagged paths. The planner retains informed ellipsoidal sampling after initial solution, carefully avoids excessive neighbor contractions, and uses early stopping. Post-processing aggressively shortcuts the found path by attempting direct edge connections between non-adjacent waypoints, significantly improving smoothness and reducing unnecessary waypoints while maintaining collision-free guarantees.",
          "planning_mechanism": "The planner grows two trees from the start and goal, alternating expansions. It samples uniformly initially, then focuses inside an ellipsoidal informed sampling region defined by the current best path cost. Each iteration extends one tree towards a sampled point by steering a fixed step size, then chooses the best parent among neighbors within an adaptive radius that gently reduces over iterations, fostering path optimality and connectivity. Both trees undergo local rewiring to improve costs. The planner attempts a direct connection from the opposite tree to the newly added node to quickly merge the trees forming a solution. Early termination occurs on stagnation or timeout. Once a path is found, a post-processing phase performs shortcutting by trying to connect distant waypoints directly, removing unnecessary waypoints and improving smoothness.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(\n        self,\n        max_iter=6000,\n        step_size=4.0,\n        max_neighbor_radius=25.0,\n        min_neighbor_radius=8.0,\n        improvement_tol=1e-6,\n        max_no_improve=80,\n        time_limit_sec=30.0,\n        post_opt_iters=200\n    ):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.max_neighbor_radius = max_neighbor_radius\n        self.min_neighbor_radius = min_neighbor_radius\n        self.improvement_tol = improvement_tol\n        self.max_no_improve = max_no_improve\n        self.time_limit_sec = time_limit_sec\n        self.post_opt_iters = post_opt_iters\n\n    def plan(self, map):\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        best_path = []\n        best_cost = float('inf')\n        c_min = math.dist(start_pos, goal_pos)\n        found_first = False\n        no_improve_count = 0\n        post_opt_count = 0\n        start_time = time.time()\n\n        def within_bounds(pos):\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d = obs\n                    px,py,pz = pos\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                        return True\n                else:\n                    x,y,w,h = obs\n                    px,py = pos\n                    if x <= px <= x+w and y <= py <= y+h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(from_p, to_p, resolution=1.0):\n            dist = math.dist(from_p, to_p)\n            if dist < 1e-12:\n                return False\n            steps = max(2, int(dist / resolution))\n            for i in range(steps + 1):\n                interp = tuple(from_p[d] + (to_p[d] - from_p[d])*i/steps for d in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def steer(from_p, to_p):\n            dist = math.dist(from_p, to_p)\n            if dist <= self.step_size:\n                return to_p\n            ratio = self.step_size / dist\n            return tuple(from_p[d] + (to_p[d] - from_p[d]) * ratio for d in range(dim))\n\n        def neighbors(tree, pos, radius):\n            radius_sq = radius*radius\n            return [n for n in tree if sum((n.position[d] - pos[d])**2 for d in range(dim)) <= radius_sq]\n\n        def adaptive_radius(n, iter_i):\n            factor = max(0.2, 1.0 - iter_i / self.max_iter)  # Avoid overly small radius\n            val = (math.log(n + 1) / (n + 1))**(1/dim)\n            radius = max(self.min_neighbor_radius, min(self.max_neighbor_radius, self.max_neighbor_radius * factor * val))\n            return radius\n\n        def choose_parent_and_add(tree, new_pos, iter_i):\n            n = len(tree)\n            radius = adaptive_radius(n, iter_i)\n            nbrs = neighbors(tree, new_pos, radius)\n\n            nearest = min(tree, key=lambda node: math.dist(node.position, new_pos))\n            min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n            best_parent = nearest\n\n            for nb in nbrs:\n                if is_edge_in_obstacle(nb.position, new_pos):\n                    continue\n                c = nb.cost + math.dist(nb.position, new_pos)\n                if c < min_cost:\n                    min_cost = c\n                    best_parent = nb\n\n            new_node = Node(new_pos, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n            return new_node, nbrs\n\n        def rewire(pivot, neighbors_list):\n            for nb in neighbors_list:\n                if nb == pivot.parent:\n                    continue\n                if is_edge_in_obstacle(pivot.position, nb.position):\n                    continue\n                new_cost = pivot.cost + math.dist(pivot.position, nb.position)\n                if new_cost + 1e-12 < nb.cost:\n                    # Remove old edge\n                    if nb.parent is not None:\n                        try:\n                            edges.remove((nb.parent, nb))\n                        except ValueError:\n                            pass\n                        if nb in nb.parent.children:\n                            nb.parent.children.remove(nb)\n                    pivot.add_child(nb)\n                    nb.cost = new_cost\n                    edges.append((pivot, nb))\n\n        def direct_connect(tree, target_node):\n            nearest = min(tree, key=lambda n: math.dist(n.position, target_node.position))\n            dist_to_target = math.dist(nearest.position, target_node.position)\n            if dist_to_target <= self.step_size:\n                if (not is_edge_in_obstacle(nearest.position, target_node.position) and\n                    not is_in_obstacle(target_node.position)):\n                    new_node = Node(target_node.position, cost=nearest.cost + dist_to_target)\n                    nearest.add_child(new_node)\n                    tree.append(new_node)\n                    nodes.append(new_node)\n                    edges.append((nearest, new_node))\n                    return new_node\n                return None\n\n            current = nearest\n            steps = int(math.ceil(dist_to_target / self.step_size))\n            for _ in range(steps):\n                new_pos = steer(current.position, target_node.position)\n                if (not within_bounds(new_pos) or is_in_obstacle(new_pos) or\n                    is_edge_in_obstacle(current.position, new_pos)):\n                    return None\n                new_node, nbrs = choose_parent_and_add(tree, new_pos, 0)\n                rewire(new_node, nbrs)\n                if math.dist(new_node.position, target_node.position) <= self.step_size:\n                    if (not is_edge_in_obstacle(new_node.position, target_node.position) and\n                        not is_in_obstacle(target_node.position)):\n                        final_node = Node(target_node.position,\n                                          cost=new_node.cost + math.dist(new_node.position, target_node.position))\n                        new_node.add_child(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n                current = new_node\n            return None\n\n        def sample_informed():\n            if not found_first or best_cost == float('inf') or c_min < 1e-12:\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            center = tuple((start_pos[d] + goal_pos[d]) / 2.0 for d in range(dim))\n            unit_dir = []\n            dist_sg = c_min\n            for d in range(dim):\n                unit_dir.append((goal_pos[d] - start_pos[d]) / dist_sg)\n            r1 = best_cost / 2.0\n            val = best_cost*best_cost - c_min*c_min\n            val = max(val, 0.0)\n            r_other = math.sqrt(val) / 2.0\n\n            if dim == 2:\n                a1 = unit_dir\n                a2 = (-a1[1], a1[0])\n                basis = (a1, a2)\n                radii = (r1, r_other)\n            else:\n                a1 = unit_dir\n                ref = (1.0, 0.0, 0.0) if abs(a1[0]) < 0.9 else (0.0,1.0,0.0)\n                b2 = _cross(a1, ref)\n                n_b2 = _norm(b2)\n                if n_b2 < 1e-12:\n                    ref = (0.0, 0.0, 1.0)\n                    b2 = _cross(a1, ref)\n                    n_b2 = _norm(b2)\n                b2 = tuple(x / n_b2 for x in b2)\n                b3 = _cross(a1, b2)\n                basis = (a1, b2, b3)\n                radii = (r1, r_other, r_other)\n\n            u = _sample_unit_ball(dim)\n            mapped = []\n            for d in range(dim):\n                val = center[d]\n                for i in range(dim):\n                    val += basis[i][d] * radii[i] * u[i]\n                val = min(max(val, 0.0), bounds[d])\n                mapped.append(val)\n            return tuple(mapped)\n\n        def _sample_unit_ball(dim):\n            while True:\n                vec = [random.gauss(0.0, 1.0) for _ in range(dim)]\n                nrm = math.sqrt(sum(v*v for v in vec))\n                if nrm < 1e-12:\n                    continue\n                vec = [v/nrm for v in vec]\n                r = random.random()**(1.0/dim)\n                return tuple(vec[i]*r for i in range(dim))\n\n        def _cross(a,b):\n            return (a[1]*b[2]-a[2]*b[1], a[2]*b[0]-a[0]*b[2], a[0]*b[1]-a[1]*b[0])\n\n        def _norm(v):\n            return math.sqrt(sum(x*x for x in v))\n\n        def path_shortcutting(path):\n            if len(path) < 3:\n                return path\n            shortcut_path = [path[0]]\n            i = 0\n            while i < len(path) - 1:\n                j = len(path) - 1\n                while j > i + 1:\n                    if not is_edge_in_obstacle(path[i], path[j]):\n                        break\n                    j -= 1\n                shortcut_path.append(path[j])\n                i = j\n            return shortcut_path\n\n        for it in range(self.max_iter):\n            if time.time() - start_time > self.time_limit_sec:\n                break\n\n            tree_a, tree_b = (start_tree, goal_tree) if it % 2 == 0 else (goal_tree, start_tree)\n            x_rand = sample_informed()\n\n            if not within_bounds(x_rand) or is_in_obstacle(x_rand):\n                if found_first:\n                    post_opt_count += 1\n                    no_improve_count += 1\n                    if post_opt_count >= self.post_opt_iters or no_improve_count >= self.max_no_improve:\n                        break\n                continue\n\n            nearest = min(tree_a, key=lambda node: math.dist(node.position, x_rand))\n            new_pos = steer(nearest.position, x_rand)\n            if not within_bounds(new_pos) or is_in_obstacle(new_pos) or is_edge_in_obstacle(nearest.position, new_pos):\n                if found_first:\n                    post_opt_count += 1\n                    no_improve_count += 1\n                    if post_opt_count >= self.post_opt_iters or no_improve_count >= self.max_no_improve:\n                        break\n                continue\n\n            new_node, nbrs = choose_parent_and_add(tree_a, new_pos, it)\n            rewire(new_node, nbrs)\n\n            meet_node = direct_connect(tree_b, new_node)\n            if meet_node is not None:\n                if it % 2 == 0:\n                    path_a = new_node.path_from_root()\n                    path_b = meet_node.path_from_root()\n                else:\n                    path_a = meet_node.path_from_root()\n                    path_b = new_node.path_from_root()\n                if path_a and path_b and path_a[-1] == path_b[-1]:\n                    merged_path = path_a + path_b[-2::-1]\n                else:\n                    merged_path = path_a + path_b[::-1]\n\n                total_cost = sum(math.dist(merged_path[i], merged_path[i+1]) for i in range(len(merged_path) - 1))\n                if total_cost + self.improvement_tol < best_cost:\n                    best_cost = total_cost\n                    best_path = merged_path\n                    found_first = True\n                    post_opt_count = 0\n                    no_improve_count = 0\n                else:\n                    if found_first:\n                        post_opt_count += 1\n                        no_improve_count += 1\n                if found_first and (post_opt_count >= self.post_opt_iters or no_improve_count >= self.max_no_improve):\n                    break\n            else:\n                if found_first:\n                    post_opt_count += 1\n                    no_improve_count += 1\n                    if post_opt_count >= self.post_opt_iters or no_improve_count >= self.max_no_improve:\n                        break\n        \n        # Post-processing path shortcutting for smoothness and path length improvement\n        if found_first and best_path:\n            for _ in range(5):  # Try multiple passes of shortcutting\n                shortened = path_shortcutting(best_path)\n                if len(shortened) == len(best_path):\n                    break\n                best_path = shortened\n\n        return PlannerResult(success=found_first, path=best_path, nodes=nodes, edges=edges)",
          "objective": -20.54313,
          "time_improvement": 6.0,
          "length_improvement": 19.0,
          "smoothness_improvement": 1486.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.035010457038879395,
                    "num_nodes_avg": 173.3,
                    "path_length_avg": 154.37889828660693,
                    "smoothness_avg": 0.04465232237074302,
                    "success_improvement": 0.0,
                    "time_improvement": -44.16235930512809,
                    "length_improvement": 15.382479558922096,
                    "smoothness_improvement": 598.90580917212,
                    "objective_score": -1.024691010324569
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.05897974967956543,
                    "num_nodes_avg": 380.6,
                    "path_length_avg": 229.58766956727146,
                    "smoothness_avg": 0.0947856766658578,
                    "success_improvement": 0.0,
                    "time_improvement": 63.47217447902824,
                    "length_improvement": 23.357027583784244,
                    "smoothness_improvement": 2338.903731975874,
                    "objective_score": 44.75038755385839
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.050714635848999025,
                    "num_nodes_avg": 293.6,
                    "path_length_avg": 122.90311253464752,
                    "smoothness_avg": 0.12740317839242893,
                    "success_improvement": 0.0,
                    "time_improvement": -2.4109193327074485,
                    "length_improvement": 18.373604671799267,
                    "smoothness_improvement": 1520.559025227274,
                    "objective_score": 17.9036821294037
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m1",
          "algorithm_description": "An improved bidirectional RRT* planner using a fixed-radius neighbor search with consistent minimal-cost parent selection and incremental rewiring, combined with balanced sampling mixing informed ellipsoidal and uniform sampling to avoid local minima. The planner implements early termination upon stagnation and applies progressive multi-pass shortcutting for enhanced path length and smoothness. It performs collision checks strictly before adding nodes or edges and maintains coherent tree data with efficient nearest neighbor queries via a lightweight spatial grid. This design aims to reduce planning time and optimize path length while preserving smoothness and robustness.",
          "planning_mechanism": "The planner grows two trees alternately from start and goal positions. Each iteration samples a point either uniformly or within an ellipsoidal informed region if a path is found. It finds the nearest neighbor and neighbors within a fixed radius using a spatial hash grid, chooses the best parent minimizing total path cost, and adds the new node after collision checks. It then rewires neighbors if the new node improves paths. Trees attempt connection each iteration. Early stopping triggers after no improvement over a set threshold. At the end, extensive incremental shortcutting refines the path, producing smoother, shorter paths with less planning time.",
          "code": "class Node:\n    __slots__ = ('position', 'parent', 'cost', 'children')\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        if parent:\n            parent.children.append(self)\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n    def path_from_root(self):\n        path = []\n        n = self\n        while n:\n            path.append(n.position)\n            n = n.parent\n        path.reverse()\n        return path\nclass Planner:\n    def __init__(self,\n                 max_iter=4000,\n                 step_size=5.0,\n                 neighbor_radius=15.0,\n                 time_limit=20.0,\n                 no_improve_limit=50,\n                 shortcut_passes=4,\n                 shortcut_attempts=350,\n                 uniform_sample_chance=0.15,\n                 grid_cell_size=12.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.neighbor_radius = neighbor_radius\n        self.time_limit = time_limit\n        self.no_improve_limit = no_improve_limit\n        self.shortcut_passes = shortcut_passes\n        self.shortcut_attempts = shortcut_attempts\n        self.uniform_sample_chance = uniform_sample_chance\n        self.grid_cell_size = grid_cell_size\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import time\n        import random\n\n        bounds = tuple(map.size)\n        dim = len(bounds)\n        start_pos = tuple(map.start)\n        goal_pos = tuple(map.goal)\n        obstacles = map.obstacles\n        is_3d = (dim == 3)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def in_obstacle(p):\n            px, py, pz = (p + (0,0,0))[:3]\n            for obs in obstacles:\n                if is_3d:\n                    ox, oy, oz, ow, oh, od = obs\n                    if ox <= px <= ox+ow and oy <= py <= oy+oh and oz <= pz <= oz+od:\n                        return True\n                else:\n                    ox, oy, ow, oh = obs\n                    if ox <= px <= ox+ow and oy <= py <= oy+oh:\n                        return True\n            return False\n\n        def edge_in_obstacle(a,b,res=1.0):\n            dist = math.dist(a,b)\n            if dist < 1e-12:\n                return False\n            steps = max(2,int(dist/res))\n            for i in range(steps+1):\n                interp = tuple(a[d] + (b[d]-a[d])*i/steps for d in range(dim))\n                if in_obstacle(interp):\n                    return True\n            return False\n\n        def steer(frm,to):\n            dist = math.dist(frm,to)\n            if dist <= self.step_size:\n                return to\n            r = self.step_size/dist\n            return tuple(frm[d] + (to[d]-frm[d])*r for d in range(dim))\n\n        # Spatial Hash Grid for neighbor queries\n        class SpatialGrid:\n            __slots__ = ('cell_size', 'dim','grid')\n            def __init__(self, bounds, cell_size):\n                self.cell_size = cell_size\n                self.dim = len(bounds)\n                self.grid = {}\n            def _hash(self,pos):\n                return tuple(int(pos[d]//self.cell_size) for d in range(self.dim))\n            def insert(self,node):\n                h = self._hash(node.position)\n                if h not in self.grid:\n                    self.grid[h] = []\n                self.grid[h].append(node)\n            def remove(self,node):\n                h = self._hash(node.position)\n                if h in self.grid:\n                    try:\n                        self.grid[h].remove(node)\n                        if not self.grid[h]:\n                            del self.grid[h]\n                    except ValueError:\n                        pass\n            def query_radius(self,pos,radius):\n                cr = int(math.ceil(radius/self.cell_size))\n                base = self._hash(pos)\n                result = []\n                rng = range(-cr,cr+1)\n                if self.dim == 2:\n                    for dx in rng:\n                        for dy in rng:\n                            cell = (base[0]+dx,base[1]+dy)\n                            if cell in self.grid:\n                                result.extend(self.grid[cell])\n                else:\n                    for dx in rng:\n                        for dy in rng:\n                            for dz in rng:\n                                cell = (base[0]+dx,base[1]+dy,base[2]+dz)\n                                if cell in self.grid:\n                                    result.extend(self.grid[cell])\n                r2 = radius*radius\n                filtered = []\n                for node in result:\n                    dist_sq = 0.0\n                    for d in range(self.dim):\n                        dist_sq += (node.position[d]-pos[d])**2\n                    if dist_sq <= r2:\n                        filtered.append(node)\n                return filtered\n            def nearest(self,pos):\n                # search increasing radius cells until find candidates\n                base = self._hash(pos)\n                search_range = 0\n                candidates = []\n                max_search = 8\n                while not candidates and search_range <= max_search:\n                    rng = range(-search_range, search_range+1)\n                    if self.dim == 2:\n                        for dx in rng:\n                            for dy in rng:\n                                cell = (base[0]+dx, base[1]+dy)\n                                if cell in self.grid:\n                                    candidates.extend(self.grid[cell])\n                    else:\n                        for dx in rng:\n                            for dy in rng:\n                                for dz in rng:\n                                    cell = (base[0]+dx, base[1]+dy, base[2]+dz)\n                                    if cell in self.grid:\n                                        candidates.extend(self.grid[cell])\n                    search_range += 1\n                if not candidates:\n                    return None\n                nearest_node = min(candidates,key=lambda n:math.dist(n.position,pos))\n                return nearest_node\n\n        def sample_uniform():\n            return tuple(random.uniform(0,bounds[d]) for d in range(dim))\n\n        def sample_informed(c_best):\n            if c_best == float('inf'):\n                # uniform fallback\n                for _ in range(30):\n                    s = sample_uniform()\n                    if not in_obstacle(s):\n                        return s\n                return sample_uniform()\n            c_min = math.dist(start_pos,goal_pos)\n            if c_min < 1e-12:\n                return sample_uniform()\n            center = tuple(0.5*(start_pos[d]+goal_pos[d]) for d in range(dim))\n            a1 = tuple((goal_pos[d]-start_pos[d])/c_min for d in range(dim))\n            radii = [c_best*0.5] + [math.sqrt(max(0,c_best*c_best-c_min*c_min))*0.5]*(dim-1)\n            # Build orthonormal basis\n            basis = [list(a1)]\n            for i in range(dim-1):\n                v = [0.0]*dim\n                v[(i+1)%dim] = 1.0\n                for b in basis: # orthogonalize\n                    proj = sum(v[j] * b[j] for j in range(dim))\n                    v = [v[j]-proj*b[j] for j in range(dim)]\n                nrm = math.sqrt(sum(x*x for x in v))\n                if nrm>1e-10:\n                    basis.append([x/nrm for x in v])\n                else:\n                    basis.append([0.0]*dim)\n            for _ in range(50):\n                # Sample in unit ball\n                vec = [random.gauss(0,1) for _ in range(dim)]\n                nrm = math.sqrt(sum(x*x for x in vec))\n                if nrm < 1e-10:\n                    continue\n                unit_vec = [x/nrm for x in vec]\n                r = random.random()**(1/dim)\n                scale = [radii[i]*unit_vec[i]*r for i in range(dim)]\n                p = [center[j]+sum(basis[i][j]*scale[i] for i in range(dim)) for j in range(dim)]\n                clamped = tuple(max(0.0,min(bounds[d],p[d])) for d in range(dim))\n                if not in_obstacle(clamped):\n                    return clamped\n            # fallback\n            return sample_uniform()\n\n        def choose_parent(nodes, grid, pos):\n            neighbors = grid.query_radius(pos, self.neighbor_radius)\n            candidates = [nb for nb in neighbors if nb and not edge_in_obstacle(nb.position,pos)]\n            if not candidates:\n                nearest = grid.nearest(pos)\n                if nearest is None:\n                    return None,None\n                if edge_in_obstacle(nearest.position,pos) or in_obstacle(pos):\n                    return None,None\n                cost = nearest.cost + math.dist(nearest.position,pos)\n                new_node = Node(pos, parent=nearest, cost=cost)\n                nodes.append(new_node)\n                grid.insert(new_node)\n                return new_node, []\n            best_parent = None\n            best_cost = float('inf')\n            for nb in candidates:\n                c = nb.cost + math.dist(nb.position,pos)\n                if c < best_cost:\n                    best_cost = c\n                    best_parent = nb\n            new_node = Node(pos, parent=best_parent, cost=best_cost)\n            nodes.append(new_node)\n            grid.insert(new_node)\n            return new_node, candidates\n\n        def rewire(new_node, neighbors, grid):\n            for nb in neighbors:\n                if nb == new_node.parent:\n                    continue\n                new_cost = new_node.cost + math.dist(new_node.position, nb.position)\n                if new_cost + 1e-12 < nb.cost:\n                    if edge_in_obstacle(new_node.position, nb.position):\n                        continue\n                    if nb.parent is not None:\n                        nb.parent.remove_child(nb)\n                    new_node.add_child(nb)\n                    nb.cost = new_cost\n                    # Propagate cost downstream\n                    stack = [nb]\n                    while stack:\n                        current = stack.pop()\n                        for ch in current.children:\n                            dcost = current.cost + math.dist(current.position, ch.position)\n                            if dcost + 1e-12 < ch.cost:\n                                ch.cost = dcost\n                                ch.parent = current\n                                stack.append(ch)\n\n        def try_connect(tree_nodes, tree_grid, other_node):\n            if not tree_nodes:\n                return None\n            nearest = tree_grid.nearest(other_node.position)\n            if nearest is None:\n                return None\n            dist = math.dist(nearest.position, other_node.position)\n            if dist <= self.step_size:\n                if edge_in_obstacle(nearest.position, other_node.position) or in_obstacle(other_node.position):\n                    return None\n                new_node = Node(other_node.position, parent=nearest, cost=nearest.cost + dist)\n                tree_nodes.append(new_node)\n                tree_grid.insert(new_node)\n                return new_node\n            # Stepwise steer toward other_node\n            current = nearest\n            steps = int(math.ceil(dist/self.step_size))\n            for _ in range(steps):\n                new_pos = steer(current.position, other_node.position)\n                if not in_bounds(new_pos) or in_obstacle(new_pos) or edge_in_obstacle(current.position,new_pos):\n                    return None\n                new_node = Node(new_pos, parent=current, cost=current.cost + math.dist(current.position,new_pos))\n                tree_nodes.append(new_node)\n                tree_grid.insert(new_node)\n                current = new_node\n                if math.dist(current.position, other_node.position)<=self.step_size:\n                    if edge_in_obstacle(current.position, other_node.position) or in_obstacle(other_node.position):\n                        return None\n                    final_node = Node(other_node.position, parent=current, cost=current.cost + math.dist(current.position, other_node.position))\n                    tree_nodes.append(final_node)\n                    tree_grid.insert(final_node)\n                    return final_node\n            return None\n\n        def shortcut_path(path):\n            if len(path)<3:\n                return list(path)\n            path = list(path)\n            for _pass in range(self.shortcut_passes):\n                changed = True\n                attempt = 0\n                while changed and attempt<self.shortcut_attempts:\n                    changed = False\n                    attempt+=1\n                    if len(path)<3:\n                        break\n                    i = random.randint(0,len(path)-3)\n                    j = random.randint(i+2,len(path)-1)\n                    p1, p2 = path[i], path[j]\n                    if not edge_in_obstacle(p1, p2):\n                        del path[i+1:j]\n                        changed = True\n            return path\n\n        # Initialization\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n        start_grid = SpatialGrid(bounds, self.grid_cell_size)\n        goal_grid = SpatialGrid(bounds, self.grid_cell_size)\n        start_grid.insert(start_root)\n        goal_grid.insert(goal_root)\n\n        best_path = []\n        best_cost = float('inf')\n        found = False\n        no_improve_count = 0\n        start_time = time.time()\n\n        for it in range(self.max_iter):\n            if time.time()-start_time > self.time_limit:\n                break\n\n            if it % 2 == 0:\n                tree_a, grid_a, tree_b, grid_b = start_tree, start_grid, goal_tree, goal_grid\n            else:\n                tree_a, grid_a, tree_b, grid_b = goal_tree, goal_grid, start_tree, start_grid\n\n            # Mixed sampling: uniform with some chance, else informed\n            if found and random.random() > self.uniform_sample_chance:\n                sample_pt = sample_informed(best_cost)\n            else:\n                sample_pt = sample_uniform()\n\n            if (not in_bounds(sample_pt)) or in_obstacle(sample_pt):\n                if found:\n                    no_improve_count += 1\n                    if no_improve_count >= self.no_improve_limit:\n                        break\n                continue\n\n            nearest = grid_a.nearest(sample_pt)\n            if nearest is None:\n                if found:\n                    no_improve_count += 1\n                    if no_improve_count >= self.no_improve_limit:\n                        break\n                continue\n            new_pos = steer(nearest.position, sample_pt)\n            if (not in_bounds(new_pos)) or in_obstacle(new_pos) or edge_in_obstacle(nearest.position, new_pos):\n                if found:\n                    no_improve_count += 1\n                    if no_improve_count >= self.no_improve_limit:\n                        break\n                continue\n\n            new_node, nbrs = choose_parent(tree_a, grid_a, new_pos)\n            if new_node is None:\n                if found:\n                    no_improve_count += 1\n                    if no_improve_count >= self.no_improve_limit:\n                        break\n                continue\n\n            rewire(new_node, nbrs, grid_a)\n\n            connect_node = try_connect(tree_b, grid_b, new_node)\n            if connect_node is not None:\n                # Merge paths\n                if it % 2 == 0:\n                    path_from_start = new_node.path_from_root()\n                    path_from_goal = connect_node.path_from_root()\n                else:\n                    path_from_start = connect_node.path_from_root()\n                    path_from_goal = new_node.path_from_root()\n                if path_from_start and path_from_goal and (path_from_start[-1] == path_from_goal[0]):\n                    merged = path_from_start + path_from_goal[1:]\n                else:\n                    merged = path_from_start + path_from_goal[::-1]\n\n                total_c = 0.0\n                for i in range(len(merged)-1):\n                    total_c += math.dist(merged[i], merged[i+1])\n\n                if total_c + 1e-9 < best_cost:\n                    best_cost = total_c\n                    best_path = merged\n                    found = True\n                    no_improve_count = 0\n                else:\n                    if found:\n                        no_improve_count += 1\n                        if no_improve_count >= self.no_improve_limit:\n                            break\n            else:\n                if found:\n                    no_improve_count += 1\n                    if no_improve_count >= self.no_improve_limit:\n                        break\n\n        if found and len(best_path) > 3:\n            best_path = shortcut_path(best_path)\n\n        return PlannerResult(success=found, path=best_path,\n                             nodes=start_tree + goal_tree,\n                             edges=[])",
          "objective": -19.00081,
          "time_improvement": 25.0,
          "length_improvement": 16.0,
          "smoothness_improvement": 357.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.030222225189208984,
                    "num_nodes_avg": 147.0,
                    "path_length_avg": 162.0589896865739,
                    "smoothness_avg": 0.021746527251033477,
                    "success_improvement": 0.0,
                    "time_improvement": -24.445884322185734,
                    "length_improvement": 11.172899763764093,
                    "smoothness_improvement": 240.3803748184353,
                    "objective_score": 0.5718764356949124
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.04946160316467285,
                    "num_nodes_avg": 282.2,
                    "path_length_avg": 241.89141723062008,
                    "smoothness_avg": 0.01840407680337228,
                    "success_improvement": 0.0,
                    "time_improvement": 69.36703156248413,
                    "length_improvement": 19.24968247001802,
                    "smoothness_improvement": 373.55015207148193,
                    "objective_score": 34.227669711113464
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.034723854064941405,
                    "num_nodes_avg": 227.5,
                    "path_length_avg": 123.09634178803749,
                    "smoothness_avg": 0.04389464248336121,
                    "success_improvement": 0.0,
                    "time_improvement": 29.88016658241256,
                    "length_improvement": 18.245271002285925,
                    "smoothness_improvement": 458.3366124228713,
                    "objective_score": 22.20289563820968
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "initial",
          "algorithm_description": "This algorithm is a dual-tree variant of Rapidly-exploring Random Tree (RRT) that grows two trees from the start and goal positions, attempting to connect them as they expand. It is efficient for single-query problems due to its bidirectional search and reduced redundant exploration.",
          "planning_mechanism": "The planner alternates between growing the start and goal trees by extending towards randomly sampled points. Each extension step involves checking for collision-free motion and attempting to connect the two trees. The algorithm terminates when a valid path is formed connecting the trees.",
          "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n        nodes = []\n        edges = []\n        success_state = False\n        extracted_path = []\n\n        for iter in range(self.max_iter):\n            rand = self._sample_free(bounds, obstacles, is_3d)\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest = self._nearest(tree_a, rand)\n                new_pos = self._steer(nearest.position, rand, self.step_size)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                    continue\n                new_node = Node(new_pos, parent=nearest, cost=nearest.cost + self._distance(nearest.position, new_pos))\n                nearest.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((nearest, new_node))\n\n                connect_node = self._nearest(tree_b, new_pos)\n                if self._connect_trees(new_node, connect_node, obstacles, is_3d, tree_b, nodes, edges):\n                    success_state = True\n                    extracted_path = self._extract_path(new_node, connect_node)\n                    return PlannerResult(True, extracted_path, start_tree + goal_tree, edges)\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        while True:\n            if is_3d:\n                point = tuple(random.uniform(0, bounds[i]) for i in range(3))\n            else:\n                point = tuple(random.uniform(0, bounds[i]) for i in range(2))\n            if not self._is_in_obstacle(point, obstacles, is_3d):\n                return point\n\n    def _nearest(self, tree, point):\n        return min(tree, key=lambda node: self._distance(node.position, point))\n\n    def _steer(self, from_pos, to_pos, step_size):\n        dist = self._distance(from_pos, to_pos)\n        if dist <= step_size:\n            return to_pos\n        ratio = step_size / dist\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n    def _connect_trees(self, node_a, node_b, obstacles, is_3d, tree, nodes, edges):\n        from_pos = node_a.position\n        to_pos = node_b.position\n        if self._is_edge_in_obstacle(from_pos, to_pos, obstacles, is_3d):\n            return False\n        curr = node_b\n        path = []\n        while True:\n            new_pos = self._steer(curr.position, from_pos, self.step_size)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return False\n            if self._is_edge_in_obstacle(curr.position, new_pos, obstacles, is_3d):\n                return False\n            new_node = Node(new_pos, parent=curr, cost=curr.cost + self._distance(curr.position, new_pos))\n            curr.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((curr, new_node))\n            if self._distance(new_pos, from_pos) < self.step_size:\n                new_node_final = Node(from_pos, parent=new_node, cost=new_node.cost + self._distance(new_pos, from_pos))\n                new_node.add_child(new_node_final)\n                tree.append(new_node_final)\n                nodes.append(new_node_final)\n                edges.append((new_node, new_node_final))\n                return True\n            curr = new_node\n\n    def _extract_path(self, node_a, node_b):\n        path_a = []\n        while node_a:\n            path_a.append(node_a.position)\n            node_a = node_a.parent\n        path_b = []\n        while node_b:\n            path_b.append(node_b.position)\n            node_b = node_b.parent\n        return list(reversed(path_a)) + path_b\n\n    def _distance(self, a, b):\n        return math.dist(a, b)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = self._distance(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n    ",
          "objective": -18.199350067879823,
          "time_improvement": 67.0,
          "length_improvement": -4.0,
          "smoothness_improvement": 78.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.009241986274719238,
                    "num_nodes_avg": 98.6,
                    "path_length_avg": 188.60059541559173,
                    "smoothness_avg": 0.011107369580525531,
                    "success_improvement": 0.0,
                    "time_improvement": 61.94432581815326,
                    "length_improvement": -3.3749749149674124,
                    "smoothness_improvement": 73.85445397432328,
                    "objective_score": 16.927585066337148
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.013762164115905761,
                    "num_nodes_avg": 215.1,
                    "path_length_avg": 298.4716236591105,
                    "smoothness_avg": 0.007330142954732018,
                    "success_improvement": 0.0,
                    "time_improvement": 91.47670289636794,
                    "length_improvement": 0.3615809932444448,
                    "smoothness_improvement": 88.6098579138185,
                    "objective_score": 28.103008754426142
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.02535843849182129,
                    "num_nodes_avg": 323.5,
                    "path_length_avg": 164.19293370544943,
                    "smoothness_avg": 0.013510302519313377,
                    "success_improvement": 0.0,
                    "time_improvement": 48.79227750896705,
                    "length_improvement": -9.049128539847096,
                    "smoothness_improvement": 71.85005081886685,
                    "objective_score": 9.567456382876191
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e1",
          "algorithm_description": "A Bidirectional Rapidly Exploring Random Tree with Dynamic Neighborhood and Progressive Path Refinement, integrating adaptive radius based on tree growth and solution quality, combined with a heuristic-informed sampling strategy that progressively focuses on the solution corridor. The algorithm grows two trees from start and goal with efficient parent selection, incremental rewiring within a dynamically adjusted radius to optimize path cost and smoothness, and applies multi-stage smoothing and shortcutting after path extraction for superior smoothness and length efficiency. Early stopping based on stagnation further improves planning efficiency.",
          "planning_mechanism": "The planning mechanism involves alternating expansions of start and goal trees by sampling points sampled uniformly early and gradually focused within an ellipsoidal informed subset once a feasible path is found. New nodes are added via steering toward samples, with parent selection and rewiring performed over adaptively sized neighborhoods for cost-effective connections. Upon successful connection of the two trees, the path is extracted and then multi-stage smoothing (combining shortcutting and curvature reduction) is applied. Early stopping occurs when no improvement in path cost is observed over a set number of iterations, thus reducing unnecessary computations. This method improves time efficiency, path length, smoothness, and success robustness over previous methods.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=4000, step_size=5.0, n_neighbors=30, max_no_improve=60, improve_tol=1e-5, shortcut_iters=350):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.n_neighbors = n_neighbors\n        self.max_no_improve = max_no_improve\n        self.improve_tol = improve_tol\n        self.shortcut_iters = shortcut_iters\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n        import time\n\n        start = tuple(map.start)\n        goal = tuple(map.goal)\n        bounds = tuple(map.size)\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        dist = lambda a,b: math.dist(a,b)\n\n        def in_obstacle(p):\n            # Efficient obstacle check\n            px = p[0]\n            py = p[1]\n            pz = p[2] if is_3d else 0.0\n            for obs in obstacles:\n                if is_3d:\n                    ox, oy, oz, ow, oh, od = obs\n                    if ox <= px <= ox + ow and oy <= py <= oy + oh and oz <= pz <= oz + od:\n                        return True\n                else:\n                    ox, oy, ow, oh = obs\n                    if ox <= px <= ox + ow and oy <= py <= oy + oh:\n                        return True\n            return False\n\n        def edge_obstacle(frm, to, resolution=1.0):\n            length = dist(frm, to)\n            if length < 1e-12:\n                return False\n            steps = max(3, int(length / resolution))\n            for i in range(steps + 1):\n                interm = tuple(frm[j] + (to[j] - frm[j]) * (i / steps) for j in range(dim))\n                if in_obstacle(interm):\n                    return True\n            return False\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            ratio = self.step_size / d\n            return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(dim))\n\n        def nearest(tree, point):\n            nearest_node = None\n            best_d = float('inf')\n            px = point\n            for node in tree:\n                # early prune distance squared\n                d2 = 0.0\n                for i in range(dim):\n                    dd = node.position[i] - px[i]\n                    d2 += dd*dd\n                    if d2 > best_d*best_d:\n                        break\n                else:\n                    d = math.sqrt(d2)\n                    if d < best_d:\n                        best_d = d\n                        nearest_node = node\n            return nearest_node, best_d\n\n        def near_nodes(tree, point, radius):\n            r2 = radius*radius\n            result = []\n            px = point\n            for node in tree:\n                d2 = 0.0\n                for i in range(dim):\n                    dd = node.position[i] - px[i]\n                    d2 += dd*dd\n                    if d2 > r2:\n                        break\n                if d2 <= r2:\n                    result.append(node)\n            return result\n\n        c_min = dist(start, goal)\n        if c_min < 1e-12:  # trivial case\n            return PlannerResult(True, [start], [Node(start)], [])\n\n        def ellipsoid_sample(c_best):\n            # If no solution yet, uniform sampling inside bounds\n            if c_best == float('inf'):\n                for _ in range(50):\n                    sample = tuple(random.uniform(0.0, bounds[i]) for i in range(dim))\n                    if not in_obstacle(sample):\n                        return sample\n                return tuple(random.uniform(0.0, bounds[i]) for i in range(dim))\n            center = tuple((start[i] + goal[i])*0.5 for i in range(dim))\n            a1 = [goal[i] - start[i] for i in range(dim)]\n            norm_a1 = math.sqrt(sum(x*x for x in a1))\n            if norm_a1 < 1e-14:\n                return tuple(random.uniform(0.0, bounds[i]) for i in range(dim))\n            unit_a1 = [x / norm_a1 for x in a1]\n            U = [unit_a1]\n            for idx in range(dim - 1):\n                base = [0.0]*dim\n                base[(idx+1)%dim] = 1.0\n                for u in U:\n                    proj = sum(base[j]*u[j] for j in range(dim))\n                    base = [base[j] - proj*u[j] for j in range(dim)]\n                norm_base = math.sqrt(sum(x*x for x in base))\n                if norm_base > 1e-14:\n                    U.append([x / norm_base for x in base])\n                else:\n                    U.append([0.0]*dim)\n            r1 = c_best * 0.5\n            val = c_best*c_best - c_min*c_min\n            r2 = math.sqrt(val)*0.5 if val > 0 else 0.0\n            radii = [r1] + [r2]*(dim-1)\n\n            for _ in range(50):\n                x_ball = [random.gauss(0,1) for _ in range(dim)]\n                norm_ball = math.sqrt(sum(x*x for x in x_ball))\n                if norm_ball < 1e-14:\n                    continue\n                unit_ball = [x / norm_ball for x in x_ball]\n                u = random.random()**(1/dim)\n                point_ball = [coord*u for coord in unit_ball]\n                scaled = [radii[i]*point_ball[i] for i in range(dim)]\n                rotated = [0.0]*dim\n                for i in range(dim):\n                    for j in range(dim):\n                        rotated[j] += scaled[i]*U[i][j]\n                sample = tuple(center[i] + rotated[i] for i in range(dim))\n                if all(0.0 <= sample[i] <= bounds[i] for i in range(dim)) and not in_obstacle(sample):\n                    return sample\n            # fallback uniform\n            for _ in range(20):\n                sample = tuple(random.uniform(0.0, bounds[i]) for i in range(dim))\n                if not in_obstacle(sample):\n                    return sample\n            return tuple(random.uniform(0.0, bounds[i]) for i in range(dim))\n\n        def connect_path(n1, n2):\n            path1 = n1.path_from_root()\n            path2 = n2.path_from_root()[::-1]\n            if path1 and path2 and path1[-1] == path2[0]:\n                return path1 + path2[1:]\n            return path1 + path2\n\n        def curvature_angle(p1, p2, p3):\n            # Returns angle (radians) at p2 formed by p1-p2-p3, zero if any point missing\n            if p1 is None or p2 is None or p3 is None:\n                return 0.0\n            v1 = [p2[i]-p1[i] for i in range(dim)]\n            v2 = [p3[i]-p2[i] for i in range(dim)]\n            len1 = math.sqrt(sum(x*x for x in v1))\n            len2 = math.sqrt(sum(x*x for x in v2))\n            if len1 < 1e-14 or len2 < 1e-14:\n                return 0.0\n            dot = sum(v1[i]*v2[i] for i in range(dim)) / (len1*len2)\n            dot = max(-1.0, min(1.0, dot))\n            return math.acos(dot)\n\n        def choose_parent(tree, new_pos, radius, c_best):\n            near = near_nodes(tree, new_pos, radius)\n            if not near:\n                return None, None, []\n\n            alpha = 0.04\n            # Find least cost + curvature penalty parent\n            best_parent = None\n            best_cost = float('inf')\n            best_score = float('inf')\n            for cand in near:\n                if edge_obstacle(cand.position, new_pos):\n                    continue\n                cost_to_new = cand.cost + dist(cand.position, new_pos)\n                penalty = 0.0\n                if cand.parent:\n                    penalty = alpha * curvature_angle(cand.parent.position, cand.position, new_pos)\n                score = cost_to_new + penalty\n                if score + self.improve_tol < best_score:\n                    best_score = score\n                    best_parent = cand\n                    best_cost = cost_to_new\n            neighbors = near\n            return best_parent, best_cost, neighbors\n\n        def rewire(new_node, neighbors, radius):\n            alpha = 0.04\n            for nb in neighbors:\n                if nb == new_node.parent:\n                    continue\n                if edge_obstacle(new_node.position, nb.position):\n                    continue\n                alt_cost = new_node.cost + dist(new_node.position, nb.position)\n                if alt_cost + self.improve_tol < nb.cost:\n                    # Check curvature penalty for rewiring\n                    old_curv = 0.0\n                    new_curv = 0.0\n                    if nb.parent and nb.parent.parent:\n                        old_curv = curvature_angle(nb.parent.parent.position if nb.parent else None, nb.parent.position if nb.parent else None, nb.position)\n                    if new_node.parent:\n                        new_curv = curvature_angle(new_node.parent.position, new_node.position, nb.position)\n                    if alpha*new_curv <= alpha*old_curv + 0.15:\n                        if nb.parent:\n                            nb.parent.remove_child(nb)\n                        new_node.add_child(nb)\n                        nb.cost = alt_cost\n\n        def add_node(tree, sample, nodes_all, edges, c_best):\n            nn, _ = nearest(tree, sample)\n            if nn is None:\n                return None\n            new_pos = steer(nn.position, sample)\n            if in_obstacle(new_pos) or edge_obstacle(nn.position, new_pos):\n                return None\n            n_nodes = len(nodes_all)\n            if n_nodes < 2:\n                radius = self.step_size * 3.0\n            else:\n                radius = min(\n                    max(self.step_size * 1.5, (self.n_neighbors * (math.log(n_nodes)/n_nodes))**(1/dim)),\n                    self.step_size * 7.0)\n                if c_best != float('inf'):\n                    shrink = max(0.3, c_best / (c_min*3.0))\n                    radius = max(self.step_size, radius * shrink)\n            best_parent, best_cost, neighbors = choose_parent(tree, new_pos, radius, c_best)\n            if best_parent is None:\n                return None\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = best_cost\n            tree.append(new_node)\n            nodes_all.append(new_node)\n            edges.append((best_parent, new_node))\n            rewire(new_node, neighbors, radius)\n            return new_node\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            path = list(path)\n            changed = True\n            iter_ct = 0\n            while changed and iter_ct < self.shortcut_iters:\n                changed = False\n                iter_ct += 1\n                i = 0\n                while i < len(path) - 2:\n                    max_j = min(len(path) - 1, i + 8 + random.randint(0,4))\n                    if max_j <= i+1:\n                        i += 1\n                        continue\n                    j = random.randint(i+2, max_j)\n                    if not edge_obstacle(path[i], path[j]):\n                        # shortcut valid, remove intermediate nodes\n                        path[i+1:j] = []\n                        changed = True\n                        break\n                    i += 1\n            return path\n\n        def reduce_curvature(path):\n            # Iteratively smooth by local averaging weighted toward neighbors to reduce sharp angles\n            if len(path) < 4:\n                return path\n            new_path = path[:]\n            for _ in range(3):\n                for i in range(1, len(new_path)-1):\n                    p_prev, p_curr, p_next = new_path[i-1], new_path[i], new_path[i+1]\n                    if edge_obstacle(p_prev, p_next):\n                        continue\n                    # Weighted average to smooth position\n                    new_coords = tuple((p_prev[d]+p_curr[d]*4+p_next[d])/6.0 for d in range(dim))\n                    if not in_obstacle(new_coords):\n                        new_path[i] = new_coords\n            return new_path\n\n        start_tree = [Node(start)]\n        goal_tree = [Node(goal)]\n        nodes_all = start_tree + goal_tree\n        edges = []\n\n        best_cost = float('inf')\n        best_path = []\n        found_solution = False\n\n        no_improve = 0\n        last_best = float('inf')\n        start_time = time.time()\n\n        for it in range(self.max_iter):\n            sample = ellipsoid_sample(best_cost if found_solution else float('inf'))\n            tree_a, tree_b = (start_tree, goal_tree) if it % 2 == 0 else (goal_tree, start_tree)\n            new_node = add_node(tree_a, sample, nodes_all, edges, best_cost)\n            if new_node is None:\n                if found_solution:\n                    no_improve += 1\n                continue\n            nbr, nbr_dist = nearest(tree_b, new_node.position)\n            if nbr and nbr_dist <= self.step_size and not edge_obstacle(new_node.position, nbr.position):\n                candidate_path = connect_path(new_node, nbr)\n                candidate_cost = new_node.cost + dist(new_node.position, nbr.position) + nbr.cost\n                if candidate_cost + self.improve_tol < best_cost:\n                    best_cost = candidate_cost\n                    best_path = candidate_path\n                    found_solution = True\n                    no_improve = 0\n                else:\n                    no_improve += 1\n            elif found_solution:\n                no_improve += 1\n\n            if found_solution and no_improve >= self.max_no_improve:\n                break\n            if found_solution and best_cost + self.improve_tol < last_best:\n                last_best = best_cost\n                no_improve = 0\n\n        if found_solution and len(best_path) > 3:\n            # Progressive smoothing passes for improved path quality\n            for _ in range(3):\n                best_path = shortcut_path(best_path)\n                best_path = reduce_curvature(best_path)\n\n        if found_solution:\n            return PlannerResult(True, best_path, nodes_all, edges)\n        return PlannerResult(False, [], nodes_all, edges)",
          "objective": -17.20387,
          "time_improvement": -2.0,
          "length_improvement": 18.0,
          "smoothness_improvement": 1437.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.029799556732177733,
                    "num_nodes_avg": 147.7,
                    "path_length_avg": 159.37740856897716,
                    "smoothness_avg": 0.040218780278571606,
                    "success_improvement": 0.0,
                    "time_improvement": -22.705464826895604,
                    "length_improvement": 12.642716866690892,
                    "smoothness_improvement": 529.5112478388893,
                    "objective_score": 3.4215469111403
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.05219976902008057,
                    "num_nodes_avg": 317.2,
                    "path_length_avg": 230.68279278463743,
                    "smoothness_avg": 0.10361431391684292,
                    "success_improvement": 0.0,
                    "time_improvement": 67.6712080780303,
                    "length_improvement": 22.991443932453425,
                    "smoothness_improvement": 2566.0709274541,
                    "objective_score": 46.92658342015165
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.07507524490356446,
                    "num_nodes_avg": 331.9,
                    "path_length_avg": 123.7842452328091,
                    "smoothness_avg": 0.10332650358391371,
                    "success_improvement": 0.0,
                    "time_improvement": -51.60366866469273,
                    "length_improvement": 17.788398288710596,
                    "smoothness_improvement": 1214.3054988182332,
                    "objective_score": 1.263465867909705
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m1",
          "algorithm_description": "This algorithm advances bidirectional RRT* by integrating a balanced KD-tree for efficient nearest neighbor queries, an adaptive rewiring radius that shrinks with improved solution cost, and an informed ellipsoidal sampling that progressively focuses search within the current best path corridor. It employs cost and curvature-aware parent selection with adaptive rewiring to locally optimize connections. Early stopping prevents wasted iterations after convergence stagnation. A comprehensive multi-pass shortcutting post-processing enhances path smoothness and reduces length, yielding paths that are efficient, smooth, and robust with significantly reduced planning time.",
          "planning_mechanism": "The planner grows two trees from start and goal alternately, inserting nodes sampled within an adaptive ellipsoid around the best path to focus refinement. Nearest neighbors and near nodes are found efficiently via a KD-tree structure to accelerate rewiring. New nodes are connected using minimal cost plus curvature penalty. Rewiring radius adapts based on node count and path cost, narrowing as better solutions emerge to concentrate optimization locally. The trees attempt reconnection at every iteration. Early termination is triggered by stalled improvement. Shortcutting smooths and shortens the final path before returning it.",
          "code": "class Node:\n    __slots__ = ('position', 'parent', 'cost', 'children', 'index')\n    def __init__(self, position, parent=None, cost=0.0, index=-1):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.index = index  # for tracking in KD-tree\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n            child.parent = None\n        except ValueError:\n            pass\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        path.reverse()\n        return path\nclass Planner:\n    def __init__(self, max_iter=3500, step_size=5.5, n_near_const=25,\n                 max_no_improve=60, improve_tol=1e-6, shortcut_iters=300):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.n_near_const = n_near_const\n        self.max_no_improve = max_no_improve\n        self.improve_tol = improve_tol\n        self.shortcut_iters = shortcut_iters\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n        import time\n        from bisect import bisect_left\n\n        start_pos = tuple(map.start)\n        goal_pos = tuple(map.goal)\n        bounds = tuple(map.size)\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        dist_func = lambda a, b: math.dist(a, b)\n\n        def in_obstacle(p):\n            px, py, pz = (p + (0, 0, 0))[:3]\n            for obs in obstacles:\n                if is_3d:\n                    ox, oy, oz, ow, oh, od = obs\n                    if ox <= px <= ox + ow and oy <= py <= oy + oh and oz <= pz <= oz + od:\n                        return True\n                else:\n                    ox, oy, ow, oh = obs\n                    if ox <= px <= ox + ow and oy <= py <= oy + oh:\n                        return True\n            return False\n\n        def edge_in_collision(a, b, resolution=1.0):\n            length = dist_func(a, b)\n            if length < 1e-12:\n                return False\n            steps = max(2, int(length / resolution))\n            for i in range(steps + 1):\n                interp = tuple(a[d] + (b[d] - a[d]) * i / steps for d in range(dim))\n                if in_obstacle(interp):\n                    return True\n            return False\n\n        def steer(frm, to):\n            d = dist_func(frm, to)\n            if d <= self.step_size:\n                return to\n            ratio = self.step_size / d\n            return tuple(frm[i] + (to[i] - frm[i]) * ratio for i in range(dim))\n\n        # KD-tree implementation specialized for efficient radius and nearest queries\n        class KDTree:\n            __slots__ = ('points', 'nodes', 'dim', 'tree', 'indices')\n            def __init__(self, points, nodes):\n                self.points = points  # list of tuples\n                self.nodes = nodes    # corresponding Node instances\n                self.dim = len(points[0]) if points else 0\n                self.indices = list(range(len(points)))\n                self.tree = self.build(0, len(points), 0)\n\n            def build(self, start, end, axis):\n                if start >= end:\n                    return None\n                mid = (start + end) >> 1\n                self.indices[start:end] = sorted(self.indices[start:end], key=lambda i: self.points[i][axis])\n                median_index = self.indices[mid]\n                left = self.build(start, mid, (axis + 1) % self.dim)\n                right = self.build(mid + 1, end, (axis + 1) % self.dim)\n                return (median_index, axis, left, right)\n\n            def _dist_sq(self, p1, p2):\n                return sum((p1[i] - p2[i]) ** 2 for i in range(self.dim))\n\n            def nearest(self, point):\n                best = [None, float('inf')]\n\n                def search(node):\n                    if node is None:\n                        return\n                    idx, axis, left, right = node\n                    pivot = self.points[idx]\n                    d_axis = point[axis] - pivot[axis]\n                    d_sq = self._dist_sq(point, pivot)\n                    if d_sq < best[1]:\n                        best[0], best[1] = idx, d_sq\n                    close, away = (left, right) if d_axis < 0 else (right, left)\n                    search(close)\n                    if d_axis * d_axis < best[1]:\n                        search(away)\n\n                search(self.tree)\n                return self.nodes[best[0]] if best[0] is not None else None, math.sqrt(best[1]) if best[0] is not None else float('inf')\n\n            def radius_search(self, point, radius):\n                radius_sq = radius * radius\n                results = []\n\n                def search(node):\n                    if node is None:\n                        return\n                    idx, axis, left, right = node\n                    pivot = self.points[idx]\n                    d_axis = point[axis] - pivot[axis]\n                    d_sq = self._dist_sq(point, pivot)\n                    if d_sq <= radius_sq:\n                        results.append(self.nodes[idx])\n                    if d_axis < 0:\n                        search(left)\n                        if d_axis * d_axis <= radius_sq:\n                            search(right)\n                    else:\n                        search(right)\n                        if d_axis * d_axis <= radius_sq:\n                            search(left)\n\n                search(self.tree)\n                return results\n\n        def adaptive_radius(n_nodes, c_best, c_min):\n            gamma = self.n_near_const\n            if n_nodes <= 1:\n                return self.step_size * 4.0\n            base_radius = min((gamma * (math.log(n_nodes) / n_nodes)) ** (1/dim), self.step_size * 6.0)\n            if c_best == float('inf'):\n                return base_radius\n            shrink = max(0.4, c_best / (c_min * 3.2))\n            return max(self.step_size * 0.7, base_radius * shrink)\n\n        # Informed ellipsoidal sampling\n        def ellipsoid_sample(c_best):\n            if c_best == float('inf'):\n                # uniform random within bounds, retry to avoid obstacles\n                for _ in range(50):\n                    pt = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                    if not in_obstacle(pt):\n                        return pt\n                # fallback\n                return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n            center = tuple((start_pos[i] + goal_pos[i]) * 0.5 for i in range(dim))\n            a1 = [goal_pos[i] - start_pos[i] for i in range(dim)]\n            norm_a1 = math.sqrt(sum(x*x for x in a1))\n            if norm_a1 < 1e-14:\n                return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n\n            unit_a1 = [x / norm_a1 for x in a1]\n\n            # Construct orthonormal basis\n            U = [unit_a1]\n            for idx in range(dim - 1):\n                base = [0.0]*dim\n                base[(idx + 1) % dim] = 1.0\n                for u in U:\n                    proj = sum(base[j] * u[j] for j in range(dim))\n                    base = [base[j] - proj * u[j] for j in range(dim)]\n                norm_base = math.sqrt(sum(x*x for x in base))\n                if norm_base > 1e-14:\n                    U.append([x / norm_base for x in base])\n                else:\n                    U.append([0.0]*dim)\n\n            r1 = c_best * 0.5\n            val = c_best*c_best - c_min*c_min\n            r2 = math.sqrt(max(0.0, val)) * 0.5\n            radii = [r1] + [r2] * (dim - 1)\n\n            max_attempts = 50\n            for _ in range(max_attempts):\n                x_ball = [random.gauss(0, 1) for _ in range(dim)]\n                norm_ball = math.sqrt(sum(x*x for x in x_ball))\n                if norm_ball < 1e-14:\n                    continue\n                unit_ball = [x / norm_ball for x in x_ball]\n                u = random.random() ** (1.0 / dim)\n                pt_ball = [coord * u for coord in unit_ball]\n                scaled = [radii[i] * pt_ball[i] for i in range(dim)]\n                pt_rot = [0.0]*dim\n                for i in range(dim):\n                    for j in range(dim):\n                        pt_rot[j] += scaled[i]*U[i][j]\n                sample = tuple(center[i] + pt_rot[i] for i in range(dim))\n                if all(0.0 <= sample[i] <= bounds[i] for i in range(dim)) and not in_obstacle(sample):\n                    return sample\n            # fallback\n            for _ in range(50):\n                pt = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                if not in_obstacle(pt):\n                    return pt\n            return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n\n        def curvature_penalty(p_par, p_cur, p_new):\n            if p_par is None:\n                return 0.0\n            v1 = tuple(p_cur[i] - p_par[i] for i in range(dim))\n            v2 = tuple(p_new[i] - p_cur[i] for i in range(dim))\n            len1 = math.sqrt(sum(x*x for x in v1))\n            len2 = math.sqrt(sum(x*x for x in v2))\n            if len1 < 1e-14 or len2 < 1e-14:\n                return 0.0\n            dot = sum(v1[i]*v2[i] for i in range(dim)) / (len1 * len2)\n            dot = max(-1.0, min(1.0, dot))\n            angle = math.acos(dot)\n            return angle\n\n        def add_node(tree, kd_tree, position, nodes_all, edges, c_best, c_min):\n            nearest_node, _ = kd_tree.nearest(position)\n            if nearest_node is None:\n                return None\n            new_pos = steer(nearest_node.position, position)\n            if in_obstacle(new_pos) or edge_in_collision(nearest_node.position, new_pos):\n                return None\n\n            n_nodes = len(nodes_all)\n            radius = adaptive_radius(n_nodes, c_best, c_min)\n            near_nodes = kd_tree.radius_search(new_pos, radius)\n\n            alpha_curv = 0.04\n            best_parent = nearest_node\n            best_cost = nearest_node.cost + dist_func(nearest_node.position, new_pos)\n            best_score = best_cost + alpha_curv * curvature_penalty(nearest_node.parent.position if nearest_node.parent else None, nearest_node.position, new_pos)\n\n            for candidate in near_nodes:\n                if candidate is nearest_node:\n                    continue\n                if edge_in_collision(candidate.position, new_pos):\n                    continue\n                c_cost = candidate.cost + dist_func(candidate.position, new_pos)\n                c_curv = alpha_curv * curvature_penalty(candidate.parent.position if candidate.parent else None, candidate.position, new_pos)\n                score = c_cost + c_curv\n                if score + self.improve_tol < best_score:\n                    best_parent = candidate\n                    best_cost = c_cost\n                    best_score = score\n\n            new_node = Node(new_pos, parent=best_parent, cost=best_cost, index=len(nodes_all))\n            best_parent.add_child(new_node)\n            tree.append(new_node)\n            nodes_all.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rebuild KD-tree after adding node for near searches\n            points = [node.position for node in tree]\n            kd_tree_new = KDTree(points, tree)\n\n            # Rewire neighbors around new_node\n            near_nodes_rewire = kd_tree_new.radius_search(new_node.position, radius)\n            for near_node in near_nodes_rewire:\n                if near_node is best_parent or near_node is new_node:\n                    continue\n                alt_cost = new_node.cost + dist_func(new_node.position, near_node.position)\n                if alt_cost + self.improve_tol < near_node.cost and not edge_in_collision(new_node.position, near_node.position):\n                    curv_new = curvature_penalty(new_node.parent.position if new_node.parent else None, new_node.position, near_node.position)\n                    par_par = near_node.parent.parent if near_node.parent and near_node.parent.parent else None\n                    curv_old = curvature_penalty(par_par.position if par_par else None,\n                                                near_node.parent.position if near_node.parent else None,\n                                                near_node.position)\n                    if alpha_curv * curv_new <= alpha_curv * curv_old + 0.20:\n                        if near_node.parent:\n                            near_node.parent.remove_child(near_node)\n                            try:\n                                edges.remove((near_node.parent, near_node))\n                            except Exception:\n                                pass\n                        new_node.add_child(near_node)\n                        near_node.cost = alt_cost\n                        edges.append((new_node, near_node))\n\n            return new_node, kd_tree_new\n\n        def connect_path(n_start, n_goal):\n            path_s = n_start.path_from_root()\n            path_g = n_goal.path_from_root()[::-1]\n            if path_s and path_g and (path_s[-1] == path_g[0]):\n                return path_s + path_g[1:]\n            else:\n                return path_s + path_g\n\n        # Progressive shortcutting for smoothing and shortening\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            path = list(path)\n            changed = True\n            iters = 0\n            max_iters = self.shortcut_iters\n            while changed and iters < max_iters:\n                changed = False\n                iters += 1\n                i = 0\n                while i < len(path) - 2:\n                    max_j = min(len(path) - 1, i + 7 + random.randint(0, 3))\n                    if max_j <= i + 1:\n                        i += 1\n                        continue\n                    j = random.randint(i + 2, max_j)\n                    # Check if direct edge between path[i] to path[j] is collision free\n                    if not edge_in_collision(path[i], path[j]):\n                        del path[i+1:j]\n                        changed = True\n                        break\n                    i += 1\n            return path\n\n        # Initialize trees\n        start_tree = [Node(start_pos, cost=0.0, index=0)]\n        goal_tree = [Node(goal_pos, cost=0.0, index=0)]\n        all_nodes = start_tree + goal_tree\n        edges = []\n\n        c_min = dist_func(start_pos, goal_pos)\n        best_cost = float('inf')\n        best_path = []\n        found_solution = False\n        no_improve_count = 0\n        last_best_cost = float('inf')\n\n        # Build initial KD-trees\n        kd_start = KDTree([start_pos], start_tree)\n        kd_goal = KDTree([goal_pos], goal_tree)\n\n        start_time = time.time()\n\n        for iteration in range(self.max_iter):\n            sample = ellipsoid_sample(best_cost if found_solution else float('inf'))\n\n            if iteration % 2 == 0:\n                tree_a, kd_a, tree_b, kd_b = start_tree, kd_start, goal_tree, kd_goal\n            else:\n                tree_a, kd_a, tree_b, kd_b = goal_tree, kd_goal, start_tree, kd_start\n\n            result = add_node(tree_a, kd_a, sample, all_nodes, edges, best_cost, c_min)\n            if result is None:\n                if found_solution:\n                    no_improve_count += 1\n                # Keep previous kd-tree\n                if iteration % 2 == 0:\n                    kd_start = kd_a\n                else:\n                    kd_goal = kd_a\n                continue\n            new_node, new_kd = result\n            if iteration % 2 == 0:\n                kd_start = new_kd\n            else:\n                kd_goal = new_kd\n\n            near_other, near_dist = kd_b.nearest(new_node.position)\n            if near_other is not None and near_dist <= self.step_size and not edge_in_collision(new_node.position, near_other.position):\n                candidate_cost = new_node.cost + dist_func(new_node.position, near_other.position) + near_other.cost\n                if candidate_cost + self.improve_tol < best_cost:\n                    best_cost = candidate_cost\n                    best_path = connect_path(new_node, near_other)\n                    found_solution = True\n                    no_improve_count = 0\n                else:\n                    no_improve_count += 1\n            else:\n                if found_solution:\n                    no_improve_count += 1\n\n            if found_solution and no_improve_count >= self.max_no_improve:\n                break\n\n            if found_solution and best_cost + self.improve_tol < last_best_cost:\n                last_best_cost = best_cost\n                no_improve_count = 0\n\n        if found_solution and len(best_path) > 3:\n            for _ in range(3):\n                best_path = shortcut_path(best_path)\n\n        if found_solution:\n            return PlannerResult(True, best_path, all_nodes, edges)\n        else:\n            return PlannerResult(False, [], all_nodes, edges)",
          "objective": -16.61183,
          "time_improvement": -1.0,
          "length_improvement": 16.0,
          "smoothness_improvement": 1506.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.02538433074951172,
                    "num_nodes_avg": 144.7,
                    "path_length_avg": 161.91038709095244,
                    "smoothness_avg": 0.041956492683206094,
                    "success_improvement": 0.0,
                    "time_improvement": -4.524913975486087,
                    "length_improvement": 11.254351201183036,
                    "smoothness_improvement": 556.7102204743027,
                    "objective_score": 8.178687630435508
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.061910390853881836,
                    "num_nodes_avg": 314.2,
                    "path_length_avg": 238.43476608984375,
                    "smoothness_avg": 0.0967468096960904,
                    "success_improvement": 0.0,
                    "time_improvement": 61.65714559095049,
                    "length_improvement": 20.403612114995642,
                    "smoothness_improvement": 2389.3650973907847,
                    "objective_score": 42.686136433236456
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.07939004898071289,
                    "num_nodes_avg": 321.1,
                    "path_length_avg": 127.44802909950822,
                    "smoothness_avg": 0.131331635766113,
                    "success_improvement": 0.0,
                    "time_improvement": -60.31679545509257,
                    "length_improvement": 15.355087495088846,
                    "smoothness_improvement": 1570.5287130519753,
                    "objective_score": -1.029342574214585
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m1",
          "algorithm_description": "A bidirectional RRT* inspired planner that grows two trees from start and goal with rewiring and dynamic neighbor radius, incorporating path shortcutting after connection to reduce path length and improve smoothness while ensuring collision-free nodes and edges throughout. It balances exploration and optimization, seeks lowest cost connections, and maintains efficient updates for paths and parents.",
          "planning_mechanism": "The planner samples collision-free points within the map bounds, extends the nearest node of one tree towards the sample, rewires neighbors for lower-cost paths, and attempts to connect the other tree to the newly added node with rewiring as well. Upon connection, a path is extracted and post-processed with shortcutting to smooth and shorten it. The rewiring radius adapts with the tree size to balance exploration and optimization. This enables efficient bidirectional growth with asymptotic optimality and improved path quality.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=5.0, gamma=50.0, max_rewire_radius=50.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.gamma = gamma\n        self.max_rewire_radius = max_rewire_radius\n\n    def plan(self, map):\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        success = False\n        final_path = []\n\n        for iter in range(self.max_iter):\n            sample = self._sample_free(bounds, obstacles, is_3d)\n\n            # Alternate trees for growth each iteration\n            if iter % 2 == 0:\n                new_node = self._extend_tree(tree_start, tree_goal, sample, obstacles, is_3d, nodes, edges, bounds)\n                if new_node:\n                    conn_node = self._connect_tree(tree_goal, new_node, obstacles, is_3d, nodes, edges, bounds)\n                    if conn_node:\n                        success = True\n                        path_start = new_node.path_from_root()\n                        path_goal = conn_node.path_from_root()\n                        if path_start and path_goal and path_start[-1] == path_goal[-1]:\n                            path_goal = path_goal[:-1]\n                        merged_path = path_start + path_goal[::-1]\n                        final_path = self._shortcut_path(merged_path, obstacles, is_3d, bounds)\n                        break\n            else:\n                new_node = self._extend_tree(tree_goal, tree_start, sample, obstacles, is_3d, nodes, edges, bounds)\n                if new_node:\n                    conn_node = self._connect_tree(tree_start, new_node, obstacles, is_3d, nodes, edges, bounds)\n                    if conn_node:\n                        success = True\n                        path_goal = new_node.path_from_root()\n                        path_start = conn_node.path_from_root()\n                        if path_goal and path_start and path_goal[-1] == path_start[-1]:\n                            path_start = path_start[:-1]\n                        merged_path = path_goal + path_start[::-1]\n                        final_path = self._shortcut_path(merged_path, obstacles, is_3d, bounds)\n                        break\n\n        return PlannerResult(success, final_path, nodes, edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        while True:\n            p = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    def _nearest(self, tree, point):\n        return min(tree, key=lambda node: self._dist(node.position, point))\n\n    def _steer(self, from_pos, to_pos):\n        dist = self._dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _near(self, tree, point, bounds):\n        n = len(tree)\n        d = len(point)\n        if n == 0:\n            return []\n        r_ddl = self.gamma * ((math.log(n) / n) ** (1.0 / d)) if n > 1 else self.step_size * 2\n        radius = max(self.step_size * 2, min(self.max_rewire_radius, r_ddl))\n        near_nodes = [node for node in tree if self._dist(node.position, point) <= radius]\n        return near_nodes\n\n    def _extend_tree(self, tree_to_extend, other_tree, sample, obstacles, is_3d, nodes, edges, bounds):\n        nearest = self._nearest(tree_to_extend, sample)\n        new_pos = self._steer(nearest.position, sample)\n        if self._is_in_obstacle(new_pos, obstacles, is_3d):\n            return None\n        if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n            return None\n\n        near_nodes = self._near(tree_to_extend, new_pos, bounds)\n\n        # Choose best parent among neighbors (including nearest) with minimal cost\n        min_cost = nearest.cost + self._dist(nearest.position, new_pos)\n        best_parent = nearest\n        for nb in near_nodes:\n            if not self._is_edge_in_obstacle(nb.position, new_pos, obstacles, is_3d):\n                cost_through_nb = nb.cost + self._dist(nb.position, new_pos)\n                if cost_through_nb < min_cost:\n                    min_cost = cost_through_nb\n                    best_parent = nb\n\n        new_node = Node(new_pos, parent=None, cost=min_cost)\n        best_parent.add_child(new_node)\n        tree_to_extend.append(new_node)\n        nodes.append(new_node)\n        edges.append((best_parent, new_node))\n\n        # Rewire neighbors to new node if cheaper and collision-free edge\n        for nb in near_nodes:\n            if nb == best_parent:\n                continue\n            if not self._is_edge_in_obstacle(new_node.position, nb.position, obstacles, is_3d):\n                cost_through_new = new_node.cost + self._dist(new_node.position, nb.position)\n                if cost_through_new + 1e-12 < nb.cost:\n                    # Reassign parent\n                    if nb.parent:\n                        nb.parent.remove_child(nb)\n                        try:\n                            edges.remove((nb.parent, nb))\n                        except:\n                            pass\n                    new_node.add_child(nb)\n                    nb.cost = cost_through_new\n                    edges.append((new_node, nb))\n\n        return new_node\n\n    def _connect_tree(self, tree_to_connect, target_node, obstacles, is_3d, nodes, edges, bounds):\n        nearest = self._nearest(tree_to_connect, target_node.position)\n\n        new_pos = target_node.position\n        if self._is_in_obstacle(new_pos, obstacles, is_3d):\n            return None\n        if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n            return None\n\n        near_nodes = self._near(tree_to_connect, new_pos, bounds)\n\n        min_cost = nearest.cost + self._dist(nearest.position, new_pos)\n        best_parent = nearest\n        for nb in near_nodes:\n            if not self._is_edge_in_obstacle(nb.position, new_pos, obstacles, is_3d):\n                cost_through_nb = nb.cost + self._dist(nb.position, new_pos)\n                if cost_through_nb < min_cost:\n                    min_cost = cost_through_nb\n                    best_parent = nb\n\n        new_node = Node(new_pos, parent=None, cost=min_cost)\n        best_parent.add_child(new_node)\n        tree_to_connect.append(new_node)\n        nodes.append(new_node)\n        edges.append((best_parent, new_node))\n\n        for nb in near_nodes:\n            if nb == best_parent:\n                continue\n            if not self._is_edge_in_obstacle(new_node.position, nb.position, obstacles, is_3d):\n                cost_through_new = new_node.cost + self._dist(new_node.position, nb.position)\n                if cost_through_new + 1e-12 < nb.cost:\n                    if nb.parent:\n                        nb.parent.remove_child(nb)\n                        try:\n                            edges.remove((nb.parent, nb))\n                        except:\n                            pass\n                    new_node.add_child(nb)\n                    nb.cost = cost_through_new\n                    edges.append((new_node, nb))\n\n        return new_node\n\n    def _shortcut_path(self, path, obstacles, is_3d, bounds):\n        if len(path) < 3:\n            return path[:]\n        shortened = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            while j > i + 1:\n                if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                    break\n                j -= 1\n            shortened.append(path[j])\n            i = j\n        return shortened\n\n    def _dist(self, a, b):\n        return math.dist(a, b)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        dist = self._dist(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * i / steps for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -16.5554,
          "time_improvement": -1.0,
          "length_improvement": 16.0,
          "smoothness_improvement": 1439.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.050579285621643065,
                    "num_nodes_avg": 106.8,
                    "path_length_avg": 164.2712937810431,
                    "smoothness_avg": 0.04226815816929853,
                    "success_improvement": 0.0,
                    "time_improvement": -108.27003598058127,
                    "length_improvement": 9.960300833383796,
                    "smoothness_improvement": 561.5884621240848,
                    "objective_score": -23.69688798352368
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.049871516227722165,
                    "num_nodes_avg": 224.9,
                    "path_length_avg": 237.86532514731707,
                    "smoothness_avg": 0.10161854011327172,
                    "success_improvement": 0.0,
                    "time_improvement": 69.11316081994654,
                    "length_improvement": 20.593707892059786,
                    "smoothness_improvement": 2514.7182299904466,
                    "objective_score": 45.66376413117207
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.03152651786804199,
                    "num_nodes_avg": 152.6,
                    "path_length_avg": 123.96994519489405,
                    "smoothness_avg": 0.10533489541470797,
                    "success_improvement": 0.0,
                    "time_improvement": 36.33672757035219,
                    "length_improvement": 17.66506521597572,
                    "smoothness_improvement": 1239.8520946618717,
                    "objective_score": 27.699317874000446
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "An improved bidirectional RRT* variant with systematic alternating tree expansions, adaptive rewiring radius, and ellipsoidal informed sampling to focus search. The planner emphasizes efficient parent selection, dynamic rewiring, early stopping on stagnation, and robust tree connection, producing shorter, smoother paths with reduced computation times.",
          "planning_mechanism": "The planner grows two trees from start and goal with alternate expansions. Initially samples uniformly, switches to ellipsoidal informed sampling after first solution to concentrate on promising regions. Each new node selects best parent minimizing cost and performs local rewiring within an adaptive radius that reduces over time. Attempts direct connection between trees after each insertion. Tracks best path and stops early if no improvement occurs over a threshold.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self,\n                 max_iter=5000,\n                 step_size=5.0,\n                 max_radius=20.0,\n                 min_radius=5.0,\n                 improvement_tol=1e-6,\n                 max_no_improve=80,\n                 time_limit=30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.max_radius = max_radius\n        self.min_radius = min_radius\n        self.improvement_tol = improvement_tol\n        self.max_no_improve = max_no_improve\n        self.time_limit = time_limit\n\n    def plan(self, map):\n        import time\n        import math\n        import random\n\n        bounds = map.size\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        best_path = []\n        best_cost = float('inf')\n        c_min = math.dist(start_pos, goal_pos)\n        found_solution = False\n        no_improve_count = 0\n\n        start_time = time.time()\n\n        def in_bounds(pos):\n            return all(0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d = obs\n                    px,py,pz = pos\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                        return True\n                else:\n                    x,y,w,h = obs\n                    px,py = pos\n                    if x <= px <= x+w and y <= py <= y+h:\n                        return True\n            return False\n\n        def edge_in_obstacle(a,b,res=1.0):\n            dist = math.dist(a,b)\n            if dist < 1e-12:\n                return False\n            steps = max(2, int(dist/res))\n            for i in range(steps+1):\n                interp = tuple(a[d]+(b[d]-a[d])*i/steps for d in range(dim))\n                if in_obstacle(interp):\n                    return True\n            return False\n\n        def steer(from_p, to_p):\n            dist = math.dist(from_p, to_p)\n            if dist <= self.step_size:\n                return to_p\n            ratio = self.step_size / dist\n            return tuple(from_p[d] + (to_p[d]-from_p[d]) * ratio for d in range(dim))\n\n        def adaptive_radius(n, iter_i):\n            factor = max(0.0, 1.0 - iter_i / self.max_iter)\n            radius = max(self.min_radius, min(self.max_radius, self.max_radius*factor*(math.log(n+1)/(n+1))**(1/dim)))\n            return radius\n\n        def neighbors(tree, pos, radius):\n            r_sq = radius*radius\n            return [node for node in tree if sum((node.position[d]-pos[d])**2 for d in range(dim)) <= r_sq]\n\n        def choose_parent(tree, pos, iter_i):\n            n = len(tree)\n            r = adaptive_radius(n, iter_i)\n            nbrs = neighbors(tree, pos, r)\n            nearest = min(tree, key=lambda node: math.dist(node.position, pos))\n            min_cost = nearest.cost + math.dist(nearest.position, pos)\n            best_parent = nearest\n            for nb in nbrs:\n                if edge_in_obstacle(nb.position, pos):\n                    continue\n                c = nb.cost + math.dist(nb.position, pos)\n                if c < min_cost:\n                    min_cost = c\n                    best_parent = nb\n            new_node = Node(pos, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n            return new_node, nbrs\n\n        def rewire(pivot, nbrs):\n            for nb in nbrs:\n                if nb == pivot.parent:\n                    continue\n                if edge_in_obstacle(pivot.position, nb.position):\n                    continue\n                new_cost = pivot.cost + math.dist(pivot.position, nb.position)\n                if new_cost + 1e-12 < nb.cost:\n                    if nb.parent is not None:\n                        try:\n                            edges.remove((nb.parent, nb))\n                        except ValueError:\n                            pass\n                        if nb in nb.parent.children:\n                            nb.parent.children.remove(nb)\n                    pivot.add_child(nb)\n                    nb.cost = new_cost\n                    edges.append((pivot, nb))\n\n        def direct_connect(tree, target_node):\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda n: math.dist(n.position, target_node.position))\n            dist_to_target = math.dist(nearest.position, target_node.position)\n            if dist_to_target <= self.step_size:\n                if not edge_in_obstacle(nearest.position, target_node.position) and not in_obstacle(target_node.position):\n                    new_node = Node(target_node.position, cost=nearest.cost + dist_to_target)\n                    nearest.add_child(new_node)\n                    tree.append(new_node)\n                    nodes.append(new_node)\n                    edges.append((nearest, new_node))\n                    return new_node\n                return None\n            current = nearest\n            steps = int(math.ceil(dist_to_target / self.step_size))\n            for _ in range(steps):\n                new_pos = steer(current.position, target_node.position)\n                if (not in_bounds(new_pos) or in_obstacle(new_pos) or edge_in_obstacle(current.position, new_pos)):\n                    return None\n                new_node, nbrs = choose_parent(tree, new_pos, 0)\n                rewire(new_node, nbrs)\n                if math.dist(new_node.position, target_node.position) <= self.step_size:\n                    if not edge_in_obstacle(new_node.position, target_node.position) and not in_obstacle(target_node.position):\n                        final_node = Node(target_node.position, cost=new_node.cost + math.dist(new_node.position, target_node.position))\n                        new_node.add_child(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n                current = new_node\n            return None\n\n        def sample_uniform():\n            return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        def sample_informed():\n            if not found_solution or best_cost == float('inf') or c_min < 1e-12:\n                return sample_uniform()\n            center = tuple((start_pos[d] + goal_pos[d]) * 0.5 for d in range(dim))\n            unit_dir = []\n            for d in range(dim):\n                unit_dir.append((goal_pos[d] - start_pos[d]) / c_min)\n            r1 = best_cost * 0.5\n            val = best_cost*best_cost - c_min*c_min\n            val = max(val, 0.0)\n            r_other = math.sqrt(val)*0.5\n\n            if dim == 2:\n                a1 = unit_dir\n                a2 = (-a1[1], a1[0])\n                basis = (a1, a2)\n                radii = (r1, r_other)\n            else:\n                def cross(u,v):\n                    return (u[1]*v[2]-u[2]*v[1], u[2]*v[0]-u[0]*v[2], u[0]*v[1]-u[1]*v[0])\n                def norm(v):\n                    return math.sqrt(sum(x*x for x in v))\n                a1 = unit_dir\n                ref = (1,0,0) if abs(a1[0]) < 0.9 else (0,1,0)\n                b2 = cross(a1, ref)\n                n_b2 = norm(b2)\n                if n_b2 < 1e-12:\n                    ref = (0,0,1)\n                    b2 = cross(a1, ref)\n                    n_b2 = norm(b2)\n                b2 = tuple(x / n_b2 for x in b2)\n                b3 = cross(a1,b2)\n                basis = (a1,b2,b3)\n                radii = (r1, r_other, r_other)\n\n            def sample_unit_ball(dim):\n                while True:\n                    vec = [random.gauss(0,1) for _ in range(dim)]\n                    nrm = math.sqrt(sum(v*v for v in vec))\n                    if nrm < 1e-12:\n                        continue\n                    vec = [v/nrm for v in vec]\n                    r = random.random()**(1/dim)\n                    return [v*r for v in vec]\n\n            u = sample_unit_ball(dim)\n            mapped = []\n            for d in range(dim):\n                val = center[d]\n                for i in range(dim):\n                    val += basis[i][d]*radii[i]*u[i]\n                val = max(0.0, min(val, bounds[d]))\n                mapped.append(val)\n            return tuple(mapped)\n\n        for it in range(self.max_iter):\n            if time.time() - start_time > self.time_limit:\n                break\n\n            tree_a, tree_b = (start_tree, goal_tree) if it % 2 == 0 else (goal_tree, start_tree)\n            x_rand = sample_informed()\n\n            if not in_bounds(x_rand) or in_obstacle(x_rand):\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n                continue\n\n            nearest = min(tree_a, key=lambda node: math.dist(node.position, x_rand))\n            new_pos = steer(nearest.position, x_rand)\n            if not in_bounds(new_pos) or in_obstacle(new_pos) or edge_in_obstacle(nearest.position, new_pos):\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n                continue\n\n            new_node, nbrs = choose_parent(tree_a, new_pos, it)\n            rewire(new_node, nbrs)\n\n            meet_node = direct_connect(tree_b, new_node)\n            if meet_node is not None:\n                if it % 2 == 0:\n                    path_a = new_node.path_from_root()\n                    path_b = meet_node.path_from_root()\n                else:\n                    path_a = meet_node.path_from_root()\n                    path_b = new_node.path_from_root()\n\n                if path_a and path_b and path_a[-1] == path_b[-1]:\n                    merged_path = path_a + path_b[-2::-1]\n                else:\n                    merged_path = path_a + path_b[::-1]\n\n                total_cost = sum(math.dist(merged_path[i], merged_path[i+1]) for i in range(len(merged_path)-1))\n                if total_cost + self.improvement_tol < best_cost:\n                    best_cost = total_cost\n                    best_path = merged_path\n                    found_solution = True\n                    no_improve_count = 0\n                else:\n                    if found_solution:\n                        no_improve_count += 1\n                        if no_improve_count >= self.max_no_improve:\n                            break\n            else:\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n\n        return PlannerResult(success=found_solution, path=best_path, nodes=nodes, edges=edges)",
          "objective": -16.08771,
          "time_improvement": 40.0,
          "length_improvement": 6.0,
          "smoothness_improvement": 87.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.013728570938110352,
                    "num_nodes_avg": 139.3,
                    "path_length_avg": 162.96103402000978,
                    "smoothness_avg": 0.01309373526123321,
                    "success_improvement": 0.0,
                    "time_improvement": 43.469941734038215,
                    "length_improvement": 10.678474970800728,
                    "smoothness_improvement": 104.9453903395135,
                    "objective_score": 19.97279445438947
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.03920111656188965,
                    "num_nodes_avg": 345.6,
                    "path_length_avg": 293.5609018533765,
                    "smoothness_avg": 0.006549654700066657,
                    "success_improvement": 0.0,
                    "time_improvement": 75.72164083809092,
                    "length_improvement": 2.0009212792884186,
                    "smoothness_improvement": 68.52733295831173,
                    "objective_score": 24.259681683791886
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.048858261108398436,
                    "num_nodes_avg": 341.8,
                    "path_length_avg": 142.5416042258134,
                    "smoothness_avg": 0.014637545538668837,
                    "success_improvement": 0.0,
                    "time_improvement": 1.337762692279919,
                    "length_improvement": 5.330653575009229,
                    "smoothness_improvement": 86.18849882064363,
                    "objective_score": 4.030663446792731
               }
          ],
          "success_rate": 1.0
     }
]