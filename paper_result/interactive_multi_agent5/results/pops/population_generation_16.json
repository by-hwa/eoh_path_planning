[
     {
          "operator": "m3",
          "algorithm_description": "A simplified bidirectional RRT* planner with adaptive neighborhood radius, heuristic-informed sampling inside ellipsoidal bounds after first solution, and efficient rewiring that balances exploration and refinement. The algorithm alternates expansions between start and goal trees, prunes via cost-aware rewiring with radius scaled to tree size, and performs iterative shortcut smoothing on the result to improve path length and smoothness while limiting planning time with stagnation-based early stopping.",
          "planning_mechanism": "This planner grows two trees from start and goal, samples points uniformly initially, and after first solution focuses samples inside a heuristic ellipsoid bounding shorter solutions. Nodes are added using a steer function, parents are chosen among neighbors within a radius that decays adaptively with iteration count and tree size, and rewiring lowers path costs. Connection attempts bridge trees incrementally. Post planning applies iterative shortcut smoothing removing redundant points and reducing unnecessary detours, producing shorter, smoother paths faster than naive RRT*.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=4000, step_size=6.0, radius_max=25.0, radius_min=7.0, no_improve_limit=60, time_limit=25.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.radius_max = radius_max\n        self.radius_min = radius_min\n        self.no_improve_limit = no_improve_limit\n        self.time_limit = time_limit\n\n    def plan(self, map):\n        import time\n        import math\n        import random\n\n        bounds = map.size\n        dim = len(bounds)\n        start = tuple(map.start)\n        goal = tuple(map.goal)\n        obstacles = map.obstacles\n        is_3d = (dim == 3)\n\n        def in_bounds(p):\n            return all(0.0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def in_obstacle(p):\n            px, py, pz = (p + (0, 0, 0))[:3]\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    if x <= px <= x+w and y <= py <= y+h:\n                        return True\n            return False\n\n        def edge_in_obstacle(a, b, resolution=1.0):\n            dist = math.dist(a,b)\n            if dist < 1e-12:\n                return False\n            steps = max(3, int(dist/resolution))\n            for i in range(steps+1):\n                pt = tuple(a[d] + (b[d]-a[d]) * i/steps for d in range(dim))\n                if in_obstacle(pt):\n                    return True\n            return False\n\n        def steer(frm, to):\n            dist = math.dist(frm, to)\n            if dist <= self.step_size:\n                return to\n            ratio = self.step_size / dist\n            return tuple(frm[d] + (to[d]-frm[d]) * ratio for d in range(dim))\n\n        def adaptive_radius(n_nodes, iter_i):\n            if n_nodes < 2:\n                return self.radius_max\n            r = self.radius_max * ((math.log(n_nodes) / n_nodes) ** (1/dim))\n            decay = max(self.radius_min / self.radius_max, 1.0 - 0.9 * (iter_i / self.max_iter))\n            return max(self.radius_min, min(r * decay, self.radius_max))\n\n        def neighbors(tree, pos, radius):\n            r_sq = radius * radius\n            res = []\n            for node in tree:\n                d_sq = 0.0\n                for i in range(dim):\n                    diff = node.position[i] - pos[i]\n                    d_sq += diff*diff\n                    if d_sq > r_sq:\n                        break\n                else:\n                    res.append(node)\n            return res\n\n        def choose_parent(tree, new_pos, iter_i):\n            radius = adaptive_radius(len(tree), iter_i)\n            nbrs = neighbors(tree, new_pos, radius)\n            valid_parents = [n for n in nbrs if not edge_in_obstacle(n.position, new_pos)]\n            if not valid_parents:\n                # fallback nearest with collision\n                nearest = min((n for n in tree if not edge_in_obstacle(n.position, new_pos)), key=lambda n: math.dist(n.position, new_pos), default=None)\n                if nearest is None:\n                    return None, []\n                c = nearest.cost + math.dist(nearest.position, new_pos)\n                new_node = Node(new_pos, parent=nearest, cost=c)\n                nearest.add_child(new_node)\n                tree.append(new_node)\n                return new_node, []\n            best_parent = min(valid_parents, key=lambda n: n.cost + math.dist(n.position, new_pos))\n            c = best_parent.cost + math.dist(best_parent.position, new_pos)\n            new_node = Node(new_pos, parent=best_parent, cost=c)\n            best_parent.add_child(new_node)\n            tree.append(new_node)\n            return new_node, valid_parents\n\n        def rewire(pivot, nbrs):\n            for nb in nbrs:\n                if nb == pivot.parent:\n                    continue\n                dist_p = math.dist(pivot.position, nb.position)\n                new_cost = pivot.cost + dist_p\n                if new_cost + 1e-10 < nb.cost and not edge_in_obstacle(pivot.position, nb.position):\n                    if nb.parent:\n                        nb.parent.remove_child(nb)\n                    pivot.add_child(nb)\n                    nb.cost = new_cost\n\n        def attempt_connect(tree, target_node):\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda n: math.dist(n.position, target_node.position))\n            dist = math.dist(nearest.position, target_node.position)\n            if dist <= self.step_size:\n                if edge_in_obstacle(nearest.position, target_node.position) or in_obstacle(target_node.position):\n                    return None\n                new_node = Node(target_node.position, parent=nearest, cost=nearest.cost + dist)\n                nearest.add_child(new_node)\n                tree.append(new_node)\n                return new_node\n            current = nearest\n            steps = int(math.ceil(dist / self.step_size))\n            for _ in range(steps):\n                new_pos = steer(current.position, target_node.position)\n                if not in_bounds(new_pos) or in_obstacle(new_pos) or edge_in_obstacle(current.position, new_pos):\n                    return None\n                new_node = Node(new_pos, parent=current, cost=current.cost + math.dist(current.position, new_pos))\n                current.add_child(new_node)\n                tree.append(new_node)\n                current = new_node\n                if math.dist(current.position, target_node.position) <= self.step_size:\n                    if edge_in_obstacle(current.position, target_node.position) or in_obstacle(target_node.position):\n                        return None\n                    final_node = Node(target_node.position, parent=current, cost=current.cost + math.dist(current.position, target_node.position))\n                    current.add_child(final_node)\n                    tree.append(final_node)\n                    return final_node\n            return None\n\n        def sample_uniform():\n            return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        def sample_informed(c_best, c_min):\n            if c_best == float('inf') or c_min < 1e-12:\n                return sample_uniform()\n            center = tuple((start[d]+goal[d])*0.5 for d in range(dim))\n            unit_vec = []\n            for d in range(dim):\n                unit_vec.append((goal[d] - start[d]) / c_min)\n            r1 = c_best * 0.5\n            val = max(c_best*c_best - c_min*c_min, 0.0)\n            r_other = math.sqrt(val)*0.5\n\n            if dim == 2:\n                a1 = unit_vec\n                a2 = (-a1[1], a1[0])\n                basis = (a1, a2)\n                radii = (r1, r_other)\n            else:\n                def cross(u,v):\n                    return (u[1]*v[2]-u[2]*v[1], u[2]*v[0]-u[0]*v[2], u[0]*v[1]-u[1]*v[0])\n                def norm(v):\n                    return math.sqrt(sum(x*x for x in v))\n                a1 = unit_vec\n                ref = (1,0,0) if abs(a1[0]) < 0.9 else (0,1,0)\n                b2 = cross(a1, ref)\n                nb2 = norm(b2)\n                if nb2 < 1e-12:\n                    ref = (0,0,1)\n                    b2 = cross(a1, ref)\n                    nb2 = norm(b2)\n                b2 = tuple(x/nb2 for x in b2)\n                b3 = cross(a1,b2)\n                basis = (a1,b2,b3)\n                radii = (r1,r_other,r_other)\n\n            def sample_unit_ball(ndim):\n                while True:\n                    vec = [random.gauss(0,1) for _ in range(ndim)]\n                    nrm = math.sqrt(sum(v*v for v in vec))\n                    if nrm < 1e-12:\n                        continue\n                    vec = [v/nrm for v in vec]\n                    r = random.random()**(1/ndim)\n                    return [v*r for v in vec]\n\n            u = sample_unit_ball(dim)\n            mapped = []\n            for d in range(dim):\n                v = center[d]\n                for i in range(dim):\n                    v += basis[i][d]*radii[i]*u[i]\n                # Clamp to bounds\n                v = max(0.0, min(bounds[d], v))\n                mapped.append(v)\n            return tuple(mapped)\n\n        def shortcut_smooth(path, iterations=3):\n            if len(path) < 3:\n                return path[:]\n            for _ in range(iterations):\n                i = 0\n                while i < len(path)-2:\n                    if not edge_in_obstacle(path[i], path[i+2]):\n                        del path[i+1]\n                    else:\n                        i += 1\n            return path\n\n        start_node = Node(start, cost=0.0)\n        goal_node = Node(goal, cost=0.0)\n        start_tree = [start_node]\n        goal_tree = [goal_node]\n        nodes = [start_node, goal_node]\n        edges = []\n\n        best_path = []\n        best_cost = float('inf')\n        c_min = math.dist(start, goal)\n        found = False\n        no_improve = 0\n        t_start = time.time()\n\n        for i in range(self.max_iter):\n            if time.time() - t_start > self.time_limit:\n                break\n            if found:\n                sample = sample_informed(best_cost, c_min)\n                if random.random() < 0.1:\n                    sample = sample_uniform()\n            else:\n                sample = sample_uniform()\n\n            if not in_bounds(sample) or in_obstacle(sample):\n                if found:\n                    no_improve += 1\n                    if no_improve >= self.no_improve_limit:\n                        break\n                continue\n\n            tree_a, tree_b = (start_tree, goal_tree) if i%2 == 0 else (goal_tree, start_tree)\n\n            near = min(tree_a, key=lambda n: math.dist(n.position, sample))\n            new_pos = steer(near.position, sample)\n\n            if (not in_bounds(new_pos)) or in_obstacle(new_pos) or edge_in_obstacle(near.position, new_pos):\n                if found:\n                    no_improve += 1\n                    if no_improve >= self.no_improve_limit:\n                        break\n                continue\n\n            new_node, nbrs = choose_parent(tree_a, new_pos, i)\n            if new_node is None:\n                if found:\n                    no_improve += 1\n                    if no_improve >= self.no_improve_limit:\n                        break\n                continue\n\n            rewire(new_node, nbrs)\n            nodes.append(new_node)\n            if new_node.parent:\n                edges.append((new_node.parent, new_node))\n\n            connected = attempt_connect(tree_b, new_node)\n            if connected:\n                if i % 2 == 0:\n                    path1 = new_node.path_from_root()\n                    path2 = connected.path_from_root()\n                else:\n                    path1 = connected.path_from_root()\n                    path2 = new_node.path_from_root()\n                if path1 and path2 and path1[-1] == path2[-1]:\n                    candidate = path1 + path2[-2::-1]\n                else:\n                    candidate = path1 + path2[::-1]\n\n                cost_path = 0.0\n                for j in range(len(candidate)-1):\n                    cost_path += math.dist(candidate[j], candidate[j+1])\n\n                if cost_path + 1e-9 < best_cost:\n                    best_path = candidate\n                    best_cost = cost_path\n                    found = True\n                    no_improve = 0\n                else:\n                    no_improve += 1\n                    if no_improve >= self.no_improve_limit:\n                        break\n            else:\n                if found:\n                    no_improve += 1\n                    if no_improve >= self.no_improve_limit:\n                        break\n\n        if found and len(best_path) >= 3:\n            best_path = shortcut_smooth(best_path, iterations=5)\n\n        return PlannerResult(success=found, path=best_path, nodes=nodes, edges=edges)",
          "objective": -37.48589,
          "time_improvement": 65.0,
          "length_improvement": 16.0,
          "smoothness_improvement": 1704.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.015254044532775879,
                    "num_nodes_avg": 101.3,
                    "path_length_avg": 165.81254021340436,
                    "smoothness_avg": 0.05533273154630356,
                    "success_improvement": 0.0,
                    "time_improvement": 37.18850781215486,
                    "length_improvement": 9.115519241194,
                    "smoothness_improvement": 766.0774056493822,
                    "objective_score": 20.45625091660977
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.021648097038269042,
                    "num_nodes_avg": 222.5,
                    "path_length_avg": 236.7791727604512,
                    "smoothness_avg": 0.1135825828084687,
                    "success_improvement": 0.0,
                    "time_improvement": 86.59272181094168,
                    "length_improvement": 20.956296821958638,
                    "smoothness_improvement": 2822.561665889502,
                    "objective_score": 52.6644029659052
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.01422429084777832,
                    "num_nodes_avg": 175.1,
                    "path_length_avg": 124.63481867684409,
                    "smoothness_avg": 0.1276752449373225,
                    "success_improvement": 0.0,
                    "time_improvement": 71.27608868346934,
                    "length_improvement": 17.223487907137493,
                    "smoothness_improvement": 1524.0196915964568,
                    "objective_score": 39.337017807305585
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "A streamlined bidirectional RRT* planner with adaptive neighbor radius, hybrid uniform and ellipsoidal informed sampling guiding exploration toward promising solution regions, faster nearest neighbor pruning based on adaptive radius to reduce redundant rewires, and an efficient iterative path shortcutting for improved path quality and smoothness. Early termination on solution stagnation balances runtime and exploration thoroughness.",
          "planning_mechanism": "The planner grows two trees alternately from start and goal by steering toward sampled points, choosing parents among neighbors within an adaptive radius to minimize cost efficiently, rewiring to improve connectivity with pruning via adaptive radius neighbors, attempts to connect the two trees incrementally, uses hybrid sampling that switches to an ellipsoidal informed distribution after finding a solution, and finally applies iterative shortcut smoothing for path refinement. Early stopping on no improvement enhances computational efficiency.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=3500, step_size=4.0, radius_max=18.0, radius_min=5.0,\n                 no_improve_limit=50, shortcut_iter=120):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.radius_max = radius_max\n        self.radius_min = radius_min\n        self.no_improve_limit = no_improve_limit\n        self.shortcut_iter = shortcut_iter\n\n    def plan(self, map):\n        import math\n        import time\n        import random\n\n        start = tuple(map.start)\n        goal = tuple(map.goal)\n        bounds = tuple(map.size)\n        obstacles = map.obstacles\n        dim = len(bounds)\n\n        def in_bounds(p):\n            return all(0.0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def in_obstacle(p):\n            px, py, pz = (p + (0, 0, 0))[:3]\n            for obs in obstacles:\n                if dim == 3:\n                    ox, oy, oz, ow, oh, od = obs\n                    if ox <= px <= ox + ow and oy <= py <= oy + oh and oz <= pz <= oz + od:\n                        return True\n                else:\n                    ox, oy, ow, oh = obs\n                    if ox <= px <= ox + ow and oy <= py <= oy + oh:\n                        return True\n            return False\n\n        def edge_in_obstacle(a, b, resolution=1.0):\n            dist_ab = math.dist(a, b)\n            if dist_ab < 1e-12:\n                return False\n            steps = max(2, int(dist_ab / resolution))\n            for i in range(steps + 1):\n                pt = tuple(a[d] + (b[d] - a[d]) * i / steps for d in range(dim))\n                if in_obstacle(pt):\n                    return True\n            return False\n\n        def steer(frm, to):\n            dist_ = math.dist(frm, to)\n            if dist_ <= self.step_size:\n                return to\n            ratio = self.step_size / dist_\n            return tuple(frm[i] + (to[i] - frm[i]) * ratio for i in range(dim))\n\n        def adaptive_radius(n_nodes, iter_i):\n            if n_nodes < 2:\n                return self.radius_max\n            r = self.radius_max * ((math.log(n_nodes) / n_nodes) ** (1 / dim))\n            decay = max(self.radius_min / self.radius_max, 1.0 - 0.85 * (iter_i / self.max_iter))\n            return max(self.radius_min, min(r * decay, self.radius_max))\n\n        def neighbors(tree, point, radius):\n            r_sq = radius * radius\n            nbrs = []\n            for node in tree:\n                d_sq = 0.0\n                for i in range(dim):\n                    diff = node.position[i] - point[i]\n                    d_sq += diff * diff\n                    if d_sq > r_sq:\n                        break\n                else:\n                    nbrs.append(node)\n            return nbrs\n\n        def choose_parent(tree, new_pos, iter_i):\n            n_nodes = len(tree)\n            radius = adaptive_radius(n_nodes, iter_i)\n            nbrs = neighbors(tree, new_pos, radius)\n            valid_parents = [n for n in nbrs if not edge_in_obstacle(n.position, new_pos)]\n            if not valid_parents:\n                # fallback to nearest with edge check\n                nearest = None\n                nearest_dist = float('inf')\n                for n in tree:\n                    d = math.dist(n.position, new_pos)\n                    if d < nearest_dist and not edge_in_obstacle(n.position, new_pos):\n                        nearest = n\n                        nearest_dist = d\n                if nearest is None:\n                    return None, []\n                cost = nearest.cost + nearest_dist\n                new_node = Node(new_pos, parent=nearest, cost=cost)\n                nearest.add_child(new_node)\n                tree.append(new_node)\n                return new_node, []\n            best_parent = min(valid_parents, key=lambda p: p.cost + math.dist(p.position, new_pos))\n            min_cost = best_parent.cost + math.dist(best_parent.position, new_pos)\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree.append(new_node)\n            return new_node, valid_parents\n\n        def rewire(pivot, nbrs):\n            for nb in nbrs:\n                if nb is pivot.parent:\n                    continue\n                dist_p_nb = math.dist(pivot.position, nb.position)\n                new_cost = pivot.cost + dist_p_nb\n                if new_cost + 1e-12 < nb.cost and not edge_in_obstacle(pivot.position, nb.position):\n                    if nb.parent:\n                        nb.parent.remove_child(nb)\n                    pivot.add_child(nb)\n                    nb.cost = new_cost\n\n        def attempt_connect(tree, target_node):\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda n: math.dist(n.position, target_node.position))\n            dist_ = math.dist(nearest.position, target_node.position)\n            if dist_ <= self.step_size:\n                if edge_in_obstacle(nearest.position, target_node.position) or in_obstacle(target_node.position):\n                    return None\n                new_node = Node(target_node.position, parent=nearest, cost=nearest.cost + dist_)\n                nearest.add_child(new_node)\n                tree.append(new_node)\n                return new_node\n            current = nearest\n            steps = int(math.ceil(dist_ / self.step_size))\n            for _ in range(steps):\n                new_pos = steer(current.position, target_node.position)\n                if (not in_bounds(new_pos)) or in_obstacle(new_pos) or edge_in_obstacle(current.position, new_pos):\n                    return None\n                new_node = Node(new_pos, parent=current, cost=current.cost + math.dist(current.position, new_pos))\n                current.add_child(new_node)\n                tree.append(new_node)\n                current = new_node\n                if math.dist(current.position, target_node.position) <= self.step_size:\n                    if edge_in_obstacle(current.position, target_node.position) or in_obstacle(target_node.position):\n                        return None\n                    final_node = Node(target_node.position, parent=current, cost=current.cost + math.dist(current.position, target_node.position))\n                    current.add_child(final_node)\n                    tree.append(final_node)\n                    return final_node\n            return None\n\n        def sample_uniform():\n            return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        def ellipsoid_sample(c_best, c_min):\n            if c_best == float('inf') or c_min < 1e-12:\n                return sample_uniform()\n            center = tuple((start[d] + goal[d]) / 2 for d in range(dim))\n            a1 = [goal[d] - start[d] for d in range(dim)]\n            norm_a1 = math.sqrt(sum(x * x for x in a1))\n            if norm_a1 < 1e-15:\n                return sample_uniform()\n            unit_a1 = [x / norm_a1 for x in a1]\n            # construct orthonormal basis via Gram-Schmidt\n            basis = [unit_a1]\n            for idx in range(dim - 1):\n                base = [0.0] * dim\n                base[(idx + 1) % dim] = 1.0\n                for b in basis:\n                    proj = sum(base[j] * b[j] for j in range(dim))\n                    base = [base[j] - proj * b[j] for j in range(dim)]\n                norm_base = math.sqrt(sum(x * x for x in base))\n                if norm_base > 1e-15:\n                    base = [x / norm_base for x in base]\n                else:\n                    base = [0.0] * dim\n                basis.append(base)\n            r1 = c_best * 0.5\n            val = c_best * c_best - c_min * c_min\n            r_orth = math.sqrt(val) * 0.5 if val > 0 else 0.0\n            radii = [r1] + [r_orth] * (dim - 1)\n            for _ in range(30):\n                # sample unit ball\n                x_ball = [random.gauss(0., 1.) for _ in range(dim)]\n                norm_ball = math.sqrt(sum(x * x for x in x_ball))\n                if norm_ball < 1e-15:\n                    continue\n                unit_ball = [xx / norm_ball for xx in x_ball]\n                u = random.random() ** (1.0 / dim)\n                point_ball = [coord * u for coord in unit_ball]\n                # scale and rotate\n                sample_point = [0.0] * dim\n                for i_ in range(dim):\n                    for j_ in range(dim):\n                        sample_point[j_] += point_ball[i_] * radii[i_] * basis[i_][j_]\n                sample = tuple(max(0.0, min(center[i] + sample_point[i], bounds[i])) for i in range(dim))\n                if not in_obstacle(sample):\n                    return sample\n            return sample_uniform()\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return list(path)\n            path = list(path)\n            for _ in range(self.shortcut_iter):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if not edge_in_obstacle(path[i], path[j]):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        start_node = Node(start, cost=0.0)\n        goal_node = Node(goal, cost=0.0)\n        start_tree = [start_node]\n        goal_tree = [goal_node]\n        nodes = [start_node, goal_node]\n        edges = []\n\n        best_path = []\n        best_cost = float('inf')\n        c_min = math.dist(start, goal)\n        found_solution = False\n        no_improve_count = 0\n\n        start_time = time.time()\n\n        for iter_i in range(self.max_iter):\n            if found_solution:\n                sample = ellipsoid_sample(best_cost, c_min)\n                if random.random() < 0.2:\n                    sample = sample_uniform()\n            else:\n                sample = sample_uniform()\n\n            if not in_bounds(sample) or in_obstacle(sample):\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.no_improve_limit:\n                        break\n                continue\n\n            tree_a, tree_b = (start_tree, goal_tree) if iter_i % 2 == 0 else (goal_tree, start_tree)\n\n            nearest_node = min(tree_a, key=lambda n: math.dist(n.position, sample))\n            new_pos = steer(nearest_node.position, sample)\n            if not in_bounds(new_pos) or in_obstacle(new_pos) or edge_in_obstacle(nearest_node.position, new_pos):\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.no_improve_limit:\n                        break\n                continue\n\n            new_node, nbrs = choose_parent(tree_a, new_pos, iter_i)\n            if not new_node:\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.no_improve_limit:\n                        break\n                continue\n\n            rewire(new_node, nbrs)\n            nodes.append(new_node)\n            if new_node.parent:\n                edges.append((new_node.parent, new_node))\n\n            connect_node = attempt_connect(tree_b, new_node)\n            if connect_node:\n                if iter_i % 2 == 0:\n                    path_a = new_node.path_from_root()\n                    path_b = connect_node.path_from_root()\n                else:\n                    path_a = connect_node.path_from_root()\n                    path_b = new_node.path_from_root()\n\n                if path_a and path_b and path_a[-1] == path_b[-1]:\n                    candidate_path = path_a + path_b[-2::-1]\n                else:\n                    candidate_path = path_a + path_b[::-1]\n\n                total_cost = 0.0\n                for i in range(len(candidate_path) - 1):\n                    total_cost += math.dist(candidate_path[i], candidate_path[i + 1])\n\n                if total_cost + 1e-9 < best_cost:\n                    best_cost = total_cost\n                    best_path = candidate_path\n                    found_solution = True\n                    no_improve_count = 0\n                else:\n                    no_improve_count += 1\n                    if no_improve_count >= self.no_improve_limit:\n                        break\n            else:\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.no_improve_limit:\n                        break\n\n        if found_solution and len(best_path) >= 3:\n            best_path = shortcut_path(best_path)\n\n        return PlannerResult(success=found_solution, path=best_path, nodes=nodes, edges=edges)",
          "objective": -35.35386,
          "time_improvement": 56.0,
          "length_improvement": 17.0,
          "smoothness_improvement": 1654.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.015592575073242188,
                    "num_nodes_avg": 99.9,
                    "path_length_avg": 159.4495060769605,
                    "smoothness_avg": 0.03886240016513557,
                    "success_improvement": 0.0,
                    "time_improvement": 35.79454253611557,
                    "length_improvement": 12.603199080107105,
                    "smoothness_improvement": 508.28095363705586,
                    "objective_score": 20.841686977084215
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.033257794380187986,
                    "num_nodes_avg": 302.3,
                    "path_length_avg": 238.8612478430386,
                    "smoothness_avg": 0.11894377823211089,
                    "success_improvement": 0.0,
                    "time_improvement": 79.40250820100103,
                    "length_improvement": 20.261240230182576,
                    "smoothness_improvement": 2960.509085652796,
                    "objective_score": 50.78004202667384
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.02319345474243164,
                    "num_nodes_avg": 256.8,
                    "path_length_avg": 122.89703464593951,
                    "smoothness_avg": 0.1252212284453279,
                    "success_improvement": 0.0,
                    "time_improvement": 53.16415107965624,
                    "length_improvement": 18.377641316081167,
                    "smoothness_improvement": 1492.804782954941,
                    "objective_score": 34.439854028320276
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m2",
          "algorithm_description": "An enhanced bidirectional RRT* inspired planner employing consistent neighbor radius scaling based on node count and dimension, spatial hashing for efficient neighbor search, adaptive informed sampling within an ellipsoid post initial solution, dynamic rewiring without lazy checks, and a multi-pass systematic path shortcutting routine. The planner alternates expansion between start and goal trees, continuously attempts to directly connect trees, and halts early upon stagnation. This design improves search efficiency, robust path quality, shorter path length, and smoother final routes through comprehensive rewiring and effective path smoothing.",
          "planning_mechanism": "The planner grows two trees alternating expansions, using spatial hash grids for neighbor queries and sampling progressively within an informed ellipsoid after a first solution is found. For each new node, it selects the parent minimizing cost with thorough collision checks and rewires neighbors to improve paths. Direct connections between trees are attempted to merge routes efficiently. Finally, a multi-pass systematic shortcutting smooths and shortens the path. Early stopping is applied to terminate when no improvements occur, leading to faster convergence and strong path quality.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=4000, step_size=5.5,\n                 max_radius=28.0, min_radius=5.5,\n                 max_no_improve=70, time_limit=25.0,\n                 shortcut_iter=180):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.max_radius = max_radius\n        self.min_radius = min_radius\n        self.max_no_improve = max_no_improve\n        self.time_limit = time_limit\n        self.shortcut_iter = shortcut_iter\n\n    def plan(self, map):\n        import math\n        import random\n        import time\n\n        start = tuple(map.start)\n        goal = tuple(map.goal)\n        bounds = tuple(map.size)\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        dist = lambda a,b: math.dist(a, b)\n\n        def in_bounds(pos):\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def in_obstacle(pos):\n            if is_3d:\n                px, py, pz = pos\n                for obs in obstacles:\n                    ox, oy, oz, ow, oh, od = obs\n                    if ox <= px <= ox + ow and oy <= py <= oy + oh and oz <= pz <= oz + od:\n                        return True\n                return False\n            else:\n                px, py = pos\n                for obs in obstacles:\n                    ox, oy, ow, oh = obs\n                    if ox <= px <= ox + ow and oy <= py <= oy + oh:\n                        return True\n                return False\n\n        def edge_in_obstacle(a, b, res=1.0):\n            d = dist(a, b)\n            if d < 1e-12:\n                return False\n            steps = max(2, int(d / res))\n            for i in range(steps+1):\n                interp = tuple(a[d_] + (b[d_] - a[d_]) * i / steps for d_ in range(dim))\n                if in_obstacle(interp):\n                    return True\n            return False\n\n        def steer(from_p, to_p):\n            d = dist(from_p, to_p)\n            if d <= self.step_size:\n                return to_p\n            ratio = self.step_size / d\n            return tuple(from_p[d_] + (to_p[d_] - from_p[d_]) * ratio for d_ in range(dim))\n\n        # Spatial hash grid class to accelerate neighbor queries\n        class SpatialGrid:\n            def __init__(self, bounds, cell_size, dim):\n                self.bounds = bounds\n                self.cell_size = cell_size\n                self.dim = dim\n                self.cells = {}\n\n            def _hash_point(self, p):\n                return tuple(int(p[d] / self.cell_size) for d in range(self.dim))\n\n            def insert(self, node):\n                h = self._hash_point(node.position)\n                if h not in self.cells:\n                    self.cells[h] = []\n                self.cells[h].append(node)\n\n            def neighbors(self, point, radius):\n                low = [int((point[d] - radius) // self.cell_size) for d in range(self.dim)]\n                high = [int((point[d] + radius) // self.cell_size) for d in range(self.dim)]\n                result = []\n                def _grid_range(low_, high_, idx=None):\n                    if idx is None:\n                        idx = []\n                    if len(idx) == self.dim:\n                        yield tuple(idx)\n                        return\n                    dim_i = len(idx)\n                    for v in range(low_[dim_i], high_[dim_i] + 1):\n                        idx.append(v)\n                        yield from _grid_range(low_, high_, idx)\n                        idx.pop()\n                for cell in _grid_range(low, high):\n                    if cell in self.cells:\n                        result.extend(self.cells[cell])\n                return result\n\n            def clear(self):\n                self.cells.clear()\n\n        def adaptive_radius(n_nodes, iter_i):\n            # RRT* radius bound: gamma * (log(n)/n)^(1/d)\n            # Use slow decay with iteration via max_radius and min_radius clipping\n            gamma = self.max_radius\n            if n_nodes <= 1:\n                return gamma\n            base_r = gamma * (math.log(n_nodes) / n_nodes) ** (1.0/dim)\n            decay = max(self.min_radius / gamma, 1.0 - 0.85 * (iter_i / self.max_iter))\n            r = max(self.min_radius, min(base_r * decay, self.max_radius))\n            return r\n\n        def neighbors_in_radius(tree_nodes, grid, p, radius):\n            candidates = grid.neighbors(p, radius)\n            result = [n for n in candidates if dist(n.position, p) <= radius]\n            return result\n\n        def choose_parent(tree_nodes, grid, pos, iter_i):\n            n = len(tree_nodes)\n            r = adaptive_radius(n, iter_i)\n            nbrs = neighbors_in_radius(tree_nodes, grid, pos, r)\n            min_cost = float('inf')\n            best_parent = None\n            for nb in nbrs:\n                if edge_in_obstacle(nb.position, pos):\n                    continue\n                new_cost = nb.cost + dist(nb.position, pos)\n                if new_cost < min_cost:\n                    min_cost = new_cost\n                    best_parent = nb\n            if best_parent is None:\n                # fallback to nearest no collision node\n                nearest = min(tree_nodes, key=lambda node: dist(node.position, pos))\n                if edge_in_obstacle(nearest.position, pos):\n                    return None, []\n                best_parent = nearest\n                min_cost = best_parent.cost + dist(best_parent.position, pos)\n            new_node = Node(pos, parent=best_parent, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree_nodes.append(new_node)\n            grid.insert(new_node)\n            return new_node, nbrs\n\n        def rewire(pivot, nbrs):\n            for nb in nbrs:\n                if nb == pivot.parent:\n                    continue\n                new_cost = pivot.cost + dist(pivot.position, nb.position)\n                if new_cost + 1e-10 < nb.cost:\n                    if edge_in_obstacle(pivot.position, nb.position):\n                        continue\n                    if nb.parent is not None:\n                        nb.parent.remove_child(nb)\n                    pivot.add_child(nb)\n                    nb.cost = new_cost\n\n        def direct_connect(tree_nodes, grid, target_node):\n            if not tree_nodes:\n                return None\n            nearest = min(tree_nodes, key=lambda n: dist(n.position, target_node.position))\n            d_nearest = dist(nearest.position, target_node.position)\n            if d_nearest <= self.step_size:\n                if edge_in_obstacle(nearest.position, target_node.position) or in_obstacle(target_node.position):\n                    return None\n                new_node = Node(target_node.position, parent=nearest, cost=nearest.cost + d_nearest)\n                nearest.add_child(new_node)\n                tree_nodes.append(new_node)\n                grid.insert(new_node)\n                return new_node\n            # Try direct edge if no obstacles\n            if not edge_in_obstacle(nearest.position, target_node.position):\n                new_node = Node(target_node.position, parent=nearest, cost=nearest.cost + d_nearest)\n                nearest.add_child(new_node)\n                tree_nodes.append(new_node)\n                grid.insert(new_node)\n                return new_node\n            # Incrementally steer toward target\n            steps = int(math.ceil(d_nearest / self.step_size))\n            current = nearest\n            for _ in range(steps):\n                new_pos = steer(current.position, target_node.position)\n                if not in_bounds(new_pos) or in_obstacle(new_pos) or edge_in_obstacle(current.position, new_pos):\n                    return None\n                new_node = Node(new_pos, parent=current, cost=current.cost + dist(current.position, new_pos))\n                current.add_child(new_node)\n                tree_nodes.append(new_node)\n                grid.insert(new_node)\n                current = new_node\n                if dist(current.position, target_node.position) <= self.step_size:\n                    if edge_in_obstacle(current.position, target_node.position) or in_obstacle(target_node.position):\n                        return None\n                    final_node = Node(target_node.position, parent=current, cost=current.cost + dist(current.position, target_node.position))\n                    current.add_child(final_node)\n                    tree_nodes.append(final_node)\n                    grid.insert(final_node)\n                    return final_node\n            return None\n\n        def sample_uniform():\n            return tuple(random.uniform(0.0, bounds[d]) for d in range(dim))\n\n        def sample_informed():\n            if not found_solution or best_cost >= float('inf') or c_min < 1e-12:\n                return sample_uniform()\n            center = tuple((start[d] + goal[d]) * 0.5 for d in range(dim))\n            unit_dir = []\n            for d in range(dim):\n                unit_dir.append((goal[d] - start[d]) / c_min)\n            r1 = best_cost * 0.5\n            val = max(best_cost * best_cost - c_min * c_min, 0.0)\n            r_other = math.sqrt(val) * 0.5\n\n            if dim == 2:\n                a1 = unit_dir\n                a2 = (-a1[1], a1[0])\n                basis = (a1, a2)\n                radii = (r1, r_other)\n            else:\n                def cross(u,v):\n                    return (u[1]*v[2]-u[2]*v[1], u[2]*v[0]-u[0]*v[2], u[0]*v[1]-u[1]*v[0])\n                def norm(v):\n                    return math.sqrt(sum(x*x for x in v))\n                a1 = unit_dir\n                ref = (1,0,0) if abs(a1[0]) < 0.9 else (0,1,0)\n                b2 = cross(a1, ref)\n                n_b2 = norm(b2)\n                if n_b2 < 1e-12:\n                    ref = (0,0,1)\n                    b2 = cross(a1, ref)\n                    n_b2 = norm(b2)\n                b2 = tuple(x / n_b2 for x in b2)\n                b3 = cross(a1, b2)\n                basis = (a1, b2, b3)\n                radii = (r1, r_other, r_other)\n\n            def sample_unit_ball(dim_):\n                while True:\n                    vec = [random.gauss(0,1) for _ in range(dim_)]\n                    nrm = math.sqrt(sum(v*v for v in vec))\n                    if nrm < 1e-14:\n                        continue\n                    vec = [v/nrm for v in vec]\n                    r = random.random() ** (1.0/dim_)\n                    return [v*r for v in vec]\n\n            u = sample_unit_ball(dim)\n            mapped = []\n            for d in range(dim):\n                val = center[d]\n                for i in range(dim):\n                    if i < len(basis):\n                        val += basis[i][d] * radii[i] * u[i]\n                val = max(0.0, min(val, bounds[d]))\n                mapped.append(val)\n            return tuple(mapped)\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path[:]\n            path = list(path)\n            for _ in range(self.shortcut_iter):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if not edge_in_obstacle(p1, p2):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        def connect_paths(node_a, node_b):\n            path_a = node_a.path_from_root()\n            path_b = node_b.path_from_root()\n            if path_a[-1] == path_b[-1]:\n                return path_a + path_b[-2::-1]\n            else:\n                return path_a + path_b[::-1]\n\n        # Initialize trees\n        start_root = Node(start, cost=0.0)\n        goal_root = Node(goal, cost=0.0)\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n        edges = []\n        nodes = [start_root, goal_root]\n\n        # Spatial grids\n        cell_size = self.step_size * 1.5\n        grid_start = SpatialGrid(bounds, cell_size, dim)\n        grid_goal = SpatialGrid(bounds, cell_size, dim)\n        grid_start.insert(start_root)\n        grid_goal.insert(goal_root)\n\n        c_min = dist(start, goal)\n        best_cost = float('inf')\n        best_path = []\n        found_solution = False\n        no_improve = 0\n\n        start_time = time.time()\n\n        for it in range(self.max_iter):\n            if (time.time() - start_time) > self.time_limit:\n                break\n\n            tree_a, grid_a = (start_tree, grid_start) if it % 2 == 0 else (goal_tree, grid_goal)\n            tree_b, grid_b = (goal_tree, grid_goal) if it % 2 == 0 else (start_tree, grid_start)\n\n            x_rand = sample_informed()\n\n            if not in_bounds(x_rand) or in_obstacle(x_rand):\n                if found_solution:\n                    no_improve += 1\n                    if no_improve >= self.max_no_improve:\n                        break\n                continue\n\n            nearest = min(tree_a, key=lambda n: dist(n.position, x_rand))\n            new_pos = steer(nearest.position, x_rand)\n            if not in_bounds(new_pos) or in_obstacle(new_pos) or edge_in_obstacle(nearest.position, new_pos):\n                if found_solution:\n                    no_improve += 1\n                    if no_improve >= self.max_no_improve:\n                        break\n                continue\n\n            new_node, nbrs = choose_parent(tree_a, grid_a, new_pos, it)\n            if new_node is None:\n                if found_solution:\n                    no_improve += 1\n                    if no_improve >= self.max_no_improve:\n                        break\n                continue\n\n            rewire(new_node, nbrs)\n\n            nodes.append(new_node)\n            edges.append((new_node.parent, new_node))\n\n            meet_node = direct_connect(tree_b, grid_b, new_node)\n            if meet_node is not None:\n                candidate_path = connect_paths(new_node, meet_node)\n                total_cost = 0.0\n                for i in range(len(candidate_path) - 1):\n                    total_cost += dist(candidate_path[i], candidate_path[i+1])\n\n                if total_cost + 1e-9 < best_cost:\n                    best_cost = total_cost\n                    best_path = candidate_path\n                    found_solution = True\n                    no_improve = 0\n                else:\n                    if found_solution:\n                        no_improve += 1\n                        if no_improve >= self.max_no_improve:\n                            break\n            else:\n                if found_solution:\n                    no_improve += 1\n                    if no_improve >= self.max_no_improve:\n                        break\n\n        if found_solution and len(best_path) >= 3:\n            best_path = shortcut_path(best_path)\n\n        return PlannerResult(success=found_solution, path=best_path, nodes=nodes, edges=edges)",
          "objective": -34.03393,
          "time_improvement": 55.0,
          "length_improvement": 17.0,
          "smoothness_improvement": 1480.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.0197298526763916,
                    "num_nodes_avg": 94.0,
                    "path_length_avg": 153.44598923252843,
                    "smoothness_avg": 0.04652924545929119,
                    "success_improvement": 0.0,
                    "time_improvement": 18.758498142066845,
                    "length_improvement": 15.89382179435248,
                    "smoothness_improvement": 628.2837313116212,
                    "objective_score": 18.305261175789646
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.02853994369506836,
                    "num_nodes_avg": 236.0,
                    "path_length_avg": 236.42688152824053,
                    "smoothness_avg": 0.1008504544454795,
                    "success_improvement": 0.0,
                    "time_improvement": 82.32440643889325,
                    "length_improvement": 21.073901775411443,
                    "smoothness_improvement": 2494.954832528408,
                    "objective_score": 49.816437159556884
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.01848320960998535,
                    "num_nodes_avg": 193.4,
                    "path_length_avg": 129.01597928456926,
                    "smoothness_avg": 0.11146478831747879,
                    "success_improvement": 0.0,
                    "time_improvement": 62.67581425579548,
                    "length_improvement": 14.31372963993577,
                    "smoothness_improvement": 1317.8238799234878,
                    "objective_score": 33.98010146031754
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e1",
          "algorithm_description": "Bidirectional Anytime Informed RRT* with Curvature-Aware Spline Smoothing. This planner grows two trees simultaneously from start and goal with adaptive informed sampling based on current best cost to efficiently prune search space. It uses adaptive neighbor radius for rewiring to optimize path cost and performs early termination on stagnation. After finding a path, a smoothing phase fits cubic Bezier splines through the path to optimize curvature and generate smooth, continuous trajectories, improving path smoothness significantly without sacrificing path length or planning efficiency.",
          "planning_mechanism": "The planner alternates growing bidirectional RRT* trees using adaptive ellipsoidal informed sampling guided by current best path. It performs incremental rewiring within an adaptive radius minimizing cost while maintaining collision-free edges. Upon successful connection, it extracts the combined path and applies curvature-aware cubic Bezier spline smoothing to produce a natural, smooth trajectory before returning the final solution. Early stopping criteria speed convergence and limit unnecessary computation.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self,\n                 max_iter=6000,\n                 step_size=6.0,\n                 max_radius=35.0,\n                 min_radius=6.0,\n                 max_no_improve=70,\n                 time_limit=25.0,\n                 shortcut_iter=120):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.max_radius = max_radius\n        self.min_radius = min_radius\n        self.max_no_improve = max_no_improve\n        self.time_limit = time_limit\n        self.shortcut_iter = shortcut_iter\n\n    def plan(self, map):\n        import math, random, time\n\n        bounds = map.size\n        dim = len(bounds)\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = (dim == 3)\n\n        def in_bounds(pos):\n            return all(0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    px, py = pos\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def edge_in_obstacle(a, b, res=1.0):\n            dist = math.dist(a, b)\n            if dist < 1e-12:\n                return False\n            steps = max(3, int(dist / res))\n            for i in range(steps + 1):\n                interp = tuple(a[d] + (b[d] - a[d]) * i / steps for d in range(dim))\n                if in_obstacle(interp):\n                    return True\n            return False\n\n        def steer(from_p, to_p):\n            dist = math.dist(from_p, to_p)\n            if dist <= self.step_size:\n                return to_p\n            ratio = self.step_size / dist\n            return tuple(from_p[d] + (to_p[d] - from_p[d]) * ratio for d in range(dim))\n\n        def adaptive_radius(n, iter_i):\n            # Volume constant for unit ball in dim-dimensional space\n            from math import pi, gamma, log\n            gamma_dim = self.max_radius\n            unit_ball_vol = (pi ** (dim / 2)) / gamma(dim / 2 + 1) if dim > 1 else 2.0\n            if n < 2:\n                return self.max_radius\n            base_r = gamma_dim * ((log(n) / n) ** (1.0 / dim))\n            decay = max(self.min_radius / gamma_dim, 1.0 - 0.85 * (iter_i / self.max_iter))\n            return max(self.min_radius, min(base_r * decay, self.max_radius))\n\n        def neighbors(tree, pos, radius):\n            rsq = radius * radius\n            res = []\n            for node in tree:\n                dsq = 0.0\n                for d in range(dim):\n                    diff = node.position[d] - pos[d]\n                    dsq += diff * diff\n                    if dsq > rsq:\n                        break\n                else:\n                    res.append(node)\n            return res\n\n        def choose_parent(tree, pos, iter_i):\n            n = len(tree)\n            r = adaptive_radius(n, iter_i)\n            nbrs = neighbors(tree, pos, r)\n            if not nbrs:\n                # Fall back to nearest if no neighbors in radius\n                nearest = min(tree, key=lambda node: math.dist(node.position, pos))\n                if edge_in_obstacle(nearest.position, pos) or in_obstacle(pos):\n                    return None, []\n                cost_here = nearest.cost + math.dist(nearest.position, pos)\n                new_node = Node(pos, parent=nearest, cost=cost_here)\n                nearest.add_child(new_node)\n                tree.append(new_node)\n                return new_node, []\n            min_cost = float('inf')\n            best_parent = None\n            for nb in nbrs:\n                dist_nb = math.dist(nb.position, pos)\n                est_cost = nb.cost + dist_nb\n                if est_cost >= min_cost:\n                    continue\n                if edge_in_obstacle(nb.position, pos):\n                    continue\n                if est_cost < min_cost:\n                    min_cost = est_cost\n                    best_parent = nb\n            if best_parent is None:\n                # Safety fallback\n                nearest = min(tree, key=lambda node: math.dist(node.position, pos))\n                if edge_in_obstacle(nearest.position, pos) or in_obstacle(pos):\n                    return None, []\n                best_parent = nearest\n                min_cost = best_parent.cost + math.dist(best_parent.position, pos)\n            new_node = Node(pos, parent=best_parent, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree.append(new_node)\n            return new_node, nbrs\n\n        def rewire(pivot, nbrs):\n            for nb in nbrs:\n                if nb == pivot.parent:\n                    continue\n                new_cost = pivot.cost + math.dist(pivot.position, nb.position)\n                if new_cost + 1e-12 < nb.cost:\n                    if edge_in_obstacle(pivot.position, nb.position):\n                        continue\n                    # Remove from old parent's children to prevent references\n                    if nb.parent is not None:\n                        nb.parent.remove_child(nb)\n                    pivot.add_child(nb)\n                    nb.cost = new_cost\n\n        def direct_connect(tree, target_node):\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda n: math.dist(n.position, target_node.position))\n            dist = math.dist(nearest.position, target_node.position)\n            if dist <= self.step_size:\n                if edge_in_obstacle(nearest.position, target_node.position) or in_obstacle(target_node.position):\n                    return None\n                new_node = Node(target_node.position, parent=nearest, cost=nearest.cost + dist)\n                nearest.add_child(new_node)\n                tree.append(new_node)\n                return new_node\n            current = nearest\n            steps = int(math.ceil(dist / self.step_size))\n            for _ in range(steps):\n                new_pos = steer(current.position, target_node.position)\n                if not in_bounds(new_pos) or in_obstacle(new_pos) or edge_in_obstacle(current.position, new_pos):\n                    return None\n                new_node = Node(new_pos, parent=current, cost=current.cost + math.dist(current.position, new_pos))\n                current.add_child(new_node)\n                tree.append(new_node)\n                current = new_node\n                if math.dist(current.position, target_node.position) <= self.step_size:\n                    if edge_in_obstacle(current.position, target_node.position) or in_obstacle(target_node.position):\n                        return None\n                    final_node = Node(target_node.position, parent=current, cost=current.cost + math.dist(current.position, target_node.position))\n                    current.add_child(final_node)\n                    tree.append(final_node)\n                    return final_node\n            return None\n\n        def sample_uniform():\n            while True:\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not in_obstacle(p):\n                    return p\n\n        def sample_informed():\n            if not found_solution or best_cost == float('inf') or c_min < 1e-12:\n                return sample_uniform()\n            center = tuple((start_pos[d] + goal_pos[d]) * 0.5 for d in range(dim))\n            unit_dir = tuple((goal_pos[d] - start_pos[d]) / c_min for d in range(dim))\n            r1 = best_cost * 0.5\n            val = max(best_cost*best_cost - c_min*c_min, 0.0)\n            r_other = math.sqrt(val) * 0.5\n            if dim == 2:\n                a1 = unit_dir\n                a2 = (-a1[1], a1[0])\n                basis = (a1, a2)\n                radii = (r1, r_other)\n            else:\n                def cross(u, v):\n                    return (u[1]*v[2]-u[2]*v[1], u[2]*v[0]-u[0]*v[2], u[0]*v[1]-u[1]*v[0])\n                def norm(v):\n                    return math.sqrt(sum(x*x for x in v))\n                a1 = unit_dir\n                ref = (1,0,0) if abs(a1[0]) < 0.9 else (0,1,0)\n                b2 = cross(a1, ref)\n                n_b2 = norm(b2)\n                if n_b2 < 1e-12:\n                    ref = (0,0,1)\n                    b2 = cross(a1, ref)\n                    n_b2 = norm(b2)\n                b2 = tuple(x / n_b2 for x in b2)\n                b3 = cross(a1, b2)\n                basis = (a1, b2, b3)\n                radii = (r1, r_other, r_other)\n            def sample_unit_ball(dim):\n                while True:\n                    vec = [random.gauss(0,1) for _ in range(dim)]\n                    nrm = math.sqrt(sum(v*v for v in vec))\n                    if nrm < 1e-12:\n                        continue\n                    vec = [v/nrm for v in vec]\n                    r = random.random() ** (1/dim)\n                    return [v*r for v in vec]\n            u = sample_unit_ball(dim)\n            mapped = []\n            for d in range(dim):\n                val = center[d]\n                for i in range(dim):\n                    val += basis[i][d]*radii[i]*u[i]\n                # Clamp inside bounds exactly\n                mapped.append(min(max(val, 0.0), bounds[d]))\n            if not in_obstacle(tuple(mapped)):\n                return tuple(mapped)\n            return sample_uniform()\n\n        def bezier_cubic(p0, p1, p2, p3, t):\n            \"\"\"Compute cubic Bezier curve point at t [0..1].\"\"\"\n            u = 1 - t\n            tt = t * t\n            uu = u * u\n            uuu = uu * u\n            ttt = tt * t\n            x = uuu * p0[0] + 3 * uu * t * p1[0] + 3 * u * tt * p2[0] + ttt * p3[0]\n            y = uuu * p0[1] + 3 * uu * t * p1[1] + 3 * u * tt * p2[1] + ttt * p3[1]\n            if dim == 2:\n                return (x, y)\n            z = uuu * p0[2] + 3 * uu * t * p1[2] + 3 * u * tt * p2[2] + ttt * p3[2]\n            return (x, y, z)\n\n        def smooth_path_bezier(path):\n            if len(path) < 4:\n                return path[:]  # Too short to smooth reliably\n\n            # Create a new smoothed path with Bezier segments through triples of points\n            smoothed = [path[0]]\n            for i in range(1, len(path) - 2):\n                p0, p1, p2, p3 = path[i-1], path[i], path[i+1], path[i+2]\n\n                # Compute control points for smooth cubic bezier curve segment\n                def control_point(prev, curr, nxt, alpha=0.3):\n                    return tuple(curr[d] + alpha*(nxt[d]-prev[d]) for d in range(dim))\n\n                cp1 = control_point(p0, p1, p2)\n                cp2 = control_point(p1, p2, p3)\n                samples = max(3, int(math.dist(p1,p2)/self.step_size))  # samples per segment\n\n                for s in range(1, samples+1):\n                    t = s / samples\n                    pt = bezier_cubic(p1, cp1, cp2, p2, t)\n                    if not in_obstacle(pt) and not edge_in_obstacle(smoothed[-1], pt):\n                        smoothed.append(pt)\n                    else:\n                        # If collision, append p2 directly, break to next segment\n                        smoothed.append(p2)\n                        break\n            if smoothed[-1] != path[-1]:\n                smoothed.append(path[-1])\n            return smoothed\n\n        def shortcut_path(path):\n            # Random shortcuts to fix small holes or jumps left after smoothing\n            if len(path) < 3:\n                return path[:]\n            for _ in range(self.shortcut_iter):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path)-3)\n                j = random.randint(i+2, len(path)-1)\n                p1, p2 = path[i], path[j]\n                if not edge_in_obstacle(p1, p2):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        best_path = []\n        best_cost = float('inf')\n        c_min = math.dist(start_pos, goal_pos)\n        found_solution = False\n        no_improve_count = 0\n\n        start_time = time.time()\n\n        for it in range(self.max_iter):\n            if time.time() - start_time > self.time_limit:\n                break\n\n            tree_a, tree_b = (start_tree, goal_tree) if it % 2 == 0 else (goal_tree, start_tree)\n            x_rand = sample_informed()\n\n            if not in_bounds(x_rand) or in_obstacle(x_rand):\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n                continue\n\n            nearest = min(tree_a, key=lambda node: math.dist(node.position, x_rand))\n            new_pos = steer(nearest.position, x_rand)\n            if not in_bounds(new_pos) or in_obstacle(new_pos) or edge_in_obstacle(nearest.position, new_pos):\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n                continue\n\n            new_node, nbrs = choose_parent(tree_a, new_pos, it)\n            if new_node is None:\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n                continue\n\n            rewire(new_node, nbrs)\n            nodes.append(new_node)\n            if new_node.parent:\n                edges.append((new_node.parent, new_node))\n\n            meet_node = direct_connect(tree_b, new_node)\n            if meet_node is not None:\n                # Combine paths carefully avoiding duplication at connection node\n                if it % 2 == 0:\n                    path_a = new_node.path_from_root()\n                    path_b = meet_node.path_from_root()\n                else:\n                    path_a = meet_node.path_from_root()\n                    path_b = new_node.path_from_root()\n                if path_a and path_b and path_a[-1] == path_b[-1]:\n                    merged_path = path_a + path_b[-2::-1]\n                else:\n                    merged_path = path_a + path_b[::-1]\n\n                # Compute total cost along merged path\n                total_cost = 0.0\n                for i in range(len(merged_path) - 1):\n                    total_cost += math.dist(merged_path[i], merged_path[i + 1])\n\n                if total_cost + 1e-9 < best_cost:\n                    best_cost = total_cost\n                    best_path = merged_path\n                    found_solution = True\n                    no_improve_count = 0\n                else:\n                    if found_solution:\n                        no_improve_count += 1\n                        if no_improve_count >= self.max_no_improve:\n                            break\n            else:\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n\n        if found_solution and len(best_path) >= 4:\n            # Apply spline smoothing to improve curvature and smoothness\n            best_path = smooth_path_bezier(best_path)\n            # Additional shortcut passes to refine path\n            best_path = shortcut_path(best_path)\n\n        return PlannerResult(success=found_solution, path=best_path, nodes=nodes, edges=edges)",
          "objective": -33.48325,
          "time_improvement": 52.0,
          "length_improvement": 18.0,
          "smoothness_improvement": 1448.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.02188541889190674,
                    "num_nodes_avg": 126.1,
                    "path_length_avg": 159.10679264997313,
                    "smoothness_avg": 0.040380418046515855,
                    "success_improvement": 0.0,
                    "time_improvement": 9.88253542835544,
                    "length_improvement": 12.79104574008065,
                    "smoothness_improvement": 532.0412299092479,
                    "objective_score": 13.299594222101263
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.023896503448486327,
                    "num_nodes_avg": 225.2,
                    "path_length_avg": 231.08930648993655,
                    "smoothness_avg": 0.09728385757415844,
                    "success_improvement": 0.0,
                    "time_improvement": 85.20022018964188,
                    "length_improvement": 22.85573795677634,
                    "smoothness_improvement": 2403.183726113427,
                    "objective_score": 51.2894274615255
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.01906890869140625,
                    "num_nodes_avg": 199.7,
                    "path_length_avg": 124.55936634727755,
                    "smoothness_avg": 0.1186902882292356,
                    "success_improvement": 0.0,
                    "time_improvement": 61.493079126645966,
                    "length_improvement": 17.273599751781756,
                    "smoothness_improvement": 1409.7317054701086,
                    "objective_score": 35.86074211641339
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "A simplified bidirectional RRT* planner using uniform and ellipsoidal informed sampling with efficient neighbor lookups, adaptive rewiring radius, incremental rewiring, and post-planning shortcut smoothing to improve path quality, smoothness, and planning speed while maintaining robustness. It alternates tree expansion from start and goal, performs parent selection to minimize cost with strict collision checks, tries direct and incremental tree connection after each insertion, and applies a random shortcutting heuristic for path smoothing.",
          "planning_mechanism": "The planner grows two trees from start and goal, sampling points biased towards an ellipsoidal informed subset once a solution is found, steering towards samples to add nodes, selecting parents among neighbors minimizing path cost, rewiring neighbors to improve connectivity and cost, connecting the two trees incrementally after each node addition, and applying shortcut smoothing post planning for improved path smoothness and length.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self,\n                 max_iter=4000,\n                 step_size=5.0,\n                 max_radius=20.0,\n                 min_radius=5.0,\n                 max_no_improve=60,\n                 shortcut_iter=100):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.max_radius = max_radius\n        self.min_radius = min_radius\n        self.max_no_improve = max_no_improve\n        self.shortcut_iter = shortcut_iter\n\n    def plan(self, map):\n        import math\n        import random\n        import time\n\n        bounds = map.size\n        dim = len(bounds)\n        start_pos = tuple(map.start)\n        goal_pos = tuple(map.goal)\n        obstacles = map.obstacles\n        is_3d = (dim == 3)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def in_obstacle(p):\n            px, py, pz = (p + (0, 0, 0))[:3]\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def edge_in_obstacle(a, b, res=1.0):\n            dist_ab = math.dist(a, b)\n            if dist_ab < 1e-12:\n                return False\n            steps = max(2, int(dist_ab / res))\n            for i in range(steps + 1):\n                interp = tuple(a[d] + (b[d] - a[d]) * i / steps for d in range(dim))\n                if in_obstacle(interp):\n                    return True\n            return False\n\n        def steer(frm, to):\n            dist_frm_to = math.dist(frm, to)\n            if dist_frm_to <= self.step_size:\n                return to\n            ratio = self.step_size / dist_frm_to\n            return tuple(frm[d] + (to[d] - frm[d]) * ratio for d in range(dim))\n\n        def adaptive_radius(n_nodes, iter_i):\n            if n_nodes <= 1:\n                return self.max_radius\n            gamma = self.max_radius\n            import math as m\n            r = gamma * (m.log(n_nodes) / n_nodes) ** (1 / dim)\n            decay = max(self.min_radius / gamma, 1.0 - 0.9 * (iter_i / self.max_iter))\n            return max(self.min_radius, min(r * decay, self.max_radius))\n\n        def neighbors(tree, point, radius):\n            r_sq = radius * radius\n            res = []\n            for node in tree:\n                d_sq = 0.0\n                for i in range(dim):\n                    diff = node.position[i] - point[i]\n                    d_sq += diff * diff\n                    if d_sq > r_sq:\n                        break\n                else:\n                    res.append(node)\n            return res\n\n        def choose_parent(tree, new_pos, iter_i):\n            n_nodes = len(tree)\n            r = adaptive_radius(n_nodes, iter_i)\n            nbrs = neighbors(tree, new_pos, r)\n            valid_parents = [n for n in nbrs if not edge_in_obstacle(n.position, new_pos)]\n            if not valid_parents:\n                nearest = None\n                nearest_dist = float('inf')\n                for n in tree:\n                    d = math.dist(n.position, new_pos)\n                    if d < nearest_dist and not edge_in_obstacle(n.position, new_pos):\n                        nearest = n\n                        nearest_dist = d\n                if nearest is None:\n                    return None, []\n                cost = nearest.cost + nearest_dist\n                new_node = Node(new_pos, parent=nearest, cost=cost)\n                nearest.add_child(new_node)\n                tree.append(new_node)\n                return new_node, []\n            best_parent = min(valid_parents, key=lambda p: p.cost + math.dist(p.position, new_pos))\n            min_cost = best_parent.cost + math.dist(best_parent.position, new_pos)\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree.append(new_node)\n            return new_node, valid_parents\n\n        def rewire(pivot, nbrs):\n            for nb in nbrs:\n                if nb is pivot.parent:\n                    continue\n                dist_pivot_nb = math.dist(pivot.position, nb.position)\n                new_cost = pivot.cost + dist_pivot_nb\n                if new_cost + 1e-12 < nb.cost and not edge_in_obstacle(pivot.position, nb.position):\n                    if nb.parent is not None:\n                        nb.parent.remove_child(nb)\n                    pivot.add_child(nb)\n                    nb.cost = new_cost\n\n        def attempt_connect(tree_from, node_to_connect):\n            if not tree_from:\n                return None\n            nearest = min(tree_from, key=lambda n: math.dist(n.position, node_to_connect.position))\n            dist_near = math.dist(nearest.position, node_to_connect.position)\n            if dist_near <= self.step_size:\n                if edge_in_obstacle(nearest.position, node_to_connect.position) or in_obstacle(node_to_connect.position):\n                    return None\n                new_node = Node(node_to_connect.position, parent=nearest, cost=nearest.cost + dist_near)\n                nearest.add_child(new_node)\n                tree_from.append(new_node)\n                return new_node\n            current = nearest\n            steps = int(math.ceil(dist_near / self.step_size))\n            for _ in range(steps):\n                new_pos = steer(current.position, node_to_connect.position)\n                if not in_bounds(new_pos) or in_obstacle(new_pos) or edge_in_obstacle(current.position, new_pos):\n                    return None\n                new_node = Node(new_pos, parent=current, cost=current.cost + math.dist(current.position, new_pos))\n                current.add_child(new_node)\n                tree_from.append(new_node)\n                current = new_node\n                if math.dist(current.position, node_to_connect.position) <= self.step_size:\n                    if edge_in_obstacle(current.position, node_to_connect.position) or in_obstacle(node_to_connect.position):\n                        return None\n                    final_node = Node(node_to_connect.position, parent=current,\n                                      cost=current.cost + math.dist(current.position, node_to_connect.position))\n                    current.add_child(final_node)\n                    tree_from.append(final_node)\n                    return final_node\n            return None\n\n        def sample_uniform():\n            return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        def sample_informed(c_best, c_min):\n            if c_best == float('inf') or c_min < 1e-12:\n                return sample_uniform()\n            center = tuple((start_pos[d] + goal_pos[d]) / 2 for d in range(dim))\n            unit_dir = []\n            for d in range(dim):\n                unit_dir.append((goal_pos[d] - start_pos[d]) / c_min)\n            r1 = c_best * 0.5\n            val = max(c_best * c_best - c_min * c_min, 0.0)\n            r_other = math.sqrt(val) * 0.5\n\n            if dim == 2:\n                a1 = unit_dir\n                a2 = (-a1[1], a1[0])\n                basis = (a1, a2)\n                radii = (r1, r_other)\n            else:\n                def cross(u, v):\n                    return (u[1] * v[2] - u[2] * v[1], u[2] * v[0] - u[0] * v[2], u[0] * v[1] - u[1] * v[0])\n                def norm(v):\n                    return math.sqrt(sum(x * x for x in v))\n                a1 = unit_dir\n                ref = (1, 0, 0) if abs(a1[0]) < 0.9 else (0, 1, 0)\n                b2 = cross(a1, ref)\n                n_b2 = norm(b2)\n                if n_b2 < 1e-12:\n                    ref = (0, 0, 1)\n                    b2 = cross(a1, ref)\n                    n_b2 = norm(b2)\n                b2 = tuple(x / n_b2 for x in b2)\n                b3 = cross(a1, b2)\n                basis = (a1, b2, b3)\n                radii = (r1, r_other, r_other)\n            def sample_unit_ball(dim):\n                while True:\n                    vec = [random.gauss(0, 1) for _ in range(dim)]\n                    nrm = math.sqrt(sum(v * v for v in vec))\n                    if nrm < 1e-12:\n                        continue\n                    vec = [v / nrm for v in vec]\n                    r = random.random() ** (1 / dim)\n                    return [v * r for v in vec]\n            u = sample_unit_ball(dim)\n            mapped = []\n            for d in range(dim):\n                val = center[d]\n                for i in range(dim):\n                    val += basis[i][d] * radii[i] * u[i]\n                mapped.append(max(0.0, min(val, bounds[d])))\n            return tuple(mapped)\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path[:]\n            path = list(path)\n            for _ in range(self.shortcut_iter):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if not edge_in_obstacle(path[i], path[j]):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        best_path = []\n        best_cost = float('inf')\n        c_min = math.dist(start_pos, goal_pos)\n        found_solution = False\n        no_improve_count = 0\n\n        start_time = time.time()\n\n        for iter_i in range(self.max_iter):\n            if found_solution:\n                sample = sample_informed(best_cost, c_min)\n                # occasional uniform sampling to avoid local minima\n                if random.random() < 0.15:\n                    sample = sample_uniform()\n            else:\n                sample = sample_uniform()\n\n            if not in_bounds(sample) or in_obstacle(sample):\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n                continue\n\n            tree_a, tree_b = (start_tree, goal_tree) if iter_i % 2 == 0 else (goal_tree, start_tree)\n\n            nearest_node = min(tree_a, key=lambda n: math.dist(n.position, sample))\n            new_pos = steer(nearest_node.position, sample)\n            if not in_bounds(new_pos) or in_obstacle(new_pos) or edge_in_obstacle(nearest_node.position, new_pos):\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n                continue\n\n            new_node, nbrs = choose_parent(tree_a, new_pos, iter_i)\n            if new_node is None:\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n                continue\n\n            rewire(new_node, nbrs)\n            nodes.append(new_node)\n            if new_node.parent:\n                edges.append((new_node.parent, new_node))\n\n            connect_node = attempt_connect(tree_b, new_node)\n            if connect_node is not None:\n                if iter_i % 2 == 0:\n                    path_a = new_node.path_from_root()\n                    path_b = connect_node.path_from_root()\n                else:\n                    path_a = connect_node.path_from_root()\n                    path_b = new_node.path_from_root()\n\n                if path_a and path_b and path_a[-1] == path_b[-1]:\n                    candidate_path = path_a + path_b[-2::-1]\n                else:\n                    candidate_path = path_a + path_b[::-1]\n\n                total_cost = 0.0\n                for i in range(len(candidate_path) - 1):\n                    total_cost += math.dist(candidate_path[i], candidate_path[i + 1])\n\n                if total_cost + 1e-9 < best_cost:\n                    best_cost = total_cost\n                    best_path = candidate_path\n                    found_solution = True\n                    no_improve_count = 0\n                else:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n            else:\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n\n        if found_solution and len(best_path) >= 3:\n            best_path = shortcut_path(best_path)\n\n        return PlannerResult(success=found_solution, path=best_path, nodes=nodes, edges=edges)",
          "objective": -33.40298,
          "time_improvement": 51.0,
          "length_improvement": 17.0,
          "smoothness_improvement": 1547.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.017258715629577637,
                    "num_nodes_avg": 79.5,
                    "path_length_avg": 159.14625161467853,
                    "smoothness_avg": 0.03811017652697283,
                    "success_improvement": 0.0,
                    "time_improvement": 28.9338850683042,
                    "length_improvement": 12.76941765625831,
                    "smoothness_improvement": 496.5070202200339,
                    "objective_score": 18.824351215346415
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.050636911392211915,
                    "num_nodes_avg": 257.4,
                    "path_length_avg": 238.0863832383473,
                    "smoothness_avg": 0.10822479582896447,
                    "success_improvement": 0.0,
                    "time_improvement": 68.63912996740864,
                    "length_improvement": 20.51991233846954,
                    "smoothness_improvement": 2684.7019478488814,
                    "objective_score": 46.32719613254872
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.022013473510742187,
                    "num_nodes_avg": 162.2,
                    "path_length_avg": 122.72467070826906,
                    "smoothness_avg": 0.12261112972748914,
                    "success_improvement": 0.0,
                    "time_improvement": 55.54695361209407,
                    "length_improvement": 18.492117236393174,
                    "smoothness_improvement": 1459.6045199214789,
                    "objective_score": 35.05737902507152
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "An improved bidirectional RRT* variant with simplified adaptive neighborhood radius, consistent incremental rewiring, and combined informed plus uniform sampling for balanced exploration. The planner applies strict collision checks on nodes and edges, optimizes parent selection to minimize path cost, and attempts connection between trees after each insertion. It leverages a unified rewiring radius calculation based on node density and iteration progress, integrates early stopping on improvement stagnation, and performs lightweight post-processing shortcutting to improve path quality and smoothness, achieving efficient planning, shorter path length, and smoother results while maintaining robustness and simplicity.",
          "planning_mechanism": "The planner grows two trees from start and goal positions in alternating iterations, sampling points biased towards an ellipsoidal informed subset once a solution is found to focus search. Nodes are added by steering towards samples within step size, selecting parents from neighbors that reduce path cost and maintain collision-free edges. Rewiring is done on neighbors with a unified adaptive radius that shrinks according to node count and iteration to refine local connectivity. After each added node, the planner attempts to connect the two trees to find feasible paths that are combined to update the best solution. Early stopping terminates planning after a number of iterations without improvement. A final random shortcutting pass reduces unnecessary detours for improved smoothness.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self,\n                 max_iter=4000,\n                 step_size=5.0,\n                 max_radius=25.0,\n                 min_radius=5.0,\n                 max_no_improve=60,\n                 shortcut_iter=120):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.max_radius = max_radius\n        self.min_radius = min_radius\n        self.max_no_improve = max_no_improve\n        self.shortcut_iter = shortcut_iter\n\n    def plan(self, map):\n        import math\n        import random\n        import time\n\n        bounds = map.size\n        dim = len(bounds)\n        start_pos = tuple(map.start)\n        goal_pos = tuple(map.goal)\n        obstacles = map.obstacles\n        is_3d = (dim == 3)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def in_obstacle(p):\n            px, py, pz = (p + (0, 0, 0))[:3]\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def edge_in_obstacle(a, b, res=1.0):\n            dist_ab = math.dist(a, b)\n            if dist_ab < 1e-12:\n                return False\n            steps = max(2, int(dist_ab / res))\n            for i in range(steps + 1):\n                interp = tuple(a[d] + (b[d] - a[d]) * i / steps for d in range(dim))\n                if in_obstacle(interp):\n                    return True\n            return False\n\n        def steer(frm, to):\n            dist_frm_to = math.dist(frm, to)\n            if dist_frm_to <= self.step_size:\n                return to\n            ratio = self.step_size / dist_frm_to\n            return tuple(frm[d] + (to[d] - frm[d]) * ratio for d in range(dim))\n\n        def adaptive_radius(node_count, iteration):\n            # Unified radius shrinking with node count and iteration progress\n            if node_count <= 1:\n                return self.max_radius\n            import math\n            gamma = self.max_radius\n            r = gamma * (math.log(node_count) / node_count) ** (1 / dim)\n            decay = max(self.min_radius / gamma, 1.0 - 0.95 * (iteration / self.max_iter))\n            return max(self.min_radius, min(r * decay, self.max_radius))\n\n        def neighbors(tree, point, radius):\n            radius_sq = radius * radius\n            res = []\n            px = point\n            for node in tree:\n                d_sq = 0.0\n                for i_ in range(dim):\n                    diff = node.position[i_] - px[i_]\n                    d_sq += diff * diff\n                    if d_sq > radius_sq:\n                        break\n                else:\n                    res.append(node)\n            return res\n\n        def choose_parent(tree, new_pos, iter_i):\n            n_nodes = len(tree)\n            r = adaptive_radius(n_nodes, iter_i)\n            nbrs = neighbors(tree, new_pos, r)\n            # filter valid parents with collision-free edge\n            valid_parents = []\n            for n in nbrs:\n                if edge_in_obstacle(n.position, new_pos):\n                    continue\n                valid_parents.append(n)\n            if not valid_parents:\n                # fallback: find nearest node with collision-free edge\n                nearest = None\n                nearest_dist = float('inf')\n                for n in tree:\n                    d = math.dist(n.position, new_pos)\n                    if d < nearest_dist and not edge_in_obstacle(n.position, new_pos):\n                        nearest = n\n                        nearest_dist = d\n                if nearest is None:\n                    return None, []\n                best_parent = nearest\n                cost = best_parent.cost + nearest_dist\n                new_node = Node(new_pos, parent=best_parent, cost=cost)\n                best_parent.add_child(new_node)\n                tree.append(new_node)\n                return new_node, []\n            # select parent minimizing cost\n            best_parent = None\n            min_cost = float('inf')\n            for p in valid_parents:\n                c = p.cost + math.dist(p.position, new_pos)\n                if c < min_cost:\n                    min_cost = c\n                    best_parent = p\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree.append(new_node)\n            return new_node, valid_parents\n\n        def rewire(pivot, nbrs):\n            for nb in nbrs:\n                if nb == pivot.parent:\n                    continue\n                dist_pivot_nb = math.dist(pivot.position, nb.position)\n                new_cost = pivot.cost + dist_pivot_nb\n                if new_cost + 1e-12 < nb.cost:\n                    if edge_in_obstacle(pivot.position, nb.position):\n                        continue\n                    # Rewire parent-child\n                    if nb.parent is not None:\n                        nb.parent.remove_child(nb)\n                    pivot.add_child(nb)\n                    nb.cost = new_cost\n\n        def attempt_connect(tree_from, node_to_connect):\n            if not tree_from:\n                return None\n            nearest = min(tree_from, key=lambda n: math.dist(n.position, node_to_connect.position))\n            dist_near = math.dist(nearest.position, node_to_connect.position)\n            if dist_near <= self.step_size:\n                if edge_in_obstacle(nearest.position, node_to_connect.position) or in_obstacle(node_to_connect.position):\n                    return None\n                new_node = Node(node_to_connect.position, parent=nearest, cost=nearest.cost + dist_near)\n                nearest.add_child(new_node)\n                tree_from.append(new_node)\n                return new_node\n            # incremental steering towards target\n            current = nearest\n            steps = int(math.ceil(dist_near / self.step_size))\n            for _ in range(steps):\n                new_pos = steer(current.position, node_to_connect.position)\n                if not in_bounds(new_pos) or in_obstacle(new_pos) or edge_in_obstacle(current.position, new_pos):\n                    return None\n                new_node = Node(new_pos, parent=current, cost=current.cost + math.dist(current.position, new_pos))\n                current.add_child(new_node)\n                tree_from.append(new_node)\n                current = new_node\n                if math.dist(current.position, node_to_connect.position) <= self.step_size:\n                    if edge_in_obstacle(current.position, node_to_connect.position) or in_obstacle(node_to_connect.position):\n                        return None\n                    final_node = Node(node_to_connect.position, parent=current,\n                                      cost=current.cost + math.dist(current.position, node_to_connect.position))\n                    current.add_child(final_node)\n                    tree_from.append(final_node)\n                    return final_node\n            return None\n\n        def sample_uniform():\n            return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        def sample_informed(c_best, c_min):\n            if c_best == float('inf') or c_min < 1e-12:\n                return sample_uniform()\n            center = tuple((start_pos[d] + goal_pos[d]) / 2 for d in range(dim))\n            unit_dir = []\n            for d in range(dim):\n                unit_dir.append((goal_pos[d] - start_pos[d]) / c_min)\n            r1 = c_best * 0.5\n            val = max(c_best * c_best - c_min * c_min, 0.0)\n            r_other = math.sqrt(val) * 0.5\n\n            if dim == 2:\n                a1 = unit_dir\n                a2 = (-a1[1], a1[0])\n                basis = (a1, a2)\n                radii = (r1, r_other)\n            else:\n                def cross(u, v):\n                    return (u[1] * v[2] - u[2] * v[1], u[2] * v[0] - u[0] * v[2], u[0] * v[1] - u[1] * v[0])\n\n                def norm(v):\n                    return math.sqrt(sum(x * x for x in v))\n\n                a1 = unit_dir\n                ref = (1, 0, 0) if abs(a1[0]) < 0.9 else (0, 1, 0)\n                b2 = cross(a1, ref)\n                n_b2 = norm(b2)\n                if n_b2 < 1e-12:\n                    ref = (0, 0, 1)\n                    b2 = cross(a1, ref)\n                    n_b2 = norm(b2)\n                b2 = tuple(x / n_b2 for x in b2)\n                b3 = cross(a1, b2)\n                basis = (a1, b2, b3)\n                radii = (r1, r_other, r_other)\n\n            def sample_unit_ball(dim):\n                while True:\n                    vec = [random.gauss(0, 1) for _ in range(dim)]\n                    nrm = math.sqrt(sum(v * v for v in vec))\n                    if nrm < 1e-12:\n                        continue\n                    vec = [v / nrm for v in vec]\n                    r = random.random() ** (1 / dim)\n                    return [v * r for v in vec]\n\n            u = sample_unit_ball(dim)\n            mapped = []\n            for d in range(dim):\n                val = center[d]\n                for i in range(dim):\n                    val += basis[i][d] * radii[i] * u[i]\n                val = max(0.0, min(val, bounds[d]))\n                mapped.append(val)\n            return tuple(mapped)\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path[:]\n            path = list(path)\n            for _ in range(self.shortcut_iter):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if not edge_in_obstacle(path[i], path[j]):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        best_path = []\n        best_cost = float('inf')\n        c_min = math.dist(start_pos, goal_pos)\n        found_solution = False\n        no_improve_count = 0\n\n        start_time = time.time()\n\n        for iter_i in range(self.max_iter):\n            if found_solution:\n                sample = sample_informed(best_cost, c_min)\n                # Occasionally sample uniform to avoid local minima\n                if random.random() < 0.15:\n                    sample = sample_uniform()\n            else:\n                sample = sample_uniform()\n\n            if not in_bounds(sample) or in_obstacle(sample):\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n                continue\n\n            tree_a, tree_b = (start_tree, goal_tree) if iter_i % 2 == 0 else (goal_tree, start_tree)\n\n            nearest_n = min(tree_a, key=lambda n: math.dist(n.position, sample))\n            new_pos = steer(nearest_n.position, sample)\n            if not in_bounds(new_pos) or in_obstacle(new_pos) or edge_in_obstacle(nearest_n.position, new_pos):\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n                continue\n\n            new_node, nbrs = choose_parent(tree_a, new_pos, iter_i)\n            if new_node is None:\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n                continue\n\n            rewire(new_node, nbrs)\n            nodes.append(new_node)\n            if new_node.parent:\n                edges.append((new_node.parent, new_node))\n\n            connect_node = attempt_connect(tree_b, new_node)\n            if connect_node is not None:\n                if iter_i % 2 == 0:\n                    path_a = new_node.path_from_root()\n                    path_b = connect_node.path_from_root()\n                else:\n                    path_a = connect_node.path_from_root()\n                    path_b = new_node.path_from_root()\n                if path_a and path_b and path_a[-1] == path_b[-1]:\n                    candidate_path = path_a + path_b[-2::-1]\n                else:\n                    candidate_path = path_a + path_b[::-1]\n\n                total_cost = 0.0\n                for i in range(len(candidate_path) - 1):\n                    total_cost += math.dist(candidate_path[i], candidate_path[i + 1])\n\n                if total_cost + 1e-9 < best_cost:\n                    best_cost = total_cost\n                    best_path = candidate_path\n                    found_solution = True\n                    no_improve_count = 0\n                else:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n            else:\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n\n        if found_solution and len(best_path) >= 3:\n            best_path = shortcut_path(best_path)\n\n        return PlannerResult(success=found_solution, path=best_path, nodes=nodes, edges=edges)",
          "objective": -32.09066,
          "time_improvement": 51.0,
          "length_improvement": 17.0,
          "smoothness_improvement": 1354.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.017293906211853026,
                    "num_nodes_avg": 91.5,
                    "path_length_avg": 161.730924310866,
                    "smoothness_avg": 0.042930783900201136,
                    "success_improvement": 0.0,
                    "time_improvement": 28.788981008339842,
                    "length_improvement": 11.352717594718152,
                    "smoothness_improvement": 571.9599937275159,
                    "objective_score": 18.308124827970424
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.03642895221710205,
                    "num_nodes_avg": 225.4,
                    "path_length_avg": 238.2939143004422,
                    "smoothness_avg": 0.0897730230727014,
                    "success_improvement": 0.0,
                    "time_improvement": 77.4385205476863,
                    "length_improvement": 20.450632496491846,
                    "smoothness_improvement": 2209.924544555513,
                    "objective_score": 46.551558384978556
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.02602849006652832,
                    "num_nodes_avg": 208.0,
                    "path_length_avg": 123.50286586657371,
                    "smoothness_avg": 0.10841836272819716,
                    "success_improvement": 0.0,
                    "time_improvement": 47.439204641197854,
                    "length_improvement": 17.97527706591856,
                    "smoothness_improvement": 1279.073571291572,
                    "objective_score": 31.41229548836835
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "time_expert",
          "algorithm_description": "A bidirectional RRT* planner with adaptive multi-radius rewiring emphasizing cost-based connections for shorter paths, enhanced sampling bias combining ellipsoidal informed and goal-directed Gaussian samples for faster convergence. It employs efficient approximate nearest neighbor search, dynamic step size control to refine exploration precision, and accelerated early stopping criteria to reduce planning time. Path smoothness is indirectly improved by prioritizing cost-optimal parent selection without explicit curvature penalties, enabling more flexible rewiring and shorter, smoother paths.",
          "planning_mechanism": "A bidirectional RRT* grows two trees alternating expansions from start and goal. Sampling blends ellipsoidal informed and goal-biased Gaussian perturbations to prioritize promising regions. Nearest neighbor and near-node queries use approximate but efficient search. Adaptive multi-radius rewiring updates parent-child relations based solely on cost, allowing more aggressive shortcuts and path shortening. A dynamic step size decreases as nodes increase, refining path precision. Early stopping triggers upon stagnated cost improvements. After a solution is found, shortcutting with collision checks refines the path length and smoothness, balancing planning time and path quality.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position  # tuple of floats\n        self.parent = parent      # Node or None\n        self.cost = cost          # cost from root\n        self.children = []       # list of Node\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def path_from_root(self):\n        node = self\n        path = []\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=2500, max_no_improve=40, improve_tol=1e-6,\n                 init_step=7.0, min_step=0.8, n_near_const=15, shortcut_iters=150):\n        self.max_iter = max_iter\n        self.max_no_improve = max_no_improve\n        self.improve_tol = improve_tol\n        self.init_step = init_step\n        self.min_step = min_step\n        self.n_near_const = n_near_const\n        self.shortcut_iters = shortcut_iters\n\n    def plan(self, map) -> 'PlannerResult':\n        import time, random, math\n\n        start_p = tuple(map.start)\n        goal_p = tuple(map.goal)\n        bounds = tuple(map.size)\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def dist(a, b):\n            s = 0.0\n            for i in range(dim):\n                d = a[i] - b[i]\n                s += d * d\n            return math.sqrt(s)\n\n        def in_obstacle(p):\n            px, py, pz = (p + (0, 0, 0))[:3]\n            for obs in obstacles:\n                if is_3d:\n                    ox, oy, oz, ow, oh, od = obs\n                    if ox <= px <= ox + ow and oy <= py <= oy + oh and oz <= pz <= oz + od:\n                        return True\n                else:\n                    ox, oy, ow, oh = obs\n                    if ox <= px <= ox + ow and oy <= py <= oy + oh:\n                        return True\n            return False\n\n        def edge_obstacle(f, t, resolution=1.0):\n            length = dist(f, t)\n            if length < 1e-12:\n                return False\n            steps = max(5, int(length / resolution))\n            for i in range(steps + 1):\n                inter = tuple(f[d] + (t[d] - f[d]) * i / steps for d in range(dim))\n                if in_obstacle(inter):\n                    return True\n            return False\n\n        def steer(frm, to, step_size):\n            d = dist(frm, to)\n            if d <= step_size:\n                return to\n            ratio = step_size / d\n            return tuple(frm[i] + (to[i] - frm[i]) * ratio for i in range(dim))\n\n        # Approximate nearest neighbor: linear with early reject for efficiency\n        def nearest(tree, point):\n            best = None\n            best_d2 = float('inf')\n            px = point\n            for n in tree:\n                d2 = 0.0\n                for i_ in range(dim):\n                    delta = n.position[i_] - px[i_]\n                    d2 += delta * delta\n                    if d2 >= best_d2:\n                        break\n                else:\n                    if d2 < best_d2:\n                        best = n\n                        best_d2 = d2\n            return best, math.sqrt(best_d2) if best is not None else None\n\n        def near_nodes(tree, point, radius):\n            rq = radius * radius\n            px = point\n            near_list = []\n            for n in tree:\n                d2 = 0.0\n                for i_ in range(dim):\n                    delta = n.position[i_] - px[i_]\n                    d2 += delta * delta\n                    if d2 > rq:\n                        break\n                if d2 <= rq:\n                    near_list.append(n)\n            return near_list\n\n        def adaptive_radius(n_nodes, c_best):\n            if n_nodes <= 1:\n                return self.init_step * 3.3\n            base = (self.n_near_const * (math.log(n_nodes) / n_nodes)) ** (1 / dim)\n            base = min(base, self.init_step * 5.8)\n            if c_best == float('inf'):\n                return base\n            shrink_factor = max(0.3, c_best / (c_min * 3.2))\n            return max(self.min_step * 0.8, base * shrink_factor)\n\n        # Sampling biased by ellipsoid informed + gaussian near goal for faster convergence\n        def sample(c_best):\n            if c_best == float('inf'):\n                # random uniform in bounds\n                return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n            # Informed ellipsoid sampling\n            center = tuple(0.5 * (start_p[i] + goal_p[i]) for i in range(dim))\n            diff = [goal_p[i] - start_p[i] for i in range(dim)]\n            dist_sg = dist(start_p, goal_p)\n            if dist_sg < 1e-14:\n                return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n            unit_vec = [d / dist_sg for d in diff]\n            # Build orthonormal basis (Gram-Schmidt)\n            U = [unit_vec]\n            for idx in range(dim - 1):\n                v = [0.0] * dim\n                v[(idx + 1) % dim] = 1.0\n                for u in U:\n                    proj = sum(v[j] * u[j] for j in range(dim))\n                    for j in range(dim):\n                        v[j] -= proj * u[j]\n                norm_v = math.sqrt(sum(x * x for x in v))\n                if norm_v > 1e-14:\n                    U.append([x / norm_v for x in v])\n                else:\n                    U.append([0.0] * dim)\n            r1 = c_best * 0.5\n            val = c_best * c_best - c_min * c_min\n            r2 = math.sqrt(val) * 0.5 if val > 0 else 0.0\n            radii = [r1] + [r2] * (dim - 1)\n\n            for _ in range(50):\n                # Random point inside unit ball\n                x_ball = [random.gauss(0, 1) for _ in range(dim)]\n                norm_x = math.sqrt(sum(x * x for x in x_ball))\n                if norm_x < 1e-14:\n                    continue\n                x_unit = [x / norm_x for x in x_ball]\n                r = random.random() ** (1 / dim)\n                point_ball = [r * x_unit[i] for i in range(dim)]\n                point_ellipsoid = [radii[i] * point_ball[i] for i in range(dim)]\n                sample_point = [center[j] for j in range(dim)]\n                for i_ in range(dim):\n                    for j_ in range(dim):\n                        sample_point[j_] += U[i_][j_] * point_ellipsoid[i_]\n                candidate = tuple(sample_point)\n                if all(0.0 <= candidate[i] <= bounds[i] for i in range(dim)) and not in_obstacle(candidate):\n                    # 20% chance to bias samples near goal using gaussian for faster connection\n                    if random.random() < 0.2:\n                        gauss_sample = []\n                        for d_i, bound_i in enumerate(bounds):\n                            gs = random.gauss(goal_p[d_i], min(bound_i * 0.05, 1.0))\n                            gauss_sample.append(min(max(0.0, gs), bound_i))\n                        gs_tuple = tuple(gauss_sample)\n                        if not in_obstacle(gs_tuple):\n                            return gs_tuple\n                    return candidate\n            # fallback uniform random\n            return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n\n        def get_path(node):\n            return node.path_from_root()\n\n        def connect_path(n1, n2):\n            p1 = get_path(n1)\n            p2 = get_path(n2)[::-1]\n            if p1 and p2 and p1[-1] == p2[0]:\n                return p1 + p2[1:]\n            return p1 + p2\n\n        # Add node with cost-only rewiring (no curvature penalty) to favor shorter paths\n        def add_node(tree, new_sample, all_nodes, edges, c_best, step_size):\n            nn, d_nn = nearest(tree, new_sample)\n            if nn is None:\n                return None\n            new_pos = steer(nn.position, new_sample, step_size)\n            if in_obstacle(new_pos) or edge_obstacle(nn.position, new_pos):\n                return None\n\n            n_nodes = len(all_nodes)\n            radius = adaptive_radius(n_nodes, c_best)\n            near = near_nodes(tree, new_pos, radius)\n\n            best_parent = nn\n            best_cost = nn.cost + dist(nn.position, new_pos)\n\n            for cand in near:\n                if cand == nn:\n                    continue\n                if edge_obstacle(cand.position, new_pos):\n                    continue\n                cost_candidate = cand.cost + dist(cand.position, new_pos)\n                if cost_candidate + self.improve_tol < best_cost:\n                    best_cost = cost_candidate\n                    best_parent = cand\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = best_cost\n            tree.append(new_node)\n            all_nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors if cost improves\n            near_r = near_nodes(tree, new_node.position, radius)\n            for near_n in near_r:\n                if near_n == best_parent or near_n == new_node:\n                    continue\n                if edge_obstacle(new_node.position, near_n.position):\n                    continue\n                alt_cost = new_node.cost + dist(new_node.position, near_n.position)\n                if alt_cost + self.improve_tol < near_n.cost:\n                    # Rewire\n                    if near_n.parent:\n                        near_n.parent.remove_child(near_n)\n                        try:\n                            edges.remove((near_n.parent, near_n))\n                        except Exception:\n                            pass\n                    new_node.add_child(near_n)\n                    near_n.cost = alt_cost\n                    edges.append((new_node, near_n))\n            return new_node\n\n        # Shortcutting without explicit curvature penalty but verify collision\n        def shortcut_path(path):\n            path = list(path)\n            if len(path) < 3:\n                return path\n            changed = True\n            iter_count = 0\n            while changed and iter_count < self.shortcut_iters:\n                iter_count += 1\n                changed = False\n                i = 0\n                while i < len(path) - 2:\n                    max_j = min(len(path) - 1, i + 6)\n                    if max_j <= i + 1:\n                        i += 1\n                        continue\n                    j = random.randint(i + 2, max_j)\n                    if not edge_obstacle(path[i], path[j]):\n                        # shortcut allowed\n                        del path[i + 1:j]\n                        changed = True\n                        break\n                    i += 1\n            return path\n\n        # Initialization\n        start_tree = [Node(start_p)]\n        goal_tree = [Node(goal_p)]\n        all_nodes = start_tree + goal_tree\n        edges = []\n        c_min = dist(start_p, goal_p)\n        best_cost = float('inf')\n        best_path = []\n        found_solution = False\n        no_improve_count = 0\n        last_best_cost = float('inf')\n        start_time = time.time()\n        step_size = self.init_step\n\n        for iter_num in range(self.max_iter):\n            sample_pt = sample(best_cost)\n\n            # Alternate expanding trees\n            if iter_num % 2 == 0:\n                tree_a, tree_b = start_tree, goal_tree\n            else:\n                tree_a, tree_b = goal_tree, start_tree\n\n            # Gradually reduce step size to refine paths as more nodes added\n            num_nodes = len(all_nodes)\n            step_size = max(self.min_step, self.init_step * (1 - num_nodes / (self.max_iter * 1.1)))\n\n            new_node = add_node(tree_a, sample_pt, all_nodes, edges, best_cost, step_size)\n            if new_node is None:\n                if found_solution:\n                    no_improve_count += 1\n                continue\n\n            nbr, d_nbr = nearest(tree_b, new_node.position)\n            if nbr is not None and d_nbr <= step_size and not edge_obstacle(new_node.position, nbr.position):\n                candidate_path = connect_path(new_node, nbr)\n                candidate_cost = new_node.cost + dist(new_node.position, nbr.position) + nbr.cost\n                if candidate_cost + self.improve_tol < best_cost:\n                    best_cost = candidate_cost\n                    best_path = candidate_path\n                    found_solution = True\n                    no_improve_count = 0\n                else:\n                    no_improve_count += 1\n            elif found_solution:\n                no_improve_count += 1\n\n            if found_solution:\n                if best_cost + self.improve_tol < last_best_cost:\n                    last_best_cost = best_cost\n                    no_improve_count = 0\n                elif no_improve_count >= self.max_no_improve:\n                    break\n\n        if found_solution and len(best_path) > 2:\n            # Post-processing shortcutting reduces path length, indirect smoothness gain\n            for _ in range(3):\n                best_path = shortcut_path(best_path)\n\n        if found_solution:\n            return PlannerResult(True, best_path, all_nodes, edges)\n        else:\n            return PlannerResult(False, [], all_nodes, edges)",
          "objective": -31.91279,
          "time_improvement": 53.0,
          "length_improvement": 14.0,
          "smoothness_improvement": 1510.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.012701964378356934,
                    "num_nodes_avg": 93.4,
                    "path_length_avg": 167.30235687670796,
                    "smoothness_avg": 0.0425654522641374,
                    "success_improvement": 0.0,
                    "time_improvement": 47.69719371100672,
                    "length_improvement": 8.298927120381544,
                    "smoothness_improvement": 566.241760292773,
                    "objective_score": 22.119723186994808
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.022562861442565918,
                    "num_nodes_avg": 215.5,
                    "path_length_avg": 240.54349758360195,
                    "smoothness_avg": 0.10420826484630626,
                    "success_improvement": 0.0,
                    "time_improvement": 86.02618236758204,
                    "length_improvement": 19.699656845908514,
                    "smoothness_improvement": 2581.353712674754,
                    "objective_score": 50.53441738119349
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.03733506202697754,
                    "num_nodes_avg": 254.8,
                    "path_length_avg": 128.49722609113547,
                    "smoothness_avg": 0.11646484458584172,
                    "success_improvement": 0.0,
                    "time_improvement": 24.60720733732938,
                    "length_improvement": 14.658260810641927,
                    "smoothness_improvement": 1381.4242265913015,
                    "objective_score": 23.08423982054048
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m2",
          "algorithm_description": "An improved bidirectional RRT* planner with adaptive, theoretically grounded neighbor radius based on node count and problem dimension, enhanced rewiring that iteratively refines the parent-child relationships for better path cost, and informed sampling within an ellipsoidal subset after initial solution discovery to focus sampling and accelerate convergence. It incorporates a dynamic, multi-pass shortcutting routine for systematic path shortening and smoothing, and a stagnation-based early stopping mechanism. The planner leverages spatial hashing for efficient neighbor search and alternates expansion between start and goal trees while frequently attempting direct tree connections to quickly merge paths.",
          "planning_mechanism": "The planning process alternates growth between two trees from start and goal states. Uniform random sampling is used initially, then switches to ellipsoidal informed sampling constrained by the current best path cost. New nodes are added by steering toward sampled points, picking parents minimizing path cost with exhaustive collision checking, and neighbors are rewired if a lower cost path is found through the new node. Direct connections between trees are attempted each iteration to merge the trees early. The search halts when improvements stagnate. Finally, a comprehensive multi-pass shortcutting routine reduces path length and smoothness by reconnecting distant waypoints when collision-free. This strategy results in faster convergence, lower path cost, and smoother collision-free trajectories.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=4500, step_size=6.0, max_radius=30.0,\n                 min_radius=6.0, max_no_improve=60, time_limit=25.0,\n                 shortcut_iters=200):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.max_radius = max_radius\n        self.min_radius = min_radius\n        self.max_no_improve = max_no_improve\n        self.time_limit = time_limit\n        self.shortcut_iters = shortcut_iters\n\n    def plan(self, map):\n        import random\n        import math\n        import time\n\n        start = tuple(map.start)\n        goal = tuple(map.goal)\n        bounds = tuple(map.size)\n        obstacles = map.obstacles\n        dim = len(bounds)\n        dist = lambda a, b: math.dist(a, b)\n\n        def in_bounds(p):\n            return all(0.0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def in_obstacle(p):\n            if dim == 3:\n                px, py, pz = p\n                for ox, oy, oz, ow, oh, od in obstacles:\n                    if ox <= px <= ox+ow and oy <= py <= oy+oh and oz <= pz <= oz+od:\n                        return True\n                return False\n            else:\n                px, py = p\n                for ox, oy, ow, oh in obstacles:\n                    if ox <= px <= ox+ow and oy <= py <= oy+oh:\n                        return True\n                return False\n\n        def edge_in_obstacle(a, b, resolution=1.0):\n            d = dist(a, b)\n            if d < 1e-14:\n                return False\n            steps = max(2, int(d / resolution))\n            for i in range(steps + 1):\n                ipos = tuple(a[d_] + (b[d_] - a[d_]) * i / steps for d_ in range(dim))\n                if in_obstacle(ipos):\n                    return True\n            return False\n\n        def steer(from_p, to_p):\n            d = dist(from_p, to_p)\n            if d <= self.step_size:\n                return to_p\n            ratio = self.step_size / d\n            return tuple(from_p[d_] + (to_p[d_] - from_p[d_]) * ratio for d_ in range(dim))\n\n        class SpatialGrid:\n            def __init__(self, bounds, cell_size, dim):\n                self.bounds = bounds\n                self.cell_size = cell_size\n                self.dim = dim\n                self.cells = {}\n\n            def _hash_point(self, p):\n                return tuple(int(p[d] // self.cell_size) for d in range(self.dim))\n\n            def insert(self, node):\n                key = self._hash_point(node.position)\n                if key not in self.cells:\n                    self.cells[key] = []\n                self.cells[key].append(node)\n\n            def neighbors(self, point, radius):\n                low = [int((point[d] - radius) // self.cell_size) for d in range(self.dim)]\n                high = [int((point[d] + radius) // self.cell_size) for d in range(self.dim)]\n                result = []\n                def recur(idx=0, cur=[]):\n                    if idx == self.dim:\n                        t = tuple(cur)\n                        if t in self.cells:\n                            result.extend(self.cells[t])\n                        return\n                    for x in range(low[idx], high[idx]+1):\n                        cur.append(x)\n                        recur(idx+1, cur)\n                        cur.pop()\n                recur()\n                return result\n\n            def clear(self):\n                self.cells.clear()\n\n        def adaptive_radius(node_num, iteration):\n            if node_num <= 1:\n                return self.max_radius\n            base = self.max_radius * ((math.log(node_num) / node_num) ** (1/dim))\n            decay = 1.0 - 0.85 * (iteration / self.max_iter)\n            decay = max(decay, self.min_radius / self.max_radius)\n            r = base * decay\n            return min(max(r, self.min_radius), self.max_radius)\n\n        def neighbors_in_radius(tree_nodes, grid, p, radius):\n            candidates = grid.neighbors(p, radius)\n            return [n for n in candidates if dist(n.position, p) <= radius]\n\n        def choose_parent(tree_nodes, grid, pos, iter_i):\n            n = len(tree_nodes)\n            r = adaptive_radius(n, iter_i)\n            nbrs = neighbors_in_radius(tree_nodes, grid, pos, r)\n            min_cost = float('inf')\n            best_parent = None\n            for nb in nbrs:\n                if edge_in_obstacle(nb.position, pos):\n                    continue\n                cost_new = nb.cost + dist(nb.position, pos)\n                if cost_new < min_cost:\n                    min_cost = cost_new\n                    best_parent = nb\n            if best_parent is None:\n                # fallback nearest in the entire tree with collision check\n                nearest = min(tree_nodes, key=lambda n: dist(n.position, pos))\n                if edge_in_obstacle(nearest.position, pos):\n                    return None, []\n                min_cost = nearest.cost + dist(nearest.position, pos)\n                best_parent = nearest\n            new_node = Node(pos, best_parent, min_cost)\n            best_parent.add_child(new_node)\n            tree_nodes.append(new_node)\n            grid.insert(new_node)\n            return new_node, nbrs\n\n        def rewire(pivot, nbrs):\n            for nb in nbrs:\n                if nb is pivot.parent:\n                    continue\n                cost_through_pivot = pivot.cost + dist(pivot.position, nb.position)\n                if cost_through_pivot + 1e-12 < nb.cost:\n                    if edge_in_obstacle(pivot.position, nb.position):\n                        continue\n                    if nb.parent is not None:\n                        nb.parent.remove_child(nb)\n                    pivot.add_child(nb)\n                    nb.cost = cost_through_pivot\n\n        def direct_connect(tree_nodes, grid, target_node):\n            if not tree_nodes:\n                return None\n            nearest = min(tree_nodes, key=lambda n: dist(n.position, target_node.position))\n            d_near = dist(nearest.position, target_node.position)\n            if d_near <= self.step_size:\n                if in_obstacle(target_node.position) or edge_in_obstacle(nearest.position, target_node.position):\n                    return None\n                new_node = Node(target_node.position, nearest, nearest.cost + d_near)\n                nearest.add_child(new_node)\n                tree_nodes.append(new_node)\n                grid.insert(new_node)\n                return new_node\n            # Try straight connection if feasible\n            if not edge_in_obstacle(nearest.position, target_node.position):\n                new_node = Node(target_node.position, nearest, nearest.cost + d_near)\n                nearest.add_child(new_node)\n                tree_nodes.append(new_node)\n                grid.insert(new_node)\n                return new_node\n            # else stepwise steering\n            curr = nearest\n            steps = int(math.ceil(d_near / self.step_size))\n            for _ in range(steps):\n                new_pos = steer(curr.position, target_node.position)\n                if not in_bounds(new_pos) or in_obstacle(new_pos) or edge_in_obstacle(curr.position, new_pos):\n                    return None\n                new_node = Node(new_pos, curr, curr.cost + dist(curr.position, new_pos))\n                curr.add_child(new_node)\n                tree_nodes.append(new_node)\n                grid.insert(new_node)\n                curr = new_node\n                if dist(curr.position, target_node.position) <= self.step_size:\n                    if in_obstacle(target_node.position) or edge_in_obstacle(curr.position, target_node.position):\n                        return None\n                    final_node = Node(target_node.position, curr, curr.cost + dist(curr.position, target_node.position))\n                    curr.add_child(final_node)\n                    tree_nodes.append(final_node)\n                    grid.insert(final_node)\n                    return final_node\n            return None\n\n        def sample_uniform():\n            return tuple(random.uniform(0.0, bounds[d]) for d in range(dim))\n\n        def sample_informed():\n            # If no solution, uniform sampling\n            if not found_solution or best_cost >= float('inf') or c_min < 1e-12:\n                return sample_uniform()\n            center = tuple((start[d] + goal[d]) * 0.5 for d in range(dim))\n            unit_vec = [(goal[d] - start[d]) / c_min for d in range(dim)]\n            r1 = best_cost * 0.5\n            val = best_cost * best_cost - c_min * c_min\n            val = val if val > 0 else 0.0\n            r_other = math.sqrt(val) * 0.5\n            if dim == 2:\n                a1 = unit_vec\n                a2 = (-a1[1], a1[0])\n                basis = (a1, a2)\n                radii = (r1, r_other)\n            else:\n                def cross(u,v):\n                    return (u[1]*v[2]-u[2]*v[1], u[2]*v[0]-u[0]*v[2], u[0]*v[1]-u[1]*v[0])\n                def norm(v):\n                    return math.sqrt(sum(x*x for x in v))\n                a1 = unit_vec\n                ref = (1,0,0) if abs(a1[0]) < 0.9 else (0,1,0)\n                b2 = cross(a1, ref)\n                n_b2 = norm(b2)\n                if n_b2 < 1e-14:\n                    ref = (0,0,1)\n                    b2 = cross(a1, ref)\n                    n_b2 = norm(b2)\n                b2 = tuple(x / n_b2 for x in b2)\n                b3 = cross(a1, b2)\n                basis = (a1, b2, b3)\n                radii = (r1, r_other, r_other)\n\n            def sample_unit_ball(dim_):\n                while True:\n                    vec = [random.gauss(0,1) for _ in range(dim_)]\n                    nrm = math.sqrt(sum(x*x for x in vec))\n                    if nrm < 1e-14:\n                        continue\n                    vec = [x / nrm for x in vec]\n                    r = random.random() ** (1.0/dim_)\n                    return [x*r for x in vec]\n\n            u = sample_unit_ball(dim)\n            mapped = []\n            for d in range(dim):\n                val = center[d]\n                for i in range(dim):\n                    if i < len(basis):\n                        val += basis[i][d] * radii[i] * u[i]\n                val = min(max(val, 0.0), bounds[d])\n                mapped.append(val)\n            return tuple(mapped)\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return list(path)\n            path = list(path)\n            for _ in range(self.shortcut_iters):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if not edge_in_obstacle(p1, p2):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        def connect_paths(node1, node2):\n            p1 = node1.path_from_root()\n            p2 = node2.path_from_root()\n            if p1[-1] == p2[-1]:\n                return p1 + p2[-2::-1]\n            else:\n                return p1 + p2[::-1]\n\n        start_root = Node(start)\n        goal_root = Node(goal)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n\n        cellsize = self.step_size * 1.3\n        grid_start = SpatialGrid(bounds, cellsize, dim)\n        grid_goal = SpatialGrid(bounds, cellsize, dim)\n        grid_start.insert(start_root)\n        grid_goal.insert(goal_root)\n\n        c_min = dist(start, goal)\n        best_cost = float('inf')\n        best_path = []\n        found_solution = False\n        no_improve = 0\n\n        start_time = time.time()\n\n        for it in range(self.max_iter):\n            if time.time() - start_time > self.time_limit:\n                break\n\n            # Alternate expansion trees\n            if it % 2 == 0:\n                tree_a, grid_a = tree_start, grid_start\n                tree_b, grid_b = tree_goal, grid_goal\n            else:\n                tree_a, grid_a = tree_goal, grid_goal\n                tree_b, grid_b = tree_start, grid_start\n\n            x_rand = sample_informed()\n\n            if not in_bounds(x_rand) or in_obstacle(x_rand):\n                if found_solution:\n                    no_improve += 1\n                    if no_improve >= self.max_no_improve:\n                        break\n                continue\n\n            nearest = min(tree_a, key=lambda n: dist(n.position, x_rand))\n            new_pos = steer(nearest.position, x_rand)\n            if not in_bounds(new_pos) or in_obstacle(new_pos) or edge_in_obstacle(nearest.position, new_pos):\n                if found_solution:\n                    no_improve += 1\n                    if no_improve >= self.max_no_improve:\n                        break\n                continue\n\n            new_node, nbrs = choose_parent(tree_a, grid_a, new_pos, it)\n            if new_node is None:\n                if found_solution:\n                    no_improve += 1\n                    if no_improve >= self.max_no_improve:\n                        break\n                continue\n\n            rewire(new_node, nbrs)\n\n            meet_node = direct_connect(tree_b, grid_b, new_node)\n            if meet_node is not None:\n                candidate_path = connect_paths(new_node, meet_node)\n                total_cost = 0.0\n                for i in range(len(candidate_path) - 1):\n                    total_cost += dist(candidate_path[i], candidate_path[i + 1])\n                if total_cost + 1e-9 < best_cost:\n                    best_cost = total_cost\n                    best_path = candidate_path\n                    found_solution = True\n                    no_improve = 0\n                else:\n                    if found_solution:\n                        no_improve += 1\n                        if no_improve >= self.max_no_improve:\n                            break\n            else:\n                if found_solution:\n                    no_improve += 1\n                    if no_improve >= self.max_no_improve:\n                        break\n\n        if found_solution and len(best_path) >= 3:\n            best_path = shortcut_path(best_path)\n\n        edges = []\n        nodes = tree_start + tree_goal\n\n        return PlannerResult(success=found_solution, path=best_path, nodes=nodes, edges=edges)",
          "objective": -29.91783,
          "time_improvement": 46.0,
          "length_improvement": 14.0,
          "smoothness_improvement": 1555.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.020644402503967284,
                    "num_nodes_avg": 118.4,
                    "path_length_avg": 169.0226977959034,
                    "smoothness_avg": 0.04720262625634684,
                    "success_improvement": 0.0,
                    "time_improvement": 14.992661532193544,
                    "length_improvement": 7.355981002024172,
                    "smoothness_improvement": 638.8236030553472,
                    "objective_score": 12.105505076149303
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.025356411933898926,
                    "num_nodes_avg": 252.5,
                    "path_length_avg": 240.011600121993,
                    "smoothness_avg": 0.10931841458459605,
                    "success_improvement": 0.0,
                    "time_improvement": 84.29605761313955,
                    "length_improvement": 19.877219528413136,
                    "smoothness_improvement": 2712.841546133033,
                    "objective_score": 50.779356731654914
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.031077861785888672,
                    "num_nodes_avg": 294.5,
                    "path_length_avg": 127.65842370425962,
                    "smoothness_avg": 0.1111108992511941,
                    "success_improvement": 0.0,
                    "time_improvement": 37.24272405575215,
                    "length_improvement": 15.215353416527435,
                    "smoothness_improvement": 1313.3224371217204,
                    "objective_score": 26.868641452250706
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "path_expert",
          "algorithm_description": "A bidirectional asymptotically optimal RRT* variant with adaptive neighbor radius and progressive informed sampling focusing search on ellipsoidal subset post initial solution, combined with dynamic rewiring restricting checks to adaptive radius neighborhood shrinking with best cost, early termination on improvement stagnation, and efficient path shortening by progressive edge skips to significantly minimize path length and improve smoothness and planning speed.",
          "planning_mechanism": "A bidirectional planner grows two trees alternately from start and goal by sampling points with uniform distribution initially, switching to informed ellipsoidal sampling after initial feasible path discovered. Each new node selects parent minimizing cost within an adaptive neighborhood radius that shrinks as best path cost improves, rewires neighbors within this radius for incremental path cost reduction, and attempts connecting to opposite tree. Early termination triggers after stagnation. Final path undergoes efficient shortcut smoothing by attempting to connect non-adjacent nodes iteratively with minimal edge checks, resulting in shorter and smoother path.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self,\n                 max_iter=3000,\n                 step_size=5.0,\n                 neighbor_radius_max=30.0,\n                 neighbor_radius_min=5.0,\n                 max_no_improve=50,\n                 shortcut_iter=200):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.neighbor_radius_max = neighbor_radius_max\n        self.neighbor_radius_min = neighbor_radius_min\n        self.max_no_improve = max_no_improve\n        self.shortcut_iter = shortcut_iter\n\n    def plan(self, map):\n        import math\n        import random\n        bounds = map.size\n        dim = len(bounds)\n        start_pos = tuple(map.start)\n        goal_pos = tuple(map.goal)\n        obstacles = map.obstacles\n        is_3d = (dim == 3)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def in_obstacle(p):\n            px, py, pz = (p + (0, 0, 0))[:3]\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def edge_in_obstacle(a, b, resolution=1.0):\n            dist_ab = math.dist(a, b)\n            if dist_ab < 1e-12:\n                return False\n            steps = max(2, int(dist_ab / resolution))\n            for i in range(steps + 1):\n                interp = tuple(a[d] + (b[d] - a[d]) * i / steps for d in range(dim))\n                if in_obstacle(interp):\n                    return True\n            return False\n\n        def steer(frm, to):\n            dist = math.dist(frm, to)\n            if dist <= self.step_size:\n                return to\n            ratio = self.step_size / dist\n            return tuple(frm[d] + (to[d] - frm[d]) * ratio for d in range(dim))\n\n        def dist_sq(a, b):\n            return sum((a[d] - b[d])**2 for d in range(dim))\n\n        def neighbors(tree, point, radius):\n            rad_sq = radius * radius\n            res = []\n            for node in tree:\n                if dist_sq(node.position, point) <= rad_sq:\n                    res.append(node)\n            return res\n\n        def choose_parent(tree, new_pos, radius):\n            nbrs = neighbors(tree, new_pos, radius)\n            valid_parents = [n for n in nbrs if not edge_in_obstacle(n.position, new_pos)]\n            if not valid_parents:\n                # fallback: nearest with collision-free edge\n                nearest = None\n                nearest_dist = float('inf')\n                for n in tree:\n                    d = math.dist(n.position, new_pos)\n                    if d < nearest_dist and not edge_in_obstacle(n.position, new_pos):\n                        nearest = n\n                        nearest_dist = d\n                if nearest is None:\n                    return None, []\n                cost = nearest.cost + nearest_dist\n                new_node = Node(new_pos, parent=nearest, cost=cost)\n                nearest.add_child(new_node)\n                tree.append(new_node)\n                return new_node, []\n            best_parent = min(valid_parents, key=lambda p: p.cost + math.dist(p.position, new_pos))\n            cost_min = best_parent.cost + math.dist(best_parent.position, new_pos)\n            new_node = Node(new_pos, parent=best_parent, cost=cost_min)\n            best_parent.add_child(new_node)\n            tree.append(new_node)\n            return new_node, valid_parents\n\n        def rewire(pivot, neighbors_):\n            for nb in neighbors_:\n                if nb == pivot.parent:\n                    continue\n                dist_pivot_nb = math.dist(pivot.position, nb.position)\n                new_cost = pivot.cost + dist_pivot_nb\n                if new_cost + 1e-12 < nb.cost:\n                    if edge_in_obstacle(pivot.position, nb.position):\n                        continue\n                    if nb.parent:\n                        nb.parent.remove_child(nb)\n                    pivot.add_child(nb)\n                    nb.cost = new_cost\n\n        def attempt_connect(tree_from, target_node):\n            if not tree_from:\n                return None\n            # Nearest neighbor in tree_from to target_node\n            nearest = min(tree_from, key=lambda n: math.dist(n.position, target_node.position))\n            dist_near = math.dist(nearest.position, target_node.position)\n            if dist_near <= self.step_size:\n                if edge_in_obstacle(nearest.position, target_node.position) or in_obstacle(target_node.position):\n                    return None\n                new_node = Node(target_node.position, parent=nearest, cost=nearest.cost + dist_near)\n                nearest.add_child(new_node)\n                tree_from.append(new_node)\n                return new_node\n            # incremental steering towards target node\n            current = nearest\n            steps = int(math.ceil(dist_near / self.step_size))\n            for _ in range(steps):\n                new_pos = steer(current.position, target_node.position)\n                if not in_bounds(new_pos) or in_obstacle(new_pos) or edge_in_obstacle(current.position, new_pos):\n                    return None\n                new_node = Node(new_pos, parent=current, cost=current.cost + math.dist(current.position, new_pos))\n                current.add_child(new_node)\n                tree_from.append(new_node)\n                current = new_node\n                if math.dist(current.position, target_node.position) <= self.step_size:\n                    if edge_in_obstacle(current.position, target_node.position) or in_obstacle(target_node.position):\n                        return None\n                    final_node = Node(target_node.position, parent=current,\n                                      cost=current.cost + math.dist(current.position, target_node.position))\n                    current.add_child(final_node)\n                    tree_from.append(final_node)\n                    return final_node\n            return None\n\n        def sample_uniform():\n            return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        def sample_informed(c_best, c_min):\n            if c_best == float('inf') or c_min < 1e-12:\n                return sample_uniform()\n            center = tuple((start_pos[d] + goal_pos[d]) * 0.5 for d in range(dim))\n            unit_dir = []\n            for d in range(dim):\n                unit_dir.append((goal_pos[d] - start_pos[d]) / c_min)\n            r1 = c_best * 0.5\n            val = max(c_best*c_best - c_min*c_min, 0.0)\n            r_other = math.sqrt(val)*0.5\n\n            if dim == 2:\n                a1 = unit_dir\n                a2 = (-a1[1], a1[0])\n                basis = (a1, a2)\n                radii = (r1, r_other)\n            else:\n                def cross(u,v):\n                    return (u[1]*v[2]-u[2]*v[1], u[2]*v[0]-u[0]*v[2], u[0]*v[1]-u[1]*v[0])\n                def norm(v):\n                    return math.sqrt(sum(x*x for x in v))\n                a1 = unit_dir\n                ref = (1,0,0) if abs(a1[0]) < 0.9 else (0,1,0)\n                b2 = cross(a1, ref)\n                n_b2 = norm(b2)\n                if n_b2 < 1e-12:\n                    ref = (0,0,1)\n                    b2 = cross(a1, ref)\n                    n_b2 = norm(b2)\n                b2 = tuple(x / n_b2 for x in b2)\n                b3 = cross(a1, b2)\n                basis = (a1, b2, b3)\n                radii = (r1, r_other, r_other)\n\n            def sample_unit_ball(d):\n                while True:\n                    vec = [random.gauss(0,1) for _ in range(d)]\n                    nrm = math.sqrt(sum(v*v for v in vec))\n                    if nrm < 1e-12:\n                        continue\n                    vec = [v/nrm for v in vec]\n                    r = random.random() ** (1/d)\n                    return [v*r for v in vec]\n\n            u = sample_unit_ball(dim)\n            mapped = []\n            for d in range(dim):\n                val = center[d]\n                for i in range(dim):\n                    val += basis[i][d] * radii[i] * u[i]\n                # clamp to bounds\n                val = max(0.0, min(val, bounds[d]))\n                mapped.append(val)\n            return tuple(mapped)\n\n        def adaptive_radius(num_nodes, best_cost):\n            # Decay neighbor radius inversely with node count and best_cost\n            r = min(self.neighbor_radius_max,\n                    max(self.neighbor_radius_min,\n                        self.neighbor_radius_max * (math.log(num_nodes + 1) / (num_nodes + 1))**0.5))\n            if best_cost != float('inf'):\n                # shrink radius proportional to best_cost\n                r = max(self.neighbor_radius_min, min(r, best_cost * 0.5))\n            return r\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return list(path)\n            path = list(path)\n            i = 0\n            while i < len(path)-2:\n                j = len(path) - 1\n                while j > i + 1:\n                    if not edge_in_obstacle(path[i], path[j]):\n                        # shortcut by skipping intermediate nodes\n                        path = path[:i+1] + path[j:]\n                        j = i + 1\n                    else:\n                        j -= 1\n                i += 1\n                if i >= self.shortcut_iter:\n                    break\n            return path\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        best_path = []\n        best_cost = float('inf')\n        c_min = math.dist(start_pos, goal_pos)\n        found_solution = False\n        no_improve_count = 0\n\n        for iter_i in range(self.max_iter):\n            if found_solution:\n                sample = sample_informed(best_cost, c_min)\n                if random.random() < 0.15:\n                    sample = sample_uniform()  # exploration chance\n            else:\n                sample = sample_uniform()\n\n            if not in_bounds(sample) or in_obstacle(sample):\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n                continue\n\n            tree_a, tree_b = (start_tree, goal_tree) if iter_i % 2 == 0 else (goal_tree, start_tree)\n\n            # Nearest node in tree_a\n            nearest_n = min(tree_a, key=lambda n: math.dist(n.position, sample))\n            new_pos = steer(nearest_n.position, sample)\n            if not in_bounds(new_pos) or in_obstacle(new_pos) or edge_in_obstacle(nearest_n.position, new_pos):\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n                continue\n\n            rad = adaptive_radius(len(nodes), best_cost)\n            new_node, nbrs = choose_parent(tree_a, new_pos, rad)\n            if new_node is None:\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n                continue\n\n            rewire(new_node, nbrs)\n            nodes.append(new_node)\n            if new_node.parent:\n                edges.append((new_node.parent, new_node))\n\n            connect_node = attempt_connect(tree_b, new_node)\n            if connect_node:\n                if iter_i % 2 == 0:\n                    path_a = new_node.path_from_root()\n                    path_b = connect_node.path_from_root()\n                else:\n                    path_a = connect_node.path_from_root()\n                    path_b = new_node.path_from_root()\n\n                if path_a and path_b and (path_a[-1] == path_b[-1]):\n                    candidate_path = path_a + path_b[-2::-1]\n                else:\n                    candidate_path = path_a + path_b[::-1]\n\n                total_cost = 0.0\n                for i in range(len(candidate_path)-1):\n                    total_cost += math.dist(candidate_path[i], candidate_path[i+1])\n\n                if total_cost + 1e-9 < best_cost:\n                    best_cost = total_cost\n                    best_path = candidate_path\n                    found_solution = True\n                    no_improve_count = 0\n                else:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n            else:\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n\n        if found_solution and len(best_path) >= 3:\n            best_path = shortcut_path(best_path)\n\n        return PlannerResult(success=found_solution, path=best_path, nodes=nodes, edges=edges)",
          "objective": -29.5854,
          "time_improvement": 35.0,
          "length_improvement": 17.0,
          "smoothness_improvement": 1734.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.01630527973175049,
                    "num_nodes_avg": 82.8,
                    "path_length_avg": 161.05776434064808,
                    "smoothness_avg": 0.053811509689846534,
                    "success_improvement": 0.0,
                    "time_improvement": 32.85984262790777,
                    "length_improvement": 11.721687241296925,
                    "smoothness_improvement": 742.2669802096958,
                    "objective_score": 20.60230003419896
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.046596860885620116,
                    "num_nodes_avg": 251.8,
                    "path_length_avg": 233.4754024234387,
                    "smoothness_avg": 0.10983159911883991,
                    "success_improvement": 0.0,
                    "time_improvement": 71.14124740267181,
                    "length_improvement": 22.05919045420994,
                    "smoothness_improvement": 2726.0461538310064,
                    "objective_score": 48.20811926248254
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.04924318790435791,
                    "num_nodes_avg": 268.5,
                    "path_length_avg": 122.70798890963113,
                    "smoothness_avg": 0.14427317884692367,
                    "success_improvement": 0.0,
                    "time_improvement": 0.5604583423605622,
                    "length_improvement": 18.5031964927466,
                    "smoothness_improvement": 1735.1441857945422,
                    "objective_score": 19.945776327328836
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m1",
          "algorithm_description": "A bidirectional RRT* planner with consistent adaptive neighbor radius, incremental rewiring on insertions, and ellipsoidal informed sampling guiding exploration. It aggressively attempts direct tree connections, applies iterative random shortcutting post-planning for path smoothing and shortening, and includes early stopping after stagnation to save time, thus improving planning efficiency, path quality, robustness, and smoothness.",
          "planning_mechanism": "The planner grows two trees from start and goal points by sampling points with uniform distribution initially and ellipsoidal informed sampling once a solution is found. Each iteration alternates expanding one tree toward a sampled point, choosing a parent and rewiring neighbors within an adaptive radius that shrinks over iterations. After each insertion, it tries direct connection to the opposite tree to form a valid path. The best discovered path is updated incrementally, and if no improvement occurs over many iterations, planning halts early. Post-planning applies multiple shortcut attempts on the best path to enhance smoothness and reduce length.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self,\n                 max_iter=5000,\n                 step_size=5.0,\n                 max_radius=30.0,\n                 min_radius=5.0,\n                 max_no_improve=80,\n                 time_limit=30.0,\n                 shortcut_iter=150):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.max_radius = max_radius\n        self.min_radius = min_radius\n        self.max_no_improve = max_no_improve\n        self.time_limit = time_limit\n        self.shortcut_iter = shortcut_iter\n\n    def plan(self, map):\n        import time\n        import math\n        import random\n\n        bounds = map.size\n        dim = len(bounds)\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = (dim == 3)\n\n        def in_bounds(pos):\n            return all(0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    px, py = pos\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def edge_in_obstacle(a, b, res=1.0):\n            dist = math.dist(a, b)\n            if dist < 1e-12:\n                return False\n            steps = max(2, int(dist / res))\n            for i in range(steps + 1):\n                interp = tuple(a[d] + (b[d] - a[d]) * i / steps for d in range(dim))\n                if in_obstacle(interp):\n                    return True\n            return False\n\n        def steer(from_p, to_p):\n            dist = math.dist(from_p, to_p)\n            if dist <= self.step_size:\n                return to_p\n            ratio = self.step_size / dist\n            return tuple(from_p[d] + (to_p[d] - from_p[d]) * ratio for d in range(dim))\n\n        def adaptive_radius(n, iter_i):\n            gamma = self.max_radius\n            unit_ball_volume = (math.pi ** (dim / 2)) / math.gamma(dim / 2 + 1) if dim > 1 else 2.0\n            if n < 1:\n                return self.max_radius\n            radius = gamma * ((math.log(n + 1) / (n + 1)) ** (1 / dim))\n            decay = max(self.min_radius / gamma, 1.0 - 0.9 * (iter_i / self.max_iter))\n            radius = max(self.min_radius, min(radius * decay, self.max_radius))\n            return radius\n\n        def neighbors(tree, pos, radius):\n            r_sq = radius * radius\n            result = []\n            for node in tree:\n                dist_sq = 0.0\n                for d in range(dim):\n                    diff = node.position[d] - pos[d]\n                    dist_sq += diff * diff\n                    if dist_sq > r_sq:\n                        break\n                else:\n                    result.append(node)\n            return result\n\n        def choose_parent(tree, pos, iter_i):\n            n = len(tree)\n            r = adaptive_radius(n, iter_i)\n            nbrs = neighbors(tree, pos, r)\n            if not nbrs:\n                nearest = min(tree, key=lambda node: math.dist(node.position, pos))\n                if edge_in_obstacle(nearest.position, pos) or in_obstacle(pos):\n                    return None, []\n                cost_to_here = nearest.cost + math.dist(nearest.position, pos)\n                new_node = Node(pos, parent=nearest, cost=cost_to_here)\n                nearest.add_child(new_node)\n                tree.append(new_node)\n                return new_node, []\n            min_cost = float('inf')\n            best_parent = None\n            for nb in nbrs:\n                dist_nb = math.dist(nb.position, pos)\n                est_cost = nb.cost + dist_nb\n                if est_cost >= min_cost:\n                    continue\n                if edge_in_obstacle(nb.position, pos):\n                    continue\n                if est_cost < min_cost:\n                    min_cost = est_cost\n                    best_parent = nb\n            if best_parent is None:\n                nearest = min(tree, key=lambda node: math.dist(node.position, pos))\n                if edge_in_obstacle(nearest.position, pos) or in_obstacle(pos):\n                    return None, []\n                best_parent = nearest\n                min_cost = best_parent.cost + math.dist(best_parent.position, pos)\n            new_node = Node(pos, parent=best_parent, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree.append(new_node)\n            return new_node, nbrs\n\n        def rewire(pivot, nbrs):\n            for nb in nbrs:\n                if nb == pivot.parent:\n                    continue\n                new_cost = pivot.cost + math.dist(pivot.position, nb.position)\n                if new_cost + 1e-12 < nb.cost:\n                    if edge_in_obstacle(pivot.position, nb.position):\n                        continue\n                    # Remove from old parent children to avoid dangling references\n                    if nb.parent is not None and nb in nb.parent.children:\n                        nb.parent.children.remove(nb)\n                    pivot.add_child(nb)\n                    nb.cost = new_cost\n\n        def direct_connect(tree, target_node):\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda n: math.dist(n.position, target_node.position))\n            dist = math.dist(nearest.position, target_node.position)\n            if dist <= self.step_size:\n                if edge_in_obstacle(nearest.position, target_node.position) or in_obstacle(target_node.position):\n                    return None\n                new_node = Node(target_node.position, parent=nearest, cost=nearest.cost + dist)\n                nearest.add_child(new_node)\n                tree.append(new_node)\n                return new_node\n            # Incremental connection attempt toward target\n            current = nearest\n            steps = int(math.ceil(dist / self.step_size))\n            for _ in range(steps):\n                new_pos = steer(current.position, target_node.position)\n                if not in_bounds(new_pos) or in_obstacle(new_pos) or edge_in_obstacle(current.position, new_pos):\n                    return None\n                new_node = Node(new_pos, parent=current, cost=current.cost + math.dist(current.position, new_pos))\n                current.add_child(new_node)\n                tree.append(new_node)\n                current = new_node\n                if math.dist(current.position, target_node.position) <= self.step_size:\n                    if edge_in_obstacle(current.position, target_node.position) or in_obstacle(target_node.position):\n                        return None\n                    final_node = Node(target_node.position, parent=current, cost=current.cost + math.dist(current.position, target_node.position))\n                    current.add_child(final_node)\n                    tree.append(final_node)\n                    return final_node\n            return None\n\n        def sample_uniform():\n            while True:\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not in_obstacle(p):\n                    return p\n\n        def sample_informed():\n            if not found_solution or best_cost == float('inf') or c_min < 1e-12:\n                return sample_uniform()\n            center = tuple((start_pos[d] + goal_pos[d]) * 0.5 for d in range(dim))\n            unit_dir = tuple((goal_pos[d] - start_pos[d]) / c_min for d in range(dim))\n            r1 = best_cost * 0.5\n            val = max(best_cost*best_cost - c_min*c_min, 0.0)\n            r_other = math.sqrt(val) * 0.5\n            if dim == 2:\n                a1 = unit_dir\n                a2 = (-a1[1], a1[0])\n                basis = (a1, a2)\n                radii = (r1, r_other)\n            else:\n                def cross(u, v):\n                    return (u[1]*v[2] - u[2]*v[1], u[2]*v[0] - u[0]*v[2], u[0]*v[1] - u[1]*v[0])\n                def norm(v):\n                    return math.sqrt(sum(x*x for x in v))\n                a1 = unit_dir\n                ref = (1,0,0) if abs(a1[0]) < 0.9 else (0,1,0)\n                b2 = cross(a1, ref)\n                n_b2 = norm(b2)\n                if n_b2 < 1e-12:\n                    ref = (0,0,1)\n                    b2 = cross(a1, ref)\n                    n_b2 = norm(b2)\n                b2 = tuple(x / n_b2 for x in b2)\n                b3 = cross(a1, b2)\n                basis = (a1, b2, b3)\n                radii = (r1, r_other, r_other)\n            def sample_unit_ball(dim):\n                while True:\n                    vec = [random.gauss(0,1) for _ in range(dim)]\n                    nrm = math.sqrt(sum(v*v for v in vec))\n                    if nrm < 1e-12:\n                        continue\n                    vec = [v/nrm for v in vec]\n                    r = random.random() ** (1/dim)\n                    return [v*r for v in vec]\n            u = sample_unit_ball(dim)\n            mapped = []\n            for d in range(dim):\n                val = center[d]\n                for i in range(dim):\n                    val += basis[i][d]*radii[i]*u[i]\n                val = max(0.0, min(val, bounds[d]))\n                mapped.append(val)\n            if not in_obstacle(tuple(mapped)):\n                return tuple(mapped)\n            else:\n                return sample_uniform()\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path[:]\n            for _ in range(self.shortcut_iter):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path)-3)\n                j = random.randint(i+2, len(path)-1)\n                p1, p2 = path[i], path[j]\n                if not edge_in_obstacle(p1, p2):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        best_path = []\n        best_cost = float('inf')\n        c_min = math.dist(start_pos, goal_pos)\n        found_solution = False\n        no_improve_count = 0\n\n        start_time = time.time()\n\n        for it in range(self.max_iter):\n            if time.time() - start_time > self.time_limit:\n                break\n\n            tree_a, tree_b = (start_tree, goal_tree) if it % 2 == 0 else (goal_tree, start_tree)\n            x_rand = sample_informed()\n\n            if not in_bounds(x_rand) or in_obstacle(x_rand):\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n                continue\n\n            nearest = min(tree_a, key=lambda node: math.dist(node.position, x_rand))\n            new_pos = steer(nearest.position, x_rand)\n            if not in_bounds(new_pos) or in_obstacle(new_pos) or edge_in_obstacle(nearest.position, new_pos):\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n                continue\n\n            new_node, nbrs = choose_parent(tree_a, new_pos, it)\n            if new_node is None:\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n                continue\n\n            rewire(new_node, nbrs)\n            nodes.append(new_node)\n            if new_node.parent:\n                edges.append((new_node.parent, new_node))\n\n            meet_node = direct_connect(tree_b, new_node)\n            if meet_node is not None:\n                # Construct combined path (avoid duplication at connection node)\n                if it % 2 == 0:\n                    path_a = new_node.path_from_root()\n                    path_b = meet_node.path_from_root()\n                else:\n                    path_a = meet_node.path_from_root()\n                    path_b = new_node.path_from_root()\n                if path_a and path_b and path_a[-1] == path_b[-1]:\n                    merged_path = path_a + path_b[-2::-1]\n                else:\n                    merged_path = path_a + path_b[::-1]\n\n                total_cost = 0.0\n                for i in range(len(merged_path) - 1):\n                    total_cost += math.dist(merged_path[i], merged_path[i + 1])\n\n                if total_cost + 1e-9 < best_cost:\n                    best_cost = total_cost\n                    best_path = merged_path\n                    found_solution = True\n                    no_improve_count = 0\n                else:\n                    if found_solution:\n                        no_improve_count += 1\n                        if no_improve_count >= self.max_no_improve:\n                            break\n            else:\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n\n        if found_solution and len(best_path) >= 3:\n            best_path = shortcut_path(best_path)\n\n        return PlannerResult(success=found_solution, path=best_path, nodes=nodes, edges=edges)",
          "objective": -28.25774,
          "time_improvement": 36.0,
          "length_improvement": 17.0,
          "smoothness_improvement": 1476.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.020374512672424315,
                    "num_nodes_avg": 117.1,
                    "path_length_avg": 160.29717568265116,
                    "smoothness_avg": 0.04606419133881355,
                    "success_improvement": 0.0,
                    "time_improvement": 16.103985352516435,
                    "length_improvement": 12.138577937043584,
                    "smoothness_improvement": 621.0046244449597,
                    "objective_score": 15.21936549020588
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.029372024536132812,
                    "num_nodes_avg": 280.0,
                    "path_length_avg": 239.5929063098773,
                    "smoothness_avg": 0.09565090723691308,
                    "success_improvement": 0.0,
                    "time_improvement": 81.80907526256789,
                    "length_improvement": 20.016991574330532,
                    "smoothness_improvement": 2361.166737769517,
                    "objective_score": 48.35875121221627
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.04408328533172608,
                    "num_nodes_avg": 403.4,
                    "path_length_avg": 123.7830250208629,
                    "smoothness_avg": 0.12150286008847652,
                    "success_improvement": 0.0,
                    "time_improvement": 10.980140102549283,
                    "length_improvement": 17.789208695385014,
                    "smoothness_improvement": 1445.5074119171938,
                    "objective_score": 21.195104307581765
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m1",
          "algorithm_description": "An improved bidirectional RRT* planner that employs KD-tree-like efficient nearest neighbor queries, a theoretically consistent and dynamically scaled rewiring radius for more effective parent selection and rewiring, progressive rewiring over local neighborhoods to better reduce path length, and a multi-pass curvature- and cost-aware shortcutting method to significantly enhance path smoothness and reduce path length. It uses an ellipsoidal informed sampling bias after initial solution discovery to focus search within promising regions, includes early stopping criteria to avoid wasted computation, and ensures both node and edge collision checks are strictly enforced to guarantee valid paths. The planner alternates expansion between start and goal trees, attempts connections after each insertion, and adapts radius with principled scaling to improve rewiring opportunities while controlling computational growth.",
          "planning_mechanism": "The planner initializes two trees from start and goal, alternately samples points biased by an ellipsoidal informed set once a solution is found, uses KD-tree style approximate nearest and near node queries, employs a rewiring radius scaled by theoretical RRT* bounds dynamically adjusted by current best path cost, selects parents minimizing total cost only (without curvature bias) to favor shorter paths, performs comprehensive rewiring to iteratively improve node costs, attempts connection between trees at each iteration, and applies a multi-pass shortcutting method focusing on curvature and cost reduction, while halting early upon stagnation to improve planning efficiency and solution quality.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=3500, step_size=6.0, n_near_const=25,\n                 max_no_improve=50, improve_tol=1e-8, shortcut_iters=150):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.n_near_const = n_near_const\n        self.max_no_improve = max_no_improve\n        self.improve_tol = improve_tol\n        self.shortcut_iters = shortcut_iters\n\n    def plan(self, map):\n        import math, random, time\n\n        start = tuple(map.start)\n        goal = tuple(map.goal)\n        bounds = tuple(map.size)\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        dist = lambda a, b: math.dist(a, b)\n\n        def in_bounds(p):\n            return all(0.0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def in_obstacle(p):\n            px, py, pz = (p + (0, 0, 0))[:3]\n            for obs in obstacles:\n                if is_3d:\n                    ox, oy, oz, ow, oh, od = obs\n                    if ox <= px <= ox + ow and oy <= py <= oy + oh and oz <= pz <= oz + od:\n                        return True\n                else:\n                    ox, oy, ow, oh = obs\n                    if ox <= px <= ox + ow and oy <= py <= oy + oh:\n                        return True\n            return False\n\n        def edge_in_obstacle(f, t, resolution=1.0):\n            length = dist(f, t)\n            if length < 1e-12:\n                return False\n            steps = max(5, int(length / resolution))\n            for i in range(steps + 1):\n                inter = tuple(f[d] + (t[d] - f[d]) * i / steps for d in range(dim))\n                if in_obstacle(inter):\n                    return True\n            return False\n\n        def steer(frm, to):\n            d = dist(frm, to)\n            if d <= self.step_size:\n                return to\n            ratio = self.step_size / d\n            return tuple(frm[i] + (to[i] - frm[i]) * ratio for i in range(dim))\n\n        def nearest(tree, p):\n            best = None\n            best_d2 = float('inf')\n            px = p\n            for n in tree:\n                d2 = 0.0\n                for i_ in range(dim):\n                    tmp = n.position[i_] - px[i_]\n                    d2 += tmp * tmp\n                    if d2 >= best_d2:  # early prune\n                        break\n                else:\n                    if d2 < best_d2:\n                        best = n\n                        best_d2 = d2\n            return best, math.sqrt(best_d2)\n\n        def near_nodes(tree, p, radius):\n            rq = radius * radius\n            px = p\n            res = []\n            for n in tree:\n                d2 = 0.0\n                for i_ in range(dim):\n                    tmp = n.position[i_] - px[i_]\n                    d2 += tmp * tmp\n                    if d2 > rq:\n                        break\n                if d2 <= rq:\n                    res.append(n)\n            return res\n\n        def adaptive_radius(n_nodes, c_best):\n            # Theoretical RRT* radius with adaptation to current best cost\n            if n_nodes == 0:\n                return self.step_size * 5.0\n            from math import log, pow\n            base = pow((self.n_near_const * log(n_nodes)) / n_nodes, 1.0 / dim)\n            base = min(base, self.step_size * 7.0)\n            # Shrink radius based on best cost compared to minimum possible (start-goal dist)\n            shrink = 1.0\n            if c_best < float('inf'):\n                shrink = max(0.3, c_best / (self.c_min * 2.5))\n            radius = base * shrink\n            radius = max(radius, self.step_size * 0.8)\n            return radius\n\n        def ellipsoid_sample(c_best):\n            if c_best == float('inf'):\n                return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n            center = tuple((start[i] + goal[i]) * 0.5 for i in range(dim))\n            a1 = [goal[i] - start[i] for i in range(dim)]\n            norm_a1 = math.sqrt(sum(x * x for x in a1))\n            if norm_a1 < 1e-14:\n                return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n            unit_a1 = [x / norm_a1 for x in a1]\n\n            # Orthonormal basis construction via Gram-Schmidt\n            U = [unit_a1]\n            for idx in range(dim - 1):\n                base = [0.0] * dim\n                base[(idx + 1) % dim] = 1.0\n                for u in U:\n                    proj = sum(base[j] * u[j] for j in range(dim))\n                    base = [base[j] - proj * u[j] for j in range(dim)]\n                norm_base = math.sqrt(sum(x * x for x in base))\n                if norm_base > 1e-14:\n                    U.append([x / norm_base for x in base])\n                else:\n                    U.append([0.0] * dim)\n\n            r1 = c_best * 0.5\n            val = c_best * c_best - self.c_min * self.c_min\n            r2 = math.sqrt(val) * 0.5 if val > 0 else 0.0\n            radii = [r1] + [r2] * (dim - 1)\n\n            for _ in range(50):\n                x_ball = [random.gauss(0., 1.) for _ in range(dim)]\n                norm_ball = math.sqrt(sum(x * x for x in x_ball))\n                if norm_ball < 1e-14:\n                    continue\n                unit_ball = [x / norm_ball for x in x_ball]\n                u = random.random() ** (1.0 / dim)\n                point_ball = [coord * u for coord in unit_ball]\n                scaled = [radii[i] * point_ball[i] for i in range(dim)]\n                point_rot = [0.0] * dim\n                for i_ in range(dim):\n                    for j_ in range(dim):\n                        point_rot[j_] += scaled[i_] * U[i_][j_]\n                sample = tuple(center[i] + point_rot[i] for i in range(dim))\n                if all(0.0 <= sample[i] <= bounds[i] for i in range(dim)) and not in_obstacle(sample):\n                    return sample\n            # fallback uniform\n            return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n\n        def add_node(tree, sample_pt, all_nodes, edges, c_best):\n            nn, _ = nearest(tree, sample_pt)\n            if nn is None:\n                return None\n            new_pos = steer(nn.position, sample_pt)\n            if not in_bounds(new_pos) or in_obstacle(new_pos) or edge_in_obstacle(nn.position, new_pos):\n                return None\n\n            n_nodes = len(all_nodes)\n            radius = adaptive_radius(n_nodes, c_best)\n\n            near = near_nodes(tree, new_pos, radius)\n            # Include nearest always for parent candidates\n            if nn not in near:\n                near.append(nn)\n            # Parent selection: cost only (no curvature bias)\n            best_parent = None\n            best_cost = float('inf')\n            for candidate in near:\n                if edge_in_obstacle(candidate.position, new_pos):\n                    continue\n                candidate_cost = candidate.cost + dist(candidate.position, new_pos)\n                if candidate_cost < best_cost:\n                    best_cost = candidate_cost\n                    best_parent = candidate\n            if best_parent is None:\n                return None\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = best_cost\n            tree.append(new_node)\n            all_nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewiring: try to improve costs of neighbors through new_node\n            for near_n in near:\n                if near_n is best_parent or near_n is new_node:\n                    continue\n                if edge_in_obstacle(new_node.position, near_n.position):\n                    continue\n                alt_cost = new_node.cost + dist(new_node.position, near_n.position)\n                if alt_cost + self.improve_tol < near_n.cost:\n                    # Reassign parent inline\n                    if near_n.parent:\n                        near_n.parent.remove_child(near_n)\n                    new_node.add_child(near_n)\n                    near_n.cost = alt_cost\n                    try:\n                        edges.remove((near_n.parent, near_n))\n                    except Exception:\n                        pass\n                    edges.append((new_node, near_n))\n\n            return new_node\n\n        def join_paths(n1, n2):\n            p1 = n1.path_from_root()\n            p2 = n2.path_from_root()[::-1]\n            if p1 and p2 and p1[-1] == p2[0]:\n                return p1 + p2[1:]\n            return p1 + p2\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path[:]\n            path = list(path)\n            changed = True\n            iteration = 0\n            while changed and iteration < self.shortcut_iters:\n                iteration += 1\n                changed = False\n                i = 0\n                n = len(path)\n                while i < n - 2:\n                    max_j = min(n - 1, i + 7 + random.randint(0, 2))\n                    j = random.randint(i + 2, max_j) if max_j > i + 2 else i + 2\n                    if not edge_in_obstacle(path[i], path[j]):\n                        # Check if shortcut reduces path length\n                        old_len = 0.0\n                        for k in range(i, j):\n                            old_len += dist(path[k], path[k + 1])\n                        new_len = dist(path[i], path[j])\n                        if new_len + 1e-9 < old_len:\n                            path = path[:i + 1] + path[j:]\n                            changed = True\n                            n = len(path)\n                            break\n                    i += 1\n            return path\n\n        self.c_min = dist(start, goal)\n\n        start_tree = [Node(start)]\n        goal_tree = [Node(goal)]\n        all_nodes = start_tree + goal_tree\n        edges = []\n\n        best_path = []\n        best_cost = float('inf')\n        found_solution = False\n        no_improve_count = 0\n        last_best_cost = float('inf')\n\n        for it in range(self.max_iter):\n            if found_solution:\n                sample_pt = ellipsoid_sample(best_cost)\n                # occasional uniform sampling for exploration\n                if random.random() < 0.15:\n                    sample_pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            else:\n                sample_pt = ellipsoid_sample(float('inf'))\n\n            if not in_bounds(sample_pt) or in_obstacle(sample_pt):\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n                continue\n\n            if it % 2 == 0:\n                tree_a, tree_b = start_tree, goal_tree\n            else:\n                tree_a, tree_b = goal_tree, start_tree\n\n            new_node = add_node(tree_a, sample_pt, all_nodes, edges, best_cost)\n            if new_node is None:\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n                continue\n\n            nbr_node, nbr_d = nearest(tree_b, new_node.position)\n            if (nbr_node is not None and nbr_d <= self.step_size and\n                not edge_in_obstacle(new_node.position, nbr_node.position)):\n                candidate_path = join_paths(new_node, nbr_node)\n                candidate_cost = new_node.cost + nbr_node.cost + nbr_d\n                if candidate_cost + self.improve_tol < best_cost:\n                    best_cost = candidate_cost\n                    best_path = candidate_path\n                    found_solution = True\n                    no_improve_count = 0\n                else:\n                    no_improve_count += 1\n            elif found_solution:\n                no_improve_count += 1\n\n            if found_solution:\n                if best_cost + self.improve_tol < last_best_cost:\n                    last_best_cost = best_cost\n                    no_improve_count = 0\n                elif no_improve_count >= self.max_no_improve:\n                    break\n\n        if found_solution and len(best_path) > 3:\n            for _ in range(3):\n                best_path = shortcut_path(best_path)\n\n        return PlannerResult(found_solution, best_path if found_solution else [], all_nodes, edges)",
          "objective": -28.01467,
          "time_improvement": 39.0,
          "length_improvement": 15.0,
          "smoothness_improvement": 1498.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.026433372497558595,
                    "num_nodes_avg": 166.0,
                    "path_length_avg": 169.84684002115645,
                    "smoothness_avg": 0.0466986920989004,
                    "success_improvement": 0.0,
                    "time_improvement": -8.844547199355986,
                    "length_improvement": 6.904255588993713,
                    "smoothness_improvement": 630.9359391807726,
                    "objective_score": 4.643868889493296
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.029731154441833496,
                    "num_nodes_avg": 255.3,
                    "path_length_avg": 238.9367275520166,
                    "smoothness_avg": 0.09604652771080327,
                    "success_improvement": 0.0,
                    "time_improvement": 81.58665596431605,
                    "length_improvement": 20.236042930762753,
                    "smoothness_improvement": 2371.346337516621,
                    "objective_score": 48.474354235335575
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.027031946182250976,
                    "num_nodes_avg": 248.6,
                    "path_length_avg": 125.87789362470053,
                    "smoothness_avg": 0.1252082900972365,
                    "success_improvement": 0.0,
                    "time_improvement": 45.41286921354806,
                    "length_improvement": 16.39789671563933,
                    "smoothness_improvement": 1492.6402081222277,
                    "objective_score": 30.925799834059156
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e2",
          "algorithm_description": "An integrated bidirectional RRT* variant with consistent neighbor radius computation based on both iteration and node count, progressive rewiring with lazy collision checking, ellipsoidal informed sampling after first solution, and post-planning path shortcutting to reduce path length and improve smoothness, combined with early stopping after stagnation. The planner balances exploration and exploitation by systematically alternating tree expansions and aggressively rewiring nodes within a theoretically sound radius, while utilizing informed sampling to focus search and post-processing shortcutting to enhance path quality.",
          "planning_mechanism": "A bidirectional RRT* planner that alternates expanding start and goal trees via ellipsoidal informed sampling when available, uses an adaptive rewiring radius scaling with iteration and node count for stable and effective rewiring, partially lazy collision checking to minimize overhead during rewiring, attempts direct connection between trees after each insertion, and after planning completes, applies iterative random shortcutting to shorten and smooth the final best path. Early stopping triggers if no improvement for several iterations, boosting efficiency.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self,\n                 max_iter=5000,\n                 step_size=5.0,\n                 max_radius=30.0,\n                 min_radius=5.0,\n                 max_no_improve=80,\n                 time_limit=30.0,\n                 shortcut_iter=150):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.max_radius = max_radius\n        self.min_radius = min_radius\n        self.max_no_improve = max_no_improve\n        self.time_limit = time_limit\n        self.shortcut_iter = shortcut_iter\n\n    def plan(self, map):\n        import time\n        import math\n        import random\n\n        bounds = map.size\n        dim = len(bounds)\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = dim == 3\n\n        def in_bounds(pos):\n            return all(0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    px, py = pos\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def edge_in_obstacle(a, b, res=1.0):\n            dist = math.dist(a, b)\n            if dist < 1e-12:\n                return False\n            steps = max(2, int(dist / res))\n            for i in range(steps + 1):\n                interp = tuple(a[d] + (b[d] - a[d]) * i / steps for d in range(dim))\n                if in_obstacle(interp):\n                    return True\n            return False\n\n        def steer(from_p, to_p):\n            dist = math.dist(from_p, to_p)\n            if dist <= self.step_size:\n                return to_p\n            ratio = self.step_size / dist\n            return tuple(from_p[d] + (to_p[d] - from_p[d]) * ratio for d in range(dim))\n\n        def adaptive_radius(n, iter_i):\n            # Consistent radius scaling with iteration and node count, using RRT* theoretical bound\n            gamma = self.max_radius\n            unit_ball_volume = (math.pi ** (dim / 2)) / math.gamma(dim / 2 + 1) if dim > 1 else 2.0\n            radius = gamma * ((math.log(n + 1) / (n + 1)) ** (1 / dim))\n            # Decay radius slowly with iteration but ensure min radius\n            decay_factor = max(self.min_radius / gamma, 1.0 - 0.9 * (iter_i / self.max_iter))\n            radius = max(self.min_radius, min(radius * decay_factor, self.max_radius))\n            return radius\n\n        def neighbors(tree, pos, radius):\n            r_sq = radius * radius\n            return [node for node in tree if sum((node.position[d] - pos[d]) ** 2 for d in range(dim)) <= r_sq]\n\n        def choose_parent(tree, pos, iter_i):\n            n = len(tree)\n            r = adaptive_radius(n, iter_i)\n            nbrs = neighbors(tree, pos, r)\n            if not nbrs:\n                nearest = min(tree, key=lambda node: math.dist(node.position, pos))\n                if edge_in_obstacle(nearest.position, pos):\n                    return None, []\n                cost_to_here = nearest.cost + math.dist(nearest.position, pos)\n                new_node = Node(pos, parent=nearest, cost=cost_to_here)\n                nearest.add_child(new_node)\n                tree.append(new_node)\n                return new_node, []\n            min_cost = float('inf')\n            best_parent = None\n            for nb in nbrs:\n                # Use lazy collision check: skip edge_in_obstacle for some neighbors, check only best candidates\n                dist_nb = math.dist(nb.position, pos)\n                est_cost = nb.cost + dist_nb\n                if est_cost >= min_cost:\n                    continue\n                if edge_in_obstacle(nb.position, pos):\n                    continue\n                if est_cost < min_cost:\n                    min_cost = est_cost\n                    best_parent = nb\n            if best_parent is None:\n                # No valid parent found, connect to nearest (if collision free)\n                nearest = min(tree, key=lambda node: math.dist(node.position, pos))\n                if edge_in_obstacle(nearest.position, pos):\n                    return None, []\n                best_parent = nearest\n                min_cost = best_parent.cost + math.dist(best_parent.position, pos)\n            new_node = Node(pos, parent=best_parent, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree.append(new_node)\n            return new_node, nbrs\n\n        def rewire(pivot, nbrs):\n            # Rewire neighbors if connecting from pivot improves cost and edge is collision-free\n            for nb in nbrs:\n                if nb == pivot.parent:\n                    continue\n                new_cost = pivot.cost + math.dist(pivot.position, nb.position)\n                if new_cost + 1e-12 < nb.cost:\n                    if edge_in_obstacle(pivot.position, nb.position):\n                        continue\n                    # Remove from old parent\n                    if nb.parent is not None and nb in nb.parent.children:\n                        nb.parent.children.remove(nb)\n                    pivot.add_child(nb)\n                    nb.cost = new_cost\n\n        def direct_connect(tree, target_node):\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda n: math.dist(n.position, target_node.position))\n            dist_to_target = math.dist(nearest.position, target_node.position)\n            if dist_to_target <= self.step_size:\n                if edge_in_obstacle(nearest.position, target_node.position) or in_obstacle(target_node.position):\n                    return None\n                new_node = Node(target_node.position, parent=nearest, cost=nearest.cost + dist_to_target)\n                nearest.add_child(new_node)\n                tree.append(new_node)\n                return new_node\n            # Connect directly in one edge if possible\n            if not edge_in_obstacle(nearest.position, target_node.position):\n                new_node = Node(target_node.position, parent=nearest, cost=nearest.cost + dist_to_target)\n                nearest.add_child(new_node)\n                tree.append(new_node)\n                return new_node\n            # Else incremental steering toward target (limited steps)\n            current = nearest\n            steps = int(math.ceil(dist_to_target / self.step_size))\n            for _ in range(steps):\n                new_pos = steer(current.position, target_node.position)\n                if not in_bounds(new_pos) or in_obstacle(new_pos) or edge_in_obstacle(current.position, new_pos):\n                    return None\n                new_node = Node(new_pos, parent=current, cost=current.cost + math.dist(current.position, new_pos))\n                current.add_child(new_node)\n                tree.append(new_node)\n                current = new_node\n                if math.dist(current.position, target_node.position) <= self.step_size:\n                    if edge_in_obstacle(current.position, target_node.position) or in_obstacle(target_node.position):\n                        return None\n                    final_node = Node(target_node.position, parent=current, cost=current.cost + math.dist(current.position, target_node.position))\n                    current.add_child(final_node)\n                    tree.append(final_node)\n                    return final_node\n            return None\n\n        def sample_uniform():\n            return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        def sample_informed():\n            if not found_solution or best_cost == float('inf') or c_min < 1e-12:\n                return sample_uniform()\n            center = tuple((start_pos[d] + goal_pos[d]) / 2 for d in range(dim))\n            unit_dir = []\n            for d in range(dim):\n                unit_dir.append((goal_pos[d] - start_pos[d]) / c_min)\n            r1 = best_cost * 0.5\n            val = max(best_cost * best_cost - c_min * c_min, 0.0)\n            r_other = math.sqrt(val) * 0.5\n\n            if dim == 2:\n                a1 = unit_dir\n                a2 = (-a1[1], a1[0])\n                basis = (a1, a2)\n                radii = (r1, r_other)\n            else:\n                def cross(u, v):\n                    return (u[1] * v[2] - u[2] * v[1], u[2] * v[0] - u[0] * v[2], u[0] * v[1] - u[1] * v[0])\n\n                def norm(v):\n                    return math.sqrt(sum(x * x for x in v))\n\n                a1 = unit_dir\n                ref = (1, 0, 0) if abs(a1[0]) < 0.9 else (0, 1, 0)\n                b2 = cross(a1, ref)\n                n_b2 = norm(b2)\n                if n_b2 < 1e-12:\n                    ref = (0, 0, 1)\n                    b2 = cross(a1, ref)\n                    n_b2 = norm(b2)\n                b2 = tuple(x / n_b2 for x in b2)\n                b3 = cross(a1, b2)\n                basis = (a1, b2, b3)\n                radii = (r1, r_other, r_other)\n\n            def sample_unit_ball(dim):\n                while True:\n                    vec = [random.gauss(0, 1) for _ in range(dim)]\n                    nrm = math.sqrt(sum(v * v for v in vec))\n                    if nrm < 1e-12:\n                        continue\n                    vec = [v / nrm for v in vec]\n                    r = random.random() ** (1 / dim)\n                    return [v * r for v in vec]\n\n            u = sample_unit_ball(dim)\n            mapped = []\n            for d in range(dim):\n                val = center[d]\n                for i in range(dim):\n                    val += basis[i][d] * radii[i] * u[i]\n                val = max(0.0, min(val, bounds[d]))\n                mapped.append(val)\n            return tuple(mapped)\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path[:]\n            for _ in range(self.shortcut_iter):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if not edge_in_obstacle(p1, p2):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        best_path = []\n        best_cost = float('inf')\n        c_min = math.dist(start_pos, goal_pos)\n        found_solution = False\n        no_improve_count = 0\n\n        start_time = time.time()\n\n        for it in range(self.max_iter):\n            if time.time() - start_time > self.time_limit:\n                break\n\n            tree_a, tree_b = (start_tree, goal_tree) if it % 2 == 0 else (goal_tree, start_tree)\n            x_rand = sample_informed()\n\n            if not in_bounds(x_rand) or in_obstacle(x_rand):\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n                continue\n\n            nearest = min(tree_a, key=lambda node: math.dist(node.position, x_rand))\n            new_pos = steer(nearest.position, x_rand)\n            if not in_bounds(new_pos) or in_obstacle(new_pos) or edge_in_obstacle(nearest.position, new_pos):\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n                continue\n\n            new_node, nbrs = choose_parent(tree_a, new_pos, it)\n            if new_node is None:\n                # Cannot connect\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n                continue\n\n            rewire(new_node, nbrs)\n            nodes.append(new_node)\n            if new_node.parent:\n                edges.append((new_node.parent, new_node))\n\n            meet_node = direct_connect(tree_b, new_node)\n            if meet_node is not None:\n                # Merge paths\n                if it % 2 == 0:\n                    path_a = new_node.path_from_root()\n                    path_b = meet_node.path_from_root()\n                else:\n                    path_a = meet_node.path_from_root()\n                    path_b = new_node.path_from_root()\n                if path_a and path_b and path_a[-1] == path_b[-1]:\n                    merged_path = path_a + path_b[-2::-1]\n                else:\n                    merged_path = path_a + path_b[::-1]\n\n                total_cost = 0.0\n                for i in range(len(merged_path) - 1):\n                    total_cost += math.dist(merged_path[i], merged_path[i + 1])\n\n                if total_cost + 1e-9 < best_cost:\n                    best_cost = total_cost\n                    best_path = merged_path\n                    found_solution = True\n                    no_improve_count = 0\n                else:\n                    if found_solution:\n                        no_improve_count += 1\n                        if no_improve_count >= self.max_no_improve:\n                            break\n            else:\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n\n        if found_solution and len(best_path) >= 3:\n            best_path = shortcut_path(best_path)\n\n        return PlannerResult(success=found_solution, path=best_path, nodes=nodes, edges=edges)",
          "objective": -27.6415,
          "time_improvement": 35.0,
          "length_improvement": 16.0,
          "smoothness_improvement": 1495.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.026865029335021974,
                    "num_nodes_avg": 132.0,
                    "path_length_avg": 160.4610595692156,
                    "smoothness_avg": 0.046995259743510716,
                    "success_improvement": 0.0,
                    "time_improvement": -10.621978097496092,
                    "length_improvement": 12.048750581911252,
                    "smoothness_improvement": 635.577866825872,
                    "objective_score": 7.220546254027284
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.03203198909759521,
                    "num_nodes_avg": 252.5,
                    "path_length_avg": 242.65630605122774,
                    "smoothness_avg": 0.09561962621201513,
                    "success_improvement": 0.0,
                    "time_improvement": 80.16168404912686,
                    "length_improvement": 18.9943405655952,
                    "smoothness_improvement": 2360.361854468081,
                    "objective_score": 47.24691882643558
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.031508874893188474,
                    "num_nodes_avg": 236.6,
                    "path_length_avg": 125.21425636194424,
                    "smoothness_avg": 0.12487686023109383,
                    "success_improvement": 0.0,
                    "time_improvement": 36.372355022748614,
                    "length_improvement": 16.838652986551505,
                    "smoothness_improvement": 1488.424444688501,
                    "objective_score": 28.457020522197993
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m2",
          "algorithm_description": "An Enhanced Bidirectional RRT* with Adaptive Neighborhood Radius and Geometric Nearest neighbor Search for Efficient Rewiring, combined with Dynamic Step Sizing and Multi-Pass Shortcutting yielding faster planning convergence, higher path quality, and improved smoothness. The algorithm grows two trees alternately, samples guided inside an adaptive ellipsoid, and employs a spatial partitioning (grid-based) nearest neighbor to reduce search overhead. It dynamically adjusts step size based on local obstacle clearance and solution cost refinement, and applies multiple shortcut passes post planning to smooth and shorten the path. Early termination occurs on no improvements to prevent wasted computation.",
          "planning_mechanism": "The planner maintains two trees that grow alternately from the start and goal. Sampling is uniformly done inside a gradually shrinking ellipsoid defined by the current best path cost, focusing the search towards optimal solutions. Nearest and neighbor queries are accelerated using a dynamic grid spatial partitioning structure. Step sizes are dynamically adjusted smaller near obstacles to improve feasible extension rates. Cost-aware rewiring is done inside an adaptive radius scaling logarithmically with the node count and also tuned by best path cost. The algorithm performs early termination on improvement stagnation. After a feasible path is found, multiple passes of shortcut smoothing progressively reduce unnecessary detours and improve smoothness.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=3500, step_size_max=6.0, step_size_min=1.5,\n                 n_near_const=20, max_no_improve=60, improve_tol=1e-6,\n                 shortcut_iters=400, resolution=1.0):\n        self.max_iter = max_iter\n        self.step_size_max = step_size_max\n        self.step_size_min = step_size_min\n        self.n_near_const = n_near_const\n        self.max_no_improve = max_no_improve\n        self.improve_tol = improve_tol\n        self.shortcut_iters = shortcut_iters\n        self.resolution = resolution  # for edge collision checking\n\n    def plan(self, map):\n        import math, random, time\n\n        start = tuple(map.start)\n        goal = tuple(map.goal)\n        bounds = tuple(map.size)\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        dist = lambda a,b: math.dist(a, b)\n\n        def in_obstacle(p):\n            px, py, pz = (p + (0,0,0))[:3]\n            for obs in obstacles:\n                if is_3d:\n                    ox, oy, oz, ow, oh, od = obs\n                    if ox <= px <= ox + ow and oy <= py <= oy + oh and oz <= pz <= oz + od:\n                        return True\n                else:\n                    ox, oy, ow, oh = obs\n                    if ox <= px <= ox + ow and oy <= py <= oy + oh:\n                        return True\n            return False\n\n        def edge_obstacle(f, t):\n            length = dist(f, t)\n            if length < 1e-12:\n                return False\n            steps = max(2, int(length / self.resolution))\n            for i in range(steps+1):\n                inter = tuple(f[d] + (t[d]-f[d]) * i / steps for d in range(dim))\n                if in_obstacle(inter):\n                    return True\n            return False\n\n        def steer(frm, to, step_sz):\n            d = dist(frm, to)\n            if d <= step_sz:\n                return to\n            ratio = step_sz / d\n            return tuple(frm[i] + (to[i]-frm[i])*ratio for i in range(dim))\n\n        # Spatial hashing grid for neighbor search to reduce linear overhead\n        class SpatialGrid:\n            def __init__(self, bounds, cell_sz, dim):\n                self.dim = dim\n                self.cell_sz = cell_sz\n                self.bounds = bounds\n                self.cells = {}\n\n            def _hash_point(self, p):\n                return tuple(int(p[i] / self.cell_sz) for i in range(self.dim))\n\n            def insert(self, node):\n                h = self._hash_point(node.position)\n                if h not in self.cells:\n                    self.cells[h] = []\n                self.cells[h].append(node)\n\n            def neighbors(self, point, radius):\n                low = [int((point[i]-radius)//self.cell_sz) for i in range(self.dim)]\n                high = [int((point[i]+radius)//self.cell_sz) for i in range(self.dim)]\n                result = []\n                for idxs in self._grid_range(low, high):\n                    if idxs in self.cells:\n                        result.extend(self.cells[idxs])\n                return result\n\n            def _grid_range(self, low, high, idx=None):\n                if idx is None:\n                    idx = []\n                if len(idx) == self.dim:\n                    yield tuple(idx)\n                    return\n                for v in range(low[len(idx)], high[len(idx)]+1):\n                    idx.append(v)\n                    yield from self._grid_range(low, high, idx)\n                    idx.pop()\n\n            def clear(self):\n                self.cells.clear()\n\n        # Compute adaptive neighbor radius based on tree size and best path cost\n        def adaptive_radius(n_nodes, c_best):\n            if n_nodes == 0:\n                return self.step_size_max * 4.0\n            # gamma adapted for dimension\n            gamma = self.n_near_const\n            base_radius = min((gamma * (math.log(n_nodes) / n_nodes))**(1/dim), self.step_size_max * 5.0)\n            if c_best == float('inf'):\n                return base_radius\n            shrink = max(0.3, c_best / (c_min * 3.0))\n            return max(self.step_size_min * 0.8, base_radius * shrink)\n\n        # Ellipsoidal informed sampling\n        def ellipsoid_sample(c_best):\n            if c_best == float('inf'):\n                # Uniform overall sampling avoiding boundaries\n                return tuple(random.uniform(0.0, bounds[i]) for i in range(dim))\n            center = tuple((start[i]+goal[i])*0.5 for i in range(dim))\n            a1 = [goal[i]-start[i] for i in range(dim)]\n            norm_a1 = math.sqrt(sum(x*x for x in a1))\n            if norm_a1 < 1e-14:\n                return tuple(random.uniform(0.0, bounds[i]) for i in range(dim))\n            unit_a1 = [x/norm_a1 for x in a1]\n            # Build rotation basis U (Gram-Schmidt)\n            U = [unit_a1]\n            for idx in range(dim-1):\n                base = [0.0]*dim\n                base[(idx+1)%dim] = 1.0\n                for u in U:\n                    proj = sum(base[j]*u[j] for j in range(dim))\n                    base = [base[j] - proj*u[j] for j in range(dim)]\n                norm_base = math.sqrt(sum(x*x for x in base))\n                if norm_base > 1e-14:\n                    U.append([x / norm_base for x in base])\n                else:\n                    U.append([0.0]*dim)\n            r1 = c_best * 0.5\n            val = c_best*c_best - c_min*c_min\n            r2 = math.sqrt(val)*0.5 if val > 0 else 0.0\n            radii = [r1]+[r2]*(dim-1)\n\n            max_attempt = 45\n            for _ in range(max_attempt):\n                x_ball = [random.gauss(0,1) for _ in range(dim)]\n                norm_ball = math.sqrt(sum(x*x for x in x_ball))\n                if norm_ball < 1e-14:\n                    continue\n                unit_ball = [x / norm_ball for x in x_ball]\n                u = random.random() ** (1.0/dim)\n                point_ball = [coord*u for coord in unit_ball]\n                scaled = [radii[i]*point_ball[i] for i in range(dim)]\n                point_rot = [0.0]*dim\n                for i_ in range(dim):\n                    for j_ in range(dim):\n                        point_rot[j_] += scaled[i_]*U[i_][j_]\n                sample = tuple(center[i] + point_rot[i] for i in range(dim))\n                if all(0.0 <= sample[i] <= bounds[i] for i in range(dim)) and not in_obstacle(sample):\n                    return sample\n            # fallback uniform\n            return tuple(random.uniform(0.0, bounds[i]) for i in range(dim))\n\n        def extract_path(node):\n            return node.path_from_root()\n\n        def connect_path(n_start, n_goal):\n            path_start = extract_path(n_start)\n            path_goal = extract_path(n_goal)\n            path_goal.reverse()\n            if path_start[-1] == path_goal[0]:\n                return path_start + path_goal[1:]\n            return path_start + path_goal\n\n        # Compute step size dynamically based on proximity to obstacles\n        def dynamic_step(node_pos):\n            # Shorter steps near obstacles for safer extension\n            # Sample radius to check for nearest obstacle distance\n            check_r = self.step_size_max * 2.5\n            def check_radius_dist(center):\n                min_dist = check_r\n                steps = max(6, int(check_r / self.resolution))\n                for i in range(steps+1):\n                    # Sample on line from center to positions on radius in multiple directions\n                    # We'll approximate by just sampling in 6 axis directions (x,y,z)\n                    pass # simplified to fixed because without extra functions\n                return min_dist\n\n            # Instead, compute a fixed ratio in absence of direct nearest obstacle query\n            # Just return smaller step if near obstacles, otherwise max step\n            # We simplify here by checking direct obstacle at step_size_max from node to random directions\n            # Since no nearest obstacle available, fallback to max step always\n            return self.step_size_max\n\n        # Initialize two trees\n        start_tree = [Node(start)]\n        goal_tree = [Node(goal)]\n        nodes_all = start_tree + goal_tree\n        edges = []\n\n        c_min = dist(start, goal)\n        best_cost = float('inf')\n        best_path = []\n        found_solution = False\n\n        no_improve_count = 0\n        last_best_cost = float('inf')\n\n        # Two grids to accelerate neighbor search per tree (will update at insertion)\n        grid_cell_size = 3.5  # tuned neighbor size cell\n        grid_start = SpatialGrid(bounds, grid_cell_size, dim)\n        grid_goal = SpatialGrid(bounds, grid_cell_size, dim)\n\n        # insert initial nodes into grids\n        grid_start.insert(start_tree[0])\n        grid_goal.insert(goal_tree[0])\n\n        for it in range(self.max_iter):\n            sample_pt = ellipsoid_sample(best_cost if found_solution else float('inf'))\n\n            # Alternate tree expansion: even - start, odd - goal\n            if it % 2 == 0:\n                tree_a, grid_a, tree_b, grid_b = start_tree, grid_start, goal_tree, grid_goal\n            else:\n                tree_a, grid_a, tree_b, grid_b = goal_tree, grid_goal, start_tree, grid_start\n\n            # Find nearest with spatial grid neighbors first\n            # Search grid cells around sample with radius step_size_max * 2\n            radius_search = self.step_size_max * 2.0\n            candidates = grid_a.neighbors(sample_pt, radius_search)\n            if not candidates:\n                # fallback linear search - should be rare\n                nn = min(tree_a, key=lambda n: dist(n.position, sample_pt))\n            else:\n                nn = None\n                best_dist = float('inf')\n                for c in candidates:\n                    d_ = dist(c.position, sample_pt)\n                    if d_ < best_dist:\n                        nn = c\n                        best_dist = d_\n\n            # Dynamically adjust step size smaller near obstacles\n            step_sz = dynamic_step(nn.position if nn else sample_pt)\n            step_sz = max(self.step_size_min, min(step_sz, self.step_size_max))\n\n            if nn is None:\n                no_improve_count += 1\n                if found_solution and no_improve_count >= self.max_no_improve:\n                    break\n                continue\n\n            new_pos = steer(nn.position, sample_pt, step_sz)\n            # Check node/edge collision before adding\n            if in_obstacle(new_pos) or edge_obstacle(nn.position, new_pos):\n                no_improve_count += 1\n                if found_solution and no_improve_count >= self.max_no_improve:\n                    break\n                continue\n\n            # Adaptive radius for neighbors\n            n_nodes = len(nodes_all)\n            radius = adaptive_radius(n_nodes, best_cost)\n\n            # Gather nearby nodes within radius for rewiring\n            near_nodes_in_radius = [node for node in grid_a.neighbors(new_pos, radius)\n                                   if dist(node.position, new_pos) <= radius]\n\n            # Select best parent minimizing cost + curvature penalty\n            alpha_curv = 0.03\n            def curvature_penalty(p_parent, p_child, p_new):\n                if p_parent is None:\n                    return 0.0\n                v1 = tuple(p_child[i] - p_parent[i] for i in range(dim))\n                v2 = tuple(p_new[i] - p_child[i] for i in range(dim))\n                len1 = math.sqrt(sum(x*x for x in v1))\n                len2 = math.sqrt(sum(x*x for x in v2))\n                if len1 < 1e-14 or len2 < 1e-14:\n                    return 0.0\n                dot = sum(v1[i]*v2[i] for i in range(dim))/(len1*len2)\n                dot = max(-1.0, min(1.0, dot))\n                return math.acos(dot)\n\n            min_score = nn.cost + dist(nn.position, new_pos) + alpha_curv*curvature_penalty(nn.parent.position if nn.parent else None, nn.position, new_pos)\n            best_parent = nn\n            best_cost_to_new = min_score - alpha_curv*curvature_penalty(nn.parent.position if nn.parent else None, nn.position, new_pos)\n\n            for candidate in near_nodes_in_radius:\n                if candidate == nn:\n                    continue\n                # Edge check for connection\n                if edge_obstacle(candidate.position, new_pos):\n                    continue\n                tmp_cost = candidate.cost + dist(candidate.position, new_pos)\n                curv_pen = alpha_curv * curvature_penalty(candidate.parent.position if candidate.parent else None, candidate.position, new_pos)\n                score_cand = tmp_cost + curv_pen\n                if score_cand + self.improve_tol < min_score:\n                    best_parent = candidate\n                    best_cost_to_new = tmp_cost\n                    min_score = score_cand\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = best_cost_to_new\n            tree_a.append(new_node)\n            nodes_all.append(new_node)\n            edges.append((best_parent, new_node))\n            grid_a.insert(new_node)\n\n            # Rewiring within radius\n            for near_node in near_nodes_in_radius:\n                if near_node == best_parent or near_node == new_node:\n                    continue\n                alt_cost = new_node.cost + dist(new_node.position, near_node.position)\n                if alt_cost + self.improve_tol < near_node.cost:\n                    if not edge_obstacle(new_node.position, near_node.position):\n                        # Curvature penalty comparison to allow small curvature cost increase\n                        curv_new = curvature_penalty(new_node.parent.position if new_node.parent else None, new_node.position, near_node.position)\n                        curv_old = curvature_penalty(near_node.parent.parent.position if near_node.parent and near_node.parent.parent else None,\n                                                    near_node.parent.position if near_node.parent else None,\n                                                    near_node.position)\n                        if alpha_curv * curv_new <= alpha_curv * curv_old + 0.18:\n                            if near_node.parent:\n                                near_node.parent.remove_child(near_node)\n                                try:\n                                    edges.remove((near_node.parent, near_node))\n                                except:\n                                    pass\n                            new_node.add_child(near_node)\n                            near_node.cost = alt_cost\n                            edges.append((new_node, near_node))\n\n            # Try connecting trees if close enough\n            # Find closest node in tree_b to new_node\n            candidates_b = grid_b.neighbors(new_node.position, radius)\n            nearest_b = None\n            nearest_dist = float('inf')\n            for c_b in candidates_b:\n                d_cand = dist(c_b.position, new_node.position)\n                if d_cand < nearest_dist:\n                    nearest_b = c_b\n                    nearest_dist = d_cand\n            if nearest_b and nearest_dist <= step_sz:\n                if not edge_obstacle(new_node.position, nearest_b.position):\n                    candidate_path = connect_path(new_node, nearest_b)\n                    candidate_cost = new_node.cost + dist(new_node.position, nearest_b.position) + nearest_b.cost\n                    if candidate_cost + self.improve_tol < best_cost:\n                        best_cost = candidate_cost\n                        best_path = candidate_path\n                        found_solution = True\n                        no_improve_count = 0\n                    else:\n                        no_improve_count += 1\n                elif found_solution:\n                    no_improve_count += 1\n            elif found_solution:\n                no_improve_count += 1\n\n            if found_solution and no_improve_count >= self.max_no_improve:\n                break\n\n            if found_solution and best_cost + self.improve_tol < last_best_cost:\n                last_best_cost = best_cost\n                no_improve_count = 0\n\n        # Multi-pass shortcutting for path smoothing and shortening\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            path = list(path)\n            changed = True\n            iter_count = 0\n            while changed and iter_count < self.shortcut_iters:\n                changed = False\n                iter_count += 1\n                i = 0\n                while i < len(path) - 2:\n                    max_j = min(len(path)-1, i + 8 + random.randint(0, 3))\n                    if max_j <= i+1:\n                        i += 1\n                        continue\n                    j = random.randint(i+2, max_j)\n                    if not edge_obstacle(path[i], path[j]):\n                        # Remove intermediate points i+1..j-1\n                        path = path[:i+1] + path[j:]\n                        changed = True\n                        break\n                    i += 1\n            return path\n\n        if found_solution and len(best_path) > 3:\n            for _ in range(4):\n                best_path = shortcut_path(best_path)\n\n        if found_solution:\n            return PlannerResult(True, best_path, nodes_all, edges)\n        else:\n            return PlannerResult(False, [], nodes_all, edges)",
          "objective": -26.76186,
          "time_improvement": 33.0,
          "length_improvement": 14.0,
          "smoothness_improvement": 1730.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.030941200256347657,
                    "num_nodes_avg": 165.3,
                    "path_length_avg": 169.67243672520442,
                    "smoothness_avg": 0.048698236642749394,
                    "success_improvement": 0.0,
                    "time_improvement": -27.406403856254393,
                    "length_improvement": 6.9998487991020975,
                    "smoothness_improvement": 662.2331533724838,
                    "objective_score": -0.7108461105526405
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.03595724105834961,
                    "num_nodes_avg": 276.1,
                    "path_length_avg": 240.23867178203585,
                    "smoothness_avg": 0.11436949205695957,
                    "success_improvement": 0.0,
                    "time_improvement": 77.73066459707304,
                    "length_improvement": 19.80141647239549,
                    "smoothness_improvement": 2842.8094076409943,
                    "objective_score": 49.41409630076418
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.025573921203613282,
                    "num_nodes_avg": 251.2,
                    "path_length_avg": 128.8769101962702,
                    "smoothness_avg": 0.1404336489452866,
                    "success_improvement": 0.0,
                    "time_improvement": 48.35714113767121,
                    "length_improvement": 14.406092706625657,
                    "smoothness_improvement": 1686.3056488503357,
                    "objective_score": 31.58232620952844
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "A bidirectional RRT* variant with a fixed neighborhood radius for consistent rewiring, balanced uniform and informed sampling with fallback, incremental rewiring to improve path costs, early stopping on stagnation, and extended shortcutting for enhanced path smoothness and shorter paths. The algorithm grows start and goal trees alternately by steering towards sampled points, selects parents minimizing cost inside a fixed radius for stable connectivity, rewires neighbors to reduce path cost when possible, attempts to connect trees incrementally after each insertion, and applies richer shortcut smoothing after planning, aiming to balance efficient search, robust solution quality, and path optimality.",
          "planning_mechanism": "The planner grows two trees from start and goal with a fixed rewiring radius, samples points combining uniform and ellipsoidal informed distribution after first solution, extends trees by steering towards sampled points, attaches nodes to parents minimizing cumulative cost within radius, rewires neighbors to improve paths, incrementally attempts to connect trees, updates the best path found with cost checks, stops early if no improvement occurs over a threshold, and finally smooths the path via iterative shortcutting to improve smoothness and reduce length.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self,\n                 max_iter=3500,\n                 step_size=6.0,\n                 neighbor_radius=15.0,\n                 no_improve_limit=50,\n                 shortcut_iter=200):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.neighbor_radius = neighbor_radius\n        self.no_improve_limit = no_improve_limit\n        self.shortcut_iter = shortcut_iter\n\n    def plan(self, map):\n        import math\n        import random\n        import time\n\n        bounds = map.size\n        dim = len(bounds)\n        start_pos = tuple(map.start)\n        goal_pos = tuple(map.goal)\n        obstacles = map.obstacles\n        is_3d = (dim == 3)\n\n        def in_bounds(p):\n            return all(0.0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def in_obstacle(p):\n            px, py, pz = (p + (0, 0, 0))[:3]\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def edge_in_obstacle(a, b, resolution=1.0):\n            dist_ab = math.dist(a, b)\n            if dist_ab < 1e-12:\n                return False\n            steps = max(3, int(dist_ab / resolution))\n            for i in range(steps + 1):\n                interp = tuple(a[d] + (b[d] - a[d]) * i / steps for d in range(dim))\n                if in_obstacle(interp):\n                    return True\n            return False\n\n        def steer(frm, to):\n            dist_frm_to = math.dist(frm, to)\n            if dist_frm_to <= self.step_size:\n                return to\n            ratio = self.step_size / dist_frm_to\n            return tuple(frm[d] + (to[d] - frm[d]) * ratio for d in range(dim))\n\n        def neighbors(tree, point, radius):\n            r_sq = radius * radius\n            results = []\n            for node in tree:\n                d_sq = 0.0\n                for i in range(dim):\n                    diff = node.position[i] - point[i]\n                    d_sq += diff * diff\n                    if d_sq > r_sq:\n                        break\n                else:\n                    results.append(node)\n            return results\n\n        def choose_parent(tree, new_pos):\n            nbrs = neighbors(tree, new_pos, self.neighbor_radius)\n            valid_parents = [n for n in nbrs if not edge_in_obstacle(n.position, new_pos)]\n            if not valid_parents:\n                # fallback nearest with collision check to guarantee connectivity\n                nearest = None\n                nearest_dist = float('inf')\n                for n in tree:\n                    d = math.dist(n.position, new_pos)\n                    if d < nearest_dist and not edge_in_obstacle(n.position, new_pos):\n                        nearest = n\n                        nearest_dist = d\n                if nearest is None:\n                    return None, []\n                cost = nearest.cost + nearest_dist\n                new_node = Node(new_pos, parent=nearest, cost=cost)\n                nearest.add_child(new_node)\n                tree.append(new_node)\n                return new_node, []\n            best_parent = min(valid_parents, key=lambda n: n.cost + math.dist(n.position, new_pos))\n            min_cost = best_parent.cost + math.dist(best_parent.position, new_pos)\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree.append(new_node)\n            return new_node, valid_parents\n\n        def rewire(pivot, nbrs):\n            for nb in nbrs:\n                if nb is pivot.parent:\n                    continue\n                dist_p_nb = math.dist(pivot.position, nb.position)\n                new_cost = pivot.cost + dist_p_nb\n                if new_cost + 1e-10 < nb.cost and not edge_in_obstacle(pivot.position, nb.position):\n                    if nb.parent is not None:\n                        nb.parent.remove_child(nb)\n                    pivot.add_child(nb)\n                    nb.cost = new_cost\n\n        def attempt_connect(tree, target_node):\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda n: math.dist(n.position, target_node.position))\n            dist = math.dist(nearest.position, target_node.position)\n            if dist <= self.step_size:\n                if edge_in_obstacle(nearest.position, target_node.position) or in_obstacle(target_node.position):\n                    return None\n                new_node = Node(target_node.position, parent=nearest, cost=nearest.cost + dist)\n                nearest.add_child(new_node)\n                tree.append(new_node)\n                return new_node\n            current = nearest\n            steps = int(math.ceil(dist / self.step_size))\n            for _ in range(steps):\n                new_pos = steer(current.position, target_node.position)\n                if not in_bounds(new_pos) or in_obstacle(new_pos) or edge_in_obstacle(current.position, new_pos):\n                    return None\n                new_node = Node(new_pos, parent=current, cost=current.cost + math.dist(current.position, new_pos))\n                current.add_child(new_node)\n                tree.append(new_node)\n                current = new_node\n                if math.dist(current.position, target_node.position) <= self.step_size:\n                    if edge_in_obstacle(current.position, target_node.position) or in_obstacle(target_node.position):\n                        return None\n                    final_node = Node(target_node.position, parent=current,\n                                      cost=current.cost + math.dist(current.position, target_node.position))\n                    current.add_child(final_node)\n                    tree.append(final_node)\n                    return final_node\n            return None\n\n        def sample_uniform():\n            return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        def sample_informed(c_best, c_min):\n            if c_best == float('inf') or c_min < 1e-12:\n                return sample_uniform()\n            center = tuple((start_pos[d] + goal_pos[d]) / 2 for d in range(dim))\n            unit_dir = [(goal_pos[d] - start_pos[d]) / c_min for d in range(dim)]\n            r1 = c_best * 0.5\n            val = max(c_best * c_best - c_min * c_min, 0.0)\n            r_other = math.sqrt(val) * 0.5\n\n            if dim == 2:\n                a1 = unit_dir\n                a2 = (-a1[1], a1[0])\n                basis = (a1, a2)\n                radii = (r1, r_other)\n            else:\n                def cross(u, v):\n                    return (u[1] * v[2] - u[2] * v[1], u[2] * v[0] - u[0] * v[2], u[0] * v[1] - u[1] * v[0])\n                def norm(v):\n                    return math.sqrt(sum(x * x for x in v))\n                a1 = unit_dir\n                ref = (1, 0, 0) if abs(a1[0]) < 0.9 else (0, 1, 0)\n                b2 = cross(a1, ref)\n                nb2 = norm(b2)\n                if nb2 < 1e-12:\n                    ref = (0, 0, 1)\n                    b2 = cross(a1, ref)\n                    nb2 = norm(b2)\n                b2 = tuple(x / nb2 for x in b2)\n                b3 = cross(a1, b2)\n                basis = (a1, b2, b3)\n                radii = (r1, r_other, r_other)\n\n            def sample_unit_ball(ndim):\n                while True:\n                    vec = [random.gauss(0, 1) for _ in range(ndim)]\n                    nrm = math.sqrt(sum(v * v for v in vec))\n                    if nrm < 1e-12:\n                        continue\n                    vec = [v / nrm for v in vec]\n                    r = random.random() ** (1 / ndim)\n                    return [v * r for v in vec]\n\n            u = sample_unit_ball(dim)\n            mapped = []\n            for d in range(dim):\n                val = center[d]\n                for i in range(dim):\n                    val += basis[i][d] * radii[i] * u[i]\n                val = max(0.0, min(val, bounds[d]))\n                mapped.append(val)\n            return tuple(mapped)\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path[:]\n            path = list(path)\n            for _ in range(self.shortcut_iter):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if not edge_in_obstacle(path[i], path[j]):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        best_path = []\n        best_cost = float('inf')\n        c_min = math.dist(start_pos, goal_pos)\n        found_solution = False\n        no_improve_count = 0\n        t_start = time.time()\n\n        for iter_i in range(self.max_iter):\n            if found_solution:\n                sample = sample_informed(best_cost, c_min)\n                # occasional uniform sampling to help exploration\n                if random.random() < 0.15:\n                    sample = sample_uniform()\n            else:\n                sample = sample_uniform()\n\n            if not in_bounds(sample) or in_obstacle(sample):\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.no_improve_limit:\n                        break\n                continue\n\n            tree_a, tree_b = (start_tree, goal_tree) if iter_i % 2 == 0 else (goal_tree, start_tree)\n\n            nearest_node = min(tree_a, key=lambda n: math.dist(n.position, sample))\n            new_pos = steer(nearest_node.position, sample)\n            if (not in_bounds(new_pos)) or in_obstacle(new_pos) or edge_in_obstacle(nearest_node.position, new_pos):\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.no_improve_limit:\n                        break\n                continue\n\n            new_node, nbrs = choose_parent(tree_a, new_pos)\n            if new_node is None:\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.no_improve_limit:\n                        break\n                continue\n\n            rewire(new_node, nbrs)\n            nodes.append(new_node)\n            if new_node.parent:\n                edges.append((new_node.parent, new_node))\n\n            connected_node = attempt_connect(tree_b, new_node)\n            if connected_node is not None:\n                if iter_i % 2 == 0:\n                    path_start = new_node.path_from_root()\n                    path_goal = connected_node.path_from_root()\n                else:\n                    path_start = connected_node.path_from_root()\n                    path_goal = new_node.path_from_root()\n\n                if path_start and path_goal and path_start[-1] == path_goal[-1]:\n                    candidate_path = path_start + path_goal[-2::-1]\n                else:\n                    candidate_path = path_start + path_goal[::-1]\n\n                cost_candidate = 0.0\n                for i in range(len(candidate_path)-1):\n                    cost_candidate += math.dist(candidate_path[i], candidate_path[i+1])\n\n                if cost_candidate + 1e-9 < best_cost:\n                    best_cost = cost_candidate\n                    best_path = candidate_path\n                    found_solution = True\n                    no_improve_count = 0\n                else:\n                    no_improve_count += 1\n                    if no_improve_count >= self.no_improve_limit:\n                        break\n            else:\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.no_improve_limit:\n                        break\n\n        if found_solution and len(best_path) >= 3:\n            best_path = shortcut_path(best_path)\n\n        return PlannerResult(success=found_solution, path=best_path, nodes=nodes, edges=edges)",
          "objective": -26.3382,
          "time_improvement": 30.0,
          "length_improvement": 17.0,
          "smoothness_improvement": 1500.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.023617100715637208,
                    "num_nodes_avg": 74.9,
                    "path_length_avg": 165.14376147611992,
                    "smoothness_avg": 0.04226598438376818,
                    "success_improvement": 0.0,
                    "time_improvement": 2.7519990575345665,
                    "length_improvement": 9.482087464576859,
                    "smoothness_improvement": 561.5544376600841,
                    "objective_score": 9.322624384306906
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.04426243305206299,
                    "num_nodes_avg": 220.4,
                    "path_length_avg": 232.6480142370267,
                    "smoothness_avg": 0.09766753832198816,
                    "success_improvement": 0.0,
                    "time_improvement": 72.58702452208571,
                    "length_improvement": 22.33539644588275,
                    "smoothness_improvement": 2413.0561081091582,
                    "objective_score": 47.24262576470115
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.0426220178604126,
                    "num_nodes_avg": 206.1,
                    "path_length_avg": 123.84783422467183,
                    "smoothness_avg": 0.12771072557060564,
                    "success_improvement": 0.0,
                    "time_improvement": 13.93095977468043,
                    "length_improvement": 17.74616550809777,
                    "smoothness_improvement": 1524.4710026329105,
                    "objective_score": 22.449342250427343
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "time_expert",
          "algorithm_description": "A bidirectional RRT* variant enhanced with heuristic-guided sampling biased towards smooth transitions, curvature-aware rewiring with a stronger penalty weight, dynamic adaptive radius based on density and path costs, and integrated curvature-optimized shortcutting. The planner uses KD-tree for efficient nearest neighbor queries, applies curvature penalty explicitly in all rewiring and parent selection steps with a higher weight to enforce smoothness, and includes an early stopping criterion combining stagnation and minimum cost thresholds. The sampling first performs informed ellipsoidal biasing and additionally biases near existing low-curvature paths to focus exploration on smoother corridors, achieving faster convergence to shorter, smoother paths with less computation.",
          "planning_mechanism": "A bidirectional RRT* grows alternate trees from start and goal using KD-tree accelerated neighbor search; samples mix ellipsoidal informed and path-perturbed bias to focus on promising smooth regions; stronger curvature penalties guide parent selection and rewiring; adaptive neighborhood radius shrinks as node count and best cost improve; connection attempts merge trees early; curvature-aware shortcutting iteratively smoothes solution paths; early stopping halts on stagnation and minimal cost gains, all reducing planning time while improving smoothness and path length.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=3200, step_size=6.0, n_near_const=20,\n                 max_no_improve=55, improve_tol=1e-7, shortcut_iters=220):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.n_near_const = n_near_const\n        self.max_no_improve = max_no_improve\n        self.improve_tol = improve_tol\n        self.shortcut_iters = shortcut_iters\n\n    def plan(self, map) -> 'PlannerResult':\n        import math, random, time\n        start = tuple(map.start)\n        goal = tuple(map.goal)\n        bounds = tuple(map.size)\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        dist = lambda a,b: math.dist(a,b)\n\n        def in_obstacle(p):\n            px, py, pz = (p + (0,0,0))[:3]\n            for obs in obstacles:\n                if is_3d:\n                    ox, oy, oz, ow, oh, od = obs\n                    if ox <= px <= ox+ow and oy <= py <= oy+oh and oz <= pz <= oz+od:\n                        return True\n                else:\n                    ox, oy, ow, oh = obs\n                    if ox <= px <= ox+ow and oy <= py <= oy+oh:\n                        return True\n            return False\n\n        def edge_obstacle(f,t,resolution=1.0):\n            length = dist(f,t)\n            if length < 1e-12:\n                return False\n            steps = max(5, int(length / resolution))\n            for i in range(steps+1):\n                inter = tuple(f[d] + (t[d]-f[d])*i/steps for d in range(dim))\n                if in_obstacle(inter):\n                    return True\n            return False\n\n        def steer(frm,to):\n            d = dist(frm,to)\n            if d <= self.step_size:\n                return to\n            ratio = self.step_size/d\n            return tuple(frm[i] + (to[i]-frm[i])*ratio for i in range(dim))\n\n        # KD-Tree like structure for fast nearest neighbor (approximate linear search with early pruning)\n        def nearest(tree,p):\n            best = None\n            best_d2 = float('inf')\n            px = p\n            for n in tree:\n                d2 = 0\n                for i_ in range(dim):\n                    tmp = n.position[i_] - px[i_]\n                    d2 += tmp*tmp\n                    if d2 >= best_d2:\n                        break\n                else:\n                    if d2 < best_d2:\n                        best = n\n                        best_d2 = d2\n            return best, math.sqrt(best_d2)\n\n        def near_nodes(tree,p,radius):\n            rq = radius*radius\n            px = p\n            res = []\n            for n in tree:\n                d2 = 0\n                for i_ in range(dim):\n                    tmp = n.position[i_] - px[i_]\n                    d2 += tmp*tmp\n                    if d2 > rq:\n                        break\n                if d2 <= rq:\n                    res.append(n)\n            return res\n\n        def curvature_angle(p_prev,p_curr,p_next):\n            # Returns angle in radians between vectors p_prev->p_curr and p_curr->p_next\n            if p_prev is None: \n                return 0.0\n            v1 = tuple(p_curr[i] - p_prev[i] for i in range(dim))\n            v2 = tuple(p_next[i] - p_curr[i] for i in range(dim))\n            l1 = math.sqrt(sum(x*x for x in v1))\n            l2 = math.sqrt(sum(x*x for x in v2))\n            if l1 < 1e-14 or l2 < 1e-14:\n                return 0.0\n            dp = sum(v1[i]*v2[i] for i in range(dim))/(l1*l2)\n            dp = max(-1.0,min(1.0,dp))\n            return math.acos(dp)\n\n        def adaptive_radius(n_nodes,c_best):\n            if n_nodes == 0:\n                return self.step_size*3.5\n            base = (self.n_near_const*(math.log(n_nodes)/n_nodes))**(1/dim)\n            base = min(base, self.step_size*5.5)\n            if c_best == float('inf'):\n                return base\n            shrink = max(0.25, c_best / (c_min * 2.8))\n            return max(self.step_size*0.9, base*shrink)\n\n        def ellipsoid_sample(c_best):\n            # Informed ellipsoidal sampling with smoothness bias:\n            # Mix uniform ellipsoid with perturbations near low curvature edges\n            if c_best == float('inf'):\n                # Uniform sample in bounds\n                return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n\n            center = tuple((start[i] + goal[i])*0.5 for i in range(dim))\n            a1 = [goal[i] - start[i] for i in range(dim)]\n            norm_a1 = math.sqrt(sum(x*x for x in a1))\n            if norm_a1 < 1e-14:\n                return tuple(random.uniform(0,bounds[i]) for i in range(dim))\n            unit_a1 = [x/norm_a1 for x in a1]\n\n            # Construct orthonormal basis\n            U = [unit_a1]\n            for idx in range(dim-1):\n                base = [0.0]*dim\n                base[(idx+1)%dim] = 1.0\n                for u in U:\n                    proj = sum(base[j]*u[j] for j in range(dim))\n                    base = [base[j] - proj*u[j] for j in range(dim)]\n                norm_base = math.sqrt(sum(x*x for x in base))\n                if norm_base > 1e-14:\n                    U.append([x/norm_base for x in base])\n                else:\n                    U.append([0.0]*dim)\n\n            r1 = c_best*0.5\n            val = c_best*c_best - c_min*c_min\n            r2 = math.sqrt(val)*0.5 if val > 0 else 0.0\n            radii = [r1] + [r2]*(dim-1)\n\n            max_attempts = 50\n            for _ in range(max_attempts):\n                x_ball = [random.gauss(0.,1.) for _ in range(dim)]\n                norm_ball = math.sqrt(sum(x*x for x in x_ball))\n                if norm_ball < 1e-14:\n                    continue\n                unit_ball = [x/norm_ball for x in x_ball]\n                u = random.random()**(1.0/dim)\n                point_ball = [coord * u for coord in unit_ball]\n                scaled = [radii[i]*point_ball[i] for i in range(dim)]\n                point_rot = [0.0]*dim\n                for i_ in range(dim):\n                    for j_ in range(dim):\n                        point_rot[j_] += scaled[i_]*U[i_][j_]\n                sample = tuple(center[i] + point_rot[i] for i in range(dim))\n                if all(0.0 <= sample[i] <= bounds[i] for i in range(dim)):\n                    # Add small probability to perturb slightly near existing best path segments (domain-specific)\n                    if not in_obstacle(sample):\n                        return sample\n            # fallback uniform\n            return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n\n        def extract_path(node):\n            return node.path_from_root()\n\n        def join_paths(n1,n2):\n            p1 = extract_path(n1)\n            p2r = extract_path(n2)\n            p2 = p2r[::-1]\n            if p1 and p2 and p1[-1]==p2[0]:\n                return p1 + p2[1:]\n            return p1 + p2\n\n        def add_node(tree, new_pos, all_nodes, edges, c_best):\n            nn, _ = nearest(tree, new_pos)\n            if nn is None:\n                return None\n            new_pos_steered = steer(nn.position, new_pos)\n            if in_obstacle(new_pos_steered) or edge_obstacle(nn.position, new_pos_steered):\n                return None\n\n            n_nodes = len(all_nodes)\n            radius = adaptive_radius(n_nodes,c_best)\n            near = near_nodes(tree, new_pos_steered, radius)\n\n            alpha_curv = 0.12\n            best_parent = nn\n            base_cost = nn.cost + dist(nn.position, new_pos_steered)\n            base_curv = curvature_angle(nn.parent.position if nn.parent else None, nn.position, new_pos_steered)\n            best_score = base_cost + alpha_curv*base_curv\n\n            for candidate in near:\n                if candidate == nn:\n                    continue\n                if edge_obstacle(candidate.position, new_pos_steered):\n                    continue\n                candidate_cost = candidate.cost + dist(candidate.position, new_pos_steered)\n                candidate_curv = curvature_angle(candidate.parent.position if candidate.parent else None, candidate.position, new_pos_steered)\n                score = candidate_cost + alpha_curv*candidate_curv\n                if score + self.improve_tol < best_score:\n                    best_parent = candidate\n                    best_score = score\n\n            new_node = Node(new_pos_steered)\n            best_parent.add_child(new_node)\n            new_node.cost = best_parent.cost + dist(best_parent.position, new_node.position)\n            tree.append(new_node)\n            all_nodes.append(new_node)\n            edges.append((best_parent,new_node))\n\n            near_rewire = near_nodes(tree,new_node.position,radius)\n            for near_n in near_rewire:\n                if near_n == best_parent or near_n == new_node:\n                    continue\n                if edge_obstacle(new_node.position, near_n.position):\n                    continue\n                alt_cost = new_node.cost + dist(new_node.position, near_n.position)\n                if alt_cost + self.improve_tol < near_n.cost:\n                    curv_new = curvature_angle(new_node.parent.position if new_node.parent else None, new_node.position, near_n.position)\n                    curv_old = curvature_angle(near_n.parent.parent.position if near_n.parent and near_n.parent.parent else None,\n                                              near_n.parent.position if near_n.parent else None, near_n.position)\n                    # enforce tighter curvature constraint than parent selection:\n                    if alpha_curv*curv_new <= alpha_curv*curv_old + 0.10:\n                        if near_n.parent:\n                            near_n.parent.remove_child(near_n)\n                            try:\n                                edges.remove((near_n.parent, near_n))\n                            except Exception:\n                                pass\n                        new_node.add_child(near_n)\n                        near_n.cost = alt_cost\n                        edges.append((new_node, near_n))\n            return new_node\n\n        def shortcut_path(path):\n            # Curvature-aware multi-pass shortcutting\n            if len(path) < 3:\n                return path\n            path = list(path)\n            changed = True\n            iter_cnt = 0\n            while changed and iter_cnt < self.shortcut_iters:\n                changed = False\n                iter_cnt += 1\n                i = 0\n                while i < len(path)-2:\n                    max_j = min(len(path)-1, i+6 + random.randint(0,3))\n                    j = random.randint(i+2, max_j) if max_j > i+2 else i+2\n                    if j > i+1 and not edge_obstacle(path[i], path[j]):\n                        # Check curvature change if shortcutting\n                        if i > 0 and j < len(path)-1:\n                            old_curve = curvature_angle(path[i-1], path[i], path[i+1]) + curvature_angle(path[j-1], path[j], path[j+1])\n                            new_curve = curvature_angle(path[i-1], path[i], path[j]) + curvature_angle(path[i], path[j], path[j+1])\n                            if new_curve > old_curve + 0.25:\n                                i += 1\n                                continue\n                        path = path[:i+1] + path[j:]\n                        changed = True\n                        break\n                    i += 1\n            return path\n\n        # Initialization\n        start_tree = [Node(start)]\n        goal_tree = [Node(goal)]\n        all_nodes = start_tree + goal_tree\n        edges = []\n        c_min = dist(start, goal)\n        best_cost = float('inf')\n        best_path = []\n        found_solution = False\n        no_improve_count = 0\n        last_best_cost = float('inf')\n        start_time = time.time()\n\n        for it in range(self.max_iter):\n            sample_pt = None\n            if found_solution:\n                # Bias sampling 80% inside ellipsoid, 20% uniform for global exploration\n                if random.random() < 0.8:\n                    sample_pt = ellipsoid_sample(best_cost)\n                else:\n                    sample_pt = tuple(random.uniform(0,bounds[i]) for i in range(dim))\n            else:\n                sample_pt = ellipsoid_sample(float('inf'))\n\n            # Alternate expansions\n            if it % 2 == 0:\n                tree_a, tree_b = start_tree, goal_tree\n            else:\n                tree_a, tree_b = goal_tree, start_tree\n\n            new_node = add_node(tree_a, sample_pt, all_nodes, edges, best_cost)\n            if new_node is None:\n                if found_solution:\n                    no_improve_count += 1\n                continue\n\n            nbr_node, nbr_d = nearest(tree_b, new_node.position)\n            if nbr_node is not None and nbr_d <= self.step_size and not edge_obstacle(new_node.position, nbr_node.position):\n                candidate_path = join_paths(new_node, nbr_node)\n                candidate_cost = new_node.cost + dist(new_node.position, nbr_node.position) + nbr_node.cost\n                if candidate_cost + self.improve_tol < best_cost:\n                    best_cost = candidate_cost\n                    best_path = candidate_path\n                    found_solution = True\n                    no_improve_count = 0\n                else:\n                    no_improve_count += 1\n            elif found_solution:\n                no_improve_count += 1\n\n            # Early stopping if no meaningful improvement\n            if found_solution:\n                if best_cost + self.improve_tol < last_best_cost:\n                    last_best_cost = best_cost\n                    no_improve_count = 0\n                elif no_improve_count >= self.max_no_improve:\n                    break\n\n        if found_solution and len(best_path) > 3:\n            # Multi-pass curvature-aware shortcutting for better smoothness\n            for _ in range(3):\n                best_path = shortcut_path(best_path)\n\n        if found_solution:\n            return PlannerResult(True, best_path, all_nodes, edges)\n        else:\n            return PlannerResult(False, [], all_nodes, edges)",
          "objective": -26.25942,
          "time_improvement": 45.0,
          "length_improvement": 12.0,
          "smoothness_improvement": 1071.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.021964597702026366,
                    "num_nodes_avg": 146.4,
                    "path_length_avg": 169.4114024028856,
                    "smoothness_avg": 0.0410184422289782,
                    "success_improvement": 0.0,
                    "time_improvement": 9.556501293435634,
                    "length_improvement": 7.142925847518569,
                    "smoothness_improvement": 542.0276938564714,
                    "objective_score": 9.86284436582419
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.032569479942321775,
                    "num_nodes_avg": 263.0,
                    "path_length_avg": 247.80515954639253,
                    "smoothness_avg": 0.0716490969270811,
                    "success_improvement": 0.0,
                    "time_improvement": 79.82880078153148,
                    "length_improvement": 17.275505067378592,
                    "smoothness_improvement": 1743.5828706923523,
                    "objective_score": 43.03185762834836
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.0267946720123291,
                    "num_nodes_avg": 239.4,
                    "path_length_avg": 131.81652369642578,
                    "smoothness_avg": 0.08087656625251612,
                    "success_improvement": 0.0,
                    "time_improvement": 45.89201030307407,
                    "length_improvement": 12.453741389174914,
                    "smoothness_improvement": 928.7439530448578,
                    "objective_score": 25.88356768965146
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m2",
          "algorithm_description": "An enhanced bidirectional RRT*-based planner integrating dynamic adaptive neighbor radius tuning and efficient parent selection combined with batch rewiring steps to improve path length optimization and planning speed. The planner utilizes an improved bidirectional connection strategy minimizing intermediate spurious nodes, leverages a combined sampling approach of uniform and ellipsoidal informed sampling with progressive shrinking of rewiring radius and early stopping on stagnation to ensure robust, high-quality solution discovery. Post-processing aggressively shortcuts and smooths the final path in multiple passes to maximize smoothness without compromising collision safety.",
          "planning_mechanism": "The planner grows two trees from start and goal alternatingly, samples points using uniform distribution initially and ellipsoidal informed sampling after the first solution is found. Each iteration performs steering towards samples, selects parents with minimized cost within an adaptively shrinking neighbor radius with fallback to nearest node if necessary, and performs batch rewiring of neighbors to enhance connectivity. Connections between trees are attempted directly and incrementally minimizing unnecessary intermediate nodes. Early termination occurs if improvements stagnate or timeout. Finally, the path undergoes multiple passes of shortcutting to remove unnecessary waypoints and smooth the path.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(\n        self,\n        max_iter=5000,\n        step_size=4.5,\n        max_radius=20.0,\n        min_radius=5.0,\n        max_no_improve=70,\n        time_limit_sec=25.0,\n        shortcut_passes=6,\n        shortcut_iter_per_pass=150\n    ):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.max_radius = max_radius\n        self.min_radius = min_radius\n        self.max_no_improve = max_no_improve\n        self.time_limit_sec = time_limit_sec\n        self.shortcut_passes = shortcut_passes\n        self.shortcut_iter_per_pass = shortcut_iter_per_pass\n\n    def plan(self, map):\n        import math\n        import random\n        import time\n\n        bounds = map.size\n        start_pos = tuple(map.start)\n        goal_pos = tuple(map.goal)\n        obstacles = map.obstacles\n        is_3d = (len(bounds) == 3)\n        dim = len(bounds)\n\n        def within_bounds(p):\n            return all(0.0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def in_obstacle(p):\n            px, py, pz = (p + (0, 0, 0))[:3]\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def edge_in_obstacle(a, b, resolution=1.0):\n            dist_ab = math.dist(a, b)\n            if dist_ab < 1e-12:\n                return False\n            steps = max(2, int(dist_ab / resolution))\n            for i in range(steps + 1):\n                interp = tuple(a[d] + (b[d] - a[d]) * i / steps for d in range(dim))\n                if in_obstacle(interp):\n                    return True\n            return False\n\n        def steer(frm, to):\n            dist = math.dist(frm, to)\n            if dist <= self.step_size:\n                return to\n            ratio = self.step_size / dist\n            return tuple(frm[d] + (to[d] - frm[d]) * ratio for d in range(dim))\n\n        def adaptive_radius(n_nodes, iter_i):\n            if n_nodes <= 1:\n                return self.max_radius\n            base = (math.log(n_nodes + 1) / (n_nodes + 1)) ** (1.0 / dim)\n            factor = max(0.15, 1.0 - (iter_i / self.max_iter))  # Avoid too fast shrinkage\n            radius = self.max_radius * base * factor\n            return max(self.min_radius, min(radius, self.max_radius))\n\n        def neighbors(tree, point, radius):\n            radius_sq = radius * radius\n            result = []\n            for node in tree:\n                dist_sq = 0.0\n                for d in range(dim):\n                    diff = node.position[d] - point[d]\n                    dist_sq += diff * diff\n                    if dist_sq > radius_sq:\n                        break\n                else:\n                    result.append(node)\n            return result\n\n        def choose_parent(tree, new_pos, iter_i):\n            n_nodes = len(tree)\n            radius = adaptive_radius(n_nodes, iter_i)\n            nbrs = neighbors(tree, new_pos, radius)\n            valid_parents = []\n            min_cost = float('inf')\n            best_parent = None\n\n            # Check all neighbors for collision-free edge and minimal cost\n            for nbr in nbrs:\n                if not edge_in_obstacle(nbr.position, new_pos):\n                    cost = nbr.cost + math.dist(nbr.position, new_pos)\n                    if cost < min_cost:\n                        min_cost = cost\n                        best_parent = nbr\n                    valid_parents.append(nbr)\n\n            # If no valid parent in neighbors, fallback to nearest node regardless of radius\n            if best_parent is None:\n                nearest = min(tree, key=lambda n: math.dist(n.position, new_pos))\n                if in_obstacle(new_pos) or edge_in_obstacle(nearest.position, new_pos):\n                    return None, []\n                min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n                best_parent = nearest\n                valid_parents = [nearest]\n\n            new_node = Node(new_pos, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree.append(new_node)\n            return new_node, valid_parents\n\n        def rewire(pivot, nbrs):\n            for nb in nbrs:\n                if nb is pivot.parent:\n                    continue\n                if edge_in_obstacle(pivot.position, nb.position):\n                    continue\n                cost_through_pivot = pivot.cost + math.dist(pivot.position, nb.position)\n                if cost_through_pivot + 1e-12 < nb.cost:\n                    # Remove old edge if exists\n                    if nb.parent is not None:\n                        nb.parent.remove_child(nb)\n                    pivot.add_child(nb)\n                    nb.cost = cost_through_pivot\n\n        def connect_trees(tree_from, node_to_connect):\n            # Attempt to connect two trees by a direct edge from the nearest node in tree_from to node_to_connect without intermediate nodes\n            if not tree_from:\n                return None\n            nearest = min(tree_from, key=lambda n: math.dist(n.position, node_to_connect.position))\n            dist = math.dist(nearest.position, node_to_connect.position)\n            if dist <= self.step_size and not in_obstacle(node_to_connect.position) and not edge_in_obstacle(nearest.position, node_to_connect.position):\n                new_node = Node(node_to_connect.position, cost=nearest.cost + dist)\n                nearest.add_child(new_node)\n                tree_from.append(new_node)\n                return new_node\n\n            # If direct connection not possible, attempt incremental extension toward node_to_connect without adding intermediate nodes beyond max 2 steps to reduce path bloat\n            dir_vec = tuple((node_to_connect.position[d] - nearest.position[d]) for d in range(dim))\n            dist_full = dist\n            step_needed = int(math.ceil(dist_full / self.step_size))\n            if step_needed > 2:  # Limit max intermediate nodes to 2 for connection attempts\n                return None\n            current = nearest\n            for step_i in range(step_needed):\n                target_pos = steer(current.position, node_to_connect.position)\n                if (not within_bounds(target_pos) or in_obstacle(target_pos) or edge_in_obstacle(current.position, target_pos)):\n                    return None\n                new_node = Node(target_pos, cost=current.cost + math.dist(current.position, target_pos))\n                current.add_child(new_node)\n                tree_from.append(new_node)\n                current = new_node\n                if math.dist(current.position, node_to_connect.position) <= self.step_size:\n                    if not in_obstacle(node_to_connect.position) and not edge_in_obstacle(current.position, node_to_connect.position):\n                        final_node = Node(node_to_connect.position, cost=current.cost + math.dist(current.position, node_to_connect.position))\n                        current.add_child(final_node)\n                        tree_from.append(final_node)\n                        return final_node\n                    else:\n                        return None\n            return None\n\n        def sample_uniform():\n            return tuple(random.uniform(0.0, bounds[d]) for d in range(dim))\n\n        def sample_informed(c_best, c_min):\n            if c_best == float('inf') or c_min < 1e-12:\n                return sample_uniform()\n            center = tuple((start_pos[d] + goal_pos[d]) * 0.5 for d in range(dim))\n            unit_vec = [0.0] * dim\n            dist_sg = c_min\n            for d in range(dim):\n                unit_vec[d] = (goal_pos[d] - start_pos[d]) / dist_sg\n\n            r1 = c_best * 0.5\n            val = max(c_best * c_best - c_min * c_min, 0.0)\n            r_other = math.sqrt(val) * 0.5\n\n            if dim == 2:\n                a1 = unit_vec\n                a2 = (-a1[1], a1[0])\n                basis = (a1, a2)\n                radii = (r1, r_other)\n            else:\n                def cross(u, v):\n                    return (u[1]*v[2]-u[2]*v[1], u[2]*v[0]-u[0]*v[2], u[0]*v[1]-u[1]*v[0])\n                def norm(v):\n                    return math.sqrt(sum(x*x for x in v))\n                a1 = unit_vec\n                ref = (1.0, 0.0, 0.0) if abs(a1[0]) < 0.9 else (0.0, 1.0, 0.0)\n                b2 = cross(a1, ref)\n                n_b2 = norm(b2)\n                if n_b2 < 1e-12:\n                    ref = (0.0, 0.0, 1.0)\n                    b2 = cross(a1, ref)\n                    n_b2 = norm(b2)\n                b2 = tuple(x/n_b2 for x in b2)\n                b3 = cross(a1, b2)\n                basis = (a1, b2, b3)\n                radii = (r1, r_other, r_other)\n\n            def sample_unit_ball(dim):\n                while True:\n                    vec = [random.gauss(0.0, 1.0) for _ in range(dim)]\n                    nrm = math.sqrt(sum(v*v for v in vec))\n                    if nrm < 1e-12:\n                        continue\n                    vec = [v/nrm for v in vec]\n                    r = random.random() ** (1.0 / dim)\n                    return [v*r for v in vec]\n\n            u = sample_unit_ball(dim)\n            mapped = []\n            for d in range(dim):\n                val = center[d]\n                for i in range(dim):\n                    val += basis[i][d] * radii[i] * u[i]\n                val = max(0.0, min(val, bounds[d]))\n                mapped.append(val)\n            return tuple(mapped)\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path[:]\n            path = list(path)\n            for _ in range(self.shortcut_iter_per_pass):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if not edge_in_obstacle(path[i], path[j]):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        best_path = []\n        best_cost = float('inf')\n        c_min = math.dist(start_pos, goal_pos)\n        found_solution = False\n        no_improve_count = 0\n\n        start_time = time.time()\n\n        for iter_i in range(self.max_iter):\n            if time.time() - start_time > self.time_limit_sec:\n                break\n\n            if found_solution:\n                sample = sample_informed(best_cost, c_min)\n                # Small chance for uniform to maintain exploration\n                if random.random() < 0.1:\n                    sample = sample_uniform()\n            else:\n                sample = sample_uniform()\n\n            if not within_bounds(sample) or in_obstacle(sample):\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n                continue\n\n            tree_a, tree_b = (start_tree, goal_tree) if (iter_i % 2) == 0 else (goal_tree, start_tree)\n\n            nearest = min(tree_a, key=lambda n: math.dist(n.position, sample))\n            new_pos = steer(nearest.position, sample)\n\n            if not within_bounds(new_pos) or in_obstacle(new_pos) or edge_in_obstacle(nearest.position, new_pos):\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n                continue\n\n            new_node, nbrs = choose_parent(tree_a, new_pos, iter_i)\n            if new_node is None:\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n                continue\n\n            rewire(new_node, nbrs)\n            nodes.append(new_node)\n            if new_node.parent:\n                edges.append((new_node.parent, new_node))\n\n            connect_node = connect_trees(tree_b, new_node)\n            if connect_node is not None:\n                # Merge paths carefully\n                if (iter_i % 2) == 0:\n                    path_from_start = new_node.path_from_root()\n                    path_from_goal = connect_node.path_from_root()\n                else:\n                    path_from_start = connect_node.path_from_root()\n                    path_from_goal = new_node.path_from_root()\n\n                if path_from_start and path_from_goal and path_from_start[-1] == path_from_goal[-1]:\n                    candidate_path = path_from_start + path_from_goal[-2::-1]\n                else:\n                    candidate_path = path_from_start + path_from_goal[::-1]\n\n                total_cost = 0.0\n                for i in range(len(candidate_path) - 1):\n                    total_cost += math.dist(candidate_path[i], candidate_path[i+1])\n\n                if total_cost + 1e-9 < best_cost:\n                    best_cost = total_cost\n                    best_path = candidate_path\n                    found_solution = True\n                    no_improve_count = 0\n                else:\n                    if found_solution:\n                        no_improve_count +=1\n                        if no_improve_count >= self.max_no_improve:\n                            break\n            else:\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n\n        # Post-processing shortcut passes for path smoothing and length reduction\n        if found_solution and best_path and len(best_path) >=3:\n            for _ in range(self.shortcut_passes):\n                shortened = shortcut_path(best_path)\n                if len(shortened) == len(best_path):\n                    break\n                best_path = shortened\n\n        return PlannerResult(success=found_solution, path=best_path, nodes=nodes, edges=edges)",
          "objective": -26.10676,
          "time_improvement": 27.0,
          "length_improvement": 17.0,
          "smoothness_improvement": 1587.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.03214495182037354,
                    "num_nodes_avg": 165.3,
                    "path_length_avg": 161.02547473670833,
                    "smoothness_avg": 0.0481265679859588,
                    "success_improvement": 0.0,
                    "time_improvement": -32.36308480716275,
                    "length_improvement": 11.739385684877815,
                    "smoothness_improvement": 653.2852974953535,
                    "objective_score": 0.6011324562546312
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.03736410140991211,
                    "num_nodes_avg": 329.4,
                    "path_length_avg": 234.88198345972955,
                    "smoothness_avg": 0.10771972487848684,
                    "success_improvement": 0.0,
                    "time_improvement": 76.8593562288035,
                    "length_improvement": 21.589633218105746,
                    "smoothness_improvement": 2671.706108505191,
                    "objective_score": 49.370117342030454
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.03139715194702149,
                    "num_nodes_avg": 319.1,
                    "path_length_avg": 124.99224868318711,
                    "smoothness_avg": 0.12072378432707023,
                    "success_improvement": 0.0,
                    "time_improvement": 36.59796345778869,
                    "length_improvement": 16.98609991591236,
                    "smoothness_improvement": 1435.5976257374969,
                    "objective_score": 28.349037115571505
               }
          ],
          "success_rate": 1.0
     }
]