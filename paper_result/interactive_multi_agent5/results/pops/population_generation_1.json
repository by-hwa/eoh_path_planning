[
     {
          "operator": "initial",
          "algorithm_description": "This algorithm grows two trees simultaneously, one from the start position and one from the goal position, and attempts to connect them to find a feasible path. This bidirectional approach accelerates convergence and increases the success rate compared to a single tree RRT.",
          "planning_mechanism": "The planning mechanism involves randomly sampling points within the map bounds, extending each tree towards the sampled points, and attempting to connect the two trees whenever new nodes are added. Collision checks are performed for nodes and edges to ensure safety, and once the two trees connect, the final path is reconstructed by backtracking through the parent nodes of each tree.",
          "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map) -> PlannerResult:\n        import math, random\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position)\n        goal_root = Node(goal_position)\n        nodes.extend([start_root, goal_root])\n        tree_a, tree_b = [start_root], [goal_root]\n\n        for _ in range(self.max_iter):\n            rand_point = self._sample_free(bounds, obstacles, is_3d)\n            new_a = self._extend_tree(tree_a, rand_point, obstacles, is_3d, nodes, edges)\n            if new_a is None:\n                continue\n\n            new_b = self._connect_trees(tree_b, new_a, obstacles, is_3d, nodes, edges)\n            if new_b:\n                success_state = True\n                path_a = new_a.path_from_root()\n                path_b = new_b.path_from_root()\n                extracted_path = path_a + path_b[::-1]\n                break\n\n            tree_a, tree_b = tree_b, tree_a  # Swap trees\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        import random\n        while True:\n            if is_3d:\n                p = (random.uniform(0, bounds[0]),\n                     random.uniform(0, bounds[1]),\n                     random.uniform(0, bounds[2]))\n            else:\n                p = (random.uniform(0, bounds[0]),\n                     random.uniform(0, bounds[1]))\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    def _nearest(self, tree, point):\n        import math\n        return min(tree, key=lambda node: math.dist(node.position, point))\n\n    def _steer(self, from_pos, to_pos):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _extend_tree(self, tree, point, obstacles, is_3d, nodes, edges):\n        nearest_node = self._nearest(tree, point)\n        new_pos = self._steer(nearest_node.position, point)\n        if not self._is_in_obstacle(new_pos, obstacles, is_3d) and not self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n            new_node = Node(new_pos, parent=nearest_node)\n            nearest_node.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n            return new_node\n        return None\n\n    def _connect_trees(self, tree, new_node, obstacles, is_3d, nodes, edges):\n        import math\n        nearest_node = self._nearest(tree, new_node.position)\n        while True:\n            new_pos = self._steer(nearest_node.position, new_node.position)\n            if (not self._is_in_obstacle(new_pos, obstacles, is_3d) and\n                not self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d)):\n                next_node = Node(new_pos, parent=nearest_node)\n                nearest_node.add_child(next_node)\n                tree.append(next_node)\n                nodes.append(next_node)\n                edges.append((nearest_node, next_node))\n\n                if math.dist(next_node.position, new_node.position) <= self.step_size:\n                    if not self._is_edge_in_obstacle(next_node.position, new_node.position, obstacles, is_3d):\n                        final_node = Node(new_node.position, parent=next_node)\n                        next_node.add_child(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((next_node, final_node))\n                        return final_node\n                    else:\n                        return None\n                nearest_node = next_node\n            else:\n                return None\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n",
          "objective": -25.227923962981944,
          "time_improvement": 87.0,
          "length_improvement": -2.0,
          "smoothness_improvement": 63.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.004349446296691895,
                    "num_nodes_avg": 77.1,
                    "path_length_avg": 181.3336822357041,
                    "smoothness_avg": 0.010364133226421615,
                    "success_improvement": 0.0,
                    "time_improvement": 82.0903097864236,
                    "length_improvement": 0.6081353505372269,
                    "smoothness_improvement": 62.22119106902168,
                    "objective_score": 25.303080101594528
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.009473919868469238,
                    "num_nodes_avg": 232.1,
                    "path_length_avg": 309.7098401574599,
                    "smoothness_avg": 0.0063037920317717076,
                    "success_improvement": 0.0,
                    "time_improvement": 94.13253372835166,
                    "length_improvement": -3.3900591480309807,
                    "smoothness_improvement": 62.20110941536065,
                    "objective_score": 26.516730176763712
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.0069907188415527345,
                    "num_nodes_avg": 156.4,
                    "path_length_avg": 156.13971391106816,
                    "smoothness_avg": 0.012882547888137738,
                    "success_improvement": 0.0,
                    "time_improvement": 85.88324787559279,
                    "length_improvement": -3.7005634055365793,
                    "smoothness_improvement": 63.865058246339665,
                    "objective_score": 23.863961610587587
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "initial",
          "algorithm_description": "This algorithm is a bidirectional extension of RRT* that grows two trees from start and goal while optimizing paths via rewiring. It combines RRT*\u2018s asymptotic optimality with RRT-Connect\u2019s fast convergence through connection attempts between the trees.",
          "planning_mechanism": "The planner alternates growing two trees with sampling, extension, and rewiring. After each extension, it attempts to connect both trees. When connection is successful, a rewired optimal path is extracted across both trees.",
          "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, radius: float = 10.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.radius = radius\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n        nodes = []\n        edges = []\n        success_state = False\n        extracted_path = []\n\n        for iter in range(self.max_iter):\n            rand = self._sample_free(bounds, obstacles, is_3d)\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest = self._nearest(tree_a, rand)\n                new_pos = self._steer(nearest.position, rand, self.step_size)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                    continue\n\n                new_node = Node(new_pos)\n                near_nodes = self._near(tree_a, new_pos, self.radius)\n                min_cost = nearest.cost + self._distance(nearest.position, new_pos)\n                min_parent = nearest\n\n                for near in near_nodes:\n                    cost = near.cost + self._distance(near.position, new_pos)\n                    if cost < min_cost and not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d):\n                        min_cost = cost\n                        min_parent = near\n\n                new_node.parent = min_parent\n                new_node.cost = min_cost\n                min_parent.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((min_parent, new_node))\n\n                for near in near_nodes:\n                    if near == min_parent:\n                        continue\n                    new_cost = new_node.cost + self._distance(new_node.position, near.position)\n                    if new_cost < near.cost and not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                        if near.parent:\n                            edges.remove((near.parent, near))\n                        near.parent = new_node\n                        near.cost = new_cost\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n\n                connect_node = self._nearest(tree_b, new_node.position)\n                if self._distance(new_node.position, connect_node.position) < self.step_size and not self._is_edge_in_obstacle(new_node.position, connect_node.position, obstacles, is_3d):\n                    success_state = True\n                    extracted_path = self._extract_path(new_node, connect_node)\n                    return PlannerResult(True, extracted_path, start_tree + goal_tree, edges)\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        while True:\n            point = tuple(random.uniform(0, bounds[i]) for i in range(3 if is_3d else 2))\n            if not self._is_in_obstacle(point, obstacles, is_3d):\n                return point\n\n    def _nearest(self, tree, point):\n        return min(tree, key=lambda node: self._distance(node.position, point))\n\n    def _near(self, tree, point, radius):\n        return [node for node in tree if self._distance(node.position, point) <= radius]\n\n    def _steer(self, from_pos, to_pos, step_size):\n        dist = self._distance(from_pos, to_pos)\n        if dist <= step_size:\n            return to_pos\n        ratio = step_size / dist\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n    def _extract_path(self, node_a, node_b):\n        path_a = []\n        while node_a:\n            path_a.append(node_a.position)\n            node_a = node_a.parent\n        path_b = []\n        while node_b:\n            path_b.append(node_b.position)\n            node_b = node_b.parent\n        return list(reversed(path_a)) + path_b\n\n    def _distance(self, a, b):\n        return math.dist(a, b)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = self._distance(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n    ",
          "objective": -23.76291481494683,
          "time_improvement": 61.0,
          "length_improvement": 8.0,
          "smoothness_improvement": 166.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.012529301643371581,
                    "num_nodes_avg": 131.9,
                    "path_length_avg": 176.77827310097746,
                    "smoothness_avg": 0.01645631271580969,
                    "success_improvement": 0.0,
                    "time_improvement": 48.408166070262766,
                    "length_improvement": 3.105027282357968,
                    "smoothness_improvement": 157.5770294574498,
                    "objective_score": 17.173351337780858
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.01886875629425049,
                    "num_nodes_avg": 256.8,
                    "path_length_avg": 267.7347696890942,
                    "smoothness_avg": 0.010597136127488454,
                    "success_improvement": 0.0,
                    "time_improvement": 88.31404606735866,
                    "length_improvement": 10.622427559723258,
                    "smoothness_improvement": 172.67194536891012,
                    "objective_score": 33.7310300828861
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.026641178131103515,
                    "num_nodes_avg": 304.4,
                    "path_length_avg": 136.29588257526552,
                    "smoothness_avg": 0.02101448639210645,
                    "success_improvement": 0.0,
                    "time_improvement": 46.20196913892299,
                    "length_improvement": 9.478764505998065,
                    "smoothness_improvement": 167.3027157795587,
                    "objective_score": 20.384363024173528
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "initial",
          "algorithm_description": "This algorithm enhances the standard BI-RRT by incorporating an optimization step that rewires nearby nodes to minimize cost, resulting in asymptotically optimal paths. It grows two trees\u2014one from the start and one from the goal\u2014and attempts to connect them while optimizing the path cost dynamically.",
          "planning_mechanism": "The planning mechanism includes sampling a random point, extending each tree toward it, rewiring neighbors within a radius to optimize the cost, and attempting to connect the two trees. When a connection is established, the combined path is extracted from both trees. Node validity and edge collision checks are strictly enforced throughout the process.",
          "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost: float = 0.0):\n        self.position = position              # Tuple[float, ...]\n        self.parent: Optional[\"Node\"] = parent\n        self.cost: float = cost\n        self.children: List[\"Node\"] = []\n        self.valid = True\n\n    def add_child(self, child_node: \"Node\"):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n\nclass Planner:\n    def __init__(\n        self,\n        max_iter: int = 5000,\n        step_size: float = 5.0,\n        gamma_rrt_star: float = 50.0,\n        max_radius: float = 60.0,\n    ):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.gamma_rrt_star = gamma_rrt_star\n        self.max_radius = max_radius\n\n    # ======================= Public API =======================\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        start_root = Node(start_position, parent=None, cost=0.0)\n        goal_root  = Node(goal_position,  parent=None, cost=0.0)\n        nodes.extend([start_root, goal_root])\n\n        tree_a: List[Node] = [start_root]\n        tree_b: List[Node] = [goal_root]\n\n        for _ in range(self.max_iter):\n            rand_point = self._sample_free(bounds, obstacles, is_3d)\n\n            new_a = self._extend_and_rewire(tree_a, rand_point, obstacles, is_3d, nodes, edges, bounds)\n            if new_a is None:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            new_b = self._connect_and_rewire(tree_b, new_a, obstacles, is_3d, nodes, edges, bounds)\n            if new_b:\n                success_state = True\n                path_a = new_a.path_from_root()\n                path_b = new_b.path_from_root()\n                if path_a and path_b and path_a[-1] == path_b[-1]:\n                    path_b = path_b[:-1]\n                extracted_path = path_a + path_b[::-1]\n                break\n\n            tree_a, tree_b = tree_b, tree_a\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        while True:\n            p = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    def _nearest(self, tree: List[Node], point):\n        return min(tree, key=lambda node: math.dist(node.position, point))\n\n    def _steer(self, from_pos, to_pos):\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _near_nodes(self, tree: List[Node], position, bounds) -> List[Node]:\n        n = max(1, len(tree))\n        d = len(position)\n        # \uacf5\uac04 \uc2a4\ucf00\uc77c\uc744 \uac04\ub2e8\ud788 bounds\ub85c \ucd94\uc815 (\uc815\ubc00 X, \uc2e4\uc6a9\uc801)\n        scale = max(1.0, sum(bounds) / d)\n        r_theory = self.gamma_rrt_star * ((math.log(n + 1) / (n + 1)) ** (1.0 / d))\n        radius = max(self.step_size * 2.0, min(self.max_radius, r_theory * 0.5 + scale * 0.02))\n        return [node for node in tree if math.dist(node.position, position) <= radius]\n\n    def _choose_parent_and_add(self, tree, new_pos, obstacles, is_3d, nodes, edges, bounds):\n        nearest = self._nearest(tree, new_pos)\n        neighbors = self._near_nodes(tree, new_pos, bounds)\n\n        min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n        best_parent = nearest\n\n        for nb in neighbors:\n            if not self._is_edge_in_obstacle(nb.position, new_pos, obstacles, is_3d):\n                cand = nb.cost + math.dist(nb.position, new_pos)\n                if cand < min_cost:\n                    min_cost = cand\n                    best_parent = nb\n\n        new_node = Node(new_pos, parent=None, cost=min_cost)\n        best_parent.add_child(new_node)\n        tree.append(new_node)\n        nodes.append(new_node)\n        edges.append((best_parent, new_node))\n        return new_node, neighbors\n\n    def _rewire_from(self, pivot: Node, neighbors: List[Node], obstacles, is_3d, edges):\n        for nb in neighbors:\n            if not self._is_edge_in_obstacle(pivot.position, nb.position, obstacles, is_3d):\n                new_cost = pivot.cost + math.dist(pivot.position, nb.position)\n                if new_cost + 1e-12 < nb.cost:  # \uc791\uc740 \uc218\uce58 \ubc84\ud37c\n                    if nb.parent is not None:\n                        try:\n                            edges.remove((nb.parent, nb))\n                        except ValueError:\n                            pass\n                        if nb in nb.parent.children:\n                            nb.parent.children.remove(nb)\n                    pivot.add_child(nb)\n                    nb.cost = new_cost\n                    edges.append((pivot, nb))\n\n    def _extend_and_rewire(self, tree, sample_point, obstacles, is_3d, nodes, edges, bounds):\n        nearest = self._nearest(tree, sample_point)\n        new_pos = self._steer(nearest.position, sample_point)\n\n        if self._is_in_obstacle(new_pos, obstacles, is_3d):\n            return None\n        if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n            return None\n\n        new_node, neighbors = self._choose_parent_and_add(tree, new_pos, obstacles, is_3d, nodes, edges, bounds)\n        self._rewire_from(new_node, neighbors, obstacles, is_3d, edges)\n        return new_node\n\n    def _connect_and_rewire(self, tree, target_node: Node, obstacles, is_3d, nodes, edges, bounds):\n        nearest = self._nearest(tree, target_node.position)\n\n        while True:\n            new_pos = self._steer(nearest.position, target_node.position)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                return None\n\n            connect_node, neighbors = self._choose_parent_and_add(tree, new_pos, obstacles, is_3d, nodes, edges, bounds)\n            self._rewire_from(connect_node, neighbors, obstacles, is_3d, edges)\n\n            if math.dist(connect_node.position, target_node.position) <= self.step_size:\n                if (not self._is_edge_in_obstacle(connect_node.position, target_node.position, obstacles, is_3d) and\n                    not self._is_in_obstacle(target_node.position, obstacles, is_3d)):\n                    final_node = Node(target_node.position, parent=None, cost=connect_node.cost + math.dist(connect_node.position, target_node.position))\n                    connect_node.add_child(final_node)\n                    tree.append(final_node)\n                    nodes.append(final_node)\n                    edges.append((connect_node, final_node))\n                    return final_node\n                else:\n                    return None\n\n            nearest = connect_node\n\n        \n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n        \n        \n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n",
          "objective": -22.142109273517423,
          "time_improvement": 49.0,
          "length_improvement": 11.0,
          "smoothness_improvement": 177.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.018251991271972655,
                    "num_nodes_avg": 78.7,
                    "path_length_avg": 175.55592835957023,
                    "smoothness_avg": 0.017196193462405217,
                    "success_improvement": 0.0,
                    "time_improvement": 24.843879619675935,
                    "length_improvement": 3.775013804415195,
                    "smoothness_improvement": 169.1577698184268,
                    "objective_score": 10.563961017644031
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.04780585765838623,
                    "num_nodes_avg": 302.9,
                    "path_length_avg": 259.03658233660315,
                    "smoothness_avg": 0.01078988487631875,
                    "success_improvement": 0.0,
                    "time_improvement": 70.39248153962646,
                    "length_improvement": 13.526132861425937,
                    "smoothness_improvement": 177.6315095076258,
                    "objective_score": 30.121581726281626
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.023344540596008302,
                    "num_nodes_avg": 176.0,
                    "path_length_avg": 128.09376742543256,
                    "smoothness_avg": 0.022442540549775757,
                    "success_improvement": 0.0,
                    "time_improvement": 52.85905490960737,
                    "length_improvement": 14.926218845764677,
                    "smoothness_improvement": 185.467459257119,
                    "objective_score": 25.74078507662661
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "initial",
          "algorithm_description": "This algorithm is a dual-tree variant of Rapidly-exploring Random Tree (RRT) that grows two trees from the start and goal positions, attempting to connect them as they expand. It is efficient for single-query problems due to its bidirectional search and reduced redundant exploration.",
          "planning_mechanism": "The planner alternates between growing the start and goal trees by extending towards randomly sampled points. Each extension step involves checking for collision-free motion and attempting to connect the two trees. The algorithm terminates when a valid path is formed connecting the trees.",
          "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n        nodes = []\n        edges = []\n        success_state = False\n        extracted_path = []\n\n        for iter in range(self.max_iter):\n            rand = self._sample_free(bounds, obstacles, is_3d)\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest = self._nearest(tree_a, rand)\n                new_pos = self._steer(nearest.position, rand, self.step_size)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                    continue\n                new_node = Node(new_pos, parent=nearest, cost=nearest.cost + self._distance(nearest.position, new_pos))\n                nearest.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((nearest, new_node))\n\n                connect_node = self._nearest(tree_b, new_pos)\n                if self._connect_trees(new_node, connect_node, obstacles, is_3d, tree_b, nodes, edges):\n                    success_state = True\n                    extracted_path = self._extract_path(new_node, connect_node)\n                    return PlannerResult(True, extracted_path, start_tree + goal_tree, edges)\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        while True:\n            if is_3d:\n                point = tuple(random.uniform(0, bounds[i]) for i in range(3))\n            else:\n                point = tuple(random.uniform(0, bounds[i]) for i in range(2))\n            if not self._is_in_obstacle(point, obstacles, is_3d):\n                return point\n\n    def _nearest(self, tree, point):\n        return min(tree, key=lambda node: self._distance(node.position, point))\n\n    def _steer(self, from_pos, to_pos, step_size):\n        dist = self._distance(from_pos, to_pos)\n        if dist <= step_size:\n            return to_pos\n        ratio = step_size / dist\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n    def _connect_trees(self, node_a, node_b, obstacles, is_3d, tree, nodes, edges):\n        from_pos = node_a.position\n        to_pos = node_b.position\n        if self._is_edge_in_obstacle(from_pos, to_pos, obstacles, is_3d):\n            return False\n        curr = node_b\n        path = []\n        while True:\n            new_pos = self._steer(curr.position, from_pos, self.step_size)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return False\n            if self._is_edge_in_obstacle(curr.position, new_pos, obstacles, is_3d):\n                return False\n            new_node = Node(new_pos, parent=curr, cost=curr.cost + self._distance(curr.position, new_pos))\n            curr.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((curr, new_node))\n            if self._distance(new_pos, from_pos) < self.step_size:\n                new_node_final = Node(from_pos, parent=new_node, cost=new_node.cost + self._distance(new_pos, from_pos))\n                new_node.add_child(new_node_final)\n                tree.append(new_node_final)\n                nodes.append(new_node_final)\n                edges.append((new_node, new_node_final))\n                return True\n            curr = new_node\n\n    def _extract_path(self, node_a, node_b):\n        path_a = []\n        while node_a:\n            path_a.append(node_a.position)\n            node_a = node_a.parent\n        path_b = []\n        while node_b:\n            path_b.append(node_b.position)\n            node_b = node_b.parent\n        return list(reversed(path_a)) + path_b\n\n    def _distance(self, a, b):\n        return math.dist(a, b)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = self._distance(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n    ",
          "objective": -18.199350067879823,
          "time_improvement": 67.0,
          "length_improvement": -4.0,
          "smoothness_improvement": 78.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.009241986274719238,
                    "num_nodes_avg": 98.6,
                    "path_length_avg": 188.60059541559173,
                    "smoothness_avg": 0.011107369580525531,
                    "success_improvement": 0.0,
                    "time_improvement": 61.94432581815326,
                    "length_improvement": -3.3749749149674124,
                    "smoothness_improvement": 73.85445397432328,
                    "objective_score": 16.927585066337148
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.013762164115905761,
                    "num_nodes_avg": 215.1,
                    "path_length_avg": 298.4716236591105,
                    "smoothness_avg": 0.007330142954732018,
                    "success_improvement": 0.0,
                    "time_improvement": 91.47670289636794,
                    "length_improvement": 0.3615809932444448,
                    "smoothness_improvement": 88.6098579138185,
                    "objective_score": 28.103008754426142
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.02535843849182129,
                    "num_nodes_avg": 323.5,
                    "path_length_avg": 164.19293370544943,
                    "smoothness_avg": 0.013510302519313377,
                    "success_improvement": 0.0,
                    "time_improvement": 48.79227750896705,
                    "length_improvement": -9.049128539847096,
                    "smoothness_improvement": 71.85005081886685,
                    "objective_score": 9.567456382876191
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "time_expert",
          "algorithm_description": "An enhanced bidirectional RRT* variant that incorporates adaptive neighbor radius shrinking to concentrate rewiring efforts for local optimality, an efficient nearest-neighbor caching structure for faster lookups, and progressive informed sampling with dynamic ellipsoidal restriction. The planner prioritizes early discovery and incremental path improvement, applies a smooth path shortcutting post-processing step to reduce path length and curvature, and enforces robust termination criteria based on stagnation and solution quality thresholds to minimize planning time.",
          "planning_mechanism": "The planner grows two trees alternately with rewiring using an adaptive radius, restricts sampling progressively to a shrinking ellipsoid after finding a solution to focus on promising areas, connects the trees upon proximity, and applies a final shortcut smoothing pass to improve total path length and smoothness before returning the best feasible path found within iteration and time limits.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def path_from_root(self):\n        path = []\n        n = self\n        while n is not None:\n            path.append(n.position)\n            n = n.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=6.0, n_near_const=35, \n                 max_no_improve=80, improve_tol=1e-6, shortcut_iters=150):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.n_near_const = n_near_const  # base neighbor count for adaptive radius\n        self.max_no_improve = max_no_improve\n        self.improve_tol = improve_tol\n        self.shortcut_iters = shortcut_iters\n\n    def plan(self, map) -> 'PlannerResult':\n        # --- Local helper imports & definitions ---\n        import math, random, time\n\n        start = tuple(map.start)\n        goal = tuple(map.goal)\n        bounds = tuple(map.size)\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        dist = lambda a, b: math.dist(a, b)\n\n        # Node collections\n        start_tree = [Node(start)]\n        goal_tree = [Node(goal)]\n        nodes_all = start_tree + goal_tree\n        edges = []\n\n        c_min = dist(start, goal)\n        best_cost = float('inf')\n        best_path = []\n        found_solution = False\n\n        # To reduce overhead of nearest neighbor search, cache all nodes' positions lists for faster processing\n        # We implement simple linear searches but with caching and limit radius dynamically to reduce checks\n\n        # Adaptive radius for near-node rewiring, shrinks with best_cost to focus local improvements\n        # r_n = min((gamma * (log(n)/n))^(1/d), max_radius) but approximate w/o logs for lightweight\n        def adaptive_radius(n_nodes, c_best):\n            # Use gamma ~ 30 (typical for 2D), avoid zero or undefined\n            gamma = self.n_near_const\n            if n_nodes == 0:\n                return self.step_size * 2.5\n            r = min((gamma * (math.log(n_nodes)/n_nodes))**(1/dim), self.step_size * 5)\n            # Shrink with c_best, stronger around best solution to focus rewiring\n            if c_best == float('inf'):\n                return r\n            shrink_factor = max(0.25, c_best / (c_min * 3))\n            return max(self.step_size*0.75, r * shrink_factor)\n\n        def in_obstacle(p):\n            px, py, pz = (p + (0,))[:3]\n            for obs in obstacles:\n                if is_3d:\n                    ox, oy, oz, ow, oh, od = obs\n                    if ox <= px <= ox + ow and oy <= py <= oy + oh and oz <= pz <= oz + od:\n                        return True\n                else:\n                    ox, oy, ow, oh = obs\n                    if ox <= px <= ox + ow and oy <= py <= oy + oh:\n                        return True\n            return False\n\n        def edge_obstacle(f, t, resolution=1.0):\n            length = dist(f, t)\n            if length < 1e-10:\n                return False\n            steps = max(2, int(length / resolution))\n            for i in range(steps + 1):\n                inter = tuple(f[j] + (t[j] - f[j]) * (i / steps) for j in range(dim))\n                if in_obstacle(inter):\n                    return True\n            return False\n\n        def steer(frm, to):\n            d = dist(frm, to)\n            if d <= self.step_size:\n                return to\n            ratio = self.step_size / d\n            return tuple(frm[i] + (to[i] - frm[i]) * ratio for i in range(dim))\n\n        # Efficient nearest neighbor search (linear but with early exit)\n        def nearest(tree, p):\n            best = None\n            best_d = float('inf')\n            px = p\n            for n in tree:\n                d2 = 0.0\n                for i in range(dim):\n                    dd = n.position[i] - px[i]\n                    d2 += dd*dd\n                    if d2 >= best_d*best_d:\n                        break\n                else:\n                    d = math.sqrt(d2)\n                    if d < best_d:\n                        best = n\n                        best_d = d\n            return best\n\n        # Near nodes within radius (adaptive radius)\n        def near_nodes(tree, p, radius):\n            r2 = radius*radius\n            result = []\n            px = p\n            for n in tree:\n                d2 = 0.0\n                for i in range(dim):\n                    dd = n.position[i] - px[i]\n                    d2 += dd*dd\n                    if d2 > r2:\n                        break\n                if d2 <= r2:\n                    result.append(n)\n            return result\n\n        # Extract path from start via parent chain\n        def extract_path(node_start_root):\n            return node_start_root.path_from_root()\n\n        # Extract full path from two connection nodes (start tree and goal tree)\n        def connect_path(n_start, n_goal):\n            path_start = extract_path(n_start)\n            path_goal_rev = extract_path(n_goal)\n            path_goal = path_goal_rev[::-1]\n            if len(path_start) > 0 and len(path_goal) > 0 and path_start[-1] == path_goal[0]:\n                return path_start + path_goal[1:]\n            else:\n                return path_start + path_goal\n\n        # Ellipsoidal informed sampling centered between start and goal, focused progressively as c_best shrinks\n        def ellipsoid_sample(c_best):\n            if c_best == float('inf'):\n                return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n\n            center = tuple((start[i] + goal[i]) * 0.5 for i in range(dim))\n            a1 = [goal[i] - start[i] for i in range(dim)]\n            norm_a1 = math.sqrt(sum(x * x for x in a1))\n            if norm_a1 < 1e-12:\n                return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n            unit_a1 = [x / norm_a1 for x in a1]\n\n            # Orthonormal basis U with unit_a1 first vector\n            U = [unit_a1]\n            for idx in range(dim - 1):\n                base = [0] * dim\n                base[(idx + 1) % dim] = 1\n                for u in U:\n                    proj = sum(base[j] * u[j] for j in range(dim))\n                    base = [base[j] - proj * u[j] for j in range(dim)]\n                norm_base = math.sqrt(sum(x * x for x in base))\n                if norm_base > 1e-12:\n                    U.append([x / norm_base for x in base])\n                else:\n                    U.append([0] * dim)\n\n            r1 = c_best * 0.5\n            val = c_best * c_best - c_min * c_min\n            r2 = math.sqrt(val) * 0.5 if val > 0 else 0.0\n            radii = [r1] + [r2] * (dim - 1)\n\n            while True:\n                x_ball = [random.gauss(0, 1) for _ in range(dim)]\n                norm_ball = math.sqrt(sum(x * x for x in x_ball))\n                if norm_ball < 1e-12:\n                    continue\n                unit_ball = [x / norm_ball for x in x_ball]\n                u = random.random() ** (1.0 / dim)\n                point_ball = [coord * u for coord in unit_ball]\n                point_scaled = [radii[i] * point_ball[i] for i in range(dim)]\n\n                point_rotated = [0.0] * dim\n                for i in range(dim):\n                    for j in range(dim):\n                        point_rotated[j] += point_scaled[i] * U[i][j]\n\n                sample = tuple(center[i] + point_rotated[i] for i in range(dim))\n\n                if all(0.0 <= sample[i] <= bounds[i] for i in range(dim)):\n                    return sample\n\n        # Path shortcutting by attempting to connect non-adjacent nodes directly if collision free\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            changed = True\n            iter_count = 0\n            while changed and iter_count < self.shortcut_iters:\n                changed = False\n                iter_count += 1\n                i = 0\n                while i < len(path) - 2:\n                    j = min(len(path) - 1, i + 2 + random.randint(0, 3))\n                    if j > i + 1 and not edge_obstacle(path[i], path[j]):\n                        # Shortcut feasible, remove intermediate nodes\n                        path = path[:i + 1] + path[j:]\n                        changed = True\n                        break\n                    i += 1\n            return path\n\n        # Add node to tree selecting best parent among near nodes\n        def add_node(tree, new_pos, nodes_all, edges, c_best):\n            nn = nearest(tree, new_pos)\n            new_pos_steered = steer(nn.position, new_pos)\n            if in_obstacle(new_pos_steered) or edge_obstacle(nn.position, new_pos_steered):\n                return None\n\n            n_nodes = len(nodes_all)\n            radius = adaptive_radius(n_nodes, c_best)\n            near = near_nodes(tree, new_pos_steered, radius)\n\n            best_parent = nn\n            best_cost = nn.cost + dist(nn.position, new_pos_steered)\n            for near_node in near:\n                if near_node == nn:\n                    continue\n                cand_cost = near_node.cost + dist(near_node.position, new_pos_steered)\n                if cand_cost + self.improve_tol < best_cost and not edge_obstacle(near_node.position, new_pos_steered):\n                    best_parent = near_node\n                    best_cost = cand_cost\n\n            new_node = Node(new_pos_steered)\n            best_parent.add_child(new_node)\n            new_node.cost = best_cost\n            tree.append(new_node)\n            nodes_all.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors to new node if beneficial\n            for near_node in near:\n                if near_node is best_parent:\n                    continue\n                alt_cost = new_node.cost + dist(new_node.position, near_node.position)\n                if alt_cost + self.improve_tol < near_node.cost:\n                    if not edge_obstacle(new_node.position, near_node.position):\n                        # Remove old parent-child relationship\n                        if near_node.parent:\n                            near_node.parent.remove_child(near_node)\n                            try:\n                                edges.remove((near_node.parent, near_node))\n                            except Exception:\n                                pass\n                        new_node.add_child(near_node)\n                        near_node.cost = alt_cost\n                        edges.append((new_node, near_node))\n\n            return new_node\n\n        no_improve_count = 0\n        last_best_cost = float('inf')\n        start_time = time.time()\n\n        for iter_count in range(self.max_iter):\n            sample_pt = ellipsoid_sample(best_cost if found_solution else float('inf'))\n\n            # Alternate tree growing: start tree first odd iters, goal second even iters\n            if iter_count % 2 == 0:\n                tree_a = start_tree\n                tree_b = goal_tree\n            else:\n                tree_a = goal_tree\n                tree_b = start_tree\n\n            new_node = add_node(tree_a, sample_pt, nodes_all, edges, best_cost)\n            if new_node is None:\n                # Could not add node (collision), continue\n                continue\n\n            # Attempt connection to other tree\n            nearest_b = nearest(tree_b, new_node.position)\n            if dist(new_node.position, nearest_b.position) <= self.step_size:\n                if not edge_obstacle(new_node.position, nearest_b.position):\n                    # Connect path candidates\n                    path_candidate = connect_path(new_node, nearest_b)\n                    candidate_cost = new_node.cost + dist(new_node.position, nearest_b.position) + nearest_b.cost\n\n                    if candidate_cost + self.improve_tol < best_cost:\n                        best_cost = candidate_cost\n                        best_path = path_candidate\n                        found_solution = True\n                        no_improve_count = 0\n                    else:\n                        no_improve_count += 1\n                else:\n                    no_improve_count += 1\n            else:\n                if found_solution:\n                    no_improve_count += 1\n\n            # Early termination when no meaningful improvement for long\n            if found_solution and no_improve_count >= self.max_no_improve:\n                break\n\n            # Restart no improve count if significant improvement detected\n            if found_solution and best_cost + self.improve_tol < last_best_cost:\n                no_improve_count = 0\n                last_best_cost = best_cost\n\n        # Final path smoothing via shortcutting if solution found\n        if found_solution and len(best_path) > 2:\n            best_path = shortcut_path(best_path)\n\n        if found_solution:\n            return PlannerResult(True, best_path, nodes_all, edges)\n        else:\n            return PlannerResult(False, [], nodes_all, edges)",
          "objective": -12.90672,
          "time_improvement": -15.0,
          "length_improvement": 14.0,
          "smoothness_improvement": 1865.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.03639078140258789,
                    "num_nodes_avg": 237.0,
                    "path_length_avg": 168.02193260520104,
                    "smoothness_avg": 0.04984815517379989,
                    "success_improvement": 0.0,
                    "time_improvement": -49.84611306639963,
                    "length_improvement": 7.9045162611873945,
                    "smoothness_improvement": 680.2318754714814,
                    "objective_score": -6.809964785850045
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.046571874618530275,
                    "num_nodes_avg": 354.8,
                    "path_length_avg": 240.5937710240402,
                    "smoothness_avg": 0.12631217131652547,
                    "success_improvement": 0.0,
                    "time_improvement": 71.15672210389786,
                    "length_improvement": 19.68287412444948,
                    "smoothness_improvement": 3150.1031469538016,
                    "objective_score": 48.907256840608056
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.08302063941955566,
                    "num_nodes_avg": 467.5,
                    "path_length_avg": 130.26416789587537,
                    "smoothness_avg": 0.14664374877167838,
                    "success_improvement": 0.0,
                    "time_improvement": -67.64825112539418,
                    "length_improvement": 13.484742196660818,
                    "smoothness_improvement": 1765.2976602601516,
                    "objective_score": -3.377141718321006
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m2",
          "algorithm_description": "This algorithm is an enhanced bidirectional RRT* variant utilizing adaptive neighbor radius based on tree size and iteration progress for improved rewiring efficiency and path optimality. It integrates an ellipsoidal informed sampling strategy after the initial solution to focus exploration within promising regions. The adaptive neighbor radius dynamically contracts with iterations, balancing exploration and exploitation. The connect procedure attempts direct connections to reduce unnecessary intermediate nodes, improving path length and smoothness. Early stopping criteria based on solution improvement stagnation reduce planning time. Consistent node and edge collision checks prevent invalid expansions, maintaining robustness. The algorithm outputs the lowest cost path found within time and iteration limits.",
          "planning_mechanism": "The planner grows two trees from start and goal positions, alternating expansions each iteration. Initially, it samples uniformly, then focuses sampling inside an ellipsoid defined by current best path cost. Each expansion attempts to add a new node via steering and selects the best parent considering nodes within an adaptive radius that decreases as iterations proceed. Local rewiring optimizes neighbors' connections when beneficial. A direct connect is attempted between the newly added node and the opposite tree to quickly form a solution. The best path is updated when trees meet. The planning stops early if no significant improvements occur over a threshold or upon timeout.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position  # Tuple[float, ...]\n        self.parent = parent      # Node or None\n        self.cost = cost          # cost from root to this node\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(\n        self,\n        max_iter=6000,\n        step_size=4.0,\n        max_neighbor_radius=30.0,\n        min_neighbor_radius=6.0,\n        improvement_tol=1e-6,\n        max_no_improve=100,\n        time_limit_sec=30.0,\n        post_opt_iters=300\n    ):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.max_neighbor_radius = max_neighbor_radius\n        self.min_neighbor_radius = min_neighbor_radius\n        self.improvement_tol = improvement_tol\n        self.max_no_improve = max_no_improve\n        self.time_limit_sec = time_limit_sec\n        self.post_opt_iters = post_opt_iters\n\n    def plan(self, map):\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        best_path = []\n        best_cost = float('inf')\n        c_min = math.dist(start_pos, goal_pos)\n        found_first = False\n        no_improve_count = 0\n        post_opt_count = 0\n        start_time = time.time()\n\n        def adaptive_radius(n, iter_i):\n            # Adaptive radius contracts as iteration increases, ensuring fewer neighbors later for efficiency\n            # Weighted blend with tree size and iteration progress\n            factor = max(0.0, 1.0 - iter_i / self.max_iter)\n            radius = max(self.min_neighbor_radius, min(self.max_neighbor_radius, self.max_neighbor_radius*factor*(math.log(n+1)/(n+1))**(1/dim)))\n            return radius\n\n        def within_bounds(pos):\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d = obs\n                    px,py,pz = pos\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                        return True\n                else:\n                    x,y,w,h = obs\n                    px,py = pos\n                    if x <= px <= x+w and y <= py <= y+h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(from_p, to_p, resolution=1.0):\n            dist = math.dist(from_p, to_p)\n            if dist < 1e-12:\n                return False\n            steps = max(2, int(dist / resolution))\n            for i in range(steps + 1):\n                interp = tuple(from_p[d] + (to_p[d] - from_p[d])*i/steps for d in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def steer(from_p, to_p):\n            dist = math.dist(from_p, to_p)\n            if dist <= self.step_size:\n                return to_p\n            ratio = self.step_size / dist\n            return tuple(from_p[d] + (to_p[d] - from_p[d]) * ratio for d in range(dim))\n\n        def neighbors(tree, pos, radius):\n            radius_sq = radius*radius\n            return [n for n in tree if ( (sum((n.position[d] - pos[d])**2 for d in range(dim))) <= radius_sq )]\n\n        def choose_parent_and_add(tree, new_pos, iter_i):\n            n = len(tree)\n            radius = adaptive_radius(n, iter_i)\n            nbrs = neighbors(tree, new_pos, radius)\n\n            nearest = min(tree, key=lambda node: math.dist(node.position, new_pos))\n            min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n            best_parent = nearest\n\n            for nb in nbrs:\n                if is_edge_in_obstacle(nb.position, new_pos):\n                    continue\n                c = nb.cost + math.dist(nb.position, new_pos)\n                if c < min_cost:\n                    min_cost = c\n                    best_parent = nb\n\n            new_node = Node(new_pos, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n            return new_node, nbrs, radius\n\n        def rewire(pivot, neighbors_list):\n            for nb in neighbors_list:\n                if is_edge_in_obstacle(pivot.position, nb.position):\n                    continue\n                new_cost = pivot.cost + math.dist(pivot.position, nb.position)\n                if new_cost + 1e-12 < nb.cost:\n                    # Rewire nb to pivot\n                    if nb.parent is not None:\n                        try:\n                            edges.remove((nb.parent, nb))\n                        except ValueError:\n                            pass\n                        if nb in nb.parent.children:\n                            nb.parent.children.remove(nb)\n                    pivot.add_child(nb)\n                    nb.cost = new_cost\n                    edges.append((pivot, nb))\n\n        def direct_connect(tree, target_node, iter_i):\n            nearest = min(tree, key=lambda n: math.dist(n.position, target_node.position))\n            # attempt a direct connection from nearest to target_node if possible\n            if (not is_edge_in_obstacle(nearest.position, target_node.position) and\n                not is_in_obstacle(target_node.position)):\n                # connect with one edge\n                new_node = Node(target_node.position, cost=nearest.cost + math.dist(nearest.position, target_node.position))\n                nearest.add_child(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((nearest, new_node))\n                return new_node\n\n            # else do incremental connection with steering and rewiring\n            current = nearest\n            for _ in range( int(math.ceil(math.dist(current.position, target_node.position) / self.step_size)) ):\n                new_pos = steer(current.position, target_node.position)\n                if not within_bounds(new_pos) or is_in_obstacle(new_pos) or is_edge_in_obstacle(current.position, new_pos):\n                    return None\n                new_node, nbrs, _ = choose_parent_and_add(tree, new_pos, iter_i)\n                rewire(new_node, nbrs)\n                if math.dist(new_node.position, target_node.position) <= self.step_size:\n                    if not is_edge_in_obstacle(new_node.position, target_node.position) and not is_in_obstacle(target_node.position):\n                        final_node = Node(target_node.position,\n                                          cost=new_node.cost + math.dist(new_node.position, target_node.position))\n                        new_node.add_child(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n                current = new_node\n            return None\n\n        def sample_informed():\n            if not found_first or best_cost == float('inf') or c_min < 1e-12:\n                # uniform sampling\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            # else sample inside prolate hyperspheroid:\n            # center\n            center = tuple((start_pos[d] + goal_pos[d])/2.0 for d in range(dim))\n            # unit direction vector from start to goal\n            unit_dir = []\n            dist_sg = c_min\n            for d in range(dim):\n                unit_dir.append((goal_pos[d] - start_pos[d]) / dist_sg)\n            # radii\n            r1 = best_cost / 2.0\n            val = best_cost*best_cost - c_min*c_min\n            val = max(val, 0.0)\n            r_other = math.sqrt(val) / 2.0\n\n            # construct orthonormal basis\n            if dim == 2:\n                a1 = unit_dir\n                a2 = (-a1[1], a1[0])\n                basis = (a1, a2)\n                radii = (r1, r_other)\n            else:\n                a1 = unit_dir\n                # pick reference vector not parallel to a1\n                ref = (1.0,0.0,0.0) if abs(a1[0]) < 0.9 else (0.0,1.0,0.0)\n                b2 = _cross(a1, ref)\n                n_b2 = _norm(b2)\n                if n_b2 < 1e-12:\n                    ref = (0.0,0.0,1.0)\n                    b2 = _cross(a1, ref)\n                    n_b2 = _norm(b2)\n                b2 = tuple(x / n_b2 for x in b2)\n                b3 = _cross(a1, b2)\n                basis = (a1, b2, b3)\n                radii = (r1, r_other, r_other)\n\n            u = _sample_unit_ball(dim)\n            mapped = []\n            for d in range(dim):\n                val = center[d]\n                for i in range(dim):\n                    val += basis[i][d] * radii[i] * u[i]\n                # clamp inside bounds\n                val = min(max(val, 0.0), bounds[d])\n                mapped.append(val)\n            return tuple(mapped)\n\n        def _sample_unit_ball(dim):\n            while True:\n                vec = [random.gauss(0.0, 1.0) for _ in range(dim)]\n                nrm = math.sqrt(sum(v*v for v in vec))\n                if nrm < 1e-12:\n                    continue\n                vec = [v/nrm for v in vec]\n                r = random.random()**(1.0/dim)\n                return tuple(vec[i]*r for i in range(dim))\n\n        def _cross(a,b):\n            return (a[1]*b[2]-a[2]*b[1], a[2]*b[0]-a[0]*b[2], a[0]*b[1]-a[1]*b[0])\n\n        def _norm(v):\n            return math.sqrt(sum(x*x for x in v))\n\n        neighbor_radius_cache = None\n\n        for it in range(self.max_iter):\n            if time.time() - start_time > self.time_limit_sec:\n                break\n\n            tree_a, tree_b = (start_tree, goal_tree) if (it % 2 == 0) else (goal_tree, start_tree)\n            x_rand = sample_informed()\n\n            if not within_bounds(x_rand) or is_in_obstacle(x_rand):\n                if found_first:\n                    post_opt_count += 1\n                    no_improve_count += 1\n                    if post_opt_count >= self.post_opt_iters or no_improve_count >= self.max_no_improve:\n                        break\n                continue\n\n            nearest = min(tree_a, key=lambda node: math.dist(node.position, x_rand))\n            new_pos = steer(nearest.position, x_rand)\n            if not within_bounds(new_pos) or is_in_obstacle(new_pos) or is_edge_in_obstacle(nearest.position, new_pos):\n                if found_first:\n                    post_opt_count += 1\n                    no_improve_count += 1\n                    if post_opt_count >= self.post_opt_iters or no_improve_count >= self.max_no_improve:\n                        break\n                continue\n\n            new_node, neighbors_list, nradius = choose_parent_and_add(tree_a, new_pos, it)\n            rewire(new_node, neighbors_list)\n\n            # Attempt direct connect (not iterative connect) from tree_b to newly added node:\n            meet_node = direct_connect(tree_b, new_node, it)\n            if meet_node is not None:\n                if it % 2 == 0:\n                    path_a = new_node.path_from_root()\n                    path_b = meet_node.path_from_root()\n                else:\n                    path_a = meet_node.path_from_root()\n                    path_b = new_node.path_from_root()\n                if path_a and path_b and path_a[-1] == path_b[-1]:\n                    merged_path = path_a + path_b[-2::-1]\n                else:\n                    merged_path = path_a + path_b[::-1]\n\n                total_cost = sum(math.dist(merged_path[i], merged_path[i+1]) for i in range(len(merged_path)-1))\n                if total_cost + self.improvement_tol < best_cost:\n                    best_cost = total_cost\n                    best_path = merged_path\n                    found_first = True\n                    post_opt_count = 0\n                    no_improve_count = 0\n                else:\n                    if found_first:\n                        post_opt_count += 1\n                        no_improve_count += 1\n                if found_first and (post_opt_count >= self.post_opt_iters or no_improve_count >= self.max_no_improve):\n                    break\n            else:\n                if found_first:\n                    post_opt_count += 1\n                    no_improve_count += 1\n                    if post_opt_count >= self.post_opt_iters or no_improve_count >= self.max_no_improve:\n                        break\n\n        return PlannerResult(success=found_first, path=best_path, nodes=nodes, edges=edges)",
          "objective": -10.44388,
          "time_improvement": 10.0,
          "length_improvement": 11.0,
          "smoothness_improvement": 142.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.02786121368408203,
                    "num_nodes_avg": 139.4,
                    "path_length_avg": 155.87313188725165,
                    "smoothness_avg": 0.017886324975422283,
                    "success_improvement": 0.0,
                    "time_improvement": -14.723960710972353,
                    "length_improvement": 14.563466444762122,
                    "smoothness_improvement": 179.95982664171103,
                    "objective_score": 5.220690786774123
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.06340575218200684,
                    "num_nodes_avg": 418.9,
                    "path_length_avg": 277.6271906369829,
                    "smoothness_avg": 0.008053558435153495,
                    "success_improvement": 0.0,
                    "time_improvement": 60.731026067193284,
                    "length_improvement": 7.320052709768729,
                    "smoothness_improvement": 107.22385928017246,
                    "objective_score": 23.14745874242008
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.05672965049743652,
                    "num_nodes_avg": 331.4,
                    "path_length_avg": 133.93060882634086,
                    "smoothness_avg": 0.018882342363182564,
                    "success_improvement": 0.0,
                    "time_improvement": -14.557377049180326,
                    "length_improvement": 11.049666707801231,
                    "smoothness_improvement": 140.18200111014838,
                    "objective_score": 2.9634969154773834
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m2",
          "algorithm_description": "Hybrid bidirectional RRT* with adaptive neighbor radius, informed ellipsoidal sampling, enhanced rewiring, and dynamic early stopping for improved efficiency, path length, and smoothness. The planner alternates expanding two trees growing from start and goal, focuses sampling inside a prolate hyperspheroid once a solution is found to accelerate convergence, adaptively adjusts the neighbor radius based on node density to balance rewiring cost and solution quality, and employs robust rewiring strategies along with early stopping criteria triggered by stagnation in cost improvement.",
          "planning_mechanism": "The planner initializes two trees from start and goal respectively. It alternates growth between the two trees each iteration by sampling first uniformly and then inside the ellipsoid bounded by current best solution cost. Each new sample is connected with the lowest-cost parent within an adaptive neighbor radius, followed by rewiring of nearby nodes to improve path costs. The opposite tree is greedily connected toward the newly added node using rewiring as well. Upon connecting the two trees, the planner updates the best path and restarts a post-optimization phase with limited iterations or until improvements stall. Using incremental nearest neighbor radius adjustment and strict collision checking, the algorithm efficiently reduces runtime and yields smoother, shorter paths with high success rates.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n\n    def path_from_root(self):\n        path = []\n        n = self\n        while n is not None:\n            path.append(n.position)\n            n = n.parent\n        return path[::-1]\nclass Planner:\n    def __init__(\n        self,\n        max_iter: int = 6000,\n        step_size: float = 4.0,\n        neighbor_factor: float = 1.5,\n        k_nearest_min: int = 10,\n        post_opt_iters: int = 300,\n        max_no_improve: int = 120,\n        improve_tol: float = 1e-5,\n        time_limit_sec: float = 30.0,\n    ):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.neighbor_factor = neighbor_factor  # multiplier for adaptive radius\n        self.k_nearest_min = k_nearest_min  # minimum neighbors for rewiring\n        self.post_opt_iters = post_opt_iters\n        self.max_no_improve = max_no_improve\n        self.improve_tol = improve_tol\n        self.time_limit_sec = time_limit_sec\n\n    def plan(self, map) -> PlannerResult:\n        import time\n        import math\n        import random\n\n        bounds = map.size\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        # Initialize trees\n        start_root = Node(start, cost=0.0)\n        goal_root = Node(goal, cost=0.0)\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        # Variables for best path tracking\n        best_cost = float('inf')\n        best_path = []\n        c_min = math.dist(start, goal)\n        found_first_solution = False\n        no_improve_count = 0\n        post_opt_count = 0\n\n        start_time = time.time()\n\n        def within_bounds(p):\n            return all(0.0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_p, to_p):\n            d = dist(from_p, to_p)\n            if d <= self.step_size:\n                return to_p\n            ratio = self.step_size / d\n            return tuple(from_p[d_] + ratio * (to_p[d_] - from_p[d_]) for d_ in range(dim))\n\n        def is_in_obstacle(p):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d_ = obs\n                    px, py, pz = p\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d_:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    px, py = p\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(p1, p2, resolution=1.0):\n            dist_p = dist(p1, p2)\n            steps = max(1, int(dist_p / resolution))\n            for i in range(steps + 1):\n                interp = tuple(p1[d_] + (p2[d_] - p1[d_]) * i / steps for d_ in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def sample_informed(c_best):\n            # Uniform until first solution found\n            if c_best == float('inf') or c_min < 1e-12:\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            # Sample inside prolate hyperspheroid defined by start, goal, c_best\n            center = tuple((start[d] + goal[d]) / 2.0 for d in range(dim))\n            a1_vec = tuple((goal[d] - start[d]) / c_min for d in range(dim))\n            r1 = c_best / 2.0\n            val_sq = max(c_best * c_best - c_min * c_min, 0.0)\n            r_ortho = math.sqrt(val_sq) / 2.0\n\n            # Construct orthonormal basis\n            if dim == 2:\n                a2_vec = (-a1_vec[1], a1_vec[0])\n                basis = (a1_vec, a2_vec)\n                radii = (r1, r_ortho)\n            else:\n                # dim=3\n                def cross(u, v):\n                    return (\n                        u[1]*v[2] - u[2]*v[1],\n                        u[2]*v[0] - u[0]*v[2],\n                        u[0]*v[1] - u[1]*v[0],\n                    )\n                def norm(v):\n                    return math.sqrt(sum(x*x for x in v))\n                def normalize(v):\n                    n_ = norm(v)\n                    if n_ < 1e-12:\n                        return v\n                    return tuple(x / n_ for x in v)\n                ref = (1.0, 0.0, 0.0) if abs(a1_vec[0]) < 0.9 else (0.0, 1.0, 0.0)\n                b2 = normalize(cross(a1_vec, ref))\n                if norm(b2) < 1e-12:\n                    ref = (0.0, 0.0, 1.0)\n                    b2 = normalize(cross(a1_vec, ref))\n                b3 = cross(a1_vec, b2)\n                basis = (a1_vec, b2, b3)\n                radii = (r1, r_ortho, r_ortho)\n\n            # Sample random point in unit n-ball\n            def sample_unit_ball(n):\n                while True:\n                    vec = [random.gauss(0.0, 1.0) for _ in range(n)]\n                    norm_v = math.sqrt(sum(x*x for x in vec))\n                    if norm_v > 1e-12:\n                        vec = [x/norm_v for x in vec]\n                        r = random.random() ** (1.0 / n)\n                        return [x * r for x in vec]\n\n            u = sample_unit_ball(dim)\n            point = [center[d] for d in range(dim)]\n            for i in range(dim):\n                for d_ in range(dim):\n                    point[d_] += basis[i][d_] * radii[i] * u[i]\n            mapped = tuple(min(max(point[d_], 0.0), bounds[d_]) for d_ in range(dim))\n            return mapped\n\n        def nearest(tree, point):\n            # Simple nearest; could be improved with spatial index.\n            return min(tree, key=lambda n: dist(n.position, point))\n\n        def neighbors(tree, point, radius):\n            return [n for n in tree if dist(n.position, point) <= radius]\n\n        def adaptive_radius(num_nodes):\n            # Use formula r = neighbor_factor * (log(n)/n)^{1/dim}\n            # Enforce min radius for initial small trees\n            if num_nodes <= 1:\n                return 30.0\n            val = math.log(num_nodes) / num_nodes\n            if val <= 0.0:\n                return 30.0\n            r = self.neighbor_factor * (val ** (1.0 / dim))\n            # Clamp radius in reasonable bounds\n            return max(min(r, 30.0), 7.0)\n\n        def add_node_with_best_parent(tree, new_pos):\n            # Try best parent minimizing cost + edge validity\n            r = adaptive_radius(len(tree))\n            nbrs = neighbors(tree, new_pos, r)\n            if not nbrs:\n                nearest_node = nearest(tree, new_pos)\n                nbrs = [nearest_node]\n            min_cost = float('inf')\n            best_parent = None\n            for n in nbrs:\n                if is_edge_in_obstacle(n.position, new_pos):\n                    continue\n                cost_ = n.cost + dist(n.position, new_pos)\n                if cost_ < min_cost:\n                    min_cost = cost_\n                    best_parent = n\n            if best_parent is None:\n                return None, []\n            new_node = Node(new_pos, parent=None, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n            return new_node, nbrs\n\n        def rewire(node, nbrs, tree):\n            # Rewire neighbors if cheaper cost via node\n            for n in nbrs:\n                if n == node or n.parent is None:\n                    continue\n                if is_edge_in_obstacle(node.position, n.position):\n                    continue\n                new_cost = node.cost + dist(node.position, n.position)\n                if new_cost + 1e-14 < n.cost:\n                    # Remove old edge\n                    if (n.parent, n) in edges:\n                        edges.remove((n.parent, n))\n                    n.parent.remove_child(n)\n                    node.add_child(n)\n                    n.cost = new_cost\n                    edges.append((node, n))\n\n        def greedy_connect(tree, target_node):\n            # Like RRT-Connect: iteratively steer and add with rewiring until close or blocked\n            current = nearest(tree, target_node.position)\n            while True:\n                new_pos = steer(current.position, target_node.position)\n                if not within_bounds(new_pos):\n                    return None\n                if is_in_obstacle(new_pos) or is_edge_in_obstacle(current.position, new_pos):\n                    return None\n                new_node, nbrs = add_node_with_best_parent(tree, new_pos)\n                if new_node is None:\n                    return None\n                rewire(new_node, nbrs, tree)\n                if dist(new_node.position, target_node.position) <= self.step_size:\n                    # Check final edge connection\n                    if (not is_edge_in_obstacle(new_node.position, target_node.position)) and target_node.valid:\n                        final_node = Node(target_node.position,\n                                         parent=None,\n                                         cost=new_node.cost + dist(new_node.position, target_node.position))\n                        new_node.add_child(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    return None\n                current = new_node\n\n        for it in range(self.max_iter):\n            if time.time() - start_time > self.time_limit_sec:\n                break\n\n            # Alternate tree expansion (connect style)\n            tree_a, tree_b = (start_tree, goal_tree) if (it % 2 == 0) else (goal_tree, start_tree)\n\n            x_rand = sample_informed(best_cost)\n\n            if not within_bounds(x_rand):\n                if found_first_solution:\n                    post_opt_count += 1\n                    no_improve_count += 1\n                    if post_opt_count >= self.post_opt_iters or no_improve_count >= self.max_no_improve:\n                        break\n                continue\n            if is_in_obstacle(x_rand):\n                if found_first_solution:\n                    post_opt_count += 1\n                    no_improve_count += 1\n                    if post_opt_count >= self.post_opt_iters or no_improve_count >= self.max_no_improve:\n                        break\n                continue\n\n            nearest_a = nearest(tree_a, x_rand)\n            new_pos = steer(nearest_a.position, x_rand)\n            if not within_bounds(new_pos):\n                if found_first_solution:\n                    post_opt_count += 1\n                    no_improve_count += 1\n                    if post_opt_count >= self.post_opt_iters or no_improve_count >= self.max_no_improve:\n                        break\n                continue\n            if is_in_obstacle(new_pos) or is_edge_in_obstacle(nearest_a.position, new_pos):\n                if found_first_solution:\n                    post_opt_count += 1\n                    no_improve_count += 1\n                    if post_opt_count >= self.post_opt_iters or no_improve_count >= self.max_no_improve:\n                        break\n                continue\n\n            new_node, nbrs = add_node_with_best_parent(tree_a, new_pos)\n            if new_node is None:\n                if found_first_solution:\n                    post_opt_count += 1\n                    no_improve_count += 1\n                    if post_opt_count >= self.post_opt_iters or no_improve_count >= self.max_no_improve:\n                        break\n                continue\n\n            rewire(new_node, nbrs, tree_a)\n\n            node_b_meet = greedy_connect(tree_b, new_node)\n            if node_b_meet is not None:\n                # Merge path from both trees\n                if it % 2 == 0:\n                    path_a = new_node.path_from_root()\n                    path_b = node_b_meet.path_from_root()\n                else:\n                    path_a = node_b_meet.path_from_root()\n                    path_b = new_node.path_from_root()\n                # Remove duplicate joint node if any\n                if path_a and path_b and path_a[-1] == path_b[-1]:\n                    full_path = path_a + path_b[-2::-1]\n                else:\n                    full_path = path_a + path_b[::-1]\n\n                cost_path = 0.0\n                for i in range(len(full_path) - 1):\n                    cost_path += dist(full_path[i], full_path[i + 1])\n\n                if cost_path + self.improve_tol < best_cost:\n                    best_cost = cost_path\n                    best_path = full_path\n                    found_first_solution = True\n                    no_improve_count = 0\n                    post_opt_count = 0\n                else:\n                    no_improve_count += 1\n                    post_opt_count += 1\n\n                if found_first_solution and (post_opt_count >= self.post_opt_iters or no_improve_count >= self.max_no_improve):\n                    break\n            else:\n                if found_first_solution:\n                    no_improve_count += 1\n                    post_opt_count += 1\n                    if post_opt_count >= self.post_opt_iters or no_improve_count >= self.max_no_improve:\n                        break\n\n        return PlannerResult(\n            success=found_first_solution,\n            path=best_path if found_first_solution else [],\n            nodes=nodes,\n            edges=edges,\n        )",
          "objective": 11.13217,
          "time_improvement": -62.0,
          "length_improvement": 12.0,
          "smoothness_improvement": 68.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.07701032161712647,
                    "num_nodes_avg": 434.2,
                    "path_length_avg": 155.61617858282244,
                    "smoothness_avg": 0.010452144229353361,
                    "success_improvement": 0.0,
                    "time_improvement": -217.10496217866594,
                    "length_improvement": 14.704306622605435,
                    "smoothness_improvement": 63.59875438385533,
                    "objective_score": -55.990910908117236
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.052776336669921875,
                    "num_nodes_avg": 502.5,
                    "path_length_avg": 269.0545941642491,
                    "smoothness_avg": 0.006460910848831797,
                    "success_improvement": 0.0,
                    "time_improvement": 67.31412344086479,
                    "length_improvement": 10.18183216087539,
                    "smoothness_improvement": 66.24388974642639,
                    "objective_score": 26.634555777516802
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.0674659013748169,
                    "num_nodes_avg": 505.7,
                    "path_length_avg": 134.37283667640756,
                    "smoothness_avg": 0.013798571007821869,
                    "success_improvement": 0.0,
                    "time_improvement": -36.237692881731306,
                    "length_improvement": 10.755960026414227,
                    "smoothness_improvement": 75.51680471492838,
                    "objective_score": -4.040147825096213
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e2",
          "algorithm_description": "An enhanced bidirectional RRT* planner incorporating adaptive neighbor radius, efficient near and nearest node searches with pruning, progressive ellipsoidal informed sampling, and systematic path shortcutting for improved smoothness and path length. Early termination is enforced upon stagnation to reduce planning time while continuously updating the best path found.",
          "planning_mechanism": "The planner grows two trees alternately toward each other with rewiring guided by an adaptively shrinking neighbor radius based on iteration count and best path cost. Sampling is progressively restricted within an ellipsoid around the start and goal once a solution is found to focus search in promising regions. A controlled shortcutting procedure post-processing removes unnecessary waypoints to smooth the path. Early stopping criteria based on lack of improvement terminate planning to save time. The combination of these mechanisms achieves efficient, high-quality, and smooth paths.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def path_from_root(self):\n        path = []\n        n = self\n        while n is not None:\n            path.append(n.position)\n            n = n.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=4.0, neighbor_const=30,\n                 no_improve_limit=80, improve_tol=1e-6, shortcut_iterations=200):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.neighbor_const = neighbor_const  # constant for adaptive radius\n        self.no_improve_limit = no_improve_limit\n        self.improve_tol = improve_tol\n        self.shortcut_iterations = shortcut_iterations\n\n    def plan(self, map) -> 'PlannerResult':\n        import math, random, time\n\n        start = tuple(map.start)\n        goal = tuple(map.goal)\n        bounds = tuple(map.size)\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def dist(a, b):\n            acc = 0.0\n            for i in range(dim):\n                d = a[i] - b[i]\n                acc += d * d\n            return math.sqrt(acc)\n\n        def in_obstacle(p):\n            px, py, pz = (p + (0, 0, 0))[:3]\n            for obs in obstacles:\n                if is_3d:\n                    ox, oy, oz, ow, oh, od = obs\n                    if ox <= px <= ox + ow and oy <= py <= oy + oh and oz <= pz <= oz + od:\n                        return True\n                else:\n                    ox, oy, ow, oh = obs\n                    if ox <= px <= ox + ow and oy <= py <= oy + oh:\n                        return True\n            return False\n\n        def edge_obstacle(f, t, resolution=0.5):\n            length = dist(f, t)\n            if length < 1e-12:\n                return False\n            steps = max(2, int(length / resolution))\n            for i in range(steps + 1):\n                inter = tuple(f[j] + (t[j] - f[j]) * (i / steps) for j in range(dim))\n                if in_obstacle(inter):\n                    return True\n            return False\n\n        def steer(frm, to):\n            d = dist(frm, to)\n            if d <= self.step_size:\n                return to\n            ratio = self.step_size / d\n            return tuple(frm[i] + (to[i] - frm[i]) * ratio for i in range(dim))\n\n        def nearest(tree, p):\n            best = None\n            best_d = float('inf')\n            px = p\n            for n in tree:\n                # Early pruning using squared dist\n                d2 = 0.0\n                for i in range(dim):\n                    dd = n.position[i] - px[i]\n                    d2 += dd * dd\n                    if d2 >= best_d * best_d:\n                        break\n                else:\n                    d = math.sqrt(d2)\n                    if d < best_d:\n                        best = n\n                        best_d = d\n            return best\n\n        def near_nodes(tree, p, radius):\n            r2 = radius * radius\n            result = []\n            px = p\n            for n in tree:\n                d2 = 0.0\n                for i in range(dim):\n                    dd = n.position[i] - px[i]\n                    d2 += dd * dd\n                    if d2 > r2:\n                        break\n                else:\n                    result.append(n)\n            return result\n\n        c_min = dist(start, goal)\n\n        def adaptive_radius(n_nodes, c_best):\n            if n_nodes == 0:\n                return self.step_size * 3.0\n            r = min((self.neighbor_const * (math.log(max(n_nodes,1)) / n_nodes)) ** (1.0 / dim), self.step_size * 6)\n            if c_best == float('inf'):\n                return r\n            shrink_factor = max(0.3, c_best / (c_min * 2.5))\n            radius = max(self.step_size * 1.0, r * shrink_factor)\n            return radius\n\n        def ellipsoid_sample(c_best):\n            if c_best == float('inf'):\n                return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n\n            center = tuple((start[i] + goal[i]) * 0.5 for i in range(dim))\n            a1 = [goal[i] - start[i] for i in range(dim)]\n            norm_a1 = math.sqrt(sum(x * x for x in a1))\n            if norm_a1 < 1e-14:\n                # Degenerate case, uniform random\n                return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n            unit_a1 = [x / norm_a1 for x in a1]\n\n            # Construct orthonormal basis (Gram-Schmidt)\n            U = [unit_a1]\n            for idx in range(dim - 1):\n                base = [0] * dim\n                base[(idx + 1) % dim] = 1\n                for u in U:\n                    proj = sum(base[j] * u[j] for j in range(dim))\n                    base = [base[j] - proj * u[j] for j in range(dim)]\n                norm_base = math.sqrt(sum(x * x for x in base))\n                if norm_base > 1e-14:\n                    base = [x / norm_base for x in base]\n                else:\n                    base = [0] * dim\n                U.append(base)\n\n            r1 = c_best * 0.5\n            val = c_best * c_best - c_min * c_min\n            r2 = math.sqrt(val) * 0.5 if val > 0 else 0.0\n            radii = [r1] + [r2] * (dim - 1)\n\n            # Sample inside unit ball with radius 1, then scale and rotate\n            while True:\n                x_ball = [random.gauss(0,1) for _ in range(dim)]\n                norm_ball = math.sqrt(sum(x*x for x in x_ball))\n                if norm_ball < 1e-14:\n                    continue\n                unit_ball = [x / norm_ball for x in x_ball]\n                u = random.random() ** (1.0 / dim)  # uniform in unit ball\n                point_ball = [coord * u for coord in unit_ball]\n\n                # Scale by ellipsoid radii\n                point_scaled = [radii[i] * point_ball[i] for i in range(dim)]\n\n                # Rotate by U matrix transpose: point_rotated_j = sum_i U[i][j]*point_scaled[i]\n                point_rotated = [0.0] * dim\n                for i in range(dim):\n                    for j in range(dim):\n                        point_rotated[j] += point_scaled[i] * U[i][j]\n\n                sample = tuple(center[i] + point_rotated[i] for i in range(dim))\n                if all(0.0 <= sample[i] <= bounds[i] for i in range(dim)):\n                    return sample\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            changed = True\n            iter_count = 0\n            while changed and iter_count < self.shortcut_iterations:\n                changed = False\n                iter_count += 1\n                i = 0\n                while i < len(path) - 2:\n                    # Try to shortcut further along the path (randomized spread)\n                    j = min(len(path) - 1, i + 2 + random.randint(0, 4))\n                    if j > i + 1 and not edge_obstacle(path[i], path[j], resolution=0.4):\n                        path = path[:i+1] + path[j:]\n                        changed = True\n                        break\n                    i += 1\n            return path\n\n        def add_node(tree, new_pos, all_nodes, edges, c_best):\n            nn = nearest(tree, new_pos)\n            new_pos_steer = steer(nn.position, new_pos)\n            if in_obstacle(new_pos_steer) or edge_obstacle(nn.position, new_pos_steer):\n                return None\n\n            n_nodes = len(all_nodes)\n            radius = adaptive_radius(n_nodes, c_best)\n            near = near_nodes(tree, new_pos_steer, radius)\n\n            best_parent = nn\n            best_cost = nn.cost + dist(nn.position, new_pos_steer)\n            for near_node in near:\n                if near_node is nn:\n                    continue\n                cand_cost = near_node.cost + dist(near_node.position, new_pos_steer)\n                if cand_cost + self.improve_tol < best_cost and not edge_obstacle(near_node.position, new_pos_steer):\n                    best_parent = near_node\n                    best_cost = cand_cost\n\n            new_node = Node(new_pos_steer)\n            best_parent.add_child(new_node)\n            new_node.cost = best_cost\n            tree.append(new_node)\n            all_nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire near neighbors if better via new node\n            for near_node in near:\n                if near_node is best_parent:\n                    continue\n                alt_cost = new_node.cost + dist(new_node.position, near_node.position)\n                if alt_cost + self.improve_tol < near_node.cost:\n                    if not edge_obstacle(new_node.position, near_node.position):\n                        if near_node.parent is not None:\n                            near_node.parent.remove_child(near_node)\n                            try:\n                                edges.remove((near_node.parent, near_node))\n                            except Exception:\n                                pass\n                        new_node.add_child(near_node)\n                        near_node.cost = alt_cost\n                        edges.append((new_node, near_node))\n\n            return new_node\n\n        def extract_full_path(n_start, n_goal):\n            path_start = n_start.path_from_root()\n            path_goal = n_goal.path_from_root()[::-1]\n            if path_start and path_goal and path_start[-1] == path_goal[0]:\n                return path_start + path_goal[1:]\n            return path_start + path_goal\n\n        start_tree = [Node(start)]\n        goal_tree = [Node(goal)]\n        all_nodes = start_tree + goal_tree\n        edges = []\n\n        best_path = []\n        best_cost = float('inf')\n        found = False\n\n        no_improve_count = 0\n        last_best = float('inf')\n\n        for iter_count in range(self.max_iter):\n            sample_pt = ellipsoid_sample(best_cost if found else float('inf'))\n\n            # Alternate trees every iteration\n            if iter_count % 2 == 0:\n                tree_a = start_tree\n                tree_b = goal_tree\n            else:\n                tree_a = goal_tree\n                tree_b = start_tree\n\n            new_node = add_node(tree_a, sample_pt, all_nodes, edges, best_cost)\n            if new_node is None:\n                continue\n\n            nearest_b = nearest(tree_b, new_node.position)\n            if nearest_b is not None:\n                d = dist(new_node.position, nearest_b.position)\n                if d <= self.step_size and not edge_obstacle(new_node.position, nearest_b.position):\n                    candidate_path = extract_full_path(new_node, nearest_b)\n                    candidate_cost = new_node.cost + d + nearest_b.cost\n\n                    if candidate_cost + self.improve_tol < best_cost:\n                        best_cost = candidate_cost\n                        best_path = candidate_path\n                        found = True\n                        no_improve_count = 0\n                    else:\n                        no_improve_count += 1\n                else:\n                    if found:\n                        no_improve_count += 1\n\n            if found:\n                if no_improve_count >= self.no_improve_limit:\n                    break\n                if best_cost + self.improve_tol < last_best:\n                    no_improve_count = 0\n                    last_best = best_cost\n\n        if found and len(best_path) > 2:\n            best_path = shortcut_path(best_path)\n\n        if found:\n            return PlannerResult(True, best_path, all_nodes, edges)\n        else:\n            return PlannerResult(False, [], all_nodes, edges)",
          "objective": 15.29634,
          "time_improvement": -55.0,
          "length_improvement": 16.0,
          "smoothness_improvement": 1611.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.043719482421875,
                    "num_nodes_avg": 252.1,
                    "path_length_avg": 160.28445035157407,
                    "smoothness_avg": 0.0447792931751143,
                    "success_improvement": 0.0,
                    "time_improvement": -80.0234634622842,
                    "length_improvement": 12.145552892652713,
                    "smoothness_improvement": 600.8931779820454,
                    "objective_score": -13.715241413183405
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.07719662189483642,
                    "num_nodes_avg": 477.2,
                    "path_length_avg": 238.96477432878683,
                    "smoothness_avg": 0.11357676567958272,
                    "success_improvement": 0.0,
                    "time_improvement": 52.189950776274806,
                    "length_improvement": 20.226680109395147,
                    "smoothness_improvement": 2822.411986973357,
                    "objective_score": 41.90505323338631
               },
               {
                    "map_id": 2,
                    "success_rate": 0.9,
                    "time_avg": 0.11687643527984619,
                    "num_nodes_avg": 565.9,
                    "path_length_avg": 126.26906884445695,
                    "smoothness_avg": 0.11859913653289308,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": -136.01516573987143,
                    "length_improvement": 16.138096760439403,
                    "smoothness_improvement": 1408.5722626207505,
                    "objective_score": -74.07883035259403
               }
          ],
          "success_rate": 0.9666666666666667
     },
     {
          "operator": "path_expert",
          "algorithm_description": "An enhanced bidirectional informed RRT* planner with an adaptive radius rewiring strategy, dynamic step size scaling, and prioritized node expansion to accelerate convergence to shorter paths and improve path smoothness. The planner leverages a k-d tree for efficient nearest neighbor queries, uses a refined ellipsoidal sampling scheme focused on the informed set, and employs early stopping based on stagnation of path improvements. It integrates a smoothing post-processing step that shortcuts the resulting path for better smoothness and reduced length.",
          "planning_mechanism": "A bidirectional RRT* grows simultaneous start and goal trees with adaptive local rewiring radius that shrinks as better paths are found, improving refinement. Samples are drawn inside an ellipsoidal informed subset bounded by the best path cost so far to focus exploration. Efficient nearest neighbor searches use a simple k-d tree approximation for scalability. Upon connection, paths are merged and post-processed with a shortcut smoothing routine to increase smoothness. Early stopping triggers when no significant improvements occur.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.children = []\n        self.cost = cost\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        path, node = [], self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=7000, step_size=6.0, base_radius=18.0, max_no_improve=80, improve_tol=1e-6):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.base_radius = base_radius\n        self.max_no_improve = max_no_improve\n        self.improve_tol = improve_tol\n\n    def plan(self, map) -> 'PlannerResult':\n        import math, random\n\n        bounds = map.size\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        # Efficient distance\n        def dist(a, b):\n            s = 0.0\n            for i in range(dim):\n                d = a[i]-b[i]\n                s += d*d\n            return math.sqrt(s)\n\n        def steer(frm, to):\n            d = dist(frm, to)\n            if d <= self.step_size:\n                return to\n            return tuple(frm[i] + (to[i]-frm[i]) * self.step_size / d for i in range(dim))\n\n        def in_obstacle(p):\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d_ = obs\n                    px,py,pz = p\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d_:\n                        return True\n                else:\n                    x,y,w,h = obs\n                    px,py = p\n                    if x <= px <= x+w and y <= py <= y+h:\n                        return True\n            return False\n\n        def edge_obstacle(p1, p2, resolution=0.7):\n            length = dist(p1, p2)\n            if length < 1e-8:\n                return False\n            steps = max(1, int(length / resolution))\n            for i in range(steps+1):\n                interp = tuple(p1[j] + (p2[j]-p1[j]) * i / steps for j in range(dim))\n                if in_obstacle(interp):\n                    return True\n            return False\n\n        class KDTree:\n            # Simple k-d tree implementation for quick nearest neighbor search\n            # balanced on initial insertions, rebuilt every few iterations to maintain balance\n            def __init__(self, nodes):\n                self.nodes = nodes\n                self.dim = dim\n                self.tree = None\n                self._build()\n\n            class _Node:\n                def __init__(self, node, axis, left, right):\n                    self.node = node\n                    self.axis = axis\n                    self.left = left\n                    self.right = right\n\n            def _build_rec(self, pts, depth=0):\n                if not pts:\n                    return None\n                axis = depth % self.dim\n                pts.sort(key=lambda n: n.position[axis])\n                median = len(pts) // 2\n                left = self._build_rec(pts[:median], depth+1)\n                right = self._build_rec(pts[median+1:], depth+1)\n                return self._Node(pts[median], axis, left, right)\n\n            def _build(self):\n                self.tree = self._build_rec(self.nodes)\n\n            def nearest(self, point, best=None, best_dist=float('inf')):\n                def recurse(nd):\n                    nonlocal best, best_dist\n                    if nd is None:\n                        return\n                    axis = nd.axis\n                    curr_node = nd.node\n                    d = dist(point, curr_node.position)\n                    if d < best_dist:\n                        best_dist = d\n                        best = curr_node\n                    diff = point[axis] - curr_node.position[axis]\n                    close, away = (nd.left, nd.right) if diff < 0 else (nd.right, nd.left)\n                    recurse(close)\n                    if abs(diff) < best_dist:\n                        recurse(away)\n                recurse(self.tree)\n                return best\n\n            def neighbors_radius(self, point, radius):\n                radius2 = radius*radius\n                result = []\n                def recurse(nd):\n                    if nd is None:\n                        return\n                    axis = nd.axis\n                    curr_node = nd.node\n                    d2 = 0.0\n                    for i in range(dim):\n                        diff = curr_node.position[i] - point[i]\n                        d2 += diff*diff\n                    if d2 <= radius2:\n                        result.append(curr_node)\n                    diff = point[axis] - curr_node.position[axis]\n                    if diff < 0:\n                        recurse(nd.left)\n                        if diff*diff <= radius2:\n                            recurse(nd.right)\n                    else:\n                        recurse(nd.right)\n                        if diff*diff <= radius2:\n                            recurse(nd.left)\n                recurse(self.tree)\n                return result\n\n        # Ellipsoidal sampling constrained by current best solution cost c_best\n        def ellipsoid_sample(c_best):\n            if c_best == float('inf'):\n                # uniform random sample inside bounds\n                return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n\n            center = tuple((start[i] + goal[i]) / 2.0 for i in range(dim))\n            a1 = [goal[i] - start[i] for i in range(dim)]\n            norm_a1 = math.sqrt(sum(x*x for x in a1))\n            if norm_a1 < 1e-12:\n                # Degenerate start and goal same position fallback\n                return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n            unit_a1 = [x / norm_a1 for x in a1]\n\n            # Construct orthonormal basis U with unit_a1 first\n            U = [unit_a1]\n            for i in range(dim-1):\n                base = [0]*dim\n                base[(i+1) % dim] = 1  # naive perpendicular approx\n                for u in U:\n                    proj = sum(base[j]*u[j] for j in range(dim))\n                    base = [base[j] - proj*u[j] for j in range(dim)]\n                norm_b = math.sqrt(sum(x*x for x in base))\n                if norm_b > 1e-12:\n                    U.append([x/norm_b for x in base])\n                else:\n                    # fallback zero vector\n                    U.append([0]*dim)\n\n            r1 = c_best / 2.0\n            delta = c_best*c_best - c_min*c_min\n            r2 = math.sqrt(delta) / 2.0 if delta > 0 else 0.0\n            radii = [r1] + [r2] * (dim - 1)\n\n            while True:\n                # Sample unit ball with normal distribution then normalize\n                x_ball = [random.gauss(0,1) for _ in range(dim)]\n                norm_ball = math.sqrt(sum(x*x for x in x_ball))\n                if norm_ball < 1e-12:\n                    continue\n                unit_ball = [x / norm_ball for x in x_ball]\n                u = random.random() ** (1.0/dim)\n                point_ball = [coord * u for coord in unit_ball]\n\n                # Scale\n                point_scaled = [radii[i]*point_ball[i] for i in range(dim)]\n\n                # Rotate by U\n                point_rotated = [0]*dim\n                for i in range(dim):\n                    for j in range(dim):\n                        point_rotated[j] += point_scaled[i]*U[i][j]\n\n                sample = tuple(center[i] + point_rotated[i] for i in range(dim))\n\n                # Check bounds\n                if all(0.0 <= sample[i] <= bounds[i] for i in range(dim)):\n                    return sample\n\n        def extract_path(start_node, goal_node):\n            path_start = []\n            node = start_node\n            while node:\n                path_start.append(node.position)\n                node = node.parent\n            path_start = path_start[::-1]\n\n            path_goal = []\n            node = goal_node\n            while node:\n                path_goal.append(node.position)\n                node = node.parent\n\n            # Join paths (path_start goes from start->node, path_goal from goal->node, so exclude duplicated node)\n            return path_start + path_goal\n\n        # Path smoothing by shortcutting: try repeatedly replacing segments with straight line collision-free shortcuts\n        def path_shortcut(path, iterations=60):\n            if len(path) < 3:\n                return path\n            for _ in range(iterations):\n                if len(path) <= 2:\n                    break\n                i = random.randint(0, len(path)-3)\n                j = random.randint(i+2, len(path)-1)\n                p1, p2 = path[i], path[j]\n                if not edge_obstacle(p1, p2):\n                    # shortcut path between i and j\n                    path = path[:i+1] + path[j:]\n            return path\n\n        start_tree = [Node(start)]\n        goal_tree = [Node(goal)]\n        nodes_all = start_tree + goal_tree\n        edges_all = []\n\n        c_min = dist(start, goal)\n        best_cost = float('inf')\n        best_path = []\n        found_solution = False\n        no_improve_count = 0\n\n        for iteration in range(self.max_iter):\n            # Shrink radius with better cost found (adaptive radius)\n            radius = min(self.base_radius, self.base_radius * (c_min / best_cost) if best_cost < float('inf') else self.base_radius)\n\n            sample = ellipsoid_sample(best_cost if found_solution else float('inf'))\n\n            # Alternate tree growth order every iteration for balance and early connection\n            if iteration % 2 == 0:\n                trees = [(start_tree, goal_tree)]\n            else:\n                trees = [(goal_tree, start_tree)]\n\n            improved_this_iter = False\n            for tree_a, tree_b in trees:\n                # Build KDTree for fast nearest lookup in tree_a\n                if len(tree_a) > 50 and iteration % 30 == 0:\n                    kdtree_a = KDTree(tree_a)\n                else:\n                    kdtree_a = None\n\n                # Find nearest node in tree_a\n                if kdtree_a:\n                    nearest_node = kdtree_a.nearest(sample)\n                else:\n                    nearest_node = min(tree_a, key=lambda n: dist(n.position, sample))\n\n                new_pos = steer(nearest_node.position, sample)\n                if in_obstacle(new_pos):\n                    continue\n                if edge_obstacle(nearest_node.position, new_pos):\n                    continue\n\n                # Find near nodes for rewiring\n                if kdtree_a:\n                    near = kdtree_a.neighbors_radius(new_pos, radius)\n                else:\n                    r2 = radius*radius\n                    near = [n for n in tree_a if sum((n.position[i]-new_pos[i])**2 for i in range(dim)) <= r2]\n\n                # Select best parent in near nodes with lowest cost + dist edge, collision-free edge required\n                min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n                best_parent = nearest_node\n                for cand in near:\n                    cand_cost = cand.cost + dist(cand.position, new_pos)\n                    if cand_cost + self.improve_tol < min_cost and not edge_obstacle(cand.position, new_pos):\n                        min_cost = cand_cost\n                        best_parent = cand\n\n                new_node = Node(new_pos)\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n                tree_a.append(new_node)\n                nodes_all.append(new_node)\n                edges_all.append((best_parent, new_node))\n\n                # Rewire near nodes to new node if improves cost and no collision\n                for near_node in near:\n                    if near_node == best_parent:\n                        continue\n                    alt_cost = new_node.cost + dist(new_node.position, near_node.position)\n                    if alt_cost + self.improve_tol < near_node.cost and not edge_obstacle(new_node.position, near_node.position):\n                        # Remove old edge\n                        if near_node.parent and near_node in near_node.parent.children:\n                            near_node.parent.children.remove(near_node)\n                        try:\n                            edges_all.remove((near_node.parent, near_node))\n                        except Exception:\n                            pass\n                        new_node.add_child(near_node)\n                        near_node.cost = alt_cost\n                        edges_all.append((new_node, near_node))\n\n                # Try to connect to other tree\n                if kdtree_b := (KDTree(tree_b) if len(tree_b) > 50 and iteration % 30 == 0 else None):\n                    connect_node = kdtree_b.nearest(new_node.position)\n                else:\n                    connect_node = min(tree_b, key=lambda n: dist(n.position, new_node.position))\n\n                dist_connect = dist(new_node.position, connect_node.position)\n                if dist_connect <= self.step_size and not edge_obstacle(new_node.position, connect_node.position):\n                    total_cost = new_node.cost + dist_connect + connect_node.cost\n                    if total_cost + self.improve_tol < best_cost:\n                        best_cost = total_cost\n                        best_path = extract_path(new_node, connect_node)\n                        best_path = path_shortcut(best_path, iterations=100)\n                        found_solution = True\n                        no_improve_count = 0\n                        improved_this_iter = True\n                    else:\n                        no_improve_count += 1\n                else:\n                    if found_solution:\n                        no_improve_count += 1\n\n            if found_solution and not improved_this_iter:\n                no_improve_count += 1\n\n            if no_improve_count >= self.max_no_improve:\n                break\n\n        if found_solution:\n            return PlannerResult(True, best_path, nodes_all, edges_all)\n        else:\n            return PlannerResult(False, [], nodes_all, edges_all)",
          "objective": 30.2081,
          "time_improvement": -46.0,
          "length_improvement": 18.0,
          "smoothness_improvement": 1268.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.04564058780670166,
                    "num_nodes_avg": 145.9,
                    "path_length_avg": 167.2440025062874,
                    "smoothness_avg": 0.046934949632013605,
                    "success_improvement": 0.0,
                    "time_improvement": -87.93398815046068,
                    "length_improvement": 8.330912075493234,
                    "smoothness_improvement": 634.633882615439,
                    "objective_score": -18.208479786765068
               },
               {
                    "map_id": 1,
                    "success_rate": 0.8,
                    "time_avg": 0.05376114845275879,
                    "num_nodes_avg": 260.0,
                    "path_length_avg": 228.37448182783814,
                    "smoothness_avg": 0.08019198340552279,
                    "success_improvement": -19.999999999999996,
                    "time_improvement": 66.7042016767016,
                    "length_improvement": 23.762024570879994,
                    "smoothness_improvement": 1963.3974929750734,
                    "objective_score": -55.91453728958615
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.10752053260803222,
                    "num_nodes_avg": 370.4,
                    "path_length_avg": 118.93718563406776,
                    "smoothness_avg": 0.10268691398197109,
                    "success_improvement": 0.0,
                    "time_improvement": -117.12226475048746,
                    "length_improvement": 21.00758448201936,
                    "smoothness_improvement": 1206.1699662911165,
                    "objective_score": -16.501278904479037
               }
          ],
          "success_rate": 0.9333333333333332
     },
     {
          "operator": "m3",
          "algorithm_description": "An improved bidirectional RRT* planner using adaptive neighborhood radius, efficient KD-tree nearest neighbor searches, and integrated batch rewiring for path quality refinement. Sampling alternates between uniform exploration and informed ellipsoidal regions defined by current best path cost to focus search. The planner performs incremental expansions with collision checks, rewires neighbors for cost improvement, and attempts direct connection between trees to quickly form solutions. Early stopping occurs after no significant improvement. Path extraction follows parent pointers from merged connecting nodes for a smooth, optimized path.",
          "planning_mechanism": "The planner grows two trees from start and goal positions, expanding alternately. It samples points uniformly or inside an ellipsoid when a solution exists. Expansion picks the best parent within an adaptive radius, then rewires neighbors to lower cost paths. After each expansion, it attempts a direct connection to the opposite tree. If a path is found, it updates the best solution and focuses sampling accordingly. Early stopping criteria reduce runtime. The output is the optimized path with recorded nodes and edges.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=4.0, max_neighbor_radius=30.0,\n                 min_neighbor_radius=5.0, improvement_tol=1e-5, max_no_improve=100,\n                 time_limit_sec=25.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.max_neighbor_radius = max_neighbor_radius\n        self.min_neighbor_radius = min_neighbor_radius\n        self.improvement_tol = improvement_tol\n        self.max_no_improve = max_no_improve\n        self.time_limit_sec = time_limit_sec\n\n    def plan(self, map):\n        import time\n        import math\n        import random\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def in_bounds(p):\n            return all(0.0 <= p[d] <= bounds[d] for d in range(dim))\n        def in_obstacle(p):\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d = obs\n                    px,py,pz = p\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                        return True\n                else:\n                    x,y,w,h = obs\n                    px,py = p\n                    if x <= px <= x+w and y <= py <= y+h:\n                        return True\n            return False\n        def edge_in_obstacle(a,b,res=1.0):\n            dist = math.dist(a,b)\n            if dist < 1e-12: return False\n            steps = max(2, int(dist/res))\n            for i in range(steps+1):\n                interp = tuple(a[d] + (b[d]-a[d])*i/steps for d in range(dim))\n                if in_obstacle(interp):\n                    return True\n            return False\n        def steer(a,b):\n            dist = math.dist(a,b)\n            if dist <= self.step_size:\n                return b\n            ratio = self.step_size / dist\n            return tuple(a[d] + (b[d]-a[d])*ratio for d in range(dim))\n\n        # KD-tree for nearest neighbor search\n        class KDNode:\n            def __init__(self, points, depth=0):\n                self.axis = depth % dim\n                self.left = None\n                self.right = None\n                self.node = None\n                if not points:\n                    return\n                points.sort(key=lambda n: n.position[self.axis])\n                median = len(points)//2\n                self.node = points[median]\n                left_points = points[:median]\n                right_points = points[median+1:]\n                if left_points:\n                    self.left = KDNode(left_points, depth+1)\n                if right_points:\n                    self.right = KDNode(right_points, depth+1)\n            def nearest(self, point, best=None, best_dist=float('inf')):\n                if self.node is None:\n                    return best, best_dist\n                d = math.dist(self.node.position, point)\n                if d < best_dist:\n                    best = self.node\n                    best_dist = d\n                diff = point[self.axis] - self.node.position[self.axis]\n                close, away = (self.left, self.right) if diff < 0 else (self.right, self.left)\n                if close:\n                    best, best_dist = close.nearest(point, best, best_dist)\n                if away and abs(diff) < best_dist:\n                    best, best_dist = away.nearest(point, best, best_dist)\n                return best, best_dist\n\n        def build_kdtree(nodes):\n            if not nodes:\n                return None\n            return KDNode(nodes)\n\n        def kdtree_nearest(tree, point):\n            if not tree:\n                return None\n            node, _ = tree.nearest(point)\n            return node\n\n        def dist_sq(a,b):\n            return sum((a[d]-b[d])**2 for d in range(dim))\n\n        def neighbors_within_radius(tree, point, radius):\n            radius_sq = radius*radius\n            result = []\n            stack = [tree]\n            while stack:\n                node = stack.pop()\n                if node is None or node.node is None:\n                    continue\n                pos = node.node.position\n                if dist_sq(pos, point) <= radius_sq:\n                    result.append(node.node)\n                diff = point[node.axis] - pos[node.axis]\n                if diff < 0:\n                    stack.append(node.left)\n                    if diff*diff < radius_sq:\n                        stack.append(node.right)\n                else:\n                    stack.append(node.right)\n                    if diff*diff < radius_sq:\n                        stack.append(node.left)\n            return result\n\n        def adaptive_radius(n, iter_i):\n            if n == 0:\n                return self.max_neighbor_radius\n            factor = max(0.25, 1.0 - iter_i / self.max_iter)\n            r = self.max_neighbor_radius * factor * math.sqrt(math.log(n+1)/(n+1))\n            return max(self.min_neighbor_radius, min(self.max_neighbor_radius, r))\n\n        def sample_uniform():\n            return tuple(random.uniform(0,bounds[d]) for d in range(dim))\n\n        def sample_informed():\n            if best_cost == float('inf') or c_min < 1e-12 or not found_first:\n                return sample_uniform()\n            center = tuple((start_pos[d]+goal_pos[d])*0.5 for d in range(dim))\n            unit_vector = [(goal_pos[d]-start_pos[d])/c_min for d in range(dim)]\n            r1 = best_cost * 0.5\n            val = best_cost*best_cost - c_min*c_min\n            r_other = math.sqrt(max(val,0))*0.5\n            # 2D or 3D basis\n            if dim == 2:\n                a1 = unit_vector\n                a2 = (-a1[1], a1[0])\n                basis = (a1, a2)\n                radii = (r1, r_other)\n            else:\n                def cross(u,v):\n                    return (u[1]*v[2]-u[2]*v[1], u[2]*v[0]-u[0]*v[2], u[0]*v[1]-u[1]*v[0])\n                def norm(v):\n                    return math.sqrt(sum(x*x for x in v))\n                a1 = unit_vector\n                ref = (1,0,0) if abs(a1[0])<0.9 else (0,1,0)\n                b2 = cross(a1, ref)\n                n_b2 = norm(b2)\n                if n_b2 < 1e-12:\n                    ref = (0,0,1)\n                    b2 = cross(a1, ref)\n                    n_b2 = norm(b2)\n                b2 = tuple(x/n_b2 for x in b2)\n                b3 = cross(a1, b2)\n                basis = (a1,b2,b3)\n                radii = (r1,r_other,r_other)\n            def sample_unit_ball(dim):\n                while True:\n                    vec = [random.gauss(0,1) for _ in range(dim)]\n                    nrm = math.sqrt(sum(v*v for v in vec))\n                    if nrm < 1e-12:\n                        continue\n                    unit_vec = [v/nrm for v in vec]\n                    r = random.random()**(1.0/dim)\n                    return [unit_vec[i]*r for i in range(dim)]\n            u = sample_unit_ball(dim)\n            res = [center[d]+sum(basis[i][d]*radii[i]*u[i] for i in range(dim)) for d in range(dim)]\n            # clamp\n            return tuple(min(max(0.0,res[d]),bounds[d]) for d in range(dim))\n\n        def choose_parent_and_add(tree, pos, iter_i):\n            n = len(tree)\n            radius = adaptive_radius(n, iter_i)\n            kdt = build_kdtree(tree)\n            near_nodes = neighbors_within_radius(kdt, pos, radius) if kdt else []\n            nearest = min(tree, key=lambda node: math.dist(node.position, pos))\n            min_cost = nearest.cost + math.dist(nearest.position,pos)\n            best_par = nearest\n            for nb in near_nodes:\n                if edge_in_obstacle(nb.position, pos):\n                    continue\n                c = nb.cost + math.dist(nb.position, pos)\n                if c < min_cost:\n                    min_cost = c\n                    best_par = nb\n            new_node = Node(pos, cost=min_cost)\n            best_par.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_par, new_node))\n            return new_node, near_nodes\n\n        def rewire(pivot, near_nodes):\n            for nb in near_nodes:\n                if nb is pivot.parent:\n                    continue\n                if edge_in_obstacle(pivot.position, nb.position):\n                    continue\n                new_cost = pivot.cost + math.dist(pivot.position, nb.position)\n                if new_cost + 1e-12 < nb.cost:\n                    if nb.parent:\n                        try:\n                            edges.remove((nb.parent, nb))\n                        except ValueError:\n                            pass\n                        if nb in nb.parent.children:\n                            nb.parent.children.remove(nb)\n                    pivot.add_child(nb)\n                    nb.cost = new_cost\n                    edges.append((pivot, nb))\n\n        def try_connect(tree, target_node):\n            kdt = build_kdtree(tree)\n            nearest = kdt.nearest(target_node.position)[0] if kdt else None\n            if nearest is None:\n                return None\n            if not edge_in_obstacle(nearest.position, target_node.position) and not in_obstacle(target_node.position):\n                new_node = Node(target_node.position, cost=nearest.cost+math.dist(nearest.position, target_node.position))\n                nearest.add_child(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((nearest,new_node))\n                return new_node\n            cur = nearest\n            dist_total = math.dist(cur.position, target_node.position)\n            steps = int(math.ceil(dist_total/self.step_size))\n            for _ in range(steps):\n                new_pos = steer(cur.position, target_node.position)\n                if (not in_bounds(new_pos)) or in_obstacle(new_pos) or edge_in_obstacle(cur.position, new_pos):\n                    return None\n                new_node, near_nodes = choose_parent_and_add(tree, new_pos, 0)\n                rewire(new_node, near_nodes)\n                if math.dist(new_node.position, target_node.position) <= self.step_size:\n                    if not edge_in_obstacle(new_node.position, target_node.position) and not in_obstacle(target_node.position):\n                        final_node = Node(target_node.position,\n                                          cost=new_node.cost+math.dist(new_node.position, target_node.position))\n                        new_node.add_child(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node,final_node))\n                        return final_node\n                    else:\n                        return None\n                cur = new_node\n            return None\n\n        def extract_path(node_from_start, node_from_goal, reversed_branch):\n            path_start = node_from_start.path_from_root()\n            path_goal = node_from_goal.path_from_root()\n            # merge properly without duplicating middle point\n            if path_start and path_goal and path_start[-1] == path_goal[-1]:\n                return path_start + path_goal[-2::-1] if reversed_branch else path_start + path_goal[-2::-1]\n            return path_start + path_goal[::-1]\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        best_path = []\n        best_cost = float('inf')\n        c_min = math.dist(start_pos, goal_pos)\n        found_first = False\n        no_improve_count = 0\n        start_time = time.time()\n\n        for iter_i in range(self.max_iter):\n            if time.time() - start_time > self.time_limit_sec:\n                break\n            tree_a, tree_b = (start_tree, goal_tree) if iter_i % 2 == 0 else (goal_tree, start_tree)\n\n            x_rand = sample_informed()\n            if not in_bounds(x_rand) or in_obstacle(x_rand):\n                if found_first:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n                continue\n\n            nearest = min(tree_a, key=lambda n: math.dist(n.position, x_rand))\n            new_pos = steer(nearest.position, x_rand)\n            if (not in_bounds(new_pos)) or in_obstacle(new_pos) or edge_in_obstacle(nearest.position, new_pos):\n                if found_first:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n                continue\n\n            new_node, near_nodes = choose_parent_and_add(tree_a, new_pos, iter_i)\n            rewire(new_node, near_nodes)\n\n            meet_node = try_connect(tree_b, new_node)\n            if meet_node is not None:\n                reversed_branch = (iter_i % 2 != 0)\n                candidate_path = extract_path(new_node, meet_node, reversed_branch)\n                cost_path = sum(math.dist(candidate_path[i], candidate_path[i+1]) for i in range(len(candidate_path)-1))\n                if cost_path + self.improvement_tol < best_cost:\n                    best_cost = cost_path\n                    best_path = candidate_path\n                    found_first = True\n                    no_improve_count = 0\n                else:\n                    if found_first:\n                        no_improve_count += 1\n                        if no_improve_count >= self.max_no_improve:\n                            break\n            else:\n                if found_first:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n\n        return PlannerResult(success=found_first, path=best_path, nodes=nodes, edges=edges)",
          "objective": 31.3389,
          "time_improvement": -128.0,
          "length_improvement": 11.0,
          "smoothness_improvement": 123.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.049280643463134766,
                    "num_nodes_avg": 193.7,
                    "path_length_avg": 159.42829900434148,
                    "smoothness_avg": 0.015782508309550324,
                    "success_improvement": 0.0,
                    "time_improvement": -102.92262456987744,
                    "length_improvement": 12.614823012657153,
                    "smoothness_improvement": 147.0305273098034,
                    "objective_score": -22.572740926819925
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.09595170021057128,
                    "num_nodes_avg": 359.6,
                    "path_length_avg": 272.5345381516294,
                    "smoothness_avg": 0.007447989450209298,
                    "success_improvement": 0.0,
                    "time_improvement": 40.57440082783746,
                    "length_improvement": 9.02012669325395,
                    "smoothness_improvement": 91.6421331238487,
                    "objective_score": 18.04260692992285
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.20817940235137938,
                    "num_nodes_avg": 397.9,
                    "path_length_avg": 135.5776476160814,
                    "smoothness_avg": 0.01818395158978751,
                    "success_improvement": 0.0,
                    "time_improvement": -320.388387376327,
                    "length_improvement": 9.955781967214673,
                    "smoothness_improvement": 131.29852202240792,
                    "objective_score": -89.48655442245725
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e2",
          "algorithm_description": "A bidirectional informed RRT* planner with adaptive step sizing, dynamic neighbor radius using k-nearest approach, obstacle-aware rewiring, and heuristic-guided sampling that progressively focuses sampling within an ellipsoid to concentrate efforts around promising paths. The planner implements pruning of trees beyond the current best cost, uses balanced tree growth with rapid connection attempts, and performs iterative path shortcutting to smooth and shorten the resulting path efficiently, terminating early if no significant improvements are observed.",
          "planning_mechanism": "The algorithm alternates growth between the two trees with adaptive step sizes reducing as better paths are found, samples in an admissible ellipsoidal region shrinking with best costs to intensify search near the optimum, applies k-nearest rewiring for flexible neighborhood connection, prunes nodes exceeding current best path cost to save computation, connects trees eagerly when within step-size distance, and applies iterative shortcutting on the final path to enhance smoothness while monitoring improvement to early halt the search.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def path_from_root(self):\n        path = []\n        n = self\n        while n:\n            path.append(n.position)\n            n = n.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=6000, step_size_init=5.0, k_nearest=12,\n                 no_improve_limit=60, improve_tol=1e-7, shortcut_iters=250):\n        self.max_iter = max_iter\n        self.step_size_init = step_size_init\n        self.k_nearest = k_nearest\n        self.no_improve_limit = no_improve_limit\n        self.improve_tol = improve_tol\n        self.shortcut_iters = shortcut_iters\n\n    def plan(self, map) -> 'PlannerResult':\n        import math, random\n\n        start = tuple(map.start)\n        goal = tuple(map.goal)\n        bounds = tuple(map.size)\n        obstacles = map.obstacles\n        dim = len(bounds)\n\n        def dist(a, b):\n            d_sq = 0.0\n            for i in range(dim):\n                d_sq += (a[i] - b[i]) ** 2\n            return math.sqrt(d_sq)\n\n        def in_obstacle(p):\n            px = p + (0.0,) * (3 - dim) if dim < 3 else p\n            for obs in obstacles:\n                if dim == 2:\n                    ox, oy, ow, oh = obs\n                    if ox <= px[0] <= ox + ow and oy <= px[1] <= oy + oh:\n                        return True\n                else:\n                    ox, oy, oz, ow, oh, od = obs\n                    if ox <= px[0] <= ox + ow and oy <= px[1] <= oy + oh and oz <= px[2] <= oz + od:\n                        return True\n            return False\n\n        def edge_obstacle(f, t, resolution=0.4):\n            length = dist(f, t)\n            if length < 1e-12:\n                return False\n            steps = max(2, int(length / resolution))\n            for i in range(steps + 1):\n                interp = tuple(f[j] + (t[j] - f[j]) * (i / steps) for j in range(dim))\n                if in_obstacle(interp):\n                    return True\n            return False\n\n        def steer(frm, to, max_step):\n            d = dist(frm, to)\n            if d <= max_step:\n                return to\n            ratio = max_step / d\n            return tuple(frm[i] + (to[i] - frm[i]) * ratio for i in range(dim))\n\n        def nearest(tree, point):\n            best = None\n            best_dist = float('inf')\n            for node in tree:\n                d = 0.0\n                for i in range(dim):\n                    diff = node.position[i] - point[i]\n                    d += diff * diff\n                    if d > best_dist * best_dist:\n                        break\n                else:\n                    d = math.sqrt(d)\n                    if d < best_dist:\n                        best = node\n                        best_dist = d\n            return best\n\n        def k_nearest_nodes(tree, point, k):\n            # find k nearest nodes by distance (linear scan sufficient for this scale)\n            dists = []\n            for n in tree:\n                d = 0.0\n                for i in range(dim):\n                    diff = n.position[i] - point[i]\n                    d += diff * diff\n                    if d > float('inf'):\n                        break\n                else:\n                    dists.append((math.sqrt(d), n))\n            dists.sort(key=lambda x: x[0])\n            return [n for _, n in dists[:k]]\n\n        def cost_to_node(node):\n            return node.cost\n\n        c_min = dist(start, goal)\n\n        def ellipsoid_sample(c_best):\n            # If no solution, sample uniformly in bounds\n            if c_best == float('inf'):\n                return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n            center = tuple((start[i] + goal[i]) * 0.5 for i in range(dim))\n            a1 = [goal[i] - start[i] for i in range(dim)]\n            norm_a1 = math.sqrt(sum(x * x for x in a1))\n            if norm_a1 < 1e-14:\n                # Degenerate case, sample uniformly\n                return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n            unit_a1 = [x / norm_a1 for x in a1]\n\n            # Build orthonormal basis using Gram-Schmidt for dim-dim matrix U\n            U = [unit_a1]\n            for idx in range(dim - 1):\n                base = [0.0] * dim\n                base[(idx + 1) % dim] = 1.0\n                for u in U:\n                    proj = sum(base[j] * u[j] for j in range(dim))\n                    base = [base[j] - proj * u[j] for j in range(dim)]\n                norm_base = math.sqrt(sum(x * x for x in base))\n                if norm_base > 1e-14:\n                    base = [x / norm_base for x in base]\n                else:\n                    base = [0.0] * dim\n                U.append(base)\n\n            r1 = c_best * 0.5\n            val = c_best * c_best - c_min * c_min\n            r2 = math.sqrt(val) * 0.5 if val > 0 else 0.0\n            radii = [r1] + [r2] * (dim - 1)\n\n            # Sample in unit ball then scale and rotate\n            while True:\n                x_ball = [random.gauss(0, 1) for _ in range(dim)]\n                norm_ball = math.sqrt(sum(x * x for x in x_ball))\n                if norm_ball < 1e-14:\n                    continue\n                unit_ball = [x / norm_ball for x in x_ball]\n                u = random.random() ** (1.0 / dim)\n                point_ball = [coord * u for coord in unit_ball]\n\n                point_scaled = [radii[i] * point_ball[i] for i in range(dim)]\n                # Rotate by U matrix transpose\n                point_rotated = [0.0] * dim\n                for i in range(dim):\n                    for j in range(dim):\n                        point_rotated[j] += point_scaled[i] * U[i][j]\n\n                sample = tuple(center[i] + point_rotated[i] for i in range(dim))\n                if all(0.0 <= sample[i] <= bounds[i] for i in range(dim)):\n                    return sample\n\n        def dynamic_step_size(iter_count, best_cost):\n            # shrink step size as better paths found (min 1.0)\n            base = self.step_size_init\n            shrink = 1.0\n            if best_cost != float('inf'):\n                shrink = max(0.3, best_cost / (c_min * 3.0))\n            # also reduce with iteration to refine\n            decay_iter_factor = max(0.2, 1.0 - iter_count / self.max_iter)\n            step = base * shrink * decay_iter_factor\n            return max(1.0, step)\n\n        def add_node(tree, sample, all_nodes, edges, best_cost, iter_count):\n            step_size = dynamic_step_size(iter_count, best_cost)\n            nn = nearest(tree, sample)\n            new_pos = steer(nn.position, sample, step_size)\n            if in_obstacle(new_pos) or edge_obstacle(nn.position, new_pos):\n                return None\n            # Find k nearest neighbors in tree for rewiring\n            near = k_nearest_nodes(tree, new_pos, self.k_nearest)\n\n            # Choose best parent among near nodes\n            best_parent = nn\n            best_cost_to_new = nn.cost + dist(nn.position, new_pos)\n            for near_node in near:\n                if near_node == nn:\n                    continue\n                cand_cost = near_node.cost + dist(near_node.position, new_pos)\n                if cand_cost + self.improve_tol < best_cost_to_new and not edge_obstacle(near_node.position, new_pos):\n                    best_parent = near_node\n                    best_cost_to_new = cand_cost\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = best_cost_to_new\n            tree.append(new_node)\n            all_nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors through new node if beneficial\n            for near_node in near:\n                if near_node == best_parent:\n                    continue\n                alt_cost = new_node.cost + dist(new_node.position, near_node.position)\n                if alt_cost + self.improve_tol < near_node.cost and not edge_obstacle(new_node.position, near_node.position):\n                    if near_node.parent is not None:\n                        near_node.parent.remove_child(near_node)\n                        try:\n                            edges.remove((near_node.parent, near_node))\n                        except Exception:\n                            pass\n                    new_node.add_child(near_node)\n                    near_node.cost = alt_cost\n                    edges.append((new_node, near_node))\n\n            return new_node\n\n        def extract_path(node_s, node_g):\n            path_s = node_s.path_from_root()\n            path_g = node_g.path_from_root()\n            # The connection node is node_s and node_g may not be same position.\n            # Attach goal tree path reversed (excluding common node if exists)\n            # To avoid double node, check equality of endpoints\n            if path_s and path_g and path_s[-1] == path_g[-1]:\n                return path_s + path_g[-2::-1]\n            else:\n                return path_s + path_g[::-1]\n\n        def shortcut_path(path):\n            # Iteratively shortcut path by trying to connect non-consecutive nodes directly\n            if len(path) < 3:\n                return path\n            changed = True\n            count = 0\n            while changed and count < self.shortcut_iters:\n                changed = False\n                count += 1\n                i = 0\n                while i < len(path) - 2:\n                    # Random distant j\n                    max_jump = min(len(path) - 1, i + 6)\n                    j = random.randint(i + 2, max_jump)\n                    if not edge_obstacle(path[i], path[j]):\n                        # shortcut possible\n                        path = path[:i+1] + path[j:]\n                        changed = True\n                        break\n                    i += 1\n            return path\n\n        # Initialize trees\n        start_node = Node(start)\n        goal_node = Node(goal)\n        tree_start = [start_node]\n        tree_goal = [goal_node]\n        all_nodes = tree_start + tree_goal\n        edges = []\n\n        best_cost = float('inf')\n        best_path = []\n        found = False\n\n        no_improve_count = 0\n        last_best = float('inf')\n\n        for itr in range(self.max_iter):\n            # Sample using ellipsoidal informed sampling\n            sample_pt = ellipsoid_sample(best_cost)\n\n            # Alternate trees for growth\n            if itr % 2 == 0:\n                tree_a, tree_b = tree_start, tree_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n\n            new_node = add_node(tree_a, sample_pt, all_nodes, edges, best_cost, itr)\n            if new_node is None:\n                continue\n\n            # Try to connect new node to nearest on other tree\n            near_connect = nearest(tree_b, new_node.position)\n            if near_connect is not None:\n                dist_cand = dist(near_connect.position, new_node.position)\n                step_curr = dynamic_step_size(itr, best_cost)\n                if dist_cand <= step_curr and not edge_obstacle(new_node.position, near_connect.position):\n                    # Possible connection\n                    path_candidate = extract_path(new_node, near_connect)\n                    candidate_cost = new_node.cost + dist_cand + near_connect.cost\n                    if candidate_cost + self.improve_tol < best_cost:\n                        best_cost = candidate_cost\n                        best_path = path_candidate\n                        found = True\n                        no_improve_count = 0\n                    else:\n                        no_improve_count += 1\n                else:\n                    if found:\n                        no_improve_count += 1\n\n            # Prune nodes exceeding best cost + tolerance to improve efficiency\n            if found:\n                limit_cost = best_cost + self.improve_tol\n                def prune(tree):\n                    to_remove = []\n                    for node in tree:\n                        if node.cost > limit_cost:\n                            to_remove.append(node)\n                    for node in to_remove:\n                        if node.parent:\n                            node.parent.remove_child(node)\n                        try:\n                            tree.remove(node)\n                            all_nodes.remove(node)\n                        except Exception:\n                            pass\n                prune(tree_start)\n                prune(tree_goal)\n\n            # Early stopping on stagnation\n            if found:\n                if best_cost + self.improve_tol < last_best:\n                    last_best = best_cost\n                    no_improve_count = 0\n                else:\n                    no_improve_count += 1\n                if no_improve_count >= self.no_improve_limit:\n                    break\n\n        # Post-processing shortcutting for smoothness and length improvements\n        if found and len(best_path) > 3:\n            best_path = shortcut_path(best_path)\n\n        if found:\n            return PlannerResult(True, best_path, all_nodes, edges)\n        else:\n            return PlannerResult(False, [], all_nodes, edges)",
          "objective": 44.13367,
          "time_improvement": -94.0,
          "length_improvement": 19.0,
          "smoothness_improvement": 1116.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.056844019889831544,
                    "num_nodes_avg": 131.4,
                    "path_length_avg": 158.28767403870523,
                    "smoothness_avg": 0.04288565059179957,
                    "success_improvement": 0.0,
                    "time_improvement": -134.06629655263816,
                    "length_improvement": 13.240017630681594,
                    "smoothness_improvement": 571.2535594424835,
                    "objective_score": -29.419610590170073
               },
               {
                    "map_id": 1,
                    "success_rate": 0.9,
                    "time_avg": 0.0836817741394043,
                    "num_nodes_avg": 359.9,
                    "path_length_avg": 228.1134320486448,
                    "smoothness_avg": 0.07374435827108994,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": 48.173512745365564,
                    "length_improvement": 23.84917050107601,
                    "smoothness_improvement": 1797.4954542294452,
                    "objective_score": -12.250966604597496
               },
               {
                    "map_id": 2,
                    "success_rate": 0.9,
                    "time_avg": 0.1458946704864502,
                    "num_nodes_avg": 412.3,
                    "path_length_avg": 118.5632699248331,
                    "smoothness_avg": 0.08490620066984564,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": -194.6133217784839,
                    "length_improvement": 21.255921492140313,
                    "smoothness_improvement": 980.0006053966165,
                    "objective_score": -90.7304406112779
               }
          ],
          "success_rate": 0.9333333333333332
     },
     {
          "operator": "e2",
          "algorithm_description": "A bidirectional variant of RRT* with informed sampling and efficient rewiring that grows two trees simultaneously, restricts sampling to an ellipsoidal informed subset after first solution, and performs local rewiring to improve path cost and smoothness with early termination on convergence.",
          "planning_mechanism": "The planner grows start and goal trees bidirectionally with RRT* rewiring, initially samples uniformly to quickly find a path, then constrains samples to an ellipsoidal informed set defined by the current best path cost. After each extension, it attempts to connect the two trees if close enough, while performing localized rewiring to continuously improve path quality. Early stopping criteria limit iterations after no improvements to reduce planning time.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=6000, step_size=5.0, radius=15.0,\n                 post_opt_iters=500, max_no_improve=100, improve_tol=1e-5):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.radius = radius\n        self.post_opt_iters = post_opt_iters\n        self.max_no_improve = max_no_improve\n        self.improve_tol = improve_tol\n\n    def plan(self, map) -> 'PlannerResult':\n        import math, random\n\n        bounds = map.size\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        start_tree = [Node(start)]\n        goal_tree = [Node(goal)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        best_cost = float('inf')\n        best_path = []\n        best_goal_node = None\n\n        c_min = math.dist(start, goal)\n        found_solution = False\n\n        no_improve_count = 0\n        post_opt_count = 0\n\n        def dist(a,b): return math.dist(a,b)\n\n        def steer(frm, to):\n            d = dist(frm, to)\n            if d <= self.step_size:\n                return to\n            return tuple(frm[i] + (to[i]-frm[i]) * self.step_size / d for i in range(dim))\n\n        def in_obstacle(p):\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d_ = obs\n                    px,py,pz = p\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d_:\n                        return True\n                else:\n                    x,y,w,h = obs\n                    px,py = p\n                    if x <= px <= x+w and y <= py <= y+h:\n                        return True\n            return False\n\n        def edge_obstacle(f, t, resolution=1.0):\n            distance = dist(f, t)\n            steps = max(1, int(distance / resolution))\n            for i in range(steps+1):\n                inter = tuple(f[j] + (t[j]-f[j])*(i/steps) for j in range(dim))\n                if in_obstacle(inter):\n                    return True\n            return False\n\n        def nearest(tree, p):\n            best = tree[0]\n            best_d = dist(best.position, p)\n            for n in tree:\n                d2 = dist(n.position, p)\n                if d2 < best_d:\n                    best = n\n                    best_d = d2\n            return best\n\n        def near_nodes(tree, p, radius):\n            result = []\n            r2 = radius**2\n            for n in tree:\n                d2 = sum((n.position[i]-p[i])**2 for i in range(dim))\n                if d2 <= r2:\n                    result.append(n)\n            return result\n\n        def extract_path(n_start, n_goal):\n            path_start, node = [], n_start\n            while node:\n                path_start.append(node.position)\n                node = node.parent\n            path_start.reverse()\n            path_goal = []\n            node = n_goal\n            while node:\n                path_goal.append(node.position)\n                node = node.parent\n            return path_start + path_goal\n\n        def ellipsoid_sample(c_best):\n            # Sample inside prolate hyperspheroid defined by start, goal, c_best\n            import random\n            import math\n\n            if c_best == float('inf'):\n                return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n\n            center = tuple((start[i]+goal[i])/2 for i in range(dim))\n            a1 = [goal[i]-start[i] for i in range(dim)]\n            norm_a1 = math.sqrt(sum(x*x for x in a1))\n            if norm_a1 < 1e-12:\n                return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n            unit_a1 = [x/norm_a1 for x in a1]\n\n            # Compute rotation matrix via Gram-Schmidt or approximate as identity except along a1 axis\n            # For simplicity, rotate only along principal axis for 2D or 3D (orthonormal basis)\n            # Since imports are restricted, implement a simple orthonormal basis:\n\n            # Construct orthonormal basis U with unit_a1 as first vector\n            U = [unit_a1]\n            for i in range(dim-1):\n                base = [0]*dim\n                base[(i+1)%dim] = 1  # simple perpendicular approx\n                # Gram-Schmidt orthogonalize base vs U\n                for u in U:\n                    proj = sum(base[j]*u[j] for j in range(dim))\n                    base = [base[j]-proj*u[j] for j in range(dim)]\n                norm_base = math.sqrt(sum(x*x for x in base))\n                if norm_base > 1e-12:\n                    U.append([x/norm_base for x in base])\n                else:\n                    # fallback: constructs zero vector, skip\n                    U.append([0]*dim)\n\n            # L matrix diagonal\n            r1 = c_best / 2\n            if c_best*c_best - c_min*c_min < 0:\n                r2 = 0\n            else:\n                r2 = math.sqrt(c_best*c_best - c_min*c_min) / 2\n            radii = [r1] + [r2] * (dim - 1)\n\n            # Sample unit ball in dim\n            while True:\n                x_ball = [random.gauss(0,1) for _ in range(dim)]\n                norm_ball = math.sqrt(sum(x*x for x in x_ball))\n                if norm_ball < 1e-12:\n                    continue\n                unit_ball = [x / norm_ball for x in x_ball]\n                u = random.random() ** (1.0/dim)\n                point_ball = [coord * u for coord in unit_ball]\n\n                # Scale by radii\n                point_scaled = [radii[i]*point_ball[i] for i in range(dim)]\n\n                # Rotate via U matrix: point = sum(point_scaled[i] * U[i]) over basis vectors\n                point_rotated = [0]*dim\n                for i in range(dim):\n                    for j in range(dim):\n                        point_rotated[j] += point_scaled[i]*U[i][j]\n\n                sample = tuple(center[i] + point_rotated[i] for i in range(dim))\n\n                if all(0 <= sample[i] <= bounds[i] for i in range(dim)):\n                    return sample\n\n        for iter_count in range(self.max_iter):\n            if found_solution:\n                sample_pt = ellipsoid_sample(best_cost)\n            else:\n                sample_pt = ellipsoid_sample(float('inf'))\n\n            # Alternate growing start and goal trees\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest_node = nearest(tree_a, sample_pt)\n                new_pos = steer(nearest_node.position, sample_pt)\n\n                if in_obstacle(new_pos) or edge_obstacle(nearest_node.position, new_pos):\n                    continue\n\n                new_node = Node(new_pos)\n                near = near_nodes(tree_a, new_pos, self.radius)\n\n                # Choose best parent in near nodes with minimal cost + dist and collision free edge\n                min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n                best_parent = nearest_node\n                for candidate in near:\n                    cand_cost = candidate.cost + dist(candidate.position, new_pos)\n                    if cand_cost + self.improve_tol < min_cost and not edge_obstacle(candidate.position, new_pos):\n                        min_cost = cand_cost\n                        best_parent = candidate\n\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n\n                # Rewire near nodes if new_node offers lower cost connection\n                for near_node in near:\n                    if near_node == best_parent:\n                        continue\n                    alt_cost = new_node.cost + dist(new_node.position, near_node.position)\n                    if alt_cost + self.improve_tol < near_node.cost and not edge_obstacle(new_node.position, near_node.position):\n                        # Remove old edge\n                        try:\n                            edges.remove((near_node.parent, near_node))\n                        except Exception:\n                            pass\n                        if near_node.parent and near_node in near_node.parent.children:\n                            near_node.parent.children.remove(near_node)\n\n                        new_node.add_child(near_node)\n                        near_node.cost = alt_cost\n                        edges.append((new_node, near_node))\n\n                # Try connect trees if nodes close enough\n                connect_node = nearest(tree_b, new_node.position)\n                if dist(new_node.position, connect_node.position) <= self.step_size and not edge_obstacle(new_node.position, connect_node.position):\n                    path = extract_path(new_node, connect_node)\n                    path_cost = new_node.cost + dist(new_node.position, connect_node.position) + connect_node.cost\n                    if path_cost + self.improve_tol < best_cost:\n                        best_cost = path_cost\n                        # Stitch trees at connection nodes: assign parents carefully\n                        # For bidirectional path extraction, keep nodes and edges unchanged,\n                        # just store nodes for path extraction\n                        best_path = path\n                        found_solution = True\n                        best_goal_node = connect_node\n                        no_improve_count = 0\n                    else:\n                        no_improve_count += 1\n\n                    if found_solution and no_improve_count >= self.max_no_improve:\n                        post_opt_count += 1\n                        if post_opt_count >= self.post_opt_iters:\n                            return PlannerResult(True, best_path, nodes, edges)\n                else:\n                    if found_solution:\n                        no_improve_count += 1\n                        post_opt_count += 1\n                        if no_improve_count >= self.max_no_improve or post_opt_count >= self.post_opt_iters:\n                            return PlannerResult(True, best_path, nodes, edges)\n\n        if found_solution:\n            return PlannerResult(True, best_path, nodes, edges)\n        else:\n            return PlannerResult(False, [], nodes, edges)",
          "objective": 52.64884,
          "time_improvement": -220.0,
          "length_improvement": 20.0,
          "smoothness_improvement": 323.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.06786198616027832,
                    "num_nodes_avg": 317.3,
                    "path_length_avg": 155.50621247453464,
                    "smoothness_avg": 0.02411673119934513,
                    "success_improvement": 0.0,
                    "time_improvement": -179.4349134355319,
                    "length_improvement": 14.764580789082476,
                    "smoothness_improvement": 277.4792135897667,
                    "objective_score": -43.58432948926125
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.14667820930480957,
                    "num_nodes_avg": 670.6,
                    "path_length_avg": 226.29277909188164,
                    "smoothness_avg": 0.017873034085429756,
                    "success_improvement": 0.0,
                    "time_improvement": 9.158040406689327,
                    "length_improvement": 24.45695686263326,
                    "smoothness_improvement": 359.8860404442116,
                    "objective_score": 19.22101644180781
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.2925038576126099,
                    "num_nodes_avg": 613.1,
                    "path_length_avg": 120.56565817380633,
                    "smoothness_avg": 0.03399415459254427,
                    "success_improvement": 0.0,
                    "time_improvement": -490.6695072338173,
                    "length_improvement": 19.926030560654297,
                    "smoothness_improvement": 332.4031372296796,
                    "objective_score": -133.58321814760419
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "initial",
          "algorithm_description": "This algorithm with post-optimization: a bidirectional RRT*-Connect that, after finding a first feasible \u201cbest shot\u201d path, keeps optimizing for only a user-defined number of extra iterations (or until no further improvements occur), then terminates\u2014while maintaining strict collision checks and a 30 s time cap.",
          "planning_mechanism": "Mechanism: Alternate tree growth with RRT* best-parent selection and local rewiring; greedily connect the opposite tree; upon the first connection, record the best path and continue only N additional iterations (or until M consecutive non-improving attempts), always staying within bounds and validating node and edge collisions; stop early on time limit and return the best path so far.",
          "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from its tree root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        n = self\n        while n:\n            path.append(n.position)\n            n = n.parent\n        return path[::-1]\n\n\nclass Planner:\n    def __init__(\n        self,\n        max_iter: int = 5000,\n        step_size: float = 5.0,\n        post_opt_iters: int = 400,   # extra iterations after first solution\n        max_no_improve: int = 150,   # early stop if no improvement for this many iterations\n        improve_tol: float = 1e-6,   # minimal cost drop to count as improvement\n        goal_sample_rate: float = 0.05,   # mild goal bias\n        bridge_bias_rate: float = 0.15,   # bias toward the opposite tree root\n        neighbor_gamma: float = 60.0,     # RRT* radius coefficient\n        time_limit_sec: float = 30.0      # hard wall time limit\n    ):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.post_opt_iters = post_opt_iters\n        self.max_no_improve = max_no_improve\n        self.improve_tol = improve_tol\n        self.goal_sample_rate = goal_sample_rate\n        self.bridge_bias_rate = bridge_bias_rate\n        self.neighbor_gamma = neighbor_gamma\n        self.time_limit_sec = time_limit_sec\n\n    def plan(self, map: Map) -> PlannerResult:\n        bounds = map.size                  # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_position = map.start         # Tuple[float, ...]\n        goal_position = map.goal           # Tuple[float, ...]\n        obstacles = map.obstacles          # Rectangular blocks: 2D=(x,y,w,h), 3D=(x,y,z,w,h,d)\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        # Core data\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        # Initialize bidirectional trees\n        start_root = Node(start_position, cost=0.0)\n        goal_root  = Node(goal_position,  cost=0.0)\n        tree_start: List[Node] = [start_root]\n        tree_goal:  List[Node] = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        # Practical RRT* neighborhood clamps\n        max_radius = max(bounds) * 0.30\n        min_radius = max(10.0, self.step_size * 2.0)\n\n        # Best solution tracking + post-optimization control\n        best_cost = float(\"inf\")\n        best_path: List[Tuple[float, ...]] = []\n        found_first_solution = False\n        post_iter_count = 0\n        no_improve_streak = 0\n\n        # Hard time limit\n        start_time = time.time()\n\n        # ----------------- Helper functions -----------------\n        def within_bounds(p):\n            return all(0.0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def clamp_bounds(p):\n            return tuple(min(max(p[d], 0.0), bounds[d]) for d in range(dim))\n\n        def steer(from_pos, to_pos):\n            d = math.dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return clamp_bounds(to_pos)\n            r = self.step_size / d\n            return clamp_bounds(tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * r for i in range(dim)))\n\n        def nearest(tree, pt):\n            return min(tree, key=lambda n: math.dist(n.position, pt))\n\n        def neighbor_radius(n_nodes: int) -> float:\n            if n_nodes < 2:\n                return min_radius\n            r_theory = self.neighbor_gamma * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            return max(min_radius, min(max_radius, r_theory))\n\n        def near_nodes(tree, pos, radius):\n            return [nd for nd in tree if math.dist(nd.position, pos) <= radius]\n\n        def uniform_sample():\n            return tuple(random.uniform(0.0, bounds[d]) for d in range(dim))\n\n        def sample_free(active_tree, other_tree):\n            # Goal bias toward the global goal or start depending on active tree\n            if random.random() < self.goal_sample_rate:\n                return goal_position if active_tree is tree_start else start_position\n            # Bridge bias: sample around the opposite root to encourage meeting\n            if random.random() < self.bridge_bias_rate:\n                anchor = other_tree[0].position\n                jitter = tuple(random.uniform(-2.0*self.step_size, 2.0*self.step_size) for _ in range(dim))\n                s = clamp_bounds(tuple(anchor[i] + jitter[i] for i in range(dim)))\n                return s if not self._is_in_obstacle(s, obstacles, is_3d) else uniform_sample()\n            # Uniform fallback\n            return uniform_sample()\n\n        def add_with_best_parent(tree, new_pos):\n            \"\"\"Insert new_pos with RRT* best-parent selection; returns (new_node, neighbors) or (None, []).\"\"\"\n            r = neighbor_radius(len(tree))\n            neigh = near_nodes(tree, new_pos, r)\n            if not neigh:\n                parent = nearest(tree, new_pos)\n                if self._is_edge_in_obstacle(parent.position, new_pos, obstacles, is_3d):\n                    return None, []\n            else:\n                candidates = [nb for nb in neigh if not self._is_edge_in_obstacle(nb.position, new_pos, obstacles, is_3d)]\n                if not candidates:\n                    return None, []\n                parent = min(candidates, key=lambda nb: nb.cost + math.dist(nb.position, new_pos))\n\n            new_node = Node(new_pos, parent=None, cost=parent.cost + math.dist(parent.position, new_pos))\n            parent.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((parent, new_node))\n            return new_node, neigh\n\n        def rewire_from(pivot: Node, neigh: List[Node]):\n            \"\"\"Local RRT* rewiring around pivot (edge and cost validated).\"\"\"\n            for nb in neigh:\n                if nb is pivot:\n                    continue\n                if self._is_edge_in_obstacle(pivot.position, nb.position, obstacles, is_3d):\n                    continue\n                new_c = pivot.cost + math.dist(pivot.position, nb.position)\n                if new_c + 1e-12 < nb.cost:\n                    if nb.parent is not None:\n                        try:\n                            edges.remove((nb.parent, nb))\n                        except ValueError:\n                            pass\n                        if nb in nb.parent.children:\n                            nb.parent.children.remove(nb)\n                    pivot.add_child(nb)\n                    nb.cost = new_c\n                    edges.append((pivot, nb))\n\n        def stitch_paths(a_node: Node, b_node: Node, a_is_start_side: bool) -> List[Tuple[float, ...]]:\n            \"\"\"Combine root\u2192a_node and root\u2192b_node into a single start\u2192goal path.\"\"\"\n            pa = a_node.path_from_root()\n            pb = b_node.path_from_root()\n            if pa and pb and pa[-1] == pb[-1]:\n                merged = pa + pb[-2::-1]\n            else:\n                merged = pa + pb[::-1]\n            return merged if a_is_start_side else merged[::-1]\n\n        def path_cost(path: List[Tuple[float, ...]]) -> float:\n            return sum(math.dist(path[i], path[i+1]) for i in range(len(path)-1))\n\n        # ----------------- Main loop -----------------\n        for it in range(self.max_iter):\n            # Enforce 30s time limit (return best so far)\n            if time.time() - start_time > self.time_limit_sec:\n                return PlannerResult(\n                    success=(len(best_path) > 0),\n                    path=best_path if best_path else [],\n                    nodes=nodes,\n                    edges=edges\n                )\n\n            # Alternate trees\n            if it % 2 == 0:\n                grow_tree, other_tree = tree_start, tree_goal\n                a_is_start_side = True\n            else:\n                grow_tree, other_tree = tree_goal, tree_start\n                a_is_start_side = False\n\n            # Sampling\n            s = sample_free(grow_tree, other_tree)\n\n            # Extend grow_tree toward sample\n            a_near = nearest(grow_tree, s)\n            a_new_pos = steer(a_near.position, s)\n\n            # Node & edge validity\n            if not within_bounds(a_new_pos) or self._is_in_obstacle(a_new_pos, obstacles, is_3d):\n                if found_first_solution:\n                    post_iter_count += 1\n                    no_improve_streak += 1\n                    if post_iter_count >= self.post_opt_iters or no_improve_streak >= self.max_no_improve:\n                        break\n                continue\n            if self._is_edge_in_obstacle(a_near.position, a_new_pos, obstacles, is_3d):\n                if found_first_solution:\n                    post_iter_count += 1\n                    no_improve_streak += 1\n                    if post_iter_count >= self.post_opt_iters or no_improve_streak >= self.max_no_improve:\n                        break\n                continue\n\n            a_new, a_neigh = add_with_best_parent(grow_tree, a_new_pos)\n            if a_new is None:\n                if found_first_solution:\n                    post_iter_count += 1\n                    no_improve_streak += 1\n                    if post_iter_count >= self.post_opt_iters or no_improve_streak >= self.max_no_improve:\n                        break\n                continue\n            rewire_from(a_new, a_neigh)\n\n            # Greedy connect the other tree toward a_new with stepwise rewiring\n            b_near = nearest(other_tree, a_new.position)\n            current = b_near\n            connected_b = None\n\n            while True:\n                step_pos = steer(current.position, a_new.position)\n                if not within_bounds(step_pos) or self._is_in_obstacle(step_pos, obstacles, is_3d):\n                    break\n                if self._is_edge_in_obstacle(current.position, step_pos, obstacles, is_3d):\n                    break\n\n                b_new, b_neigh = add_with_best_parent(other_tree, step_pos)\n                if b_new is None:\n                    break\n                rewire_from(b_new, b_neigh)\n                current = b_new\n\n                # Try to close the final short bridge exactly to a_new\n                if math.dist(current.position, a_new.position) <= self.step_size:\n                    if not self._is_edge_in_obstacle(current.position, a_new.position, obstacles, is_3d) and a_new.valid:\n                        final_b = Node(\n                            a_new.position,\n                            parent=None,\n                            cost=current.cost + math.dist(current.position, a_new.position)\n                        )\n                        current.add_child(final_b)\n                        other_tree.append(final_b)\n                        nodes.append(final_b)\n                        edges.append((current, final_b))\n                        connected_b = final_b\n                    break\n\n            # If a connection was made, evaluate candidate and manage post-optimization counters\n            if connected_b is not None:\n                candidate = stitch_paths(a_new, connected_b, a_is_start_side)\n                cand_cost = path_cost(candidate)\n\n                if cand_cost + self.improve_tol < best_cost:\n                    best_cost = cand_cost\n                    best_path = candidate\n                    success_state = True\n                    no_improve_streak = 0\n                else:\n                    no_improve_streak += 1\n\n                if not found_first_solution:\n                    found_first_solution = True\n                    post_iter_count = 0\n                else:\n                    post_iter_count += 1\n\n                if post_iter_count >= self.post_opt_iters or no_improve_streak >= self.max_no_improve:\n                    break\n            else:\n                # No successful connection this iteration\n                if found_first_solution:\n                    post_iter_count += 1\n                    no_improve_streak += 1\n                    if post_iter_count >= self.post_opt_iters or no_improve_streak >= self.max_no_improve:\n                        break\n\n        extracted_path = best_path if success_state else []\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    # ----------------- Collision utilities -----------------\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(\n                from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps)\n                for d in range(len(from_pos))\n            )\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n",
          "objective": 58.90993109227704,
          "time_improvement": -241.0,
          "length_improvement": 19.0,
          "smoothness_improvement": 421.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.1319195032119751,
                    "num_nodes_avg": 328.5,
                    "path_length_avg": 154.46328986818702,
                    "smoothness_avg": 0.034972451631960014,
                    "success_improvement": 0.0,
                    "time_improvement": -443.20418611728786,
                    "length_improvement": 15.33622319578786,
                    "smoothness_improvement": 447.3948119344172,
                    "objective_score": -121.52254785804155
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.12165653705596924,
                    "num_nodes_avg": 563.9,
                    "path_length_avg": 238.20393947669004,
                    "smoothness_avg": 0.017926604047225774,
                    "success_improvement": 0.0,
                    "time_improvement": 24.654669048116872,
                    "length_improvement": 20.480668682442023,
                    "smoothness_improvement": 361.264434146107,
                    "objective_score": 21.49112409463081
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.1998586416244507,
                    "num_nodes_avg": 499.0,
                    "path_length_avg": 120.18715712039948,
                    "smoothness_avg": 0.04356825221869788,
                    "success_improvement": 0.0,
                    "time_improvement": -303.58580679328855,
                    "length_improvement": 20.17741293804379,
                    "smoothness_improvement": 454.1849523479772,
                    "objective_score": -76.69836951342039
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "initial",
          "algorithm_description": "This algorithm is an optimal variant of RRT that improves path quality over time by rewiring the tree to minimize path cost. It incrementally builds a space-filling tree from start toward the goal while performing local optimizations by choosing better parents and rewiring nearby nodes.",
          "planning_mechanism": "The planner samples a point, extends the nearest node toward it, finds nearby nodes within a radius, selects the node offering the lowest-cost path as the parent, and rewires suboptimal neighbors to the new node if a shorter path through it is possible and valid.",
          "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.children.remove(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 3.0, goal_sample_rate: float = 0.05, neighbor_radius: float = 10.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n\n    def plan(self, map) -> PlannerResult:\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        root = Node(start_position)\n        nodes.append(root)\n\n        for _ in range(self.max_iter):\n            # Goal biasing\n            if random.random() < self.goal_sample_rate:\n                sample = goal_position\n            else:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n\n            # Nearest node\n            nearest_node = min(nodes, key=lambda n: math.dist(n.position, sample))\n            direction = tuple(sample[d] - nearest_node.position[d] for d in range(len(bounds)))\n            dist_to_sample = math.dist(nearest_node.position, sample)\n            if dist_to_sample == 0:\n                continue\n            unit = tuple(d / dist_to_sample for d in direction)\n            new_position = tuple(nearest_node.position[d] + unit[d] * min(self.step_size, dist_to_sample) for d in range(len(bounds)))\n\n            if self._is_in_obstacle(new_position, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_position, obstacles, is_3d):\n                continue\n\n            # Nearby nodes for choosing best parent\n            new_node = Node(new_position)\n            near_nodes = [n for n in nodes if math.dist(n.position, new_position) <= self.neighbor_radius]\n\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_position)\n            best_parent = nearest_node\n\n            for near_node in near_nodes:\n                temp_cost = near_node.cost + math.dist(near_node.position, new_position)\n                if temp_cost < min_cost and not self._is_edge_in_obstacle(near_node.position, new_position, obstacles, is_3d):\n                    min_cost = temp_cost\n                    best_parent = near_node\n\n            new_node.update_parent(best_parent, min_cost)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewiring\n            for near_node in near_nodes:\n                if near_node == best_parent:\n                    continue\n                cost_through_new = new_node.cost + math.dist(near_node.position, new_position)\n                if cost_through_new < near_node.cost and not self._is_edge_in_obstacle(new_position, near_node.position, obstacles, is_3d):\n                    edges.remove((near_node.parent, near_node))\n                    near_node.update_parent(new_node, cost_through_new)\n                    edges.append((new_node, near_node))\n\n            # Check goal connection\n            if math.dist(new_position, goal_position) <= self.step_size:\n                if not self._is_edge_in_obstacle(new_position, goal_position, obstacles, is_3d) and not self._is_in_obstacle(goal_position, obstacles, is_3d):\n                    goal_node = Node(goal_position)\n                    goal_cost = new_node.cost + math.dist(new_position, goal_position)\n                    goal_node.update_parent(new_node, goal_cost)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    success_state = True\n                    break\n\n        if success_state:\n            path = []\n            node = nodes[-1]\n            while node:\n                path.append(node.position)\n                node = node.parent\n            extracted_path = path[::-1]\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n    ",
          "objective": 72.28152473444305,
          "time_improvement": -283.0,
          "length_improvement": 20.0,
          "smoothness_improvement": 160.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.054693055152893064,
                    "num_nodes_avg": 400.7,
                    "path_length_avg": 161.43019076253373,
                    "smoothness_avg": 0.013949692064313773,
                    "success_improvement": 0.0,
                    "time_improvement": -125.20928132102236,
                    "length_improvement": 11.51755441798709,
                    "smoothness_improvement": 118.34297304767232,
                    "objective_score": -30.060536880276086
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.6519697904586792,
                    "num_nodes_avg": 1652.8,
                    "path_length_avg": 225.43577304469767,
                    "smoothness_avg": 0.011237143837375355,
                    "success_improvement": 0.0,
                    "time_improvement": -303.7833134288512,
                    "length_improvement": 24.743050148734607,
                    "smoothness_improvement": 189.13980472322058,
                    "objective_score": -75.34346491579849
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.2573090553283691,
                    "num_nodes_avg": 832.5,
                    "path_length_avg": 116.5111984426798,
                    "smoothness_avg": 0.02150547486960897,
                    "success_improvement": 0.0,
                    "time_improvement": -419.5986615632748,
                    "length_improvement": 22.618809661443194,
                    "smoothness_improvement": 173.54805297239113,
                    "objective_score": -111.44057240725456
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "initial",
          "algorithm_description": "This algorithm is a sampling-based path planning algorithm that incrementally builds a space-filling tree rooted at the start position by randomly sampling the configuration space and extending the nearest existing node toward the sample. It continues this process until the goal is reached or a maximum number of iterations is exceeded.",
          "planning_mechanism": "The planner randomly samples free configurations, finds the nearest node in the current tree, attempts to extend toward the sample by a fixed step size, and adds the new node if the move is valid. This repeats until the goal is reached or iteration limit is hit.",
          "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 3.0, goal_sample_rate: float = 0.05):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map) -> PlannerResult:\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        root = Node(start_position)\n        nodes.append(root)\n\n        for _ in range(self.max_iter):\n            # Goal biasing\n            if random.random() < self.goal_sample_rate:\n                sample = goal_position\n            else:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n\n            # Find nearest node\n            nearest_node = min(nodes, key=lambda n: math.dist(n.position, sample))\n\n            # Steer\n            direction = tuple(sample[d] - nearest_node.position[d] for d in range(len(bounds)))\n            length = math.dist(nearest_node.position, sample)\n            if length == 0:\n                continue\n            unit = tuple(d / length for d in direction)\n            new_position = tuple(nearest_node.position[d] + unit[d] * min(self.step_size, length) for d in range(len(bounds)))\n\n            if self._is_in_obstacle(new_position, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_position, obstacles, is_3d):\n                continue\n\n            new_node = Node(new_position, parent=nearest_node, cost=nearest_node.cost + math.dist(nearest_node.position, new_position))\n            nearest_node.add_child(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n\n            # Check if goal reached\n            if math.dist(new_position, goal_position) <= self.step_size:\n                if not self._is_edge_in_obstacle(new_position, goal_position, obstacles, is_3d) and not self._is_in_obstacle(goal_position, obstacles, is_3d):\n                    goal_node = Node(goal_position, parent=new_node, cost=new_node.cost + math.dist(new_position, goal_position))\n                    new_node.add_child(goal_node)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    success_state = True\n                    break\n\n        if success_state:\n            path = []\n            node = nodes[-1]\n            while node:\n                path.append(node.position)\n                node = node.parent\n            extracted_path = path[::-1]\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n    ",
          "objective": 110.32172404977739,
          "time_improvement": -313.0,
          "length_improvement": -3.0,
          "smoothness_improvement": 419.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.042421364784240724,
                    "num_nodes_avg": 516.4,
                    "path_length_avg": 189.15618872126882,
                    "smoothness_avg": 0.006191511424887926,
                    "success_improvement": 0.0,
                    "time_improvement": -74.67821186819229,
                    "length_improvement": -3.679504409748345,
                    "smoothness_improvement": -3.0894011182488095,
                    "objective_score": -24.62661321189794
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.2341987133026123,
                    "num_nodes_avg": 1725.4,
                    "path_length_avg": 300.4983691862574,
                    "smoothness_avg": 0.00391355736693649,
                    "success_improvement": 0.0,
                    "time_improvement": -45.045880717222865,
                    "length_improvement": -0.31500500035262213,
                    "smoothness_improvement": 0.6986498727096686,
                    "objective_score": -13.699273966014882
               },
               {
                    "map_id": 2,
                    "success_rate": 0.9,
                    "time_avg": 0.45523672103881835,
                    "num_nodes_avg": 1525.1,
                    "path_length_avg": 158.46249346590153,
                    "smoothness_avg": 0.10679626147523477,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": -819.2851399821861,
                    "length_improvement": -5.243242986980386,
                    "smoothness_improvement": 1258.4405630849506,
                    "objective_score": -292.63928497141933
               }
          ],
          "success_rate": 0.9666666666666667
     },
     {
          "operator": "initial",
          "algorithm_description": "This algorithm with post-optimization limits: a two-tree, asymptotically optimal planner that, after finding a first feasible path, continues improving within the start\u2013goal ellipsoid for only a user-defined number of extra iterations (or until no improvement is observed), then stops.",
          "planning_mechanism": "Mechanism: Alternate expanding start/goal trees with RRT* best-parent selection and local rewiring; greedily connect the opposite tree; upon first connection, switch to informed (ellipsoidal) sampling and keep optimizing for N additional iterations (or until M consecutive non-improvements), always enforcing node and edge collision checks, bounds, and a strict 30 s time limit that returns the best path so far.",
          "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        n = self\n        while n:\n            path.append(n.position)\n            n = n.parent\n        return path[::-1]\n\n\nclass Planner:\n    def __init__(\n        self,\n        max_iter: int = 5000,\n        step_size: float = 5.0,\n        neighbor_radius: float = 25.0,\n        post_opt_iters: int = 400,    # extra iterations after first solution\n        max_no_improve: int = 150,    # stop early if this many consecutive iterations show no improvement\n        improve_tol: float = 1e-6,    # minimal cost drop to count as improvement\n        time_limit_sec: float = 30.0  # hard wall time limit\n    ):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.neighbor_radius = neighbor_radius\n        self.post_opt_iters = post_opt_iters\n        self.max_no_improve = max_no_improve\n        self.improve_tol = improve_tol\n        self.time_limit_sec = time_limit_sec\n\n    def plan(self, map: Map) -> PlannerResult:\n        bounds = map.size                  # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_position = map.start         # Tuple[float, ...]\n        goal_position = map.goal           # Tuple[float, ...]\n        obstacles = map.obstacles          # Rectangular blocks / boxes\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        # Core data\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        # Initialize two trees\n        start_root = Node(start_position, cost=0.0)\n        goal_root  = Node(goal_position,  cost=0.0)\n        tree_a: List[Node] = [start_root]\n        tree_b: List[Node] = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        # RRT* neighborhood (practical clamp)\n        gamma_rrt_star = 60.0\n        max_radius = max(bounds) * 0.30\n        min_radius = max(10.0, self.step_size * 2.0)\n\n        # Best solution & informed sampling params\n        best_cost = float(\"inf\")\n        best_path: List[Tuple[float, ...]] = []\n        c_min = math.dist(start_position, goal_position)\n\n        # Post-optimization control\n        found_first_solution = False\n        post_iter_count = 0\n        no_improve_streak = 0\n\n        # Time guard\n        start_time = time.time()\n\n        # ---------- Helpers ----------\n        def within_bounds(p):\n            return all(0.0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def nearest(tree, pt):\n            return min(tree, key=lambda n: math.dist(n.position, pt))\n\n        def steer(from_pos, to_pos):\n            d = math.dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            r = self.step_size / d\n            return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * r for i in range(dim))\n\n        def neighbor_radius_fn(n_nodes: int) -> float:\n            if n_nodes < 2:\n                return min_radius\n            r_theory = gamma_rrt_star * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            return max(min_radius, min(max_radius, r_theory))\n\n        def near_nodes(tree, pos, radius):\n            return [nd for nd in tree if math.dist(nd.position, pos) <= radius]\n\n        def add_with_best_parent(tree, new_pos):\n            \"\"\"Insert new_pos using RRT* best-parent selection; return (new_node, neighbors) or (None, []).\"\"\"\n            r = neighbor_radius_fn(len(tree))\n            neigh = near_nodes(tree, new_pos, r)\n            parent_candidates = neigh if neigh else [nearest(tree, new_pos)]\n            parent_candidates = [nb for nb in parent_candidates\n                                 if not self._is_edge_in_obstacle(nb.position, new_pos, obstacles, is_3d)]\n            if not parent_candidates:\n                return None, []\n            parent = min(parent_candidates, key=lambda nb: nb.cost + math.dist(nb.position, new_pos))\n            new_node = Node(new_pos, parent=None, cost=parent.cost + math.dist(parent.position, new_pos))\n            parent.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((parent, new_node))\n            return new_node, neigh\n\n        def rewire_from(pivot: Node, neigh: List[Node]):\n            for nb in neigh:\n                if nb is pivot:\n                    continue\n                if self._is_edge_in_obstacle(pivot.position, nb.position, obstacles, is_3d):\n                    continue\n                new_c = pivot.cost + math.dist(pivot.position, nb.position)\n                if new_c + 1e-12 < nb.cost:\n                    if nb.parent is not None:\n                        try:\n                            edges.remove((nb.parent, nb))\n                        except ValueError:\n                            pass\n                        if nb in nb.parent.children:\n                            nb.parent.children.remove(nb)\n                    pivot.add_child(nb)\n                    nb.cost = new_c\n                    edges.append((pivot, nb))\n\n        def stitch_paths(meet_a: Node, meet_b: Node, a_is_start_side: bool) -> List[Tuple[float, ...]]:\n            \"\"\"Create full path from start to goal using meeting nodes from both trees.\"\"\"\n            path_a = meet_a.path_from_root()\n            path_b = meet_b.path_from_root()\n            if path_a and path_b and path_a[-1] == path_b[-1]:\n                merged = path_a + path_b[-2::-1]\n            else:\n                merged = path_a + path_b[::-1]\n            return merged if a_is_start_side else merged[::-1]\n\n        def path_cost(path):\n            return sum(math.dist(path[i], path[i+1]) for i in range(len(path)-1))\n\n        # ---------- Main loop ----------\n        for it in range(self.max_iter):\n            # Hard time limit\n            if time.time() - start_time > self.time_limit_sec:\n                return PlannerResult(\n                    success=(len(best_path) > 0),\n                    path=best_path if best_path else [],\n                    nodes=nodes,\n                    edges=edges\n                )\n\n            # Choose expansion/connection sides\n            if it % 2 == 0:\n                grow_tree, other_tree = tree_a, tree_b\n                a_is_start_side = True\n            else:\n                grow_tree, other_tree = tree_b, tree_a\n                a_is_start_side = False\n\n            # Informed sampling (uniform before first solution; ellipsoid after)\n            sample = self._sample_informed(start_position, goal_position, best_cost, c_min, bounds)\n\n            # Extend grow_tree toward sample\n            a_near = nearest(grow_tree, sample)\n            a_new_pos = steer(a_near.position, sample)\n\n            if (not within_bounds(a_new_pos)) or self._is_in_obstacle(a_new_pos, obstacles, is_3d):\n                # count post-optimization iterations if already in post phase\n                if found_first_solution:\n                    post_iter_count += 1\n                    no_improve_streak += 1\n                    if post_iter_count >= self.post_opt_iters or no_improve_streak >= self.max_no_improve:\n                        break\n                continue\n            if self._is_edge_in_obstacle(a_near.position, a_new_pos, obstacles, is_3d):\n                if found_first_solution:\n                    post_iter_count += 1\n                    no_improve_streak += 1\n                    if post_iter_count >= self.post_opt_iters or no_improve_streak >= self.max_no_improve:\n                        break\n                continue\n\n            a_new, a_neigh = add_with_best_parent(grow_tree, a_new_pos)\n            if a_new is None:\n                if found_first_solution:\n                    post_iter_count += 1\n                    no_improve_streak += 1\n                    if post_iter_count >= self.post_opt_iters or no_improve_streak >= self.max_no_improve:\n                        break\n                continue\n            rewire_from(a_new, a_neigh)\n\n            # Greedy connect other_tree toward a_new, with local rewiring each step\n            b_near = nearest(other_tree, a_new.position)\n            current = b_near\n            connected_b = None\n\n            while True:\n                step_pos = steer(current.position, a_new.position)\n                if (not within_bounds(step_pos)) or self._is_in_obstacle(step_pos, obstacles, is_3d):\n                    break\n                if self._is_edge_in_obstacle(current.position, step_pos, obstacles, is_3d):\n                    break\n\n                b_new, b_neigh = add_with_best_parent(other_tree, step_pos)\n                if b_new is None:\n                    break\n                rewire_from(b_new, b_neigh)\n                current = b_new\n\n                # Try a final short bridge\n                if math.dist(current.position, a_new.position) <= self.step_size:\n                    if not self._is_edge_in_obstacle(current.position, a_new.position, obstacles, is_3d) and a_new.valid:\n                        final_b = Node(\n                            a_new.position,\n                            parent=None,\n                            cost=current.cost + math.dist(current.position, a_new.position)\n                        )\n                        current.add_child(final_b)\n                        other_tree.append(final_b)\n                        nodes.append(final_b)\n                        edges.append((current, final_b))\n                        connected_b = final_b\n                    break\n\n            # If a connection was made, evaluate and manage post-optimization counters\n            if connected_b is not None:\n                candidate_path = stitch_paths(a_new, connected_b, a_is_start_side)\n                cand_cost = path_cost(candidate_path)\n\n                if cand_cost + self.improve_tol < best_cost:\n                    best_cost = cand_cost\n                    best_path = candidate_path\n                    success_state = True\n                    no_improve_streak = 0\n                else:\n                    no_improve_streak += 1\n\n                if not found_first_solution:\n                    found_first_solution = True\n                    post_iter_count = 0\n                else:\n                    post_iter_count += 1\n\n                if post_iter_count >= self.post_opt_iters or no_improve_streak >= self.max_no_improve:\n                    break\n            else:\n                # No successful connection this iteration\n                if found_first_solution:\n                    post_iter_count += 1\n                    no_improve_streak += 1\n                    if post_iter_count >= self.post_opt_iters or no_improve_streak >= self.max_no_improve:\n                        break\n\n        extracted_path = best_path if success_state else []\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    # ---------------- Informed Sampling ----------------\n    def _sample_informed(self, start, goal, c_best, c_min, bounds):\n        \"\"\"Uniform in bounds if no solution; otherwise sample within the start\u2013goal ellipsoid.\"\"\"\n        dim = len(bounds)\n        if c_best == float(\"inf\") or c_min <= 1e-12:\n            return tuple(random.uniform(0.0, bounds[d]) for d in range(dim))\n\n        # Ellipsoid radii\n        r1 = c_best / 2.0\n        r_other_sq = max(c_best * c_best - c_min * c_min, 0.0)\n        r_other = math.sqrt(r_other_sq) / 2.0\n\n        # Center and first axis (unit)\n        center = tuple((s + g) / 2.0 for s, g in zip(start, goal))\n        a1 = tuple((goal[d] - start[d]) / c_min for d in range(dim))\n\n        # Orthonormal basis aligned with a1\n        if dim == 2:\n            a2 = (-a1[1], a1[0])\n            basis = (a1, a2)\n            radii = (r1, r_other)\n        else:  # 3D\n            ref = (1.0, 0.0, 0.0) if abs(a1[0]) < 0.9 else (0.0, 1.0, 0.0)\n            b2 = self._normalize(self._cross(a1, ref))\n            if self._norm(b2) < 1e-12:\n                ref = (0.0, 0.0, 1.0)\n                b2 = self._normalize(self._cross(a1, ref))\n            b3 = self._cross(a1, b2)\n            basis = (a1, b2, b3)\n            radii = (r1, r_other, r_other)\n\n        u = self._sample_unit_ball(dim)\n\n        mapped = []\n        for d in range(dim):\n            val = center[d]\n            for i in range(dim):\n                val += basis[i][d] * radii[i] * u[i]\n            mapped.append(val)\n\n        mapped = tuple(min(max(mapped[d], 0.0), bounds[d]) for d in range(dim))\n        return mapped\n\n    def _sample_unit_ball(self, dim):\n        while True:\n            v = [random.gauss(0.0, 1.0) for _ in range(dim)]\n            n = math.sqrt(sum(x * x for x in v))\n            if n > 1e-12:\n                v = [x / n for x in v]\n                r = random.random() ** (1.0 / dim)\n                return tuple(v[i] * r for i in range(dim))\n\n    def _cross(self, a, b):\n        ax, ay, az = a\n        bx, by, bz = b\n        return (ay * bz - az * by, az * bx - ax * bz, ax * by - ay * bx)\n\n    def _norm(self, v):\n        return math.sqrt(sum(x * x for x in v))\n\n    def _normalize(self, v):\n        n = self._norm(v)\n        if n < 1e-12:\n            return v\n        return tuple(x / n for x in v)\n\n    # ---------------- Collision Utilities ----------------\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(\n                from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps)\n                for d in range(len(from_pos))\n            )\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n",
          "objective": 112.05796489046001,
          "time_improvement": -419.0,
          "length_improvement": 19.0,
          "smoothness_improvement": 399.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.21478092670440674,
                    "num_nodes_avg": 471.7,
                    "path_length_avg": 148.15736974768996,
                    "smoothness_avg": 0.0309097442240469,
                    "success_improvement": 0.0,
                    "time_improvement": -784.4021971225352,
                    "length_improvement": 18.79259793753102,
                    "smoothness_improvement": 383.8046186902347,
                    "objective_score": -222.12607728079075
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.14841887950897217,
                    "num_nodes_avg": 504.1,
                    "path_length_avg": 243.50061456463112,
                    "smoothness_avg": 0.017440476273822066,
                    "success_improvement": 0.0,
                    "time_improvement": 8.07999416450198,
                    "length_improvement": 18.712486081748057,
                    "smoothness_improvement": 348.7560163927473,
                    "objective_score": 15.395269980363166
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.2876542329788208,
                    "num_nodes_avg": 647.5,
                    "path_length_avg": 119.19911869718798,
                    "smoothness_avg": 0.04433447387231853,
                    "success_improvement": 0.0,
                    "time_improvement": -480.87638718374615,
                    "length_improvement": 20.833621013407036,
                    "smoothness_improvement": 463.9312352254324,
                    "objective_score": -129.44308737095247
               }
          ],
          "success_rate": 1.0
     }
]