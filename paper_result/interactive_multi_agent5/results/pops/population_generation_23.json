[
     {
          "operator": "m3",
          "algorithm_description": "A simplified bidirectional RRT* planner with adaptive neighborhood radius, heuristic-informed sampling inside ellipsoidal bounds after first solution, and efficient rewiring that balances exploration and refinement. The algorithm alternates expansions between start and goal trees, prunes via cost-aware rewiring with radius scaled to tree size, and performs iterative shortcut smoothing on the result to improve path length and smoothness while limiting planning time with stagnation-based early stopping.",
          "planning_mechanism": "This planner grows two trees from start and goal, samples points uniformly initially, and after first solution focuses samples inside a heuristic ellipsoid bounding shorter solutions. Nodes are added using a steer function, parents are chosen among neighbors within a radius that decays adaptively with iteration count and tree size, and rewiring lowers path costs. Connection attempts bridge trees incrementally. Post planning applies iterative shortcut smoothing removing redundant points and reducing unnecessary detours, producing shorter, smoother paths faster than naive RRT*.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=4000, step_size=6.0, radius_max=25.0, radius_min=7.0, no_improve_limit=60, time_limit=25.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.radius_max = radius_max\n        self.radius_min = radius_min\n        self.no_improve_limit = no_improve_limit\n        self.time_limit = time_limit\n\n    def plan(self, map):\n        import time\n        import math\n        import random\n\n        bounds = map.size\n        dim = len(bounds)\n        start = tuple(map.start)\n        goal = tuple(map.goal)\n        obstacles = map.obstacles\n        is_3d = (dim == 3)\n\n        def in_bounds(p):\n            return all(0.0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def in_obstacle(p):\n            px, py, pz = (p + (0, 0, 0))[:3]\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    if x <= px <= x+w and y <= py <= y+h:\n                        return True\n            return False\n\n        def edge_in_obstacle(a, b, resolution=1.0):\n            dist = math.dist(a,b)\n            if dist < 1e-12:\n                return False\n            steps = max(3, int(dist/resolution))\n            for i in range(steps+1):\n                pt = tuple(a[d] + (b[d]-a[d]) * i/steps for d in range(dim))\n                if in_obstacle(pt):\n                    return True\n            return False\n\n        def steer(frm, to):\n            dist = math.dist(frm, to)\n            if dist <= self.step_size:\n                return to\n            ratio = self.step_size / dist\n            return tuple(frm[d] + (to[d]-frm[d]) * ratio for d in range(dim))\n\n        def adaptive_radius(n_nodes, iter_i):\n            if n_nodes < 2:\n                return self.radius_max\n            r = self.radius_max * ((math.log(n_nodes) / n_nodes) ** (1/dim))\n            decay = max(self.radius_min / self.radius_max, 1.0 - 0.9 * (iter_i / self.max_iter))\n            return max(self.radius_min, min(r * decay, self.radius_max))\n\n        def neighbors(tree, pos, radius):\n            r_sq = radius * radius\n            res = []\n            for node in tree:\n                d_sq = 0.0\n                for i in range(dim):\n                    diff = node.position[i] - pos[i]\n                    d_sq += diff*diff\n                    if d_sq > r_sq:\n                        break\n                else:\n                    res.append(node)\n            return res\n\n        def choose_parent(tree, new_pos, iter_i):\n            radius = adaptive_radius(len(tree), iter_i)\n            nbrs = neighbors(tree, new_pos, radius)\n            valid_parents = [n for n in nbrs if not edge_in_obstacle(n.position, new_pos)]\n            if not valid_parents:\n                # fallback nearest with collision\n                nearest = min((n for n in tree if not edge_in_obstacle(n.position, new_pos)), key=lambda n: math.dist(n.position, new_pos), default=None)\n                if nearest is None:\n                    return None, []\n                c = nearest.cost + math.dist(nearest.position, new_pos)\n                new_node = Node(new_pos, parent=nearest, cost=c)\n                nearest.add_child(new_node)\n                tree.append(new_node)\n                return new_node, []\n            best_parent = min(valid_parents, key=lambda n: n.cost + math.dist(n.position, new_pos))\n            c = best_parent.cost + math.dist(best_parent.position, new_pos)\n            new_node = Node(new_pos, parent=best_parent, cost=c)\n            best_parent.add_child(new_node)\n            tree.append(new_node)\n            return new_node, valid_parents\n\n        def rewire(pivot, nbrs):\n            for nb in nbrs:\n                if nb == pivot.parent:\n                    continue\n                dist_p = math.dist(pivot.position, nb.position)\n                new_cost = pivot.cost + dist_p\n                if new_cost + 1e-10 < nb.cost and not edge_in_obstacle(pivot.position, nb.position):\n                    if nb.parent:\n                        nb.parent.remove_child(nb)\n                    pivot.add_child(nb)\n                    nb.cost = new_cost\n\n        def attempt_connect(tree, target_node):\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda n: math.dist(n.position, target_node.position))\n            dist = math.dist(nearest.position, target_node.position)\n            if dist <= self.step_size:\n                if edge_in_obstacle(nearest.position, target_node.position) or in_obstacle(target_node.position):\n                    return None\n                new_node = Node(target_node.position, parent=nearest, cost=nearest.cost + dist)\n                nearest.add_child(new_node)\n                tree.append(new_node)\n                return new_node\n            current = nearest\n            steps = int(math.ceil(dist / self.step_size))\n            for _ in range(steps):\n                new_pos = steer(current.position, target_node.position)\n                if not in_bounds(new_pos) or in_obstacle(new_pos) or edge_in_obstacle(current.position, new_pos):\n                    return None\n                new_node = Node(new_pos, parent=current, cost=current.cost + math.dist(current.position, new_pos))\n                current.add_child(new_node)\n                tree.append(new_node)\n                current = new_node\n                if math.dist(current.position, target_node.position) <= self.step_size:\n                    if edge_in_obstacle(current.position, target_node.position) or in_obstacle(target_node.position):\n                        return None\n                    final_node = Node(target_node.position, parent=current, cost=current.cost + math.dist(current.position, target_node.position))\n                    current.add_child(final_node)\n                    tree.append(final_node)\n                    return final_node\n            return None\n\n        def sample_uniform():\n            return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        def sample_informed(c_best, c_min):\n            if c_best == float('inf') or c_min < 1e-12:\n                return sample_uniform()\n            center = tuple((start[d]+goal[d])*0.5 for d in range(dim))\n            unit_vec = []\n            for d in range(dim):\n                unit_vec.append((goal[d] - start[d]) / c_min)\n            r1 = c_best * 0.5\n            val = max(c_best*c_best - c_min*c_min, 0.0)\n            r_other = math.sqrt(val)*0.5\n\n            if dim == 2:\n                a1 = unit_vec\n                a2 = (-a1[1], a1[0])\n                basis = (a1, a2)\n                radii = (r1, r_other)\n            else:\n                def cross(u,v):\n                    return (u[1]*v[2]-u[2]*v[1], u[2]*v[0]-u[0]*v[2], u[0]*v[1]-u[1]*v[0])\n                def norm(v):\n                    return math.sqrt(sum(x*x for x in v))\n                a1 = unit_vec\n                ref = (1,0,0) if abs(a1[0]) < 0.9 else (0,1,0)\n                b2 = cross(a1, ref)\n                nb2 = norm(b2)\n                if nb2 < 1e-12:\n                    ref = (0,0,1)\n                    b2 = cross(a1, ref)\n                    nb2 = norm(b2)\n                b2 = tuple(x/nb2 for x in b2)\n                b3 = cross(a1,b2)\n                basis = (a1,b2,b3)\n                radii = (r1,r_other,r_other)\n\n            def sample_unit_ball(ndim):\n                while True:\n                    vec = [random.gauss(0,1) for _ in range(ndim)]\n                    nrm = math.sqrt(sum(v*v for v in vec))\n                    if nrm < 1e-12:\n                        continue\n                    vec = [v/nrm for v in vec]\n                    r = random.random()**(1/ndim)\n                    return [v*r for v in vec]\n\n            u = sample_unit_ball(dim)\n            mapped = []\n            for d in range(dim):\n                v = center[d]\n                for i in range(dim):\n                    v += basis[i][d]*radii[i]*u[i]\n                # Clamp to bounds\n                v = max(0.0, min(bounds[d], v))\n                mapped.append(v)\n            return tuple(mapped)\n\n        def shortcut_smooth(path, iterations=3):\n            if len(path) < 3:\n                return path[:]\n            for _ in range(iterations):\n                i = 0\n                while i < len(path)-2:\n                    if not edge_in_obstacle(path[i], path[i+2]):\n                        del path[i+1]\n                    else:\n                        i += 1\n            return path\n\n        start_node = Node(start, cost=0.0)\n        goal_node = Node(goal, cost=0.0)\n        start_tree = [start_node]\n        goal_tree = [goal_node]\n        nodes = [start_node, goal_node]\n        edges = []\n\n        best_path = []\n        best_cost = float('inf')\n        c_min = math.dist(start, goal)\n        found = False\n        no_improve = 0\n        t_start = time.time()\n\n        for i in range(self.max_iter):\n            if time.time() - t_start > self.time_limit:\n                break\n            if found:\n                sample = sample_informed(best_cost, c_min)\n                if random.random() < 0.1:\n                    sample = sample_uniform()\n            else:\n                sample = sample_uniform()\n\n            if not in_bounds(sample) or in_obstacle(sample):\n                if found:\n                    no_improve += 1\n                    if no_improve >= self.no_improve_limit:\n                        break\n                continue\n\n            tree_a, tree_b = (start_tree, goal_tree) if i%2 == 0 else (goal_tree, start_tree)\n\n            near = min(tree_a, key=lambda n: math.dist(n.position, sample))\n            new_pos = steer(near.position, sample)\n\n            if (not in_bounds(new_pos)) or in_obstacle(new_pos) or edge_in_obstacle(near.position, new_pos):\n                if found:\n                    no_improve += 1\n                    if no_improve >= self.no_improve_limit:\n                        break\n                continue\n\n            new_node, nbrs = choose_parent(tree_a, new_pos, i)\n            if new_node is None:\n                if found:\n                    no_improve += 1\n                    if no_improve >= self.no_improve_limit:\n                        break\n                continue\n\n            rewire(new_node, nbrs)\n            nodes.append(new_node)\n            if new_node.parent:\n                edges.append((new_node.parent, new_node))\n\n            connected = attempt_connect(tree_b, new_node)\n            if connected:\n                if i % 2 == 0:\n                    path1 = new_node.path_from_root()\n                    path2 = connected.path_from_root()\n                else:\n                    path1 = connected.path_from_root()\n                    path2 = new_node.path_from_root()\n                if path1 and path2 and path1[-1] == path2[-1]:\n                    candidate = path1 + path2[-2::-1]\n                else:\n                    candidate = path1 + path2[::-1]\n\n                cost_path = 0.0\n                for j in range(len(candidate)-1):\n                    cost_path += math.dist(candidate[j], candidate[j+1])\n\n                if cost_path + 1e-9 < best_cost:\n                    best_path = candidate\n                    best_cost = cost_path\n                    found = True\n                    no_improve = 0\n                else:\n                    no_improve += 1\n                    if no_improve >= self.no_improve_limit:\n                        break\n            else:\n                if found:\n                    no_improve += 1\n                    if no_improve >= self.no_improve_limit:\n                        break\n\n        if found and len(best_path) >= 3:\n            best_path = shortcut_smooth(best_path, iterations=5)\n\n        return PlannerResult(success=found, path=best_path, nodes=nodes, edges=edges)",
          "objective": -37.48589,
          "time_improvement": 65.0,
          "length_improvement": 16.0,
          "smoothness_improvement": 1704.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.015254044532775879,
                    "num_nodes_avg": 101.3,
                    "path_length_avg": 165.81254021340436,
                    "smoothness_avg": 0.05533273154630356,
                    "success_improvement": 0.0,
                    "time_improvement": 37.18850781215486,
                    "length_improvement": 9.115519241194,
                    "smoothness_improvement": 766.0774056493822,
                    "objective_score": 20.45625091660977
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.021648097038269042,
                    "num_nodes_avg": 222.5,
                    "path_length_avg": 236.7791727604512,
                    "smoothness_avg": 0.1135825828084687,
                    "success_improvement": 0.0,
                    "time_improvement": 86.59272181094168,
                    "length_improvement": 20.956296821958638,
                    "smoothness_improvement": 2822.561665889502,
                    "objective_score": 52.6644029659052
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.01422429084777832,
                    "num_nodes_avg": 175.1,
                    "path_length_avg": 124.63481867684409,
                    "smoothness_avg": 0.1276752449373225,
                    "success_improvement": 0.0,
                    "time_improvement": 71.27608868346934,
                    "length_improvement": 17.223487907137493,
                    "smoothness_improvement": 1524.0196915964568,
                    "objective_score": 39.337017807305585
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "A streamlined bidirectional RRT* planner with adaptive neighbor radius, hybrid uniform and ellipsoidal informed sampling guiding exploration toward promising solution regions, faster nearest neighbor pruning based on adaptive radius to reduce redundant rewires, and an efficient iterative path shortcutting for improved path quality and smoothness. Early termination on solution stagnation balances runtime and exploration thoroughness.",
          "planning_mechanism": "The planner grows two trees alternately from start and goal by steering toward sampled points, choosing parents among neighbors within an adaptive radius to minimize cost efficiently, rewiring to improve connectivity with pruning via adaptive radius neighbors, attempts to connect the two trees incrementally, uses hybrid sampling that switches to an ellipsoidal informed distribution after finding a solution, and finally applies iterative shortcut smoothing for path refinement. Early stopping on no improvement enhances computational efficiency.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=3500, step_size=4.0, radius_max=18.0, radius_min=5.0,\n                 no_improve_limit=50, shortcut_iter=120):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.radius_max = radius_max\n        self.radius_min = radius_min\n        self.no_improve_limit = no_improve_limit\n        self.shortcut_iter = shortcut_iter\n\n    def plan(self, map):\n        import math\n        import time\n        import random\n\n        start = tuple(map.start)\n        goal = tuple(map.goal)\n        bounds = tuple(map.size)\n        obstacles = map.obstacles\n        dim = len(bounds)\n\n        def in_bounds(p):\n            return all(0.0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def in_obstacle(p):\n            px, py, pz = (p + (0, 0, 0))[:3]\n            for obs in obstacles:\n                if dim == 3:\n                    ox, oy, oz, ow, oh, od = obs\n                    if ox <= px <= ox + ow and oy <= py <= oy + oh and oz <= pz <= oz + od:\n                        return True\n                else:\n                    ox, oy, ow, oh = obs\n                    if ox <= px <= ox + ow and oy <= py <= oy + oh:\n                        return True\n            return False\n\n        def edge_in_obstacle(a, b, resolution=1.0):\n            dist_ab = math.dist(a, b)\n            if dist_ab < 1e-12:\n                return False\n            steps = max(2, int(dist_ab / resolution))\n            for i in range(steps + 1):\n                pt = tuple(a[d] + (b[d] - a[d]) * i / steps for d in range(dim))\n                if in_obstacle(pt):\n                    return True\n            return False\n\n        def steer(frm, to):\n            dist_ = math.dist(frm, to)\n            if dist_ <= self.step_size:\n                return to\n            ratio = self.step_size / dist_\n            return tuple(frm[i] + (to[i] - frm[i]) * ratio for i in range(dim))\n\n        def adaptive_radius(n_nodes, iter_i):\n            if n_nodes < 2:\n                return self.radius_max\n            r = self.radius_max * ((math.log(n_nodes) / n_nodes) ** (1 / dim))\n            decay = max(self.radius_min / self.radius_max, 1.0 - 0.85 * (iter_i / self.max_iter))\n            return max(self.radius_min, min(r * decay, self.radius_max))\n\n        def neighbors(tree, point, radius):\n            r_sq = radius * radius\n            nbrs = []\n            for node in tree:\n                d_sq = 0.0\n                for i in range(dim):\n                    diff = node.position[i] - point[i]\n                    d_sq += diff * diff\n                    if d_sq > r_sq:\n                        break\n                else:\n                    nbrs.append(node)\n            return nbrs\n\n        def choose_parent(tree, new_pos, iter_i):\n            n_nodes = len(tree)\n            radius = adaptive_radius(n_nodes, iter_i)\n            nbrs = neighbors(tree, new_pos, radius)\n            valid_parents = [n for n in nbrs if not edge_in_obstacle(n.position, new_pos)]\n            if not valid_parents:\n                # fallback to nearest with edge check\n                nearest = None\n                nearest_dist = float('inf')\n                for n in tree:\n                    d = math.dist(n.position, new_pos)\n                    if d < nearest_dist and not edge_in_obstacle(n.position, new_pos):\n                        nearest = n\n                        nearest_dist = d\n                if nearest is None:\n                    return None, []\n                cost = nearest.cost + nearest_dist\n                new_node = Node(new_pos, parent=nearest, cost=cost)\n                nearest.add_child(new_node)\n                tree.append(new_node)\n                return new_node, []\n            best_parent = min(valid_parents, key=lambda p: p.cost + math.dist(p.position, new_pos))\n            min_cost = best_parent.cost + math.dist(best_parent.position, new_pos)\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree.append(new_node)\n            return new_node, valid_parents\n\n        def rewire(pivot, nbrs):\n            for nb in nbrs:\n                if nb is pivot.parent:\n                    continue\n                dist_p_nb = math.dist(pivot.position, nb.position)\n                new_cost = pivot.cost + dist_p_nb\n                if new_cost + 1e-12 < nb.cost and not edge_in_obstacle(pivot.position, nb.position):\n                    if nb.parent:\n                        nb.parent.remove_child(nb)\n                    pivot.add_child(nb)\n                    nb.cost = new_cost\n\n        def attempt_connect(tree, target_node):\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda n: math.dist(n.position, target_node.position))\n            dist_ = math.dist(nearest.position, target_node.position)\n            if dist_ <= self.step_size:\n                if edge_in_obstacle(nearest.position, target_node.position) or in_obstacle(target_node.position):\n                    return None\n                new_node = Node(target_node.position, parent=nearest, cost=nearest.cost + dist_)\n                nearest.add_child(new_node)\n                tree.append(new_node)\n                return new_node\n            current = nearest\n            steps = int(math.ceil(dist_ / self.step_size))\n            for _ in range(steps):\n                new_pos = steer(current.position, target_node.position)\n                if (not in_bounds(new_pos)) or in_obstacle(new_pos) or edge_in_obstacle(current.position, new_pos):\n                    return None\n                new_node = Node(new_pos, parent=current, cost=current.cost + math.dist(current.position, new_pos))\n                current.add_child(new_node)\n                tree.append(new_node)\n                current = new_node\n                if math.dist(current.position, target_node.position) <= self.step_size:\n                    if edge_in_obstacle(current.position, target_node.position) or in_obstacle(target_node.position):\n                        return None\n                    final_node = Node(target_node.position, parent=current, cost=current.cost + math.dist(current.position, target_node.position))\n                    current.add_child(final_node)\n                    tree.append(final_node)\n                    return final_node\n            return None\n\n        def sample_uniform():\n            return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        def ellipsoid_sample(c_best, c_min):\n            if c_best == float('inf') or c_min < 1e-12:\n                return sample_uniform()\n            center = tuple((start[d] + goal[d]) / 2 for d in range(dim))\n            a1 = [goal[d] - start[d] for d in range(dim)]\n            norm_a1 = math.sqrt(sum(x * x for x in a1))\n            if norm_a1 < 1e-15:\n                return sample_uniform()\n            unit_a1 = [x / norm_a1 for x in a1]\n            # construct orthonormal basis via Gram-Schmidt\n            basis = [unit_a1]\n            for idx in range(dim - 1):\n                base = [0.0] * dim\n                base[(idx + 1) % dim] = 1.0\n                for b in basis:\n                    proj = sum(base[j] * b[j] for j in range(dim))\n                    base = [base[j] - proj * b[j] for j in range(dim)]\n                norm_base = math.sqrt(sum(x * x for x in base))\n                if norm_base > 1e-15:\n                    base = [x / norm_base for x in base]\n                else:\n                    base = [0.0] * dim\n                basis.append(base)\n            r1 = c_best * 0.5\n            val = c_best * c_best - c_min * c_min\n            r_orth = math.sqrt(val) * 0.5 if val > 0 else 0.0\n            radii = [r1] + [r_orth] * (dim - 1)\n            for _ in range(30):\n                # sample unit ball\n                x_ball = [random.gauss(0., 1.) for _ in range(dim)]\n                norm_ball = math.sqrt(sum(x * x for x in x_ball))\n                if norm_ball < 1e-15:\n                    continue\n                unit_ball = [xx / norm_ball for xx in x_ball]\n                u = random.random() ** (1.0 / dim)\n                point_ball = [coord * u for coord in unit_ball]\n                # scale and rotate\n                sample_point = [0.0] * dim\n                for i_ in range(dim):\n                    for j_ in range(dim):\n                        sample_point[j_] += point_ball[i_] * radii[i_] * basis[i_][j_]\n                sample = tuple(max(0.0, min(center[i] + sample_point[i], bounds[i])) for i in range(dim))\n                if not in_obstacle(sample):\n                    return sample\n            return sample_uniform()\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return list(path)\n            path = list(path)\n            for _ in range(self.shortcut_iter):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if not edge_in_obstacle(path[i], path[j]):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        start_node = Node(start, cost=0.0)\n        goal_node = Node(goal, cost=0.0)\n        start_tree = [start_node]\n        goal_tree = [goal_node]\n        nodes = [start_node, goal_node]\n        edges = []\n\n        best_path = []\n        best_cost = float('inf')\n        c_min = math.dist(start, goal)\n        found_solution = False\n        no_improve_count = 0\n\n        start_time = time.time()\n\n        for iter_i in range(self.max_iter):\n            if found_solution:\n                sample = ellipsoid_sample(best_cost, c_min)\n                if random.random() < 0.2:\n                    sample = sample_uniform()\n            else:\n                sample = sample_uniform()\n\n            if not in_bounds(sample) or in_obstacle(sample):\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.no_improve_limit:\n                        break\n                continue\n\n            tree_a, tree_b = (start_tree, goal_tree) if iter_i % 2 == 0 else (goal_tree, start_tree)\n\n            nearest_node = min(tree_a, key=lambda n: math.dist(n.position, sample))\n            new_pos = steer(nearest_node.position, sample)\n            if not in_bounds(new_pos) or in_obstacle(new_pos) or edge_in_obstacle(nearest_node.position, new_pos):\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.no_improve_limit:\n                        break\n                continue\n\n            new_node, nbrs = choose_parent(tree_a, new_pos, iter_i)\n            if not new_node:\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.no_improve_limit:\n                        break\n                continue\n\n            rewire(new_node, nbrs)\n            nodes.append(new_node)\n            if new_node.parent:\n                edges.append((new_node.parent, new_node))\n\n            connect_node = attempt_connect(tree_b, new_node)\n            if connect_node:\n                if iter_i % 2 == 0:\n                    path_a = new_node.path_from_root()\n                    path_b = connect_node.path_from_root()\n                else:\n                    path_a = connect_node.path_from_root()\n                    path_b = new_node.path_from_root()\n\n                if path_a and path_b and path_a[-1] == path_b[-1]:\n                    candidate_path = path_a + path_b[-2::-1]\n                else:\n                    candidate_path = path_a + path_b[::-1]\n\n                total_cost = 0.0\n                for i in range(len(candidate_path) - 1):\n                    total_cost += math.dist(candidate_path[i], candidate_path[i + 1])\n\n                if total_cost + 1e-9 < best_cost:\n                    best_cost = total_cost\n                    best_path = candidate_path\n                    found_solution = True\n                    no_improve_count = 0\n                else:\n                    no_improve_count += 1\n                    if no_improve_count >= self.no_improve_limit:\n                        break\n            else:\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.no_improve_limit:\n                        break\n\n        if found_solution and len(best_path) >= 3:\n            best_path = shortcut_path(best_path)\n\n        return PlannerResult(success=found_solution, path=best_path, nodes=nodes, edges=edges)",
          "objective": -35.35386,
          "time_improvement": 56.0,
          "length_improvement": 17.0,
          "smoothness_improvement": 1654.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.015592575073242188,
                    "num_nodes_avg": 99.9,
                    "path_length_avg": 159.4495060769605,
                    "smoothness_avg": 0.03886240016513557,
                    "success_improvement": 0.0,
                    "time_improvement": 35.79454253611557,
                    "length_improvement": 12.603199080107105,
                    "smoothness_improvement": 508.28095363705586,
                    "objective_score": 20.841686977084215
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.033257794380187986,
                    "num_nodes_avg": 302.3,
                    "path_length_avg": 238.8612478430386,
                    "smoothness_avg": 0.11894377823211089,
                    "success_improvement": 0.0,
                    "time_improvement": 79.40250820100103,
                    "length_improvement": 20.261240230182576,
                    "smoothness_improvement": 2960.509085652796,
                    "objective_score": 50.78004202667384
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.02319345474243164,
                    "num_nodes_avg": 256.8,
                    "path_length_avg": 122.89703464593951,
                    "smoothness_avg": 0.1252212284453279,
                    "success_improvement": 0.0,
                    "time_improvement": 53.16415107965624,
                    "length_improvement": 18.377641316081167,
                    "smoothness_improvement": 1492.804782954941,
                    "objective_score": 34.439854028320276
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m2",
          "algorithm_description": "An advanced bidirectional informed RRT* planner with integrated incremental path curvature smoothing during rewiring, utilizing spatial hashing for efficient neighbor search. The planner adaptively adjusts the neighborhood radius based on node density and iteration progress to balance exploration and refinement. Instead of relying solely on stochastic shortcutting, it performs deterministic curvature optimization incrementally during rewiring to produce smoother paths progressively. Combined adaptive informed sampling, early stopping on stagnation, and a final optimized shortcut phase yield efficient planning with reduced search time, shorter path length, and significantly improved path smoothness and robustness.",
          "planning_mechanism": "The algorithm grows two trees alternately from start and goal locations, sampling points uniformly or inside an informed ellipsoid after the first solution. Each new node selects an optimal parent from spatial-hashed neighbors with collision-free edges and rewires neighbors to improve overall cost and smoothness. During rewiring, it applies curvature-based local smoothing that adjusts node positions to minimize sharp angles while respecting collision constraints. The trees attempt connection after each addition to yield updated best paths. Planning terminates upon max iterations or stagnation. A final path shortcutting further refines the path.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self,\n                 max_iter=3500,\n                 step_size=5.0,\n                 max_radius=30.0,\n                 min_radius=7.0,\n                 max_no_improve=50,\n                 shortcut_iter=180,\n                 cell_size=15.0,\n                 curv_smooth_alpha=0.3,   # blending factor for curvature smoothing, lower is gentler moves\n                 curv_smooth_iters=3):    # iterations of curvature smoothing during rewire\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.max_radius = max_radius\n        self.min_radius = min_radius\n        self.max_no_improve = max_no_improve\n        self.shortcut_iter = shortcut_iter\n        self.cell_size = cell_size\n        self.curv_smooth_alpha = curv_smooth_alpha\n        self.curv_smooth_iters = curv_smooth_iters\n\n    def plan(self, map):\n        import math\n        import random\n\n        bounds = map.size\n        dim = len(bounds)\n        start_pos = tuple(map.start)\n        goal_pos = tuple(map.goal)\n        obstacles = map.obstacles\n        is_3d = (dim == 3)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def in_obstacle(p):\n            px, py, pz = (p + (0, 0, 0))[:3]\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def edge_in_obstacle(a, b, resolution=1.0):\n            dist_ab = math.dist(a, b)\n            if dist_ab < 1e-12:\n                return False\n            steps = max(2, int(dist_ab / resolution))\n            for i in range(steps + 1):\n                interp = tuple(a[d] + (b[d] - a[d]) * i / steps for d in range(dim))\n                if in_obstacle(interp):\n                    return True\n            return False\n\n        def steer(frm, to):\n            dist = math.dist(frm, to)\n            if dist <= self.step_size:\n                return to\n            ratio = self.step_size / dist\n            return tuple(frm[d] + (to[d] - frm[d]) * ratio for d in range(dim))\n\n        class SpatialHash:\n            def __init__(self, bounds, cell_size):\n                self.cell_size = cell_size\n                self.inv_cell = 1.0 / cell_size\n                self.grid = {}\n                self.bounds = bounds\n                self.dim = len(bounds)\n\n            def _hash_coords(self, p):\n                return tuple(int(p[d] * self.inv_cell) for d in range(self.dim))\n\n            def insert(self, node):\n                hc = self._hash_coords(node.position)\n                self.grid.setdefault(hc, []).append(node)\n\n            def remove(self, node):\n                hc = self._hash_coords(node.position)\n                cell = self.grid.get(hc, [])\n                if node in cell:\n                    cell.remove(node)\n                    if not cell:\n                        del self.grid[hc]\n\n            def neighbors(self, p, radius):\n                r_cells = int(math.ceil(radius * self.inv_cell))\n                hc = self._hash_coords(p)\n                candidates = []\n                rng = range(-r_cells, r_cells + 1)\n                for dx in rng:\n                    for dy in rng:\n                        if self.dim == 2:\n                            cell_key = (hc[0] + dx, hc[1] + dy)\n                            cell_nodes = self.grid.get(cell_key)\n                            if cell_nodes:\n                                candidates.extend(cell_nodes)\n                        else:\n                            for dz in rng:\n                                cell_key = (hc[0] + dx, hc[1] + dy, hc[2] + dz)\n                                cell_nodes = self.grid.get(cell_key)\n                                if cell_nodes:\n                                    candidates.extend(cell_nodes)\n                r_sq = radius * radius\n                result = []\n                for node in candidates:\n                    dsq = 0.0\n                    for d in range(self.dim):\n                        diff = node.position[d] - p[d]\n                        dsq += diff * diff\n                        if dsq > r_sq:\n                            break\n                    else:\n                        result.append(node)\n                return result\n\n        def sample_uniform():\n            return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        def sample_informed(c_best, c_min):\n            if c_best == float('inf') or c_min < 1e-12:\n                return sample_uniform()\n            center = tuple((start_pos[d] + goal_pos[d]) * 0.5 for d in range(dim))\n            unit_dir = [(goal_pos[d] - start_pos[d]) / c_min for d in range(dim)]\n            r1 = c_best * 0.5\n            diff_sq = max(c_best * c_best - c_min * c_min, 0.0)\n            r_other = math.sqrt(diff_sq) * 0.5\n\n            if dim == 2:\n                a1 = unit_dir\n                a2 = (-a1[1], a1[0])\n                basis = (a1, a2)\n                radii = (r1, r_other)\n            else:\n                def cross(u, v):\n                    return (u[1] * v[2] - u[2] * v[1],\n                            u[2] * v[0] - u[0] * v[2],\n                            u[0] * v[1] - u[1] * v[0])\n\n                def norm(v):\n                    return math.sqrt(sum(x * x for x in v))\n\n                a1 = unit_dir\n                ref = (1, 0, 0) if abs(a1[0]) < 0.9 else (0, 1, 0)\n                b2 = cross(a1, ref)\n                n_b2 = norm(b2)\n                if n_b2 < 1e-12:\n                    ref = (0, 0, 1)\n                    b2 = cross(a1, ref)\n                    n_b2 = norm(b2)\n                b2 = tuple(x / n_b2 for x in b2)\n                b3 = cross(a1, b2)\n                basis = (a1, b2, b3)\n                radii = (r1, r_other, r_other)\n\n            def sample_unit_ball(dim):\n                while True:\n                    vec = [random.gauss(0, 1) for _ in range(dim)]\n                    nrm = math.sqrt(sum(v * v for v in vec))\n                    if nrm < 1e-12:\n                        continue\n                    vec = [v / nrm for v in vec]\n                    r = random.random() ** (1 / dim)\n                    return [v * r for v in vec]\n\n            u = sample_unit_ball(dim)\n            mapped = []\n            for d in range(dim):\n                val = center[d]\n                for i in range(dim):\n                    val += basis[i][d] * radii[i] * u[i]\n                val = max(0.0, min(val, bounds[d]))\n                mapped.append(val)\n            return tuple(mapped)\n\n        def adaptive_radius(num_nodes, best_cost, iteration):\n            import math\n            if num_nodes <= 1:\n                return self.max_radius\n            base = self.max_radius * (math.log(num_nodes) / num_nodes) ** (1 / dim)\n            radius = max(self.min_radius, min(base, self.max_radius))\n            # add decay with iteration for refinement towards end of search\n            decay = max(self.min_radius / self.max_radius, 1.0 - 0.9 * iteration / self.max_iter)\n            radius = radius * decay\n            if best_cost != float('inf'):\n                radius = max(self.min_radius, min(radius, best_cost * 0.5))\n            return radius\n\n        def choose_parent(tree_hash, tree_nodes, new_pos, radius, iteration, best_cost):\n            nbrs = tree_hash.neighbors(new_pos, radius)\n            valid_parents = []\n            for n in nbrs:\n                if not edge_in_obstacle(n.position, new_pos):\n                    valid_parents.append(n)\n            if not valid_parents:\n                # fallback nearest node globally with collision-free edge\n                nearest = None\n                nearest_dist = float('inf')\n                for n in tree_nodes:\n                    d = math.dist(n.position, new_pos)\n                    if d < nearest_dist and not edge_in_obstacle(n.position, new_pos):\n                        nearest = n\n                        nearest_dist = d\n                if nearest is None:\n                    return None, []\n                cost = nearest.cost + nearest_dist\n                new_node = Node(new_pos, parent=nearest, cost=cost)\n                nearest.add_child(new_node)\n                tree_nodes.append(new_node)\n                tree_hash.insert(new_node)\n                return new_node, []\n            best_parent = min(valid_parents, key=lambda p: p.cost + math.dist(p.position, new_pos))\n            cost_min = best_parent.cost + math.dist(best_parent.position, new_pos)\n            new_node = Node(new_pos, parent=best_parent, cost=cost_min)\n            best_parent.add_child(new_node)\n            tree_nodes.append(new_node)\n            tree_hash.insert(new_node)\n            return new_node, valid_parents\n\n        def curvature(points):\n            # Returns curvature estimate at center point of three points in dim\n            import math\n            if len(points) != 3:\n                return 0.0\n            p0, p1, p2 = points\n            def dist(a,b):\n                return math.dist(a,b)\n            a = dist(p0, p1)\n            b = dist(p1, p2)\n            c = dist(p0, p2)\n            denom = 2 * a * b * c\n            if denom < 1e-12:\n                return 0.0\n            # Using the formula for circumradius R of triangle and curvature = 1/R\n            s = (a+b+c)/2\n            area = max(s*(s-a)*(s-b)*(s-c), 0.0) ** 0.5\n            if area < 1e-12:\n                return 0.0\n            curvature = 4*area / denom\n            return curvature\n\n        def smooth_local_path(node, tree_hash):\n            # Attempt local curvature smoothing by moving node position slightly along median of neighbors\n            if node.parent is None or not node.children:\n                return  # can't smooth root or leafless nodes well\n            for _ in range(self.curv_smooth_iters):\n                ppos = node.parent.position\n                cpos = node.position\n                # Average child position - here we pick median child to avoid spread\n                cchildren = node.children\n                # Compute average child position\n                if not cchildren:\n                    break\n                avg_cpos = [0.0]*dim\n                for cnode in cchildren:\n                    for d in range(dim):\n                        avg_cpos[d] += cnode.position[d]\n                n_c = len(cchildren)\n                avg_cpos = [x/n_c for x in avg_cpos]\n\n                # Compute median point between parent and avg child pos\n                med = tuple((ppos[d] + avg_cpos[d]) * 0.5 for d in range(dim))\n\n                # Proposed new position interpolated between current and median (curv_smooth_alpha blending)\n                new_pos = tuple(cpos[d] + self.curv_smooth_alpha * (med[d] - cpos[d]) for d in range(dim))\n\n                # Validate new pos: in bounds and free of collision and edges from parent and to children free\n                if not in_bounds(new_pos) or in_obstacle(new_pos):\n                    break\n                if edge_in_obstacle(ppos, new_pos):\n                    break\n                collision_children = False\n                for cnode in cchildren:\n                    if edge_in_obstacle(new_pos, cnode.position):\n                        collision_children = True\n                        break\n                if collision_children:\n                    break\n\n                # Commit position update\n                node.position = new_pos\n                # Update cost: cost from parent to node plus node to children costs\n                dist_parent = math.dist(node.position, ppos)\n                if node.cost is not None:\n                    cost_diff = dist_parent + sum(math.dist(node.position, c.position) for c in cchildren)\n                    # Recalculate cost for node as parent's cost plus dist to parent\n                    node.cost = node.parent.cost + dist_parent\n                    # Update children's costs recursively to keep consistency\n                    def update_descendant_costs(n):\n                        for ch in n.children:\n                            ch.cost = n.cost + math.dist(n.position, ch.position)\n                            update_descendant_costs(ch)\n                    update_descendant_costs(node)\n                # Update spatial hash: remove and reinsert node position\n                tree_hash.remove(node)\n                tree_hash.insert(node)\n\n        def rewire(pivot, neighbors_, tree_hash):\n            import math\n            for nb in neighbors_:\n                if nb == pivot.parent:\n                    continue\n                dist_pivot_nb = math.dist(pivot.position, nb.position)\n                new_cost = pivot.cost + dist_pivot_nb\n                if new_cost + 1e-12 < nb.cost:\n                    if edge_in_obstacle(pivot.position, nb.position):\n                        continue\n                    if nb.parent:\n                        nb.parent.remove_child(nb)\n                    pivot.add_child(nb)\n                    nb.cost = new_cost\n                    # Incremental curvature smoothing after rewire improves path smoothness\n                    smooth_local_path(nb, tree_hash)\n\n        def attempt_connect(tree_hash, tree_nodes, node_to_connect):\n            if not tree_nodes:\n                return None\n            nearest = min(tree_nodes, key=lambda n: math.dist(n.position, node_to_connect.position))\n            dist_near = math.dist(nearest.position, node_to_connect.position)\n            if dist_near <= self.step_size:\n                if edge_in_obstacle(nearest.position, node_to_connect.position) or in_obstacle(node_to_connect.position):\n                    return None\n                new_node = Node(node_to_connect.position, parent=nearest, cost=nearest.cost + dist_near)\n                nearest.add_child(new_node)\n                tree_nodes.append(new_node)\n                tree_hash.insert(new_node)\n                return new_node\n            current = nearest\n            steps = int(math.ceil(dist_near / self.step_size))\n            for _ in range(steps):\n                new_pos = steer(current.position, node_to_connect.position)\n                if not in_bounds(new_pos) or in_obstacle(new_pos) or edge_in_obstacle(current.position, new_pos):\n                    return None\n                new_node = Node(new_pos, parent=current, cost=current.cost + math.dist(current.position, new_pos))\n                current.add_child(new_node)\n                tree_nodes.append(new_node)\n                tree_hash.insert(new_node)\n                current = new_node\n                if math.dist(current.position, node_to_connect.position) <= self.step_size:\n                    if edge_in_obstacle(current.position, node_to_connect.position) or in_obstacle(node_to_connect.position):\n                        return None\n                    final_node = Node(node_to_connect.position, parent=current,\n                                      cost=current.cost + math.dist(current.position, node_to_connect.position))\n                    current.add_child(final_node)\n                    tree_nodes.append(final_node)\n                    tree_hash.insert(final_node)\n                    return final_node\n            return None\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path[:]\n\n            path = list(path)\n            for _ in range(self.shortcut_iter):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if not edge_in_obstacle(path[i], path[j]):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        # Initialize trees, spatial hashes, and structures\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n        start_hash = SpatialHash(bounds, self.cell_size)\n        goal_hash = SpatialHash(bounds, self.cell_size)\n        start_hash.insert(start_root)\n        goal_hash.insert(goal_root)\n        nodes = [start_root, goal_root]\n        edges = []\n\n        best_path = []\n        best_cost = float('inf')\n        c_min = math.dist(start_pos, goal_pos)\n        found_solution = False\n        no_improve_count = 0\n\n        for iter_i in range(self.max_iter):\n            if found_solution:\n                sample = sample_informed(best_cost, c_min)\n                if random.random() < 0.12:\n                    sample = sample_uniform()\n            else:\n                sample = sample_uniform()\n\n            if not in_bounds(sample) or in_obstacle(sample):\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n                continue\n\n            if iter_i % 2 == 0:\n                tree_nodes, tree_hash = start_tree, start_hash\n                other_nodes, other_hash = goal_tree, goal_hash\n            else:\n                tree_nodes, tree_hash = goal_tree, goal_hash\n                other_nodes, other_hash = start_tree, start_hash\n\n            nearest = min(tree_nodes, key=lambda n: math.dist(n.position, sample))\n            new_pos = steer(nearest.position, sample)\n            if (not in_bounds(new_pos) or in_obstacle(new_pos) or\n                    edge_in_obstacle(nearest.position, new_pos)):\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n                continue\n\n            radius = adaptive_radius(len(nodes), best_cost, iter_i)\n            new_node, neighbors_ = choose_parent(tree_hash, tree_nodes, new_pos, radius, iter_i, best_cost)\n            if new_node is None:\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n                continue\n\n            rewire(new_node, neighbors_, tree_hash)\n            nodes.append(new_node)\n            if new_node.parent:\n                edges.append((new_node.parent, new_node))\n\n            connect_node = attempt_connect(other_hash, other_nodes, new_node)\n            if connect_node is not None:\n                if iter_i % 2 == 0:\n                    path_from = new_node.path_from_root()\n                    path_to = connect_node.path_from_root()\n                else:\n                    path_from = connect_node.path_from_root()\n                    path_to = new_node.path_from_root()\n\n                if path_from and path_to and path_from[-1] == path_to[-1]:\n                    candidate_path = path_from + path_to[-2::-1]\n                else:\n                    candidate_path = path_from + path_to[::-1]\n\n                total_cost = 0.0\n                for i in range(len(candidate_path) - 1):\n                    total_cost += math.dist(candidate_path[i], candidate_path[i + 1])\n\n                if total_cost + 1e-9 < best_cost:\n                    best_cost = total_cost\n                    best_path = candidate_path\n                    found_solution = True\n                    no_improve_count = 0\n                else:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n            else:\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n\n        if found_solution and len(best_path) >= 3:\n            best_path = shortcut_path(best_path)\n\n        return PlannerResult(success=found_solution, path=best_path, nodes=nodes, edges=edges)",
          "objective": -34.77469,
          "time_improvement": 54.0,
          "length_improvement": 18.0,
          "smoothness_improvement": 1582.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.01753549575805664,
                    "num_nodes_avg": 83.8,
                    "path_length_avg": 156.5959158641199,
                    "smoothness_avg": 0.040558544041310964,
                    "success_improvement": 0.0,
                    "time_improvement": 27.794189111579076,
                    "length_improvement": 14.167297093795597,
                    "smoothness_improvement": 534.8292885345801,
                    "objective_score": 19.512781432423978
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.028028345108032225,
                    "num_nodes_avg": 244.9,
                    "path_length_avg": 238.44272786041475,
                    "smoothness_avg": 0.11414201364342831,
                    "success_improvement": 0.0,
                    "time_improvement": 82.64125389968378,
                    "length_improvement": 20.400954246812184,
                    "smoothness_improvement": 2836.9562242147567,
                    "objective_score": 51.21772983906622
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.024633383750915526,
                    "num_nodes_avg": 256.5,
                    "path_length_avg": 121.32891893190724,
                    "smoothness_avg": 0.11580524742212554,
                    "success_improvement": 0.0,
                    "time_improvement": 50.256421366842396,
                    "length_improvement": 19.419109107695295,
                    "smoothness_improvement": 1373.0341993552297,
                    "objective_score": 33.593562871446046
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m2",
          "algorithm_description": "A bidirectional RRT* planner with adaptive logarithmic neighbor radius shrinking, heuristic-informed ellipsoidal sampling, and iteratively improved path smoothing that includes adaptive angle-based pruning and curvature-aware shortcutting. This planner dynamically balances exploration and exploitation, uses spatial hashing for efficient neighbor queries, and applies a systematic post-processing smoothing phase that progressively removes sharp turns and shortens path length, thereby improving efficiency, robustness, path quality, and smoothness while reducing overall planning time.",
          "planning_mechanism": "The planner alternately grows two trees from start and goal positions using a step-limited extend function, sampling points with uniform distribution initially and switching to an ellipsoidal informed subset after finding a first feasible path. It employs spatial hashing to efficiently retrieve neighbors within an adaptively shrinking radius tied logarithmically to the number of nodes and the current best path cost. Parent selection and rewiring prioritize improving path cost while verifying collision-free connections. Each iteration attempts to connect the two trees to form a complete path, updating the best solution found. Planning terminates early when improvements stagnate. Finally, a robust smoothing phase applies multiple shortcut attempts interleaved with adaptive angular pruning of sharp turns based on curvature thresholds, producing a smoother and shorter feasible path.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self,\n                 max_iter=3000,\n                 step_size=6.0,\n                 max_radius=28.0,\n                 min_radius=6.5,\n                 max_no_improve=40,\n                 shortcut_iter=180,\n                 cell_size=16.0,\n                 curvature_threshold=0.75  # cosine threshold close to 1 for mild pruning\n                 ):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.max_radius = max_radius\n        self.min_radius = min_radius\n        self.max_no_improve = max_no_improve\n        self.shortcut_iter = shortcut_iter\n        self.cell_size = cell_size\n        self.curvature_threshold = curvature_threshold\n\n    def plan(self, map):\n        import math\n        import random\n\n        bounds = map.size\n        dim = len(bounds)\n        start_pos = tuple(map.start)\n        goal_pos = tuple(map.goal)\n        obstacles = map.obstacles\n        is_3d = (dim == 3)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def in_obstacle(p):\n            px, py, pz = (p + (0, 0, 0))[:3]\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def edge_in_obstacle(a, b, resolution=1.0):\n            dist_ab = math.dist(a, b)\n            if dist_ab < 1e-12:\n                return False\n            steps = max(3, int(dist_ab / resolution))\n            for i in range(steps + 1):\n                interp = tuple(a[d] + (b[d] - a[d]) * i / steps for d in range(dim))\n                if in_obstacle(interp):\n                    return True\n            return False\n\n        def steer(frm, to):\n            dist = math.dist(frm, to)\n            if dist <= self.step_size:\n                return to\n            ratio = self.step_size / dist\n            return tuple(frm[d] + (to[d] - frm[d]) * ratio for d in range(dim))\n\n        class SpatialHash:\n            def __init__(self, bounds, cell_size):\n                self.cell_size = cell_size\n                self.inv_cell = 1.0 / cell_size\n                self.grid = {}\n                self.bounds = bounds\n                self.dim = len(bounds)\n\n            def _hash_coords(self, p):\n                return tuple(int(p[d] * self.inv_cell) for d in range(self.dim))\n\n            def insert(self, node):\n                hc = self._hash_coords(node.position)\n                self.grid.setdefault(hc, []).append(node)\n\n            def remove(self, node):\n                hc = self._hash_coords(node.position)\n                cell = self.grid.get(hc, [])\n                if node in cell:\n                    cell.remove(node)\n                    if not cell:\n                        del self.grid[hc]\n\n            def neighbors(self, p, radius):\n                r_cells = int(math.ceil(radius * self.inv_cell))\n                hc = self._hash_coords(p)\n                candidates = []\n                for dx in range(-r_cells, r_cells + 1):\n                    for dy in range(-r_cells, r_cells + 1):\n                        if self.dim == 2:\n                            cell_key = (hc[0] + dx, hc[1] + dy)\n                            cell_nodes = self.grid.get(cell_key)\n                            if cell_nodes:\n                                candidates.extend(cell_nodes)\n                        else:\n                            for dz in range(-r_cells, r_cells + 1):\n                                cell_key = (hc[0] + dx, hc[1] + dy, hc[2] + dz)\n                                cell_nodes = self.grid.get(cell_key)\n                                if cell_nodes:\n                                    candidates.extend(cell_nodes)\n                r_sq = radius * radius\n                result = []\n                for node in candidates:\n                    dsq = 0.0\n                    for d in range(self.dim):\n                        diff = node.position[d] - p[d]\n                        dsq += diff * diff\n                        if dsq > r_sq:\n                            break\n                    else:\n                        result.append(node)\n                return result\n\n        def sample_uniform():\n            return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        def sample_informed(c_best, c_min):\n            if c_best == float('inf') or c_min < 1e-12:\n                return sample_uniform()\n            center = tuple((start_pos[d] + goal_pos[d]) * 0.5 for d in range(dim))\n            unit_dir = [(goal_pos[d] - start_pos[d]) / c_min for d in range(dim)]\n            r1 = c_best * 0.5\n            diff_sq = max(c_best * c_best - c_min * c_min, 0.0)\n            r_other = math.sqrt(diff_sq) * 0.5\n            if dim == 2:\n                a1 = unit_dir\n                a2 = (-a1[1], a1[0])\n                basis = (a1, a2)\n                radii = (r1, r_other)\n            else:\n                def cross(u, v):\n                    return (\n                        u[1] * v[2] - u[2] * v[1],\n                        u[2] * v[0] - u[0] * v[2],\n                        u[0] * v[1] - u[1] * v[0],\n                    )\n\n                def norm(v):\n                    return math.sqrt(sum(x * x for x in v))\n\n                a1 = unit_dir\n                ref = (1, 0, 0) if abs(a1[0]) < 0.9 else (0, 1, 0)\n                b2 = cross(a1, ref)\n                n_b2 = norm(b2)\n                if n_b2 < 1e-14:\n                    ref = (0, 0, 1)\n                    b2 = cross(a1, ref)\n                    n_b2 = norm(b2)\n                b2 = tuple(x / n_b2 for x in b2)\n                b3 = cross(a1, b2)\n                basis = (a1, b2, b3)\n                radii = (r1, r_other, r_other)\n\n            def sample_unit_ball(dim):\n                while True:\n                    vec = [random.gauss(0, 1) for _ in range(dim)]\n                    nrm = math.sqrt(sum(v * v for v in vec))\n                    if nrm < 1e-14:\n                        continue\n                    vec = [v / nrm for v in vec]\n                    r = random.random() ** (1 / dim)\n                    return [v * r for v in vec]\n\n            u = sample_unit_ball(dim)\n            mapped = []\n            for d in range(dim):\n                val = center[d]\n                for i in range(dim):\n                    val += basis[i][d] * radii[i] * u[i]\n                # Clamp\n                val = max(0.0, min(val, bounds[d]))\n                mapped.append(val)\n            if in_obstacle(tuple(mapped)):\n                return sample_uniform()\n            return tuple(mapped)\n\n        def adaptive_radius(num_nodes, best_cost):\n            if num_nodes <= 1:\n                return self.max_radius\n            base = self.max_radius * (math.log(num_nodes) / num_nodes) ** (1 / dim)\n            radius = max(self.min_radius, min(base, self.max_radius))\n            if best_cost != float('inf'):\n                radius = max(self.min_radius, min(radius, best_cost * 0.55))\n            return radius\n\n        def choose_parent(tree_hash, tree_nodes, new_pos, radius):\n            nbrs = tree_hash.neighbors(new_pos, radius)\n            valid_parents = []\n            for n in nbrs:\n                if not edge_in_obstacle(n.position, new_pos):\n                    valid_parents.append(n)\n            if not valid_parents:\n                # fallback nearest collision-free parent globally\n                nearest = None\n                nearest_dist = float('inf')\n                for n in tree_nodes:\n                    d = math.dist(n.position, new_pos)\n                    if d < nearest_dist and not edge_in_obstacle(n.position, new_pos) and not in_obstacle(new_pos):\n                        nearest = n\n                        nearest_dist = d\n                if nearest is None:\n                    return None, []\n                cost = nearest.cost + nearest_dist\n                new_node = Node(new_pos, parent=nearest, cost=cost)\n                nearest.add_child(new_node)\n                tree_nodes.append(new_node)\n                tree_hash.insert(new_node)\n                return new_node, []\n            best_parent = min(valid_parents, key=lambda p: p.cost + math.dist(p.position, new_pos))\n            cost_min = best_parent.cost + math.dist(best_parent.position, new_pos)\n            new_node = Node(new_pos, parent=best_parent, cost=cost_min)\n            best_parent.add_child(new_node)\n            tree_nodes.append(new_node)\n            tree_hash.insert(new_node)\n            return new_node, valid_parents\n\n        def rewire(pivot, neighbors_, tree_hash):\n            for nb in neighbors_:\n                if nb == pivot.parent:\n                    continue\n                dist_pivot_nb = math.dist(pivot.position, nb.position)\n                new_cost = pivot.cost + dist_pivot_nb\n                if new_cost + 1e-12 < nb.cost:\n                    if edge_in_obstacle(pivot.position, nb.position):\n                        continue\n                    if nb.parent:\n                        nb.parent.remove_child(nb)\n                    pivot.add_child(nb)\n                    nb.cost = new_cost\n\n        def attempt_connect(tree_hash, tree_nodes, node_to_connect):\n            if not tree_nodes:\n                return None\n            nearest = min(tree_nodes, key=lambda n: math.dist(n.position, node_to_connect.position))\n            dist_near = math.dist(nearest.position, node_to_connect.position)\n            if dist_near <= self.step_size:\n                if edge_in_obstacle(nearest.position, node_to_connect.position) or in_obstacle(node_to_connect.position):\n                    return None\n                new_node = Node(node_to_connect.position, parent=nearest, cost=nearest.cost + dist_near)\n                nearest.add_child(new_node)\n                tree_nodes.append(new_node)\n                tree_hash.insert(new_node)\n                return new_node\n            current = nearest\n            steps = int(math.ceil(dist_near / self.step_size))\n            for _ in range(steps):\n                new_pos = steer(current.position, node_to_connect.position)\n                if not in_bounds(new_pos) or in_obstacle(new_pos) or edge_in_obstacle(current.position, new_pos):\n                    return None\n                new_node = Node(new_pos, parent=current, cost=current.cost + math.dist(current.position, new_pos))\n                current.add_child(new_node)\n                tree_nodes.append(new_node)\n                tree_hash.insert(new_node)\n                current = new_node\n                if math.dist(current.position, node_to_connect.position) <= self.step_size:\n                    if edge_in_obstacle(current.position, node_to_connect.position) or in_obstacle(node_to_connect.position):\n                        return None\n                    final_node = Node(node_to_connect.position, parent=current,\n                                      cost=current.cost + math.dist(current.position, node_to_connect.position))\n                    current.add_child(final_node)\n                    tree_nodes.append(final_node)\n                    tree_hash.insert(final_node)\n                    return final_node\n            return None\n\n        def smooth_path(path):\n            if len(path) < 3:\n                return path[:]\n\n            def angle_cosine(p1, p2, p3):\n                def vec(a, b):\n                    return [b[d] - a[d] for d in range(dim)]\n\n                v1 = vec(p2, p1)\n                v2 = vec(p2, p3)\n                norm1 = math.sqrt(sum(x * x for x in v1))\n                norm2 = math.sqrt(sum(x * x for x in v2))\n                if norm1 < 1e-12 or norm2 < 1e-12:\n                    return 1.0\n                dot = sum(v1[d] * v2[d] for d in range(dim))\n                return dot / (norm1 * norm2)\n\n            path = list(path)\n            # Multiple passes of shortcutting with bias towards larger shortcuts\n            for _ in range(self.shortcut_iter):\n                n = len(path)\n                if n < 3:\n                    break\n                max_dist = max(2, n // 4)\n                i = random.randint(0, n - max_dist - 1)\n                j = random.randint(i + 2, min(i + max_dist, n - 1))\n                if not edge_in_obstacle(path[i], path[j]):\n                    path = path[:i + 1] + path[j:]\n\n            # Adaptive angle-based pruning pass to remove sharp kinks\n            improved = True\n            max_passes = 3\n            pass_count = 0\n            while improved and pass_count < max_passes and len(path) >= 3:\n                improved = False\n                pass_count += 1\n                i = 1\n                while i < len(path) - 1:\n                    cos_phi = angle_cosine(path[i - 1], path[i], path[i + 1])\n                    if cos_phi > self.curvature_threshold:\n                        if not edge_in_obstacle(path[i - 1], path[i + 1]):\n                            path.pop(i)\n                            improved = True\n                            # After popping, i stays the same for next iteration to check new triple\n                            continue\n                    i += 1\n            return path\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n        start_hash = SpatialHash(bounds, self.cell_size)\n        goal_hash = SpatialHash(bounds, self.cell_size)\n        start_hash.insert(start_root)\n        goal_hash.insert(goal_root)\n        nodes = [start_root, goal_root]\n        edges = []\n\n        best_path = []\n        best_cost = float('inf')\n        c_min = math.dist(start_pos, goal_pos)\n        found_solution = False\n        no_improve_count = 0\n\n        for iter_i in range(self.max_iter):\n            if found_solution:\n                sample = sample_informed(best_cost, c_min)\n                if random.random() < 0.15:\n                    sample = sample_uniform()\n            else:\n                sample = sample_uniform()\n\n            if not in_bounds(sample) or in_obstacle(sample):\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n                continue\n\n            if iter_i % 2 == 0:\n                tree_nodes, tree_hash = start_tree, start_hash\n                other_nodes, other_hash = goal_tree, goal_hash\n            else:\n                tree_nodes, tree_hash = goal_tree, goal_hash\n                other_nodes, other_hash = start_tree, start_hash\n\n            nearest = min(tree_nodes, key=lambda n: math.dist(n.position, sample))\n            new_pos = steer(nearest.position, sample)\n            if not in_bounds(new_pos) or in_obstacle(new_pos) or edge_in_obstacle(nearest.position, new_pos):\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n                continue\n\n            radius = adaptive_radius(len(nodes), best_cost)\n            new_node, neighbors_ = choose_parent(tree_hash, tree_nodes, new_pos, radius)\n            if new_node is None:\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n                continue\n\n            rewire(new_node, neighbors_, tree_hash)\n            nodes.append(new_node)\n            if new_node.parent:\n                edges.append((new_node.parent, new_node))\n\n            connect_node = attempt_connect(other_hash, other_nodes, new_node)\n            if connect_node is not None:\n                if iter_i % 2 == 0:\n                    path_from = new_node.path_from_root()\n                    path_to = connect_node.path_from_root()\n                else:\n                    path_from = connect_node.path_from_root()\n                    path_to = new_node.path_from_root()\n\n                if path_from and path_to and path_from[-1] == path_to[-1]:\n                    candidate_path = path_from + path_to[-2::-1]\n                else:\n                    candidate_path = path_from + path_to[::-1]\n\n                total_cost = 0.0\n                for i in range(len(candidate_path) - 1):\n                    total_cost += math.dist(candidate_path[i], candidate_path[i + 1])\n\n                if total_cost + 1e-9 < best_cost:\n                    best_cost = total_cost\n                    best_path = candidate_path\n                    found_solution = True\n                    no_improve_count = 0\n                else:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n            else:\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n\n        if found_solution and len(best_path) >= 3:\n            best_path = smooth_path(best_path)\n\n        return PlannerResult(success=found_solution, path=best_path, nodes=nodes, edges=edges)",
          "objective": -34.45401,
          "time_improvement": 58.0,
          "length_improvement": 16.0,
          "smoothness_improvement": 1528.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.01999657154083252,
                    "num_nodes_avg": 89.9,
                    "path_length_avg": 162.74971200158262,
                    "smoothness_avg": 0.039820397090488915,
                    "success_improvement": 0.0,
                    "time_improvement": 17.660231394897927,
                    "length_improvement": 10.794303917712321,
                    "smoothness_improvement": 523.2756858424558,
                    "objective_score": 14.39103019830905
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.019843316078186034,
                    "num_nodes_avg": 189.5,
                    "path_length_avg": 237.9191179380231,
                    "smoothness_avg": 0.09948050789722851,
                    "success_improvement": 0.0,
                    "time_improvement": 87.71047365579776,
                    "length_improvement": 20.57575031018248,
                    "smoothness_improvement": 2459.7051211092953,
                    "objective_score": 50.95711788839529
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.015211749076843261,
                    "num_nodes_avg": 187.6,
                    "path_length_avg": 127.43089079816491,
                    "smoothness_avg": 0.13379614372824492,
                    "success_improvement": 0.0,
                    "time_improvement": 69.28205868900604,
                    "length_improvement": 15.36646993880286,
                    "smoothness_improvement": 1601.877072419238,
                    "objective_score": 38.01388493207972
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m2",
          "algorithm_description": "An enhanced bidirectional RRT* inspired planner employing consistent neighbor radius scaling based on node count and dimension, spatial hashing for efficient neighbor search, adaptive informed sampling within an ellipsoid post initial solution, dynamic rewiring without lazy checks, and a multi-pass systematic path shortcutting routine. The planner alternates expansion between start and goal trees, continuously attempts to directly connect trees, and halts early upon stagnation. This design improves search efficiency, robust path quality, shorter path length, and smoother final routes through comprehensive rewiring and effective path smoothing.",
          "planning_mechanism": "The planner grows two trees alternating expansions, using spatial hash grids for neighbor queries and sampling progressively within an informed ellipsoid after a first solution is found. For each new node, it selects the parent minimizing cost with thorough collision checks and rewires neighbors to improve paths. Direct connections between trees are attempted to merge routes efficiently. Finally, a multi-pass systematic shortcutting smooths and shortens the path. Early stopping is applied to terminate when no improvements occur, leading to faster convergence and strong path quality.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=4000, step_size=5.5,\n                 max_radius=28.0, min_radius=5.5,\n                 max_no_improve=70, time_limit=25.0,\n                 shortcut_iter=180):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.max_radius = max_radius\n        self.min_radius = min_radius\n        self.max_no_improve = max_no_improve\n        self.time_limit = time_limit\n        self.shortcut_iter = shortcut_iter\n\n    def plan(self, map):\n        import math\n        import random\n        import time\n\n        start = tuple(map.start)\n        goal = tuple(map.goal)\n        bounds = tuple(map.size)\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        dist = lambda a,b: math.dist(a, b)\n\n        def in_bounds(pos):\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def in_obstacle(pos):\n            if is_3d:\n                px, py, pz = pos\n                for obs in obstacles:\n                    ox, oy, oz, ow, oh, od = obs\n                    if ox <= px <= ox + ow and oy <= py <= oy + oh and oz <= pz <= oz + od:\n                        return True\n                return False\n            else:\n                px, py = pos\n                for obs in obstacles:\n                    ox, oy, ow, oh = obs\n                    if ox <= px <= ox + ow and oy <= py <= oy + oh:\n                        return True\n                return False\n\n        def edge_in_obstacle(a, b, res=1.0):\n            d = dist(a, b)\n            if d < 1e-12:\n                return False\n            steps = max(2, int(d / res))\n            for i in range(steps+1):\n                interp = tuple(a[d_] + (b[d_] - a[d_]) * i / steps for d_ in range(dim))\n                if in_obstacle(interp):\n                    return True\n            return False\n\n        def steer(from_p, to_p):\n            d = dist(from_p, to_p)\n            if d <= self.step_size:\n                return to_p\n            ratio = self.step_size / d\n            return tuple(from_p[d_] + (to_p[d_] - from_p[d_]) * ratio for d_ in range(dim))\n\n        # Spatial hash grid class to accelerate neighbor queries\n        class SpatialGrid:\n            def __init__(self, bounds, cell_size, dim):\n                self.bounds = bounds\n                self.cell_size = cell_size\n                self.dim = dim\n                self.cells = {}\n\n            def _hash_point(self, p):\n                return tuple(int(p[d] / self.cell_size) for d in range(self.dim))\n\n            def insert(self, node):\n                h = self._hash_point(node.position)\n                if h not in self.cells:\n                    self.cells[h] = []\n                self.cells[h].append(node)\n\n            def neighbors(self, point, radius):\n                low = [int((point[d] - radius) // self.cell_size) for d in range(self.dim)]\n                high = [int((point[d] + radius) // self.cell_size) for d in range(self.dim)]\n                result = []\n                def _grid_range(low_, high_, idx=None):\n                    if idx is None:\n                        idx = []\n                    if len(idx) == self.dim:\n                        yield tuple(idx)\n                        return\n                    dim_i = len(idx)\n                    for v in range(low_[dim_i], high_[dim_i] + 1):\n                        idx.append(v)\n                        yield from _grid_range(low_, high_, idx)\n                        idx.pop()\n                for cell in _grid_range(low, high):\n                    if cell in self.cells:\n                        result.extend(self.cells[cell])\n                return result\n\n            def clear(self):\n                self.cells.clear()\n\n        def adaptive_radius(n_nodes, iter_i):\n            # RRT* radius bound: gamma * (log(n)/n)^(1/d)\n            # Use slow decay with iteration via max_radius and min_radius clipping\n            gamma = self.max_radius\n            if n_nodes <= 1:\n                return gamma\n            base_r = gamma * (math.log(n_nodes) / n_nodes) ** (1.0/dim)\n            decay = max(self.min_radius / gamma, 1.0 - 0.85 * (iter_i / self.max_iter))\n            r = max(self.min_radius, min(base_r * decay, self.max_radius))\n            return r\n\n        def neighbors_in_radius(tree_nodes, grid, p, radius):\n            candidates = grid.neighbors(p, radius)\n            result = [n for n in candidates if dist(n.position, p) <= radius]\n            return result\n\n        def choose_parent(tree_nodes, grid, pos, iter_i):\n            n = len(tree_nodes)\n            r = adaptive_radius(n, iter_i)\n            nbrs = neighbors_in_radius(tree_nodes, grid, pos, r)\n            min_cost = float('inf')\n            best_parent = None\n            for nb in nbrs:\n                if edge_in_obstacle(nb.position, pos):\n                    continue\n                new_cost = nb.cost + dist(nb.position, pos)\n                if new_cost < min_cost:\n                    min_cost = new_cost\n                    best_parent = nb\n            if best_parent is None:\n                # fallback to nearest no collision node\n                nearest = min(tree_nodes, key=lambda node: dist(node.position, pos))\n                if edge_in_obstacle(nearest.position, pos):\n                    return None, []\n                best_parent = nearest\n                min_cost = best_parent.cost + dist(best_parent.position, pos)\n            new_node = Node(pos, parent=best_parent, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree_nodes.append(new_node)\n            grid.insert(new_node)\n            return new_node, nbrs\n\n        def rewire(pivot, nbrs):\n            for nb in nbrs:\n                if nb == pivot.parent:\n                    continue\n                new_cost = pivot.cost + dist(pivot.position, nb.position)\n                if new_cost + 1e-10 < nb.cost:\n                    if edge_in_obstacle(pivot.position, nb.position):\n                        continue\n                    if nb.parent is not None:\n                        nb.parent.remove_child(nb)\n                    pivot.add_child(nb)\n                    nb.cost = new_cost\n\n        def direct_connect(tree_nodes, grid, target_node):\n            if not tree_nodes:\n                return None\n            nearest = min(tree_nodes, key=lambda n: dist(n.position, target_node.position))\n            d_nearest = dist(nearest.position, target_node.position)\n            if d_nearest <= self.step_size:\n                if edge_in_obstacle(nearest.position, target_node.position) or in_obstacle(target_node.position):\n                    return None\n                new_node = Node(target_node.position, parent=nearest, cost=nearest.cost + d_nearest)\n                nearest.add_child(new_node)\n                tree_nodes.append(new_node)\n                grid.insert(new_node)\n                return new_node\n            # Try direct edge if no obstacles\n            if not edge_in_obstacle(nearest.position, target_node.position):\n                new_node = Node(target_node.position, parent=nearest, cost=nearest.cost + d_nearest)\n                nearest.add_child(new_node)\n                tree_nodes.append(new_node)\n                grid.insert(new_node)\n                return new_node\n            # Incrementally steer toward target\n            steps = int(math.ceil(d_nearest / self.step_size))\n            current = nearest\n            for _ in range(steps):\n                new_pos = steer(current.position, target_node.position)\n                if not in_bounds(new_pos) or in_obstacle(new_pos) or edge_in_obstacle(current.position, new_pos):\n                    return None\n                new_node = Node(new_pos, parent=current, cost=current.cost + dist(current.position, new_pos))\n                current.add_child(new_node)\n                tree_nodes.append(new_node)\n                grid.insert(new_node)\n                current = new_node\n                if dist(current.position, target_node.position) <= self.step_size:\n                    if edge_in_obstacle(current.position, target_node.position) or in_obstacle(target_node.position):\n                        return None\n                    final_node = Node(target_node.position, parent=current, cost=current.cost + dist(current.position, target_node.position))\n                    current.add_child(final_node)\n                    tree_nodes.append(final_node)\n                    grid.insert(final_node)\n                    return final_node\n            return None\n\n        def sample_uniform():\n            return tuple(random.uniform(0.0, bounds[d]) for d in range(dim))\n\n        def sample_informed():\n            if not found_solution or best_cost >= float('inf') or c_min < 1e-12:\n                return sample_uniform()\n            center = tuple((start[d] + goal[d]) * 0.5 for d in range(dim))\n            unit_dir = []\n            for d in range(dim):\n                unit_dir.append((goal[d] - start[d]) / c_min)\n            r1 = best_cost * 0.5\n            val = max(best_cost * best_cost - c_min * c_min, 0.0)\n            r_other = math.sqrt(val) * 0.5\n\n            if dim == 2:\n                a1 = unit_dir\n                a2 = (-a1[1], a1[0])\n                basis = (a1, a2)\n                radii = (r1, r_other)\n            else:\n                def cross(u,v):\n                    return (u[1]*v[2]-u[2]*v[1], u[2]*v[0]-u[0]*v[2], u[0]*v[1]-u[1]*v[0])\n                def norm(v):\n                    return math.sqrt(sum(x*x for x in v))\n                a1 = unit_dir\n                ref = (1,0,0) if abs(a1[0]) < 0.9 else (0,1,0)\n                b2 = cross(a1, ref)\n                n_b2 = norm(b2)\n                if n_b2 < 1e-12:\n                    ref = (0,0,1)\n                    b2 = cross(a1, ref)\n                    n_b2 = norm(b2)\n                b2 = tuple(x / n_b2 for x in b2)\n                b3 = cross(a1, b2)\n                basis = (a1, b2, b3)\n                radii = (r1, r_other, r_other)\n\n            def sample_unit_ball(dim_):\n                while True:\n                    vec = [random.gauss(0,1) for _ in range(dim_)]\n                    nrm = math.sqrt(sum(v*v for v in vec))\n                    if nrm < 1e-14:\n                        continue\n                    vec = [v/nrm for v in vec]\n                    r = random.random() ** (1.0/dim_)\n                    return [v*r for v in vec]\n\n            u = sample_unit_ball(dim)\n            mapped = []\n            for d in range(dim):\n                val = center[d]\n                for i in range(dim):\n                    if i < len(basis):\n                        val += basis[i][d] * radii[i] * u[i]\n                val = max(0.0, min(val, bounds[d]))\n                mapped.append(val)\n            return tuple(mapped)\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path[:]\n            path = list(path)\n            for _ in range(self.shortcut_iter):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if not edge_in_obstacle(p1, p2):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        def connect_paths(node_a, node_b):\n            path_a = node_a.path_from_root()\n            path_b = node_b.path_from_root()\n            if path_a[-1] == path_b[-1]:\n                return path_a + path_b[-2::-1]\n            else:\n                return path_a + path_b[::-1]\n\n        # Initialize trees\n        start_root = Node(start, cost=0.0)\n        goal_root = Node(goal, cost=0.0)\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n        edges = []\n        nodes = [start_root, goal_root]\n\n        # Spatial grids\n        cell_size = self.step_size * 1.5\n        grid_start = SpatialGrid(bounds, cell_size, dim)\n        grid_goal = SpatialGrid(bounds, cell_size, dim)\n        grid_start.insert(start_root)\n        grid_goal.insert(goal_root)\n\n        c_min = dist(start, goal)\n        best_cost = float('inf')\n        best_path = []\n        found_solution = False\n        no_improve = 0\n\n        start_time = time.time()\n\n        for it in range(self.max_iter):\n            if (time.time() - start_time) > self.time_limit:\n                break\n\n            tree_a, grid_a = (start_tree, grid_start) if it % 2 == 0 else (goal_tree, grid_goal)\n            tree_b, grid_b = (goal_tree, grid_goal) if it % 2 == 0 else (start_tree, grid_start)\n\n            x_rand = sample_informed()\n\n            if not in_bounds(x_rand) or in_obstacle(x_rand):\n                if found_solution:\n                    no_improve += 1\n                    if no_improve >= self.max_no_improve:\n                        break\n                continue\n\n            nearest = min(tree_a, key=lambda n: dist(n.position, x_rand))\n            new_pos = steer(nearest.position, x_rand)\n            if not in_bounds(new_pos) or in_obstacle(new_pos) or edge_in_obstacle(nearest.position, new_pos):\n                if found_solution:\n                    no_improve += 1\n                    if no_improve >= self.max_no_improve:\n                        break\n                continue\n\n            new_node, nbrs = choose_parent(tree_a, grid_a, new_pos, it)\n            if new_node is None:\n                if found_solution:\n                    no_improve += 1\n                    if no_improve >= self.max_no_improve:\n                        break\n                continue\n\n            rewire(new_node, nbrs)\n\n            nodes.append(new_node)\n            edges.append((new_node.parent, new_node))\n\n            meet_node = direct_connect(tree_b, grid_b, new_node)\n            if meet_node is not None:\n                candidate_path = connect_paths(new_node, meet_node)\n                total_cost = 0.0\n                for i in range(len(candidate_path) - 1):\n                    total_cost += dist(candidate_path[i], candidate_path[i+1])\n\n                if total_cost + 1e-9 < best_cost:\n                    best_cost = total_cost\n                    best_path = candidate_path\n                    found_solution = True\n                    no_improve = 0\n                else:\n                    if found_solution:\n                        no_improve += 1\n                        if no_improve >= self.max_no_improve:\n                            break\n            else:\n                if found_solution:\n                    no_improve += 1\n                    if no_improve >= self.max_no_improve:\n                        break\n\n        if found_solution and len(best_path) >= 3:\n            best_path = shortcut_path(best_path)\n\n        return PlannerResult(success=found_solution, path=best_path, nodes=nodes, edges=edges)",
          "objective": -34.03393,
          "time_improvement": 55.0,
          "length_improvement": 17.0,
          "smoothness_improvement": 1480.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.0197298526763916,
                    "num_nodes_avg": 94.0,
                    "path_length_avg": 153.44598923252843,
                    "smoothness_avg": 0.04652924545929119,
                    "success_improvement": 0.0,
                    "time_improvement": 18.758498142066845,
                    "length_improvement": 15.89382179435248,
                    "smoothness_improvement": 628.2837313116212,
                    "objective_score": 18.305261175789646
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.02853994369506836,
                    "num_nodes_avg": 236.0,
                    "path_length_avg": 236.42688152824053,
                    "smoothness_avg": 0.1008504544454795,
                    "success_improvement": 0.0,
                    "time_improvement": 82.32440643889325,
                    "length_improvement": 21.073901775411443,
                    "smoothness_improvement": 2494.954832528408,
                    "objective_score": 49.816437159556884
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.01848320960998535,
                    "num_nodes_avg": 193.4,
                    "path_length_avg": 129.01597928456926,
                    "smoothness_avg": 0.11146478831747879,
                    "success_improvement": 0.0,
                    "time_improvement": 62.67581425579548,
                    "length_improvement": 14.31372963993577,
                    "smoothness_improvement": 1317.8238799234878,
                    "objective_score": 33.98010146031754
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m2",
          "algorithm_description": "A bidirectional RRT* planner with stabilized adaptive radius, efficient incremental neighbor searches, balanced curvature penalty to guide parent selection and rewiring with simplified checks, combined with progressive deterministic shortcutting smoothing passes and early stopping on stagnation, enhancing planning efficiency, path quality, robustness, and smoothness.",
          "planning_mechanism": "The planner grows two trees from start and goal points in alternation. Sampling adapts between uniform and informed ellipsoidal methods once a solution is found. The rewiring radius follows a smooth, bounded adaptive formula to prevent overly aggressive shrinking and maintain sufficient neighborhood size, improving exploration and rewiring opportunities. Curvature penalty guides parent choice and rewiring with a moderate quadratic cost to favor smoother paths but with simplified conditions reducing overhead. The smoothing stage applies multiple deterministic shortcut passes and adaptive angle pruning to systematically reduce sharp turns. Early termination on consecutive non-improvements speeds convergence. Spatial hashing supports efficient incremental neighbor queries without costly rebuilding.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self,\n                 max_iter=2500,\n                 step_size=6.0,\n                 max_radius=22.0,\n                 min_radius=8.5,\n                 max_no_improve=40,\n                 shortcut_passes=3,\n                 shortcut_iter_per_pass=100,\n                 cell_size=14.0,\n                 base_curvature_penalty=0.035):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.max_radius = max_radius\n        self.min_radius = min_radius\n        self.max_no_improve = max_no_improve\n        self.shortcut_passes = shortcut_passes\n        self.shortcut_iter_per_pass = shortcut_iter_per_pass\n        self.cell_size = cell_size\n        self.base_curvature_penalty = base_curvature_penalty\n\n    def plan(self, map):\n        import math\n        import random\n\n        bounds = map.size\n        dim = len(bounds)\n        start_pos = tuple(map.start)\n        goal_pos = tuple(map.goal)\n        obstacles = map.obstacles\n        is_3d = (dim == 3)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def in_obstacle(p):\n            px, py, pz = (p + (0, 0, 0))[:3]\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def edge_in_obstacle(a, b, resolution=1.0):\n            dist_ab = math.dist(a, b)\n            if dist_ab < 1e-12:\n                return False\n            steps = max(3, int(dist_ab / resolution))\n            for i in range(steps + 1):\n                interp = tuple(a[d] + (b[d] - a[d]) * i / steps for d in range(dim))\n                if in_obstacle(interp):\n                    return True\n            return False\n\n        def steer(frm, to):\n            distv = math.dist(frm, to)\n            if distv <= self.step_size:\n                return to\n            ratio = self.step_size / distv\n            return tuple(frm[d] + (to[d] - frm[d]) * ratio for d in range(dim))\n\n        class SpatialHash:\n            def __init__(self, bounds, cell_size):\n                self.cell_size = cell_size\n                self.inv_cell = 1.0 / cell_size\n                self.grid = {}\n                self.bounds = bounds\n                self.dim = len(bounds)\n\n            def _hash_coords(self, p):\n                return tuple(int(p[d] * self.inv_cell) for d in range(self.dim))\n\n            def insert(self, node):\n                hc = self._hash_coords(node.position)\n                self.grid.setdefault(hc, []).append(node)\n\n            def remove(self, node):\n                hc = self._hash_coords(node.position)\n                cell = self.grid.get(hc, [])\n                if node in cell:\n                    cell.remove(node)\n                    if not cell:\n                        del self.grid[hc]\n\n            def neighbors(self, p, radius):\n                r_cells = int(math.ceil(radius * self.inv_cell))\n                hc = self._hash_coords(p)\n                candidates = []\n                for dx in range(-r_cells, r_cells + 1):\n                    for dy in range(-r_cells, r_cells + 1):\n                        if self.dim == 2:\n                            cell_key = (hc[0] + dx, hc[1] + dy)\n                            cell_nodes = self.grid.get(cell_key)\n                            if cell_nodes:\n                                candidates.extend(cell_nodes)\n                        else:\n                            for dz in range(-r_cells, r_cells + 1):\n                                cell_key = (hc[0] + dx, hc[1] + dy, hc[2] + dz)\n                                cell_nodes = self.grid.get(cell_key)\n                                if cell_nodes:\n                                    candidates.extend(cell_nodes)\n                r_sq = radius * radius\n                result = []\n                for node in candidates:\n                    dsq = 0.0\n                    for d in range(self.dim):\n                        diff = node.position[d] - p[d]\n                        dsq += diff * diff\n                        if dsq > r_sq:\n                            break\n                    else:\n                        result.append(node)\n                return result\n\n        def sample_uniform():\n            return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        def sample_informed(c_best, c_min):\n            if c_best == float('inf') or c_min < 1e-12:\n                return sample_uniform()\n            center = tuple((start_pos[d] + goal_pos[d]) * 0.5 for d in range(dim))\n            unit_dir = [(goal_pos[d] - start_pos[d]) / c_min for d in range(dim)]\n            r1 = c_best * 0.5\n            diff_sq = max(c_best * c_best - c_min * c_min, 0.0)\n            r_other = math.sqrt(diff_sq) * 0.5\n            if dim == 2:\n                a1 = unit_dir\n                a2 = (-a1[1], a1[0])\n                basis = (a1, a2)\n                radii = (r1, r_other)\n            else:\n                def cross(u, v):\n                    return (\n                        u[1] * v[2] - u[2] * v[1],\n                        u[2] * v[0] - u[0] * v[2],\n                        u[0] * v[1] - u[1] * v[0],\n                    )\n\n                def norm(v):\n                    return math.sqrt(sum(x * x for x in v))\n\n                a1 = unit_dir\n                ref = (1, 0, 0) if abs(a1[0]) < 0.9 else (0, 1, 0)\n                b2 = cross(a1, ref)\n                n_b2 = norm(b2)\n                if n_b2 < 1e-14:\n                    ref = (0, 0, 1)\n                    b2 = cross(a1, ref)\n                    n_b2 = norm(b2)\n                b2 = tuple(x / n_b2 for x in b2)\n                b3 = cross(a1, b2)\n                basis = (a1, b2, b3)\n                radii = (r1, r_other, r_other)\n\n            def sample_unit_ball(dim_):\n                while True:\n                    vec = [random.gauss(0, 1) for _ in range(dim_)]\n                    nrm = math.sqrt(sum(v * v for v in vec))\n                    if nrm < 1e-14:\n                        continue\n                    vec = [v / nrm for v in vec]\n                    r = random.random() ** (1 / dim_)\n                    return [v * r for v in vec]\n\n            u = sample_unit_ball(dim)\n            mapped = []\n            for d in range(dim):\n                val = center[d]\n                for i in range(dim):\n                    val += basis[i][d] * radii[i] * u[i]\n                val = max(0.0, min(val, bounds[d]))\n                mapped.append(val)\n            sample = tuple(mapped)\n            if in_obstacle(sample):\n                return sample_uniform()\n            return sample\n\n        def adaptive_radius(num_nodes, best_cost):\n            if num_nodes <= 1:\n                return self.max_radius\n            base_log = max(1.5, math.log(num_nodes))\n            # stabilized function limiting too small radius and avoiding aggressive shrinking\n            base = self.max_radius * (base_log / num_nodes) ** (1.0 / dim)\n            base = max(self.min_radius, min(base, self.max_radius))\n            if best_cost != float('inf'):\n                base = max(self.min_radius, min(base, best_cost * 0.8))\n            return base\n\n        def curvature_angle(p0, p1, p2):\n            v1 = [p1[d] - p0[d] for d in range(dim)]\n            v2 = [p2[d] - p1[d] for d in range(dim)]\n            n1 = math.sqrt(sum(x * x for x in v1))\n            n2 = math.sqrt(sum(x * x for x in v2))\n            if n1 < 1e-12 or n2 < 1e-12:\n                return 0.0\n            dot = sum(v1[d] * v2[d] for d in range(dim)) / (n1 * n2)\n            dot = max(-1.0, min(1.0, dot))\n            return math.acos(dot)\n\n        def adaptive_curvature_penalty(p_parent, p_last, p_new):\n            if p_parent is None:\n                return 0.0\n            angle = curvature_angle(p_parent, p_last, p_new)\n            norm_angle = angle / math.pi\n            return self.base_curvature_penalty * (norm_angle ** 2)\n\n        def choose_parent(tree_hash, tree_nodes, new_pos, radius):\n            nbrs = tree_hash.neighbors(new_pos, radius)\n            valid_parents = []\n            for n in nbrs:\n                if not edge_in_obstacle(n.position, new_pos) and not in_obstacle(new_pos):\n                    valid_parents.append(n)\n            if not valid_parents:\n                # fallback nearest collision-free parent (not global linear scan - limit to fixed radius)\n                fallback_nbrs = tree_hash.neighbors(new_pos, radius * 1.5)\n                nearest = None\n                ndist = float('inf')\n                for n in fallback_nbrs:\n                    dist = math.dist(n.position, new_pos)\n                    if dist < ndist and not edge_in_obstacle(n.position, new_pos) and not in_obstacle(new_pos):\n                        nearest = n\n                        ndist = dist\n                if nearest is None:\n                    return None, []\n                new_cost = nearest.cost + ndist\n                new_node = Node(new_pos, parent=nearest, cost=new_cost)\n                nearest.add_child(new_node)\n                tree_nodes.append(new_node)\n                tree_hash.insert(new_node)\n                return new_node, []\n            best_parent = None\n            min_score = float('inf')\n            best_cost_to_new = float('inf')\n            for p in valid_parents:\n                p_parent_pos = p.parent.position if p.parent else None\n                penalty = adaptive_curvature_penalty(p_parent_pos, p.position, new_pos)\n                cost_candidate = p.cost + math.dist(p.position, new_pos) + penalty\n                if cost_candidate < min_score:\n                    best_parent = p\n                    min_score = cost_candidate\n                    best_cost_to_new = p.cost + math.dist(p.position, new_pos)\n            new_node = Node(new_pos, parent=best_parent, cost=best_cost_to_new)\n            best_parent.add_child(new_node)\n            tree_nodes.append(new_node)\n            tree_hash.insert(new_node)\n            return new_node, valid_parents\n\n        def rewire(pivot, neighbors_, tree_hash):\n            p_parent_pos = pivot.parent.position if pivot.parent else None\n            for nb in neighbors_:\n                if nb == pivot.parent:\n                    continue\n                dist_pivot_nb = math.dist(pivot.position, nb.position)\n                new_cost = pivot.cost + dist_pivot_nb\n                if new_cost + 1e-12 < nb.cost:\n                    if edge_in_obstacle(pivot.position, nb.position):\n                        continue\n                    nb_parent_pos = nb.parent.position if nb.parent else None\n                    old_angle = curvature_angle(nb_parent_pos if nb_parent_pos else nb.position, nb.position,\n                                               nb.children[0].position if nb.children else nb.position)\n                    new_angle = curvature_angle(p_parent_pos if p_parent_pos else pivot.position,\n                                               pivot.position, nb.position)\n                    # Relaxed curvature check for rewire - allow if local curvature not worse by more than ~0.35 rad\n                    if new_angle <= old_angle + 0.35:\n                        if nb.parent:\n                            nb.parent.remove_child(nb)\n                        pivot.add_child(nb)\n                        nb.cost = new_cost\n\n        def attempt_connect(tree_hash, tree_nodes, node_to_connect):\n            if not tree_nodes:\n                return None\n            nearest = min(tree_nodes, key=lambda n: math.dist(n.position, node_to_connect.position))\n            dist_near = math.dist(nearest.position, node_to_connect.position)\n            if dist_near <= self.step_size:\n                if edge_in_obstacle(nearest.position, node_to_connect.position) or in_obstacle(node_to_connect.position):\n                    return None\n                new_node = Node(node_to_connect.position, parent=nearest, cost=nearest.cost + dist_near)\n                nearest.add_child(new_node)\n                tree_nodes.append(new_node)\n                tree_hash.insert(new_node)\n                return new_node\n            current = nearest\n            steps = int(math.ceil(dist_near / self.step_size))\n            for _ in range(steps):\n                new_pos = steer(current.position, node_to_connect.position)\n                if not in_bounds(new_pos) or in_obstacle(new_pos) or edge_in_obstacle(current.position, new_pos):\n                    return None\n                new_node = Node(new_pos, parent=current, cost=current.cost + math.dist(current.position, new_pos))\n                current.add_child(new_node)\n                tree_nodes.append(new_node)\n                tree_hash.insert(new_node)\n                current = new_node\n                if math.dist(current.position, node_to_connect.position) <= self.step_size:\n                    if edge_in_obstacle(current.position, node_to_connect.position) or in_obstacle(node_to_connect.position):\n                        return None\n                    final_node = Node(node_to_connect.position, parent=current,\n                                      cost=current.cost + math.dist(current.position, node_to_connect.position))\n                    current.add_child(final_node)\n                    tree_nodes.append(final_node)\n                    tree_hash.insert(final_node)\n                    return final_node\n            return None\n\n        def angle_cosine(p1, p2, p3):\n            v1 = [p2[d] - p1[d] for d in range(dim)]\n            v2 = [p3[d] - p2[d] for d in range(dim)]\n            norm1 = math.sqrt(sum(x * x for x in v1))\n            norm2 = math.sqrt(sum(x * x for x in v2))\n            if norm1 < 1e-12 or norm2 < 1e-12:\n                return 1.0\n            dot = sum(v1[d] * v2[d] for d in range(dim)) / (norm1 * norm2)\n            return max(-1.0, min(1.0, dot))\n\n        def smooth_path(path):\n            if len(path) < 3:\n                return path[:]\n            path = list(path)\n            n = len(path)\n            for pass_i in range(self.shortcut_passes):\n                max_seg = max(2, n // (4 - pass_i))\n                changes = True\n                while changes:\n                    changes = False\n                    i = 0\n                    while i < len(path) - 2:\n                        limit_j = min(i + max_seg, len(path) - 1)\n                        j = i + 2\n                        shortcut_done = False\n                        while j <= limit_j:\n                            if not edge_in_obstacle(path[i], path[j]):\n                                del path[i + 1:j]\n                                changes = True\n                                shortcut_done = True\n                                break\n                            j += 1\n                        if not shortcut_done:\n                            i += 1\n            for _ in range(2):\n                cosines = []\n                for i in range(1, len(path) - 1):\n                    cosines.append(angle_cosine(path[i - 1], path[i], path[i + 1]))\n                if not cosines:\n                    break\n                mean_cos = sum(cosines) / len(cosines)\n                std_cos = (sum((c - mean_cos) ** 2 for c in cosines) / len(cosines)) ** 0.5 if len(cosines) > 1 else 0.0\n                adapt_thresh = max(0.55, mean_cos - 0.25 * std_cos)\n                i = 1\n                while i < len(path) - 1:\n                    cphi = angle_cosine(path[i - 1], path[i], path[i + 1])\n                    if cphi > adapt_thresh:\n                        if not edge_in_obstacle(path[i - 1], path[i + 1]):\n                            path.pop(i)\n                            continue\n                    i += 1\n            return path\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n        start_hash = SpatialHash(bounds, self.cell_size)\n        goal_hash = SpatialHash(bounds, self.cell_size)\n        start_hash.insert(start_root)\n        goal_hash.insert(goal_root)\n        nodes = [start_root, goal_root]\n        edges = []\n\n        best_path = []\n        best_cost = float('inf')\n        c_min = math.dist(start_pos, goal_pos)\n        found_solution = False\n        no_improve_count = 0\n\n        for iter_i in range(self.max_iter):\n            if found_solution:\n                sample = sample_informed(best_cost, c_min)\n                if random.random() < 0.15:\n                    sample = sample_uniform()\n            else:\n                sample = sample_uniform()\n\n            if not in_bounds(sample) or in_obstacle(sample):\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n                continue\n\n            if iter_i % 2 == 0:\n                tree_nodes, tree_hash = start_tree, start_hash\n                other_nodes, other_hash = goal_tree, goal_hash\n            else:\n                tree_nodes, tree_hash = goal_tree, goal_hash\n                other_nodes, other_hash = start_tree, start_hash\n\n            nearest = min(tree_nodes, key=lambda n: math.dist(n.position, sample))\n            new_pos = steer(nearest.position, sample)\n            if not in_bounds(new_pos) or in_obstacle(new_pos) or edge_in_obstacle(nearest.position, new_pos):\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n                continue\n\n            radius = adaptive_radius(len(nodes), best_cost)\n            new_node, neighbors_ = choose_parent(tree_hash, tree_nodes, new_pos, radius)\n            if new_node is None:\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n                continue\n\n            rewire(new_node, neighbors_, tree_hash)\n            nodes.append(new_node)\n            if new_node.parent:\n                edges.append((new_node.parent, new_node))\n\n            connect_node = attempt_connect(other_hash, other_nodes, new_node)\n            if connect_node is not None:\n                if iter_i % 2 == 0:\n                    path_from = new_node.path_from_root()\n                    path_to = connect_node.path_from_root()\n                else:\n                    path_from = connect_node.path_from_root()\n                    path_to = new_node.path_from_root()\n\n                if path_from and path_to and path_from[-1] == path_to[-1]:\n                    candidate_path = path_from + path_to[-2::-1]\n                else:\n                    candidate_path = path_from + path_to[::-1]\n\n                total_cost = 0.0\n                for i in range(len(candidate_path) - 1):\n                    total_cost += math.dist(candidate_path[i], candidate_path[i + 1])\n\n                if total_cost + 1e-9 < best_cost:\n                    best_cost = total_cost\n                    best_path = candidate_path\n                    found_solution = True\n                    no_improve_count = 0\n                else:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n            else:\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n\n        if found_solution and len(best_path) >= 3:\n            best_path = smooth_path(best_path)\n        return PlannerResult(success=found_solution, path=best_path, nodes=nodes, edges=edges)",
          "objective": -33.96721,
          "time_improvement": 54.0,
          "length_improvement": 14.0,
          "smoothness_improvement": 1851.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.020581674575805665,
                    "num_nodes_avg": 92.3,
                    "path_length_avg": 173.33053054946487,
                    "smoothness_avg": 0.05060936855059147,
                    "success_improvement": 0.0,
                    "time_improvement": 15.250955964284485,
                    "length_improvement": 4.9947896078188725,
                    "smoothness_improvement": 692.1465178195746,
                    "objective_score": 11.032893143074542
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.025353479385375976,
                    "num_nodes_avg": 199.1,
                    "path_length_avg": 233.88790573267997,
                    "smoothness_avg": 0.12077787549725576,
                    "success_improvement": 0.0,
                    "time_improvement": 84.29787382330255,
                    "length_improvement": 21.92148497633578,
                    "smoothness_improvement": 3007.7017293318363,
                    "objective_score": 53.48076177945141
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.019076204299926756,
                    "num_nodes_avg": 179.1,
                    "path_length_avg": 126.28757734917039,
                    "smoothness_avg": 0.15360141920084422,
                    "success_improvement": 0.0,
                    "time_improvement": 61.478346693627984,
                    "length_improvement": 16.125804292889022,
                    "smoothness_improvement": 1853.7987145573316,
                    "objective_score": 37.387980156608464
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m2",
          "algorithm_description": "The algorithm is an enhanced bidirectional RRT* planner utilizing a stabilized adaptive radius strategy, efficient incremental spatial hashing for neighbor searches, and balanced curvature penalties to guide parent selection and rewiring, combined with multistage deterministic path shortcutting and adaptive node pruning to produce smooth, near-optimal feasible paths. It employs early termination on solution stagnation to improve planning efficiency.",
          "planning_mechanism": "The planner alternates expansion between two trees rooted at start and goal positions, sampling adaptively between uniform and ellipsoidal informed distributions after an initial solution is found. It uses a smoothly bounded adaptive radius inversely proportional to tree size to regulate neighborhood sizes and maintain exploration diversity. Parent selection and rewiring incorporate curvature-based penalties to favor smooth connections while preserving computational efficiency. A multi-pass deterministic shortcutting followed by adaptive threshold-based pruning reduces path curvature iteratively. Early stopping criteria terminate the search on prolonged absence of improvements, guaranteeing efficient convergence.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self,\n                 max_iter=2200,\n                 step_size=7.0,\n                 max_radius=20.0,\n                 min_radius=10.0,\n                 max_no_improve=35,\n                 shortcut_passes=4,\n                 shortcut_iter_per_pass=120,\n                 cell_size=15.0,\n                 base_curvature_penalty=0.028):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.max_radius = max_radius\n        self.min_radius = min_radius\n        self.max_no_improve = max_no_improve\n        self.shortcut_passes = shortcut_passes\n        self.shortcut_iter_per_pass = shortcut_iter_per_pass\n        self.cell_size = cell_size\n        self.base_curvature_penalty = base_curvature_penalty\n\n    def plan(self, map):\n        import math\n        import random\n\n        bounds = map.size\n        dim = len(bounds)\n        start_pos = tuple(map.start)\n        goal_pos = tuple(map.goal)\n        obstacles = map.obstacles\n        is_3d = (dim == 3)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def in_obstacle(p):\n            px, py, pz = (p + (0, 0, 0))[:3]\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def edge_in_obstacle(a, b, resolution=1.0):\n            dist_ab = math.dist(a, b)\n            if dist_ab < 1e-12:\n                return False\n            steps = max(3, int(dist_ab / resolution))\n            for i in range(steps + 1):\n                interp = tuple(a[d] + (b[d] - a[d]) * i / steps for d in range(dim))\n                if in_obstacle(interp):\n                    return True\n            return False\n\n        def steer(frm, to):\n            distv = math.dist(frm, to)\n            if distv <= self.step_size:\n                return to\n            ratio = self.step_size / distv\n            return tuple(frm[d] + (to[d] - frm[d]) * ratio for d in range(dim))\n\n        class SpatialHash:\n            def __init__(self, bounds, cell_size):\n                self.cell_size = cell_size\n                self.inv_cell = 1.0 / cell_size\n                self.grid = {}\n                self.bounds = bounds\n                self.dim = len(bounds)\n\n            def _hash_coords(self, p):\n                return tuple(int(p[d] * self.inv_cell) for d in range(self.dim))\n\n            def insert(self, node):\n                hc = self._hash_coords(node.position)\n                self.grid.setdefault(hc, []).append(node)\n\n            def remove(self, node):\n                hc = self._hash_coords(node.position)\n                cell = self.grid.get(hc, [])\n                if node in cell:\n                    cell.remove(node)\n                    if not cell:\n                        del self.grid[hc]\n\n            def neighbors(self, p, radius):\n                r_cells = int(math.ceil(radius * self.inv_cell))\n                hc = self._hash_coords(p)\n                candidates = []\n                if self.dim == 2:\n                    for dx in range(-r_cells, r_cells + 1):\n                        for dy in range(-r_cells, r_cells + 1):\n                            cell_key = (hc[0] + dx, hc[1] + dy)\n                            cell_nodes = self.grid.get(cell_key)\n                            if cell_nodes:\n                                candidates.extend(cell_nodes)\n                else:\n                    for dx in range(-r_cells, r_cells + 1):\n                        for dy in range(-r_cells, r_cells + 1):\n                            for dz in range(-r_cells, r_cells + 1):\n                                cell_key = (hc[0] + dx, hc[1] + dy, hc[2] + dz)\n                                cell_nodes = self.grid.get(cell_key)\n                                if cell_nodes:\n                                    candidates.extend(cell_nodes)\n                r_sq = radius * radius\n                result = []\n                for node in candidates:\n                    dsq = 0.0\n                    for d in range(self.dim):\n                        diff = node.position[d] - p[d]\n                        dsq += diff * diff\n                        if dsq > r_sq:\n                            break\n                    else:\n                        result.append(node)\n                return result\n\n        def sample_uniform():\n            return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        def sample_informed(c_best, c_min):\n            if c_best == float('inf') or c_min < 1e-12:\n                return sample_uniform()\n            center = tuple((start_pos[d] + goal_pos[d]) * 0.5 for d in range(dim))\n            unit_dir = [(goal_pos[d] - start_pos[d]) / c_min for d in range(dim)]\n            r1 = c_best * 0.5\n            diff_sq = max(c_best * c_best - c_min * c_min, 0.0)\n            r_other = math.sqrt(diff_sq) * 0.5\n            if dim == 2:\n                a1 = unit_dir\n                a2 = (-a1[1], a1[0])\n                basis = (a1, a2)\n                radii = (r1, r_other)\n            else:\n                def cross(u, v):\n                    return (\n                        u[1] * v[2] - u[2] * v[1],\n                        u[2] * v[0] - u[0] * v[2],\n                        u[0] * v[1] - u[1] * v[0],\n                    )\n\n                def norm(v):\n                    return math.sqrt(sum(x * x for x in v))\n\n                a1 = unit_dir\n                ref = (1, 0, 0) if abs(a1[0]) < 0.9 else (0, 1, 0)\n                b2 = cross(a1, ref)\n                n_b2 = norm(b2)\n                if n_b2 < 1e-14:\n                    ref = (0, 0, 1)\n                    b2 = cross(a1, ref)\n                    n_b2 = norm(b2)\n                b2 = tuple(x / n_b2 for x in b2)\n                b3 = cross(a1, b2)\n                basis = (a1, b2, b3)\n                radii = (r1, r_other, r_other)\n\n            def sample_unit_ball(dim_):\n                while True:\n                    vec = [random.gauss(0, 1) for _ in range(dim_)]\n                    nrm = math.sqrt(sum(v * v for v in vec))\n                    if nrm < 1e-14:\n                        continue\n                    vec = [v / nrm for v in vec]\n                    r = random.random() ** (1 / dim_)\n                    return [v * r for v in vec]\n\n            u = sample_unit_ball(dim)\n            mapped = []\n            for d in range(dim):\n                val = center[d]\n                for i in range(dim):\n                    val += basis[i][d] * radii[i] * u[i]\n                val = max(0.0, min(val, bounds[d]))\n                mapped.append(val)\n            sample = tuple(mapped)\n            if in_obstacle(sample):\n                return sample_uniform()\n            return sample\n\n        def adaptive_radius(num_nodes, best_cost):\n            if num_nodes <= 1:\n                return self.max_radius\n            base_log = max(1.7, math.log(num_nodes))\n            base = self.max_radius * (base_log / num_nodes) ** (1.0 / dim)\n            base = max(self.min_radius, min(base, self.max_radius))\n            if best_cost != float('inf'):\n                base = max(self.min_radius, min(base, best_cost * 0.85))\n            return base\n\n        def curvature_angle(p0, p1, p2):\n            v1 = [p1[d] - p0[d] for d in range(dim)]\n            v2 = [p2[d] - p1[d] for d in range(dim)]\n            n1 = math.sqrt(sum(x * x for x in v1))\n            n2 = math.sqrt(sum(x * x for x in v2))\n            if n1 < 1e-12 or n2 < 1e-12:\n                return 0.0\n            dot = sum(v1[d] * v2[d] for d in range(dim)) / (n1 * n2)\n            dot = max(-1.0, min(1.0, dot))\n            return math.acos(dot)\n\n        def adaptive_curvature_penalty(p_parent, p_last, p_new):\n            if p_parent is None:\n                return 0.0\n            angle = curvature_angle(p_parent, p_last, p_new)\n            norm_angle = angle / math.pi\n            return self.base_curvature_penalty * (norm_angle ** 2)\n\n        def choose_parent(tree_hash, tree_nodes, new_pos, radius):\n            nbrs = tree_hash.neighbors(new_pos, radius)\n            valid_parents = []\n            for n in nbrs:\n                if not edge_in_obstacle(n.position, new_pos) and not in_obstacle(new_pos):\n                    valid_parents.append(n)\n            if not valid_parents:\n                fallback_nbrs = tree_hash.neighbors(new_pos, radius * 1.8)\n                nearest = None\n                ndist = float('inf')\n                for n in fallback_nbrs:\n                    dist = math.dist(n.position, new_pos)\n                    if (dist < ndist\n                            and not edge_in_obstacle(n.position, new_pos)\n                            and not in_obstacle(new_pos)):\n                        nearest = n\n                        ndist = dist\n                if nearest is None:\n                    return None, []\n                new_cost = nearest.cost + ndist\n                new_node = Node(new_pos, parent=nearest, cost=new_cost)\n                nearest.add_child(new_node)\n                tree_nodes.append(new_node)\n                tree_hash.insert(new_node)\n                return new_node, []\n            best_parent = None\n            min_score = float('inf')\n            best_cost_to_new = float('inf')\n            for p in valid_parents:\n                p_parent_pos = p.parent.position if p.parent else None\n                penalty = adaptive_curvature_penalty(p_parent_pos, p.position, new_pos)\n                cost_candidate = p.cost + math.dist(p.position, new_pos) + penalty\n                if cost_candidate < min_score:\n                    best_parent = p\n                    min_score = cost_candidate\n                    best_cost_to_new = p.cost + math.dist(p.position, new_pos)\n            new_node = Node(new_pos, parent=best_parent, cost=best_cost_to_new)\n            best_parent.add_child(new_node)\n            tree_nodes.append(new_node)\n            tree_hash.insert(new_node)\n            return new_node, valid_parents\n\n        def rewire(pivot, neighbors_, tree_hash):\n            p_parent_pos = pivot.parent.position if pivot.parent else None\n            for nb in neighbors_:\n                if nb == pivot.parent:\n                    continue\n                dist_pivot_nb = math.dist(pivot.position, nb.position)\n                new_cost = pivot.cost + dist_pivot_nb\n                if new_cost + 1e-10 < nb.cost:\n                    if edge_in_obstacle(pivot.position, nb.position):\n                        continue\n                    nb_parent_pos = nb.parent.position if nb.parent else None\n                    old_angle = curvature_angle(nb_parent_pos if nb_parent_pos else nb.position,\n                                               nb.position,\n                                               nb.children[0].position if nb.children else nb.position)\n                    new_angle = curvature_angle(p_parent_pos if p_parent_pos else pivot.position,\n                                               pivot.position, nb.position)\n                    # Moderate curvature relaxation\n                    if new_angle <= old_angle + 0.30:\n                        if nb.parent:\n                            nb.parent.remove_child(nb)\n                        pivot.add_child(nb)\n                        nb.cost = new_cost\n\n        def attempt_connect(tree_hash, tree_nodes, node_to_connect):\n            if not tree_nodes:\n                return None\n            nearest = min(tree_nodes, key=lambda n: math.dist(n.position, node_to_connect.position))\n            dist_near = math.dist(nearest.position, node_to_connect.position)\n            if dist_near <= self.step_size:\n                if edge_in_obstacle(nearest.position, node_to_connect.position) or in_obstacle(node_to_connect.position):\n                    return None\n                new_node = Node(node_to_connect.position, parent=nearest, cost=nearest.cost + dist_near)\n                nearest.add_child(new_node)\n                tree_nodes.append(new_node)\n                tree_hash.insert(new_node)\n                return new_node\n            current = nearest\n            steps = int(math.ceil(dist_near / self.step_size))\n            for _ in range(steps):\n                new_pos = steer(current.position, node_to_connect.position)\n                if not in_bounds(new_pos) or in_obstacle(new_pos) or edge_in_obstacle(current.position, new_pos):\n                    return None\n                new_node = Node(new_pos, parent=current, cost=current.cost + math.dist(current.position, new_pos))\n                current.add_child(new_node)\n                tree_nodes.append(new_node)\n                tree_hash.insert(new_node)\n                current = new_node\n                if math.dist(current.position, node_to_connect.position) <= self.step_size:\n                    if edge_in_obstacle(current.position, node_to_connect.position) or in_obstacle(node_to_connect.position):\n                        return None\n                    final_node = Node(node_to_connect.position, parent=current,\n                                      cost=current.cost + math.dist(current.position, node_to_connect.position))\n                    current.add_child(final_node)\n                    tree_nodes.append(final_node)\n                    tree_hash.insert(final_node)\n                    return final_node\n            return None\n\n        def angle_cosine(p1, p2, p3):\n            v1 = [p2[d] - p1[d] for d in range(dim)]\n            v2 = [p3[d] - p2[d] for d in range(dim)]\n            norm1 = math.sqrt(sum(x * x for x in v1))\n            norm2 = math.sqrt(sum(x * x for x in v2))\n            if norm1 < 1e-12 or norm2 < 1e-12:\n                return 1.0\n            dot = sum(v1[d] * v2[d] for d in range(dim)) / (norm1 * norm2)\n            return max(-1.0, min(1.0, dot))\n\n        def smooth_path(path):\n            if len(path) < 3:\n                return path[:]\n            path = list(path)\n            n = len(path)\n            for pass_i in range(self.shortcut_passes):\n                max_seg = max(2, n // (5 - pass_i))\n                changes = True\n                while changes:\n                    changes = False\n                    i = 0\n                    while i < len(path) - 2:\n                        limit_j = min(i + max_seg, len(path) - 1)\n                        shortcut_done = False\n                        j = i + 2\n                        while j <= limit_j:\n                            if not edge_in_obstacle(path[i], path[j]):\n                                del path[i + 1:j]\n                                changes = True\n                                shortcut_done = True\n                                break\n                            j += 1\n                        if not shortcut_done:\n                            i += 1\n            for _ in range(3):\n                cosines = []\n                for i in range(1, len(path) - 1):\n                    cosines.append(angle_cosine(path[i - 1], path[i], path[i + 1]))\n                if not cosines:\n                    break\n                mean_cos = sum(cosines) / len(cosines)\n                std_cos = (sum((c - mean_cos) ** 2 for c in cosines) / len(cosines)) ** 0.5 if len(cosines) > 1 else 0.0\n                adapt_thresh = max(0.57, mean_cos - 0.28 * std_cos)\n                i = 1\n                while i < len(path) - 1:\n                    cphi = angle_cosine(path[i - 1], path[i], path[i + 1])\n                    if cphi > adapt_thresh:\n                        if not edge_in_obstacle(path[i - 1], path[i + 1]):\n                            path.pop(i)\n                            continue\n                    i += 1\n            return path\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n        start_hash = SpatialHash(bounds, self.cell_size)\n        goal_hash = SpatialHash(bounds, self.cell_size)\n        start_hash.insert(start_root)\n        goal_hash.insert(goal_root)\n        nodes = [start_root, goal_root]\n        edges = []\n\n        best_path = []\n        best_cost = float('inf')\n        c_min = math.dist(start_pos, goal_pos)\n        found_solution = False\n        no_improve_count = 0\n\n        for iter_i in range(self.max_iter):\n            if found_solution:\n                sample = sample_informed(best_cost, c_min)\n                if random.random() < 0.18:\n                    sample = sample_uniform()\n            else:\n                sample = sample_uniform()\n\n            if not in_bounds(sample) or in_obstacle(sample):\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n                continue\n\n            if iter_i % 2 == 0:\n                tree_nodes, tree_hash = start_tree, start_hash\n                other_nodes, other_hash = goal_tree, goal_hash\n            else:\n                tree_nodes, tree_hash = goal_tree, goal_hash\n                other_nodes, other_hash = start_tree, start_hash\n\n            nearest = min(tree_nodes, key=lambda n: math.dist(n.position, sample))\n            new_pos = steer(nearest.position, sample)\n            if not in_bounds(new_pos) or in_obstacle(new_pos) or edge_in_obstacle(nearest.position, new_pos):\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n                continue\n\n            radius = adaptive_radius(len(nodes), best_cost)\n            new_node, neighbors_ = choose_parent(tree_hash, tree_nodes, new_pos, radius)\n            if new_node is None:\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n                continue\n\n            rewire(new_node, neighbors_, tree_hash)\n            nodes.append(new_node)\n            if new_node.parent:\n                edges.append((new_node.parent, new_node))\n\n            connect_node = attempt_connect(other_hash, other_nodes, new_node)\n            if connect_node is not None:\n                if iter_i % 2 == 0:\n                    path_from = new_node.path_from_root()\n                    path_to = connect_node.path_from_root()\n                else:\n                    path_from = connect_node.path_from_root()\n                    path_to = new_node.path_from_root()\n\n                if path_from and path_to and path_from[-1] == path_to[-1]:\n                    candidate_path = path_from + path_to[-2::-1]\n                else:\n                    candidate_path = path_from + path_to[::-1]\n\n                total_cost = 0.0\n                for i in range(len(candidate_path) - 1):\n                    total_cost += math.dist(candidate_path[i], candidate_path[i + 1])\n\n                if total_cost + 1e-9 < best_cost:\n                    best_cost = total_cost\n                    best_path = candidate_path\n                    found_solution = True\n                    no_improve_count = 0\n                else:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n            else:\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n\n        if found_solution and len(best_path) >= 3:\n            best_path = smooth_path(best_path)\n        return PlannerResult(success=found_solution, path=best_path, nodes=nodes, edges=edges)",
          "objective": -33.94541,
          "time_improvement": 55.0,
          "length_improvement": 15.0,
          "smoothness_improvement": 1639.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.018680477142333986,
                    "num_nodes_avg": 73.2,
                    "path_length_avg": 166.54203392694396,
                    "smoothness_avg": 0.04905540276868659,
                    "success_improvement": 0.0,
                    "time_improvement": 23.07950579468979,
                    "length_improvement": 8.715672177235327,
                    "smoothness_improvement": 667.8235788420573,
                    "objective_score": 15.492372938958418
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.021914100646972655,
                    "num_nodes_avg": 177.1,
                    "path_length_avg": 233.40648918776395,
                    "smoothness_avg": 0.10530633639792145,
                    "success_improvement": 0.0,
                    "time_improvement": 86.42797825981668,
                    "length_improvement": 22.08219567583568,
                    "smoothness_improvement": 2609.607884606783,
                    "objective_score": 52.22575030648032
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.022051072120666503,
                    "num_nodes_avg": 167.4,
                    "path_length_avg": 127.29625041705307,
                    "smoothness_avg": 0.13684443615822822,
                    "success_improvement": 0.0,
                    "time_improvement": 55.47102862232494,
                    "length_improvement": 15.455891669051361,
                    "smoothness_improvement": 1640.6511271270833,
                    "objective_score": 34.118099223763714
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e1",
          "algorithm_description": "Bidirectional Anytime Informed RRT* with Curvature-Aware Spline Smoothing. This planner grows two trees simultaneously from start and goal with adaptive informed sampling based on current best cost to efficiently prune search space. It uses adaptive neighbor radius for rewiring to optimize path cost and performs early termination on stagnation. After finding a path, a smoothing phase fits cubic Bezier splines through the path to optimize curvature and generate smooth, continuous trajectories, improving path smoothness significantly without sacrificing path length or planning efficiency.",
          "planning_mechanism": "The planner alternates growing bidirectional RRT* trees using adaptive ellipsoidal informed sampling guided by current best path. It performs incremental rewiring within an adaptive radius minimizing cost while maintaining collision-free edges. Upon successful connection, it extracts the combined path and applies curvature-aware cubic Bezier spline smoothing to produce a natural, smooth trajectory before returning the final solution. Early stopping criteria speed convergence and limit unnecessary computation.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self,\n                 max_iter=6000,\n                 step_size=6.0,\n                 max_radius=35.0,\n                 min_radius=6.0,\n                 max_no_improve=70,\n                 time_limit=25.0,\n                 shortcut_iter=120):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.max_radius = max_radius\n        self.min_radius = min_radius\n        self.max_no_improve = max_no_improve\n        self.time_limit = time_limit\n        self.shortcut_iter = shortcut_iter\n\n    def plan(self, map):\n        import math, random, time\n\n        bounds = map.size\n        dim = len(bounds)\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = (dim == 3)\n\n        def in_bounds(pos):\n            return all(0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    px, py = pos\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def edge_in_obstacle(a, b, res=1.0):\n            dist = math.dist(a, b)\n            if dist < 1e-12:\n                return False\n            steps = max(3, int(dist / res))\n            for i in range(steps + 1):\n                interp = tuple(a[d] + (b[d] - a[d]) * i / steps for d in range(dim))\n                if in_obstacle(interp):\n                    return True\n            return False\n\n        def steer(from_p, to_p):\n            dist = math.dist(from_p, to_p)\n            if dist <= self.step_size:\n                return to_p\n            ratio = self.step_size / dist\n            return tuple(from_p[d] + (to_p[d] - from_p[d]) * ratio for d in range(dim))\n\n        def adaptive_radius(n, iter_i):\n            # Volume constant for unit ball in dim-dimensional space\n            from math import pi, gamma, log\n            gamma_dim = self.max_radius\n            unit_ball_vol = (pi ** (dim / 2)) / gamma(dim / 2 + 1) if dim > 1 else 2.0\n            if n < 2:\n                return self.max_radius\n            base_r = gamma_dim * ((log(n) / n) ** (1.0 / dim))\n            decay = max(self.min_radius / gamma_dim, 1.0 - 0.85 * (iter_i / self.max_iter))\n            return max(self.min_radius, min(base_r * decay, self.max_radius))\n\n        def neighbors(tree, pos, radius):\n            rsq = radius * radius\n            res = []\n            for node in tree:\n                dsq = 0.0\n                for d in range(dim):\n                    diff = node.position[d] - pos[d]\n                    dsq += diff * diff\n                    if dsq > rsq:\n                        break\n                else:\n                    res.append(node)\n            return res\n\n        def choose_parent(tree, pos, iter_i):\n            n = len(tree)\n            r = adaptive_radius(n, iter_i)\n            nbrs = neighbors(tree, pos, r)\n            if not nbrs:\n                # Fall back to nearest if no neighbors in radius\n                nearest = min(tree, key=lambda node: math.dist(node.position, pos))\n                if edge_in_obstacle(nearest.position, pos) or in_obstacle(pos):\n                    return None, []\n                cost_here = nearest.cost + math.dist(nearest.position, pos)\n                new_node = Node(pos, parent=nearest, cost=cost_here)\n                nearest.add_child(new_node)\n                tree.append(new_node)\n                return new_node, []\n            min_cost = float('inf')\n            best_parent = None\n            for nb in nbrs:\n                dist_nb = math.dist(nb.position, pos)\n                est_cost = nb.cost + dist_nb\n                if est_cost >= min_cost:\n                    continue\n                if edge_in_obstacle(nb.position, pos):\n                    continue\n                if est_cost < min_cost:\n                    min_cost = est_cost\n                    best_parent = nb\n            if best_parent is None:\n                # Safety fallback\n                nearest = min(tree, key=lambda node: math.dist(node.position, pos))\n                if edge_in_obstacle(nearest.position, pos) or in_obstacle(pos):\n                    return None, []\n                best_parent = nearest\n                min_cost = best_parent.cost + math.dist(best_parent.position, pos)\n            new_node = Node(pos, parent=best_parent, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree.append(new_node)\n            return new_node, nbrs\n\n        def rewire(pivot, nbrs):\n            for nb in nbrs:\n                if nb == pivot.parent:\n                    continue\n                new_cost = pivot.cost + math.dist(pivot.position, nb.position)\n                if new_cost + 1e-12 < nb.cost:\n                    if edge_in_obstacle(pivot.position, nb.position):\n                        continue\n                    # Remove from old parent's children to prevent references\n                    if nb.parent is not None:\n                        nb.parent.remove_child(nb)\n                    pivot.add_child(nb)\n                    nb.cost = new_cost\n\n        def direct_connect(tree, target_node):\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda n: math.dist(n.position, target_node.position))\n            dist = math.dist(nearest.position, target_node.position)\n            if dist <= self.step_size:\n                if edge_in_obstacle(nearest.position, target_node.position) or in_obstacle(target_node.position):\n                    return None\n                new_node = Node(target_node.position, parent=nearest, cost=nearest.cost + dist)\n                nearest.add_child(new_node)\n                tree.append(new_node)\n                return new_node\n            current = nearest\n            steps = int(math.ceil(dist / self.step_size))\n            for _ in range(steps):\n                new_pos = steer(current.position, target_node.position)\n                if not in_bounds(new_pos) or in_obstacle(new_pos) or edge_in_obstacle(current.position, new_pos):\n                    return None\n                new_node = Node(new_pos, parent=current, cost=current.cost + math.dist(current.position, new_pos))\n                current.add_child(new_node)\n                tree.append(new_node)\n                current = new_node\n                if math.dist(current.position, target_node.position) <= self.step_size:\n                    if edge_in_obstacle(current.position, target_node.position) or in_obstacle(target_node.position):\n                        return None\n                    final_node = Node(target_node.position, parent=current, cost=current.cost + math.dist(current.position, target_node.position))\n                    current.add_child(final_node)\n                    tree.append(final_node)\n                    return final_node\n            return None\n\n        def sample_uniform():\n            while True:\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not in_obstacle(p):\n                    return p\n\n        def sample_informed():\n            if not found_solution or best_cost == float('inf') or c_min < 1e-12:\n                return sample_uniform()\n            center = tuple((start_pos[d] + goal_pos[d]) * 0.5 for d in range(dim))\n            unit_dir = tuple((goal_pos[d] - start_pos[d]) / c_min for d in range(dim))\n            r1 = best_cost * 0.5\n            val = max(best_cost*best_cost - c_min*c_min, 0.0)\n            r_other = math.sqrt(val) * 0.5\n            if dim == 2:\n                a1 = unit_dir\n                a2 = (-a1[1], a1[0])\n                basis = (a1, a2)\n                radii = (r1, r_other)\n            else:\n                def cross(u, v):\n                    return (u[1]*v[2]-u[2]*v[1], u[2]*v[0]-u[0]*v[2], u[0]*v[1]-u[1]*v[0])\n                def norm(v):\n                    return math.sqrt(sum(x*x for x in v))\n                a1 = unit_dir\n                ref = (1,0,0) if abs(a1[0]) < 0.9 else (0,1,0)\n                b2 = cross(a1, ref)\n                n_b2 = norm(b2)\n                if n_b2 < 1e-12:\n                    ref = (0,0,1)\n                    b2 = cross(a1, ref)\n                    n_b2 = norm(b2)\n                b2 = tuple(x / n_b2 for x in b2)\n                b3 = cross(a1, b2)\n                basis = (a1, b2, b3)\n                radii = (r1, r_other, r_other)\n            def sample_unit_ball(dim):\n                while True:\n                    vec = [random.gauss(0,1) for _ in range(dim)]\n                    nrm = math.sqrt(sum(v*v for v in vec))\n                    if nrm < 1e-12:\n                        continue\n                    vec = [v/nrm for v in vec]\n                    r = random.random() ** (1/dim)\n                    return [v*r for v in vec]\n            u = sample_unit_ball(dim)\n            mapped = []\n            for d in range(dim):\n                val = center[d]\n                for i in range(dim):\n                    val += basis[i][d]*radii[i]*u[i]\n                # Clamp inside bounds exactly\n                mapped.append(min(max(val, 0.0), bounds[d]))\n            if not in_obstacle(tuple(mapped)):\n                return tuple(mapped)\n            return sample_uniform()\n\n        def bezier_cubic(p0, p1, p2, p3, t):\n            \"\"\"Compute cubic Bezier curve point at t [0..1].\"\"\"\n            u = 1 - t\n            tt = t * t\n            uu = u * u\n            uuu = uu * u\n            ttt = tt * t\n            x = uuu * p0[0] + 3 * uu * t * p1[0] + 3 * u * tt * p2[0] + ttt * p3[0]\n            y = uuu * p0[1] + 3 * uu * t * p1[1] + 3 * u * tt * p2[1] + ttt * p3[1]\n            if dim == 2:\n                return (x, y)\n            z = uuu * p0[2] + 3 * uu * t * p1[2] + 3 * u * tt * p2[2] + ttt * p3[2]\n            return (x, y, z)\n\n        def smooth_path_bezier(path):\n            if len(path) < 4:\n                return path[:]  # Too short to smooth reliably\n\n            # Create a new smoothed path with Bezier segments through triples of points\n            smoothed = [path[0]]\n            for i in range(1, len(path) - 2):\n                p0, p1, p2, p3 = path[i-1], path[i], path[i+1], path[i+2]\n\n                # Compute control points for smooth cubic bezier curve segment\n                def control_point(prev, curr, nxt, alpha=0.3):\n                    return tuple(curr[d] + alpha*(nxt[d]-prev[d]) for d in range(dim))\n\n                cp1 = control_point(p0, p1, p2)\n                cp2 = control_point(p1, p2, p3)\n                samples = max(3, int(math.dist(p1,p2)/self.step_size))  # samples per segment\n\n                for s in range(1, samples+1):\n                    t = s / samples\n                    pt = bezier_cubic(p1, cp1, cp2, p2, t)\n                    if not in_obstacle(pt) and not edge_in_obstacle(smoothed[-1], pt):\n                        smoothed.append(pt)\n                    else:\n                        # If collision, append p2 directly, break to next segment\n                        smoothed.append(p2)\n                        break\n            if smoothed[-1] != path[-1]:\n                smoothed.append(path[-1])\n            return smoothed\n\n        def shortcut_path(path):\n            # Random shortcuts to fix small holes or jumps left after smoothing\n            if len(path) < 3:\n                return path[:]\n            for _ in range(self.shortcut_iter):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path)-3)\n                j = random.randint(i+2, len(path)-1)\n                p1, p2 = path[i], path[j]\n                if not edge_in_obstacle(p1, p2):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        best_path = []\n        best_cost = float('inf')\n        c_min = math.dist(start_pos, goal_pos)\n        found_solution = False\n        no_improve_count = 0\n\n        start_time = time.time()\n\n        for it in range(self.max_iter):\n            if time.time() - start_time > self.time_limit:\n                break\n\n            tree_a, tree_b = (start_tree, goal_tree) if it % 2 == 0 else (goal_tree, start_tree)\n            x_rand = sample_informed()\n\n            if not in_bounds(x_rand) or in_obstacle(x_rand):\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n                continue\n\n            nearest = min(tree_a, key=lambda node: math.dist(node.position, x_rand))\n            new_pos = steer(nearest.position, x_rand)\n            if not in_bounds(new_pos) or in_obstacle(new_pos) or edge_in_obstacle(nearest.position, new_pos):\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n                continue\n\n            new_node, nbrs = choose_parent(tree_a, new_pos, it)\n            if new_node is None:\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n                continue\n\n            rewire(new_node, nbrs)\n            nodes.append(new_node)\n            if new_node.parent:\n                edges.append((new_node.parent, new_node))\n\n            meet_node = direct_connect(tree_b, new_node)\n            if meet_node is not None:\n                # Combine paths carefully avoiding duplication at connection node\n                if it % 2 == 0:\n                    path_a = new_node.path_from_root()\n                    path_b = meet_node.path_from_root()\n                else:\n                    path_a = meet_node.path_from_root()\n                    path_b = new_node.path_from_root()\n                if path_a and path_b and path_a[-1] == path_b[-1]:\n                    merged_path = path_a + path_b[-2::-1]\n                else:\n                    merged_path = path_a + path_b[::-1]\n\n                # Compute total cost along merged path\n                total_cost = 0.0\n                for i in range(len(merged_path) - 1):\n                    total_cost += math.dist(merged_path[i], merged_path[i + 1])\n\n                if total_cost + 1e-9 < best_cost:\n                    best_cost = total_cost\n                    best_path = merged_path\n                    found_solution = True\n                    no_improve_count = 0\n                else:\n                    if found_solution:\n                        no_improve_count += 1\n                        if no_improve_count >= self.max_no_improve:\n                            break\n            else:\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n\n        if found_solution and len(best_path) >= 4:\n            # Apply spline smoothing to improve curvature and smoothness\n            best_path = smooth_path_bezier(best_path)\n            # Additional shortcut passes to refine path\n            best_path = shortcut_path(best_path)\n\n        return PlannerResult(success=found_solution, path=best_path, nodes=nodes, edges=edges)",
          "objective": -33.48325,
          "time_improvement": 52.0,
          "length_improvement": 18.0,
          "smoothness_improvement": 1448.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.02188541889190674,
                    "num_nodes_avg": 126.1,
                    "path_length_avg": 159.10679264997313,
                    "smoothness_avg": 0.040380418046515855,
                    "success_improvement": 0.0,
                    "time_improvement": 9.88253542835544,
                    "length_improvement": 12.79104574008065,
                    "smoothness_improvement": 532.0412299092479,
                    "objective_score": 13.299594222101263
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.023896503448486327,
                    "num_nodes_avg": 225.2,
                    "path_length_avg": 231.08930648993655,
                    "smoothness_avg": 0.09728385757415844,
                    "success_improvement": 0.0,
                    "time_improvement": 85.20022018964188,
                    "length_improvement": 22.85573795677634,
                    "smoothness_improvement": 2403.183726113427,
                    "objective_score": 51.2894274615255
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.01906890869140625,
                    "num_nodes_avg": 199.7,
                    "path_length_avg": 124.55936634727755,
                    "smoothness_avg": 0.1186902882292356,
                    "success_improvement": 0.0,
                    "time_improvement": 61.493079126645966,
                    "length_improvement": 17.273599751781756,
                    "smoothness_improvement": 1409.7317054701086,
                    "objective_score": 35.86074211641339
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "A simplified bidirectional RRT* planner using uniform and ellipsoidal informed sampling with efficient neighbor lookups, adaptive rewiring radius, incremental rewiring, and post-planning shortcut smoothing to improve path quality, smoothness, and planning speed while maintaining robustness. It alternates tree expansion from start and goal, performs parent selection to minimize cost with strict collision checks, tries direct and incremental tree connection after each insertion, and applies a random shortcutting heuristic for path smoothing.",
          "planning_mechanism": "The planner grows two trees from start and goal, sampling points biased towards an ellipsoidal informed subset once a solution is found, steering towards samples to add nodes, selecting parents among neighbors minimizing path cost, rewiring neighbors to improve connectivity and cost, connecting the two trees incrementally after each node addition, and applying shortcut smoothing post planning for improved path smoothness and length.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self,\n                 max_iter=4000,\n                 step_size=5.0,\n                 max_radius=20.0,\n                 min_radius=5.0,\n                 max_no_improve=60,\n                 shortcut_iter=100):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.max_radius = max_radius\n        self.min_radius = min_radius\n        self.max_no_improve = max_no_improve\n        self.shortcut_iter = shortcut_iter\n\n    def plan(self, map):\n        import math\n        import random\n        import time\n\n        bounds = map.size\n        dim = len(bounds)\n        start_pos = tuple(map.start)\n        goal_pos = tuple(map.goal)\n        obstacles = map.obstacles\n        is_3d = (dim == 3)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def in_obstacle(p):\n            px, py, pz = (p + (0, 0, 0))[:3]\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def edge_in_obstacle(a, b, res=1.0):\n            dist_ab = math.dist(a, b)\n            if dist_ab < 1e-12:\n                return False\n            steps = max(2, int(dist_ab / res))\n            for i in range(steps + 1):\n                interp = tuple(a[d] + (b[d] - a[d]) * i / steps for d in range(dim))\n                if in_obstacle(interp):\n                    return True\n            return False\n\n        def steer(frm, to):\n            dist_frm_to = math.dist(frm, to)\n            if dist_frm_to <= self.step_size:\n                return to\n            ratio = self.step_size / dist_frm_to\n            return tuple(frm[d] + (to[d] - frm[d]) * ratio for d in range(dim))\n\n        def adaptive_radius(n_nodes, iter_i):\n            if n_nodes <= 1:\n                return self.max_radius\n            gamma = self.max_radius\n            import math as m\n            r = gamma * (m.log(n_nodes) / n_nodes) ** (1 / dim)\n            decay = max(self.min_radius / gamma, 1.0 - 0.9 * (iter_i / self.max_iter))\n            return max(self.min_radius, min(r * decay, self.max_radius))\n\n        def neighbors(tree, point, radius):\n            r_sq = radius * radius\n            res = []\n            for node in tree:\n                d_sq = 0.0\n                for i in range(dim):\n                    diff = node.position[i] - point[i]\n                    d_sq += diff * diff\n                    if d_sq > r_sq:\n                        break\n                else:\n                    res.append(node)\n            return res\n\n        def choose_parent(tree, new_pos, iter_i):\n            n_nodes = len(tree)\n            r = adaptive_radius(n_nodes, iter_i)\n            nbrs = neighbors(tree, new_pos, r)\n            valid_parents = [n for n in nbrs if not edge_in_obstacle(n.position, new_pos)]\n            if not valid_parents:\n                nearest = None\n                nearest_dist = float('inf')\n                for n in tree:\n                    d = math.dist(n.position, new_pos)\n                    if d < nearest_dist and not edge_in_obstacle(n.position, new_pos):\n                        nearest = n\n                        nearest_dist = d\n                if nearest is None:\n                    return None, []\n                cost = nearest.cost + nearest_dist\n                new_node = Node(new_pos, parent=nearest, cost=cost)\n                nearest.add_child(new_node)\n                tree.append(new_node)\n                return new_node, []\n            best_parent = min(valid_parents, key=lambda p: p.cost + math.dist(p.position, new_pos))\n            min_cost = best_parent.cost + math.dist(best_parent.position, new_pos)\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree.append(new_node)\n            return new_node, valid_parents\n\n        def rewire(pivot, nbrs):\n            for nb in nbrs:\n                if nb is pivot.parent:\n                    continue\n                dist_pivot_nb = math.dist(pivot.position, nb.position)\n                new_cost = pivot.cost + dist_pivot_nb\n                if new_cost + 1e-12 < nb.cost and not edge_in_obstacle(pivot.position, nb.position):\n                    if nb.parent is not None:\n                        nb.parent.remove_child(nb)\n                    pivot.add_child(nb)\n                    nb.cost = new_cost\n\n        def attempt_connect(tree_from, node_to_connect):\n            if not tree_from:\n                return None\n            nearest = min(tree_from, key=lambda n: math.dist(n.position, node_to_connect.position))\n            dist_near = math.dist(nearest.position, node_to_connect.position)\n            if dist_near <= self.step_size:\n                if edge_in_obstacle(nearest.position, node_to_connect.position) or in_obstacle(node_to_connect.position):\n                    return None\n                new_node = Node(node_to_connect.position, parent=nearest, cost=nearest.cost + dist_near)\n                nearest.add_child(new_node)\n                tree_from.append(new_node)\n                return new_node\n            current = nearest\n            steps = int(math.ceil(dist_near / self.step_size))\n            for _ in range(steps):\n                new_pos = steer(current.position, node_to_connect.position)\n                if not in_bounds(new_pos) or in_obstacle(new_pos) or edge_in_obstacle(current.position, new_pos):\n                    return None\n                new_node = Node(new_pos, parent=current, cost=current.cost + math.dist(current.position, new_pos))\n                current.add_child(new_node)\n                tree_from.append(new_node)\n                current = new_node\n                if math.dist(current.position, node_to_connect.position) <= self.step_size:\n                    if edge_in_obstacle(current.position, node_to_connect.position) or in_obstacle(node_to_connect.position):\n                        return None\n                    final_node = Node(node_to_connect.position, parent=current,\n                                      cost=current.cost + math.dist(current.position, node_to_connect.position))\n                    current.add_child(final_node)\n                    tree_from.append(final_node)\n                    return final_node\n            return None\n\n        def sample_uniform():\n            return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        def sample_informed(c_best, c_min):\n            if c_best == float('inf') or c_min < 1e-12:\n                return sample_uniform()\n            center = tuple((start_pos[d] + goal_pos[d]) / 2 for d in range(dim))\n            unit_dir = []\n            for d in range(dim):\n                unit_dir.append((goal_pos[d] - start_pos[d]) / c_min)\n            r1 = c_best * 0.5\n            val = max(c_best * c_best - c_min * c_min, 0.0)\n            r_other = math.sqrt(val) * 0.5\n\n            if dim == 2:\n                a1 = unit_dir\n                a2 = (-a1[1], a1[0])\n                basis = (a1, a2)\n                radii = (r1, r_other)\n            else:\n                def cross(u, v):\n                    return (u[1] * v[2] - u[2] * v[1], u[2] * v[0] - u[0] * v[2], u[0] * v[1] - u[1] * v[0])\n                def norm(v):\n                    return math.sqrt(sum(x * x for x in v))\n                a1 = unit_dir\n                ref = (1, 0, 0) if abs(a1[0]) < 0.9 else (0, 1, 0)\n                b2 = cross(a1, ref)\n                n_b2 = norm(b2)\n                if n_b2 < 1e-12:\n                    ref = (0, 0, 1)\n                    b2 = cross(a1, ref)\n                    n_b2 = norm(b2)\n                b2 = tuple(x / n_b2 for x in b2)\n                b3 = cross(a1, b2)\n                basis = (a1, b2, b3)\n                radii = (r1, r_other, r_other)\n            def sample_unit_ball(dim):\n                while True:\n                    vec = [random.gauss(0, 1) for _ in range(dim)]\n                    nrm = math.sqrt(sum(v * v for v in vec))\n                    if nrm < 1e-12:\n                        continue\n                    vec = [v / nrm for v in vec]\n                    r = random.random() ** (1 / dim)\n                    return [v * r for v in vec]\n            u = sample_unit_ball(dim)\n            mapped = []\n            for d in range(dim):\n                val = center[d]\n                for i in range(dim):\n                    val += basis[i][d] * radii[i] * u[i]\n                mapped.append(max(0.0, min(val, bounds[d])))\n            return tuple(mapped)\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path[:]\n            path = list(path)\n            for _ in range(self.shortcut_iter):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if not edge_in_obstacle(path[i], path[j]):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        best_path = []\n        best_cost = float('inf')\n        c_min = math.dist(start_pos, goal_pos)\n        found_solution = False\n        no_improve_count = 0\n\n        start_time = time.time()\n\n        for iter_i in range(self.max_iter):\n            if found_solution:\n                sample = sample_informed(best_cost, c_min)\n                # occasional uniform sampling to avoid local minima\n                if random.random() < 0.15:\n                    sample = sample_uniform()\n            else:\n                sample = sample_uniform()\n\n            if not in_bounds(sample) or in_obstacle(sample):\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n                continue\n\n            tree_a, tree_b = (start_tree, goal_tree) if iter_i % 2 == 0 else (goal_tree, start_tree)\n\n            nearest_node = min(tree_a, key=lambda n: math.dist(n.position, sample))\n            new_pos = steer(nearest_node.position, sample)\n            if not in_bounds(new_pos) or in_obstacle(new_pos) or edge_in_obstacle(nearest_node.position, new_pos):\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n                continue\n\n            new_node, nbrs = choose_parent(tree_a, new_pos, iter_i)\n            if new_node is None:\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n                continue\n\n            rewire(new_node, nbrs)\n            nodes.append(new_node)\n            if new_node.parent:\n                edges.append((new_node.parent, new_node))\n\n            connect_node = attempt_connect(tree_b, new_node)\n            if connect_node is not None:\n                if iter_i % 2 == 0:\n                    path_a = new_node.path_from_root()\n                    path_b = connect_node.path_from_root()\n                else:\n                    path_a = connect_node.path_from_root()\n                    path_b = new_node.path_from_root()\n\n                if path_a and path_b and path_a[-1] == path_b[-1]:\n                    candidate_path = path_a + path_b[-2::-1]\n                else:\n                    candidate_path = path_a + path_b[::-1]\n\n                total_cost = 0.0\n                for i in range(len(candidate_path) - 1):\n                    total_cost += math.dist(candidate_path[i], candidate_path[i + 1])\n\n                if total_cost + 1e-9 < best_cost:\n                    best_cost = total_cost\n                    best_path = candidate_path\n                    found_solution = True\n                    no_improve_count = 0\n                else:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n            else:\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n\n        if found_solution and len(best_path) >= 3:\n            best_path = shortcut_path(best_path)\n\n        return PlannerResult(success=found_solution, path=best_path, nodes=nodes, edges=edges)",
          "objective": -33.40298,
          "time_improvement": 51.0,
          "length_improvement": 17.0,
          "smoothness_improvement": 1547.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.017258715629577637,
                    "num_nodes_avg": 79.5,
                    "path_length_avg": 159.14625161467853,
                    "smoothness_avg": 0.03811017652697283,
                    "success_improvement": 0.0,
                    "time_improvement": 28.9338850683042,
                    "length_improvement": 12.76941765625831,
                    "smoothness_improvement": 496.5070202200339,
                    "objective_score": 18.824351215346415
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.050636911392211915,
                    "num_nodes_avg": 257.4,
                    "path_length_avg": 238.0863832383473,
                    "smoothness_avg": 0.10822479582896447,
                    "success_improvement": 0.0,
                    "time_improvement": 68.63912996740864,
                    "length_improvement": 20.51991233846954,
                    "smoothness_improvement": 2684.7019478488814,
                    "objective_score": 46.32719613254872
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.022013473510742187,
                    "num_nodes_avg": 162.2,
                    "path_length_avg": 122.72467070826906,
                    "smoothness_avg": 0.12261112972748914,
                    "success_improvement": 0.0,
                    "time_improvement": 55.54695361209407,
                    "length_improvement": 18.492117236393174,
                    "smoothness_improvement": 1459.6045199214789,
                    "objective_score": 35.05737902507152
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e2",
          "algorithm_description": "A bidirectional RRT* variant with spatial hashing for efficient neighbor search and rewiring, adaptive neighborhood radius tuned by node density and best path cost, combined adaptive-involved sampling focusing on informed ellipsoid post initial solution, and a multi-pass smoothing stage employing iterative shortcutting enhanced with curvature-aware pruning for improved path smoothness and length while maintaining robust collision checking and early stopping on stagnation. The planner grows two trees alternately and attempts connection after each extension; spatial hashing replaces costly linear neighbor queries, accelerating rewire and parent choosing. Post-planning smoothing iteratively shortcuts and removes sharp angle nodes to generate a smooth, short, feasible path. Early termination triggers after no improvement threshold, ensuring faster convergence and higher-quality results.",
          "planning_mechanism": "The algorithm samples points initially uniformly, then biased inside an ellipsoidal informed subset after first solution. It extends nodes towards samples with collision checking, selects optimal parents in a spatial-hashed neighborhood for rewiring efficiency, alternates tree growth, attempts to connect opposite trees each iteration, and updates the best path cost. Termination occurs after max iterations or consecutive stagnation. A final smoothing phase applies multiple shortcut passes combined with angle-based node pruning to optimize smoothness and path length.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self,\n                 max_iter=3500,\n                 step_size=5.0,\n                 max_radius=30.0,\n                 min_radius=7.0,\n                 max_no_improve=45,\n                 shortcut_iter=150,\n                 cell_size=15.0,\n                 curvature_threshold=0.3):  # smaller is stricter smoothing\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.max_radius = max_radius\n        self.min_radius = min_radius\n        self.max_no_improve = max_no_improve\n        self.shortcut_iter = shortcut_iter\n        self.cell_size = cell_size\n        self.curvature_threshold = curvature_threshold\n\n    def plan(self, map):\n        import math\n        import random\n\n        bounds = map.size\n        dim = len(bounds)\n        start_pos = tuple(map.start)\n        goal_pos = tuple(map.goal)\n        obstacles = map.obstacles\n        is_3d = (dim == 3)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def in_obstacle(p):\n            px, py, pz = (p + (0, 0, 0))[:3]\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def edge_in_obstacle(a, b, resolution=1.0):\n            dist_ab = math.dist(a, b)\n            if dist_ab < 1e-12:\n                return False\n            steps = max(2, int(dist_ab / resolution))\n            for i in range(steps + 1):\n                interp = tuple(a[d] + (b[d] - a[d]) * i / steps for d in range(dim))\n                if in_obstacle(interp):\n                    return True\n            return False\n\n        def steer(frm, to):\n            dist = math.dist(frm, to)\n            if dist <= self.step_size:\n                return to\n            ratio = self.step_size / dist\n            return tuple(frm[d] + (to[d] - frm[d]) * ratio for d in range(dim))\n\n        # Spatial hashing for neighbor queries to limit search to local cells\n        class SpatialHash:\n            def __init__(self, bounds, cell_size):\n                self.cell_size = cell_size\n                self.inv_cell = 1.0 / cell_size\n                self.grid = {}\n                self.bounds = bounds\n                self.dim = len(bounds)\n\n            def _hash_coords(self, p):\n                return tuple(int(p[d] * self.inv_cell) for d in range(self.dim))\n\n            def insert(self, node):\n                hc = self._hash_coords(node.position)\n                self.grid.setdefault(hc, []).append(node)\n\n            def remove(self, node):\n                hc = self._hash_coords(node.position)\n                cell = self.grid.get(hc, [])\n                if node in cell:\n                    cell.remove(node)\n                    if not cell:\n                        del self.grid[hc]\n\n            def neighbors(self, p, radius):\n                r_cells = int(math.ceil(radius * self.inv_cell))\n                hc = self._hash_coords(p)\n                candidates = []\n                for dx in range(-r_cells, r_cells + 1):\n                    for dy in range(-r_cells, r_cells + 1):\n                        for dz in ([0] if self.dim == 2 else range(-r_cells, r_cells + 1)):\n                            cell_key = None\n                            if self.dim == 2:\n                                cell_key = (hc[0] + dx, hc[1] + dy)\n                            else:\n                                cell_key = (hc[0] + dx, hc[1] + dy, hc[2] + dz)\n                            cell_nodes = self.grid.get(cell_key)\n                            if cell_nodes:\n                                candidates.extend(cell_nodes)\n                r_sq = radius * radius\n                result = []\n                for node in candidates:\n                    dsq = 0.0\n                    for d in range(self.dim):\n                        diff = node.position[d] - p[d]\n                        dsq += diff * diff\n                        if dsq > r_sq:\n                            break\n                    else:\n                        result.append(node)\n                return result\n\n        # Informed sampling improving search efficiency after first solution\n        def sample_uniform():\n            return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        def sample_informed(c_best, c_min):\n            if c_best == float('inf') or c_min < 1e-12:\n                return sample_uniform()\n            center = tuple((start_pos[d] + goal_pos[d]) * 0.5 for d in range(dim))\n            unit_dir = [(goal_pos[d] - start_pos[d]) / c_min for d in range(dim)]\n            r1 = c_best * 0.5\n            diff_sq = max(c_best*c_best - c_min*c_min, 0.0)\n            r_other = math.sqrt(diff_sq) * 0.5\n\n            if dim == 2:\n                a1 = unit_dir\n                a2 = (-a1[1], a1[0])\n                basis = (a1, a2)\n                radii = (r1, r_other)\n            else:\n                # 3D orthonormal basis\n                def cross(u,v):\n                    return (u[1]*v[2]-u[2]*v[1], u[2]*v[0]-u[0]*v[2], u[0]*v[1]-u[1]*v[0])\n                def norm(v):\n                    return math.sqrt(sum(x*x for x in v))\n                a1 = unit_dir\n                ref = (1,0,0) if abs(a1[0]) < 0.9 else (0,1,0)\n                b2 = cross(a1, ref)\n                n_b2 = norm(b2)\n                if n_b2 < 1e-12:\n                    ref = (0,0,1)\n                    b2 = cross(a1, ref)\n                    n_b2 = norm(b2)\n                b2 = tuple(x / n_b2 for x in b2)\n                b3 = cross(a1, b2)\n                basis = (a1, b2, b3)\n                radii = (r1, r_other, r_other)\n\n            def sample_unit_ball(dim):\n                while True:\n                    vec = [random.gauss(0,1) for _ in range(dim)]\n                    nrm = math.sqrt(sum(v*v for v in vec))\n                    if nrm < 1e-12:\n                        continue\n                    vec = [v / nrm for v in vec]\n                    r = random.random() ** (1/dim)\n                    return [v * r for v in vec]\n\n            u = sample_unit_ball(dim)\n            mapped = []\n            for d in range(dim):\n                val = center[d]\n                for i in range(dim):\n                    val += basis[i][d] * radii[i] * u[i]\n                val = max(0.0, min(val, bounds[d]))\n                mapped.append(val)\n            return tuple(mapped)\n\n        # Adaptive neighborhood radius balancing rewiring cost and quality\n        def adaptive_radius(num_nodes, best_cost):\n            import math\n            if num_nodes <= 1:\n                return self.max_radius\n            # base radius scales with dimension\n            base = self.max_radius * (math.log(num_nodes) / num_nodes) ** (1/dim)\n            radius = max(self.min_radius, min(base, self.max_radius))\n            if best_cost != float('inf'):\n                # shrink radius proportional to best_cost and global spread\n                radius = max(self.min_radius, min(radius, best_cost * 0.5))\n            return radius\n\n        # Select best parent from spatial-hash neighbors minimizing cost with collision-free edge\n        def choose_parent(tree_hash, tree_nodes, new_pos, radius):\n            nbrs = tree_hash.neighbors(new_pos, radius)\n            valid_parents = []\n            for n in nbrs:\n                if not edge_in_obstacle(n.position, new_pos):\n                    valid_parents.append(n)\n            if not valid_parents:\n                # fallback nearest node globally with collision-free edge\n                nearest = None\n                nearest_dist = float('inf')\n                for n in tree_nodes:\n                    d = math.dist(n.position, new_pos)\n                    if d < nearest_dist and not edge_in_obstacle(n.position, new_pos):\n                        nearest = n\n                        nearest_dist = d\n                if nearest is None:\n                    return None, []\n                cost = nearest.cost + nearest_dist\n                new_node = Node(new_pos, parent=nearest, cost=cost)\n                nearest.add_child(new_node)\n                tree_nodes.append(new_node)\n                tree_hash.insert(new_node)\n                return new_node, []\n            best_parent = min(valid_parents, key=lambda p: p.cost + math.dist(p.position, new_pos))\n            cost_min = best_parent.cost + math.dist(best_parent.position, new_pos)\n            new_node = Node(new_pos, parent=best_parent, cost=cost_min)\n            best_parent.add_child(new_node)\n            tree_nodes.append(new_node)\n            tree_hash.insert(new_node)\n            return new_node, valid_parents\n\n        # Rewire neighbors in radius if cost improves and collision-free edge\n        def rewire(pivot, neighbors_, tree_hash):\n            for nb in neighbors_:\n                if nb == pivot.parent:\n                    continue\n                dist_pivot_nb = math.dist(pivot.position, nb.position)\n                new_cost = pivot.cost + dist_pivot_nb\n                if new_cost + 1e-12 < nb.cost:\n                    if edge_in_obstacle(pivot.position, nb.position):\n                        continue\n                    if nb.parent:\n                        nb.parent.remove_child(nb)\n                    pivot.add_child(nb)\n                    nb.cost = new_cost\n\n        # Try to connect two trees by extending tree_from towards node_to_connect\n        def attempt_connect(tree_hash, tree_nodes, node_to_connect):\n            if not tree_nodes:\n                return None\n            nearest = min(tree_nodes, key=lambda n: math.dist(n.position, node_to_connect.position))\n            dist_near = math.dist(nearest.position, node_to_connect.position)\n            if dist_near <= self.step_size:\n                if edge_in_obstacle(nearest.position, node_to_connect.position) or in_obstacle(node_to_connect.position):\n                    return None\n                new_node = Node(node_to_connect.position, parent=nearest, cost=nearest.cost + dist_near)\n                nearest.add_child(new_node)\n                tree_nodes.append(new_node)\n                tree_hash.insert(new_node)\n                return new_node\n            current = nearest\n            steps = int(math.ceil(dist_near / self.step_size))\n            for _ in range(steps):\n                new_pos = steer(current.position, node_to_connect.position)\n                if not in_bounds(new_pos) or in_obstacle(new_pos) or edge_in_obstacle(current.position, new_pos):\n                    return None\n                new_node = Node(new_pos, parent=current, cost=current.cost + math.dist(current.position, new_pos))\n                current.add_child(new_node)\n                tree_nodes.append(new_node)\n                tree_hash.insert(new_node)\n                current = new_node\n                if math.dist(current.position, node_to_connect.position) <= self.step_size:\n                    if edge_in_obstacle(current.position, node_to_connect.position) or in_obstacle(node_to_connect.position):\n                        return None\n                    final_node = Node(node_to_connect.position, parent=current,\n                                      cost=current.cost + math.dist(current.position, node_to_connect.position))\n                    current.add_child(final_node)\n                    tree_nodes.append(final_node)\n                    tree_hash.insert(final_node)\n                    return final_node\n            return None\n\n        # Multi-pass shortcut attempts with randomness + angle-based node removal for smoothing\n        def smooth_path(path):\n            if len(path) < 3:\n                return path[:]\n\n            # Angular pruning helper: cosine between vectors\n            def angle_cosine(p1, p2, p3):\n                import math\n                def vec(a,b):\n                    return [b[d]-a[d] for d in range(dim)]\n                v1 = vec(p2, p1)\n                v2 = vec(p2, p3)\n                norm1 = math.sqrt(sum(x*x for x in v1))\n                norm2 = math.sqrt(sum(x*x for x in v2))\n                if norm1 < 1e-12 or norm2 < 1e-12:\n                    return 1.0  # treat as straight\n                dot = sum(v1[d]*v2[d] for d in range(dim))\n                return dot / (norm1 * norm2)\n\n            path = list(path)\n            for _ in range(self.shortcut_iter):\n                if len(path) < 3:\n                    break\n                # Random shortcut attempt\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if not edge_in_obstacle(path[i], path[j]):\n                    path = path[:i+1] + path[j:]\n\n            # Angle-based pruning to remove sharp kinks\n            improved = True\n            while improved and len(path) >= 3:\n                improved = False\n                for i in range(1, len(path)-1):\n                    cos_phi = angle_cosine(path[i-1], path[i], path[i+1])\n                    if cos_phi > self.curvature_threshold:  # close to 1 means nearly straight\n                        candidate = path[:i] + path[i+1:]\n                        # Verify if shortcut edge is collision-free\n                        if not edge_in_obstacle(path[i-1], path[i+1]):\n                            path = candidate\n                            improved = True\n                            break\n            return path\n\n        # Initialize trees, spatial hashes and nodes list\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n        start_hash = SpatialHash(bounds, self.cell_size)\n        goal_hash = SpatialHash(bounds, self.cell_size)\n        start_hash.insert(start_root)\n        goal_hash.insert(goal_root)\n        nodes = [start_root, goal_root]\n        edges = []\n\n        best_path = []\n        best_cost = float('inf')\n        c_min = math.dist(start_pos, goal_pos)\n        found_solution = False\n        no_improve_count = 0\n\n        for iter_i in range(self.max_iter):\n            # Sample point: informed sampling biased inside ellipsoid after initial solution\n            if found_solution:\n                sample = sample_informed(best_cost, c_min)\n                if random.random() < 0.12:\n                    sample = sample_uniform()\n            else:\n                sample = sample_uniform()\n\n            if not in_bounds(sample) or in_obstacle(sample):\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n                continue\n\n            # Alternate tree expansion\n            if iter_i % 2 == 0:\n                tree_nodes, tree_hash = start_tree, start_hash\n                other_nodes, other_hash = goal_tree, goal_hash\n            else:\n                tree_nodes, tree_hash = goal_tree, goal_hash\n                other_nodes, other_hash = start_tree, start_hash\n\n            nearest = min(tree_nodes, key=lambda n: math.dist(n.position, sample))\n            new_pos = steer(nearest.position, sample)\n            if (not in_bounds(new_pos) or in_obstacle(new_pos) or\n                edge_in_obstacle(nearest.position, new_pos)):\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n                continue\n\n            radius = adaptive_radius(len(nodes), best_cost)\n            new_node, neighbors_ = choose_parent(tree_hash, tree_nodes, new_pos, radius)\n            if new_node is None:\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n                continue\n\n            rewire(new_node, neighbors_, tree_hash)\n            nodes.append(new_node)\n            if new_node.parent:\n                edges.append((new_node.parent, new_node))\n\n            connect_node = attempt_connect(other_hash, other_nodes, new_node)\n            if connect_node is not None:\n                if iter_i % 2 == 0:\n                    path_from = new_node.path_from_root()\n                    path_to = connect_node.path_from_root()\n                else:\n                    path_from = connect_node.path_from_root()\n                    path_to = new_node.path_from_root()\n\n                if path_from and path_to and path_from[-1] == path_to[-1]:\n                    candidate_path = path_from + path_to[-2::-1]\n                else:\n                    candidate_path = path_from + path_to[::-1]\n\n                total_cost = 0.0\n                for i in range(len(candidate_path)-1):\n                    total_cost += math.dist(candidate_path[i], candidate_path[i+1])\n\n                if total_cost + 1e-9 < best_cost:\n                    best_cost = total_cost\n                    best_path = candidate_path\n                    found_solution = True\n                    no_improve_count = 0\n                else:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n            else:\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n\n        if found_solution and len(best_path) >= 3:\n            best_path = smooth_path(best_path)\n\n        return PlannerResult(success=found_solution, path=best_path, nodes=nodes, edges=edges)",
          "objective": -32.9029,
          "time_improvement": 49.0,
          "length_improvement": 17.0,
          "smoothness_improvement": 1609.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.01923995018005371,
                    "num_nodes_avg": 92.2,
                    "path_length_avg": 157.3363578129988,
                    "smoothness_avg": 0.044642828864860054,
                    "success_improvement": 0.0,
                    "time_improvement": 20.77576685761409,
                    "length_improvement": 13.761449128561546,
                    "smoothness_improvement": 598.7572151895736,
                    "objective_score": 17.483385610369023
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.02807478904724121,
                    "num_nodes_avg": 247.3,
                    "path_length_avg": 236.40540078810062,
                    "smoothness_avg": 0.1090320795024787,
                    "success_improvement": 0.0,
                    "time_improvement": 82.61248985580178,
                    "length_improvement": 21.081072664758967,
                    "smoothness_improvement": 2705.4739382313296,
                    "objective_score": 50.959760246752566
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.02779085636138916,
                    "num_nodes_avg": 285.3,
                    "path_length_avg": 126.75283500904695,
                    "smoothness_avg": 0.1275381291737158,
                    "success_improvement": 0.0,
                    "time_improvement": 43.88035916323632,
                    "length_improvement": 15.81680230838801,
                    "smoothness_improvement": 1522.2755892042126,
                    "objective_score": 30.265567080024766
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "An improved bidirectional RRT* variant with simplified adaptive neighborhood radius, consistent incremental rewiring, and combined informed plus uniform sampling for balanced exploration. The planner applies strict collision checks on nodes and edges, optimizes parent selection to minimize path cost, and attempts connection between trees after each insertion. It leverages a unified rewiring radius calculation based on node density and iteration progress, integrates early stopping on improvement stagnation, and performs lightweight post-processing shortcutting to improve path quality and smoothness, achieving efficient planning, shorter path length, and smoother results while maintaining robustness and simplicity.",
          "planning_mechanism": "The planner grows two trees from start and goal positions in alternating iterations, sampling points biased towards an ellipsoidal informed subset once a solution is found to focus search. Nodes are added by steering towards samples within step size, selecting parents from neighbors that reduce path cost and maintain collision-free edges. Rewiring is done on neighbors with a unified adaptive radius that shrinks according to node count and iteration to refine local connectivity. After each added node, the planner attempts to connect the two trees to find feasible paths that are combined to update the best solution. Early stopping terminates planning after a number of iterations without improvement. A final random shortcutting pass reduces unnecessary detours for improved smoothness.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self,\n                 max_iter=4000,\n                 step_size=5.0,\n                 max_radius=25.0,\n                 min_radius=5.0,\n                 max_no_improve=60,\n                 shortcut_iter=120):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.max_radius = max_radius\n        self.min_radius = min_radius\n        self.max_no_improve = max_no_improve\n        self.shortcut_iter = shortcut_iter\n\n    def plan(self, map):\n        import math\n        import random\n        import time\n\n        bounds = map.size\n        dim = len(bounds)\n        start_pos = tuple(map.start)\n        goal_pos = tuple(map.goal)\n        obstacles = map.obstacles\n        is_3d = (dim == 3)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def in_obstacle(p):\n            px, py, pz = (p + (0, 0, 0))[:3]\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def edge_in_obstacle(a, b, res=1.0):\n            dist_ab = math.dist(a, b)\n            if dist_ab < 1e-12:\n                return False\n            steps = max(2, int(dist_ab / res))\n            for i in range(steps + 1):\n                interp = tuple(a[d] + (b[d] - a[d]) * i / steps for d in range(dim))\n                if in_obstacle(interp):\n                    return True\n            return False\n\n        def steer(frm, to):\n            dist_frm_to = math.dist(frm, to)\n            if dist_frm_to <= self.step_size:\n                return to\n            ratio = self.step_size / dist_frm_to\n            return tuple(frm[d] + (to[d] - frm[d]) * ratio for d in range(dim))\n\n        def adaptive_radius(node_count, iteration):\n            # Unified radius shrinking with node count and iteration progress\n            if node_count <= 1:\n                return self.max_radius\n            import math\n            gamma = self.max_radius\n            r = gamma * (math.log(node_count) / node_count) ** (1 / dim)\n            decay = max(self.min_radius / gamma, 1.0 - 0.95 * (iteration / self.max_iter))\n            return max(self.min_radius, min(r * decay, self.max_radius))\n\n        def neighbors(tree, point, radius):\n            radius_sq = radius * radius\n            res = []\n            px = point\n            for node in tree:\n                d_sq = 0.0\n                for i_ in range(dim):\n                    diff = node.position[i_] - px[i_]\n                    d_sq += diff * diff\n                    if d_sq > radius_sq:\n                        break\n                else:\n                    res.append(node)\n            return res\n\n        def choose_parent(tree, new_pos, iter_i):\n            n_nodes = len(tree)\n            r = adaptive_radius(n_nodes, iter_i)\n            nbrs = neighbors(tree, new_pos, r)\n            # filter valid parents with collision-free edge\n            valid_parents = []\n            for n in nbrs:\n                if edge_in_obstacle(n.position, new_pos):\n                    continue\n                valid_parents.append(n)\n            if not valid_parents:\n                # fallback: find nearest node with collision-free edge\n                nearest = None\n                nearest_dist = float('inf')\n                for n in tree:\n                    d = math.dist(n.position, new_pos)\n                    if d < nearest_dist and not edge_in_obstacle(n.position, new_pos):\n                        nearest = n\n                        nearest_dist = d\n                if nearest is None:\n                    return None, []\n                best_parent = nearest\n                cost = best_parent.cost + nearest_dist\n                new_node = Node(new_pos, parent=best_parent, cost=cost)\n                best_parent.add_child(new_node)\n                tree.append(new_node)\n                return new_node, []\n            # select parent minimizing cost\n            best_parent = None\n            min_cost = float('inf')\n            for p in valid_parents:\n                c = p.cost + math.dist(p.position, new_pos)\n                if c < min_cost:\n                    min_cost = c\n                    best_parent = p\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree.append(new_node)\n            return new_node, valid_parents\n\n        def rewire(pivot, nbrs):\n            for nb in nbrs:\n                if nb == pivot.parent:\n                    continue\n                dist_pivot_nb = math.dist(pivot.position, nb.position)\n                new_cost = pivot.cost + dist_pivot_nb\n                if new_cost + 1e-12 < nb.cost:\n                    if edge_in_obstacle(pivot.position, nb.position):\n                        continue\n                    # Rewire parent-child\n                    if nb.parent is not None:\n                        nb.parent.remove_child(nb)\n                    pivot.add_child(nb)\n                    nb.cost = new_cost\n\n        def attempt_connect(tree_from, node_to_connect):\n            if not tree_from:\n                return None\n            nearest = min(tree_from, key=lambda n: math.dist(n.position, node_to_connect.position))\n            dist_near = math.dist(nearest.position, node_to_connect.position)\n            if dist_near <= self.step_size:\n                if edge_in_obstacle(nearest.position, node_to_connect.position) or in_obstacle(node_to_connect.position):\n                    return None\n                new_node = Node(node_to_connect.position, parent=nearest, cost=nearest.cost + dist_near)\n                nearest.add_child(new_node)\n                tree_from.append(new_node)\n                return new_node\n            # incremental steering towards target\n            current = nearest\n            steps = int(math.ceil(dist_near / self.step_size))\n            for _ in range(steps):\n                new_pos = steer(current.position, node_to_connect.position)\n                if not in_bounds(new_pos) or in_obstacle(new_pos) or edge_in_obstacle(current.position, new_pos):\n                    return None\n                new_node = Node(new_pos, parent=current, cost=current.cost + math.dist(current.position, new_pos))\n                current.add_child(new_node)\n                tree_from.append(new_node)\n                current = new_node\n                if math.dist(current.position, node_to_connect.position) <= self.step_size:\n                    if edge_in_obstacle(current.position, node_to_connect.position) or in_obstacle(node_to_connect.position):\n                        return None\n                    final_node = Node(node_to_connect.position, parent=current,\n                                      cost=current.cost + math.dist(current.position, node_to_connect.position))\n                    current.add_child(final_node)\n                    tree_from.append(final_node)\n                    return final_node\n            return None\n\n        def sample_uniform():\n            return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        def sample_informed(c_best, c_min):\n            if c_best == float('inf') or c_min < 1e-12:\n                return sample_uniform()\n            center = tuple((start_pos[d] + goal_pos[d]) / 2 for d in range(dim))\n            unit_dir = []\n            for d in range(dim):\n                unit_dir.append((goal_pos[d] - start_pos[d]) / c_min)\n            r1 = c_best * 0.5\n            val = max(c_best * c_best - c_min * c_min, 0.0)\n            r_other = math.sqrt(val) * 0.5\n\n            if dim == 2:\n                a1 = unit_dir\n                a2 = (-a1[1], a1[0])\n                basis = (a1, a2)\n                radii = (r1, r_other)\n            else:\n                def cross(u, v):\n                    return (u[1] * v[2] - u[2] * v[1], u[2] * v[0] - u[0] * v[2], u[0] * v[1] - u[1] * v[0])\n\n                def norm(v):\n                    return math.sqrt(sum(x * x for x in v))\n\n                a1 = unit_dir\n                ref = (1, 0, 0) if abs(a1[0]) < 0.9 else (0, 1, 0)\n                b2 = cross(a1, ref)\n                n_b2 = norm(b2)\n                if n_b2 < 1e-12:\n                    ref = (0, 0, 1)\n                    b2 = cross(a1, ref)\n                    n_b2 = norm(b2)\n                b2 = tuple(x / n_b2 for x in b2)\n                b3 = cross(a1, b2)\n                basis = (a1, b2, b3)\n                radii = (r1, r_other, r_other)\n\n            def sample_unit_ball(dim):\n                while True:\n                    vec = [random.gauss(0, 1) for _ in range(dim)]\n                    nrm = math.sqrt(sum(v * v for v in vec))\n                    if nrm < 1e-12:\n                        continue\n                    vec = [v / nrm for v in vec]\n                    r = random.random() ** (1 / dim)\n                    return [v * r for v in vec]\n\n            u = sample_unit_ball(dim)\n            mapped = []\n            for d in range(dim):\n                val = center[d]\n                for i in range(dim):\n                    val += basis[i][d] * radii[i] * u[i]\n                val = max(0.0, min(val, bounds[d]))\n                mapped.append(val)\n            return tuple(mapped)\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path[:]\n            path = list(path)\n            for _ in range(self.shortcut_iter):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if not edge_in_obstacle(path[i], path[j]):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        best_path = []\n        best_cost = float('inf')\n        c_min = math.dist(start_pos, goal_pos)\n        found_solution = False\n        no_improve_count = 0\n\n        start_time = time.time()\n\n        for iter_i in range(self.max_iter):\n            if found_solution:\n                sample = sample_informed(best_cost, c_min)\n                # Occasionally sample uniform to avoid local minima\n                if random.random() < 0.15:\n                    sample = sample_uniform()\n            else:\n                sample = sample_uniform()\n\n            if not in_bounds(sample) or in_obstacle(sample):\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n                continue\n\n            tree_a, tree_b = (start_tree, goal_tree) if iter_i % 2 == 0 else (goal_tree, start_tree)\n\n            nearest_n = min(tree_a, key=lambda n: math.dist(n.position, sample))\n            new_pos = steer(nearest_n.position, sample)\n            if not in_bounds(new_pos) or in_obstacle(new_pos) or edge_in_obstacle(nearest_n.position, new_pos):\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n                continue\n\n            new_node, nbrs = choose_parent(tree_a, new_pos, iter_i)\n            if new_node is None:\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n                continue\n\n            rewire(new_node, nbrs)\n            nodes.append(new_node)\n            if new_node.parent:\n                edges.append((new_node.parent, new_node))\n\n            connect_node = attempt_connect(tree_b, new_node)\n            if connect_node is not None:\n                if iter_i % 2 == 0:\n                    path_a = new_node.path_from_root()\n                    path_b = connect_node.path_from_root()\n                else:\n                    path_a = connect_node.path_from_root()\n                    path_b = new_node.path_from_root()\n                if path_a and path_b and path_a[-1] == path_b[-1]:\n                    candidate_path = path_a + path_b[-2::-1]\n                else:\n                    candidate_path = path_a + path_b[::-1]\n\n                total_cost = 0.0\n                for i in range(len(candidate_path) - 1):\n                    total_cost += math.dist(candidate_path[i], candidate_path[i + 1])\n\n                if total_cost + 1e-9 < best_cost:\n                    best_cost = total_cost\n                    best_path = candidate_path\n                    found_solution = True\n                    no_improve_count = 0\n                else:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n            else:\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n\n        if found_solution and len(best_path) >= 3:\n            best_path = shortcut_path(best_path)\n\n        return PlannerResult(success=found_solution, path=best_path, nodes=nodes, edges=edges)",
          "objective": -32.09066,
          "time_improvement": 51.0,
          "length_improvement": 17.0,
          "smoothness_improvement": 1354.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.017293906211853026,
                    "num_nodes_avg": 91.5,
                    "path_length_avg": 161.730924310866,
                    "smoothness_avg": 0.042930783900201136,
                    "success_improvement": 0.0,
                    "time_improvement": 28.788981008339842,
                    "length_improvement": 11.352717594718152,
                    "smoothness_improvement": 571.9599937275159,
                    "objective_score": 18.308124827970424
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.03642895221710205,
                    "num_nodes_avg": 225.4,
                    "path_length_avg": 238.2939143004422,
                    "smoothness_avg": 0.0897730230727014,
                    "success_improvement": 0.0,
                    "time_improvement": 77.4385205476863,
                    "length_improvement": 20.450632496491846,
                    "smoothness_improvement": 2209.924544555513,
                    "objective_score": 46.551558384978556
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.02602849006652832,
                    "num_nodes_avg": 208.0,
                    "path_length_avg": 123.50286586657371,
                    "smoothness_avg": 0.10841836272819716,
                    "success_improvement": 0.0,
                    "time_improvement": 47.439204641197854,
                    "length_improvement": 17.97527706591856,
                    "smoothness_improvement": 1279.073571291572,
                    "objective_score": 31.41229548836835
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "time_expert",
          "algorithm_description": "A bidirectional RRT* planner with adaptive multi-radius rewiring emphasizing cost-based connections for shorter paths, enhanced sampling bias combining ellipsoidal informed and goal-directed Gaussian samples for faster convergence. It employs efficient approximate nearest neighbor search, dynamic step size control to refine exploration precision, and accelerated early stopping criteria to reduce planning time. Path smoothness is indirectly improved by prioritizing cost-optimal parent selection without explicit curvature penalties, enabling more flexible rewiring and shorter, smoother paths.",
          "planning_mechanism": "A bidirectional RRT* grows two trees alternating expansions from start and goal. Sampling blends ellipsoidal informed and goal-biased Gaussian perturbations to prioritize promising regions. Nearest neighbor and near-node queries use approximate but efficient search. Adaptive multi-radius rewiring updates parent-child relations based solely on cost, allowing more aggressive shortcuts and path shortening. A dynamic step size decreases as nodes increase, refining path precision. Early stopping triggers upon stagnated cost improvements. After a solution is found, shortcutting with collision checks refines the path length and smoothness, balancing planning time and path quality.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position  # tuple of floats\n        self.parent = parent      # Node or None\n        self.cost = cost          # cost from root\n        self.children = []       # list of Node\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def path_from_root(self):\n        node = self\n        path = []\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=2500, max_no_improve=40, improve_tol=1e-6,\n                 init_step=7.0, min_step=0.8, n_near_const=15, shortcut_iters=150):\n        self.max_iter = max_iter\n        self.max_no_improve = max_no_improve\n        self.improve_tol = improve_tol\n        self.init_step = init_step\n        self.min_step = min_step\n        self.n_near_const = n_near_const\n        self.shortcut_iters = shortcut_iters\n\n    def plan(self, map) -> 'PlannerResult':\n        import time, random, math\n\n        start_p = tuple(map.start)\n        goal_p = tuple(map.goal)\n        bounds = tuple(map.size)\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def dist(a, b):\n            s = 0.0\n            for i in range(dim):\n                d = a[i] - b[i]\n                s += d * d\n            return math.sqrt(s)\n\n        def in_obstacle(p):\n            px, py, pz = (p + (0, 0, 0))[:3]\n            for obs in obstacles:\n                if is_3d:\n                    ox, oy, oz, ow, oh, od = obs\n                    if ox <= px <= ox + ow and oy <= py <= oy + oh and oz <= pz <= oz + od:\n                        return True\n                else:\n                    ox, oy, ow, oh = obs\n                    if ox <= px <= ox + ow and oy <= py <= oy + oh:\n                        return True\n            return False\n\n        def edge_obstacle(f, t, resolution=1.0):\n            length = dist(f, t)\n            if length < 1e-12:\n                return False\n            steps = max(5, int(length / resolution))\n            for i in range(steps + 1):\n                inter = tuple(f[d] + (t[d] - f[d]) * i / steps for d in range(dim))\n                if in_obstacle(inter):\n                    return True\n            return False\n\n        def steer(frm, to, step_size):\n            d = dist(frm, to)\n            if d <= step_size:\n                return to\n            ratio = step_size / d\n            return tuple(frm[i] + (to[i] - frm[i]) * ratio for i in range(dim))\n\n        # Approximate nearest neighbor: linear with early reject for efficiency\n        def nearest(tree, point):\n            best = None\n            best_d2 = float('inf')\n            px = point\n            for n in tree:\n                d2 = 0.0\n                for i_ in range(dim):\n                    delta = n.position[i_] - px[i_]\n                    d2 += delta * delta\n                    if d2 >= best_d2:\n                        break\n                else:\n                    if d2 < best_d2:\n                        best = n\n                        best_d2 = d2\n            return best, math.sqrt(best_d2) if best is not None else None\n\n        def near_nodes(tree, point, radius):\n            rq = radius * radius\n            px = point\n            near_list = []\n            for n in tree:\n                d2 = 0.0\n                for i_ in range(dim):\n                    delta = n.position[i_] - px[i_]\n                    d2 += delta * delta\n                    if d2 > rq:\n                        break\n                if d2 <= rq:\n                    near_list.append(n)\n            return near_list\n\n        def adaptive_radius(n_nodes, c_best):\n            if n_nodes <= 1:\n                return self.init_step * 3.3\n            base = (self.n_near_const * (math.log(n_nodes) / n_nodes)) ** (1 / dim)\n            base = min(base, self.init_step * 5.8)\n            if c_best == float('inf'):\n                return base\n            shrink_factor = max(0.3, c_best / (c_min * 3.2))\n            return max(self.min_step * 0.8, base * shrink_factor)\n\n        # Sampling biased by ellipsoid informed + gaussian near goal for faster convergence\n        def sample(c_best):\n            if c_best == float('inf'):\n                # random uniform in bounds\n                return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n            # Informed ellipsoid sampling\n            center = tuple(0.5 * (start_p[i] + goal_p[i]) for i in range(dim))\n            diff = [goal_p[i] - start_p[i] for i in range(dim)]\n            dist_sg = dist(start_p, goal_p)\n            if dist_sg < 1e-14:\n                return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n            unit_vec = [d / dist_sg for d in diff]\n            # Build orthonormal basis (Gram-Schmidt)\n            U = [unit_vec]\n            for idx in range(dim - 1):\n                v = [0.0] * dim\n                v[(idx + 1) % dim] = 1.0\n                for u in U:\n                    proj = sum(v[j] * u[j] for j in range(dim))\n                    for j in range(dim):\n                        v[j] -= proj * u[j]\n                norm_v = math.sqrt(sum(x * x for x in v))\n                if norm_v > 1e-14:\n                    U.append([x / norm_v for x in v])\n                else:\n                    U.append([0.0] * dim)\n            r1 = c_best * 0.5\n            val = c_best * c_best - c_min * c_min\n            r2 = math.sqrt(val) * 0.5 if val > 0 else 0.0\n            radii = [r1] + [r2] * (dim - 1)\n\n            for _ in range(50):\n                # Random point inside unit ball\n                x_ball = [random.gauss(0, 1) for _ in range(dim)]\n                norm_x = math.sqrt(sum(x * x for x in x_ball))\n                if norm_x < 1e-14:\n                    continue\n                x_unit = [x / norm_x for x in x_ball]\n                r = random.random() ** (1 / dim)\n                point_ball = [r * x_unit[i] for i in range(dim)]\n                point_ellipsoid = [radii[i] * point_ball[i] for i in range(dim)]\n                sample_point = [center[j] for j in range(dim)]\n                for i_ in range(dim):\n                    for j_ in range(dim):\n                        sample_point[j_] += U[i_][j_] * point_ellipsoid[i_]\n                candidate = tuple(sample_point)\n                if all(0.0 <= candidate[i] <= bounds[i] for i in range(dim)) and not in_obstacle(candidate):\n                    # 20% chance to bias samples near goal using gaussian for faster connection\n                    if random.random() < 0.2:\n                        gauss_sample = []\n                        for d_i, bound_i in enumerate(bounds):\n                            gs = random.gauss(goal_p[d_i], min(bound_i * 0.05, 1.0))\n                            gauss_sample.append(min(max(0.0, gs), bound_i))\n                        gs_tuple = tuple(gauss_sample)\n                        if not in_obstacle(gs_tuple):\n                            return gs_tuple\n                    return candidate\n            # fallback uniform random\n            return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n\n        def get_path(node):\n            return node.path_from_root()\n\n        def connect_path(n1, n2):\n            p1 = get_path(n1)\n            p2 = get_path(n2)[::-1]\n            if p1 and p2 and p1[-1] == p2[0]:\n                return p1 + p2[1:]\n            return p1 + p2\n\n        # Add node with cost-only rewiring (no curvature penalty) to favor shorter paths\n        def add_node(tree, new_sample, all_nodes, edges, c_best, step_size):\n            nn, d_nn = nearest(tree, new_sample)\n            if nn is None:\n                return None\n            new_pos = steer(nn.position, new_sample, step_size)\n            if in_obstacle(new_pos) or edge_obstacle(nn.position, new_pos):\n                return None\n\n            n_nodes = len(all_nodes)\n            radius = adaptive_radius(n_nodes, c_best)\n            near = near_nodes(tree, new_pos, radius)\n\n            best_parent = nn\n            best_cost = nn.cost + dist(nn.position, new_pos)\n\n            for cand in near:\n                if cand == nn:\n                    continue\n                if edge_obstacle(cand.position, new_pos):\n                    continue\n                cost_candidate = cand.cost + dist(cand.position, new_pos)\n                if cost_candidate + self.improve_tol < best_cost:\n                    best_cost = cost_candidate\n                    best_parent = cand\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = best_cost\n            tree.append(new_node)\n            all_nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors if cost improves\n            near_r = near_nodes(tree, new_node.position, radius)\n            for near_n in near_r:\n                if near_n == best_parent or near_n == new_node:\n                    continue\n                if edge_obstacle(new_node.position, near_n.position):\n                    continue\n                alt_cost = new_node.cost + dist(new_node.position, near_n.position)\n                if alt_cost + self.improve_tol < near_n.cost:\n                    # Rewire\n                    if near_n.parent:\n                        near_n.parent.remove_child(near_n)\n                        try:\n                            edges.remove((near_n.parent, near_n))\n                        except Exception:\n                            pass\n                    new_node.add_child(near_n)\n                    near_n.cost = alt_cost\n                    edges.append((new_node, near_n))\n            return new_node\n\n        # Shortcutting without explicit curvature penalty but verify collision\n        def shortcut_path(path):\n            path = list(path)\n            if len(path) < 3:\n                return path\n            changed = True\n            iter_count = 0\n            while changed and iter_count < self.shortcut_iters:\n                iter_count += 1\n                changed = False\n                i = 0\n                while i < len(path) - 2:\n                    max_j = min(len(path) - 1, i + 6)\n                    if max_j <= i + 1:\n                        i += 1\n                        continue\n                    j = random.randint(i + 2, max_j)\n                    if not edge_obstacle(path[i], path[j]):\n                        # shortcut allowed\n                        del path[i + 1:j]\n                        changed = True\n                        break\n                    i += 1\n            return path\n\n        # Initialization\n        start_tree = [Node(start_p)]\n        goal_tree = [Node(goal_p)]\n        all_nodes = start_tree + goal_tree\n        edges = []\n        c_min = dist(start_p, goal_p)\n        best_cost = float('inf')\n        best_path = []\n        found_solution = False\n        no_improve_count = 0\n        last_best_cost = float('inf')\n        start_time = time.time()\n        step_size = self.init_step\n\n        for iter_num in range(self.max_iter):\n            sample_pt = sample(best_cost)\n\n            # Alternate expanding trees\n            if iter_num % 2 == 0:\n                tree_a, tree_b = start_tree, goal_tree\n            else:\n                tree_a, tree_b = goal_tree, start_tree\n\n            # Gradually reduce step size to refine paths as more nodes added\n            num_nodes = len(all_nodes)\n            step_size = max(self.min_step, self.init_step * (1 - num_nodes / (self.max_iter * 1.1)))\n\n            new_node = add_node(tree_a, sample_pt, all_nodes, edges, best_cost, step_size)\n            if new_node is None:\n                if found_solution:\n                    no_improve_count += 1\n                continue\n\n            nbr, d_nbr = nearest(tree_b, new_node.position)\n            if nbr is not None and d_nbr <= step_size and not edge_obstacle(new_node.position, nbr.position):\n                candidate_path = connect_path(new_node, nbr)\n                candidate_cost = new_node.cost + dist(new_node.position, nbr.position) + nbr.cost\n                if candidate_cost + self.improve_tol < best_cost:\n                    best_cost = candidate_cost\n                    best_path = candidate_path\n                    found_solution = True\n                    no_improve_count = 0\n                else:\n                    no_improve_count += 1\n            elif found_solution:\n                no_improve_count += 1\n\n            if found_solution:\n                if best_cost + self.improve_tol < last_best_cost:\n                    last_best_cost = best_cost\n                    no_improve_count = 0\n                elif no_improve_count >= self.max_no_improve:\n                    break\n\n        if found_solution and len(best_path) > 2:\n            # Post-processing shortcutting reduces path length, indirect smoothness gain\n            for _ in range(3):\n                best_path = shortcut_path(best_path)\n\n        if found_solution:\n            return PlannerResult(True, best_path, all_nodes, edges)\n        else:\n            return PlannerResult(False, [], all_nodes, edges)",
          "objective": -31.91279,
          "time_improvement": 53.0,
          "length_improvement": 14.0,
          "smoothness_improvement": 1510.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.012701964378356934,
                    "num_nodes_avg": 93.4,
                    "path_length_avg": 167.30235687670796,
                    "smoothness_avg": 0.0425654522641374,
                    "success_improvement": 0.0,
                    "time_improvement": 47.69719371100672,
                    "length_improvement": 8.298927120381544,
                    "smoothness_improvement": 566.241760292773,
                    "objective_score": 22.119723186994808
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.022562861442565918,
                    "num_nodes_avg": 215.5,
                    "path_length_avg": 240.54349758360195,
                    "smoothness_avg": 0.10420826484630626,
                    "success_improvement": 0.0,
                    "time_improvement": 86.02618236758204,
                    "length_improvement": 19.699656845908514,
                    "smoothness_improvement": 2581.353712674754,
                    "objective_score": 50.53441738119349
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.03733506202697754,
                    "num_nodes_avg": 254.8,
                    "path_length_avg": 128.49722609113547,
                    "smoothness_avg": 0.11646484458584172,
                    "success_improvement": 0.0,
                    "time_improvement": 24.60720733732938,
                    "length_improvement": 14.658260810641927,
                    "smoothness_improvement": 1381.4242265913015,
                    "objective_score": 23.08423982054048
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "A bidirectional informed RRT* planner with efficient spatial hashing for neighbor search, consistent adaptive neighbor radius scaling, iterative parent selection and rewiring to improve path cost, combined with informed sampling after initial path found and multi-pass shortcutting for path smoothness. Early stopping criterion prevents unnecessary computation after stagnation. The planner grows trees from start and goal alternately, attempts direct connections to merge both trees, dynamically updates best path, and refines it iteratively before returning the final smooth and short path.",
          "planning_mechanism": "The planner alternates extending trees from start and goal inputs by sampling points inside map bounds or informed ellipsoid based on best path cost. It selects the lowest cost parent within an adaptive radius, rewires neighbors to reduce path cost locally, and tries direct connections between trees. After a solution is found, sampling focuses in the ellipsoid bounding potential shorter paths. A multi-pass shortcutting procedure removes unnecessary waypoints to reduce path length and improve smoothness. Planning stops early if no path improvement occurs after a fixed number of iterations.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=4000, step_size=6.0, min_radius=5.0, max_radius=30.0,\n                 max_no_improve=50, time_limit=25.0,\n                 shortcut_passes=3, shortcut_iter_per_pass=60):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_radius = min_radius\n        self.max_radius = max_radius\n        self.max_no_improve = max_no_improve\n        self.time_limit = time_limit\n        self.shortcut_passes = shortcut_passes\n        self.shortcut_iter_per_pass = shortcut_iter_per_pass\n\n    def plan(self, map):\n        import math\n        import random\n        import time\n\n        start = tuple(map.start)\n        goal = tuple(map.goal)\n        bounds = tuple(map.size)\n        obstacles = map.obstacles\n        dim = len(bounds)\n        dist = math.dist\n\n        def in_bounds(p):\n            return all(0.0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def in_obstacle(p):\n            if dim == 3:\n                px, py, pz = p\n                for ox, oy, oz, ow, oh, od in obstacles:\n                    if ox <= px <= ox+ow and oy <= py <= oy+oh and oz <= pz <= oz+od:\n                        return True\n            else:\n                px, py = p\n                for ox, oy, ow, oh in obstacles:\n                    if ox <= px <= ox+ow and oy <= py <= oy+oh:\n                        return True\n            return False\n\n        def edge_in_obstacle(a, b, res=1.0):\n            length = dist(a, b)\n            if length < 1e-12:\n                return False\n            steps = max(5, int(length / res))\n            for i in range(steps + 1):\n                interp = tuple(a[d] + (b[d] - a[d]) * i / steps for d in range(dim))\n                if in_obstacle(interp):\n                    return True\n            return False\n\n        def steer(frm, to):\n            d = dist(frm, to)\n            if d <= self.step_size:\n                return to\n            ratio = self.step_size / d\n            return tuple(frm[d_] + (to[d_] - frm[d_]) * ratio for d_ in range(dim))\n\n        class SpatialHash:\n            def __init__(self, size, cell_size, dim):\n                self.size = size\n                self.cell_size = cell_size\n                self.dim = dim\n                self.cells = {}\n\n            def _hash_point(self, p):\n                return tuple(int(p[d] // self.cell_size) for d in range(self.dim))\n\n            def insert(self, node):\n                h = self._hash_point(node.position)\n                if h not in self.cells:\n                    self.cells[h] = []\n                self.cells[h].append(node)\n\n            def neighbors(self, point, radius):\n                low = [int((point[d]-radius)//self.cell_size) for d in range(self.dim)]\n                high = [int((point[d]+radius)//self.cell_size) for d in range(self.dim)]\n                candidates = []\n                def dfs(idx=0, cur=[]):\n                    if idx == self.dim:\n                        ckey = tuple(cur)\n                        if ckey in self.cells:\n                            candidates.extend(self.cells[ckey])\n                        return\n                    for v in range(low[idx], high[idx]+1):\n                        cur.append(v)\n                        dfs(idx+1, cur)\n                        cur.pop()\n                dfs()\n                r_sq = radius*radius\n                return [n for n in candidates if sum((n.position[d]-point[d])**2 for d in range(self.dim)) <= r_sq]\n\n        def adaptive_radius(n_nodes, it):\n            if n_nodes <= 1:\n                return self.max_radius\n            base = self.max_radius * (math.log(n_nodes) / n_nodes) ** (1.0 / dim)\n            decay = max(self.min_radius / self.max_radius, 1.0 - 0.9 * it / self.max_iter)\n            return max(self.min_radius, min(base * decay, self.max_radius))\n\n        def choose_parent(tree_nodes, grid, pos, it):\n            radius = adaptive_radius(len(tree_nodes), it)\n            neighbors = grid.neighbors(pos, radius)\n            min_cost = float('inf')\n            best_parent = None\n            for n in neighbors:\n                if edge_in_obstacle(n.position, pos):\n                    continue\n                c = n.cost + dist(n.position, pos)\n                if c < min_cost:\n                    min_cost = c\n                    best_parent = n\n            if best_parent is None:\n                nearest = min(tree_nodes, key=lambda n: dist(n.position, pos))\n                if edge_in_obstacle(nearest.position, pos):\n                    return None, []\n                best_parent = nearest\n                min_cost = best_parent.cost + dist(best_parent.position, pos)\n            new_node = Node(pos, best_parent, min_cost)\n            best_parent.add_child(new_node)\n            tree_nodes.append(new_node)\n            grid.insert(new_node)\n            return new_node, neighbors\n\n        def rewire(node, neighbors):\n            for n in neighbors:\n                if n is node.parent:\n                    continue\n                new_cost = node.cost + dist(node.position, n.position)\n                if new_cost + 1e-12 < n.cost and not edge_in_obstacle(node.position, n.position):\n                    if n.parent:\n                        n.parent.remove_child(n)\n                    node.add_child(n)\n                    n.cost = new_cost\n\n        def direct_connect(tree, grid, target):\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda n: dist(n.position, target.position))\n            d_to_goal = dist(nearest.position, target.position)\n            if d_to_goal <= self.step_size:\n                if in_obstacle(target.position) or edge_in_obstacle(nearest.position, target.position):\n                    return None\n                new_node = Node(target.position, nearest, nearest.cost + d_to_goal)\n                nearest.add_child(new_node)\n                tree.append(new_node)\n                grid.insert(new_node)\n                return new_node\n            # steer incrementally toward goal\n            current = nearest\n            steps = int(math.ceil(d_to_goal / self.step_size))\n            for _ in range(steps):\n                p_new = steer(current.position, target.position)\n                if (not in_bounds(p_new)) or in_obstacle(p_new) or edge_in_obstacle(current.position, p_new):\n                    return None\n                new_node = Node(p_new, current, current.cost + dist(current.position, p_new))\n                current.add_child(new_node)\n                tree.append(new_node)\n                grid.insert(new_node)\n                current = new_node\n                if dist(current.position, target.position) <= self.step_size:\n                    if in_obstacle(target.position) or edge_in_obstacle(current.position, target.position):\n                        return None\n                    final_node = Node(target.position, current, current.cost + dist(current.position, target.position))\n                    current.add_child(final_node)\n                    tree.append(final_node)\n                    grid.insert(final_node)\n                    return final_node\n            return None\n\n        def sample_uniform():\n            return tuple(random.uniform(0.0, bounds[d]) for d in range(dim))\n\n        def sample_informed():\n            if not found_solution or best_cost == float('inf') or c_min < 1e-14:\n                return sample_uniform()\n            center = tuple((start[d]+goal[d])*0.5 for d in range(dim))\n            a1 = [(goal[d]-start[d])/c_min for d in range(dim)]\n            r1 = best_cost*0.5\n            r2 = math.sqrt(max(best_cost*best_cost - c_min*c_min,0))*0.5\n            if dim == 2:\n                a2 = (-a1[1], a1[0])\n                basis = [a1, a2]\n                radii = [r1, r2]\n            else:\n                def cross(u,v):\n                    return (u[1]*v[2]-u[2]*v[1], u[2]*v[0]-u[0]*v[2], u[0]*v[1]-u[1]*v[0])\n                def norm(v):\n                    return math.sqrt(sum(x*x for x in v))\n                ref = (1,0,0) if abs(a1[0]) < 0.9 else (0,1,0)\n                b2 = cross(a1, ref)\n                n_b2 = norm(b2)\n                if n_b2 < 1e-14:\n                    ref = (0,0,1)\n                    b2 = cross(a1, ref)\n                    n_b2 = norm(b2)\n                b2 = tuple(x/n_b2 for x in b2)\n                b3 = cross(a1,b2)\n                basis = [a1,b2,b3]\n                radii = [r1,r2,r2]\n\n            def sample_unit_ball(ndim):\n                while True:\n                    vec = [random.gauss(0,1) for _ in range(ndim)]\n                    nrm = math.sqrt(sum(x*x for x in vec))\n                    if nrm < 1e-14:\n                        continue\n                    vec = [x/nrm for x in vec]\n                    r = random.random()**(1.0/ndim)\n                    return [v*r for v in vec]\n\n            u = sample_unit_ball(dim)\n            p = [0.0]*dim\n            for d in range(dim):\n                val = center[d]\n                for i_ in range(dim):\n                    if i_ < len(basis):\n                        val += basis[i_][d]*radii[i_]*u[i_]\n                val = max(0.0, min(val, bounds[d]))\n                p[d] = val\n            return tuple(p)\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path[:]\n            path = list(path)\n            for _ in range(self.shortcut_iter_per_pass):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path)-3)\n                j = random.randint(i+2, len(path)-1)\n                if not edge_in_obstacle(path[i], path[j]):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        def multi_pass_shortcut(path):\n            res_path = path\n            for _ in range(self.shortcut_passes):\n                res_path = shortcut_path(res_path)\n            return res_path\n\n        def connect_paths(n_start, n_goal):\n            p_start = n_start.path_from_root()\n            p_goal = n_goal.path_from_root()\n            if p_start[-1] == p_goal[-1]:\n                return p_start + p_goal[-2::-1]\n            else:\n                return p_start + p_goal[::-1]\n\n        start_node = Node(start, cost=0.0)\n        goal_node = Node(goal, cost=0.0)\n        tree_start = [start_node]\n        tree_goal = [goal_node]\n        nodes = [start_node, goal_node]\n        edges = []\n\n        cell_size = self.step_size * 1.5\n        grid_start = SpatialHash(bounds, cell_size, dim)\n        grid_goal = SpatialHash(bounds, cell_size, dim)\n        grid_start.insert(start_node)\n        grid_goal.insert(goal_node)\n\n        c_min = dist(start, goal)\n        best_cost = float('inf')\n        best_path = []\n        found_solution = False\n        no_improve = 0\n\n        start_time = time.time()\n\n        for it in range(self.max_iter):\n            if time.time() - start_time > self.time_limit:\n                break\n            if no_improve >= self.max_no_improve:\n                break\n\n            tree_a, grid_a = (tree_start, grid_start) if it % 2 == 0 else (tree_goal, grid_goal)\n            tree_b, grid_b = (tree_goal, grid_goal) if it % 2 == 0 else (tree_start, grid_start)\n\n            sample = sample_informed() if found_solution else sample_uniform()\n            if not in_bounds(sample) or in_obstacle(sample):\n                no_improve = no_improve + 1 if found_solution else 0\n                continue\n\n            nearest = min(tree_a, key=lambda n: dist(n.position, sample))\n            new_pos = steer(nearest.position, sample)\n            if not in_bounds(new_pos) or in_obstacle(new_pos) or edge_in_obstacle(nearest.position, new_pos):\n                no_improve = no_improve + 1 if found_solution else 0\n                continue\n\n            new_node, nbrs = choose_parent(tree_a, grid_a, new_pos, it)\n            if new_node is None:\n                no_improve = no_improve + 1 if found_solution else 0\n                continue\n            rewire(new_node, nbrs)\n            nodes.append(new_node)\n            edges.append((new_node.parent, new_node))\n\n            connect_node = direct_connect(tree_b, grid_b, new_node)\n            if connect_node:\n                candidate_path = connect_paths(new_node, connect_node)\n                cost_path = 0.0\n                for i in range(len(candidate_path)-1):\n                    cost_path += dist(candidate_path[i], candidate_path[i+1])\n                if cost_path + 1e-12 < best_cost:\n                    best_cost = cost_path\n                    best_path = candidate_path\n                    found_solution = True\n                    no_improve = 0\n                else:\n                    no_improve += 1\n            else:\n                no_improve = no_improve + 1 if found_solution else 0\n\n        if found_solution and len(best_path) >= 3:\n            best_path = multi_pass_shortcut(best_path)\n\n        return PlannerResult(success=found_solution, path=best_path, nodes=nodes, edges=edges)",
          "objective": -31.70156,
          "time_improvement": 48.0,
          "length_improvement": 16.0,
          "smoothness_improvement": 1562.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.016392445564270018,
                    "num_nodes_avg": 82.9,
                    "path_length_avg": 165.87323704797151,
                    "smoothness_avg": 0.037117046018902464,
                    "success_improvement": 0.0,
                    "time_improvement": 32.50092037639713,
                    "length_improvement": 9.082250344364851,
                    "smoothness_improvement": 480.9623711513166,
                    "objective_score": 17.604438175294636
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.019131898880004883,
                    "num_nodes_avg": 172.3,
                    "path_length_avg": 236.49188117146687,
                    "smoothness_avg": 0.10204689187676277,
                    "success_improvement": 0.0,
                    "time_improvement": 88.15107442858779,
                    "length_improvement": 21.052203023591492,
                    "smoothness_improvement": 2525.7400293943756,
                    "objective_score": 51.705344289703106
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.03753662109375,
                    "num_nodes_avg": 330.6,
                    "path_length_avg": 125.13705962092322,
                    "smoothness_avg": 0.1399520374508409,
                    "success_improvement": 0.0,
                    "time_improvement": 24.200187766303173,
                    "length_improvement": 16.889923386223877,
                    "smoothness_improvement": 1680.1795861898495,
                    "objective_score": 25.794908292574526
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m1",
          "algorithm_description": "A bidirectional RRT* planner with dynamically clamped adaptive radius for neighbor search, stricter and collision-checked parent selection avoiding fallback to nearest unchecked nodes, incremental rewiring considering both cost and smoothness, and an early-stopping criterion on stagnation. It integrates a balanced sampling strategy mixing uniform and informed samples to improve exploration and exploitation. The planner grows two trees from start and goal alternately, attempts connecting them each iteration, and performs enhanced multi-pass shortcutting with adaptive curvature pruning for smoother, shorter paths. This design improves planning efficiency, path quality, robustness, success rate, smoothness, and reduces search time.",
          "planning_mechanism": "A bidirectional planner grows start and goal trees alternately by sampling a mix of uniform and ellipsoid-informed points. New nodes select parents that minimize a combined cost and curvature metric within a dynamically clamped adaptive radius, with strict collision checks. Rewiring locally improves both cost and path smoothness. Each iteration attempts to directly connect the two trees. The planner stops early if no improvement occurs for a configurable iteration window. After path extraction, an enhanced multi-pass shortcutting procedure with curvature and cost pruning iteratively smooths and shortens the path, yielding better final path quality without excessive planning time.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self,\n                 max_iter=3000,\n                 step_size=5.0,\n                 radius_gain=3.0,\n                 min_radius=6.0,\n                 max_radius=20.0,\n                 max_no_improve=40,\n                 shortcut_passes=5,\n                 shortcut_iter_per_pass=120,\n                 cell_size=11.0,\n                 curvature_threshold=0.3,\n                 curvature_weight=0.15):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.radius_gain = radius_gain\n        self.min_radius = min_radius\n        self.max_radius = max_radius\n        self.max_no_improve = max_no_improve\n        self.shortcut_passes = shortcut_passes\n        self.shortcut_iter_per_pass = shortcut_iter_per_pass\n        self.cell_size = cell_size\n        self.curvature_threshold = curvature_threshold\n        self.curvature_weight = curvature_weight\n\n    def plan(self, map):\n        import math\n        import random\n        import time\n\n        bounds = map.size\n        dim = len(bounds)\n        start_pos = tuple(map.start)\n        goal_pos = tuple(map.goal)\n        obstacles = map.obstacles\n        is_3d = (dim == 3)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def in_obstacle(p):\n            if is_3d:\n                px, py, pz = p\n                for obs in obstacles:\n                    x, y, z, w, h, d_ = obs\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d_:\n                        return True\n                return False\n            else:\n                px, py = p\n                for obs in obstacles:\n                    x, y, w, h = obs\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n                return False\n\n        def edge_in_obstacle(a, b, resolution=1.0):\n            dist_ab = math.dist(a, b)\n            if dist_ab < 1e-12:\n                return False\n            steps = max(3, int(dist_ab / resolution))\n            for i in range(steps + 1):\n                interp = tuple(a[d] + (b[d] - a[d]) * i / steps for d in range(dim))\n                if in_obstacle(interp):\n                    return True\n            return False\n\n        def steer(frm, to):\n            dist_ = math.dist(frm, to)\n            if dist_ <= self.step_size:\n                return to\n            ratio = self.step_size / dist_\n            return tuple(frm[d] + (to[d] - frm[d]) * ratio for d in range(dim))\n\n        class SpatialHash:\n            def __init__(self, bounds, cell_size):\n                self.cell_size = cell_size\n                self.inv_cell = 1.0 / cell_size\n                self.grid = {}\n                self.dim = len(bounds)\n\n            def _hash_coords(self, p):\n                return tuple(int(p[d] * self.inv_cell) for d in range(self.dim))\n\n            def insert(self, node):\n                hc = self._hash_coords(node.position)\n                self.grid.setdefault(hc, []).append(node)\n\n            def neighbors(self, p, radius):\n                r_cells = int(math.ceil(radius * self.inv_cell))\n                hc = self._hash_coords(p)\n                candidates = []\n                rng = range(-r_cells, r_cells + 1)\n                if self.dim == 2:\n                    for dx in rng:\n                        for dy in rng:\n                            cell_key = (hc[0] + dx, hc[1] + dy)\n                            cell_nodes = self.grid.get(cell_key)\n                            if cell_nodes:\n                                candidates.extend(cell_nodes)\n                else:\n                    for dx in rng:\n                        for dy in rng:\n                            for dz in rng:\n                                cell_key = (hc[0] + dx, hc[1] + dy, hc[2] + dz)\n                                cell_nodes = self.grid.get(cell_key)\n                                if cell_nodes:\n                                    candidates.extend(cell_nodes)\n                r_sq = radius * radius\n                result = []\n                for node in candidates:\n                    d_sq = 0.0\n                    for d in range(self.dim):\n                        diff = node.position[d] - p[d]\n                        d_sq += diff * diff\n                        if d_sq > r_sq:\n                            break\n                    else:\n                        result.append(node)\n                return result\n\n        def sample_uniform():\n            return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        def sample_informed(c_best, c_min):\n            if c_best == float('inf') or c_min < 1e-12:\n                return sample_uniform()\n            center = tuple((start_pos[d] + goal_pos[d]) * 0.5 for d in range(dim))\n            unit_dir = [(goal_pos[d] - start_pos[d]) / c_min for d in range(dim)]\n            r1 = c_best * 0.5\n            diff_sq = max(c_best*c_best - c_min*c_min, 0.0)\n            r_other = math.sqrt(diff_sq) * 0.5\n\n            if dim == 2:\n                a1 = unit_dir\n                a2 = (-a1[1], a1[0])\n                basis = (a1, a2)\n                radii = (r1, r_other)\n            else:\n                def cross(u,v):\n                    return (u[1]*v[2]-u[2]*v[1], u[2]*v[0]-u[0]*v[2], u[0]*v[1]-u[1]*v[0])\n                def norm(v):\n                    return math.sqrt(sum(x*x for x in v))\n                a1 = unit_dir\n                ref = (1.0, 0.0, 0.0) if abs(a1[0]) < 0.9 else (0.0, 1.0, 0.0)\n                b2 = cross(a1, ref)\n                n_b2 = norm(b2)\n                if n_b2 < 1e-14:\n                    ref = (0.0, 0.0, 1.0)\n                    b2 = cross(a1, ref)\n                    n_b2 = norm(b2)\n                b2 = tuple(x / n_b2 for x in b2)\n                b3 = cross(a1, b2)\n                basis = (a1, b2, b3)\n                radii = (r1, r_other, r_other)\n\n            def sample_unit_ball(ndim):\n                while True:\n                    vec = [random.gauss(0, 1) for _ in range(ndim)]\n                    nrm = math.sqrt(sum(v * v for v in vec))\n                    if nrm < 1e-14:\n                        continue\n                    vec = [v / nrm for v in vec]\n                    r = random.random() ** (1.0 / ndim)\n                    return [v * r for v in vec]\n\n            u = sample_unit_ball(dim)\n            mapped = []\n            for d in range(dim):\n                val = center[d]\n                for i in range(dim):\n                    val += basis[i][d] * radii[i] * u[i]\n                val = max(0.0, min(val, bounds[d]))\n                mapped.append(val)\n            return tuple(mapped)\n\n        def angle_cosine(p1, p2, p3):\n            def vec(a, b):\n                return [b[d] - a[d] for d in range(dim)]\n            v1 = vec(p2, p1)\n            v2 = vec(p2, p3)\n            norm1 = math.sqrt(sum(x * x for x in v1))\n            norm2 = math.sqrt(sum(x * x for x in v2))\n            if norm1 < 1e-12 or norm2 < 1e-12:\n                return 1.0\n            dot = sum(v1[d] * v2[d] for d in range(dim))\n            return dot / (norm1 * norm2)\n\n        def smoothness_cost(parent, child, new_pos):\n            # Small curvature reduces cost; calculate angle cos between (parent->child) and (child->new_pos)\n            if parent is None or child is None:\n                return 0.0\n            c = angle_cosine(parent.position, child.position, new_pos)\n            return max(0.0, 1.0 - c)  # The closer to 0 curvature (cos~1), the lower value\n\n        def choose_parent(tree_hash, tree_nodes, new_pos, radius):\n            nbrs = tree_hash.neighbors(new_pos, radius)\n            valid_parents = []\n            for n in nbrs:\n                if not edge_in_obstacle(n.position, new_pos):\n                    valid_parents.append(n)\n            if not valid_parents:\n                return None, []\n            best_parent = None\n            min_score = float('inf')\n            for p in valid_parents:\n                dist_p_new = math.dist(p.position, new_pos)\n                cost_p_new = p.cost + dist_p_new\n                # Find parent's parent for curvature cost\n                curvature_penalty = 0.0\n                if p.parent is not None:\n                    curvature_penalty = self.curvature_weight * smoothness_cost(p.parent, p, new_pos)\n                score = cost_p_new + curvature_penalty\n                if score < min_score:\n                    min_score = score\n                    best_parent = p\n            cost_min = best_parent.cost + math.dist(best_parent.position, new_pos)\n            new_node = Node(new_pos, parent=best_parent, cost=cost_min)\n            best_parent.add_child(new_node)\n            tree_nodes.append(new_node)\n            tree_hash.insert(new_node)\n            return new_node, valid_parents\n\n        def rewire(new_node, neighbors, tree_hash):\n            for nb in neighbors:\n                if nb == new_node.parent:\n                    continue\n                dist_new_nb = math.dist(new_node.position, nb.position)\n                new_cost = new_node.cost + dist_new_nb\n                if new_cost + 1e-12 < nb.cost:\n                    # Check curvature penalty if rewire proceeds\n                    curvature_penalty = 0.0\n                    if new_node.parent is not None:\n                        curvature_penalty = self.curvature_weight * smoothness_cost(new_node.parent, new_node, nb.position)\n                    total_new_cost = new_cost + curvature_penalty\n                    if total_new_cost + 1e-12 < nb.cost:\n                        if edge_in_obstacle(new_node.position, nb.position):\n                            continue\n                        if nb.parent:\n                            nb.parent.remove_child(nb)\n                        new_node.add_child(nb)\n                        nb.cost = new_cost\n\n        def attempt_connect(tree_hash, tree_nodes, node):\n            if not tree_nodes:\n                return None\n            nearest = min(tree_nodes, key=lambda n: math.dist(n.position, node.position))\n            dist_near = math.dist(nearest.position, node.position)\n            if dist_near <= self.step_size:\n                if edge_in_obstacle(nearest.position, node.position) or in_obstacle(node.position):\n                    return None\n                new_node = Node(node.position, parent=nearest, cost=nearest.cost + dist_near)\n                nearest.add_child(new_node)\n                tree_nodes.append(new_node)\n                tree_hash.insert(new_node)\n                return new_node\n            current = nearest\n            steps = int(math.ceil(dist_near / self.step_size))\n            for _ in range(steps):\n                new_pos = steer(current.position, node.position)\n                if (not in_bounds(new_pos) or in_obstacle(new_pos) or\n                    edge_in_obstacle(current.position, new_pos)):\n                    return None\n                new_node = Node(new_pos, parent=current, cost=current.cost + math.dist(current.position, new_pos))\n                current.add_child(new_node)\n                tree_nodes.append(new_node)\n                tree_hash.insert(new_node)\n                current = new_node\n                if math.dist(current.position, node.position) <= self.step_size:\n                    if edge_in_obstacle(current.position, node.position) or in_obstacle(node.position):\n                        return None\n                    final_node = Node(node.position, parent=current,\n                                      cost=current.cost + math.dist(current.position, node.position))\n                    current.add_child(final_node)\n                    tree_nodes.append(final_node)\n                    tree_hash.insert(final_node)\n                    return final_node\n            return None\n\n        def multi_pass_shortcut(path):\n            if len(path) < 3:\n                return list(path)\n\n            def angle_cos(p1, p2, p3):\n                return angle_cosine(p1, p2, p3)\n\n            path = list(path)\n            for _ in range(self.shortcut_passes):\n                for _ in range(self.shortcut_iter_per_pass):\n                    if len(path) < 3:\n                        break\n                    i = random.randint(0, len(path) - 3)\n                    j = random.randint(i + 2, len(path) - 1)\n                    if not edge_in_obstacle(path[i], path[j]):\n                        path = path[:i+1] + path[j:]\n                improved = True\n                while improved and len(path) >= 3:\n                    improved = False\n                    for i in range(1, len(path) - 1):\n                        cos_phi = angle_cos(path[i-1], path[i], path[i+1])\n                        if cos_phi > self.curvature_threshold:\n                            candidate = path[:i] + path[i+1:]\n                            if not edge_in_obstacle(path[i-1], path[i+1]):\n                                path = candidate\n                                improved = True\n                                break\n            return path\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n        start_hash = SpatialHash(bounds, self.cell_size)\n        goal_hash = SpatialHash(bounds, self.cell_size)\n        start_hash.insert(start_root)\n        goal_hash.insert(goal_root)\n        nodes = [start_root, goal_root]\n        edges = []\n\n        best_path = []\n        best_cost = float('inf')\n        c_min = math.dist(start_pos, goal_pos)\n        found_solution = False\n        no_improve_count = 0\n\n        start_time = time.time()\n\n        # Adaptive radius function clamped upward/downward by configured limits\n        def adaptive_radius(n_nodes):\n            # Based on RRT* radius theorem: radius ~ (log(n)/n)^{1/dim}, scaled\n            if n_nodes < 2:\n                return self.max_radius\n            val = self.radius_gain * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            return max(self.min_radius, min(self.max_radius, val))\n\n        for iter_i in range(self.max_iter):\n            if time.time() - start_time > 30.0:\n                break\n            # Balanced sampling: informed with small uniform ratio\n            if found_solution:\n                sample = sample_informed(best_cost, c_min)\n                if random.random() < 0.12:\n                    sample = sample_uniform()\n            else:\n                sample = sample_uniform()\n\n            if not in_bounds(sample) or in_obstacle(sample):\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n                continue\n\n            # Alternate tree expansions\n            if iter_i % 2 == 0:\n                tree_nodes, tree_hash = start_tree, start_hash\n                other_nodes, other_hash = goal_tree, goal_hash\n            else:\n                tree_nodes, tree_hash = goal_tree, goal_hash\n                other_nodes, other_hash = start_tree, start_hash\n\n            nearest_node = min(tree_nodes, key=lambda n: math.dist(n.position, sample))\n            new_pos = steer(nearest_node.position, sample)\n\n            if (not in_bounds(new_pos) or in_obstacle(new_pos) or\n                edge_in_obstacle(nearest_node.position, new_pos)):\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n                continue\n\n            radius = adaptive_radius(len(tree_nodes))\n\n            new_node, neighbors_ = choose_parent(tree_hash, tree_nodes, new_pos, radius)\n            if new_node is None:\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n                continue\n\n            rewire(new_node, neighbors_, tree_hash)\n            nodes.append(new_node)\n            if new_node.parent:\n                edges.append((new_node.parent, new_node))\n\n            connect_node = attempt_connect(other_hash, other_nodes, new_node)\n            if connect_node is not None:\n                if iter_i % 2 == 0:\n                    path_from = new_node.path_from_root()\n                    path_to = connect_node.path_from_root()\n                else:\n                    path_from = connect_node.path_from_root()\n                    path_to = new_node.path_from_root()\n\n                if path_from and path_to and path_from[-1] == path_to[-1]:\n                    candidate_path = path_from + path_to[-2::-1]\n                else:\n                    candidate_path = path_from + path_to[::-1]\n\n                # Compute candidate path cost\n                total_cost = 0.0\n                for i in range(len(candidate_path) - 1):\n                    total_cost += math.dist(candidate_path[i], candidate_path[i + 1])\n\n                if total_cost + 1e-9 < best_cost:\n                    best_cost = total_cost\n                    best_path = candidate_path\n                    found_solution = True\n                    no_improve_count = 0\n                else:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n            else:\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n\n        if found_solution and len(best_path) >= 3:\n            best_path = multi_pass_shortcut(best_path)\n\n        return PlannerResult(success=found_solution, path=best_path, nodes=nodes, edges=edges)",
          "objective": -31.48243,
          "time_improvement": 41.0,
          "length_improvement": 17.0,
          "smoothness_improvement": 1778.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.028242158889770507,
                    "num_nodes_avg": 79.8,
                    "path_length_avg": 158.5878381238725,
                    "smoothness_avg": 0.04423982457836187,
                    "success_improvement": 0.0,
                    "time_improvement": -16.292576612131292,
                    "length_improvement": 13.075492939197108,
                    "smoothness_improvement": 592.4493229680619,
                    "objective_score": 5.919769394719187
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.03674776554107666,
                    "num_nodes_avg": 252.9,
                    "path_length_avg": 239.84841629540648,
                    "smoothness_avg": 0.13684001891827163,
                    "success_improvement": 0.0,
                    "time_improvement": 77.24107044769137,
                    "length_improvement": 19.931694986713737,
                    "smoothness_improvement": 3420.9922486488545,
                    "objective_score": 52.236299369579925
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.01839940547943115,
                    "num_nodes_avg": 171.9,
                    "path_length_avg": 123.37780446189984,
                    "smoothness_avg": 0.1116785523359373,
                    "success_improvement": 0.0,
                    "time_improvement": 62.84504465467852,
                    "length_improvement": 18.05833689611881,
                    "smoothness_improvement": 1320.5429424598617,
                    "objective_score": 36.29123024637415
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "A simplified bidirectional informed RRT* planner using adaptive neighbor radius, spatial hashing for neighbor searches, and enhanced path smoothing by combining extensive shortcutting with iterative curvature pruning using a stricter threshold. The planner alternates tree expansions, samples adaptively inside an informed ellipsoid after initial success, rewires nodes for cost improvements, attempts direct tree connections, and applies robust smoothing that prunes sharp turns for smoother and shorter paths. This balances efficiency, path quality, and smoothness with simpler, clear mechanics.",
          "planning_mechanism": "The planner alternates growing two trees from start and goal, samples points uniformly before solving or within an informed ellipsoid after. It selects parents minimizing path cost within an adaptive radius, rewires neighbors to reduce costs, and tries connecting the two trees. After a solution is found, a robust smoothing stage applies multiple shortcutting attempts and iterative angle-based pruning with a stricter curvature threshold to remove sharp corners, yielding smoother, shorter, and lower-cost paths. Early termination occurs on stagnation, improving planning efficiency.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=3000, step_size=6.0,\n                 max_radius=25.0, min_radius=5.5,\n                 max_no_improve=40, shortcut_iter=300,\n                 curvature_threshold=0.85):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.max_radius = max_radius\n        self.min_radius = min_radius\n        self.max_no_improve = max_no_improve\n        self.shortcut_iter = shortcut_iter\n        self.curvature_threshold = curvature_threshold\n\n    def plan(self, map):\n        import math\n        import random\n        start = tuple(map.start)\n        goal = tuple(map.goal)\n        bounds = tuple(map.size)\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def in_bounds(p):\n            return all(0.0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def in_obstacle(p):\n            if is_3d:\n                px, py, pz = p\n                for obs in obstacles:\n                    ox, oy, oz, ow, oh, od = obs\n                    if ox <= px <= ox+ow and oy <= py <= oy+oh and oz <= pz <= oz+od:\n                        return True\n                return False\n            else:\n                px, py = p\n                for obs in obstacles:\n                    ox, oy, ow, oh = obs\n                    if ox <= px <= ox+ow and oy <= py <= oy+oh:\n                        return True\n                return False\n\n        def edge_in_obstacle(a, b, res=1.0):\n            dist_ab = math.dist(a, b)\n            if dist_ab < 1e-12:\n                return False\n            steps = max(3, int(dist_ab / res))\n            for i in range(steps+1):\n                interp = tuple(a[d] + (b[d] - a[d]) * i / steps for d in range(dim))\n                if in_obstacle(interp):\n                    return True\n            return False\n\n        def steer(frm, to):\n            d = math.dist(frm, to)\n            if d <= self.step_size:\n                return to\n            ratio = self.step_size / d\n            return tuple(frm[d] + (to[d] - frm[d]) * ratio for d in range(dim))\n\n        class SpatialHash:\n            def __init__(self, bounds, cell_size, dim):\n                self.cell_size = cell_size\n                self.inv_cell = 1.0 / cell_size\n                self.grid = {}\n                self.dim = dim\n\n            def _hash_coords(self, p):\n                return tuple(int(p[d] * self.inv_cell) for d in range(self.dim))\n\n            def insert(self, node):\n                hc = self._hash_coords(node.position)\n                self.grid.setdefault(hc, []).append(node)\n\n            def neighbors(self, p, radius):\n                c = self._hash_coords(p)\n                r_cells = int(math.ceil(radius * self.inv_cell))\n                candidates = []\n                def _recurse(dim_i, idx):\n                    if dim_i == self.dim:\n                        cell = tuple(idx)\n                        if cell in self.grid:\n                            candidates.extend(self.grid[cell])\n                        return\n                    for off in range(-r_cells, r_cells+1):\n                        idx.append(c[dim_i] + off)\n                        _recurse(dim_i+1, idx)\n                        idx.pop()\n                _recurse(0, [])\n                radius_sq = radius*radius\n                result = []\n                for n in candidates:\n                    dist_sq = 0\n                    for d in range(self.dim):\n                        diff = n.position[d] - p[d]\n                        dist_sq += diff*diff\n                        if dist_sq > radius_sq:\n                            break\n                    else:\n                        result.append(n)\n                return result\n\n        def adaptive_radius(num_nodes, best_cost):\n            if num_nodes <= 1:\n                return self.max_radius\n            base = self.max_radius * (math.log(num_nodes) / num_nodes) ** (1.0/dim)\n            base = max(self.min_radius, min(base, self.max_radius))\n            if best_cost != float('inf'):\n                base = max(self.min_radius, min(base, best_cost*0.55))\n            return base\n\n        def sample_uniform():\n            return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        def sample_informed(c_best, c_min):\n            if c_best == float('inf') or c_min < 1e-12:\n                return sample_uniform()\n            center = tuple((start[d] + goal[d]) * 0.5 for d in range(dim))\n            unit_dir = [(goal[d] - start[d]) / c_min for d in range(dim)]\n            r1 = c_best * 0.5\n            val = max(c_best*c_best - c_min*c_min, 0.0)\n            r_other = 0 if val < 0 else math.sqrt(val)*0.5\n\n            if dim == 2:\n                a1 = unit_dir\n                a2 = (-a1[1], a1[0])\n                basis = (a1, a2)\n                radii = (r1, r_other)\n            else:\n                def cross(u,v):\n                    return (u[1]*v[2]-u[2]*v[1], u[2]*v[0]-u[0]*v[2], u[0]*v[1]-u[1]*v[0])\n                def norm(v):\n                    return math.sqrt(sum(x*x for x in v))\n                a1 = unit_dir\n                ref = (1, 0, 0) if abs(a1[0]) < 0.9 else (0, 1, 0)\n                b2 = cross(a1, ref)\n                n_b2 = norm(b2)\n                if n_b2 < 1e-14:\n                    ref = (0,0,1)\n                    b2 = cross(a1, ref)\n                    n_b2 = norm(b2)\n                b2 = tuple(x/n_b2 for x in b2)\n                b3 = cross(a1, b2)\n                basis = (a1, b2, b3)\n                radii = (r1, r_other, r_other)\n\n            def sample_unit_ball(dim_):\n                while True:\n                    vec = [random.gauss(0,1) for _ in range(dim_)]\n                    nrm = math.sqrt(sum(x*x for x in vec))\n                    if nrm < 1e-14:\n                        continue\n                    vec = [x/nrm for x in vec]\n                    r = random.random() ** (1.0/dim_)\n                    return [x*r for x in vec]\n\n            u = sample_unit_ball(dim)\n            p = []\n            for d in range(dim):\n                val = center[d]\n                for i in range(dim):\n                    val += basis[i][d]*radii[i]*u[i]\n                val = max(0.0, min(val, bounds[d]))\n                p.append(val)\n            if in_obstacle(tuple(p)):\n                return sample_uniform()\n            return tuple(p)\n\n        def choose_parent(tree_hash, tree_nodes, pos, best_cost):\n            radius = adaptive_radius(len(tree_nodes), best_cost)\n            nbrs = tree_hash.neighbors(pos, radius)\n            best_p = None\n            best_c = float('inf')\n            valid_parents = []\n            for n in nbrs:\n                if not edge_in_obstacle(n.position, pos):\n                    valid_parents.append(n)\n                    c = n.cost + math.dist(n.position, pos)\n                    if c < best_c:\n                        best_c = c\n                        best_p = n\n            if best_p is None:\n                nearest = min(tree_nodes, key=lambda n: math.dist(n.position, pos))\n                if edge_in_obstacle(nearest.position, pos) or in_obstacle(pos):\n                    return None, []\n                best_p = nearest\n                best_c = best_p.cost + math.dist(best_p.position, pos)\n            new_node = Node(pos, parent=best_p, cost=best_c)\n            best_p.add_child(new_node)\n            tree_nodes.append(new_node)\n            tree_hash.insert(new_node)\n            return new_node, valid_parents\n\n        def rewire(pivot, neighbors):\n            for n in neighbors:\n                if n is pivot.parent:\n                    continue\n                c_new = pivot.cost + math.dist(pivot.position, n.position)\n                if c_new + 1e-11 < n.cost and not edge_in_obstacle(pivot.position, n.position):\n                    if n.parent:\n                        n.parent.remove_child(n)\n                    pivot.add_child(n)\n                    n.cost = c_new\n\n        def attempt_connect(tree_nodes, tree_hash, node):\n            if not tree_nodes:\n                return None\n            nearest = min(tree_nodes, key=lambda n: math.dist(n.position, node.position))\n            d = math.dist(nearest.position, node.position)\n            if d <= self.step_size:\n                if edge_in_obstacle(nearest.position, node.position) or in_obstacle(node.position):\n                    return None\n                n = Node(node.position, parent=nearest, cost=nearest.cost + d)\n                nearest.add_child(n)\n                tree_nodes.append(n)\n                tree_hash.insert(n)\n                return n\n            current = nearest\n            steps = int(math.ceil(d / self.step_size))\n            for _ in range(steps):\n                new_pos = steer(current.position, node.position)\n                if not in_bounds(new_pos) or in_obstacle(new_pos) or edge_in_obstacle(current.position, new_pos):\n                    return None\n                nxt = Node(new_pos, parent=current, cost=current.cost + math.dist(current.position, new_pos))\n                current.add_child(nxt)\n                tree_nodes.append(nxt)\n                tree_hash.insert(nxt)\n                current = nxt\n                if math.dist(current.position, node.position) <= self.step_size:\n                    if edge_in_obstacle(current.position, node.position) or in_obstacle(node.position):\n                        return None\n                    final = Node(node.position, parent=current, cost=current.cost + math.dist(current.position, node.position))\n                    current.add_child(final)\n                    tree_nodes.append(final)\n                    tree_hash.insert(final)\n                    return final\n            return None\n\n        def connect_paths(n1, n2):\n            path1 = n1.path_from_root()\n            path2 = n2.path_from_root()\n            if path1[-1] == path2[-1]:\n                return path1 + path2[-2::-1]\n            else:\n                return path1 + path2[::-1]\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path[:]\n            path = list(path)\n            for _ in range(self.shortcut_iter):\n                if len(path)<3:\n                    break\n                i = random.randint(0, len(path)-3)\n                j = random.randint(i+2, len(path)-1)\n                if not edge_in_obstacle(path[i], path[j]):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        def angle_cosine(p1, p2, p3):\n            def vec(a,b):\n                return [b[d]-a[d] for d in range(dim)]\n            v1 = vec(p2,p1)\n            v2 = vec(p2,p3)\n            n1 = math.sqrt(sum(x*x for x in v1))\n            n2 = math.sqrt(sum(x*x for x in v2))\n            if n1 < 1e-12 or n2 < 1e-12:\n                return 1.0\n            dot = sum(v1[d]*v2[d] for d in range(dim))\n            return dot/(n1*n2)\n\n        def prune_path(path):\n            if len(path)<3:\n                return path[:]\n            path = list(path)\n            improved, max_pass = True, 3\n            pass_cnt = 0\n            while improved and pass_cnt < max_pass and len(path)>=3:\n                improved = False\n                pass_cnt+=1\n                i = 1\n                while i < len(path)-1:\n                    cos_angle = angle_cosine(path[i-1], path[i], path[i+1])\n                    if cos_angle > self.curvature_threshold:\n                        if not edge_in_obstacle(path[i-1], path[i+1]):\n                            path.pop(i)\n                            improved = True\n                            continue\n                    i+=1\n            return path\n\n        start_root = Node(start, cost=0.0)\n        goal_root = Node(goal, cost=0.0)\n        start_tree, goal_tree = [start_root], [goal_root]\n        start_hash = SpatialHash(bounds, self.step_size*2.0, dim)\n        goal_hash = SpatialHash(bounds, self.step_size*2.0, dim)\n        start_hash.insert(start_root)\n        goal_hash.insert(goal_root)\n        nodes = [start_root, goal_root]\n        edges = []\n\n        best_cost = float('inf')\n        c_min = math.dist(start, goal)\n        best_path = []\n        found_solution = False\n        no_improve_count = 0\n\n        for i in range(self.max_iter):\n            if found_solution:\n                sample = sample_informed(best_cost, c_min)\n                if random.random()<0.15:\n                    sample = sample_uniform()\n            else:\n                sample = sample_uniform()\n            if not in_bounds(sample) or in_obstacle(sample):\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n                continue\n\n            if i%2==0:\n                tree_nodes, tree_hash = start_tree, start_hash\n                other_nodes, other_hash = goal_tree, goal_hash\n            else:\n                tree_nodes, tree_hash = goal_tree, goal_hash\n                other_nodes, other_hash = start_tree, start_hash\n\n            nearest = min(tree_nodes, key=lambda n: math.dist(n.position, sample))\n            new_pos = steer(nearest.position, sample)\n            if not in_bounds(new_pos) or in_obstacle(new_pos) or edge_in_obstacle(nearest.position, new_pos):\n                if found_solution:\n                    no_improve_count+=1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n                continue\n\n            new_node, nbrs = choose_parent(tree_hash, tree_nodes, new_pos, best_cost)\n            if new_node is None:\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n                continue\n\n            rewire(new_node, nbrs)\n            nodes.append(new_node)\n            if new_node.parent:\n                edges.append((new_node.parent, new_node))\n\n            meet_node = attempt_connect(other_nodes, other_hash, new_node)\n            if meet_node is not None:\n                candidate_path = connect_paths(new_node, meet_node)\n                cost = 0.0\n                for k in range(len(candidate_path)-1):\n                    cost += math.dist(candidate_path[k], candidate_path[k+1])\n                if cost + 1e-9 < best_cost:\n                    best_cost = cost\n                    best_path = candidate_path\n                    found_solution = True\n                    no_improve_count = 0\n                else:\n                    if found_solution:\n                        no_improve_count += 1\n                        if no_improve_count >= self.max_no_improve:\n                            break\n            else:\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n\n        if found_solution and len(best_path) >= 3:\n            best_path = shortcut_path(best_path)\n            best_path = prune_path(best_path)\n\n        return PlannerResult(success=found_solution, path=best_path, nodes=nodes, edges=edges)",
          "objective": -31.43162,
          "time_improvement": 49.0,
          "length_improvement": 14.0,
          "smoothness_improvement": 1601.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.02159616947174072,
                    "num_nodes_avg": 90.5,
                    "path_length_avg": 167.6565671050185,
                    "smoothness_avg": 0.04700511662893172,
                    "success_improvement": 0.0,
                    "time_improvement": 11.073576116355218,
                    "length_improvement": 8.104778881424291,
                    "smoothness_improvement": 635.7321484872799,
                    "objective_score": 11.363600906197538
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.023778271675109864,
                    "num_nodes_avg": 190.3,
                    "path_length_avg": 240.91494042973173,
                    "smoothness_avg": 0.10953591372585851,
                    "success_improvement": 0.0,
                    "time_improvement": 85.27344446767617,
                    "length_improvement": 19.57565853248087,
                    "smoothness_improvement": 2718.437955696015,
                    "objective_score": 50.91961823827145
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.024289941787719725,
                    "num_nodes_avg": 220.1,
                    "path_length_avg": 126.77072934462929,
                    "smoothness_avg": 0.12175686404160639,
                    "success_improvement": 0.0,
                    "time_improvement": 50.949953058424214,
                    "length_improvement": 15.804917742730911,
                    "smoothness_improvement": 1448.738323452384,
                    "objective_score": 32.011628180427735
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e2",
          "algorithm_description": "A Bidirectional RRT* variant with spatial grid acceleration, adaptive neighbor radius, and curvature-aware rewiring. This planner alternates expansions from start and goal, uses ellipsoidal informed sampling post initial solution, leverages spatial hashing grids for efficient nearest neighbor search, dynamically scales rewiring radius with tree size and solution cost, and incorporates curvature penalties to encourage smooth paths. The algorithm applies multi-pass accelerated shortcutting after planning and employs early termination on stagnation to balance planning efficiency with path quality improvements.",
          "planning_mechanism": "A bidirectional tree growth approach alternates expansions; nodes connect to parents that minimize travel cost plus curvature penalty chosen from spatial grid-based neighbors within an adaptive radius. After adding nodes, neighbors are rewired if a cheaper, smoother path exists. Ellipsoidal informed sampling focuses exploration after initial solutions. Tree connectivity is tested each iteration to attempt building a path. The planner stops on stagnation or iteration limit. Final path is smoothed through multiple passes of shortcutting to improve length and smoothness.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=3500, step_size=6.0, n_near_const=20,\n                 max_no_improve=60, improve_tol=1e-6, shortcut_iters=400,\n                 grid_cell_size=4.0, resolution=1.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.n_near_const = n_near_const\n        self.max_no_improve = max_no_improve\n        self.improve_tol = improve_tol\n        self.shortcut_iters = shortcut_iters\n        self.grid_cell_size = grid_cell_size\n        self.resolution = resolution\n\n    def plan(self, map):\n        import math\n        import random\n\n        # Basic environment info\n        start = tuple(map.start)\n        goal = tuple(map.goal)\n        bounds = tuple(map.size)\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        dist = lambda a,b: math.dist(a,b)\n        step_size = self.step_size\n        resolution = self.resolution\n\n        def in_obstacle(p):\n            px, py, pz = (p + (0,0,0))[:3]\n            for obs in obstacles:\n                if is_3d:\n                    ox, oy, oz, ow, oh, od = obs\n                    if ox <= px <= ox + ow and oy <= py <= oy + oh and oz <= pz <= oz + od:\n                        return True\n                else:\n                    ox, oy, ow, oh = obs\n                    if ox <= px <= ox + ow and oy <= py <= oy + oh:\n                        return True\n            return False\n\n        def edge_obstacle(f, t):\n            length = dist(f, t)\n            if length < 1e-12:\n                return False\n            steps = max(3, int(length / resolution))\n            for i in range(steps + 1):\n                inter = tuple(f[d] + (t[d] - f[d]) * i / steps for d in range(dim))\n                if in_obstacle(inter):\n                    return True\n            return False\n\n        def steer(frm, to, max_step):\n            d = dist(frm, to)\n            if d <= max_step:\n                return to\n            ratio = max_step / d\n            return tuple(frm[i] + (to[i] - frm[i]) * ratio for i in range(dim))\n\n        def in_bounds(p):\n            return all(0.0 <= p[d] <= bounds[d] for d in range(dim))\n\n        # Spatial hashing grid to accelerate neighbor queries\n        class SpatialGrid:\n            def __init__(self, bounds, cell_sz, dim):\n                self.dim = dim\n                self.cell_sz = cell_sz\n                self.cells = {}\n            def _hash_point(self, p):\n                return tuple(int(p[i]//self.cell_sz) for i in range(self.dim))\n            def insert(self, node):\n                h = self._hash_point(node.position)\n                if h not in self.cells:\n                    self.cells[h] = []\n                self.cells[h].append(node)\n            def neighbors(self, point, radius):\n                low = [int((point[i] - radius)//self.cell_sz) for i in range(self.dim)]\n                high = [int((point[i] + radius)//self.cell_sz) for i in range(self.dim)]\n                result = []\n                def recursive_collect(idx=[]):\n                    if len(idx) == self.dim:\n                        key = tuple(idx)\n                        if key in self.cells:\n                            result.extend(self.cells[key])\n                        return\n                    for v in range(low[len(idx)], high[len(idx)]+1):\n                        idx.append(v)\n                        recursive_collect(idx)\n                        idx.pop()\n                recursive_collect()\n                return result\n            def clear(self):\n                self.cells.clear()\n\n        # Adaptive neighbor radius scales with node count and best cost\n        def adaptive_radius(n_nodes, c_best):\n            if n_nodes <= 1:\n                return step_size * 4.0\n            gamma = self.n_near_const\n            base_r = min((gamma*(math.log(n_nodes)/n_nodes))**(1/dim), step_size * 6.0)\n            if c_best == float('inf'):\n                return base_r\n            shrink = max(0.3, c_best/(c_min * 3.0))\n            return max(step_size * 0.8, base_r * shrink)\n\n        # Ellipsoidal informed sampling concentrates search inside informed subset after solution\n        def sample_informed(c_best):\n            if c_best == float('inf') or c_min < 1e-12:\n                # uniform random sample inside bounds\n                return tuple(random.uniform(0.0, bounds[i]) for i in range(dim))\n            center = tuple((start[i] + goal[i]) * 0.5 for i in range(dim))\n            diff = [goal[i] - start[i] for i in range(dim)]\n            norm_diff = math.sqrt(sum(x*x for x in diff))\n            if norm_diff < 1e-14:\n                return tuple(random.uniform(0.0, bounds[i]) for i in range(dim))\n            unit_dir = [x / norm_diff for x in diff]\n            # build orthonormal basis U\n            U = [unit_dir]\n            for idx in range(dim - 1):\n                base = [0.0]*dim\n                base[(idx + 1) % dim] = 1.0\n                for u in U:\n                    proj = sum(base[j]*u[j] for j in range(dim))\n                    base = [base[j] - proj*u[j] for j in range(dim)]\n                norm_base = math.sqrt(sum(x*x for x in base))\n                if norm_base > 1e-14:\n                    U.append([x/norm_base for x in base])\n                else:\n                    U.append([0.0]*dim)\n            r1 = c_best * 0.5\n            val = c_best*c_best - c_min*c_min\n            r2 = math.sqrt(val)*0.5 if val > 0 else 0.0\n            radii = [r1] + [r2]*(dim - 1)\n\n            max_attempts = 40\n            for _ in range(max_attempts):\n                x_ball = [random.gauss(0,1) for _ in range(dim)]\n                norm_ball = math.sqrt(sum(x*x for x in x_ball))\n                if norm_ball < 1e-14:\n                    continue\n                unit_ball = [x/norm_ball for x in x_ball]\n                scale = random.random() ** (1/dim)\n                point_ball = [coord*scale for coord in unit_ball]\n                mapped = [0.0]*dim\n                for i_ in range(dim):\n                    for j_ in range(dim):\n                        mapped[j_] += radii[i_] * point_ball[i_] * U[i_][j_]\n                sample = tuple(center[i] + mapped[i] for i in range(dim))\n                if all(0.0 <= sample[i] <= bounds[i] for i in range(dim)) and not in_obstacle(sample):\n                    return sample\n            # fallback uniform\n            return tuple(random.uniform(0.0, bounds[i]) for i in range(dim))\n\n        # Helper to retrieve path from two nodes meeting\n        def connect_path(n1, n2):\n            path1 = n1.path_from_root()\n            path2 = n2.path_from_root()[::-1]\n            if path1[-1] == path2[0]:\n                return path1 + path2[1:]\n            return path1 + path2\n\n        # Curvature penalty encourages smooth transitions: angle between segments in radians\n        def curvature_penalty(p_parent, p_last, p_new):\n            if p_parent is None:\n                return 0.0\n            v1 = tuple(p_last[i]-p_parent[i] for i in range(dim))\n            v2 = tuple(p_new[i]-p_last[i] for i in range(dim))\n            len1 = math.sqrt(sum(x*x for x in v1))\n            len2 = math.sqrt(sum(x*x for x in v2))\n            if len1 < 1e-14 or len2 < 1e-14:\n                return 0.0\n            dot = sum(v1[i]*v2[i] for i in range(dim)) / (len1 * len2)\n            dot = max(-1.0, min(1.0, dot))\n            return math.acos(dot)\n\n        # Multi-pass shortcutting to smooth and shorten paths\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path[:]\n            path = list(path)\n            changed = True\n            iter_count = 0\n            max_iters = self.shortcut_iters\n            while changed and iter_count < max_iters:\n                changed = False\n                iter_count += 1\n                i = 0\n                while i < len(path) - 2:\n                    max_j = min(len(path) - 1, i + 8 + random.randint(0,3))\n                    if max_j <= i + 1:\n                        i += 1\n                        continue\n                    j = random.randint(i+2, max_j)\n                    if not edge_obstacle(path[i], path[j]):\n                        path = path[:i+1] + path[j:]\n                        changed = True\n                        break\n                    i += 1\n            return path\n\n        # Initialization of trees and grid\n        start_root = Node(start, cost=0.0)\n        goal_root = Node(goal, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        all_nodes = [start_root, goal_root]\n        edges = []\n\n        grid_start = SpatialGrid(bounds, self.grid_cell_size, dim)\n        grid_goal = SpatialGrid(bounds, self.grid_cell_size, dim)\n        grid_start.insert(start_root)\n        grid_goal.insert(goal_root)\n\n        c_min = dist(start, goal)\n        best_cost = float('inf')\n        best_path = []\n        found_solution = False\n        no_improve_count = 0\n        last_best_cost = float('inf')\n        alpha_curv = 0.03\n\n        for it in range(self.max_iter):\n            sample = sample_informed(best_cost if found_solution else float('inf'))\n\n            tree_a, grid_a, tree_b, grid_b = (tree_start, grid_start, tree_goal, grid_goal) if it % 2 == 0 else (tree_goal, grid_goal, tree_start, grid_start)\n\n            # Candidate nearest neighbors in grid to sample\n            candidates = grid_a.neighbors(sample, step_size * 2.0)\n            if candidates:\n                nearest = min(candidates, key=lambda n: dist(n.position, sample))\n            else:\n                nearest = min(tree_a, key=lambda n: dist(n.position, sample))\n\n            new_pos = steer(nearest.position, sample, step_size)\n            if not in_bounds(new_pos) or in_obstacle(new_pos) or edge_obstacle(nearest.position, new_pos):\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n                continue\n\n            n_nodes = len(all_nodes)\n            radius = adaptive_radius(n_nodes, best_cost)\n\n            neighbors_in_radius = [n for n in grid_a.neighbors(new_pos, radius) if dist(n.position, new_pos) <= radius]\n\n            # Choose parent minimizing cost + curvature penalty\n            min_score = nearest.cost + dist(nearest.position, new_pos)\n            curv_pen = alpha_curv * curvature_penalty(nearest.parent.position if nearest.parent else None, nearest.position, new_pos)\n            min_score += curv_pen\n            best_parent = nearest\n            best_cost_to_new = min_score - curv_pen\n\n            for candidate in neighbors_in_radius:\n                if candidate == nearest:\n                    continue\n                if edge_obstacle(candidate.position, new_pos):\n                    continue\n                tmp_cost = candidate.cost + dist(candidate.position, new_pos)\n                curv_cand = alpha_curv * curvature_penalty(candidate.parent.position if candidate.parent else None, candidate.position, new_pos)\n                score_cand = tmp_cost + curv_cand\n                if score_cand + self.improve_tol < min_score:\n                    best_parent = candidate\n                    best_cost_to_new = tmp_cost\n                    min_score = score_cand\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = best_cost_to_new\n            tree_a.append(new_node)\n            all_nodes.append(new_node)\n            edges.append((best_parent, new_node))\n            grid_a.insert(new_node)\n\n            # Rewire neighbors to possibly reduce cost with curvature penalty constraints\n            for nb in neighbors_in_radius:\n                if nb == best_parent or nb == new_node:\n                    continue\n                alt_cost = new_node.cost + dist(new_node.position, nb.position)\n                if alt_cost + self.improve_tol < nb.cost:\n                    if not edge_obstacle(new_node.position, nb.position):\n                        # Compare curvature penalty for rewiring allowance\n                        curv_new = curvature_penalty(new_node.parent.position if new_node.parent else None, new_node.position, nb.position)\n                        curv_old = curvature_penalty(nb.parent.parent.position if nb.parent and nb.parent.parent else None,\n                                                    nb.parent.position if nb.parent else None,\n                                                    nb.position)\n                        if alpha_curv * curv_new <= alpha_curv * curv_old + 0.18:\n                            if nb.parent:\n                                nb.parent.remove_child(nb)\n                                try:\n                                    edges.remove((nb.parent, nb))\n                                except:\n                                    pass\n                            new_node.add_child(nb)\n                            nb.cost = alt_cost\n                            edges.append((new_node, nb))\n\n            # Attempt connect new_node with nodes of other tree inside radius\n            candidates_b = grid_b.neighbors(new_node.position, radius)\n            nearest_b = None\n            nearest_dist = float('inf')\n            for nb_node in candidates_b:\n                d_nb = dist(nb_node.position, new_node.position)\n                if d_nb < nearest_dist:\n                    nearest_dist = d_nb\n                    nearest_b = nb_node\n            if nearest_b and nearest_dist <= step_size and not edge_obstacle(new_node.position, nearest_b.position):\n                candidate_path = connect_path(new_node, nearest_b)\n                cost_connect = new_node.cost + dist(new_node.position, nearest_b.position) + nearest_b.cost\n                if cost_connect + self.improve_tol < best_cost:\n                    best_cost = cost_connect\n                    best_path = candidate_path\n                    found_solution = True\n                    no_improve_count = 0\n                else:\n                    no_improve_count += 1\n            elif found_solution:\n                no_improve_count += 1\n\n            if found_solution and no_improve_count >= self.max_no_improve:\n                break\n\n            if found_solution and best_cost + self.improve_tol < last_best_cost:\n                last_best_cost = best_cost\n                no_improve_count = 0\n\n        # Post-processing path smoothing with multi-pass shortcutting\n        if found_solution and len(best_path) > 3:\n            for _ in range(4):\n                best_path = shortcut_path(best_path)\n\n        if found_solution:\n            return PlannerResult(True, best_path, all_nodes, edges)\n        else:\n            return PlannerResult(False, [], all_nodes, edges)",
          "objective": -30.76555,
          "time_improvement": 45.0,
          "length_improvement": 14.0,
          "smoothness_improvement": 1809.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.02610607147216797,
                    "num_nodes_avg": 160.5,
                    "path_length_avg": 168.9755502828832,
                    "smoothness_avg": 0.045653219129898524,
                    "success_improvement": 0.0,
                    "time_improvement": -7.496821633508575,
                    "length_improvement": 7.3818233010107,
                    "smoothness_improvement": 614.572016935004,
                    "objective_score": 5.252907575228868
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.0313495397567749,
                    "num_nodes_avg": 281.9,
                    "path_length_avg": 241.80590666243202,
                    "smoothness_avg": 0.12894467947637372,
                    "success_improvement": 0.0,
                    "time_improvement": 80.58434420933136,
                    "length_improvement": 19.27822835896443,
                    "smoothness_improvement": 3217.839478025683,
                    "objective_score": 51.83143766830648
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.018782854080200195,
                    "num_nodes_avg": 205.8,
                    "path_length_avg": 128.95878155839154,
                    "smoothness_avg": 0.1333351501954944,
                    "success_improvement": 0.0,
                    "time_improvement": 62.07072530752751,
                    "length_improvement": 14.351717646199976,
                    "smoothness_improvement": 1596.0132687096545,
                    "objective_score": 35.21231452352651
               }
          ],
          "success_rate": 1.0
     }
]