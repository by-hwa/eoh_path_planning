[
     {
          "operator": "m3",
          "algorithm_description": "A simplified bidirectional RRT* planner with adaptive neighborhood radius, heuristic-informed sampling inside ellipsoidal bounds after first solution, and efficient rewiring that balances exploration and refinement. The algorithm alternates expansions between start and goal trees, prunes via cost-aware rewiring with radius scaled to tree size, and performs iterative shortcut smoothing on the result to improve path length and smoothness while limiting planning time with stagnation-based early stopping.",
          "planning_mechanism": "This planner grows two trees from start and goal, samples points uniformly initially, and after first solution focuses samples inside a heuristic ellipsoid bounding shorter solutions. Nodes are added using a steer function, parents are chosen among neighbors within a radius that decays adaptively with iteration count and tree size, and rewiring lowers path costs. Connection attempts bridge trees incrementally. Post planning applies iterative shortcut smoothing removing redundant points and reducing unnecessary detours, producing shorter, smoother paths faster than naive RRT*.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=4000, step_size=6.0, radius_max=25.0, radius_min=7.0, no_improve_limit=60, time_limit=25.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.radius_max = radius_max\n        self.radius_min = radius_min\n        self.no_improve_limit = no_improve_limit\n        self.time_limit = time_limit\n\n    def plan(self, map):\n        import time\n        import math\n        import random\n\n        bounds = map.size\n        dim = len(bounds)\n        start = tuple(map.start)\n        goal = tuple(map.goal)\n        obstacles = map.obstacles\n        is_3d = (dim == 3)\n\n        def in_bounds(p):\n            return all(0.0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def in_obstacle(p):\n            px, py, pz = (p + (0, 0, 0))[:3]\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    if x <= px <= x+w and y <= py <= y+h:\n                        return True\n            return False\n\n        def edge_in_obstacle(a, b, resolution=1.0):\n            dist = math.dist(a,b)\n            if dist < 1e-12:\n                return False\n            steps = max(3, int(dist/resolution))\n            for i in range(steps+1):\n                pt = tuple(a[d] + (b[d]-a[d]) * i/steps for d in range(dim))\n                if in_obstacle(pt):\n                    return True\n            return False\n\n        def steer(frm, to):\n            dist = math.dist(frm, to)\n            if dist <= self.step_size:\n                return to\n            ratio = self.step_size / dist\n            return tuple(frm[d] + (to[d]-frm[d]) * ratio for d in range(dim))\n\n        def adaptive_radius(n_nodes, iter_i):\n            if n_nodes < 2:\n                return self.radius_max\n            r = self.radius_max * ((math.log(n_nodes) / n_nodes) ** (1/dim))\n            decay = max(self.radius_min / self.radius_max, 1.0 - 0.9 * (iter_i / self.max_iter))\n            return max(self.radius_min, min(r * decay, self.radius_max))\n\n        def neighbors(tree, pos, radius):\n            r_sq = radius * radius\n            res = []\n            for node in tree:\n                d_sq = 0.0\n                for i in range(dim):\n                    diff = node.position[i] - pos[i]\n                    d_sq += diff*diff\n                    if d_sq > r_sq:\n                        break\n                else:\n                    res.append(node)\n            return res\n\n        def choose_parent(tree, new_pos, iter_i):\n            radius = adaptive_radius(len(tree), iter_i)\n            nbrs = neighbors(tree, new_pos, radius)\n            valid_parents = [n for n in nbrs if not edge_in_obstacle(n.position, new_pos)]\n            if not valid_parents:\n                # fallback nearest with collision\n                nearest = min((n for n in tree if not edge_in_obstacle(n.position, new_pos)), key=lambda n: math.dist(n.position, new_pos), default=None)\n                if nearest is None:\n                    return None, []\n                c = nearest.cost + math.dist(nearest.position, new_pos)\n                new_node = Node(new_pos, parent=nearest, cost=c)\n                nearest.add_child(new_node)\n                tree.append(new_node)\n                return new_node, []\n            best_parent = min(valid_parents, key=lambda n: n.cost + math.dist(n.position, new_pos))\n            c = best_parent.cost + math.dist(best_parent.position, new_pos)\n            new_node = Node(new_pos, parent=best_parent, cost=c)\n            best_parent.add_child(new_node)\n            tree.append(new_node)\n            return new_node, valid_parents\n\n        def rewire(pivot, nbrs):\n            for nb in nbrs:\n                if nb == pivot.parent:\n                    continue\n                dist_p = math.dist(pivot.position, nb.position)\n                new_cost = pivot.cost + dist_p\n                if new_cost + 1e-10 < nb.cost and not edge_in_obstacle(pivot.position, nb.position):\n                    if nb.parent:\n                        nb.parent.remove_child(nb)\n                    pivot.add_child(nb)\n                    nb.cost = new_cost\n\n        def attempt_connect(tree, target_node):\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda n: math.dist(n.position, target_node.position))\n            dist = math.dist(nearest.position, target_node.position)\n            if dist <= self.step_size:\n                if edge_in_obstacle(nearest.position, target_node.position) or in_obstacle(target_node.position):\n                    return None\n                new_node = Node(target_node.position, parent=nearest, cost=nearest.cost + dist)\n                nearest.add_child(new_node)\n                tree.append(new_node)\n                return new_node\n            current = nearest\n            steps = int(math.ceil(dist / self.step_size))\n            for _ in range(steps):\n                new_pos = steer(current.position, target_node.position)\n                if not in_bounds(new_pos) or in_obstacle(new_pos) or edge_in_obstacle(current.position, new_pos):\n                    return None\n                new_node = Node(new_pos, parent=current, cost=current.cost + math.dist(current.position, new_pos))\n                current.add_child(new_node)\n                tree.append(new_node)\n                current = new_node\n                if math.dist(current.position, target_node.position) <= self.step_size:\n                    if edge_in_obstacle(current.position, target_node.position) or in_obstacle(target_node.position):\n                        return None\n                    final_node = Node(target_node.position, parent=current, cost=current.cost + math.dist(current.position, target_node.position))\n                    current.add_child(final_node)\n                    tree.append(final_node)\n                    return final_node\n            return None\n\n        def sample_uniform():\n            return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        def sample_informed(c_best, c_min):\n            if c_best == float('inf') or c_min < 1e-12:\n                return sample_uniform()\n            center = tuple((start[d]+goal[d])*0.5 for d in range(dim))\n            unit_vec = []\n            for d in range(dim):\n                unit_vec.append((goal[d] - start[d]) / c_min)\n            r1 = c_best * 0.5\n            val = max(c_best*c_best - c_min*c_min, 0.0)\n            r_other = math.sqrt(val)*0.5\n\n            if dim == 2:\n                a1 = unit_vec\n                a2 = (-a1[1], a1[0])\n                basis = (a1, a2)\n                radii = (r1, r_other)\n            else:\n                def cross(u,v):\n                    return (u[1]*v[2]-u[2]*v[1], u[2]*v[0]-u[0]*v[2], u[0]*v[1]-u[1]*v[0])\n                def norm(v):\n                    return math.sqrt(sum(x*x for x in v))\n                a1 = unit_vec\n                ref = (1,0,0) if abs(a1[0]) < 0.9 else (0,1,0)\n                b2 = cross(a1, ref)\n                nb2 = norm(b2)\n                if nb2 < 1e-12:\n                    ref = (0,0,1)\n                    b2 = cross(a1, ref)\n                    nb2 = norm(b2)\n                b2 = tuple(x/nb2 for x in b2)\n                b3 = cross(a1,b2)\n                basis = (a1,b2,b3)\n                radii = (r1,r_other,r_other)\n\n            def sample_unit_ball(ndim):\n                while True:\n                    vec = [random.gauss(0,1) for _ in range(ndim)]\n                    nrm = math.sqrt(sum(v*v for v in vec))\n                    if nrm < 1e-12:\n                        continue\n                    vec = [v/nrm for v in vec]\n                    r = random.random()**(1/ndim)\n                    return [v*r for v in vec]\n\n            u = sample_unit_ball(dim)\n            mapped = []\n            for d in range(dim):\n                v = center[d]\n                for i in range(dim):\n                    v += basis[i][d]*radii[i]*u[i]\n                # Clamp to bounds\n                v = max(0.0, min(bounds[d], v))\n                mapped.append(v)\n            return tuple(mapped)\n\n        def shortcut_smooth(path, iterations=3):\n            if len(path) < 3:\n                return path[:]\n            for _ in range(iterations):\n                i = 0\n                while i < len(path)-2:\n                    if not edge_in_obstacle(path[i], path[i+2]):\n                        del path[i+1]\n                    else:\n                        i += 1\n            return path\n\n        start_node = Node(start, cost=0.0)\n        goal_node = Node(goal, cost=0.0)\n        start_tree = [start_node]\n        goal_tree = [goal_node]\n        nodes = [start_node, goal_node]\n        edges = []\n\n        best_path = []\n        best_cost = float('inf')\n        c_min = math.dist(start, goal)\n        found = False\n        no_improve = 0\n        t_start = time.time()\n\n        for i in range(self.max_iter):\n            if time.time() - t_start > self.time_limit:\n                break\n            if found:\n                sample = sample_informed(best_cost, c_min)\n                if random.random() < 0.1:\n                    sample = sample_uniform()\n            else:\n                sample = sample_uniform()\n\n            if not in_bounds(sample) or in_obstacle(sample):\n                if found:\n                    no_improve += 1\n                    if no_improve >= self.no_improve_limit:\n                        break\n                continue\n\n            tree_a, tree_b = (start_tree, goal_tree) if i%2 == 0 else (goal_tree, start_tree)\n\n            near = min(tree_a, key=lambda n: math.dist(n.position, sample))\n            new_pos = steer(near.position, sample)\n\n            if (not in_bounds(new_pos)) or in_obstacle(new_pos) or edge_in_obstacle(near.position, new_pos):\n                if found:\n                    no_improve += 1\n                    if no_improve >= self.no_improve_limit:\n                        break\n                continue\n\n            new_node, nbrs = choose_parent(tree_a, new_pos, i)\n            if new_node is None:\n                if found:\n                    no_improve += 1\n                    if no_improve >= self.no_improve_limit:\n                        break\n                continue\n\n            rewire(new_node, nbrs)\n            nodes.append(new_node)\n            if new_node.parent:\n                edges.append((new_node.parent, new_node))\n\n            connected = attempt_connect(tree_b, new_node)\n            if connected:\n                if i % 2 == 0:\n                    path1 = new_node.path_from_root()\n                    path2 = connected.path_from_root()\n                else:\n                    path1 = connected.path_from_root()\n                    path2 = new_node.path_from_root()\n                if path1 and path2 and path1[-1] == path2[-1]:\n                    candidate = path1 + path2[-2::-1]\n                else:\n                    candidate = path1 + path2[::-1]\n\n                cost_path = 0.0\n                for j in range(len(candidate)-1):\n                    cost_path += math.dist(candidate[j], candidate[j+1])\n\n                if cost_path + 1e-9 < best_cost:\n                    best_path = candidate\n                    best_cost = cost_path\n                    found = True\n                    no_improve = 0\n                else:\n                    no_improve += 1\n                    if no_improve >= self.no_improve_limit:\n                        break\n            else:\n                if found:\n                    no_improve += 1\n                    if no_improve >= self.no_improve_limit:\n                        break\n\n        if found and len(best_path) >= 3:\n            best_path = shortcut_smooth(best_path, iterations=5)\n\n        return PlannerResult(success=found, path=best_path, nodes=nodes, edges=edges)",
          "objective": -37.48589,
          "time_improvement": 65.0,
          "length_improvement": 16.0,
          "smoothness_improvement": 1704.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.015254044532775879,
                    "num_nodes_avg": 101.3,
                    "path_length_avg": 165.81254021340436,
                    "smoothness_avg": 0.05533273154630356,
                    "success_improvement": 0.0,
                    "time_improvement": 37.18850781215486,
                    "length_improvement": 9.115519241194,
                    "smoothness_improvement": 766.0774056493822,
                    "objective_score": 20.45625091660977
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.021648097038269042,
                    "num_nodes_avg": 222.5,
                    "path_length_avg": 236.7791727604512,
                    "smoothness_avg": 0.1135825828084687,
                    "success_improvement": 0.0,
                    "time_improvement": 86.59272181094168,
                    "length_improvement": 20.956296821958638,
                    "smoothness_improvement": 2822.561665889502,
                    "objective_score": 52.6644029659052
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.01422429084777832,
                    "num_nodes_avg": 175.1,
                    "path_length_avg": 124.63481867684409,
                    "smoothness_avg": 0.1276752449373225,
                    "success_improvement": 0.0,
                    "time_improvement": 71.27608868346934,
                    "length_improvement": 17.223487907137493,
                    "smoothness_improvement": 1524.0196915964568,
                    "objective_score": 39.337017807305585
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "A streamlined bidirectional RRT* planner with adaptive neighbor radius, hybrid uniform and ellipsoidal informed sampling guiding exploration toward promising solution regions, faster nearest neighbor pruning based on adaptive radius to reduce redundant rewires, and an efficient iterative path shortcutting for improved path quality and smoothness. Early termination on solution stagnation balances runtime and exploration thoroughness.",
          "planning_mechanism": "The planner grows two trees alternately from start and goal by steering toward sampled points, choosing parents among neighbors within an adaptive radius to minimize cost efficiently, rewiring to improve connectivity with pruning via adaptive radius neighbors, attempts to connect the two trees incrementally, uses hybrid sampling that switches to an ellipsoidal informed distribution after finding a solution, and finally applies iterative shortcut smoothing for path refinement. Early stopping on no improvement enhances computational efficiency.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=3500, step_size=4.0, radius_max=18.0, radius_min=5.0,\n                 no_improve_limit=50, shortcut_iter=120):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.radius_max = radius_max\n        self.radius_min = radius_min\n        self.no_improve_limit = no_improve_limit\n        self.shortcut_iter = shortcut_iter\n\n    def plan(self, map):\n        import math\n        import time\n        import random\n\n        start = tuple(map.start)\n        goal = tuple(map.goal)\n        bounds = tuple(map.size)\n        obstacles = map.obstacles\n        dim = len(bounds)\n\n        def in_bounds(p):\n            return all(0.0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def in_obstacle(p):\n            px, py, pz = (p + (0, 0, 0))[:3]\n            for obs in obstacles:\n                if dim == 3:\n                    ox, oy, oz, ow, oh, od = obs\n                    if ox <= px <= ox + ow and oy <= py <= oy + oh and oz <= pz <= oz + od:\n                        return True\n                else:\n                    ox, oy, ow, oh = obs\n                    if ox <= px <= ox + ow and oy <= py <= oy + oh:\n                        return True\n            return False\n\n        def edge_in_obstacle(a, b, resolution=1.0):\n            dist_ab = math.dist(a, b)\n            if dist_ab < 1e-12:\n                return False\n            steps = max(2, int(dist_ab / resolution))\n            for i in range(steps + 1):\n                pt = tuple(a[d] + (b[d] - a[d]) * i / steps for d in range(dim))\n                if in_obstacle(pt):\n                    return True\n            return False\n\n        def steer(frm, to):\n            dist_ = math.dist(frm, to)\n            if dist_ <= self.step_size:\n                return to\n            ratio = self.step_size / dist_\n            return tuple(frm[i] + (to[i] - frm[i]) * ratio for i in range(dim))\n\n        def adaptive_radius(n_nodes, iter_i):\n            if n_nodes < 2:\n                return self.radius_max\n            r = self.radius_max * ((math.log(n_nodes) / n_nodes) ** (1 / dim))\n            decay = max(self.radius_min / self.radius_max, 1.0 - 0.85 * (iter_i / self.max_iter))\n            return max(self.radius_min, min(r * decay, self.radius_max))\n\n        def neighbors(tree, point, radius):\n            r_sq = radius * radius\n            nbrs = []\n            for node in tree:\n                d_sq = 0.0\n                for i in range(dim):\n                    diff = node.position[i] - point[i]\n                    d_sq += diff * diff\n                    if d_sq > r_sq:\n                        break\n                else:\n                    nbrs.append(node)\n            return nbrs\n\n        def choose_parent(tree, new_pos, iter_i):\n            n_nodes = len(tree)\n            radius = adaptive_radius(n_nodes, iter_i)\n            nbrs = neighbors(tree, new_pos, radius)\n            valid_parents = [n for n in nbrs if not edge_in_obstacle(n.position, new_pos)]\n            if not valid_parents:\n                # fallback to nearest with edge check\n                nearest = None\n                nearest_dist = float('inf')\n                for n in tree:\n                    d = math.dist(n.position, new_pos)\n                    if d < nearest_dist and not edge_in_obstacle(n.position, new_pos):\n                        nearest = n\n                        nearest_dist = d\n                if nearest is None:\n                    return None, []\n                cost = nearest.cost + nearest_dist\n                new_node = Node(new_pos, parent=nearest, cost=cost)\n                nearest.add_child(new_node)\n                tree.append(new_node)\n                return new_node, []\n            best_parent = min(valid_parents, key=lambda p: p.cost + math.dist(p.position, new_pos))\n            min_cost = best_parent.cost + math.dist(best_parent.position, new_pos)\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree.append(new_node)\n            return new_node, valid_parents\n\n        def rewire(pivot, nbrs):\n            for nb in nbrs:\n                if nb is pivot.parent:\n                    continue\n                dist_p_nb = math.dist(pivot.position, nb.position)\n                new_cost = pivot.cost + dist_p_nb\n                if new_cost + 1e-12 < nb.cost and not edge_in_obstacle(pivot.position, nb.position):\n                    if nb.parent:\n                        nb.parent.remove_child(nb)\n                    pivot.add_child(nb)\n                    nb.cost = new_cost\n\n        def attempt_connect(tree, target_node):\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda n: math.dist(n.position, target_node.position))\n            dist_ = math.dist(nearest.position, target_node.position)\n            if dist_ <= self.step_size:\n                if edge_in_obstacle(nearest.position, target_node.position) or in_obstacle(target_node.position):\n                    return None\n                new_node = Node(target_node.position, parent=nearest, cost=nearest.cost + dist_)\n                nearest.add_child(new_node)\n                tree.append(new_node)\n                return new_node\n            current = nearest\n            steps = int(math.ceil(dist_ / self.step_size))\n            for _ in range(steps):\n                new_pos = steer(current.position, target_node.position)\n                if (not in_bounds(new_pos)) or in_obstacle(new_pos) or edge_in_obstacle(current.position, new_pos):\n                    return None\n                new_node = Node(new_pos, parent=current, cost=current.cost + math.dist(current.position, new_pos))\n                current.add_child(new_node)\n                tree.append(new_node)\n                current = new_node\n                if math.dist(current.position, target_node.position) <= self.step_size:\n                    if edge_in_obstacle(current.position, target_node.position) or in_obstacle(target_node.position):\n                        return None\n                    final_node = Node(target_node.position, parent=current, cost=current.cost + math.dist(current.position, target_node.position))\n                    current.add_child(final_node)\n                    tree.append(final_node)\n                    return final_node\n            return None\n\n        def sample_uniform():\n            return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        def ellipsoid_sample(c_best, c_min):\n            if c_best == float('inf') or c_min < 1e-12:\n                return sample_uniform()\n            center = tuple((start[d] + goal[d]) / 2 for d in range(dim))\n            a1 = [goal[d] - start[d] for d in range(dim)]\n            norm_a1 = math.sqrt(sum(x * x for x in a1))\n            if norm_a1 < 1e-15:\n                return sample_uniform()\n            unit_a1 = [x / norm_a1 for x in a1]\n            # construct orthonormal basis via Gram-Schmidt\n            basis = [unit_a1]\n            for idx in range(dim - 1):\n                base = [0.0] * dim\n                base[(idx + 1) % dim] = 1.0\n                for b in basis:\n                    proj = sum(base[j] * b[j] for j in range(dim))\n                    base = [base[j] - proj * b[j] for j in range(dim)]\n                norm_base = math.sqrt(sum(x * x for x in base))\n                if norm_base > 1e-15:\n                    base = [x / norm_base for x in base]\n                else:\n                    base = [0.0] * dim\n                basis.append(base)\n            r1 = c_best * 0.5\n            val = c_best * c_best - c_min * c_min\n            r_orth = math.sqrt(val) * 0.5 if val > 0 else 0.0\n            radii = [r1] + [r_orth] * (dim - 1)\n            for _ in range(30):\n                # sample unit ball\n                x_ball = [random.gauss(0., 1.) for _ in range(dim)]\n                norm_ball = math.sqrt(sum(x * x for x in x_ball))\n                if norm_ball < 1e-15:\n                    continue\n                unit_ball = [xx / norm_ball for xx in x_ball]\n                u = random.random() ** (1.0 / dim)\n                point_ball = [coord * u for coord in unit_ball]\n                # scale and rotate\n                sample_point = [0.0] * dim\n                for i_ in range(dim):\n                    for j_ in range(dim):\n                        sample_point[j_] += point_ball[i_] * radii[i_] * basis[i_][j_]\n                sample = tuple(max(0.0, min(center[i] + sample_point[i], bounds[i])) for i in range(dim))\n                if not in_obstacle(sample):\n                    return sample\n            return sample_uniform()\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return list(path)\n            path = list(path)\n            for _ in range(self.shortcut_iter):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if not edge_in_obstacle(path[i], path[j]):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        start_node = Node(start, cost=0.0)\n        goal_node = Node(goal, cost=0.0)\n        start_tree = [start_node]\n        goal_tree = [goal_node]\n        nodes = [start_node, goal_node]\n        edges = []\n\n        best_path = []\n        best_cost = float('inf')\n        c_min = math.dist(start, goal)\n        found_solution = False\n        no_improve_count = 0\n\n        start_time = time.time()\n\n        for iter_i in range(self.max_iter):\n            if found_solution:\n                sample = ellipsoid_sample(best_cost, c_min)\n                if random.random() < 0.2:\n                    sample = sample_uniform()\n            else:\n                sample = sample_uniform()\n\n            if not in_bounds(sample) or in_obstacle(sample):\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.no_improve_limit:\n                        break\n                continue\n\n            tree_a, tree_b = (start_tree, goal_tree) if iter_i % 2 == 0 else (goal_tree, start_tree)\n\n            nearest_node = min(tree_a, key=lambda n: math.dist(n.position, sample))\n            new_pos = steer(nearest_node.position, sample)\n            if not in_bounds(new_pos) or in_obstacle(new_pos) or edge_in_obstacle(nearest_node.position, new_pos):\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.no_improve_limit:\n                        break\n                continue\n\n            new_node, nbrs = choose_parent(tree_a, new_pos, iter_i)\n            if not new_node:\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.no_improve_limit:\n                        break\n                continue\n\n            rewire(new_node, nbrs)\n            nodes.append(new_node)\n            if new_node.parent:\n                edges.append((new_node.parent, new_node))\n\n            connect_node = attempt_connect(tree_b, new_node)\n            if connect_node:\n                if iter_i % 2 == 0:\n                    path_a = new_node.path_from_root()\n                    path_b = connect_node.path_from_root()\n                else:\n                    path_a = connect_node.path_from_root()\n                    path_b = new_node.path_from_root()\n\n                if path_a and path_b and path_a[-1] == path_b[-1]:\n                    candidate_path = path_a + path_b[-2::-1]\n                else:\n                    candidate_path = path_a + path_b[::-1]\n\n                total_cost = 0.0\n                for i in range(len(candidate_path) - 1):\n                    total_cost += math.dist(candidate_path[i], candidate_path[i + 1])\n\n                if total_cost + 1e-9 < best_cost:\n                    best_cost = total_cost\n                    best_path = candidate_path\n                    found_solution = True\n                    no_improve_count = 0\n                else:\n                    no_improve_count += 1\n                    if no_improve_count >= self.no_improve_limit:\n                        break\n            else:\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.no_improve_limit:\n                        break\n\n        if found_solution and len(best_path) >= 3:\n            best_path = shortcut_path(best_path)\n\n        return PlannerResult(success=found_solution, path=best_path, nodes=nodes, edges=edges)",
          "objective": -35.35386,
          "time_improvement": 56.0,
          "length_improvement": 17.0,
          "smoothness_improvement": 1654.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.015592575073242188,
                    "num_nodes_avg": 99.9,
                    "path_length_avg": 159.4495060769605,
                    "smoothness_avg": 0.03886240016513557,
                    "success_improvement": 0.0,
                    "time_improvement": 35.79454253611557,
                    "length_improvement": 12.603199080107105,
                    "smoothness_improvement": 508.28095363705586,
                    "objective_score": 20.841686977084215
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.033257794380187986,
                    "num_nodes_avg": 302.3,
                    "path_length_avg": 238.8612478430386,
                    "smoothness_avg": 0.11894377823211089,
                    "success_improvement": 0.0,
                    "time_improvement": 79.40250820100103,
                    "length_improvement": 20.261240230182576,
                    "smoothness_improvement": 2960.509085652796,
                    "objective_score": 50.78004202667384
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.02319345474243164,
                    "num_nodes_avg": 256.8,
                    "path_length_avg": 122.89703464593951,
                    "smoothness_avg": 0.1252212284453279,
                    "success_improvement": 0.0,
                    "time_improvement": 53.16415107965624,
                    "length_improvement": 18.377641316081167,
                    "smoothness_improvement": 1492.804782954941,
                    "objective_score": 34.439854028320276
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m2",
          "algorithm_description": "An enhanced bidirectional RRT* inspired planner employing consistent neighbor radius scaling based on node count and dimension, spatial hashing for efficient neighbor search, adaptive informed sampling within an ellipsoid post initial solution, dynamic rewiring without lazy checks, and a multi-pass systematic path shortcutting routine. The planner alternates expansion between start and goal trees, continuously attempts to directly connect trees, and halts early upon stagnation. This design improves search efficiency, robust path quality, shorter path length, and smoother final routes through comprehensive rewiring and effective path smoothing.",
          "planning_mechanism": "The planner grows two trees alternating expansions, using spatial hash grids for neighbor queries and sampling progressively within an informed ellipsoid after a first solution is found. For each new node, it selects the parent minimizing cost with thorough collision checks and rewires neighbors to improve paths. Direct connections between trees are attempted to merge routes efficiently. Finally, a multi-pass systematic shortcutting smooths and shortens the path. Early stopping is applied to terminate when no improvements occur, leading to faster convergence and strong path quality.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=4000, step_size=5.5,\n                 max_radius=28.0, min_radius=5.5,\n                 max_no_improve=70, time_limit=25.0,\n                 shortcut_iter=180):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.max_radius = max_radius\n        self.min_radius = min_radius\n        self.max_no_improve = max_no_improve\n        self.time_limit = time_limit\n        self.shortcut_iter = shortcut_iter\n\n    def plan(self, map):\n        import math\n        import random\n        import time\n\n        start = tuple(map.start)\n        goal = tuple(map.goal)\n        bounds = tuple(map.size)\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        dist = lambda a,b: math.dist(a, b)\n\n        def in_bounds(pos):\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def in_obstacle(pos):\n            if is_3d:\n                px, py, pz = pos\n                for obs in obstacles:\n                    ox, oy, oz, ow, oh, od = obs\n                    if ox <= px <= ox + ow and oy <= py <= oy + oh and oz <= pz <= oz + od:\n                        return True\n                return False\n            else:\n                px, py = pos\n                for obs in obstacles:\n                    ox, oy, ow, oh = obs\n                    if ox <= px <= ox + ow and oy <= py <= oy + oh:\n                        return True\n                return False\n\n        def edge_in_obstacle(a, b, res=1.0):\n            d = dist(a, b)\n            if d < 1e-12:\n                return False\n            steps = max(2, int(d / res))\n            for i in range(steps+1):\n                interp = tuple(a[d_] + (b[d_] - a[d_]) * i / steps for d_ in range(dim))\n                if in_obstacle(interp):\n                    return True\n            return False\n\n        def steer(from_p, to_p):\n            d = dist(from_p, to_p)\n            if d <= self.step_size:\n                return to_p\n            ratio = self.step_size / d\n            return tuple(from_p[d_] + (to_p[d_] - from_p[d_]) * ratio for d_ in range(dim))\n\n        # Spatial hash grid class to accelerate neighbor queries\n        class SpatialGrid:\n            def __init__(self, bounds, cell_size, dim):\n                self.bounds = bounds\n                self.cell_size = cell_size\n                self.dim = dim\n                self.cells = {}\n\n            def _hash_point(self, p):\n                return tuple(int(p[d] / self.cell_size) for d in range(self.dim))\n\n            def insert(self, node):\n                h = self._hash_point(node.position)\n                if h not in self.cells:\n                    self.cells[h] = []\n                self.cells[h].append(node)\n\n            def neighbors(self, point, radius):\n                low = [int((point[d] - radius) // self.cell_size) for d in range(self.dim)]\n                high = [int((point[d] + radius) // self.cell_size) for d in range(self.dim)]\n                result = []\n                def _grid_range(low_, high_, idx=None):\n                    if idx is None:\n                        idx = []\n                    if len(idx) == self.dim:\n                        yield tuple(idx)\n                        return\n                    dim_i = len(idx)\n                    for v in range(low_[dim_i], high_[dim_i] + 1):\n                        idx.append(v)\n                        yield from _grid_range(low_, high_, idx)\n                        idx.pop()\n                for cell in _grid_range(low, high):\n                    if cell in self.cells:\n                        result.extend(self.cells[cell])\n                return result\n\n            def clear(self):\n                self.cells.clear()\n\n        def adaptive_radius(n_nodes, iter_i):\n            # RRT* radius bound: gamma * (log(n)/n)^(1/d)\n            # Use slow decay with iteration via max_radius and min_radius clipping\n            gamma = self.max_radius\n            if n_nodes <= 1:\n                return gamma\n            base_r = gamma * (math.log(n_nodes) / n_nodes) ** (1.0/dim)\n            decay = max(self.min_radius / gamma, 1.0 - 0.85 * (iter_i / self.max_iter))\n            r = max(self.min_radius, min(base_r * decay, self.max_radius))\n            return r\n\n        def neighbors_in_radius(tree_nodes, grid, p, radius):\n            candidates = grid.neighbors(p, radius)\n            result = [n for n in candidates if dist(n.position, p) <= radius]\n            return result\n\n        def choose_parent(tree_nodes, grid, pos, iter_i):\n            n = len(tree_nodes)\n            r = adaptive_radius(n, iter_i)\n            nbrs = neighbors_in_radius(tree_nodes, grid, pos, r)\n            min_cost = float('inf')\n            best_parent = None\n            for nb in nbrs:\n                if edge_in_obstacle(nb.position, pos):\n                    continue\n                new_cost = nb.cost + dist(nb.position, pos)\n                if new_cost < min_cost:\n                    min_cost = new_cost\n                    best_parent = nb\n            if best_parent is None:\n                # fallback to nearest no collision node\n                nearest = min(tree_nodes, key=lambda node: dist(node.position, pos))\n                if edge_in_obstacle(nearest.position, pos):\n                    return None, []\n                best_parent = nearest\n                min_cost = best_parent.cost + dist(best_parent.position, pos)\n            new_node = Node(pos, parent=best_parent, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree_nodes.append(new_node)\n            grid.insert(new_node)\n            return new_node, nbrs\n\n        def rewire(pivot, nbrs):\n            for nb in nbrs:\n                if nb == pivot.parent:\n                    continue\n                new_cost = pivot.cost + dist(pivot.position, nb.position)\n                if new_cost + 1e-10 < nb.cost:\n                    if edge_in_obstacle(pivot.position, nb.position):\n                        continue\n                    if nb.parent is not None:\n                        nb.parent.remove_child(nb)\n                    pivot.add_child(nb)\n                    nb.cost = new_cost\n\n        def direct_connect(tree_nodes, grid, target_node):\n            if not tree_nodes:\n                return None\n            nearest = min(tree_nodes, key=lambda n: dist(n.position, target_node.position))\n            d_nearest = dist(nearest.position, target_node.position)\n            if d_nearest <= self.step_size:\n                if edge_in_obstacle(nearest.position, target_node.position) or in_obstacle(target_node.position):\n                    return None\n                new_node = Node(target_node.position, parent=nearest, cost=nearest.cost + d_nearest)\n                nearest.add_child(new_node)\n                tree_nodes.append(new_node)\n                grid.insert(new_node)\n                return new_node\n            # Try direct edge if no obstacles\n            if not edge_in_obstacle(nearest.position, target_node.position):\n                new_node = Node(target_node.position, parent=nearest, cost=nearest.cost + d_nearest)\n                nearest.add_child(new_node)\n                tree_nodes.append(new_node)\n                grid.insert(new_node)\n                return new_node\n            # Incrementally steer toward target\n            steps = int(math.ceil(d_nearest / self.step_size))\n            current = nearest\n            for _ in range(steps):\n                new_pos = steer(current.position, target_node.position)\n                if not in_bounds(new_pos) or in_obstacle(new_pos) or edge_in_obstacle(current.position, new_pos):\n                    return None\n                new_node = Node(new_pos, parent=current, cost=current.cost + dist(current.position, new_pos))\n                current.add_child(new_node)\n                tree_nodes.append(new_node)\n                grid.insert(new_node)\n                current = new_node\n                if dist(current.position, target_node.position) <= self.step_size:\n                    if edge_in_obstacle(current.position, target_node.position) or in_obstacle(target_node.position):\n                        return None\n                    final_node = Node(target_node.position, parent=current, cost=current.cost + dist(current.position, target_node.position))\n                    current.add_child(final_node)\n                    tree_nodes.append(final_node)\n                    grid.insert(final_node)\n                    return final_node\n            return None\n\n        def sample_uniform():\n            return tuple(random.uniform(0.0, bounds[d]) for d in range(dim))\n\n        def sample_informed():\n            if not found_solution or best_cost >= float('inf') or c_min < 1e-12:\n                return sample_uniform()\n            center = tuple((start[d] + goal[d]) * 0.5 for d in range(dim))\n            unit_dir = []\n            for d in range(dim):\n                unit_dir.append((goal[d] - start[d]) / c_min)\n            r1 = best_cost * 0.5\n            val = max(best_cost * best_cost - c_min * c_min, 0.0)\n            r_other = math.sqrt(val) * 0.5\n\n            if dim == 2:\n                a1 = unit_dir\n                a2 = (-a1[1], a1[0])\n                basis = (a1, a2)\n                radii = (r1, r_other)\n            else:\n                def cross(u,v):\n                    return (u[1]*v[2]-u[2]*v[1], u[2]*v[0]-u[0]*v[2], u[0]*v[1]-u[1]*v[0])\n                def norm(v):\n                    return math.sqrt(sum(x*x for x in v))\n                a1 = unit_dir\n                ref = (1,0,0) if abs(a1[0]) < 0.9 else (0,1,0)\n                b2 = cross(a1, ref)\n                n_b2 = norm(b2)\n                if n_b2 < 1e-12:\n                    ref = (0,0,1)\n                    b2 = cross(a1, ref)\n                    n_b2 = norm(b2)\n                b2 = tuple(x / n_b2 for x in b2)\n                b3 = cross(a1, b2)\n                basis = (a1, b2, b3)\n                radii = (r1, r_other, r_other)\n\n            def sample_unit_ball(dim_):\n                while True:\n                    vec = [random.gauss(0,1) for _ in range(dim_)]\n                    nrm = math.sqrt(sum(v*v for v in vec))\n                    if nrm < 1e-14:\n                        continue\n                    vec = [v/nrm for v in vec]\n                    r = random.random() ** (1.0/dim_)\n                    return [v*r for v in vec]\n\n            u = sample_unit_ball(dim)\n            mapped = []\n            for d in range(dim):\n                val = center[d]\n                for i in range(dim):\n                    if i < len(basis):\n                        val += basis[i][d] * radii[i] * u[i]\n                val = max(0.0, min(val, bounds[d]))\n                mapped.append(val)\n            return tuple(mapped)\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path[:]\n            path = list(path)\n            for _ in range(self.shortcut_iter):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if not edge_in_obstacle(p1, p2):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        def connect_paths(node_a, node_b):\n            path_a = node_a.path_from_root()\n            path_b = node_b.path_from_root()\n            if path_a[-1] == path_b[-1]:\n                return path_a + path_b[-2::-1]\n            else:\n                return path_a + path_b[::-1]\n\n        # Initialize trees\n        start_root = Node(start, cost=0.0)\n        goal_root = Node(goal, cost=0.0)\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n        edges = []\n        nodes = [start_root, goal_root]\n\n        # Spatial grids\n        cell_size = self.step_size * 1.5\n        grid_start = SpatialGrid(bounds, cell_size, dim)\n        grid_goal = SpatialGrid(bounds, cell_size, dim)\n        grid_start.insert(start_root)\n        grid_goal.insert(goal_root)\n\n        c_min = dist(start, goal)\n        best_cost = float('inf')\n        best_path = []\n        found_solution = False\n        no_improve = 0\n\n        start_time = time.time()\n\n        for it in range(self.max_iter):\n            if (time.time() - start_time) > self.time_limit:\n                break\n\n            tree_a, grid_a = (start_tree, grid_start) if it % 2 == 0 else (goal_tree, grid_goal)\n            tree_b, grid_b = (goal_tree, grid_goal) if it % 2 == 0 else (start_tree, grid_start)\n\n            x_rand = sample_informed()\n\n            if not in_bounds(x_rand) or in_obstacle(x_rand):\n                if found_solution:\n                    no_improve += 1\n                    if no_improve >= self.max_no_improve:\n                        break\n                continue\n\n            nearest = min(tree_a, key=lambda n: dist(n.position, x_rand))\n            new_pos = steer(nearest.position, x_rand)\n            if not in_bounds(new_pos) or in_obstacle(new_pos) or edge_in_obstacle(nearest.position, new_pos):\n                if found_solution:\n                    no_improve += 1\n                    if no_improve >= self.max_no_improve:\n                        break\n                continue\n\n            new_node, nbrs = choose_parent(tree_a, grid_a, new_pos, it)\n            if new_node is None:\n                if found_solution:\n                    no_improve += 1\n                    if no_improve >= self.max_no_improve:\n                        break\n                continue\n\n            rewire(new_node, nbrs)\n\n            nodes.append(new_node)\n            edges.append((new_node.parent, new_node))\n\n            meet_node = direct_connect(tree_b, grid_b, new_node)\n            if meet_node is not None:\n                candidate_path = connect_paths(new_node, meet_node)\n                total_cost = 0.0\n                for i in range(len(candidate_path) - 1):\n                    total_cost += dist(candidate_path[i], candidate_path[i+1])\n\n                if total_cost + 1e-9 < best_cost:\n                    best_cost = total_cost\n                    best_path = candidate_path\n                    found_solution = True\n                    no_improve = 0\n                else:\n                    if found_solution:\n                        no_improve += 1\n                        if no_improve >= self.max_no_improve:\n                            break\n            else:\n                if found_solution:\n                    no_improve += 1\n                    if no_improve >= self.max_no_improve:\n                        break\n\n        if found_solution and len(best_path) >= 3:\n            best_path = shortcut_path(best_path)\n\n        return PlannerResult(success=found_solution, path=best_path, nodes=nodes, edges=edges)",
          "objective": -34.03393,
          "time_improvement": 55.0,
          "length_improvement": 17.0,
          "smoothness_improvement": 1480.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.0197298526763916,
                    "num_nodes_avg": 94.0,
                    "path_length_avg": 153.44598923252843,
                    "smoothness_avg": 0.04652924545929119,
                    "success_improvement": 0.0,
                    "time_improvement": 18.758498142066845,
                    "length_improvement": 15.89382179435248,
                    "smoothness_improvement": 628.2837313116212,
                    "objective_score": 18.305261175789646
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.02853994369506836,
                    "num_nodes_avg": 236.0,
                    "path_length_avg": 236.42688152824053,
                    "smoothness_avg": 0.1008504544454795,
                    "success_improvement": 0.0,
                    "time_improvement": 82.32440643889325,
                    "length_improvement": 21.073901775411443,
                    "smoothness_improvement": 2494.954832528408,
                    "objective_score": 49.816437159556884
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.01848320960998535,
                    "num_nodes_avg": 193.4,
                    "path_length_avg": 129.01597928456926,
                    "smoothness_avg": 0.11146478831747879,
                    "success_improvement": 0.0,
                    "time_improvement": 62.67581425579548,
                    "length_improvement": 14.31372963993577,
                    "smoothness_improvement": 1317.8238799234878,
                    "objective_score": 33.98010146031754
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e1",
          "algorithm_description": "Bidirectional Anytime Informed RRT* with Curvature-Aware Spline Smoothing. This planner grows two trees simultaneously from start and goal with adaptive informed sampling based on current best cost to efficiently prune search space. It uses adaptive neighbor radius for rewiring to optimize path cost and performs early termination on stagnation. After finding a path, a smoothing phase fits cubic Bezier splines through the path to optimize curvature and generate smooth, continuous trajectories, improving path smoothness significantly without sacrificing path length or planning efficiency.",
          "planning_mechanism": "The planner alternates growing bidirectional RRT* trees using adaptive ellipsoidal informed sampling guided by current best path. It performs incremental rewiring within an adaptive radius minimizing cost while maintaining collision-free edges. Upon successful connection, it extracts the combined path and applies curvature-aware cubic Bezier spline smoothing to produce a natural, smooth trajectory before returning the final solution. Early stopping criteria speed convergence and limit unnecessary computation.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self,\n                 max_iter=6000,\n                 step_size=6.0,\n                 max_radius=35.0,\n                 min_radius=6.0,\n                 max_no_improve=70,\n                 time_limit=25.0,\n                 shortcut_iter=120):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.max_radius = max_radius\n        self.min_radius = min_radius\n        self.max_no_improve = max_no_improve\n        self.time_limit = time_limit\n        self.shortcut_iter = shortcut_iter\n\n    def plan(self, map):\n        import math, random, time\n\n        bounds = map.size\n        dim = len(bounds)\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = (dim == 3)\n\n        def in_bounds(pos):\n            return all(0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    px, py = pos\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def edge_in_obstacle(a, b, res=1.0):\n            dist = math.dist(a, b)\n            if dist < 1e-12:\n                return False\n            steps = max(3, int(dist / res))\n            for i in range(steps + 1):\n                interp = tuple(a[d] + (b[d] - a[d]) * i / steps for d in range(dim))\n                if in_obstacle(interp):\n                    return True\n            return False\n\n        def steer(from_p, to_p):\n            dist = math.dist(from_p, to_p)\n            if dist <= self.step_size:\n                return to_p\n            ratio = self.step_size / dist\n            return tuple(from_p[d] + (to_p[d] - from_p[d]) * ratio for d in range(dim))\n\n        def adaptive_radius(n, iter_i):\n            # Volume constant for unit ball in dim-dimensional space\n            from math import pi, gamma, log\n            gamma_dim = self.max_radius\n            unit_ball_vol = (pi ** (dim / 2)) / gamma(dim / 2 + 1) if dim > 1 else 2.0\n            if n < 2:\n                return self.max_radius\n            base_r = gamma_dim * ((log(n) / n) ** (1.0 / dim))\n            decay = max(self.min_radius / gamma_dim, 1.0 - 0.85 * (iter_i / self.max_iter))\n            return max(self.min_radius, min(base_r * decay, self.max_radius))\n\n        def neighbors(tree, pos, radius):\n            rsq = radius * radius\n            res = []\n            for node in tree:\n                dsq = 0.0\n                for d in range(dim):\n                    diff = node.position[d] - pos[d]\n                    dsq += diff * diff\n                    if dsq > rsq:\n                        break\n                else:\n                    res.append(node)\n            return res\n\n        def choose_parent(tree, pos, iter_i):\n            n = len(tree)\n            r = adaptive_radius(n, iter_i)\n            nbrs = neighbors(tree, pos, r)\n            if not nbrs:\n                # Fall back to nearest if no neighbors in radius\n                nearest = min(tree, key=lambda node: math.dist(node.position, pos))\n                if edge_in_obstacle(nearest.position, pos) or in_obstacle(pos):\n                    return None, []\n                cost_here = nearest.cost + math.dist(nearest.position, pos)\n                new_node = Node(pos, parent=nearest, cost=cost_here)\n                nearest.add_child(new_node)\n                tree.append(new_node)\n                return new_node, []\n            min_cost = float('inf')\n            best_parent = None\n            for nb in nbrs:\n                dist_nb = math.dist(nb.position, pos)\n                est_cost = nb.cost + dist_nb\n                if est_cost >= min_cost:\n                    continue\n                if edge_in_obstacle(nb.position, pos):\n                    continue\n                if est_cost < min_cost:\n                    min_cost = est_cost\n                    best_parent = nb\n            if best_parent is None:\n                # Safety fallback\n                nearest = min(tree, key=lambda node: math.dist(node.position, pos))\n                if edge_in_obstacle(nearest.position, pos) or in_obstacle(pos):\n                    return None, []\n                best_parent = nearest\n                min_cost = best_parent.cost + math.dist(best_parent.position, pos)\n            new_node = Node(pos, parent=best_parent, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree.append(new_node)\n            return new_node, nbrs\n\n        def rewire(pivot, nbrs):\n            for nb in nbrs:\n                if nb == pivot.parent:\n                    continue\n                new_cost = pivot.cost + math.dist(pivot.position, nb.position)\n                if new_cost + 1e-12 < nb.cost:\n                    if edge_in_obstacle(pivot.position, nb.position):\n                        continue\n                    # Remove from old parent's children to prevent references\n                    if nb.parent is not None:\n                        nb.parent.remove_child(nb)\n                    pivot.add_child(nb)\n                    nb.cost = new_cost\n\n        def direct_connect(tree, target_node):\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda n: math.dist(n.position, target_node.position))\n            dist = math.dist(nearest.position, target_node.position)\n            if dist <= self.step_size:\n                if edge_in_obstacle(nearest.position, target_node.position) or in_obstacle(target_node.position):\n                    return None\n                new_node = Node(target_node.position, parent=nearest, cost=nearest.cost + dist)\n                nearest.add_child(new_node)\n                tree.append(new_node)\n                return new_node\n            current = nearest\n            steps = int(math.ceil(dist / self.step_size))\n            for _ in range(steps):\n                new_pos = steer(current.position, target_node.position)\n                if not in_bounds(new_pos) or in_obstacle(new_pos) or edge_in_obstacle(current.position, new_pos):\n                    return None\n                new_node = Node(new_pos, parent=current, cost=current.cost + math.dist(current.position, new_pos))\n                current.add_child(new_node)\n                tree.append(new_node)\n                current = new_node\n                if math.dist(current.position, target_node.position) <= self.step_size:\n                    if edge_in_obstacle(current.position, target_node.position) or in_obstacle(target_node.position):\n                        return None\n                    final_node = Node(target_node.position, parent=current, cost=current.cost + math.dist(current.position, target_node.position))\n                    current.add_child(final_node)\n                    tree.append(final_node)\n                    return final_node\n            return None\n\n        def sample_uniform():\n            while True:\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not in_obstacle(p):\n                    return p\n\n        def sample_informed():\n            if not found_solution or best_cost == float('inf') or c_min < 1e-12:\n                return sample_uniform()\n            center = tuple((start_pos[d] + goal_pos[d]) * 0.5 for d in range(dim))\n            unit_dir = tuple((goal_pos[d] - start_pos[d]) / c_min for d in range(dim))\n            r1 = best_cost * 0.5\n            val = max(best_cost*best_cost - c_min*c_min, 0.0)\n            r_other = math.sqrt(val) * 0.5\n            if dim == 2:\n                a1 = unit_dir\n                a2 = (-a1[1], a1[0])\n                basis = (a1, a2)\n                radii = (r1, r_other)\n            else:\n                def cross(u, v):\n                    return (u[1]*v[2]-u[2]*v[1], u[2]*v[0]-u[0]*v[2], u[0]*v[1]-u[1]*v[0])\n                def norm(v):\n                    return math.sqrt(sum(x*x for x in v))\n                a1 = unit_dir\n                ref = (1,0,0) if abs(a1[0]) < 0.9 else (0,1,0)\n                b2 = cross(a1, ref)\n                n_b2 = norm(b2)\n                if n_b2 < 1e-12:\n                    ref = (0,0,1)\n                    b2 = cross(a1, ref)\n                    n_b2 = norm(b2)\n                b2 = tuple(x / n_b2 for x in b2)\n                b3 = cross(a1, b2)\n                basis = (a1, b2, b3)\n                radii = (r1, r_other, r_other)\n            def sample_unit_ball(dim):\n                while True:\n                    vec = [random.gauss(0,1) for _ in range(dim)]\n                    nrm = math.sqrt(sum(v*v for v in vec))\n                    if nrm < 1e-12:\n                        continue\n                    vec = [v/nrm for v in vec]\n                    r = random.random() ** (1/dim)\n                    return [v*r for v in vec]\n            u = sample_unit_ball(dim)\n            mapped = []\n            for d in range(dim):\n                val = center[d]\n                for i in range(dim):\n                    val += basis[i][d]*radii[i]*u[i]\n                # Clamp inside bounds exactly\n                mapped.append(min(max(val, 0.0), bounds[d]))\n            if not in_obstacle(tuple(mapped)):\n                return tuple(mapped)\n            return sample_uniform()\n\n        def bezier_cubic(p0, p1, p2, p3, t):\n            \"\"\"Compute cubic Bezier curve point at t [0..1].\"\"\"\n            u = 1 - t\n            tt = t * t\n            uu = u * u\n            uuu = uu * u\n            ttt = tt * t\n            x = uuu * p0[0] + 3 * uu * t * p1[0] + 3 * u * tt * p2[0] + ttt * p3[0]\n            y = uuu * p0[1] + 3 * uu * t * p1[1] + 3 * u * tt * p2[1] + ttt * p3[1]\n            if dim == 2:\n                return (x, y)\n            z = uuu * p0[2] + 3 * uu * t * p1[2] + 3 * u * tt * p2[2] + ttt * p3[2]\n            return (x, y, z)\n\n        def smooth_path_bezier(path):\n            if len(path) < 4:\n                return path[:]  # Too short to smooth reliably\n\n            # Create a new smoothed path with Bezier segments through triples of points\n            smoothed = [path[0]]\n            for i in range(1, len(path) - 2):\n                p0, p1, p2, p3 = path[i-1], path[i], path[i+1], path[i+2]\n\n                # Compute control points for smooth cubic bezier curve segment\n                def control_point(prev, curr, nxt, alpha=0.3):\n                    return tuple(curr[d] + alpha*(nxt[d]-prev[d]) for d in range(dim))\n\n                cp1 = control_point(p0, p1, p2)\n                cp2 = control_point(p1, p2, p3)\n                samples = max(3, int(math.dist(p1,p2)/self.step_size))  # samples per segment\n\n                for s in range(1, samples+1):\n                    t = s / samples\n                    pt = bezier_cubic(p1, cp1, cp2, p2, t)\n                    if not in_obstacle(pt) and not edge_in_obstacle(smoothed[-1], pt):\n                        smoothed.append(pt)\n                    else:\n                        # If collision, append p2 directly, break to next segment\n                        smoothed.append(p2)\n                        break\n            if smoothed[-1] != path[-1]:\n                smoothed.append(path[-1])\n            return smoothed\n\n        def shortcut_path(path):\n            # Random shortcuts to fix small holes or jumps left after smoothing\n            if len(path) < 3:\n                return path[:]\n            for _ in range(self.shortcut_iter):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path)-3)\n                j = random.randint(i+2, len(path)-1)\n                p1, p2 = path[i], path[j]\n                if not edge_in_obstacle(p1, p2):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        best_path = []\n        best_cost = float('inf')\n        c_min = math.dist(start_pos, goal_pos)\n        found_solution = False\n        no_improve_count = 0\n\n        start_time = time.time()\n\n        for it in range(self.max_iter):\n            if time.time() - start_time > self.time_limit:\n                break\n\n            tree_a, tree_b = (start_tree, goal_tree) if it % 2 == 0 else (goal_tree, start_tree)\n            x_rand = sample_informed()\n\n            if not in_bounds(x_rand) or in_obstacle(x_rand):\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n                continue\n\n            nearest = min(tree_a, key=lambda node: math.dist(node.position, x_rand))\n            new_pos = steer(nearest.position, x_rand)\n            if not in_bounds(new_pos) or in_obstacle(new_pos) or edge_in_obstacle(nearest.position, new_pos):\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n                continue\n\n            new_node, nbrs = choose_parent(tree_a, new_pos, it)\n            if new_node is None:\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n                continue\n\n            rewire(new_node, nbrs)\n            nodes.append(new_node)\n            if new_node.parent:\n                edges.append((new_node.parent, new_node))\n\n            meet_node = direct_connect(tree_b, new_node)\n            if meet_node is not None:\n                # Combine paths carefully avoiding duplication at connection node\n                if it % 2 == 0:\n                    path_a = new_node.path_from_root()\n                    path_b = meet_node.path_from_root()\n                else:\n                    path_a = meet_node.path_from_root()\n                    path_b = new_node.path_from_root()\n                if path_a and path_b and path_a[-1] == path_b[-1]:\n                    merged_path = path_a + path_b[-2::-1]\n                else:\n                    merged_path = path_a + path_b[::-1]\n\n                # Compute total cost along merged path\n                total_cost = 0.0\n                for i in range(len(merged_path) - 1):\n                    total_cost += math.dist(merged_path[i], merged_path[i + 1])\n\n                if total_cost + 1e-9 < best_cost:\n                    best_cost = total_cost\n                    best_path = merged_path\n                    found_solution = True\n                    no_improve_count = 0\n                else:\n                    if found_solution:\n                        no_improve_count += 1\n                        if no_improve_count >= self.max_no_improve:\n                            break\n            else:\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n\n        if found_solution and len(best_path) >= 4:\n            # Apply spline smoothing to improve curvature and smoothness\n            best_path = smooth_path_bezier(best_path)\n            # Additional shortcut passes to refine path\n            best_path = shortcut_path(best_path)\n\n        return PlannerResult(success=found_solution, path=best_path, nodes=nodes, edges=edges)",
          "objective": -33.48325,
          "time_improvement": 52.0,
          "length_improvement": 18.0,
          "smoothness_improvement": 1448.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.02188541889190674,
                    "num_nodes_avg": 126.1,
                    "path_length_avg": 159.10679264997313,
                    "smoothness_avg": 0.040380418046515855,
                    "success_improvement": 0.0,
                    "time_improvement": 9.88253542835544,
                    "length_improvement": 12.79104574008065,
                    "smoothness_improvement": 532.0412299092479,
                    "objective_score": 13.299594222101263
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.023896503448486327,
                    "num_nodes_avg": 225.2,
                    "path_length_avg": 231.08930648993655,
                    "smoothness_avg": 0.09728385757415844,
                    "success_improvement": 0.0,
                    "time_improvement": 85.20022018964188,
                    "length_improvement": 22.85573795677634,
                    "smoothness_improvement": 2403.183726113427,
                    "objective_score": 51.2894274615255
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.01906890869140625,
                    "num_nodes_avg": 199.7,
                    "path_length_avg": 124.55936634727755,
                    "smoothness_avg": 0.1186902882292356,
                    "success_improvement": 0.0,
                    "time_improvement": 61.493079126645966,
                    "length_improvement": 17.273599751781756,
                    "smoothness_improvement": 1409.7317054701086,
                    "objective_score": 35.86074211641339
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "A simplified bidirectional RRT* planner using uniform and ellipsoidal informed sampling with efficient neighbor lookups, adaptive rewiring radius, incremental rewiring, and post-planning shortcut smoothing to improve path quality, smoothness, and planning speed while maintaining robustness. It alternates tree expansion from start and goal, performs parent selection to minimize cost with strict collision checks, tries direct and incremental tree connection after each insertion, and applies a random shortcutting heuristic for path smoothing.",
          "planning_mechanism": "The planner grows two trees from start and goal, sampling points biased towards an ellipsoidal informed subset once a solution is found, steering towards samples to add nodes, selecting parents among neighbors minimizing path cost, rewiring neighbors to improve connectivity and cost, connecting the two trees incrementally after each node addition, and applying shortcut smoothing post planning for improved path smoothness and length.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self,\n                 max_iter=4000,\n                 step_size=5.0,\n                 max_radius=20.0,\n                 min_radius=5.0,\n                 max_no_improve=60,\n                 shortcut_iter=100):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.max_radius = max_radius\n        self.min_radius = min_radius\n        self.max_no_improve = max_no_improve\n        self.shortcut_iter = shortcut_iter\n\n    def plan(self, map):\n        import math\n        import random\n        import time\n\n        bounds = map.size\n        dim = len(bounds)\n        start_pos = tuple(map.start)\n        goal_pos = tuple(map.goal)\n        obstacles = map.obstacles\n        is_3d = (dim == 3)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def in_obstacle(p):\n            px, py, pz = (p + (0, 0, 0))[:3]\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def edge_in_obstacle(a, b, res=1.0):\n            dist_ab = math.dist(a, b)\n            if dist_ab < 1e-12:\n                return False\n            steps = max(2, int(dist_ab / res))\n            for i in range(steps + 1):\n                interp = tuple(a[d] + (b[d] - a[d]) * i / steps for d in range(dim))\n                if in_obstacle(interp):\n                    return True\n            return False\n\n        def steer(frm, to):\n            dist_frm_to = math.dist(frm, to)\n            if dist_frm_to <= self.step_size:\n                return to\n            ratio = self.step_size / dist_frm_to\n            return tuple(frm[d] + (to[d] - frm[d]) * ratio for d in range(dim))\n\n        def adaptive_radius(n_nodes, iter_i):\n            if n_nodes <= 1:\n                return self.max_radius\n            gamma = self.max_radius\n            import math as m\n            r = gamma * (m.log(n_nodes) / n_nodes) ** (1 / dim)\n            decay = max(self.min_radius / gamma, 1.0 - 0.9 * (iter_i / self.max_iter))\n            return max(self.min_radius, min(r * decay, self.max_radius))\n\n        def neighbors(tree, point, radius):\n            r_sq = radius * radius\n            res = []\n            for node in tree:\n                d_sq = 0.0\n                for i in range(dim):\n                    diff = node.position[i] - point[i]\n                    d_sq += diff * diff\n                    if d_sq > r_sq:\n                        break\n                else:\n                    res.append(node)\n            return res\n\n        def choose_parent(tree, new_pos, iter_i):\n            n_nodes = len(tree)\n            r = adaptive_radius(n_nodes, iter_i)\n            nbrs = neighbors(tree, new_pos, r)\n            valid_parents = [n for n in nbrs if not edge_in_obstacle(n.position, new_pos)]\n            if not valid_parents:\n                nearest = None\n                nearest_dist = float('inf')\n                for n in tree:\n                    d = math.dist(n.position, new_pos)\n                    if d < nearest_dist and not edge_in_obstacle(n.position, new_pos):\n                        nearest = n\n                        nearest_dist = d\n                if nearest is None:\n                    return None, []\n                cost = nearest.cost + nearest_dist\n                new_node = Node(new_pos, parent=nearest, cost=cost)\n                nearest.add_child(new_node)\n                tree.append(new_node)\n                return new_node, []\n            best_parent = min(valid_parents, key=lambda p: p.cost + math.dist(p.position, new_pos))\n            min_cost = best_parent.cost + math.dist(best_parent.position, new_pos)\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree.append(new_node)\n            return new_node, valid_parents\n\n        def rewire(pivot, nbrs):\n            for nb in nbrs:\n                if nb is pivot.parent:\n                    continue\n                dist_pivot_nb = math.dist(pivot.position, nb.position)\n                new_cost = pivot.cost + dist_pivot_nb\n                if new_cost + 1e-12 < nb.cost and not edge_in_obstacle(pivot.position, nb.position):\n                    if nb.parent is not None:\n                        nb.parent.remove_child(nb)\n                    pivot.add_child(nb)\n                    nb.cost = new_cost\n\n        def attempt_connect(tree_from, node_to_connect):\n            if not tree_from:\n                return None\n            nearest = min(tree_from, key=lambda n: math.dist(n.position, node_to_connect.position))\n            dist_near = math.dist(nearest.position, node_to_connect.position)\n            if dist_near <= self.step_size:\n                if edge_in_obstacle(nearest.position, node_to_connect.position) or in_obstacle(node_to_connect.position):\n                    return None\n                new_node = Node(node_to_connect.position, parent=nearest, cost=nearest.cost + dist_near)\n                nearest.add_child(new_node)\n                tree_from.append(new_node)\n                return new_node\n            current = nearest\n            steps = int(math.ceil(dist_near / self.step_size))\n            for _ in range(steps):\n                new_pos = steer(current.position, node_to_connect.position)\n                if not in_bounds(new_pos) or in_obstacle(new_pos) or edge_in_obstacle(current.position, new_pos):\n                    return None\n                new_node = Node(new_pos, parent=current, cost=current.cost + math.dist(current.position, new_pos))\n                current.add_child(new_node)\n                tree_from.append(new_node)\n                current = new_node\n                if math.dist(current.position, node_to_connect.position) <= self.step_size:\n                    if edge_in_obstacle(current.position, node_to_connect.position) or in_obstacle(node_to_connect.position):\n                        return None\n                    final_node = Node(node_to_connect.position, parent=current,\n                                      cost=current.cost + math.dist(current.position, node_to_connect.position))\n                    current.add_child(final_node)\n                    tree_from.append(final_node)\n                    return final_node\n            return None\n\n        def sample_uniform():\n            return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        def sample_informed(c_best, c_min):\n            if c_best == float('inf') or c_min < 1e-12:\n                return sample_uniform()\n            center = tuple((start_pos[d] + goal_pos[d]) / 2 for d in range(dim))\n            unit_dir = []\n            for d in range(dim):\n                unit_dir.append((goal_pos[d] - start_pos[d]) / c_min)\n            r1 = c_best * 0.5\n            val = max(c_best * c_best - c_min * c_min, 0.0)\n            r_other = math.sqrt(val) * 0.5\n\n            if dim == 2:\n                a1 = unit_dir\n                a2 = (-a1[1], a1[0])\n                basis = (a1, a2)\n                radii = (r1, r_other)\n            else:\n                def cross(u, v):\n                    return (u[1] * v[2] - u[2] * v[1], u[2] * v[0] - u[0] * v[2], u[0] * v[1] - u[1] * v[0])\n                def norm(v):\n                    return math.sqrt(sum(x * x for x in v))\n                a1 = unit_dir\n                ref = (1, 0, 0) if abs(a1[0]) < 0.9 else (0, 1, 0)\n                b2 = cross(a1, ref)\n                n_b2 = norm(b2)\n                if n_b2 < 1e-12:\n                    ref = (0, 0, 1)\n                    b2 = cross(a1, ref)\n                    n_b2 = norm(b2)\n                b2 = tuple(x / n_b2 for x in b2)\n                b3 = cross(a1, b2)\n                basis = (a1, b2, b3)\n                radii = (r1, r_other, r_other)\n            def sample_unit_ball(dim):\n                while True:\n                    vec = [random.gauss(0, 1) for _ in range(dim)]\n                    nrm = math.sqrt(sum(v * v for v in vec))\n                    if nrm < 1e-12:\n                        continue\n                    vec = [v / nrm for v in vec]\n                    r = random.random() ** (1 / dim)\n                    return [v * r for v in vec]\n            u = sample_unit_ball(dim)\n            mapped = []\n            for d in range(dim):\n                val = center[d]\n                for i in range(dim):\n                    val += basis[i][d] * radii[i] * u[i]\n                mapped.append(max(0.0, min(val, bounds[d])))\n            return tuple(mapped)\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path[:]\n            path = list(path)\n            for _ in range(self.shortcut_iter):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if not edge_in_obstacle(path[i], path[j]):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        best_path = []\n        best_cost = float('inf')\n        c_min = math.dist(start_pos, goal_pos)\n        found_solution = False\n        no_improve_count = 0\n\n        start_time = time.time()\n\n        for iter_i in range(self.max_iter):\n            if found_solution:\n                sample = sample_informed(best_cost, c_min)\n                # occasional uniform sampling to avoid local minima\n                if random.random() < 0.15:\n                    sample = sample_uniform()\n            else:\n                sample = sample_uniform()\n\n            if not in_bounds(sample) or in_obstacle(sample):\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n                continue\n\n            tree_a, tree_b = (start_tree, goal_tree) if iter_i % 2 == 0 else (goal_tree, start_tree)\n\n            nearest_node = min(tree_a, key=lambda n: math.dist(n.position, sample))\n            new_pos = steer(nearest_node.position, sample)\n            if not in_bounds(new_pos) or in_obstacle(new_pos) or edge_in_obstacle(nearest_node.position, new_pos):\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n                continue\n\n            new_node, nbrs = choose_parent(tree_a, new_pos, iter_i)\n            if new_node is None:\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n                continue\n\n            rewire(new_node, nbrs)\n            nodes.append(new_node)\n            if new_node.parent:\n                edges.append((new_node.parent, new_node))\n\n            connect_node = attempt_connect(tree_b, new_node)\n            if connect_node is not None:\n                if iter_i % 2 == 0:\n                    path_a = new_node.path_from_root()\n                    path_b = connect_node.path_from_root()\n                else:\n                    path_a = connect_node.path_from_root()\n                    path_b = new_node.path_from_root()\n\n                if path_a and path_b and path_a[-1] == path_b[-1]:\n                    candidate_path = path_a + path_b[-2::-1]\n                else:\n                    candidate_path = path_a + path_b[::-1]\n\n                total_cost = 0.0\n                for i in range(len(candidate_path) - 1):\n                    total_cost += math.dist(candidate_path[i], candidate_path[i + 1])\n\n                if total_cost + 1e-9 < best_cost:\n                    best_cost = total_cost\n                    best_path = candidate_path\n                    found_solution = True\n                    no_improve_count = 0\n                else:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n            else:\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n\n        if found_solution and len(best_path) >= 3:\n            best_path = shortcut_path(best_path)\n\n        return PlannerResult(success=found_solution, path=best_path, nodes=nodes, edges=edges)",
          "objective": -33.40298,
          "time_improvement": 51.0,
          "length_improvement": 17.0,
          "smoothness_improvement": 1547.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.017258715629577637,
                    "num_nodes_avg": 79.5,
                    "path_length_avg": 159.14625161467853,
                    "smoothness_avg": 0.03811017652697283,
                    "success_improvement": 0.0,
                    "time_improvement": 28.9338850683042,
                    "length_improvement": 12.76941765625831,
                    "smoothness_improvement": 496.5070202200339,
                    "objective_score": 18.824351215346415
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.050636911392211915,
                    "num_nodes_avg": 257.4,
                    "path_length_avg": 238.0863832383473,
                    "smoothness_avg": 0.10822479582896447,
                    "success_improvement": 0.0,
                    "time_improvement": 68.63912996740864,
                    "length_improvement": 20.51991233846954,
                    "smoothness_improvement": 2684.7019478488814,
                    "objective_score": 46.32719613254872
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.022013473510742187,
                    "num_nodes_avg": 162.2,
                    "path_length_avg": 122.72467070826906,
                    "smoothness_avg": 0.12261112972748914,
                    "success_improvement": 0.0,
                    "time_improvement": 55.54695361209407,
                    "length_improvement": 18.492117236393174,
                    "smoothness_improvement": 1459.6045199214789,
                    "objective_score": 35.05737902507152
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e2",
          "algorithm_description": "A bidirectional RRT* variant with spatial hashing for efficient neighbor search and rewiring, adaptive neighborhood radius tuned by node density and best path cost, combined adaptive-involved sampling focusing on informed ellipsoid post initial solution, and a multi-pass smoothing stage employing iterative shortcutting enhanced with curvature-aware pruning for improved path smoothness and length while maintaining robust collision checking and early stopping on stagnation. The planner grows two trees alternately and attempts connection after each extension; spatial hashing replaces costly linear neighbor queries, accelerating rewire and parent choosing. Post-planning smoothing iteratively shortcuts and removes sharp angle nodes to generate a smooth, short, feasible path. Early termination triggers after no improvement threshold, ensuring faster convergence and higher-quality results.",
          "planning_mechanism": "The algorithm samples points initially uniformly, then biased inside an ellipsoidal informed subset after first solution. It extends nodes towards samples with collision checking, selects optimal parents in a spatial-hashed neighborhood for rewiring efficiency, alternates tree growth, attempts to connect opposite trees each iteration, and updates the best path cost. Termination occurs after max iterations or consecutive stagnation. A final smoothing phase applies multiple shortcut passes combined with angle-based node pruning to optimize smoothness and path length.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self,\n                 max_iter=3500,\n                 step_size=5.0,\n                 max_radius=30.0,\n                 min_radius=7.0,\n                 max_no_improve=45,\n                 shortcut_iter=150,\n                 cell_size=15.0,\n                 curvature_threshold=0.3):  # smaller is stricter smoothing\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.max_radius = max_radius\n        self.min_radius = min_radius\n        self.max_no_improve = max_no_improve\n        self.shortcut_iter = shortcut_iter\n        self.cell_size = cell_size\n        self.curvature_threshold = curvature_threshold\n\n    def plan(self, map):\n        import math\n        import random\n\n        bounds = map.size\n        dim = len(bounds)\n        start_pos = tuple(map.start)\n        goal_pos = tuple(map.goal)\n        obstacles = map.obstacles\n        is_3d = (dim == 3)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def in_obstacle(p):\n            px, py, pz = (p + (0, 0, 0))[:3]\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def edge_in_obstacle(a, b, resolution=1.0):\n            dist_ab = math.dist(a, b)\n            if dist_ab < 1e-12:\n                return False\n            steps = max(2, int(dist_ab / resolution))\n            for i in range(steps + 1):\n                interp = tuple(a[d] + (b[d] - a[d]) * i / steps for d in range(dim))\n                if in_obstacle(interp):\n                    return True\n            return False\n\n        def steer(frm, to):\n            dist = math.dist(frm, to)\n            if dist <= self.step_size:\n                return to\n            ratio = self.step_size / dist\n            return tuple(frm[d] + (to[d] - frm[d]) * ratio for d in range(dim))\n\n        # Spatial hashing for neighbor queries to limit search to local cells\n        class SpatialHash:\n            def __init__(self, bounds, cell_size):\n                self.cell_size = cell_size\n                self.inv_cell = 1.0 / cell_size\n                self.grid = {}\n                self.bounds = bounds\n                self.dim = len(bounds)\n\n            def _hash_coords(self, p):\n                return tuple(int(p[d] * self.inv_cell) for d in range(self.dim))\n\n            def insert(self, node):\n                hc = self._hash_coords(node.position)\n                self.grid.setdefault(hc, []).append(node)\n\n            def remove(self, node):\n                hc = self._hash_coords(node.position)\n                cell = self.grid.get(hc, [])\n                if node in cell:\n                    cell.remove(node)\n                    if not cell:\n                        del self.grid[hc]\n\n            def neighbors(self, p, radius):\n                r_cells = int(math.ceil(radius * self.inv_cell))\n                hc = self._hash_coords(p)\n                candidates = []\n                for dx in range(-r_cells, r_cells + 1):\n                    for dy in range(-r_cells, r_cells + 1):\n                        for dz in ([0] if self.dim == 2 else range(-r_cells, r_cells + 1)):\n                            cell_key = None\n                            if self.dim == 2:\n                                cell_key = (hc[0] + dx, hc[1] + dy)\n                            else:\n                                cell_key = (hc[0] + dx, hc[1] + dy, hc[2] + dz)\n                            cell_nodes = self.grid.get(cell_key)\n                            if cell_nodes:\n                                candidates.extend(cell_nodes)\n                r_sq = radius * radius\n                result = []\n                for node in candidates:\n                    dsq = 0.0\n                    for d in range(self.dim):\n                        diff = node.position[d] - p[d]\n                        dsq += diff * diff\n                        if dsq > r_sq:\n                            break\n                    else:\n                        result.append(node)\n                return result\n\n        # Informed sampling improving search efficiency after first solution\n        def sample_uniform():\n            return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        def sample_informed(c_best, c_min):\n            if c_best == float('inf') or c_min < 1e-12:\n                return sample_uniform()\n            center = tuple((start_pos[d] + goal_pos[d]) * 0.5 for d in range(dim))\n            unit_dir = [(goal_pos[d] - start_pos[d]) / c_min for d in range(dim)]\n            r1 = c_best * 0.5\n            diff_sq = max(c_best*c_best - c_min*c_min, 0.0)\n            r_other = math.sqrt(diff_sq) * 0.5\n\n            if dim == 2:\n                a1 = unit_dir\n                a2 = (-a1[1], a1[0])\n                basis = (a1, a2)\n                radii = (r1, r_other)\n            else:\n                # 3D orthonormal basis\n                def cross(u,v):\n                    return (u[1]*v[2]-u[2]*v[1], u[2]*v[0]-u[0]*v[2], u[0]*v[1]-u[1]*v[0])\n                def norm(v):\n                    return math.sqrt(sum(x*x for x in v))\n                a1 = unit_dir\n                ref = (1,0,0) if abs(a1[0]) < 0.9 else (0,1,0)\n                b2 = cross(a1, ref)\n                n_b2 = norm(b2)\n                if n_b2 < 1e-12:\n                    ref = (0,0,1)\n                    b2 = cross(a1, ref)\n                    n_b2 = norm(b2)\n                b2 = tuple(x / n_b2 for x in b2)\n                b3 = cross(a1, b2)\n                basis = (a1, b2, b3)\n                radii = (r1, r_other, r_other)\n\n            def sample_unit_ball(dim):\n                while True:\n                    vec = [random.gauss(0,1) for _ in range(dim)]\n                    nrm = math.sqrt(sum(v*v for v in vec))\n                    if nrm < 1e-12:\n                        continue\n                    vec = [v / nrm for v in vec]\n                    r = random.random() ** (1/dim)\n                    return [v * r for v in vec]\n\n            u = sample_unit_ball(dim)\n            mapped = []\n            for d in range(dim):\n                val = center[d]\n                for i in range(dim):\n                    val += basis[i][d] * radii[i] * u[i]\n                val = max(0.0, min(val, bounds[d]))\n                mapped.append(val)\n            return tuple(mapped)\n\n        # Adaptive neighborhood radius balancing rewiring cost and quality\n        def adaptive_radius(num_nodes, best_cost):\n            import math\n            if num_nodes <= 1:\n                return self.max_radius\n            # base radius scales with dimension\n            base = self.max_radius * (math.log(num_nodes) / num_nodes) ** (1/dim)\n            radius = max(self.min_radius, min(base, self.max_radius))\n            if best_cost != float('inf'):\n                # shrink radius proportional to best_cost and global spread\n                radius = max(self.min_radius, min(radius, best_cost * 0.5))\n            return radius\n\n        # Select best parent from spatial-hash neighbors minimizing cost with collision-free edge\n        def choose_parent(tree_hash, tree_nodes, new_pos, radius):\n            nbrs = tree_hash.neighbors(new_pos, radius)\n            valid_parents = []\n            for n in nbrs:\n                if not edge_in_obstacle(n.position, new_pos):\n                    valid_parents.append(n)\n            if not valid_parents:\n                # fallback nearest node globally with collision-free edge\n                nearest = None\n                nearest_dist = float('inf')\n                for n in tree_nodes:\n                    d = math.dist(n.position, new_pos)\n                    if d < nearest_dist and not edge_in_obstacle(n.position, new_pos):\n                        nearest = n\n                        nearest_dist = d\n                if nearest is None:\n                    return None, []\n                cost = nearest.cost + nearest_dist\n                new_node = Node(new_pos, parent=nearest, cost=cost)\n                nearest.add_child(new_node)\n                tree_nodes.append(new_node)\n                tree_hash.insert(new_node)\n                return new_node, []\n            best_parent = min(valid_parents, key=lambda p: p.cost + math.dist(p.position, new_pos))\n            cost_min = best_parent.cost + math.dist(best_parent.position, new_pos)\n            new_node = Node(new_pos, parent=best_parent, cost=cost_min)\n            best_parent.add_child(new_node)\n            tree_nodes.append(new_node)\n            tree_hash.insert(new_node)\n            return new_node, valid_parents\n\n        # Rewire neighbors in radius if cost improves and collision-free edge\n        def rewire(pivot, neighbors_, tree_hash):\n            for nb in neighbors_:\n                if nb == pivot.parent:\n                    continue\n                dist_pivot_nb = math.dist(pivot.position, nb.position)\n                new_cost = pivot.cost + dist_pivot_nb\n                if new_cost + 1e-12 < nb.cost:\n                    if edge_in_obstacle(pivot.position, nb.position):\n                        continue\n                    if nb.parent:\n                        nb.parent.remove_child(nb)\n                    pivot.add_child(nb)\n                    nb.cost = new_cost\n\n        # Try to connect two trees by extending tree_from towards node_to_connect\n        def attempt_connect(tree_hash, tree_nodes, node_to_connect):\n            if not tree_nodes:\n                return None\n            nearest = min(tree_nodes, key=lambda n: math.dist(n.position, node_to_connect.position))\n            dist_near = math.dist(nearest.position, node_to_connect.position)\n            if dist_near <= self.step_size:\n                if edge_in_obstacle(nearest.position, node_to_connect.position) or in_obstacle(node_to_connect.position):\n                    return None\n                new_node = Node(node_to_connect.position, parent=nearest, cost=nearest.cost + dist_near)\n                nearest.add_child(new_node)\n                tree_nodes.append(new_node)\n                tree_hash.insert(new_node)\n                return new_node\n            current = nearest\n            steps = int(math.ceil(dist_near / self.step_size))\n            for _ in range(steps):\n                new_pos = steer(current.position, node_to_connect.position)\n                if not in_bounds(new_pos) or in_obstacle(new_pos) or edge_in_obstacle(current.position, new_pos):\n                    return None\n                new_node = Node(new_pos, parent=current, cost=current.cost + math.dist(current.position, new_pos))\n                current.add_child(new_node)\n                tree_nodes.append(new_node)\n                tree_hash.insert(new_node)\n                current = new_node\n                if math.dist(current.position, node_to_connect.position) <= self.step_size:\n                    if edge_in_obstacle(current.position, node_to_connect.position) or in_obstacle(node_to_connect.position):\n                        return None\n                    final_node = Node(node_to_connect.position, parent=current,\n                                      cost=current.cost + math.dist(current.position, node_to_connect.position))\n                    current.add_child(final_node)\n                    tree_nodes.append(final_node)\n                    tree_hash.insert(final_node)\n                    return final_node\n            return None\n\n        # Multi-pass shortcut attempts with randomness + angle-based node removal for smoothing\n        def smooth_path(path):\n            if len(path) < 3:\n                return path[:]\n\n            # Angular pruning helper: cosine between vectors\n            def angle_cosine(p1, p2, p3):\n                import math\n                def vec(a,b):\n                    return [b[d]-a[d] for d in range(dim)]\n                v1 = vec(p2, p1)\n                v2 = vec(p2, p3)\n                norm1 = math.sqrt(sum(x*x for x in v1))\n                norm2 = math.sqrt(sum(x*x for x in v2))\n                if norm1 < 1e-12 or norm2 < 1e-12:\n                    return 1.0  # treat as straight\n                dot = sum(v1[d]*v2[d] for d in range(dim))\n                return dot / (norm1 * norm2)\n\n            path = list(path)\n            for _ in range(self.shortcut_iter):\n                if len(path) < 3:\n                    break\n                # Random shortcut attempt\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if not edge_in_obstacle(path[i], path[j]):\n                    path = path[:i+1] + path[j:]\n\n            # Angle-based pruning to remove sharp kinks\n            improved = True\n            while improved and len(path) >= 3:\n                improved = False\n                for i in range(1, len(path)-1):\n                    cos_phi = angle_cosine(path[i-1], path[i], path[i+1])\n                    if cos_phi > self.curvature_threshold:  # close to 1 means nearly straight\n                        candidate = path[:i] + path[i+1:]\n                        # Verify if shortcut edge is collision-free\n                        if not edge_in_obstacle(path[i-1], path[i+1]):\n                            path = candidate\n                            improved = True\n                            break\n            return path\n\n        # Initialize trees, spatial hashes and nodes list\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n        start_hash = SpatialHash(bounds, self.cell_size)\n        goal_hash = SpatialHash(bounds, self.cell_size)\n        start_hash.insert(start_root)\n        goal_hash.insert(goal_root)\n        nodes = [start_root, goal_root]\n        edges = []\n\n        best_path = []\n        best_cost = float('inf')\n        c_min = math.dist(start_pos, goal_pos)\n        found_solution = False\n        no_improve_count = 0\n\n        for iter_i in range(self.max_iter):\n            # Sample point: informed sampling biased inside ellipsoid after initial solution\n            if found_solution:\n                sample = sample_informed(best_cost, c_min)\n                if random.random() < 0.12:\n                    sample = sample_uniform()\n            else:\n                sample = sample_uniform()\n\n            if not in_bounds(sample) or in_obstacle(sample):\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n                continue\n\n            # Alternate tree expansion\n            if iter_i % 2 == 0:\n                tree_nodes, tree_hash = start_tree, start_hash\n                other_nodes, other_hash = goal_tree, goal_hash\n            else:\n                tree_nodes, tree_hash = goal_tree, goal_hash\n                other_nodes, other_hash = start_tree, start_hash\n\n            nearest = min(tree_nodes, key=lambda n: math.dist(n.position, sample))\n            new_pos = steer(nearest.position, sample)\n            if (not in_bounds(new_pos) or in_obstacle(new_pos) or\n                edge_in_obstacle(nearest.position, new_pos)):\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n                continue\n\n            radius = adaptive_radius(len(nodes), best_cost)\n            new_node, neighbors_ = choose_parent(tree_hash, tree_nodes, new_pos, radius)\n            if new_node is None:\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n                continue\n\n            rewire(new_node, neighbors_, tree_hash)\n            nodes.append(new_node)\n            if new_node.parent:\n                edges.append((new_node.parent, new_node))\n\n            connect_node = attempt_connect(other_hash, other_nodes, new_node)\n            if connect_node is not None:\n                if iter_i % 2 == 0:\n                    path_from = new_node.path_from_root()\n                    path_to = connect_node.path_from_root()\n                else:\n                    path_from = connect_node.path_from_root()\n                    path_to = new_node.path_from_root()\n\n                if path_from and path_to and path_from[-1] == path_to[-1]:\n                    candidate_path = path_from + path_to[-2::-1]\n                else:\n                    candidate_path = path_from + path_to[::-1]\n\n                total_cost = 0.0\n                for i in range(len(candidate_path)-1):\n                    total_cost += math.dist(candidate_path[i], candidate_path[i+1])\n\n                if total_cost + 1e-9 < best_cost:\n                    best_cost = total_cost\n                    best_path = candidate_path\n                    found_solution = True\n                    no_improve_count = 0\n                else:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n            else:\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n\n        if found_solution and len(best_path) >= 3:\n            best_path = smooth_path(best_path)\n\n        return PlannerResult(success=found_solution, path=best_path, nodes=nodes, edges=edges)",
          "objective": -32.9029,
          "time_improvement": 49.0,
          "length_improvement": 17.0,
          "smoothness_improvement": 1609.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.01923995018005371,
                    "num_nodes_avg": 92.2,
                    "path_length_avg": 157.3363578129988,
                    "smoothness_avg": 0.044642828864860054,
                    "success_improvement": 0.0,
                    "time_improvement": 20.77576685761409,
                    "length_improvement": 13.761449128561546,
                    "smoothness_improvement": 598.7572151895736,
                    "objective_score": 17.483385610369023
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.02807478904724121,
                    "num_nodes_avg": 247.3,
                    "path_length_avg": 236.40540078810062,
                    "smoothness_avg": 0.1090320795024787,
                    "success_improvement": 0.0,
                    "time_improvement": 82.61248985580178,
                    "length_improvement": 21.081072664758967,
                    "smoothness_improvement": 2705.4739382313296,
                    "objective_score": 50.959760246752566
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.02779085636138916,
                    "num_nodes_avg": 285.3,
                    "path_length_avg": 126.75283500904695,
                    "smoothness_avg": 0.1275381291737158,
                    "success_improvement": 0.0,
                    "time_improvement": 43.88035916323632,
                    "length_improvement": 15.81680230838801,
                    "smoothness_improvement": 1522.2755892042126,
                    "objective_score": 30.265567080024766
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "An improved bidirectional RRT* variant with simplified adaptive neighborhood radius, consistent incremental rewiring, and combined informed plus uniform sampling for balanced exploration. The planner applies strict collision checks on nodes and edges, optimizes parent selection to minimize path cost, and attempts connection between trees after each insertion. It leverages a unified rewiring radius calculation based on node density and iteration progress, integrates early stopping on improvement stagnation, and performs lightweight post-processing shortcutting to improve path quality and smoothness, achieving efficient planning, shorter path length, and smoother results while maintaining robustness and simplicity.",
          "planning_mechanism": "The planner grows two trees from start and goal positions in alternating iterations, sampling points biased towards an ellipsoidal informed subset once a solution is found to focus search. Nodes are added by steering towards samples within step size, selecting parents from neighbors that reduce path cost and maintain collision-free edges. Rewiring is done on neighbors with a unified adaptive radius that shrinks according to node count and iteration to refine local connectivity. After each added node, the planner attempts to connect the two trees to find feasible paths that are combined to update the best solution. Early stopping terminates planning after a number of iterations without improvement. A final random shortcutting pass reduces unnecessary detours for improved smoothness.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self,\n                 max_iter=4000,\n                 step_size=5.0,\n                 max_radius=25.0,\n                 min_radius=5.0,\n                 max_no_improve=60,\n                 shortcut_iter=120):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.max_radius = max_radius\n        self.min_radius = min_radius\n        self.max_no_improve = max_no_improve\n        self.shortcut_iter = shortcut_iter\n\n    def plan(self, map):\n        import math\n        import random\n        import time\n\n        bounds = map.size\n        dim = len(bounds)\n        start_pos = tuple(map.start)\n        goal_pos = tuple(map.goal)\n        obstacles = map.obstacles\n        is_3d = (dim == 3)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def in_obstacle(p):\n            px, py, pz = (p + (0, 0, 0))[:3]\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def edge_in_obstacle(a, b, res=1.0):\n            dist_ab = math.dist(a, b)\n            if dist_ab < 1e-12:\n                return False\n            steps = max(2, int(dist_ab / res))\n            for i in range(steps + 1):\n                interp = tuple(a[d] + (b[d] - a[d]) * i / steps for d in range(dim))\n                if in_obstacle(interp):\n                    return True\n            return False\n\n        def steer(frm, to):\n            dist_frm_to = math.dist(frm, to)\n            if dist_frm_to <= self.step_size:\n                return to\n            ratio = self.step_size / dist_frm_to\n            return tuple(frm[d] + (to[d] - frm[d]) * ratio for d in range(dim))\n\n        def adaptive_radius(node_count, iteration):\n            # Unified radius shrinking with node count and iteration progress\n            if node_count <= 1:\n                return self.max_radius\n            import math\n            gamma = self.max_radius\n            r = gamma * (math.log(node_count) / node_count) ** (1 / dim)\n            decay = max(self.min_radius / gamma, 1.0 - 0.95 * (iteration / self.max_iter))\n            return max(self.min_radius, min(r * decay, self.max_radius))\n\n        def neighbors(tree, point, radius):\n            radius_sq = radius * radius\n            res = []\n            px = point\n            for node in tree:\n                d_sq = 0.0\n                for i_ in range(dim):\n                    diff = node.position[i_] - px[i_]\n                    d_sq += diff * diff\n                    if d_sq > radius_sq:\n                        break\n                else:\n                    res.append(node)\n            return res\n\n        def choose_parent(tree, new_pos, iter_i):\n            n_nodes = len(tree)\n            r = adaptive_radius(n_nodes, iter_i)\n            nbrs = neighbors(tree, new_pos, r)\n            # filter valid parents with collision-free edge\n            valid_parents = []\n            for n in nbrs:\n                if edge_in_obstacle(n.position, new_pos):\n                    continue\n                valid_parents.append(n)\n            if not valid_parents:\n                # fallback: find nearest node with collision-free edge\n                nearest = None\n                nearest_dist = float('inf')\n                for n in tree:\n                    d = math.dist(n.position, new_pos)\n                    if d < nearest_dist and not edge_in_obstacle(n.position, new_pos):\n                        nearest = n\n                        nearest_dist = d\n                if nearest is None:\n                    return None, []\n                best_parent = nearest\n                cost = best_parent.cost + nearest_dist\n                new_node = Node(new_pos, parent=best_parent, cost=cost)\n                best_parent.add_child(new_node)\n                tree.append(new_node)\n                return new_node, []\n            # select parent minimizing cost\n            best_parent = None\n            min_cost = float('inf')\n            for p in valid_parents:\n                c = p.cost + math.dist(p.position, new_pos)\n                if c < min_cost:\n                    min_cost = c\n                    best_parent = p\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree.append(new_node)\n            return new_node, valid_parents\n\n        def rewire(pivot, nbrs):\n            for nb in nbrs:\n                if nb == pivot.parent:\n                    continue\n                dist_pivot_nb = math.dist(pivot.position, nb.position)\n                new_cost = pivot.cost + dist_pivot_nb\n                if new_cost + 1e-12 < nb.cost:\n                    if edge_in_obstacle(pivot.position, nb.position):\n                        continue\n                    # Rewire parent-child\n                    if nb.parent is not None:\n                        nb.parent.remove_child(nb)\n                    pivot.add_child(nb)\n                    nb.cost = new_cost\n\n        def attempt_connect(tree_from, node_to_connect):\n            if not tree_from:\n                return None\n            nearest = min(tree_from, key=lambda n: math.dist(n.position, node_to_connect.position))\n            dist_near = math.dist(nearest.position, node_to_connect.position)\n            if dist_near <= self.step_size:\n                if edge_in_obstacle(nearest.position, node_to_connect.position) or in_obstacle(node_to_connect.position):\n                    return None\n                new_node = Node(node_to_connect.position, parent=nearest, cost=nearest.cost + dist_near)\n                nearest.add_child(new_node)\n                tree_from.append(new_node)\n                return new_node\n            # incremental steering towards target\n            current = nearest\n            steps = int(math.ceil(dist_near / self.step_size))\n            for _ in range(steps):\n                new_pos = steer(current.position, node_to_connect.position)\n                if not in_bounds(new_pos) or in_obstacle(new_pos) or edge_in_obstacle(current.position, new_pos):\n                    return None\n                new_node = Node(new_pos, parent=current, cost=current.cost + math.dist(current.position, new_pos))\n                current.add_child(new_node)\n                tree_from.append(new_node)\n                current = new_node\n                if math.dist(current.position, node_to_connect.position) <= self.step_size:\n                    if edge_in_obstacle(current.position, node_to_connect.position) or in_obstacle(node_to_connect.position):\n                        return None\n                    final_node = Node(node_to_connect.position, parent=current,\n                                      cost=current.cost + math.dist(current.position, node_to_connect.position))\n                    current.add_child(final_node)\n                    tree_from.append(final_node)\n                    return final_node\n            return None\n\n        def sample_uniform():\n            return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        def sample_informed(c_best, c_min):\n            if c_best == float('inf') or c_min < 1e-12:\n                return sample_uniform()\n            center = tuple((start_pos[d] + goal_pos[d]) / 2 for d in range(dim))\n            unit_dir = []\n            for d in range(dim):\n                unit_dir.append((goal_pos[d] - start_pos[d]) / c_min)\n            r1 = c_best * 0.5\n            val = max(c_best * c_best - c_min * c_min, 0.0)\n            r_other = math.sqrt(val) * 0.5\n\n            if dim == 2:\n                a1 = unit_dir\n                a2 = (-a1[1], a1[0])\n                basis = (a1, a2)\n                radii = (r1, r_other)\n            else:\n                def cross(u, v):\n                    return (u[1] * v[2] - u[2] * v[1], u[2] * v[0] - u[0] * v[2], u[0] * v[1] - u[1] * v[0])\n\n                def norm(v):\n                    return math.sqrt(sum(x * x for x in v))\n\n                a1 = unit_dir\n                ref = (1, 0, 0) if abs(a1[0]) < 0.9 else (0, 1, 0)\n                b2 = cross(a1, ref)\n                n_b2 = norm(b2)\n                if n_b2 < 1e-12:\n                    ref = (0, 0, 1)\n                    b2 = cross(a1, ref)\n                    n_b2 = norm(b2)\n                b2 = tuple(x / n_b2 for x in b2)\n                b3 = cross(a1, b2)\n                basis = (a1, b2, b3)\n                radii = (r1, r_other, r_other)\n\n            def sample_unit_ball(dim):\n                while True:\n                    vec = [random.gauss(0, 1) for _ in range(dim)]\n                    nrm = math.sqrt(sum(v * v for v in vec))\n                    if nrm < 1e-12:\n                        continue\n                    vec = [v / nrm for v in vec]\n                    r = random.random() ** (1 / dim)\n                    return [v * r for v in vec]\n\n            u = sample_unit_ball(dim)\n            mapped = []\n            for d in range(dim):\n                val = center[d]\n                for i in range(dim):\n                    val += basis[i][d] * radii[i] * u[i]\n                val = max(0.0, min(val, bounds[d]))\n                mapped.append(val)\n            return tuple(mapped)\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path[:]\n            path = list(path)\n            for _ in range(self.shortcut_iter):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if not edge_in_obstacle(path[i], path[j]):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        best_path = []\n        best_cost = float('inf')\n        c_min = math.dist(start_pos, goal_pos)\n        found_solution = False\n        no_improve_count = 0\n\n        start_time = time.time()\n\n        for iter_i in range(self.max_iter):\n            if found_solution:\n                sample = sample_informed(best_cost, c_min)\n                # Occasionally sample uniform to avoid local minima\n                if random.random() < 0.15:\n                    sample = sample_uniform()\n            else:\n                sample = sample_uniform()\n\n            if not in_bounds(sample) or in_obstacle(sample):\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n                continue\n\n            tree_a, tree_b = (start_tree, goal_tree) if iter_i % 2 == 0 else (goal_tree, start_tree)\n\n            nearest_n = min(tree_a, key=lambda n: math.dist(n.position, sample))\n            new_pos = steer(nearest_n.position, sample)\n            if not in_bounds(new_pos) or in_obstacle(new_pos) or edge_in_obstacle(nearest_n.position, new_pos):\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n                continue\n\n            new_node, nbrs = choose_parent(tree_a, new_pos, iter_i)\n            if new_node is None:\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n                continue\n\n            rewire(new_node, nbrs)\n            nodes.append(new_node)\n            if new_node.parent:\n                edges.append((new_node.parent, new_node))\n\n            connect_node = attempt_connect(tree_b, new_node)\n            if connect_node is not None:\n                if iter_i % 2 == 0:\n                    path_a = new_node.path_from_root()\n                    path_b = connect_node.path_from_root()\n                else:\n                    path_a = connect_node.path_from_root()\n                    path_b = new_node.path_from_root()\n                if path_a and path_b and path_a[-1] == path_b[-1]:\n                    candidate_path = path_a + path_b[-2::-1]\n                else:\n                    candidate_path = path_a + path_b[::-1]\n\n                total_cost = 0.0\n                for i in range(len(candidate_path) - 1):\n                    total_cost += math.dist(candidate_path[i], candidate_path[i + 1])\n\n                if total_cost + 1e-9 < best_cost:\n                    best_cost = total_cost\n                    best_path = candidate_path\n                    found_solution = True\n                    no_improve_count = 0\n                else:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n            else:\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n\n        if found_solution and len(best_path) >= 3:\n            best_path = shortcut_path(best_path)\n\n        return PlannerResult(success=found_solution, path=best_path, nodes=nodes, edges=edges)",
          "objective": -32.09066,
          "time_improvement": 51.0,
          "length_improvement": 17.0,
          "smoothness_improvement": 1354.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.017293906211853026,
                    "num_nodes_avg": 91.5,
                    "path_length_avg": 161.730924310866,
                    "smoothness_avg": 0.042930783900201136,
                    "success_improvement": 0.0,
                    "time_improvement": 28.788981008339842,
                    "length_improvement": 11.352717594718152,
                    "smoothness_improvement": 571.9599937275159,
                    "objective_score": 18.308124827970424
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.03642895221710205,
                    "num_nodes_avg": 225.4,
                    "path_length_avg": 238.2939143004422,
                    "smoothness_avg": 0.0897730230727014,
                    "success_improvement": 0.0,
                    "time_improvement": 77.4385205476863,
                    "length_improvement": 20.450632496491846,
                    "smoothness_improvement": 2209.924544555513,
                    "objective_score": 46.551558384978556
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.02602849006652832,
                    "num_nodes_avg": 208.0,
                    "path_length_avg": 123.50286586657371,
                    "smoothness_avg": 0.10841836272819716,
                    "success_improvement": 0.0,
                    "time_improvement": 47.439204641197854,
                    "length_improvement": 17.97527706591856,
                    "smoothness_improvement": 1279.073571291572,
                    "objective_score": 31.41229548836835
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "time_expert",
          "algorithm_description": "A bidirectional RRT* planner with adaptive multi-radius rewiring emphasizing cost-based connections for shorter paths, enhanced sampling bias combining ellipsoidal informed and goal-directed Gaussian samples for faster convergence. It employs efficient approximate nearest neighbor search, dynamic step size control to refine exploration precision, and accelerated early stopping criteria to reduce planning time. Path smoothness is indirectly improved by prioritizing cost-optimal parent selection without explicit curvature penalties, enabling more flexible rewiring and shorter, smoother paths.",
          "planning_mechanism": "A bidirectional RRT* grows two trees alternating expansions from start and goal. Sampling blends ellipsoidal informed and goal-biased Gaussian perturbations to prioritize promising regions. Nearest neighbor and near-node queries use approximate but efficient search. Adaptive multi-radius rewiring updates parent-child relations based solely on cost, allowing more aggressive shortcuts and path shortening. A dynamic step size decreases as nodes increase, refining path precision. Early stopping triggers upon stagnated cost improvements. After a solution is found, shortcutting with collision checks refines the path length and smoothness, balancing planning time and path quality.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position  # tuple of floats\n        self.parent = parent      # Node or None\n        self.cost = cost          # cost from root\n        self.children = []       # list of Node\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def path_from_root(self):\n        node = self\n        path = []\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=2500, max_no_improve=40, improve_tol=1e-6,\n                 init_step=7.0, min_step=0.8, n_near_const=15, shortcut_iters=150):\n        self.max_iter = max_iter\n        self.max_no_improve = max_no_improve\n        self.improve_tol = improve_tol\n        self.init_step = init_step\n        self.min_step = min_step\n        self.n_near_const = n_near_const\n        self.shortcut_iters = shortcut_iters\n\n    def plan(self, map) -> 'PlannerResult':\n        import time, random, math\n\n        start_p = tuple(map.start)\n        goal_p = tuple(map.goal)\n        bounds = tuple(map.size)\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def dist(a, b):\n            s = 0.0\n            for i in range(dim):\n                d = a[i] - b[i]\n                s += d * d\n            return math.sqrt(s)\n\n        def in_obstacle(p):\n            px, py, pz = (p + (0, 0, 0))[:3]\n            for obs in obstacles:\n                if is_3d:\n                    ox, oy, oz, ow, oh, od = obs\n                    if ox <= px <= ox + ow and oy <= py <= oy + oh and oz <= pz <= oz + od:\n                        return True\n                else:\n                    ox, oy, ow, oh = obs\n                    if ox <= px <= ox + ow and oy <= py <= oy + oh:\n                        return True\n            return False\n\n        def edge_obstacle(f, t, resolution=1.0):\n            length = dist(f, t)\n            if length < 1e-12:\n                return False\n            steps = max(5, int(length / resolution))\n            for i in range(steps + 1):\n                inter = tuple(f[d] + (t[d] - f[d]) * i / steps for d in range(dim))\n                if in_obstacle(inter):\n                    return True\n            return False\n\n        def steer(frm, to, step_size):\n            d = dist(frm, to)\n            if d <= step_size:\n                return to\n            ratio = step_size / d\n            return tuple(frm[i] + (to[i] - frm[i]) * ratio for i in range(dim))\n\n        # Approximate nearest neighbor: linear with early reject for efficiency\n        def nearest(tree, point):\n            best = None\n            best_d2 = float('inf')\n            px = point\n            for n in tree:\n                d2 = 0.0\n                for i_ in range(dim):\n                    delta = n.position[i_] - px[i_]\n                    d2 += delta * delta\n                    if d2 >= best_d2:\n                        break\n                else:\n                    if d2 < best_d2:\n                        best = n\n                        best_d2 = d2\n            return best, math.sqrt(best_d2) if best is not None else None\n\n        def near_nodes(tree, point, radius):\n            rq = radius * radius\n            px = point\n            near_list = []\n            for n in tree:\n                d2 = 0.0\n                for i_ in range(dim):\n                    delta = n.position[i_] - px[i_]\n                    d2 += delta * delta\n                    if d2 > rq:\n                        break\n                if d2 <= rq:\n                    near_list.append(n)\n            return near_list\n\n        def adaptive_radius(n_nodes, c_best):\n            if n_nodes <= 1:\n                return self.init_step * 3.3\n            base = (self.n_near_const * (math.log(n_nodes) / n_nodes)) ** (1 / dim)\n            base = min(base, self.init_step * 5.8)\n            if c_best == float('inf'):\n                return base\n            shrink_factor = max(0.3, c_best / (c_min * 3.2))\n            return max(self.min_step * 0.8, base * shrink_factor)\n\n        # Sampling biased by ellipsoid informed + gaussian near goal for faster convergence\n        def sample(c_best):\n            if c_best == float('inf'):\n                # random uniform in bounds\n                return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n            # Informed ellipsoid sampling\n            center = tuple(0.5 * (start_p[i] + goal_p[i]) for i in range(dim))\n            diff = [goal_p[i] - start_p[i] for i in range(dim)]\n            dist_sg = dist(start_p, goal_p)\n            if dist_sg < 1e-14:\n                return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n            unit_vec = [d / dist_sg for d in diff]\n            # Build orthonormal basis (Gram-Schmidt)\n            U = [unit_vec]\n            for idx in range(dim - 1):\n                v = [0.0] * dim\n                v[(idx + 1) % dim] = 1.0\n                for u in U:\n                    proj = sum(v[j] * u[j] for j in range(dim))\n                    for j in range(dim):\n                        v[j] -= proj * u[j]\n                norm_v = math.sqrt(sum(x * x for x in v))\n                if norm_v > 1e-14:\n                    U.append([x / norm_v for x in v])\n                else:\n                    U.append([0.0] * dim)\n            r1 = c_best * 0.5\n            val = c_best * c_best - c_min * c_min\n            r2 = math.sqrt(val) * 0.5 if val > 0 else 0.0\n            radii = [r1] + [r2] * (dim - 1)\n\n            for _ in range(50):\n                # Random point inside unit ball\n                x_ball = [random.gauss(0, 1) for _ in range(dim)]\n                norm_x = math.sqrt(sum(x * x for x in x_ball))\n                if norm_x < 1e-14:\n                    continue\n                x_unit = [x / norm_x for x in x_ball]\n                r = random.random() ** (1 / dim)\n                point_ball = [r * x_unit[i] for i in range(dim)]\n                point_ellipsoid = [radii[i] * point_ball[i] for i in range(dim)]\n                sample_point = [center[j] for j in range(dim)]\n                for i_ in range(dim):\n                    for j_ in range(dim):\n                        sample_point[j_] += U[i_][j_] * point_ellipsoid[i_]\n                candidate = tuple(sample_point)\n                if all(0.0 <= candidate[i] <= bounds[i] for i in range(dim)) and not in_obstacle(candidate):\n                    # 20% chance to bias samples near goal using gaussian for faster connection\n                    if random.random() < 0.2:\n                        gauss_sample = []\n                        for d_i, bound_i in enumerate(bounds):\n                            gs = random.gauss(goal_p[d_i], min(bound_i * 0.05, 1.0))\n                            gauss_sample.append(min(max(0.0, gs), bound_i))\n                        gs_tuple = tuple(gauss_sample)\n                        if not in_obstacle(gs_tuple):\n                            return gs_tuple\n                    return candidate\n            # fallback uniform random\n            return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n\n        def get_path(node):\n            return node.path_from_root()\n\n        def connect_path(n1, n2):\n            p1 = get_path(n1)\n            p2 = get_path(n2)[::-1]\n            if p1 and p2 and p1[-1] == p2[0]:\n                return p1 + p2[1:]\n            return p1 + p2\n\n        # Add node with cost-only rewiring (no curvature penalty) to favor shorter paths\n        def add_node(tree, new_sample, all_nodes, edges, c_best, step_size):\n            nn, d_nn = nearest(tree, new_sample)\n            if nn is None:\n                return None\n            new_pos = steer(nn.position, new_sample, step_size)\n            if in_obstacle(new_pos) or edge_obstacle(nn.position, new_pos):\n                return None\n\n            n_nodes = len(all_nodes)\n            radius = adaptive_radius(n_nodes, c_best)\n            near = near_nodes(tree, new_pos, radius)\n\n            best_parent = nn\n            best_cost = nn.cost + dist(nn.position, new_pos)\n\n            for cand in near:\n                if cand == nn:\n                    continue\n                if edge_obstacle(cand.position, new_pos):\n                    continue\n                cost_candidate = cand.cost + dist(cand.position, new_pos)\n                if cost_candidate + self.improve_tol < best_cost:\n                    best_cost = cost_candidate\n                    best_parent = cand\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = best_cost\n            tree.append(new_node)\n            all_nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors if cost improves\n            near_r = near_nodes(tree, new_node.position, radius)\n            for near_n in near_r:\n                if near_n == best_parent or near_n == new_node:\n                    continue\n                if edge_obstacle(new_node.position, near_n.position):\n                    continue\n                alt_cost = new_node.cost + dist(new_node.position, near_n.position)\n                if alt_cost + self.improve_tol < near_n.cost:\n                    # Rewire\n                    if near_n.parent:\n                        near_n.parent.remove_child(near_n)\n                        try:\n                            edges.remove((near_n.parent, near_n))\n                        except Exception:\n                            pass\n                    new_node.add_child(near_n)\n                    near_n.cost = alt_cost\n                    edges.append((new_node, near_n))\n            return new_node\n\n        # Shortcutting without explicit curvature penalty but verify collision\n        def shortcut_path(path):\n            path = list(path)\n            if len(path) < 3:\n                return path\n            changed = True\n            iter_count = 0\n            while changed and iter_count < self.shortcut_iters:\n                iter_count += 1\n                changed = False\n                i = 0\n                while i < len(path) - 2:\n                    max_j = min(len(path) - 1, i + 6)\n                    if max_j <= i + 1:\n                        i += 1\n                        continue\n                    j = random.randint(i + 2, max_j)\n                    if not edge_obstacle(path[i], path[j]):\n                        # shortcut allowed\n                        del path[i + 1:j]\n                        changed = True\n                        break\n                    i += 1\n            return path\n\n        # Initialization\n        start_tree = [Node(start_p)]\n        goal_tree = [Node(goal_p)]\n        all_nodes = start_tree + goal_tree\n        edges = []\n        c_min = dist(start_p, goal_p)\n        best_cost = float('inf')\n        best_path = []\n        found_solution = False\n        no_improve_count = 0\n        last_best_cost = float('inf')\n        start_time = time.time()\n        step_size = self.init_step\n\n        for iter_num in range(self.max_iter):\n            sample_pt = sample(best_cost)\n\n            # Alternate expanding trees\n            if iter_num % 2 == 0:\n                tree_a, tree_b = start_tree, goal_tree\n            else:\n                tree_a, tree_b = goal_tree, start_tree\n\n            # Gradually reduce step size to refine paths as more nodes added\n            num_nodes = len(all_nodes)\n            step_size = max(self.min_step, self.init_step * (1 - num_nodes / (self.max_iter * 1.1)))\n\n            new_node = add_node(tree_a, sample_pt, all_nodes, edges, best_cost, step_size)\n            if new_node is None:\n                if found_solution:\n                    no_improve_count += 1\n                continue\n\n            nbr, d_nbr = nearest(tree_b, new_node.position)\n            if nbr is not None and d_nbr <= step_size and not edge_obstacle(new_node.position, nbr.position):\n                candidate_path = connect_path(new_node, nbr)\n                candidate_cost = new_node.cost + dist(new_node.position, nbr.position) + nbr.cost\n                if candidate_cost + self.improve_tol < best_cost:\n                    best_cost = candidate_cost\n                    best_path = candidate_path\n                    found_solution = True\n                    no_improve_count = 0\n                else:\n                    no_improve_count += 1\n            elif found_solution:\n                no_improve_count += 1\n\n            if found_solution:\n                if best_cost + self.improve_tol < last_best_cost:\n                    last_best_cost = best_cost\n                    no_improve_count = 0\n                elif no_improve_count >= self.max_no_improve:\n                    break\n\n        if found_solution and len(best_path) > 2:\n            # Post-processing shortcutting reduces path length, indirect smoothness gain\n            for _ in range(3):\n                best_path = shortcut_path(best_path)\n\n        if found_solution:\n            return PlannerResult(True, best_path, all_nodes, edges)\n        else:\n            return PlannerResult(False, [], all_nodes, edges)",
          "objective": -31.91279,
          "time_improvement": 53.0,
          "length_improvement": 14.0,
          "smoothness_improvement": 1510.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.012701964378356934,
                    "num_nodes_avg": 93.4,
                    "path_length_avg": 167.30235687670796,
                    "smoothness_avg": 0.0425654522641374,
                    "success_improvement": 0.0,
                    "time_improvement": 47.69719371100672,
                    "length_improvement": 8.298927120381544,
                    "smoothness_improvement": 566.241760292773,
                    "objective_score": 22.119723186994808
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.022562861442565918,
                    "num_nodes_avg": 215.5,
                    "path_length_avg": 240.54349758360195,
                    "smoothness_avg": 0.10420826484630626,
                    "success_improvement": 0.0,
                    "time_improvement": 86.02618236758204,
                    "length_improvement": 19.699656845908514,
                    "smoothness_improvement": 2581.353712674754,
                    "objective_score": 50.53441738119349
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.03733506202697754,
                    "num_nodes_avg": 254.8,
                    "path_length_avg": 128.49722609113547,
                    "smoothness_avg": 0.11646484458584172,
                    "success_improvement": 0.0,
                    "time_improvement": 24.60720733732938,
                    "length_improvement": 14.658260810641927,
                    "smoothness_improvement": 1381.4242265913015,
                    "objective_score": 23.08423982054048
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e2",
          "algorithm_description": "A Bidirectional RRT* variant with spatial grid acceleration, adaptive neighbor radius, and curvature-aware rewiring. This planner alternates expansions from start and goal, uses ellipsoidal informed sampling post initial solution, leverages spatial hashing grids for efficient nearest neighbor search, dynamically scales rewiring radius with tree size and solution cost, and incorporates curvature penalties to encourage smooth paths. The algorithm applies multi-pass accelerated shortcutting after planning and employs early termination on stagnation to balance planning efficiency with path quality improvements.",
          "planning_mechanism": "A bidirectional tree growth approach alternates expansions; nodes connect to parents that minimize travel cost plus curvature penalty chosen from spatial grid-based neighbors within an adaptive radius. After adding nodes, neighbors are rewired if a cheaper, smoother path exists. Ellipsoidal informed sampling focuses exploration after initial solutions. Tree connectivity is tested each iteration to attempt building a path. The planner stops on stagnation or iteration limit. Final path is smoothed through multiple passes of shortcutting to improve length and smoothness.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=3500, step_size=6.0, n_near_const=20,\n                 max_no_improve=60, improve_tol=1e-6, shortcut_iters=400,\n                 grid_cell_size=4.0, resolution=1.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.n_near_const = n_near_const\n        self.max_no_improve = max_no_improve\n        self.improve_tol = improve_tol\n        self.shortcut_iters = shortcut_iters\n        self.grid_cell_size = grid_cell_size\n        self.resolution = resolution\n\n    def plan(self, map):\n        import math\n        import random\n\n        # Basic environment info\n        start = tuple(map.start)\n        goal = tuple(map.goal)\n        bounds = tuple(map.size)\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        dist = lambda a,b: math.dist(a,b)\n        step_size = self.step_size\n        resolution = self.resolution\n\n        def in_obstacle(p):\n            px, py, pz = (p + (0,0,0))[:3]\n            for obs in obstacles:\n                if is_3d:\n                    ox, oy, oz, ow, oh, od = obs\n                    if ox <= px <= ox + ow and oy <= py <= oy + oh and oz <= pz <= oz + od:\n                        return True\n                else:\n                    ox, oy, ow, oh = obs\n                    if ox <= px <= ox + ow and oy <= py <= oy + oh:\n                        return True\n            return False\n\n        def edge_obstacle(f, t):\n            length = dist(f, t)\n            if length < 1e-12:\n                return False\n            steps = max(3, int(length / resolution))\n            for i in range(steps + 1):\n                inter = tuple(f[d] + (t[d] - f[d]) * i / steps for d in range(dim))\n                if in_obstacle(inter):\n                    return True\n            return False\n\n        def steer(frm, to, max_step):\n            d = dist(frm, to)\n            if d <= max_step:\n                return to\n            ratio = max_step / d\n            return tuple(frm[i] + (to[i] - frm[i]) * ratio for i in range(dim))\n\n        def in_bounds(p):\n            return all(0.0 <= p[d] <= bounds[d] for d in range(dim))\n\n        # Spatial hashing grid to accelerate neighbor queries\n        class SpatialGrid:\n            def __init__(self, bounds, cell_sz, dim):\n                self.dim = dim\n                self.cell_sz = cell_sz\n                self.cells = {}\n            def _hash_point(self, p):\n                return tuple(int(p[i]//self.cell_sz) for i in range(self.dim))\n            def insert(self, node):\n                h = self._hash_point(node.position)\n                if h not in self.cells:\n                    self.cells[h] = []\n                self.cells[h].append(node)\n            def neighbors(self, point, radius):\n                low = [int((point[i] - radius)//self.cell_sz) for i in range(self.dim)]\n                high = [int((point[i] + radius)//self.cell_sz) for i in range(self.dim)]\n                result = []\n                def recursive_collect(idx=[]):\n                    if len(idx) == self.dim:\n                        key = tuple(idx)\n                        if key in self.cells:\n                            result.extend(self.cells[key])\n                        return\n                    for v in range(low[len(idx)], high[len(idx)]+1):\n                        idx.append(v)\n                        recursive_collect(idx)\n                        idx.pop()\n                recursive_collect()\n                return result\n            def clear(self):\n                self.cells.clear()\n\n        # Adaptive neighbor radius scales with node count and best cost\n        def adaptive_radius(n_nodes, c_best):\n            if n_nodes <= 1:\n                return step_size * 4.0\n            gamma = self.n_near_const\n            base_r = min((gamma*(math.log(n_nodes)/n_nodes))**(1/dim), step_size * 6.0)\n            if c_best == float('inf'):\n                return base_r\n            shrink = max(0.3, c_best/(c_min * 3.0))\n            return max(step_size * 0.8, base_r * shrink)\n\n        # Ellipsoidal informed sampling concentrates search inside informed subset after solution\n        def sample_informed(c_best):\n            if c_best == float('inf') or c_min < 1e-12:\n                # uniform random sample inside bounds\n                return tuple(random.uniform(0.0, bounds[i]) for i in range(dim))\n            center = tuple((start[i] + goal[i]) * 0.5 for i in range(dim))\n            diff = [goal[i] - start[i] for i in range(dim)]\n            norm_diff = math.sqrt(sum(x*x for x in diff))\n            if norm_diff < 1e-14:\n                return tuple(random.uniform(0.0, bounds[i]) for i in range(dim))\n            unit_dir = [x / norm_diff for x in diff]\n            # build orthonormal basis U\n            U = [unit_dir]\n            for idx in range(dim - 1):\n                base = [0.0]*dim\n                base[(idx + 1) % dim] = 1.0\n                for u in U:\n                    proj = sum(base[j]*u[j] for j in range(dim))\n                    base = [base[j] - proj*u[j] for j in range(dim)]\n                norm_base = math.sqrt(sum(x*x for x in base))\n                if norm_base > 1e-14:\n                    U.append([x/norm_base for x in base])\n                else:\n                    U.append([0.0]*dim)\n            r1 = c_best * 0.5\n            val = c_best*c_best - c_min*c_min\n            r2 = math.sqrt(val)*0.5 if val > 0 else 0.0\n            radii = [r1] + [r2]*(dim - 1)\n\n            max_attempts = 40\n            for _ in range(max_attempts):\n                x_ball = [random.gauss(0,1) for _ in range(dim)]\n                norm_ball = math.sqrt(sum(x*x for x in x_ball))\n                if norm_ball < 1e-14:\n                    continue\n                unit_ball = [x/norm_ball for x in x_ball]\n                scale = random.random() ** (1/dim)\n                point_ball = [coord*scale for coord in unit_ball]\n                mapped = [0.0]*dim\n                for i_ in range(dim):\n                    for j_ in range(dim):\n                        mapped[j_] += radii[i_] * point_ball[i_] * U[i_][j_]\n                sample = tuple(center[i] + mapped[i] for i in range(dim))\n                if all(0.0 <= sample[i] <= bounds[i] for i in range(dim)) and not in_obstacle(sample):\n                    return sample\n            # fallback uniform\n            return tuple(random.uniform(0.0, bounds[i]) for i in range(dim))\n\n        # Helper to retrieve path from two nodes meeting\n        def connect_path(n1, n2):\n            path1 = n1.path_from_root()\n            path2 = n2.path_from_root()[::-1]\n            if path1[-1] == path2[0]:\n                return path1 + path2[1:]\n            return path1 + path2\n\n        # Curvature penalty encourages smooth transitions: angle between segments in radians\n        def curvature_penalty(p_parent, p_last, p_new):\n            if p_parent is None:\n                return 0.0\n            v1 = tuple(p_last[i]-p_parent[i] for i in range(dim))\n            v2 = tuple(p_new[i]-p_last[i] for i in range(dim))\n            len1 = math.sqrt(sum(x*x for x in v1))\n            len2 = math.sqrt(sum(x*x for x in v2))\n            if len1 < 1e-14 or len2 < 1e-14:\n                return 0.0\n            dot = sum(v1[i]*v2[i] for i in range(dim)) / (len1 * len2)\n            dot = max(-1.0, min(1.0, dot))\n            return math.acos(dot)\n\n        # Multi-pass shortcutting to smooth and shorten paths\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path[:]\n            path = list(path)\n            changed = True\n            iter_count = 0\n            max_iters = self.shortcut_iters\n            while changed and iter_count < max_iters:\n                changed = False\n                iter_count += 1\n                i = 0\n                while i < len(path) - 2:\n                    max_j = min(len(path) - 1, i + 8 + random.randint(0,3))\n                    if max_j <= i + 1:\n                        i += 1\n                        continue\n                    j = random.randint(i+2, max_j)\n                    if not edge_obstacle(path[i], path[j]):\n                        path = path[:i+1] + path[j:]\n                        changed = True\n                        break\n                    i += 1\n            return path\n\n        # Initialization of trees and grid\n        start_root = Node(start, cost=0.0)\n        goal_root = Node(goal, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        all_nodes = [start_root, goal_root]\n        edges = []\n\n        grid_start = SpatialGrid(bounds, self.grid_cell_size, dim)\n        grid_goal = SpatialGrid(bounds, self.grid_cell_size, dim)\n        grid_start.insert(start_root)\n        grid_goal.insert(goal_root)\n\n        c_min = dist(start, goal)\n        best_cost = float('inf')\n        best_path = []\n        found_solution = False\n        no_improve_count = 0\n        last_best_cost = float('inf')\n        alpha_curv = 0.03\n\n        for it in range(self.max_iter):\n            sample = sample_informed(best_cost if found_solution else float('inf'))\n\n            tree_a, grid_a, tree_b, grid_b = (tree_start, grid_start, tree_goal, grid_goal) if it % 2 == 0 else (tree_goal, grid_goal, tree_start, grid_start)\n\n            # Candidate nearest neighbors in grid to sample\n            candidates = grid_a.neighbors(sample, step_size * 2.0)\n            if candidates:\n                nearest = min(candidates, key=lambda n: dist(n.position, sample))\n            else:\n                nearest = min(tree_a, key=lambda n: dist(n.position, sample))\n\n            new_pos = steer(nearest.position, sample, step_size)\n            if not in_bounds(new_pos) or in_obstacle(new_pos) or edge_obstacle(nearest.position, new_pos):\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n                continue\n\n            n_nodes = len(all_nodes)\n            radius = adaptive_radius(n_nodes, best_cost)\n\n            neighbors_in_radius = [n for n in grid_a.neighbors(new_pos, radius) if dist(n.position, new_pos) <= radius]\n\n            # Choose parent minimizing cost + curvature penalty\n            min_score = nearest.cost + dist(nearest.position, new_pos)\n            curv_pen = alpha_curv * curvature_penalty(nearest.parent.position if nearest.parent else None, nearest.position, new_pos)\n            min_score += curv_pen\n            best_parent = nearest\n            best_cost_to_new = min_score - curv_pen\n\n            for candidate in neighbors_in_radius:\n                if candidate == nearest:\n                    continue\n                if edge_obstacle(candidate.position, new_pos):\n                    continue\n                tmp_cost = candidate.cost + dist(candidate.position, new_pos)\n                curv_cand = alpha_curv * curvature_penalty(candidate.parent.position if candidate.parent else None, candidate.position, new_pos)\n                score_cand = tmp_cost + curv_cand\n                if score_cand + self.improve_tol < min_score:\n                    best_parent = candidate\n                    best_cost_to_new = tmp_cost\n                    min_score = score_cand\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = best_cost_to_new\n            tree_a.append(new_node)\n            all_nodes.append(new_node)\n            edges.append((best_parent, new_node))\n            grid_a.insert(new_node)\n\n            # Rewire neighbors to possibly reduce cost with curvature penalty constraints\n            for nb in neighbors_in_radius:\n                if nb == best_parent or nb == new_node:\n                    continue\n                alt_cost = new_node.cost + dist(new_node.position, nb.position)\n                if alt_cost + self.improve_tol < nb.cost:\n                    if not edge_obstacle(new_node.position, nb.position):\n                        # Compare curvature penalty for rewiring allowance\n                        curv_new = curvature_penalty(new_node.parent.position if new_node.parent else None, new_node.position, nb.position)\n                        curv_old = curvature_penalty(nb.parent.parent.position if nb.parent and nb.parent.parent else None,\n                                                    nb.parent.position if nb.parent else None,\n                                                    nb.position)\n                        if alpha_curv * curv_new <= alpha_curv * curv_old + 0.18:\n                            if nb.parent:\n                                nb.parent.remove_child(nb)\n                                try:\n                                    edges.remove((nb.parent, nb))\n                                except:\n                                    pass\n                            new_node.add_child(nb)\n                            nb.cost = alt_cost\n                            edges.append((new_node, nb))\n\n            # Attempt connect new_node with nodes of other tree inside radius\n            candidates_b = grid_b.neighbors(new_node.position, radius)\n            nearest_b = None\n            nearest_dist = float('inf')\n            for nb_node in candidates_b:\n                d_nb = dist(nb_node.position, new_node.position)\n                if d_nb < nearest_dist:\n                    nearest_dist = d_nb\n                    nearest_b = nb_node\n            if nearest_b and nearest_dist <= step_size and not edge_obstacle(new_node.position, nearest_b.position):\n                candidate_path = connect_path(new_node, nearest_b)\n                cost_connect = new_node.cost + dist(new_node.position, nearest_b.position) + nearest_b.cost\n                if cost_connect + self.improve_tol < best_cost:\n                    best_cost = cost_connect\n                    best_path = candidate_path\n                    found_solution = True\n                    no_improve_count = 0\n                else:\n                    no_improve_count += 1\n            elif found_solution:\n                no_improve_count += 1\n\n            if found_solution and no_improve_count >= self.max_no_improve:\n                break\n\n            if found_solution and best_cost + self.improve_tol < last_best_cost:\n                last_best_cost = best_cost\n                no_improve_count = 0\n\n        # Post-processing path smoothing with multi-pass shortcutting\n        if found_solution and len(best_path) > 3:\n            for _ in range(4):\n                best_path = shortcut_path(best_path)\n\n        if found_solution:\n            return PlannerResult(True, best_path, all_nodes, edges)\n        else:\n            return PlannerResult(False, [], all_nodes, edges)",
          "objective": -30.76555,
          "time_improvement": 45.0,
          "length_improvement": 14.0,
          "smoothness_improvement": 1809.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.02610607147216797,
                    "num_nodes_avg": 160.5,
                    "path_length_avg": 168.9755502828832,
                    "smoothness_avg": 0.045653219129898524,
                    "success_improvement": 0.0,
                    "time_improvement": -7.496821633508575,
                    "length_improvement": 7.3818233010107,
                    "smoothness_improvement": 614.572016935004,
                    "objective_score": 5.252907575228868
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.0313495397567749,
                    "num_nodes_avg": 281.9,
                    "path_length_avg": 241.80590666243202,
                    "smoothness_avg": 0.12894467947637372,
                    "success_improvement": 0.0,
                    "time_improvement": 80.58434420933136,
                    "length_improvement": 19.27822835896443,
                    "smoothness_improvement": 3217.839478025683,
                    "objective_score": 51.83143766830648
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.018782854080200195,
                    "num_nodes_avg": 205.8,
                    "path_length_avg": 128.95878155839154,
                    "smoothness_avg": 0.1333351501954944,
                    "success_improvement": 0.0,
                    "time_improvement": 62.07072530752751,
                    "length_improvement": 14.351717646199976,
                    "smoothness_improvement": 1596.0132687096545,
                    "objective_score": 35.21231452352651
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "A bidirectional RRT* planner with spatial hashing for fast neighbor search, consistent adaptive radius scaling, iterative rewiring for cost improvement, informed sampling within an ellipsoid after an initial solution, and an integrated multi-pass path shortcutting procedure. Early stopping avoids unnecessary computation by detecting stagnation. The planner alternates tree expansion, attempts direct tree connections, and robustly updates paths to deliver efficient planning, shorter and smoother paths.",
          "planning_mechanism": "The algorithm grows start and goal trees alternately using spatial hashing to efficiently find neighbors within a theoretically grounded radius. It selects parents minimizing cost, performs iterative rewiring to improve paths, and after first solution found, focuses sampling within an informed ellipsoid. It attempts direct connections to merge trees and applies multi-pass shortcutting to smooth and shorten the path. Early stopping is triggered upon stagnation to save search time.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(\n        self,\n        max_iter=4000,\n        step_size=5.5,\n        max_radius=28.0,\n        min_radius=5.5,\n        max_no_improve=70,\n        time_limit=25.0,\n        shortcut_passes=3,\n        shortcut_iter_per_pass=60,\n    ):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.max_radius = max_radius\n        self.min_radius = min_radius\n        self.max_no_improve = max_no_improve\n        self.time_limit = time_limit\n        self.shortcut_passes = shortcut_passes\n        self.shortcut_iter_per_pass = shortcut_iter_per_pass\n\n    def plan(self, map):\n        import math\n        import random\n        import time\n\n        start = tuple(map.start)\n        goal = tuple(map.goal)\n        bounds = tuple(map.size)\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = dim == 3\n        dist = lambda a, b: math.dist(a, b)\n\n        def in_bounds(p):\n            return all(0.0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def in_obstacle(p):\n            if is_3d:\n                px, py, pz = p\n                for obs in obstacles:\n                    ox, oy, oz, ow, oh, od = obs\n                    if ox <= px <= ox + ow and oy <= py <= oy + oh and oz <= pz <= oz + od:\n                        return True\n                return False\n            else:\n                px, py = p\n                for obs in obstacles:\n                    ox, oy, ow, oh = obs\n                    if ox <= px <= ox + ow and oy <= py <= oy + oh:\n                        return True\n                return False\n\n        def edge_in_obstacle(a, b, res=1.0):\n            d = dist(a, b)\n            if d < 1e-12:\n                return False\n            steps = max(3, int(d / res))\n            for i in range(steps + 1):\n                interp = tuple(a[dd] + (b[dd] - a[dd]) * i / steps for dd in range(dim))\n                if in_obstacle(interp):\n                    return True\n            return False\n\n        def steer(frm, to):\n            d = dist(frm, to)\n            if d <= self.step_size:\n                return to\n            ratio = self.step_size / d\n            return tuple(frm[d_] + (to[d_] - frm[d_]) * ratio for d_ in range(dim))\n\n        class SpatialHash:\n            def __init__(self, bounds, cell_size, dim):\n                self.bounds = bounds\n                self.cell_size = cell_size\n                self.dim = dim\n                self.cells = {}\n\n            def _hash_point(self, p):\n                return tuple(int(p[d] / self.cell_size) for d in range(self.dim))\n\n            def insert(self, node):\n                h = self._hash_point(node.position)\n                if h not in self.cells:\n                    self.cells[h] = []\n                self.cells[h].append(node)\n\n            def neighbors(self, point, radius):\n                r_cells = int(math.ceil(radius / self.cell_size))\n                center_cell = self._hash_point(point)\n                result = []\n                def _rec(idx=[], d=0):\n                    if d == self.dim:\n                        result.append(tuple(idx))\n                    else:\n                        for val in range(center_cell[d] - r_cells, center_cell[d] + r_cells + 1):\n                            idx.append(val)\n                            _rec(idx, d + 1)\n                            idx.pop()\n                _rec()\n                neighbors = []\n                for cell in result:\n                    if cell in self.cells:\n                        neighbors.extend(self.cells[cell])\n                res_sq = radius * radius\n                return [n for n in neighbors if sum((n.position[d] - point[d]) ** 2 for d in range(self.dim)) <= res_sq]\n\n        def adaptive_radius(n_nodes, iter_i):\n            if n_nodes <= 1:\n                return self.max_radius\n            base = self.max_radius * (math.log(n_nodes) / n_nodes) ** (1.0 / dim)\n            decay = max(self.min_radius / self.max_radius, 1.0 - 0.85 * iter_i / self.max_iter)\n            r = max(self.min_radius, min(base * decay, self.max_radius))\n            return r\n\n        def choose_parent(tree_nodes, grid, pos, iter_i):\n            n = len(tree_nodes)\n            r = adaptive_radius(n, iter_i)\n            nbrs = grid.neighbors(pos, r)\n            min_cost = float(\"inf\")\n            best_parent = None\n            for nb in nbrs:\n                if edge_in_obstacle(nb.position, pos):\n                    continue\n                new_cost = nb.cost + dist(nb.position, pos)\n                if new_cost < min_cost:\n                    min_cost = new_cost\n                    best_parent = nb\n            if best_parent is None:\n                # fallback nearest no collision parent\n                nearest = None\n                nearest_dist = float(\"inf\")\n                for n_node in tree_nodes:\n                    d_to = dist(n_node.position, pos)\n                    if d_to < nearest_dist and not edge_in_obstacle(n_node.position, pos):\n                        nearest = n_node\n                        nearest_dist = d_to\n                if nearest is None:\n                    return None, []\n                best_parent = nearest\n                min_cost = best_parent.cost + nearest_dist\n            new_node = Node(pos, parent=best_parent, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree_nodes.append(new_node)\n            grid.insert(new_node)\n            return new_node, nbrs\n\n        def rewire(pivot, nbrs):\n            for nb in nbrs:\n                if nb == pivot.parent:\n                    continue\n                new_cost = pivot.cost + dist(pivot.position, nb.position)\n                if new_cost + 1e-12 < nb.cost:\n                    if edge_in_obstacle(pivot.position, nb.position):\n                        continue\n                    if nb.parent is not None:\n                        nb.parent.remove_child(nb)\n                    pivot.add_child(nb)\n                    nb.cost = new_cost\n\n        def direct_connect(tree_nodes, grid, target_node):\n            if not tree_nodes:\n                return None\n            nearest = min(tree_nodes, key=lambda n: dist(n.position, target_node.position))\n            d_near = dist(nearest.position, target_node.position)\n            if d_near <= self.step_size:\n                if in_obstacle(target_node.position) or edge_in_obstacle(nearest.position, target_node.position):\n                    return None\n                new_node = Node(target_node.position, parent=nearest, cost=nearest.cost + d_near)\n                nearest.add_child(new_node)\n                tree_nodes.append(new_node)\n                grid.insert(new_node)\n                return new_node\n            # Attempt direct edge if collision free\n            if not edge_in_obstacle(nearest.position, target_node.position):\n                new_node = Node(target_node.position, parent=nearest, cost=nearest.cost + d_near)\n                nearest.add_child(new_node)\n                tree_nodes.append(new_node)\n                grid.insert(new_node)\n                return new_node\n            # Incrementally steer towards target\n            steps = int(math.ceil(d_near / self.step_size))\n            current = nearest\n            for _ in range(steps):\n                new_pos = steer(current.position, target_node.position)\n                if not in_bounds(new_pos) or in_obstacle(new_pos) or edge_in_obstacle(current.position, new_pos):\n                    return None\n                new_node = Node(new_pos, parent=current, cost=current.cost + dist(current.position, new_pos))\n                current.add_child(new_node)\n                tree_nodes.append(new_node)\n                grid.insert(new_node)\n                current = new_node\n                if dist(current.position, target_node.position) <= self.step_size:\n                    if in_obstacle(target_node.position) or edge_in_obstacle(current.position, target_node.position):\n                        return None\n                    final_node = Node(target_node.position, parent=current, cost=current.cost + dist(current.position, target_node.position))\n                    current.add_child(final_node)\n                    tree_nodes.append(final_node)\n                    grid.insert(final_node)\n                    return final_node\n            return None\n\n        def sample_uniform():\n            return tuple(random.uniform(0.0, bounds[d]) for d in range(dim))\n\n        def sample_informed():\n            if not found_solution or best_cost == float(\"inf\") or c_min < 1e-14:\n                return sample_uniform()\n            center = tuple((start[d] + goal[d]) * 0.5 for d in range(dim))\n            unit_dir = [(goal[d] - start[d]) / c_min for d in range(dim)]\n            r1 = best_cost * 0.5\n            val = max(best_cost * best_cost - c_min * c_min, 0)\n            r_other = math.sqrt(val) * 0.5\n\n            if dim == 2:\n                a1 = unit_dir\n                a2 = (-a1[1], a1[0])\n                basis = (a1, a2)\n                radii = (r1, r_other)\n            else:\n                def cross(u, v):\n                    return (u[1]*v[2] - u[2]*v[1], u[2]*v[0] - u[0]*v[2], u[0]*v[1] - u[1]*v[0])\n\n                def norm(v):\n                    return math.sqrt(sum(x*x for x in v))\n\n                a1 = unit_dir\n                ref = (1.0, 0.0, 0.0) if abs(a1[0]) < 0.9 else (0.0, 1.0, 0.0)\n                b2 = cross(a1, ref)\n                n_b2 = norm(b2)\n                if n_b2 < 1e-14:\n                    ref = (0.0, 0.0, 1.0)\n                    b2 = cross(a1, ref)\n                    n_b2 = norm(b2)\n                b2 = tuple(x / n_b2 for x in b2)\n                b3 = cross(a1, b2)\n                basis = (a1, b2, b3)\n                radii = (r1, r_other, r_other)\n\n            def sample_unit_ball(ndim):\n                while True:\n                    vec = [random.gauss(0, 1) for _ in range(ndim)]\n                    nrm = math.sqrt(sum(v * v for v in vec))\n                    if nrm < 1e-14:\n                        continue\n                    vec = [v / nrm for v in vec]\n                    r = random.random() ** (1.0 / ndim)\n                    return [v * r for v in vec]\n\n            u = sample_unit_ball(dim)\n            mapped = []\n            for d in range(dim):\n                val = center[d]\n                for i in range(dim):\n                    if i < len(basis):\n                        val += basis[i][d] * radii[i] * u[i]\n                val = max(0.0, min(val, bounds[d]))\n                mapped.append(val)\n            return tuple(mapped)\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path[:]\n            path = list(path)\n            for _ in range(self.shortcut_iter_per_pass):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if not edge_in_obstacle(path[i], path[j]):\n                    # Remove intermediate points\n                    path = path[: i + 1] + path[j :]\n            return path\n\n        def multi_pass_shortcut(path):\n            result = path\n            for _ in range(self.shortcut_passes):\n                result = shortcut_path(result)\n            return result\n\n        def connect_paths(node_a, node_b):\n            path_a = node_a.path_from_root()\n            path_b = node_b.path_from_root()\n            if path_a[-1] == path_b[-1]:\n                return path_a + path_b[-2::-1]\n            else:\n                return path_a + path_b[::-1]\n\n        start_root = Node(start, cost=0.0)\n        goal_root = Node(goal, cost=0.0)\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        cell_size = self.step_size * 1.5\n        grid_start = SpatialHash(bounds, cell_size, dim)\n        grid_goal = SpatialHash(bounds, cell_size, dim)\n        grid_start.insert(start_root)\n        grid_goal.insert(goal_root)\n\n        c_min = dist(start, goal)\n        best_cost = float(\"inf\")\n        best_path = []\n        found_solution = False\n        no_improve = 0\n\n        start_time = time.time()\n\n        for it in range(self.max_iter):\n            if time.time() - start_time > self.time_limit:\n                break\n\n            tree_a, grid_a = (start_tree, grid_start) if it % 2 == 0 else (goal_tree, grid_goal)\n            tree_b, grid_b = (goal_tree, grid_goal) if it % 2 == 0 else (start_tree, grid_start)\n\n            x_rand = sample_informed()\n\n            if not in_bounds(x_rand) or in_obstacle(x_rand):\n                if found_solution:\n                    no_improve += 1\n                    if no_improve >= self.max_no_improve:\n                        break\n                continue\n\n            nearest = min(tree_a, key=lambda n: dist(n.position, x_rand))\n            new_pos = steer(nearest.position, x_rand)\n            if not in_bounds(new_pos) or in_obstacle(new_pos) or edge_in_obstacle(nearest.position, new_pos):\n                if found_solution:\n                    no_improve += 1\n                    if no_improve >= self.max_no_improve:\n                        break\n                continue\n\n            new_node, nbrs = choose_parent(tree_a, grid_a, new_pos, it)\n            if new_node is None:\n                if found_solution:\n                    no_improve += 1\n                    if no_improve >= self.max_no_improve:\n                        break\n                continue\n\n            rewire(new_node, nbrs)\n            nodes.append(new_node)\n            edges.append((new_node.parent, new_node))\n\n            meet_node = direct_connect(tree_b, grid_b, new_node)\n            if meet_node is not None:\n                candidate_path = connect_paths(new_node, meet_node)\n                total_cost = 0.0\n                for i in range(len(candidate_path) - 1):\n                    total_cost += dist(candidate_path[i], candidate_path[i + 1])\n\n                if total_cost + 1e-12 < best_cost:\n                    best_cost = total_cost\n                    best_path = candidate_path\n                    found_solution = True\n                    no_improve = 0\n                else:\n                    if found_solution:\n                        no_improve += 1\n                        if no_improve >= self.max_no_improve:\n                            break\n            else:\n                if found_solution:\n                    no_improve += 1\n                    if no_improve >= self.max_no_improve:\n                        break\n\n        if found_solution and len(best_path) >= 3:\n            best_path = multi_pass_shortcut(best_path)\n\n        return PlannerResult(success=found_solution, path=best_path, nodes=nodes, edges=edges)",
          "objective": -30.13231,
          "time_improvement": 44.0,
          "length_improvement": 16.0,
          "smoothness_improvement": 1459.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.025123214721679686,
                    "num_nodes_avg": 116.3,
                    "path_length_avg": 164.54278418565775,
                    "smoothness_avg": 0.04731325250463405,
                    "success_improvement": 0.0,
                    "time_improvement": -3.449717996671913,
                    "length_improvement": 9.811492640573752,
                    "smoothness_improvement": 640.5551440697853,
                    "objective_score": 8.054755905691604
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.04280211925506592,
                    "num_nodes_avg": 250.4,
                    "path_length_avg": 235.10494261062905,
                    "smoothness_avg": 0.09734598136668222,
                    "success_improvement": 0.0,
                    "time_improvement": 73.49143811950486,
                    "length_improvement": 21.515203036012164,
                    "smoothness_improvement": 2404.7822160410233,
                    "objective_score": 46.980464337663875
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.018729448318481445,
                    "num_nodes_avg": 161.2,
                    "path_length_avg": 125.35572995809525,
                    "smoothness_avg": 0.11260013109151763,
                    "success_improvement": 0.0,
                    "time_improvement": 62.17857056883561,
                    "length_improvement": 16.744692960236716,
                    "smoothness_improvement": 1332.2653562069754,
                    "objective_score": 35.36171372782759
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m2",
          "algorithm_description": "An improved bidirectional RRT* planner with adaptive, theoretically grounded neighbor radius based on node count and problem dimension, enhanced rewiring that iteratively refines the parent-child relationships for better path cost, and informed sampling within an ellipsoidal subset after initial solution discovery to focus sampling and accelerate convergence. It incorporates a dynamic, multi-pass shortcutting routine for systematic path shortening and smoothing, and a stagnation-based early stopping mechanism. The planner leverages spatial hashing for efficient neighbor search and alternates expansion between start and goal trees while frequently attempting direct tree connections to quickly merge paths.",
          "planning_mechanism": "The planning process alternates growth between two trees from start and goal states. Uniform random sampling is used initially, then switches to ellipsoidal informed sampling constrained by the current best path cost. New nodes are added by steering toward sampled points, picking parents minimizing path cost with exhaustive collision checking, and neighbors are rewired if a lower cost path is found through the new node. Direct connections between trees are attempted each iteration to merge the trees early. The search halts when improvements stagnate. Finally, a comprehensive multi-pass shortcutting routine reduces path length and smoothness by reconnecting distant waypoints when collision-free. This strategy results in faster convergence, lower path cost, and smoother collision-free trajectories.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=4500, step_size=6.0, max_radius=30.0,\n                 min_radius=6.0, max_no_improve=60, time_limit=25.0,\n                 shortcut_iters=200):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.max_radius = max_radius\n        self.min_radius = min_radius\n        self.max_no_improve = max_no_improve\n        self.time_limit = time_limit\n        self.shortcut_iters = shortcut_iters\n\n    def plan(self, map):\n        import random\n        import math\n        import time\n\n        start = tuple(map.start)\n        goal = tuple(map.goal)\n        bounds = tuple(map.size)\n        obstacles = map.obstacles\n        dim = len(bounds)\n        dist = lambda a, b: math.dist(a, b)\n\n        def in_bounds(p):\n            return all(0.0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def in_obstacle(p):\n            if dim == 3:\n                px, py, pz = p\n                for ox, oy, oz, ow, oh, od in obstacles:\n                    if ox <= px <= ox+ow and oy <= py <= oy+oh and oz <= pz <= oz+od:\n                        return True\n                return False\n            else:\n                px, py = p\n                for ox, oy, ow, oh in obstacles:\n                    if ox <= px <= ox+ow and oy <= py <= oy+oh:\n                        return True\n                return False\n\n        def edge_in_obstacle(a, b, resolution=1.0):\n            d = dist(a, b)\n            if d < 1e-14:\n                return False\n            steps = max(2, int(d / resolution))\n            for i in range(steps + 1):\n                ipos = tuple(a[d_] + (b[d_] - a[d_]) * i / steps for d_ in range(dim))\n                if in_obstacle(ipos):\n                    return True\n            return False\n\n        def steer(from_p, to_p):\n            d = dist(from_p, to_p)\n            if d <= self.step_size:\n                return to_p\n            ratio = self.step_size / d\n            return tuple(from_p[d_] + (to_p[d_] - from_p[d_]) * ratio for d_ in range(dim))\n\n        class SpatialGrid:\n            def __init__(self, bounds, cell_size, dim):\n                self.bounds = bounds\n                self.cell_size = cell_size\n                self.dim = dim\n                self.cells = {}\n\n            def _hash_point(self, p):\n                return tuple(int(p[d] // self.cell_size) for d in range(self.dim))\n\n            def insert(self, node):\n                key = self._hash_point(node.position)\n                if key not in self.cells:\n                    self.cells[key] = []\n                self.cells[key].append(node)\n\n            def neighbors(self, point, radius):\n                low = [int((point[d] - radius) // self.cell_size) for d in range(self.dim)]\n                high = [int((point[d] + radius) // self.cell_size) for d in range(self.dim)]\n                result = []\n                def recur(idx=0, cur=[]):\n                    if idx == self.dim:\n                        t = tuple(cur)\n                        if t in self.cells:\n                            result.extend(self.cells[t])\n                        return\n                    for x in range(low[idx], high[idx]+1):\n                        cur.append(x)\n                        recur(idx+1, cur)\n                        cur.pop()\n                recur()\n                return result\n\n            def clear(self):\n                self.cells.clear()\n\n        def adaptive_radius(node_num, iteration):\n            if node_num <= 1:\n                return self.max_radius\n            base = self.max_radius * ((math.log(node_num) / node_num) ** (1/dim))\n            decay = 1.0 - 0.85 * (iteration / self.max_iter)\n            decay = max(decay, self.min_radius / self.max_radius)\n            r = base * decay\n            return min(max(r, self.min_radius), self.max_radius)\n\n        def neighbors_in_radius(tree_nodes, grid, p, radius):\n            candidates = grid.neighbors(p, radius)\n            return [n for n in candidates if dist(n.position, p) <= radius]\n\n        def choose_parent(tree_nodes, grid, pos, iter_i):\n            n = len(tree_nodes)\n            r = adaptive_radius(n, iter_i)\n            nbrs = neighbors_in_radius(tree_nodes, grid, pos, r)\n            min_cost = float('inf')\n            best_parent = None\n            for nb in nbrs:\n                if edge_in_obstacle(nb.position, pos):\n                    continue\n                cost_new = nb.cost + dist(nb.position, pos)\n                if cost_new < min_cost:\n                    min_cost = cost_new\n                    best_parent = nb\n            if best_parent is None:\n                # fallback nearest in the entire tree with collision check\n                nearest = min(tree_nodes, key=lambda n: dist(n.position, pos))\n                if edge_in_obstacle(nearest.position, pos):\n                    return None, []\n                min_cost = nearest.cost + dist(nearest.position, pos)\n                best_parent = nearest\n            new_node = Node(pos, best_parent, min_cost)\n            best_parent.add_child(new_node)\n            tree_nodes.append(new_node)\n            grid.insert(new_node)\n            return new_node, nbrs\n\n        def rewire(pivot, nbrs):\n            for nb in nbrs:\n                if nb is pivot.parent:\n                    continue\n                cost_through_pivot = pivot.cost + dist(pivot.position, nb.position)\n                if cost_through_pivot + 1e-12 < nb.cost:\n                    if edge_in_obstacle(pivot.position, nb.position):\n                        continue\n                    if nb.parent is not None:\n                        nb.parent.remove_child(nb)\n                    pivot.add_child(nb)\n                    nb.cost = cost_through_pivot\n\n        def direct_connect(tree_nodes, grid, target_node):\n            if not tree_nodes:\n                return None\n            nearest = min(tree_nodes, key=lambda n: dist(n.position, target_node.position))\n            d_near = dist(nearest.position, target_node.position)\n            if d_near <= self.step_size:\n                if in_obstacle(target_node.position) or edge_in_obstacle(nearest.position, target_node.position):\n                    return None\n                new_node = Node(target_node.position, nearest, nearest.cost + d_near)\n                nearest.add_child(new_node)\n                tree_nodes.append(new_node)\n                grid.insert(new_node)\n                return new_node\n            # Try straight connection if feasible\n            if not edge_in_obstacle(nearest.position, target_node.position):\n                new_node = Node(target_node.position, nearest, nearest.cost + d_near)\n                nearest.add_child(new_node)\n                tree_nodes.append(new_node)\n                grid.insert(new_node)\n                return new_node\n            # else stepwise steering\n            curr = nearest\n            steps = int(math.ceil(d_near / self.step_size))\n            for _ in range(steps):\n                new_pos = steer(curr.position, target_node.position)\n                if not in_bounds(new_pos) or in_obstacle(new_pos) or edge_in_obstacle(curr.position, new_pos):\n                    return None\n                new_node = Node(new_pos, curr, curr.cost + dist(curr.position, new_pos))\n                curr.add_child(new_node)\n                tree_nodes.append(new_node)\n                grid.insert(new_node)\n                curr = new_node\n                if dist(curr.position, target_node.position) <= self.step_size:\n                    if in_obstacle(target_node.position) or edge_in_obstacle(curr.position, target_node.position):\n                        return None\n                    final_node = Node(target_node.position, curr, curr.cost + dist(curr.position, target_node.position))\n                    curr.add_child(final_node)\n                    tree_nodes.append(final_node)\n                    grid.insert(final_node)\n                    return final_node\n            return None\n\n        def sample_uniform():\n            return tuple(random.uniform(0.0, bounds[d]) for d in range(dim))\n\n        def sample_informed():\n            # If no solution, uniform sampling\n            if not found_solution or best_cost >= float('inf') or c_min < 1e-12:\n                return sample_uniform()\n            center = tuple((start[d] + goal[d]) * 0.5 for d in range(dim))\n            unit_vec = [(goal[d] - start[d]) / c_min for d in range(dim)]\n            r1 = best_cost * 0.5\n            val = best_cost * best_cost - c_min * c_min\n            val = val if val > 0 else 0.0\n            r_other = math.sqrt(val) * 0.5\n            if dim == 2:\n                a1 = unit_vec\n                a2 = (-a1[1], a1[0])\n                basis = (a1, a2)\n                radii = (r1, r_other)\n            else:\n                def cross(u,v):\n                    return (u[1]*v[2]-u[2]*v[1], u[2]*v[0]-u[0]*v[2], u[0]*v[1]-u[1]*v[0])\n                def norm(v):\n                    return math.sqrt(sum(x*x for x in v))\n                a1 = unit_vec\n                ref = (1,0,0) if abs(a1[0]) < 0.9 else (0,1,0)\n                b2 = cross(a1, ref)\n                n_b2 = norm(b2)\n                if n_b2 < 1e-14:\n                    ref = (0,0,1)\n                    b2 = cross(a1, ref)\n                    n_b2 = norm(b2)\n                b2 = tuple(x / n_b2 for x in b2)\n                b3 = cross(a1, b2)\n                basis = (a1, b2, b3)\n                radii = (r1, r_other, r_other)\n\n            def sample_unit_ball(dim_):\n                while True:\n                    vec = [random.gauss(0,1) for _ in range(dim_)]\n                    nrm = math.sqrt(sum(x*x for x in vec))\n                    if nrm < 1e-14:\n                        continue\n                    vec = [x / nrm for x in vec]\n                    r = random.random() ** (1.0/dim_)\n                    return [x*r for x in vec]\n\n            u = sample_unit_ball(dim)\n            mapped = []\n            for d in range(dim):\n                val = center[d]\n                for i in range(dim):\n                    if i < len(basis):\n                        val += basis[i][d] * radii[i] * u[i]\n                val = min(max(val, 0.0), bounds[d])\n                mapped.append(val)\n            return tuple(mapped)\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return list(path)\n            path = list(path)\n            for _ in range(self.shortcut_iters):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if not edge_in_obstacle(p1, p2):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        def connect_paths(node1, node2):\n            p1 = node1.path_from_root()\n            p2 = node2.path_from_root()\n            if p1[-1] == p2[-1]:\n                return p1 + p2[-2::-1]\n            else:\n                return p1 + p2[::-1]\n\n        start_root = Node(start)\n        goal_root = Node(goal)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n\n        cellsize = self.step_size * 1.3\n        grid_start = SpatialGrid(bounds, cellsize, dim)\n        grid_goal = SpatialGrid(bounds, cellsize, dim)\n        grid_start.insert(start_root)\n        grid_goal.insert(goal_root)\n\n        c_min = dist(start, goal)\n        best_cost = float('inf')\n        best_path = []\n        found_solution = False\n        no_improve = 0\n\n        start_time = time.time()\n\n        for it in range(self.max_iter):\n            if time.time() - start_time > self.time_limit:\n                break\n\n            # Alternate expansion trees\n            if it % 2 == 0:\n                tree_a, grid_a = tree_start, grid_start\n                tree_b, grid_b = tree_goal, grid_goal\n            else:\n                tree_a, grid_a = tree_goal, grid_goal\n                tree_b, grid_b = tree_start, grid_start\n\n            x_rand = sample_informed()\n\n            if not in_bounds(x_rand) or in_obstacle(x_rand):\n                if found_solution:\n                    no_improve += 1\n                    if no_improve >= self.max_no_improve:\n                        break\n                continue\n\n            nearest = min(tree_a, key=lambda n: dist(n.position, x_rand))\n            new_pos = steer(nearest.position, x_rand)\n            if not in_bounds(new_pos) or in_obstacle(new_pos) or edge_in_obstacle(nearest.position, new_pos):\n                if found_solution:\n                    no_improve += 1\n                    if no_improve >= self.max_no_improve:\n                        break\n                continue\n\n            new_node, nbrs = choose_parent(tree_a, grid_a, new_pos, it)\n            if new_node is None:\n                if found_solution:\n                    no_improve += 1\n                    if no_improve >= self.max_no_improve:\n                        break\n                continue\n\n            rewire(new_node, nbrs)\n\n            meet_node = direct_connect(tree_b, grid_b, new_node)\n            if meet_node is not None:\n                candidate_path = connect_paths(new_node, meet_node)\n                total_cost = 0.0\n                for i in range(len(candidate_path) - 1):\n                    total_cost += dist(candidate_path[i], candidate_path[i + 1])\n                if total_cost + 1e-9 < best_cost:\n                    best_cost = total_cost\n                    best_path = candidate_path\n                    found_solution = True\n                    no_improve = 0\n                else:\n                    if found_solution:\n                        no_improve += 1\n                        if no_improve >= self.max_no_improve:\n                            break\n            else:\n                if found_solution:\n                    no_improve += 1\n                    if no_improve >= self.max_no_improve:\n                        break\n\n        if found_solution and len(best_path) >= 3:\n            best_path = shortcut_path(best_path)\n\n        edges = []\n        nodes = tree_start + tree_goal\n\n        return PlannerResult(success=found_solution, path=best_path, nodes=nodes, edges=edges)",
          "objective": -29.91783,
          "time_improvement": 46.0,
          "length_improvement": 14.0,
          "smoothness_improvement": 1555.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.020644402503967284,
                    "num_nodes_avg": 118.4,
                    "path_length_avg": 169.0226977959034,
                    "smoothness_avg": 0.04720262625634684,
                    "success_improvement": 0.0,
                    "time_improvement": 14.992661532193544,
                    "length_improvement": 7.355981002024172,
                    "smoothness_improvement": 638.8236030553472,
                    "objective_score": 12.105505076149303
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.025356411933898926,
                    "num_nodes_avg": 252.5,
                    "path_length_avg": 240.011600121993,
                    "smoothness_avg": 0.10931841458459605,
                    "success_improvement": 0.0,
                    "time_improvement": 84.29605761313955,
                    "length_improvement": 19.877219528413136,
                    "smoothness_improvement": 2712.841546133033,
                    "objective_score": 50.779356731654914
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.031077861785888672,
                    "num_nodes_avg": 294.5,
                    "path_length_avg": 127.65842370425962,
                    "smoothness_avg": 0.1111108992511941,
                    "success_improvement": 0.0,
                    "time_improvement": 37.24272405575215,
                    "length_improvement": 15.215353416527435,
                    "smoothness_improvement": 1313.3224371217204,
                    "objective_score": 26.868641452250706
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "path_expert",
          "algorithm_description": "A bidirectional asymptotically optimal RRT* variant with adaptive neighbor radius and progressive informed sampling focusing search on ellipsoidal subset post initial solution, combined with dynamic rewiring restricting checks to adaptive radius neighborhood shrinking with best cost, early termination on improvement stagnation, and efficient path shortening by progressive edge skips to significantly minimize path length and improve smoothness and planning speed.",
          "planning_mechanism": "A bidirectional planner grows two trees alternately from start and goal by sampling points with uniform distribution initially, switching to informed ellipsoidal sampling after initial feasible path discovered. Each new node selects parent minimizing cost within an adaptive neighborhood radius that shrinks as best path cost improves, rewires neighbors within this radius for incremental path cost reduction, and attempts connecting to opposite tree. Early termination triggers after stagnation. Final path undergoes efficient shortcut smoothing by attempting to connect non-adjacent nodes iteratively with minimal edge checks, resulting in shorter and smoother path.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self,\n                 max_iter=3000,\n                 step_size=5.0,\n                 neighbor_radius_max=30.0,\n                 neighbor_radius_min=5.0,\n                 max_no_improve=50,\n                 shortcut_iter=200):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.neighbor_radius_max = neighbor_radius_max\n        self.neighbor_radius_min = neighbor_radius_min\n        self.max_no_improve = max_no_improve\n        self.shortcut_iter = shortcut_iter\n\n    def plan(self, map):\n        import math\n        import random\n        bounds = map.size\n        dim = len(bounds)\n        start_pos = tuple(map.start)\n        goal_pos = tuple(map.goal)\n        obstacles = map.obstacles\n        is_3d = (dim == 3)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def in_obstacle(p):\n            px, py, pz = (p + (0, 0, 0))[:3]\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def edge_in_obstacle(a, b, resolution=1.0):\n            dist_ab = math.dist(a, b)\n            if dist_ab < 1e-12:\n                return False\n            steps = max(2, int(dist_ab / resolution))\n            for i in range(steps + 1):\n                interp = tuple(a[d] + (b[d] - a[d]) * i / steps for d in range(dim))\n                if in_obstacle(interp):\n                    return True\n            return False\n\n        def steer(frm, to):\n            dist = math.dist(frm, to)\n            if dist <= self.step_size:\n                return to\n            ratio = self.step_size / dist\n            return tuple(frm[d] + (to[d] - frm[d]) * ratio for d in range(dim))\n\n        def dist_sq(a, b):\n            return sum((a[d] - b[d])**2 for d in range(dim))\n\n        def neighbors(tree, point, radius):\n            rad_sq = radius * radius\n            res = []\n            for node in tree:\n                if dist_sq(node.position, point) <= rad_sq:\n                    res.append(node)\n            return res\n\n        def choose_parent(tree, new_pos, radius):\n            nbrs = neighbors(tree, new_pos, radius)\n            valid_parents = [n for n in nbrs if not edge_in_obstacle(n.position, new_pos)]\n            if not valid_parents:\n                # fallback: nearest with collision-free edge\n                nearest = None\n                nearest_dist = float('inf')\n                for n in tree:\n                    d = math.dist(n.position, new_pos)\n                    if d < nearest_dist and not edge_in_obstacle(n.position, new_pos):\n                        nearest = n\n                        nearest_dist = d\n                if nearest is None:\n                    return None, []\n                cost = nearest.cost + nearest_dist\n                new_node = Node(new_pos, parent=nearest, cost=cost)\n                nearest.add_child(new_node)\n                tree.append(new_node)\n                return new_node, []\n            best_parent = min(valid_parents, key=lambda p: p.cost + math.dist(p.position, new_pos))\n            cost_min = best_parent.cost + math.dist(best_parent.position, new_pos)\n            new_node = Node(new_pos, parent=best_parent, cost=cost_min)\n            best_parent.add_child(new_node)\n            tree.append(new_node)\n            return new_node, valid_parents\n\n        def rewire(pivot, neighbors_):\n            for nb in neighbors_:\n                if nb == pivot.parent:\n                    continue\n                dist_pivot_nb = math.dist(pivot.position, nb.position)\n                new_cost = pivot.cost + dist_pivot_nb\n                if new_cost + 1e-12 < nb.cost:\n                    if edge_in_obstacle(pivot.position, nb.position):\n                        continue\n                    if nb.parent:\n                        nb.parent.remove_child(nb)\n                    pivot.add_child(nb)\n                    nb.cost = new_cost\n\n        def attempt_connect(tree_from, target_node):\n            if not tree_from:\n                return None\n            # Nearest neighbor in tree_from to target_node\n            nearest = min(tree_from, key=lambda n: math.dist(n.position, target_node.position))\n            dist_near = math.dist(nearest.position, target_node.position)\n            if dist_near <= self.step_size:\n                if edge_in_obstacle(nearest.position, target_node.position) or in_obstacle(target_node.position):\n                    return None\n                new_node = Node(target_node.position, parent=nearest, cost=nearest.cost + dist_near)\n                nearest.add_child(new_node)\n                tree_from.append(new_node)\n                return new_node\n            # incremental steering towards target node\n            current = nearest\n            steps = int(math.ceil(dist_near / self.step_size))\n            for _ in range(steps):\n                new_pos = steer(current.position, target_node.position)\n                if not in_bounds(new_pos) or in_obstacle(new_pos) or edge_in_obstacle(current.position, new_pos):\n                    return None\n                new_node = Node(new_pos, parent=current, cost=current.cost + math.dist(current.position, new_pos))\n                current.add_child(new_node)\n                tree_from.append(new_node)\n                current = new_node\n                if math.dist(current.position, target_node.position) <= self.step_size:\n                    if edge_in_obstacle(current.position, target_node.position) or in_obstacle(target_node.position):\n                        return None\n                    final_node = Node(target_node.position, parent=current,\n                                      cost=current.cost + math.dist(current.position, target_node.position))\n                    current.add_child(final_node)\n                    tree_from.append(final_node)\n                    return final_node\n            return None\n\n        def sample_uniform():\n            return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        def sample_informed(c_best, c_min):\n            if c_best == float('inf') or c_min < 1e-12:\n                return sample_uniform()\n            center = tuple((start_pos[d] + goal_pos[d]) * 0.5 for d in range(dim))\n            unit_dir = []\n            for d in range(dim):\n                unit_dir.append((goal_pos[d] - start_pos[d]) / c_min)\n            r1 = c_best * 0.5\n            val = max(c_best*c_best - c_min*c_min, 0.0)\n            r_other = math.sqrt(val)*0.5\n\n            if dim == 2:\n                a1 = unit_dir\n                a2 = (-a1[1], a1[0])\n                basis = (a1, a2)\n                radii = (r1, r_other)\n            else:\n                def cross(u,v):\n                    return (u[1]*v[2]-u[2]*v[1], u[2]*v[0]-u[0]*v[2], u[0]*v[1]-u[1]*v[0])\n                def norm(v):\n                    return math.sqrt(sum(x*x for x in v))\n                a1 = unit_dir\n                ref = (1,0,0) if abs(a1[0]) < 0.9 else (0,1,0)\n                b2 = cross(a1, ref)\n                n_b2 = norm(b2)\n                if n_b2 < 1e-12:\n                    ref = (0,0,1)\n                    b2 = cross(a1, ref)\n                    n_b2 = norm(b2)\n                b2 = tuple(x / n_b2 for x in b2)\n                b3 = cross(a1, b2)\n                basis = (a1, b2, b3)\n                radii = (r1, r_other, r_other)\n\n            def sample_unit_ball(d):\n                while True:\n                    vec = [random.gauss(0,1) for _ in range(d)]\n                    nrm = math.sqrt(sum(v*v for v in vec))\n                    if nrm < 1e-12:\n                        continue\n                    vec = [v/nrm for v in vec]\n                    r = random.random() ** (1/d)\n                    return [v*r for v in vec]\n\n            u = sample_unit_ball(dim)\n            mapped = []\n            for d in range(dim):\n                val = center[d]\n                for i in range(dim):\n                    val += basis[i][d] * radii[i] * u[i]\n                # clamp to bounds\n                val = max(0.0, min(val, bounds[d]))\n                mapped.append(val)\n            return tuple(mapped)\n\n        def adaptive_radius(num_nodes, best_cost):\n            # Decay neighbor radius inversely with node count and best_cost\n            r = min(self.neighbor_radius_max,\n                    max(self.neighbor_radius_min,\n                        self.neighbor_radius_max * (math.log(num_nodes + 1) / (num_nodes + 1))**0.5))\n            if best_cost != float('inf'):\n                # shrink radius proportional to best_cost\n                r = max(self.neighbor_radius_min, min(r, best_cost * 0.5))\n            return r\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return list(path)\n            path = list(path)\n            i = 0\n            while i < len(path)-2:\n                j = len(path) - 1\n                while j > i + 1:\n                    if not edge_in_obstacle(path[i], path[j]):\n                        # shortcut by skipping intermediate nodes\n                        path = path[:i+1] + path[j:]\n                        j = i + 1\n                    else:\n                        j -= 1\n                i += 1\n                if i >= self.shortcut_iter:\n                    break\n            return path\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        best_path = []\n        best_cost = float('inf')\n        c_min = math.dist(start_pos, goal_pos)\n        found_solution = False\n        no_improve_count = 0\n\n        for iter_i in range(self.max_iter):\n            if found_solution:\n                sample = sample_informed(best_cost, c_min)\n                if random.random() < 0.15:\n                    sample = sample_uniform()  # exploration chance\n            else:\n                sample = sample_uniform()\n\n            if not in_bounds(sample) or in_obstacle(sample):\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n                continue\n\n            tree_a, tree_b = (start_tree, goal_tree) if iter_i % 2 == 0 else (goal_tree, start_tree)\n\n            # Nearest node in tree_a\n            nearest_n = min(tree_a, key=lambda n: math.dist(n.position, sample))\n            new_pos = steer(nearest_n.position, sample)\n            if not in_bounds(new_pos) or in_obstacle(new_pos) or edge_in_obstacle(nearest_n.position, new_pos):\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n                continue\n\n            rad = adaptive_radius(len(nodes), best_cost)\n            new_node, nbrs = choose_parent(tree_a, new_pos, rad)\n            if new_node is None:\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n                continue\n\n            rewire(new_node, nbrs)\n            nodes.append(new_node)\n            if new_node.parent:\n                edges.append((new_node.parent, new_node))\n\n            connect_node = attempt_connect(tree_b, new_node)\n            if connect_node:\n                if iter_i % 2 == 0:\n                    path_a = new_node.path_from_root()\n                    path_b = connect_node.path_from_root()\n                else:\n                    path_a = connect_node.path_from_root()\n                    path_b = new_node.path_from_root()\n\n                if path_a and path_b and (path_a[-1] == path_b[-1]):\n                    candidate_path = path_a + path_b[-2::-1]\n                else:\n                    candidate_path = path_a + path_b[::-1]\n\n                total_cost = 0.0\n                for i in range(len(candidate_path)-1):\n                    total_cost += math.dist(candidate_path[i], candidate_path[i+1])\n\n                if total_cost + 1e-9 < best_cost:\n                    best_cost = total_cost\n                    best_path = candidate_path\n                    found_solution = True\n                    no_improve_count = 0\n                else:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n            else:\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n\n        if found_solution and len(best_path) >= 3:\n            best_path = shortcut_path(best_path)\n\n        return PlannerResult(success=found_solution, path=best_path, nodes=nodes, edges=edges)",
          "objective": -29.5854,
          "time_improvement": 35.0,
          "length_improvement": 17.0,
          "smoothness_improvement": 1734.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.01630527973175049,
                    "num_nodes_avg": 82.8,
                    "path_length_avg": 161.05776434064808,
                    "smoothness_avg": 0.053811509689846534,
                    "success_improvement": 0.0,
                    "time_improvement": 32.85984262790777,
                    "length_improvement": 11.721687241296925,
                    "smoothness_improvement": 742.2669802096958,
                    "objective_score": 20.60230003419896
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.046596860885620116,
                    "num_nodes_avg": 251.8,
                    "path_length_avg": 233.4754024234387,
                    "smoothness_avg": 0.10983159911883991,
                    "success_improvement": 0.0,
                    "time_improvement": 71.14124740267181,
                    "length_improvement": 22.05919045420994,
                    "smoothness_improvement": 2726.0461538310064,
                    "objective_score": 48.20811926248254
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.04924318790435791,
                    "num_nodes_avg": 268.5,
                    "path_length_avg": 122.70798890963113,
                    "smoothness_avg": 0.14427317884692367,
                    "success_improvement": 0.0,
                    "time_improvement": 0.5604583423605622,
                    "length_improvement": 18.5031964927466,
                    "smoothness_improvement": 1735.1441857945422,
                    "objective_score": 19.945776327328836
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m1",
          "algorithm_description": "A bidirectional RRT* planner with consistent adaptive neighbor radius, incremental rewiring on insertions, and ellipsoidal informed sampling guiding exploration. It aggressively attempts direct tree connections, applies iterative random shortcutting post-planning for path smoothing and shortening, and includes early stopping after stagnation to save time, thus improving planning efficiency, path quality, robustness, and smoothness.",
          "planning_mechanism": "The planner grows two trees from start and goal points by sampling points with uniform distribution initially and ellipsoidal informed sampling once a solution is found. Each iteration alternates expanding one tree toward a sampled point, choosing a parent and rewiring neighbors within an adaptive radius that shrinks over iterations. After each insertion, it tries direct connection to the opposite tree to form a valid path. The best discovered path is updated incrementally, and if no improvement occurs over many iterations, planning halts early. Post-planning applies multiple shortcut attempts on the best path to enhance smoothness and reduce length.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self,\n                 max_iter=5000,\n                 step_size=5.0,\n                 max_radius=30.0,\n                 min_radius=5.0,\n                 max_no_improve=80,\n                 time_limit=30.0,\n                 shortcut_iter=150):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.max_radius = max_radius\n        self.min_radius = min_radius\n        self.max_no_improve = max_no_improve\n        self.time_limit = time_limit\n        self.shortcut_iter = shortcut_iter\n\n    def plan(self, map):\n        import time\n        import math\n        import random\n\n        bounds = map.size\n        dim = len(bounds)\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = (dim == 3)\n\n        def in_bounds(pos):\n            return all(0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    px, py = pos\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def edge_in_obstacle(a, b, res=1.0):\n            dist = math.dist(a, b)\n            if dist < 1e-12:\n                return False\n            steps = max(2, int(dist / res))\n            for i in range(steps + 1):\n                interp = tuple(a[d] + (b[d] - a[d]) * i / steps for d in range(dim))\n                if in_obstacle(interp):\n                    return True\n            return False\n\n        def steer(from_p, to_p):\n            dist = math.dist(from_p, to_p)\n            if dist <= self.step_size:\n                return to_p\n            ratio = self.step_size / dist\n            return tuple(from_p[d] + (to_p[d] - from_p[d]) * ratio for d in range(dim))\n\n        def adaptive_radius(n, iter_i):\n            gamma = self.max_radius\n            unit_ball_volume = (math.pi ** (dim / 2)) / math.gamma(dim / 2 + 1) if dim > 1 else 2.0\n            if n < 1:\n                return self.max_radius\n            radius = gamma * ((math.log(n + 1) / (n + 1)) ** (1 / dim))\n            decay = max(self.min_radius / gamma, 1.0 - 0.9 * (iter_i / self.max_iter))\n            radius = max(self.min_radius, min(radius * decay, self.max_radius))\n            return radius\n\n        def neighbors(tree, pos, radius):\n            r_sq = radius * radius\n            result = []\n            for node in tree:\n                dist_sq = 0.0\n                for d in range(dim):\n                    diff = node.position[d] - pos[d]\n                    dist_sq += diff * diff\n                    if dist_sq > r_sq:\n                        break\n                else:\n                    result.append(node)\n            return result\n\n        def choose_parent(tree, pos, iter_i):\n            n = len(tree)\n            r = adaptive_radius(n, iter_i)\n            nbrs = neighbors(tree, pos, r)\n            if not nbrs:\n                nearest = min(tree, key=lambda node: math.dist(node.position, pos))\n                if edge_in_obstacle(nearest.position, pos) or in_obstacle(pos):\n                    return None, []\n                cost_to_here = nearest.cost + math.dist(nearest.position, pos)\n                new_node = Node(pos, parent=nearest, cost=cost_to_here)\n                nearest.add_child(new_node)\n                tree.append(new_node)\n                return new_node, []\n            min_cost = float('inf')\n            best_parent = None\n            for nb in nbrs:\n                dist_nb = math.dist(nb.position, pos)\n                est_cost = nb.cost + dist_nb\n                if est_cost >= min_cost:\n                    continue\n                if edge_in_obstacle(nb.position, pos):\n                    continue\n                if est_cost < min_cost:\n                    min_cost = est_cost\n                    best_parent = nb\n            if best_parent is None:\n                nearest = min(tree, key=lambda node: math.dist(node.position, pos))\n                if edge_in_obstacle(nearest.position, pos) or in_obstacle(pos):\n                    return None, []\n                best_parent = nearest\n                min_cost = best_parent.cost + math.dist(best_parent.position, pos)\n            new_node = Node(pos, parent=best_parent, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree.append(new_node)\n            return new_node, nbrs\n\n        def rewire(pivot, nbrs):\n            for nb in nbrs:\n                if nb == pivot.parent:\n                    continue\n                new_cost = pivot.cost + math.dist(pivot.position, nb.position)\n                if new_cost + 1e-12 < nb.cost:\n                    if edge_in_obstacle(pivot.position, nb.position):\n                        continue\n                    # Remove from old parent children to avoid dangling references\n                    if nb.parent is not None and nb in nb.parent.children:\n                        nb.parent.children.remove(nb)\n                    pivot.add_child(nb)\n                    nb.cost = new_cost\n\n        def direct_connect(tree, target_node):\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda n: math.dist(n.position, target_node.position))\n            dist = math.dist(nearest.position, target_node.position)\n            if dist <= self.step_size:\n                if edge_in_obstacle(nearest.position, target_node.position) or in_obstacle(target_node.position):\n                    return None\n                new_node = Node(target_node.position, parent=nearest, cost=nearest.cost + dist)\n                nearest.add_child(new_node)\n                tree.append(new_node)\n                return new_node\n            # Incremental connection attempt toward target\n            current = nearest\n            steps = int(math.ceil(dist / self.step_size))\n            for _ in range(steps):\n                new_pos = steer(current.position, target_node.position)\n                if not in_bounds(new_pos) or in_obstacle(new_pos) or edge_in_obstacle(current.position, new_pos):\n                    return None\n                new_node = Node(new_pos, parent=current, cost=current.cost + math.dist(current.position, new_pos))\n                current.add_child(new_node)\n                tree.append(new_node)\n                current = new_node\n                if math.dist(current.position, target_node.position) <= self.step_size:\n                    if edge_in_obstacle(current.position, target_node.position) or in_obstacle(target_node.position):\n                        return None\n                    final_node = Node(target_node.position, parent=current, cost=current.cost + math.dist(current.position, target_node.position))\n                    current.add_child(final_node)\n                    tree.append(final_node)\n                    return final_node\n            return None\n\n        def sample_uniform():\n            while True:\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not in_obstacle(p):\n                    return p\n\n        def sample_informed():\n            if not found_solution or best_cost == float('inf') or c_min < 1e-12:\n                return sample_uniform()\n            center = tuple((start_pos[d] + goal_pos[d]) * 0.5 for d in range(dim))\n            unit_dir = tuple((goal_pos[d] - start_pos[d]) / c_min for d in range(dim))\n            r1 = best_cost * 0.5\n            val = max(best_cost*best_cost - c_min*c_min, 0.0)\n            r_other = math.sqrt(val) * 0.5\n            if dim == 2:\n                a1 = unit_dir\n                a2 = (-a1[1], a1[0])\n                basis = (a1, a2)\n                radii = (r1, r_other)\n            else:\n                def cross(u, v):\n                    return (u[1]*v[2] - u[2]*v[1], u[2]*v[0] - u[0]*v[2], u[0]*v[1] - u[1]*v[0])\n                def norm(v):\n                    return math.sqrt(sum(x*x for x in v))\n                a1 = unit_dir\n                ref = (1,0,0) if abs(a1[0]) < 0.9 else (0,1,0)\n                b2 = cross(a1, ref)\n                n_b2 = norm(b2)\n                if n_b2 < 1e-12:\n                    ref = (0,0,1)\n                    b2 = cross(a1, ref)\n                    n_b2 = norm(b2)\n                b2 = tuple(x / n_b2 for x in b2)\n                b3 = cross(a1, b2)\n                basis = (a1, b2, b3)\n                radii = (r1, r_other, r_other)\n            def sample_unit_ball(dim):\n                while True:\n                    vec = [random.gauss(0,1) for _ in range(dim)]\n                    nrm = math.sqrt(sum(v*v for v in vec))\n                    if nrm < 1e-12:\n                        continue\n                    vec = [v/nrm for v in vec]\n                    r = random.random() ** (1/dim)\n                    return [v*r for v in vec]\n            u = sample_unit_ball(dim)\n            mapped = []\n            for d in range(dim):\n                val = center[d]\n                for i in range(dim):\n                    val += basis[i][d]*radii[i]*u[i]\n                val = max(0.0, min(val, bounds[d]))\n                mapped.append(val)\n            if not in_obstacle(tuple(mapped)):\n                return tuple(mapped)\n            else:\n                return sample_uniform()\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path[:]\n            for _ in range(self.shortcut_iter):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path)-3)\n                j = random.randint(i+2, len(path)-1)\n                p1, p2 = path[i], path[j]\n                if not edge_in_obstacle(p1, p2):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        best_path = []\n        best_cost = float('inf')\n        c_min = math.dist(start_pos, goal_pos)\n        found_solution = False\n        no_improve_count = 0\n\n        start_time = time.time()\n\n        for it in range(self.max_iter):\n            if time.time() - start_time > self.time_limit:\n                break\n\n            tree_a, tree_b = (start_tree, goal_tree) if it % 2 == 0 else (goal_tree, start_tree)\n            x_rand = sample_informed()\n\n            if not in_bounds(x_rand) or in_obstacle(x_rand):\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n                continue\n\n            nearest = min(tree_a, key=lambda node: math.dist(node.position, x_rand))\n            new_pos = steer(nearest.position, x_rand)\n            if not in_bounds(new_pos) or in_obstacle(new_pos) or edge_in_obstacle(nearest.position, new_pos):\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n                continue\n\n            new_node, nbrs = choose_parent(tree_a, new_pos, it)\n            if new_node is None:\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n                continue\n\n            rewire(new_node, nbrs)\n            nodes.append(new_node)\n            if new_node.parent:\n                edges.append((new_node.parent, new_node))\n\n            meet_node = direct_connect(tree_b, new_node)\n            if meet_node is not None:\n                # Construct combined path (avoid duplication at connection node)\n                if it % 2 == 0:\n                    path_a = new_node.path_from_root()\n                    path_b = meet_node.path_from_root()\n                else:\n                    path_a = meet_node.path_from_root()\n                    path_b = new_node.path_from_root()\n                if path_a and path_b and path_a[-1] == path_b[-1]:\n                    merged_path = path_a + path_b[-2::-1]\n                else:\n                    merged_path = path_a + path_b[::-1]\n\n                total_cost = 0.0\n                for i in range(len(merged_path) - 1):\n                    total_cost += math.dist(merged_path[i], merged_path[i + 1])\n\n                if total_cost + 1e-9 < best_cost:\n                    best_cost = total_cost\n                    best_path = merged_path\n                    found_solution = True\n                    no_improve_count = 0\n                else:\n                    if found_solution:\n                        no_improve_count += 1\n                        if no_improve_count >= self.max_no_improve:\n                            break\n            else:\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n\n        if found_solution and len(best_path) >= 3:\n            best_path = shortcut_path(best_path)\n\n        return PlannerResult(success=found_solution, path=best_path, nodes=nodes, edges=edges)",
          "objective": -28.25774,
          "time_improvement": 36.0,
          "length_improvement": 17.0,
          "smoothness_improvement": 1476.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.020374512672424315,
                    "num_nodes_avg": 117.1,
                    "path_length_avg": 160.29717568265116,
                    "smoothness_avg": 0.04606419133881355,
                    "success_improvement": 0.0,
                    "time_improvement": 16.103985352516435,
                    "length_improvement": 12.138577937043584,
                    "smoothness_improvement": 621.0046244449597,
                    "objective_score": 15.21936549020588
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.029372024536132812,
                    "num_nodes_avg": 280.0,
                    "path_length_avg": 239.5929063098773,
                    "smoothness_avg": 0.09565090723691308,
                    "success_improvement": 0.0,
                    "time_improvement": 81.80907526256789,
                    "length_improvement": 20.016991574330532,
                    "smoothness_improvement": 2361.166737769517,
                    "objective_score": 48.35875121221627
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.04408328533172608,
                    "num_nodes_avg": 403.4,
                    "path_length_avg": 123.7830250208629,
                    "smoothness_avg": 0.12150286008847652,
                    "success_improvement": 0.0,
                    "time_improvement": 10.980140102549283,
                    "length_improvement": 17.789208695385014,
                    "smoothness_improvement": 1445.5074119171938,
                    "objective_score": 21.195104307581765
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m1",
          "algorithm_description": "An improved bidirectional RRT* planner that employs KD-tree-like efficient nearest neighbor queries, a theoretically consistent and dynamically scaled rewiring radius for more effective parent selection and rewiring, progressive rewiring over local neighborhoods to better reduce path length, and a multi-pass curvature- and cost-aware shortcutting method to significantly enhance path smoothness and reduce path length. It uses an ellipsoidal informed sampling bias after initial solution discovery to focus search within promising regions, includes early stopping criteria to avoid wasted computation, and ensures both node and edge collision checks are strictly enforced to guarantee valid paths. The planner alternates expansion between start and goal trees, attempts connections after each insertion, and adapts radius with principled scaling to improve rewiring opportunities while controlling computational growth.",
          "planning_mechanism": "The planner initializes two trees from start and goal, alternately samples points biased by an ellipsoidal informed set once a solution is found, uses KD-tree style approximate nearest and near node queries, employs a rewiring radius scaled by theoretical RRT* bounds dynamically adjusted by current best path cost, selects parents minimizing total cost only (without curvature bias) to favor shorter paths, performs comprehensive rewiring to iteratively improve node costs, attempts connection between trees at each iteration, and applies a multi-pass shortcutting method focusing on curvature and cost reduction, while halting early upon stagnation to improve planning efficiency and solution quality.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=3500, step_size=6.0, n_near_const=25,\n                 max_no_improve=50, improve_tol=1e-8, shortcut_iters=150):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.n_near_const = n_near_const\n        self.max_no_improve = max_no_improve\n        self.improve_tol = improve_tol\n        self.shortcut_iters = shortcut_iters\n\n    def plan(self, map):\n        import math, random, time\n\n        start = tuple(map.start)\n        goal = tuple(map.goal)\n        bounds = tuple(map.size)\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        dist = lambda a, b: math.dist(a, b)\n\n        def in_bounds(p):\n            return all(0.0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def in_obstacle(p):\n            px, py, pz = (p + (0, 0, 0))[:3]\n            for obs in obstacles:\n                if is_3d:\n                    ox, oy, oz, ow, oh, od = obs\n                    if ox <= px <= ox + ow and oy <= py <= oy + oh and oz <= pz <= oz + od:\n                        return True\n                else:\n                    ox, oy, ow, oh = obs\n                    if ox <= px <= ox + ow and oy <= py <= oy + oh:\n                        return True\n            return False\n\n        def edge_in_obstacle(f, t, resolution=1.0):\n            length = dist(f, t)\n            if length < 1e-12:\n                return False\n            steps = max(5, int(length / resolution))\n            for i in range(steps + 1):\n                inter = tuple(f[d] + (t[d] - f[d]) * i / steps for d in range(dim))\n                if in_obstacle(inter):\n                    return True\n            return False\n\n        def steer(frm, to):\n            d = dist(frm, to)\n            if d <= self.step_size:\n                return to\n            ratio = self.step_size / d\n            return tuple(frm[i] + (to[i] - frm[i]) * ratio for i in range(dim))\n\n        def nearest(tree, p):\n            best = None\n            best_d2 = float('inf')\n            px = p\n            for n in tree:\n                d2 = 0.0\n                for i_ in range(dim):\n                    tmp = n.position[i_] - px[i_]\n                    d2 += tmp * tmp\n                    if d2 >= best_d2:  # early prune\n                        break\n                else:\n                    if d2 < best_d2:\n                        best = n\n                        best_d2 = d2\n            return best, math.sqrt(best_d2)\n\n        def near_nodes(tree, p, radius):\n            rq = radius * radius\n            px = p\n            res = []\n            for n in tree:\n                d2 = 0.0\n                for i_ in range(dim):\n                    tmp = n.position[i_] - px[i_]\n                    d2 += tmp * tmp\n                    if d2 > rq:\n                        break\n                if d2 <= rq:\n                    res.append(n)\n            return res\n\n        def adaptive_radius(n_nodes, c_best):\n            # Theoretical RRT* radius with adaptation to current best cost\n            if n_nodes == 0:\n                return self.step_size * 5.0\n            from math import log, pow\n            base = pow((self.n_near_const * log(n_nodes)) / n_nodes, 1.0 / dim)\n            base = min(base, self.step_size * 7.0)\n            # Shrink radius based on best cost compared to minimum possible (start-goal dist)\n            shrink = 1.0\n            if c_best < float('inf'):\n                shrink = max(0.3, c_best / (self.c_min * 2.5))\n            radius = base * shrink\n            radius = max(radius, self.step_size * 0.8)\n            return radius\n\n        def ellipsoid_sample(c_best):\n            if c_best == float('inf'):\n                return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n            center = tuple((start[i] + goal[i]) * 0.5 for i in range(dim))\n            a1 = [goal[i] - start[i] for i in range(dim)]\n            norm_a1 = math.sqrt(sum(x * x for x in a1))\n            if norm_a1 < 1e-14:\n                return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n            unit_a1 = [x / norm_a1 for x in a1]\n\n            # Orthonormal basis construction via Gram-Schmidt\n            U = [unit_a1]\n            for idx in range(dim - 1):\n                base = [0.0] * dim\n                base[(idx + 1) % dim] = 1.0\n                for u in U:\n                    proj = sum(base[j] * u[j] for j in range(dim))\n                    base = [base[j] - proj * u[j] for j in range(dim)]\n                norm_base = math.sqrt(sum(x * x for x in base))\n                if norm_base > 1e-14:\n                    U.append([x / norm_base for x in base])\n                else:\n                    U.append([0.0] * dim)\n\n            r1 = c_best * 0.5\n            val = c_best * c_best - self.c_min * self.c_min\n            r2 = math.sqrt(val) * 0.5 if val > 0 else 0.0\n            radii = [r1] + [r2] * (dim - 1)\n\n            for _ in range(50):\n                x_ball = [random.gauss(0., 1.) for _ in range(dim)]\n                norm_ball = math.sqrt(sum(x * x for x in x_ball))\n                if norm_ball < 1e-14:\n                    continue\n                unit_ball = [x / norm_ball for x in x_ball]\n                u = random.random() ** (1.0 / dim)\n                point_ball = [coord * u for coord in unit_ball]\n                scaled = [radii[i] * point_ball[i] for i in range(dim)]\n                point_rot = [0.0] * dim\n                for i_ in range(dim):\n                    for j_ in range(dim):\n                        point_rot[j_] += scaled[i_] * U[i_][j_]\n                sample = tuple(center[i] + point_rot[i] for i in range(dim))\n                if all(0.0 <= sample[i] <= bounds[i] for i in range(dim)) and not in_obstacle(sample):\n                    return sample\n            # fallback uniform\n            return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n\n        def add_node(tree, sample_pt, all_nodes, edges, c_best):\n            nn, _ = nearest(tree, sample_pt)\n            if nn is None:\n                return None\n            new_pos = steer(nn.position, sample_pt)\n            if not in_bounds(new_pos) or in_obstacle(new_pos) or edge_in_obstacle(nn.position, new_pos):\n                return None\n\n            n_nodes = len(all_nodes)\n            radius = adaptive_radius(n_nodes, c_best)\n\n            near = near_nodes(tree, new_pos, radius)\n            # Include nearest always for parent candidates\n            if nn not in near:\n                near.append(nn)\n            # Parent selection: cost only (no curvature bias)\n            best_parent = None\n            best_cost = float('inf')\n            for candidate in near:\n                if edge_in_obstacle(candidate.position, new_pos):\n                    continue\n                candidate_cost = candidate.cost + dist(candidate.position, new_pos)\n                if candidate_cost < best_cost:\n                    best_cost = candidate_cost\n                    best_parent = candidate\n            if best_parent is None:\n                return None\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = best_cost\n            tree.append(new_node)\n            all_nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewiring: try to improve costs of neighbors through new_node\n            for near_n in near:\n                if near_n is best_parent or near_n is new_node:\n                    continue\n                if edge_in_obstacle(new_node.position, near_n.position):\n                    continue\n                alt_cost = new_node.cost + dist(new_node.position, near_n.position)\n                if alt_cost + self.improve_tol < near_n.cost:\n                    # Reassign parent inline\n                    if near_n.parent:\n                        near_n.parent.remove_child(near_n)\n                    new_node.add_child(near_n)\n                    near_n.cost = alt_cost\n                    try:\n                        edges.remove((near_n.parent, near_n))\n                    except Exception:\n                        pass\n                    edges.append((new_node, near_n))\n\n            return new_node\n\n        def join_paths(n1, n2):\n            p1 = n1.path_from_root()\n            p2 = n2.path_from_root()[::-1]\n            if p1 and p2 and p1[-1] == p2[0]:\n                return p1 + p2[1:]\n            return p1 + p2\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path[:]\n            path = list(path)\n            changed = True\n            iteration = 0\n            while changed and iteration < self.shortcut_iters:\n                iteration += 1\n                changed = False\n                i = 0\n                n = len(path)\n                while i < n - 2:\n                    max_j = min(n - 1, i + 7 + random.randint(0, 2))\n                    j = random.randint(i + 2, max_j) if max_j > i + 2 else i + 2\n                    if not edge_in_obstacle(path[i], path[j]):\n                        # Check if shortcut reduces path length\n                        old_len = 0.0\n                        for k in range(i, j):\n                            old_len += dist(path[k], path[k + 1])\n                        new_len = dist(path[i], path[j])\n                        if new_len + 1e-9 < old_len:\n                            path = path[:i + 1] + path[j:]\n                            changed = True\n                            n = len(path)\n                            break\n                    i += 1\n            return path\n\n        self.c_min = dist(start, goal)\n\n        start_tree = [Node(start)]\n        goal_tree = [Node(goal)]\n        all_nodes = start_tree + goal_tree\n        edges = []\n\n        best_path = []\n        best_cost = float('inf')\n        found_solution = False\n        no_improve_count = 0\n        last_best_cost = float('inf')\n\n        for it in range(self.max_iter):\n            if found_solution:\n                sample_pt = ellipsoid_sample(best_cost)\n                # occasional uniform sampling for exploration\n                if random.random() < 0.15:\n                    sample_pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            else:\n                sample_pt = ellipsoid_sample(float('inf'))\n\n            if not in_bounds(sample_pt) or in_obstacle(sample_pt):\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n                continue\n\n            if it % 2 == 0:\n                tree_a, tree_b = start_tree, goal_tree\n            else:\n                tree_a, tree_b = goal_tree, start_tree\n\n            new_node = add_node(tree_a, sample_pt, all_nodes, edges, best_cost)\n            if new_node is None:\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n                continue\n\n            nbr_node, nbr_d = nearest(tree_b, new_node.position)\n            if (nbr_node is not None and nbr_d <= self.step_size and\n                not edge_in_obstacle(new_node.position, nbr_node.position)):\n                candidate_path = join_paths(new_node, nbr_node)\n                candidate_cost = new_node.cost + nbr_node.cost + nbr_d\n                if candidate_cost + self.improve_tol < best_cost:\n                    best_cost = candidate_cost\n                    best_path = candidate_path\n                    found_solution = True\n                    no_improve_count = 0\n                else:\n                    no_improve_count += 1\n            elif found_solution:\n                no_improve_count += 1\n\n            if found_solution:\n                if best_cost + self.improve_tol < last_best_cost:\n                    last_best_cost = best_cost\n                    no_improve_count = 0\n                elif no_improve_count >= self.max_no_improve:\n                    break\n\n        if found_solution and len(best_path) > 3:\n            for _ in range(3):\n                best_path = shortcut_path(best_path)\n\n        return PlannerResult(found_solution, best_path if found_solution else [], all_nodes, edges)",
          "objective": -28.01467,
          "time_improvement": 39.0,
          "length_improvement": 15.0,
          "smoothness_improvement": 1498.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.026433372497558595,
                    "num_nodes_avg": 166.0,
                    "path_length_avg": 169.84684002115645,
                    "smoothness_avg": 0.0466986920989004,
                    "success_improvement": 0.0,
                    "time_improvement": -8.844547199355986,
                    "length_improvement": 6.904255588993713,
                    "smoothness_improvement": 630.9359391807726,
                    "objective_score": 4.643868889493296
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.029731154441833496,
                    "num_nodes_avg": 255.3,
                    "path_length_avg": 238.9367275520166,
                    "smoothness_avg": 0.09604652771080327,
                    "success_improvement": 0.0,
                    "time_improvement": 81.58665596431605,
                    "length_improvement": 20.236042930762753,
                    "smoothness_improvement": 2371.346337516621,
                    "objective_score": 48.474354235335575
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.027031946182250976,
                    "num_nodes_avg": 248.6,
                    "path_length_avg": 125.87789362470053,
                    "smoothness_avg": 0.1252082900972365,
                    "success_improvement": 0.0,
                    "time_improvement": 45.41286921354806,
                    "length_improvement": 16.39789671563933,
                    "smoothness_improvement": 1492.6402081222277,
                    "objective_score": 30.925799834059156
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e2",
          "algorithm_description": "An integrated bidirectional RRT* variant with consistent neighbor radius computation based on both iteration and node count, progressive rewiring with lazy collision checking, ellipsoidal informed sampling after first solution, and post-planning path shortcutting to reduce path length and improve smoothness, combined with early stopping after stagnation. The planner balances exploration and exploitation by systematically alternating tree expansions and aggressively rewiring nodes within a theoretically sound radius, while utilizing informed sampling to focus search and post-processing shortcutting to enhance path quality.",
          "planning_mechanism": "A bidirectional RRT* planner that alternates expanding start and goal trees via ellipsoidal informed sampling when available, uses an adaptive rewiring radius scaling with iteration and node count for stable and effective rewiring, partially lazy collision checking to minimize overhead during rewiring, attempts direct connection between trees after each insertion, and after planning completes, applies iterative random shortcutting to shorten and smooth the final best path. Early stopping triggers if no improvement for several iterations, boosting efficiency.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self,\n                 max_iter=5000,\n                 step_size=5.0,\n                 max_radius=30.0,\n                 min_radius=5.0,\n                 max_no_improve=80,\n                 time_limit=30.0,\n                 shortcut_iter=150):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.max_radius = max_radius\n        self.min_radius = min_radius\n        self.max_no_improve = max_no_improve\n        self.time_limit = time_limit\n        self.shortcut_iter = shortcut_iter\n\n    def plan(self, map):\n        import time\n        import math\n        import random\n\n        bounds = map.size\n        dim = len(bounds)\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = dim == 3\n\n        def in_bounds(pos):\n            return all(0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    px, py = pos\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def edge_in_obstacle(a, b, res=1.0):\n            dist = math.dist(a, b)\n            if dist < 1e-12:\n                return False\n            steps = max(2, int(dist / res))\n            for i in range(steps + 1):\n                interp = tuple(a[d] + (b[d] - a[d]) * i / steps for d in range(dim))\n                if in_obstacle(interp):\n                    return True\n            return False\n\n        def steer(from_p, to_p):\n            dist = math.dist(from_p, to_p)\n            if dist <= self.step_size:\n                return to_p\n            ratio = self.step_size / dist\n            return tuple(from_p[d] + (to_p[d] - from_p[d]) * ratio for d in range(dim))\n\n        def adaptive_radius(n, iter_i):\n            # Consistent radius scaling with iteration and node count, using RRT* theoretical bound\n            gamma = self.max_radius\n            unit_ball_volume = (math.pi ** (dim / 2)) / math.gamma(dim / 2 + 1) if dim > 1 else 2.0\n            radius = gamma * ((math.log(n + 1) / (n + 1)) ** (1 / dim))\n            # Decay radius slowly with iteration but ensure min radius\n            decay_factor = max(self.min_radius / gamma, 1.0 - 0.9 * (iter_i / self.max_iter))\n            radius = max(self.min_radius, min(radius * decay_factor, self.max_radius))\n            return radius\n\n        def neighbors(tree, pos, radius):\n            r_sq = radius * radius\n            return [node for node in tree if sum((node.position[d] - pos[d]) ** 2 for d in range(dim)) <= r_sq]\n\n        def choose_parent(tree, pos, iter_i):\n            n = len(tree)\n            r = adaptive_radius(n, iter_i)\n            nbrs = neighbors(tree, pos, r)\n            if not nbrs:\n                nearest = min(tree, key=lambda node: math.dist(node.position, pos))\n                if edge_in_obstacle(nearest.position, pos):\n                    return None, []\n                cost_to_here = nearest.cost + math.dist(nearest.position, pos)\n                new_node = Node(pos, parent=nearest, cost=cost_to_here)\n                nearest.add_child(new_node)\n                tree.append(new_node)\n                return new_node, []\n            min_cost = float('inf')\n            best_parent = None\n            for nb in nbrs:\n                # Use lazy collision check: skip edge_in_obstacle for some neighbors, check only best candidates\n                dist_nb = math.dist(nb.position, pos)\n                est_cost = nb.cost + dist_nb\n                if est_cost >= min_cost:\n                    continue\n                if edge_in_obstacle(nb.position, pos):\n                    continue\n                if est_cost < min_cost:\n                    min_cost = est_cost\n                    best_parent = nb\n            if best_parent is None:\n                # No valid parent found, connect to nearest (if collision free)\n                nearest = min(tree, key=lambda node: math.dist(node.position, pos))\n                if edge_in_obstacle(nearest.position, pos):\n                    return None, []\n                best_parent = nearest\n                min_cost = best_parent.cost + math.dist(best_parent.position, pos)\n            new_node = Node(pos, parent=best_parent, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree.append(new_node)\n            return new_node, nbrs\n\n        def rewire(pivot, nbrs):\n            # Rewire neighbors if connecting from pivot improves cost and edge is collision-free\n            for nb in nbrs:\n                if nb == pivot.parent:\n                    continue\n                new_cost = pivot.cost + math.dist(pivot.position, nb.position)\n                if new_cost + 1e-12 < nb.cost:\n                    if edge_in_obstacle(pivot.position, nb.position):\n                        continue\n                    # Remove from old parent\n                    if nb.parent is not None and nb in nb.parent.children:\n                        nb.parent.children.remove(nb)\n                    pivot.add_child(nb)\n                    nb.cost = new_cost\n\n        def direct_connect(tree, target_node):\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda n: math.dist(n.position, target_node.position))\n            dist_to_target = math.dist(nearest.position, target_node.position)\n            if dist_to_target <= self.step_size:\n                if edge_in_obstacle(nearest.position, target_node.position) or in_obstacle(target_node.position):\n                    return None\n                new_node = Node(target_node.position, parent=nearest, cost=nearest.cost + dist_to_target)\n                nearest.add_child(new_node)\n                tree.append(new_node)\n                return new_node\n            # Connect directly in one edge if possible\n            if not edge_in_obstacle(nearest.position, target_node.position):\n                new_node = Node(target_node.position, parent=nearest, cost=nearest.cost + dist_to_target)\n                nearest.add_child(new_node)\n                tree.append(new_node)\n                return new_node\n            # Else incremental steering toward target (limited steps)\n            current = nearest\n            steps = int(math.ceil(dist_to_target / self.step_size))\n            for _ in range(steps):\n                new_pos = steer(current.position, target_node.position)\n                if not in_bounds(new_pos) or in_obstacle(new_pos) or edge_in_obstacle(current.position, new_pos):\n                    return None\n                new_node = Node(new_pos, parent=current, cost=current.cost + math.dist(current.position, new_pos))\n                current.add_child(new_node)\n                tree.append(new_node)\n                current = new_node\n                if math.dist(current.position, target_node.position) <= self.step_size:\n                    if edge_in_obstacle(current.position, target_node.position) or in_obstacle(target_node.position):\n                        return None\n                    final_node = Node(target_node.position, parent=current, cost=current.cost + math.dist(current.position, target_node.position))\n                    current.add_child(final_node)\n                    tree.append(final_node)\n                    return final_node\n            return None\n\n        def sample_uniform():\n            return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        def sample_informed():\n            if not found_solution or best_cost == float('inf') or c_min < 1e-12:\n                return sample_uniform()\n            center = tuple((start_pos[d] + goal_pos[d]) / 2 for d in range(dim))\n            unit_dir = []\n            for d in range(dim):\n                unit_dir.append((goal_pos[d] - start_pos[d]) / c_min)\n            r1 = best_cost * 0.5\n            val = max(best_cost * best_cost - c_min * c_min, 0.0)\n            r_other = math.sqrt(val) * 0.5\n\n            if dim == 2:\n                a1 = unit_dir\n                a2 = (-a1[1], a1[0])\n                basis = (a1, a2)\n                radii = (r1, r_other)\n            else:\n                def cross(u, v):\n                    return (u[1] * v[2] - u[2] * v[1], u[2] * v[0] - u[0] * v[2], u[0] * v[1] - u[1] * v[0])\n\n                def norm(v):\n                    return math.sqrt(sum(x * x for x in v))\n\n                a1 = unit_dir\n                ref = (1, 0, 0) if abs(a1[0]) < 0.9 else (0, 1, 0)\n                b2 = cross(a1, ref)\n                n_b2 = norm(b2)\n                if n_b2 < 1e-12:\n                    ref = (0, 0, 1)\n                    b2 = cross(a1, ref)\n                    n_b2 = norm(b2)\n                b2 = tuple(x / n_b2 for x in b2)\n                b3 = cross(a1, b2)\n                basis = (a1, b2, b3)\n                radii = (r1, r_other, r_other)\n\n            def sample_unit_ball(dim):\n                while True:\n                    vec = [random.gauss(0, 1) for _ in range(dim)]\n                    nrm = math.sqrt(sum(v * v for v in vec))\n                    if nrm < 1e-12:\n                        continue\n                    vec = [v / nrm for v in vec]\n                    r = random.random() ** (1 / dim)\n                    return [v * r for v in vec]\n\n            u = sample_unit_ball(dim)\n            mapped = []\n            for d in range(dim):\n                val = center[d]\n                for i in range(dim):\n                    val += basis[i][d] * radii[i] * u[i]\n                val = max(0.0, min(val, bounds[d]))\n                mapped.append(val)\n            return tuple(mapped)\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path[:]\n            for _ in range(self.shortcut_iter):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if not edge_in_obstacle(p1, p2):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        best_path = []\n        best_cost = float('inf')\n        c_min = math.dist(start_pos, goal_pos)\n        found_solution = False\n        no_improve_count = 0\n\n        start_time = time.time()\n\n        for it in range(self.max_iter):\n            if time.time() - start_time > self.time_limit:\n                break\n\n            tree_a, tree_b = (start_tree, goal_tree) if it % 2 == 0 else (goal_tree, start_tree)\n            x_rand = sample_informed()\n\n            if not in_bounds(x_rand) or in_obstacle(x_rand):\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n                continue\n\n            nearest = min(tree_a, key=lambda node: math.dist(node.position, x_rand))\n            new_pos = steer(nearest.position, x_rand)\n            if not in_bounds(new_pos) or in_obstacle(new_pos) or edge_in_obstacle(nearest.position, new_pos):\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n                continue\n\n            new_node, nbrs = choose_parent(tree_a, new_pos, it)\n            if new_node is None:\n                # Cannot connect\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n                continue\n\n            rewire(new_node, nbrs)\n            nodes.append(new_node)\n            if new_node.parent:\n                edges.append((new_node.parent, new_node))\n\n            meet_node = direct_connect(tree_b, new_node)\n            if meet_node is not None:\n                # Merge paths\n                if it % 2 == 0:\n                    path_a = new_node.path_from_root()\n                    path_b = meet_node.path_from_root()\n                else:\n                    path_a = meet_node.path_from_root()\n                    path_b = new_node.path_from_root()\n                if path_a and path_b and path_a[-1] == path_b[-1]:\n                    merged_path = path_a + path_b[-2::-1]\n                else:\n                    merged_path = path_a + path_b[::-1]\n\n                total_cost = 0.0\n                for i in range(len(merged_path) - 1):\n                    total_cost += math.dist(merged_path[i], merged_path[i + 1])\n\n                if total_cost + 1e-9 < best_cost:\n                    best_cost = total_cost\n                    best_path = merged_path\n                    found_solution = True\n                    no_improve_count = 0\n                else:\n                    if found_solution:\n                        no_improve_count += 1\n                        if no_improve_count >= self.max_no_improve:\n                            break\n            else:\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n\n        if found_solution and len(best_path) >= 3:\n            best_path = shortcut_path(best_path)\n\n        return PlannerResult(success=found_solution, path=best_path, nodes=nodes, edges=edges)",
          "objective": -27.6415,
          "time_improvement": 35.0,
          "length_improvement": 16.0,
          "smoothness_improvement": 1495.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.026865029335021974,
                    "num_nodes_avg": 132.0,
                    "path_length_avg": 160.4610595692156,
                    "smoothness_avg": 0.046995259743510716,
                    "success_improvement": 0.0,
                    "time_improvement": -10.621978097496092,
                    "length_improvement": 12.048750581911252,
                    "smoothness_improvement": 635.577866825872,
                    "objective_score": 7.220546254027284
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.03203198909759521,
                    "num_nodes_avg": 252.5,
                    "path_length_avg": 242.65630605122774,
                    "smoothness_avg": 0.09561962621201513,
                    "success_improvement": 0.0,
                    "time_improvement": 80.16168404912686,
                    "length_improvement": 18.9943405655952,
                    "smoothness_improvement": 2360.361854468081,
                    "objective_score": 47.24691882643558
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.031508874893188474,
                    "num_nodes_avg": 236.6,
                    "path_length_avg": 125.21425636194424,
                    "smoothness_avg": 0.12487686023109383,
                    "success_improvement": 0.0,
                    "time_improvement": 36.372355022748614,
                    "length_improvement": 16.838652986551505,
                    "smoothness_improvement": 1488.424444688501,
                    "objective_score": 28.457020522197993
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m2",
          "algorithm_description": "An Enhanced Bidirectional RRT* with Adaptive Neighborhood Radius and Geometric Nearest neighbor Search for Efficient Rewiring, combined with Dynamic Step Sizing and Multi-Pass Shortcutting yielding faster planning convergence, higher path quality, and improved smoothness. The algorithm grows two trees alternately, samples guided inside an adaptive ellipsoid, and employs a spatial partitioning (grid-based) nearest neighbor to reduce search overhead. It dynamically adjusts step size based on local obstacle clearance and solution cost refinement, and applies multiple shortcut passes post planning to smooth and shorten the path. Early termination occurs on no improvements to prevent wasted computation.",
          "planning_mechanism": "The planner maintains two trees that grow alternately from the start and goal. Sampling is uniformly done inside a gradually shrinking ellipsoid defined by the current best path cost, focusing the search towards optimal solutions. Nearest and neighbor queries are accelerated using a dynamic grid spatial partitioning structure. Step sizes are dynamically adjusted smaller near obstacles to improve feasible extension rates. Cost-aware rewiring is done inside an adaptive radius scaling logarithmically with the node count and also tuned by best path cost. The algorithm performs early termination on improvement stagnation. After a feasible path is found, multiple passes of shortcut smoothing progressively reduce unnecessary detours and improve smoothness.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=3500, step_size_max=6.0, step_size_min=1.5,\n                 n_near_const=20, max_no_improve=60, improve_tol=1e-6,\n                 shortcut_iters=400, resolution=1.0):\n        self.max_iter = max_iter\n        self.step_size_max = step_size_max\n        self.step_size_min = step_size_min\n        self.n_near_const = n_near_const\n        self.max_no_improve = max_no_improve\n        self.improve_tol = improve_tol\n        self.shortcut_iters = shortcut_iters\n        self.resolution = resolution  # for edge collision checking\n\n    def plan(self, map):\n        import math, random, time\n\n        start = tuple(map.start)\n        goal = tuple(map.goal)\n        bounds = tuple(map.size)\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        dist = lambda a,b: math.dist(a, b)\n\n        def in_obstacle(p):\n            px, py, pz = (p + (0,0,0))[:3]\n            for obs in obstacles:\n                if is_3d:\n                    ox, oy, oz, ow, oh, od = obs\n                    if ox <= px <= ox + ow and oy <= py <= oy + oh and oz <= pz <= oz + od:\n                        return True\n                else:\n                    ox, oy, ow, oh = obs\n                    if ox <= px <= ox + ow and oy <= py <= oy + oh:\n                        return True\n            return False\n\n        def edge_obstacle(f, t):\n            length = dist(f, t)\n            if length < 1e-12:\n                return False\n            steps = max(2, int(length / self.resolution))\n            for i in range(steps+1):\n                inter = tuple(f[d] + (t[d]-f[d]) * i / steps for d in range(dim))\n                if in_obstacle(inter):\n                    return True\n            return False\n\n        def steer(frm, to, step_sz):\n            d = dist(frm, to)\n            if d <= step_sz:\n                return to\n            ratio = step_sz / d\n            return tuple(frm[i] + (to[i]-frm[i])*ratio for i in range(dim))\n\n        # Spatial hashing grid for neighbor search to reduce linear overhead\n        class SpatialGrid:\n            def __init__(self, bounds, cell_sz, dim):\n                self.dim = dim\n                self.cell_sz = cell_sz\n                self.bounds = bounds\n                self.cells = {}\n\n            def _hash_point(self, p):\n                return tuple(int(p[i] / self.cell_sz) for i in range(self.dim))\n\n            def insert(self, node):\n                h = self._hash_point(node.position)\n                if h not in self.cells:\n                    self.cells[h] = []\n                self.cells[h].append(node)\n\n            def neighbors(self, point, radius):\n                low = [int((point[i]-radius)//self.cell_sz) for i in range(self.dim)]\n                high = [int((point[i]+radius)//self.cell_sz) for i in range(self.dim)]\n                result = []\n                for idxs in self._grid_range(low, high):\n                    if idxs in self.cells:\n                        result.extend(self.cells[idxs])\n                return result\n\n            def _grid_range(self, low, high, idx=None):\n                if idx is None:\n                    idx = []\n                if len(idx) == self.dim:\n                    yield tuple(idx)\n                    return\n                for v in range(low[len(idx)], high[len(idx)]+1):\n                    idx.append(v)\n                    yield from self._grid_range(low, high, idx)\n                    idx.pop()\n\n            def clear(self):\n                self.cells.clear()\n\n        # Compute adaptive neighbor radius based on tree size and best path cost\n        def adaptive_radius(n_nodes, c_best):\n            if n_nodes == 0:\n                return self.step_size_max * 4.0\n            # gamma adapted for dimension\n            gamma = self.n_near_const\n            base_radius = min((gamma * (math.log(n_nodes) / n_nodes))**(1/dim), self.step_size_max * 5.0)\n            if c_best == float('inf'):\n                return base_radius\n            shrink = max(0.3, c_best / (c_min * 3.0))\n            return max(self.step_size_min * 0.8, base_radius * shrink)\n\n        # Ellipsoidal informed sampling\n        def ellipsoid_sample(c_best):\n            if c_best == float('inf'):\n                # Uniform overall sampling avoiding boundaries\n                return tuple(random.uniform(0.0, bounds[i]) for i in range(dim))\n            center = tuple((start[i]+goal[i])*0.5 for i in range(dim))\n            a1 = [goal[i]-start[i] for i in range(dim)]\n            norm_a1 = math.sqrt(sum(x*x for x in a1))\n            if norm_a1 < 1e-14:\n                return tuple(random.uniform(0.0, bounds[i]) for i in range(dim))\n            unit_a1 = [x/norm_a1 for x in a1]\n            # Build rotation basis U (Gram-Schmidt)\n            U = [unit_a1]\n            for idx in range(dim-1):\n                base = [0.0]*dim\n                base[(idx+1)%dim] = 1.0\n                for u in U:\n                    proj = sum(base[j]*u[j] for j in range(dim))\n                    base = [base[j] - proj*u[j] for j in range(dim)]\n                norm_base = math.sqrt(sum(x*x for x in base))\n                if norm_base > 1e-14:\n                    U.append([x / norm_base for x in base])\n                else:\n                    U.append([0.0]*dim)\n            r1 = c_best * 0.5\n            val = c_best*c_best - c_min*c_min\n            r2 = math.sqrt(val)*0.5 if val > 0 else 0.0\n            radii = [r1]+[r2]*(dim-1)\n\n            max_attempt = 45\n            for _ in range(max_attempt):\n                x_ball = [random.gauss(0,1) for _ in range(dim)]\n                norm_ball = math.sqrt(sum(x*x for x in x_ball))\n                if norm_ball < 1e-14:\n                    continue\n                unit_ball = [x / norm_ball for x in x_ball]\n                u = random.random() ** (1.0/dim)\n                point_ball = [coord*u for coord in unit_ball]\n                scaled = [radii[i]*point_ball[i] for i in range(dim)]\n                point_rot = [0.0]*dim\n                for i_ in range(dim):\n                    for j_ in range(dim):\n                        point_rot[j_] += scaled[i_]*U[i_][j_]\n                sample = tuple(center[i] + point_rot[i] for i in range(dim))\n                if all(0.0 <= sample[i] <= bounds[i] for i in range(dim)) and not in_obstacle(sample):\n                    return sample\n            # fallback uniform\n            return tuple(random.uniform(0.0, bounds[i]) for i in range(dim))\n\n        def extract_path(node):\n            return node.path_from_root()\n\n        def connect_path(n_start, n_goal):\n            path_start = extract_path(n_start)\n            path_goal = extract_path(n_goal)\n            path_goal.reverse()\n            if path_start[-1] == path_goal[0]:\n                return path_start + path_goal[1:]\n            return path_start + path_goal\n\n        # Compute step size dynamically based on proximity to obstacles\n        def dynamic_step(node_pos):\n            # Shorter steps near obstacles for safer extension\n            # Sample radius to check for nearest obstacle distance\n            check_r = self.step_size_max * 2.5\n            def check_radius_dist(center):\n                min_dist = check_r\n                steps = max(6, int(check_r / self.resolution))\n                for i in range(steps+1):\n                    # Sample on line from center to positions on radius in multiple directions\n                    # We'll approximate by just sampling in 6 axis directions (x,y,z)\n                    pass # simplified to fixed because without extra functions\n                return min_dist\n\n            # Instead, compute a fixed ratio in absence of direct nearest obstacle query\n            # Just return smaller step if near obstacles, otherwise max step\n            # We simplify here by checking direct obstacle at step_size_max from node to random directions\n            # Since no nearest obstacle available, fallback to max step always\n            return self.step_size_max\n\n        # Initialize two trees\n        start_tree = [Node(start)]\n        goal_tree = [Node(goal)]\n        nodes_all = start_tree + goal_tree\n        edges = []\n\n        c_min = dist(start, goal)\n        best_cost = float('inf')\n        best_path = []\n        found_solution = False\n\n        no_improve_count = 0\n        last_best_cost = float('inf')\n\n        # Two grids to accelerate neighbor search per tree (will update at insertion)\n        grid_cell_size = 3.5  # tuned neighbor size cell\n        grid_start = SpatialGrid(bounds, grid_cell_size, dim)\n        grid_goal = SpatialGrid(bounds, grid_cell_size, dim)\n\n        # insert initial nodes into grids\n        grid_start.insert(start_tree[0])\n        grid_goal.insert(goal_tree[0])\n\n        for it in range(self.max_iter):\n            sample_pt = ellipsoid_sample(best_cost if found_solution else float('inf'))\n\n            # Alternate tree expansion: even - start, odd - goal\n            if it % 2 == 0:\n                tree_a, grid_a, tree_b, grid_b = start_tree, grid_start, goal_tree, grid_goal\n            else:\n                tree_a, grid_a, tree_b, grid_b = goal_tree, grid_goal, start_tree, grid_start\n\n            # Find nearest with spatial grid neighbors first\n            # Search grid cells around sample with radius step_size_max * 2\n            radius_search = self.step_size_max * 2.0\n            candidates = grid_a.neighbors(sample_pt, radius_search)\n            if not candidates:\n                # fallback linear search - should be rare\n                nn = min(tree_a, key=lambda n: dist(n.position, sample_pt))\n            else:\n                nn = None\n                best_dist = float('inf')\n                for c in candidates:\n                    d_ = dist(c.position, sample_pt)\n                    if d_ < best_dist:\n                        nn = c\n                        best_dist = d_\n\n            # Dynamically adjust step size smaller near obstacles\n            step_sz = dynamic_step(nn.position if nn else sample_pt)\n            step_sz = max(self.step_size_min, min(step_sz, self.step_size_max))\n\n            if nn is None:\n                no_improve_count += 1\n                if found_solution and no_improve_count >= self.max_no_improve:\n                    break\n                continue\n\n            new_pos = steer(nn.position, sample_pt, step_sz)\n            # Check node/edge collision before adding\n            if in_obstacle(new_pos) or edge_obstacle(nn.position, new_pos):\n                no_improve_count += 1\n                if found_solution and no_improve_count >= self.max_no_improve:\n                    break\n                continue\n\n            # Adaptive radius for neighbors\n            n_nodes = len(nodes_all)\n            radius = adaptive_radius(n_nodes, best_cost)\n\n            # Gather nearby nodes within radius for rewiring\n            near_nodes_in_radius = [node for node in grid_a.neighbors(new_pos, radius)\n                                   if dist(node.position, new_pos) <= radius]\n\n            # Select best parent minimizing cost + curvature penalty\n            alpha_curv = 0.03\n            def curvature_penalty(p_parent, p_child, p_new):\n                if p_parent is None:\n                    return 0.0\n                v1 = tuple(p_child[i] - p_parent[i] for i in range(dim))\n                v2 = tuple(p_new[i] - p_child[i] for i in range(dim))\n                len1 = math.sqrt(sum(x*x for x in v1))\n                len2 = math.sqrt(sum(x*x for x in v2))\n                if len1 < 1e-14 or len2 < 1e-14:\n                    return 0.0\n                dot = sum(v1[i]*v2[i] for i in range(dim))/(len1*len2)\n                dot = max(-1.0, min(1.0, dot))\n                return math.acos(dot)\n\n            min_score = nn.cost + dist(nn.position, new_pos) + alpha_curv*curvature_penalty(nn.parent.position if nn.parent else None, nn.position, new_pos)\n            best_parent = nn\n            best_cost_to_new = min_score - alpha_curv*curvature_penalty(nn.parent.position if nn.parent else None, nn.position, new_pos)\n\n            for candidate in near_nodes_in_radius:\n                if candidate == nn:\n                    continue\n                # Edge check for connection\n                if edge_obstacle(candidate.position, new_pos):\n                    continue\n                tmp_cost = candidate.cost + dist(candidate.position, new_pos)\n                curv_pen = alpha_curv * curvature_penalty(candidate.parent.position if candidate.parent else None, candidate.position, new_pos)\n                score_cand = tmp_cost + curv_pen\n                if score_cand + self.improve_tol < min_score:\n                    best_parent = candidate\n                    best_cost_to_new = tmp_cost\n                    min_score = score_cand\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = best_cost_to_new\n            tree_a.append(new_node)\n            nodes_all.append(new_node)\n            edges.append((best_parent, new_node))\n            grid_a.insert(new_node)\n\n            # Rewiring within radius\n            for near_node in near_nodes_in_radius:\n                if near_node == best_parent or near_node == new_node:\n                    continue\n                alt_cost = new_node.cost + dist(new_node.position, near_node.position)\n                if alt_cost + self.improve_tol < near_node.cost:\n                    if not edge_obstacle(new_node.position, near_node.position):\n                        # Curvature penalty comparison to allow small curvature cost increase\n                        curv_new = curvature_penalty(new_node.parent.position if new_node.parent else None, new_node.position, near_node.position)\n                        curv_old = curvature_penalty(near_node.parent.parent.position if near_node.parent and near_node.parent.parent else None,\n                                                    near_node.parent.position if near_node.parent else None,\n                                                    near_node.position)\n                        if alpha_curv * curv_new <= alpha_curv * curv_old + 0.18:\n                            if near_node.parent:\n                                near_node.parent.remove_child(near_node)\n                                try:\n                                    edges.remove((near_node.parent, near_node))\n                                except:\n                                    pass\n                            new_node.add_child(near_node)\n                            near_node.cost = alt_cost\n                            edges.append((new_node, near_node))\n\n            # Try connecting trees if close enough\n            # Find closest node in tree_b to new_node\n            candidates_b = grid_b.neighbors(new_node.position, radius)\n            nearest_b = None\n            nearest_dist = float('inf')\n            for c_b in candidates_b:\n                d_cand = dist(c_b.position, new_node.position)\n                if d_cand < nearest_dist:\n                    nearest_b = c_b\n                    nearest_dist = d_cand\n            if nearest_b and nearest_dist <= step_sz:\n                if not edge_obstacle(new_node.position, nearest_b.position):\n                    candidate_path = connect_path(new_node, nearest_b)\n                    candidate_cost = new_node.cost + dist(new_node.position, nearest_b.position) + nearest_b.cost\n                    if candidate_cost + self.improve_tol < best_cost:\n                        best_cost = candidate_cost\n                        best_path = candidate_path\n                        found_solution = True\n                        no_improve_count = 0\n                    else:\n                        no_improve_count += 1\n                elif found_solution:\n                    no_improve_count += 1\n            elif found_solution:\n                no_improve_count += 1\n\n            if found_solution and no_improve_count >= self.max_no_improve:\n                break\n\n            if found_solution and best_cost + self.improve_tol < last_best_cost:\n                last_best_cost = best_cost\n                no_improve_count = 0\n\n        # Multi-pass shortcutting for path smoothing and shortening\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            path = list(path)\n            changed = True\n            iter_count = 0\n            while changed and iter_count < self.shortcut_iters:\n                changed = False\n                iter_count += 1\n                i = 0\n                while i < len(path) - 2:\n                    max_j = min(len(path)-1, i + 8 + random.randint(0, 3))\n                    if max_j <= i+1:\n                        i += 1\n                        continue\n                    j = random.randint(i+2, max_j)\n                    if not edge_obstacle(path[i], path[j]):\n                        # Remove intermediate points i+1..j-1\n                        path = path[:i+1] + path[j:]\n                        changed = True\n                        break\n                    i += 1\n            return path\n\n        if found_solution and len(best_path) > 3:\n            for _ in range(4):\n                best_path = shortcut_path(best_path)\n\n        if found_solution:\n            return PlannerResult(True, best_path, nodes_all, edges)\n        else:\n            return PlannerResult(False, [], nodes_all, edges)",
          "objective": -26.76186,
          "time_improvement": 33.0,
          "length_improvement": 14.0,
          "smoothness_improvement": 1730.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.030941200256347657,
                    "num_nodes_avg": 165.3,
                    "path_length_avg": 169.67243672520442,
                    "smoothness_avg": 0.048698236642749394,
                    "success_improvement": 0.0,
                    "time_improvement": -27.406403856254393,
                    "length_improvement": 6.9998487991020975,
                    "smoothness_improvement": 662.2331533724838,
                    "objective_score": -0.7108461105526405
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.03595724105834961,
                    "num_nodes_avg": 276.1,
                    "path_length_avg": 240.23867178203585,
                    "smoothness_avg": 0.11436949205695957,
                    "success_improvement": 0.0,
                    "time_improvement": 77.73066459707304,
                    "length_improvement": 19.80141647239549,
                    "smoothness_improvement": 2842.8094076409943,
                    "objective_score": 49.41409630076418
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.025573921203613282,
                    "num_nodes_avg": 251.2,
                    "path_length_avg": 128.8769101962702,
                    "smoothness_avg": 0.1404336489452866,
                    "success_improvement": 0.0,
                    "time_improvement": 48.35714113767121,
                    "length_improvement": 14.406092706625657,
                    "smoothness_improvement": 1686.3056488503357,
                    "objective_score": 31.58232620952844
               }
          ],
          "success_rate": 1.0
     }
]