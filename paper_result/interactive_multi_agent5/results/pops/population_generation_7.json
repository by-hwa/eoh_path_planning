[
     {
          "operator": "m3",
          "algorithm_description": "A simplified bidirectional RRT* planner using uniform and ellipsoidal informed sampling with efficient neighbor lookups, adaptive rewiring radius, incremental rewiring, and post-planning shortcut smoothing to improve path quality, smoothness, and planning speed while maintaining robustness. It alternates tree expansion from start and goal, performs parent selection to minimize cost with strict collision checks, tries direct and incremental tree connection after each insertion, and applies a random shortcutting heuristic for path smoothing.",
          "planning_mechanism": "The planner grows two trees from start and goal, sampling points biased towards an ellipsoidal informed subset once a solution is found, steering towards samples to add nodes, selecting parents among neighbors minimizing path cost, rewiring neighbors to improve connectivity and cost, connecting the two trees incrementally after each node addition, and applying shortcut smoothing post planning for improved path smoothness and length.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self,\n                 max_iter=4000,\n                 step_size=5.0,\n                 max_radius=20.0,\n                 min_radius=5.0,\n                 max_no_improve=60,\n                 shortcut_iter=100):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.max_radius = max_radius\n        self.min_radius = min_radius\n        self.max_no_improve = max_no_improve\n        self.shortcut_iter = shortcut_iter\n\n    def plan(self, map):\n        import math\n        import random\n        import time\n\n        bounds = map.size\n        dim = len(bounds)\n        start_pos = tuple(map.start)\n        goal_pos = tuple(map.goal)\n        obstacles = map.obstacles\n        is_3d = (dim == 3)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def in_obstacle(p):\n            px, py, pz = (p + (0, 0, 0))[:3]\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def edge_in_obstacle(a, b, res=1.0):\n            dist_ab = math.dist(a, b)\n            if dist_ab < 1e-12:\n                return False\n            steps = max(2, int(dist_ab / res))\n            for i in range(steps + 1):\n                interp = tuple(a[d] + (b[d] - a[d]) * i / steps for d in range(dim))\n                if in_obstacle(interp):\n                    return True\n            return False\n\n        def steer(frm, to):\n            dist_frm_to = math.dist(frm, to)\n            if dist_frm_to <= self.step_size:\n                return to\n            ratio = self.step_size / dist_frm_to\n            return tuple(frm[d] + (to[d] - frm[d]) * ratio for d in range(dim))\n\n        def adaptive_radius(n_nodes, iter_i):\n            if n_nodes <= 1:\n                return self.max_radius\n            gamma = self.max_radius\n            import math as m\n            r = gamma * (m.log(n_nodes) / n_nodes) ** (1 / dim)\n            decay = max(self.min_radius / gamma, 1.0 - 0.9 * (iter_i / self.max_iter))\n            return max(self.min_radius, min(r * decay, self.max_radius))\n\n        def neighbors(tree, point, radius):\n            r_sq = radius * radius\n            res = []\n            for node in tree:\n                d_sq = 0.0\n                for i in range(dim):\n                    diff = node.position[i] - point[i]\n                    d_sq += diff * diff\n                    if d_sq > r_sq:\n                        break\n                else:\n                    res.append(node)\n            return res\n\n        def choose_parent(tree, new_pos, iter_i):\n            n_nodes = len(tree)\n            r = adaptive_radius(n_nodes, iter_i)\n            nbrs = neighbors(tree, new_pos, r)\n            valid_parents = [n for n in nbrs if not edge_in_obstacle(n.position, new_pos)]\n            if not valid_parents:\n                nearest = None\n                nearest_dist = float('inf')\n                for n in tree:\n                    d = math.dist(n.position, new_pos)\n                    if d < nearest_dist and not edge_in_obstacle(n.position, new_pos):\n                        nearest = n\n                        nearest_dist = d\n                if nearest is None:\n                    return None, []\n                cost = nearest.cost + nearest_dist\n                new_node = Node(new_pos, parent=nearest, cost=cost)\n                nearest.add_child(new_node)\n                tree.append(new_node)\n                return new_node, []\n            best_parent = min(valid_parents, key=lambda p: p.cost + math.dist(p.position, new_pos))\n            min_cost = best_parent.cost + math.dist(best_parent.position, new_pos)\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree.append(new_node)\n            return new_node, valid_parents\n\n        def rewire(pivot, nbrs):\n            for nb in nbrs:\n                if nb is pivot.parent:\n                    continue\n                dist_pivot_nb = math.dist(pivot.position, nb.position)\n                new_cost = pivot.cost + dist_pivot_nb\n                if new_cost + 1e-12 < nb.cost and not edge_in_obstacle(pivot.position, nb.position):\n                    if nb.parent is not None:\n                        nb.parent.remove_child(nb)\n                    pivot.add_child(nb)\n                    nb.cost = new_cost\n\n        def attempt_connect(tree_from, node_to_connect):\n            if not tree_from:\n                return None\n            nearest = min(tree_from, key=lambda n: math.dist(n.position, node_to_connect.position))\n            dist_near = math.dist(nearest.position, node_to_connect.position)\n            if dist_near <= self.step_size:\n                if edge_in_obstacle(nearest.position, node_to_connect.position) or in_obstacle(node_to_connect.position):\n                    return None\n                new_node = Node(node_to_connect.position, parent=nearest, cost=nearest.cost + dist_near)\n                nearest.add_child(new_node)\n                tree_from.append(new_node)\n                return new_node\n            current = nearest\n            steps = int(math.ceil(dist_near / self.step_size))\n            for _ in range(steps):\n                new_pos = steer(current.position, node_to_connect.position)\n                if not in_bounds(new_pos) or in_obstacle(new_pos) or edge_in_obstacle(current.position, new_pos):\n                    return None\n                new_node = Node(new_pos, parent=current, cost=current.cost + math.dist(current.position, new_pos))\n                current.add_child(new_node)\n                tree_from.append(new_node)\n                current = new_node\n                if math.dist(current.position, node_to_connect.position) <= self.step_size:\n                    if edge_in_obstacle(current.position, node_to_connect.position) or in_obstacle(node_to_connect.position):\n                        return None\n                    final_node = Node(node_to_connect.position, parent=current,\n                                      cost=current.cost + math.dist(current.position, node_to_connect.position))\n                    current.add_child(final_node)\n                    tree_from.append(final_node)\n                    return final_node\n            return None\n\n        def sample_uniform():\n            return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        def sample_informed(c_best, c_min):\n            if c_best == float('inf') or c_min < 1e-12:\n                return sample_uniform()\n            center = tuple((start_pos[d] + goal_pos[d]) / 2 for d in range(dim))\n            unit_dir = []\n            for d in range(dim):\n                unit_dir.append((goal_pos[d] - start_pos[d]) / c_min)\n            r1 = c_best * 0.5\n            val = max(c_best * c_best - c_min * c_min, 0.0)\n            r_other = math.sqrt(val) * 0.5\n\n            if dim == 2:\n                a1 = unit_dir\n                a2 = (-a1[1], a1[0])\n                basis = (a1, a2)\n                radii = (r1, r_other)\n            else:\n                def cross(u, v):\n                    return (u[1] * v[2] - u[2] * v[1], u[2] * v[0] - u[0] * v[2], u[0] * v[1] - u[1] * v[0])\n                def norm(v):\n                    return math.sqrt(sum(x * x for x in v))\n                a1 = unit_dir\n                ref = (1, 0, 0) if abs(a1[0]) < 0.9 else (0, 1, 0)\n                b2 = cross(a1, ref)\n                n_b2 = norm(b2)\n                if n_b2 < 1e-12:\n                    ref = (0, 0, 1)\n                    b2 = cross(a1, ref)\n                    n_b2 = norm(b2)\n                b2 = tuple(x / n_b2 for x in b2)\n                b3 = cross(a1, b2)\n                basis = (a1, b2, b3)\n                radii = (r1, r_other, r_other)\n            def sample_unit_ball(dim):\n                while True:\n                    vec = [random.gauss(0, 1) for _ in range(dim)]\n                    nrm = math.sqrt(sum(v * v for v in vec))\n                    if nrm < 1e-12:\n                        continue\n                    vec = [v / nrm for v in vec]\n                    r = random.random() ** (1 / dim)\n                    return [v * r for v in vec]\n            u = sample_unit_ball(dim)\n            mapped = []\n            for d in range(dim):\n                val = center[d]\n                for i in range(dim):\n                    val += basis[i][d] * radii[i] * u[i]\n                mapped.append(max(0.0, min(val, bounds[d])))\n            return tuple(mapped)\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path[:]\n            path = list(path)\n            for _ in range(self.shortcut_iter):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if not edge_in_obstacle(path[i], path[j]):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        best_path = []\n        best_cost = float('inf')\n        c_min = math.dist(start_pos, goal_pos)\n        found_solution = False\n        no_improve_count = 0\n\n        start_time = time.time()\n\n        for iter_i in range(self.max_iter):\n            if found_solution:\n                sample = sample_informed(best_cost, c_min)\n                # occasional uniform sampling to avoid local minima\n                if random.random() < 0.15:\n                    sample = sample_uniform()\n            else:\n                sample = sample_uniform()\n\n            if not in_bounds(sample) or in_obstacle(sample):\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n                continue\n\n            tree_a, tree_b = (start_tree, goal_tree) if iter_i % 2 == 0 else (goal_tree, start_tree)\n\n            nearest_node = min(tree_a, key=lambda n: math.dist(n.position, sample))\n            new_pos = steer(nearest_node.position, sample)\n            if not in_bounds(new_pos) or in_obstacle(new_pos) or edge_in_obstacle(nearest_node.position, new_pos):\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n                continue\n\n            new_node, nbrs = choose_parent(tree_a, new_pos, iter_i)\n            if new_node is None:\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n                continue\n\n            rewire(new_node, nbrs)\n            nodes.append(new_node)\n            if new_node.parent:\n                edges.append((new_node.parent, new_node))\n\n            connect_node = attempt_connect(tree_b, new_node)\n            if connect_node is not None:\n                if iter_i % 2 == 0:\n                    path_a = new_node.path_from_root()\n                    path_b = connect_node.path_from_root()\n                else:\n                    path_a = connect_node.path_from_root()\n                    path_b = new_node.path_from_root()\n\n                if path_a and path_b and path_a[-1] == path_b[-1]:\n                    candidate_path = path_a + path_b[-2::-1]\n                else:\n                    candidate_path = path_a + path_b[::-1]\n\n                total_cost = 0.0\n                for i in range(len(candidate_path) - 1):\n                    total_cost += math.dist(candidate_path[i], candidate_path[i + 1])\n\n                if total_cost + 1e-9 < best_cost:\n                    best_cost = total_cost\n                    best_path = candidate_path\n                    found_solution = True\n                    no_improve_count = 0\n                else:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n            else:\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n\n        if found_solution and len(best_path) >= 3:\n            best_path = shortcut_path(best_path)\n\n        return PlannerResult(success=found_solution, path=best_path, nodes=nodes, edges=edges)",
          "objective": -33.40298,
          "time_improvement": 51.0,
          "length_improvement": 17.0,
          "smoothness_improvement": 1547.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.017258715629577637,
                    "num_nodes_avg": 79.5,
                    "path_length_avg": 159.14625161467853,
                    "smoothness_avg": 0.03811017652697283,
                    "success_improvement": 0.0,
                    "time_improvement": 28.9338850683042,
                    "length_improvement": 12.76941765625831,
                    "smoothness_improvement": 496.5070202200339,
                    "objective_score": 18.824351215346415
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.050636911392211915,
                    "num_nodes_avg": 257.4,
                    "path_length_avg": 238.0863832383473,
                    "smoothness_avg": 0.10822479582896447,
                    "success_improvement": 0.0,
                    "time_improvement": 68.63912996740864,
                    "length_improvement": 20.51991233846954,
                    "smoothness_improvement": 2684.7019478488814,
                    "objective_score": 46.32719613254872
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.022013473510742187,
                    "num_nodes_avg": 162.2,
                    "path_length_avg": 122.72467070826906,
                    "smoothness_avg": 0.12261112972748914,
                    "success_improvement": 0.0,
                    "time_improvement": 55.54695361209407,
                    "length_improvement": 18.492117236393174,
                    "smoothness_improvement": 1459.6045199214789,
                    "objective_score": 35.05737902507152
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "An improved bidirectional RRT* variant with simplified adaptive neighborhood radius, consistent incremental rewiring, and combined informed plus uniform sampling for balanced exploration. The planner applies strict collision checks on nodes and edges, optimizes parent selection to minimize path cost, and attempts connection between trees after each insertion. It leverages a unified rewiring radius calculation based on node density and iteration progress, integrates early stopping on improvement stagnation, and performs lightweight post-processing shortcutting to improve path quality and smoothness, achieving efficient planning, shorter path length, and smoother results while maintaining robustness and simplicity.",
          "planning_mechanism": "The planner grows two trees from start and goal positions in alternating iterations, sampling points biased towards an ellipsoidal informed subset once a solution is found to focus search. Nodes are added by steering towards samples within step size, selecting parents from neighbors that reduce path cost and maintain collision-free edges. Rewiring is done on neighbors with a unified adaptive radius that shrinks according to node count and iteration to refine local connectivity. After each added node, the planner attempts to connect the two trees to find feasible paths that are combined to update the best solution. Early stopping terminates planning after a number of iterations without improvement. A final random shortcutting pass reduces unnecessary detours for improved smoothness.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self,\n                 max_iter=4000,\n                 step_size=5.0,\n                 max_radius=25.0,\n                 min_radius=5.0,\n                 max_no_improve=60,\n                 shortcut_iter=120):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.max_radius = max_radius\n        self.min_radius = min_radius\n        self.max_no_improve = max_no_improve\n        self.shortcut_iter = shortcut_iter\n\n    def plan(self, map):\n        import math\n        import random\n        import time\n\n        bounds = map.size\n        dim = len(bounds)\n        start_pos = tuple(map.start)\n        goal_pos = tuple(map.goal)\n        obstacles = map.obstacles\n        is_3d = (dim == 3)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def in_obstacle(p):\n            px, py, pz = (p + (0, 0, 0))[:3]\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def edge_in_obstacle(a, b, res=1.0):\n            dist_ab = math.dist(a, b)\n            if dist_ab < 1e-12:\n                return False\n            steps = max(2, int(dist_ab / res))\n            for i in range(steps + 1):\n                interp = tuple(a[d] + (b[d] - a[d]) * i / steps for d in range(dim))\n                if in_obstacle(interp):\n                    return True\n            return False\n\n        def steer(frm, to):\n            dist_frm_to = math.dist(frm, to)\n            if dist_frm_to <= self.step_size:\n                return to\n            ratio = self.step_size / dist_frm_to\n            return tuple(frm[d] + (to[d] - frm[d]) * ratio for d in range(dim))\n\n        def adaptive_radius(node_count, iteration):\n            # Unified radius shrinking with node count and iteration progress\n            if node_count <= 1:\n                return self.max_radius\n            import math\n            gamma = self.max_radius\n            r = gamma * (math.log(node_count) / node_count) ** (1 / dim)\n            decay = max(self.min_radius / gamma, 1.0 - 0.95 * (iteration / self.max_iter))\n            return max(self.min_radius, min(r * decay, self.max_radius))\n\n        def neighbors(tree, point, radius):\n            radius_sq = radius * radius\n            res = []\n            px = point\n            for node in tree:\n                d_sq = 0.0\n                for i_ in range(dim):\n                    diff = node.position[i_] - px[i_]\n                    d_sq += diff * diff\n                    if d_sq > radius_sq:\n                        break\n                else:\n                    res.append(node)\n            return res\n\n        def choose_parent(tree, new_pos, iter_i):\n            n_nodes = len(tree)\n            r = adaptive_radius(n_nodes, iter_i)\n            nbrs = neighbors(tree, new_pos, r)\n            # filter valid parents with collision-free edge\n            valid_parents = []\n            for n in nbrs:\n                if edge_in_obstacle(n.position, new_pos):\n                    continue\n                valid_parents.append(n)\n            if not valid_parents:\n                # fallback: find nearest node with collision-free edge\n                nearest = None\n                nearest_dist = float('inf')\n                for n in tree:\n                    d = math.dist(n.position, new_pos)\n                    if d < nearest_dist and not edge_in_obstacle(n.position, new_pos):\n                        nearest = n\n                        nearest_dist = d\n                if nearest is None:\n                    return None, []\n                best_parent = nearest\n                cost = best_parent.cost + nearest_dist\n                new_node = Node(new_pos, parent=best_parent, cost=cost)\n                best_parent.add_child(new_node)\n                tree.append(new_node)\n                return new_node, []\n            # select parent minimizing cost\n            best_parent = None\n            min_cost = float('inf')\n            for p in valid_parents:\n                c = p.cost + math.dist(p.position, new_pos)\n                if c < min_cost:\n                    min_cost = c\n                    best_parent = p\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree.append(new_node)\n            return new_node, valid_parents\n\n        def rewire(pivot, nbrs):\n            for nb in nbrs:\n                if nb == pivot.parent:\n                    continue\n                dist_pivot_nb = math.dist(pivot.position, nb.position)\n                new_cost = pivot.cost + dist_pivot_nb\n                if new_cost + 1e-12 < nb.cost:\n                    if edge_in_obstacle(pivot.position, nb.position):\n                        continue\n                    # Rewire parent-child\n                    if nb.parent is not None:\n                        nb.parent.remove_child(nb)\n                    pivot.add_child(nb)\n                    nb.cost = new_cost\n\n        def attempt_connect(tree_from, node_to_connect):\n            if not tree_from:\n                return None\n            nearest = min(tree_from, key=lambda n: math.dist(n.position, node_to_connect.position))\n            dist_near = math.dist(nearest.position, node_to_connect.position)\n            if dist_near <= self.step_size:\n                if edge_in_obstacle(nearest.position, node_to_connect.position) or in_obstacle(node_to_connect.position):\n                    return None\n                new_node = Node(node_to_connect.position, parent=nearest, cost=nearest.cost + dist_near)\n                nearest.add_child(new_node)\n                tree_from.append(new_node)\n                return new_node\n            # incremental steering towards target\n            current = nearest\n            steps = int(math.ceil(dist_near / self.step_size))\n            for _ in range(steps):\n                new_pos = steer(current.position, node_to_connect.position)\n                if not in_bounds(new_pos) or in_obstacle(new_pos) or edge_in_obstacle(current.position, new_pos):\n                    return None\n                new_node = Node(new_pos, parent=current, cost=current.cost + math.dist(current.position, new_pos))\n                current.add_child(new_node)\n                tree_from.append(new_node)\n                current = new_node\n                if math.dist(current.position, node_to_connect.position) <= self.step_size:\n                    if edge_in_obstacle(current.position, node_to_connect.position) or in_obstacle(node_to_connect.position):\n                        return None\n                    final_node = Node(node_to_connect.position, parent=current,\n                                      cost=current.cost + math.dist(current.position, node_to_connect.position))\n                    current.add_child(final_node)\n                    tree_from.append(final_node)\n                    return final_node\n            return None\n\n        def sample_uniform():\n            return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        def sample_informed(c_best, c_min):\n            if c_best == float('inf') or c_min < 1e-12:\n                return sample_uniform()\n            center = tuple((start_pos[d] + goal_pos[d]) / 2 for d in range(dim))\n            unit_dir = []\n            for d in range(dim):\n                unit_dir.append((goal_pos[d] - start_pos[d]) / c_min)\n            r1 = c_best * 0.5\n            val = max(c_best * c_best - c_min * c_min, 0.0)\n            r_other = math.sqrt(val) * 0.5\n\n            if dim == 2:\n                a1 = unit_dir\n                a2 = (-a1[1], a1[0])\n                basis = (a1, a2)\n                radii = (r1, r_other)\n            else:\n                def cross(u, v):\n                    return (u[1] * v[2] - u[2] * v[1], u[2] * v[0] - u[0] * v[2], u[0] * v[1] - u[1] * v[0])\n\n                def norm(v):\n                    return math.sqrt(sum(x * x for x in v))\n\n                a1 = unit_dir\n                ref = (1, 0, 0) if abs(a1[0]) < 0.9 else (0, 1, 0)\n                b2 = cross(a1, ref)\n                n_b2 = norm(b2)\n                if n_b2 < 1e-12:\n                    ref = (0, 0, 1)\n                    b2 = cross(a1, ref)\n                    n_b2 = norm(b2)\n                b2 = tuple(x / n_b2 for x in b2)\n                b3 = cross(a1, b2)\n                basis = (a1, b2, b3)\n                radii = (r1, r_other, r_other)\n\n            def sample_unit_ball(dim):\n                while True:\n                    vec = [random.gauss(0, 1) for _ in range(dim)]\n                    nrm = math.sqrt(sum(v * v for v in vec))\n                    if nrm < 1e-12:\n                        continue\n                    vec = [v / nrm for v in vec]\n                    r = random.random() ** (1 / dim)\n                    return [v * r for v in vec]\n\n            u = sample_unit_ball(dim)\n            mapped = []\n            for d in range(dim):\n                val = center[d]\n                for i in range(dim):\n                    val += basis[i][d] * radii[i] * u[i]\n                val = max(0.0, min(val, bounds[d]))\n                mapped.append(val)\n            return tuple(mapped)\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path[:]\n            path = list(path)\n            for _ in range(self.shortcut_iter):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if not edge_in_obstacle(path[i], path[j]):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        best_path = []\n        best_cost = float('inf')\n        c_min = math.dist(start_pos, goal_pos)\n        found_solution = False\n        no_improve_count = 0\n\n        start_time = time.time()\n\n        for iter_i in range(self.max_iter):\n            if found_solution:\n                sample = sample_informed(best_cost, c_min)\n                # Occasionally sample uniform to avoid local minima\n                if random.random() < 0.15:\n                    sample = sample_uniform()\n            else:\n                sample = sample_uniform()\n\n            if not in_bounds(sample) or in_obstacle(sample):\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n                continue\n\n            tree_a, tree_b = (start_tree, goal_tree) if iter_i % 2 == 0 else (goal_tree, start_tree)\n\n            nearest_n = min(tree_a, key=lambda n: math.dist(n.position, sample))\n            new_pos = steer(nearest_n.position, sample)\n            if not in_bounds(new_pos) or in_obstacle(new_pos) or edge_in_obstacle(nearest_n.position, new_pos):\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n                continue\n\n            new_node, nbrs = choose_parent(tree_a, new_pos, iter_i)\n            if new_node is None:\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n                continue\n\n            rewire(new_node, nbrs)\n            nodes.append(new_node)\n            if new_node.parent:\n                edges.append((new_node.parent, new_node))\n\n            connect_node = attempt_connect(tree_b, new_node)\n            if connect_node is not None:\n                if iter_i % 2 == 0:\n                    path_a = new_node.path_from_root()\n                    path_b = connect_node.path_from_root()\n                else:\n                    path_a = connect_node.path_from_root()\n                    path_b = new_node.path_from_root()\n                if path_a and path_b and path_a[-1] == path_b[-1]:\n                    candidate_path = path_a + path_b[-2::-1]\n                else:\n                    candidate_path = path_a + path_b[::-1]\n\n                total_cost = 0.0\n                for i in range(len(candidate_path) - 1):\n                    total_cost += math.dist(candidate_path[i], candidate_path[i + 1])\n\n                if total_cost + 1e-9 < best_cost:\n                    best_cost = total_cost\n                    best_path = candidate_path\n                    found_solution = True\n                    no_improve_count = 0\n                else:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n            else:\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n\n        if found_solution and len(best_path) >= 3:\n            best_path = shortcut_path(best_path)\n\n        return PlannerResult(success=found_solution, path=best_path, nodes=nodes, edges=edges)",
          "objective": -32.09066,
          "time_improvement": 51.0,
          "length_improvement": 17.0,
          "smoothness_improvement": 1354.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.017293906211853026,
                    "num_nodes_avg": 91.5,
                    "path_length_avg": 161.730924310866,
                    "smoothness_avg": 0.042930783900201136,
                    "success_improvement": 0.0,
                    "time_improvement": 28.788981008339842,
                    "length_improvement": 11.352717594718152,
                    "smoothness_improvement": 571.9599937275159,
                    "objective_score": 18.308124827970424
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.03642895221710205,
                    "num_nodes_avg": 225.4,
                    "path_length_avg": 238.2939143004422,
                    "smoothness_avg": 0.0897730230727014,
                    "success_improvement": 0.0,
                    "time_improvement": 77.4385205476863,
                    "length_improvement": 20.450632496491846,
                    "smoothness_improvement": 2209.924544555513,
                    "objective_score": 46.551558384978556
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.02602849006652832,
                    "num_nodes_avg": 208.0,
                    "path_length_avg": 123.50286586657371,
                    "smoothness_avg": 0.10841836272819716,
                    "success_improvement": 0.0,
                    "time_improvement": 47.439204641197854,
                    "length_improvement": 17.97527706591856,
                    "smoothness_improvement": 1279.073571291572,
                    "objective_score": 31.41229548836835
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "time_expert",
          "algorithm_description": "A bidirectional RRT* planner with adaptive multi-radius rewiring emphasizing cost-based connections for shorter paths, enhanced sampling bias combining ellipsoidal informed and goal-directed Gaussian samples for faster convergence. It employs efficient approximate nearest neighbor search, dynamic step size control to refine exploration precision, and accelerated early stopping criteria to reduce planning time. Path smoothness is indirectly improved by prioritizing cost-optimal parent selection without explicit curvature penalties, enabling more flexible rewiring and shorter, smoother paths.",
          "planning_mechanism": "A bidirectional RRT* grows two trees alternating expansions from start and goal. Sampling blends ellipsoidal informed and goal-biased Gaussian perturbations to prioritize promising regions. Nearest neighbor and near-node queries use approximate but efficient search. Adaptive multi-radius rewiring updates parent-child relations based solely on cost, allowing more aggressive shortcuts and path shortening. A dynamic step size decreases as nodes increase, refining path precision. Early stopping triggers upon stagnated cost improvements. After a solution is found, shortcutting with collision checks refines the path length and smoothness, balancing planning time and path quality.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position  # tuple of floats\n        self.parent = parent      # Node or None\n        self.cost = cost          # cost from root\n        self.children = []       # list of Node\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def path_from_root(self):\n        node = self\n        path = []\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=2500, max_no_improve=40, improve_tol=1e-6,\n                 init_step=7.0, min_step=0.8, n_near_const=15, shortcut_iters=150):\n        self.max_iter = max_iter\n        self.max_no_improve = max_no_improve\n        self.improve_tol = improve_tol\n        self.init_step = init_step\n        self.min_step = min_step\n        self.n_near_const = n_near_const\n        self.shortcut_iters = shortcut_iters\n\n    def plan(self, map) -> 'PlannerResult':\n        import time, random, math\n\n        start_p = tuple(map.start)\n        goal_p = tuple(map.goal)\n        bounds = tuple(map.size)\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def dist(a, b):\n            s = 0.0\n            for i in range(dim):\n                d = a[i] - b[i]\n                s += d * d\n            return math.sqrt(s)\n\n        def in_obstacle(p):\n            px, py, pz = (p + (0, 0, 0))[:3]\n            for obs in obstacles:\n                if is_3d:\n                    ox, oy, oz, ow, oh, od = obs\n                    if ox <= px <= ox + ow and oy <= py <= oy + oh and oz <= pz <= oz + od:\n                        return True\n                else:\n                    ox, oy, ow, oh = obs\n                    if ox <= px <= ox + ow and oy <= py <= oy + oh:\n                        return True\n            return False\n\n        def edge_obstacle(f, t, resolution=1.0):\n            length = dist(f, t)\n            if length < 1e-12:\n                return False\n            steps = max(5, int(length / resolution))\n            for i in range(steps + 1):\n                inter = tuple(f[d] + (t[d] - f[d]) * i / steps for d in range(dim))\n                if in_obstacle(inter):\n                    return True\n            return False\n\n        def steer(frm, to, step_size):\n            d = dist(frm, to)\n            if d <= step_size:\n                return to\n            ratio = step_size / d\n            return tuple(frm[i] + (to[i] - frm[i]) * ratio for i in range(dim))\n\n        # Approximate nearest neighbor: linear with early reject for efficiency\n        def nearest(tree, point):\n            best = None\n            best_d2 = float('inf')\n            px = point\n            for n in tree:\n                d2 = 0.0\n                for i_ in range(dim):\n                    delta = n.position[i_] - px[i_]\n                    d2 += delta * delta\n                    if d2 >= best_d2:\n                        break\n                else:\n                    if d2 < best_d2:\n                        best = n\n                        best_d2 = d2\n            return best, math.sqrt(best_d2) if best is not None else None\n\n        def near_nodes(tree, point, radius):\n            rq = radius * radius\n            px = point\n            near_list = []\n            for n in tree:\n                d2 = 0.0\n                for i_ in range(dim):\n                    delta = n.position[i_] - px[i_]\n                    d2 += delta * delta\n                    if d2 > rq:\n                        break\n                if d2 <= rq:\n                    near_list.append(n)\n            return near_list\n\n        def adaptive_radius(n_nodes, c_best):\n            if n_nodes <= 1:\n                return self.init_step * 3.3\n            base = (self.n_near_const * (math.log(n_nodes) / n_nodes)) ** (1 / dim)\n            base = min(base, self.init_step * 5.8)\n            if c_best == float('inf'):\n                return base\n            shrink_factor = max(0.3, c_best / (c_min * 3.2))\n            return max(self.min_step * 0.8, base * shrink_factor)\n\n        # Sampling biased by ellipsoid informed + gaussian near goal for faster convergence\n        def sample(c_best):\n            if c_best == float('inf'):\n                # random uniform in bounds\n                return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n            # Informed ellipsoid sampling\n            center = tuple(0.5 * (start_p[i] + goal_p[i]) for i in range(dim))\n            diff = [goal_p[i] - start_p[i] for i in range(dim)]\n            dist_sg = dist(start_p, goal_p)\n            if dist_sg < 1e-14:\n                return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n            unit_vec = [d / dist_sg for d in diff]\n            # Build orthonormal basis (Gram-Schmidt)\n            U = [unit_vec]\n            for idx in range(dim - 1):\n                v = [0.0] * dim\n                v[(idx + 1) % dim] = 1.0\n                for u in U:\n                    proj = sum(v[j] * u[j] for j in range(dim))\n                    for j in range(dim):\n                        v[j] -= proj * u[j]\n                norm_v = math.sqrt(sum(x * x for x in v))\n                if norm_v > 1e-14:\n                    U.append([x / norm_v for x in v])\n                else:\n                    U.append([0.0] * dim)\n            r1 = c_best * 0.5\n            val = c_best * c_best - c_min * c_min\n            r2 = math.sqrt(val) * 0.5 if val > 0 else 0.0\n            radii = [r1] + [r2] * (dim - 1)\n\n            for _ in range(50):\n                # Random point inside unit ball\n                x_ball = [random.gauss(0, 1) for _ in range(dim)]\n                norm_x = math.sqrt(sum(x * x for x in x_ball))\n                if norm_x < 1e-14:\n                    continue\n                x_unit = [x / norm_x for x in x_ball]\n                r = random.random() ** (1 / dim)\n                point_ball = [r * x_unit[i] for i in range(dim)]\n                point_ellipsoid = [radii[i] * point_ball[i] for i in range(dim)]\n                sample_point = [center[j] for j in range(dim)]\n                for i_ in range(dim):\n                    for j_ in range(dim):\n                        sample_point[j_] += U[i_][j_] * point_ellipsoid[i_]\n                candidate = tuple(sample_point)\n                if all(0.0 <= candidate[i] <= bounds[i] for i in range(dim)) and not in_obstacle(candidate):\n                    # 20% chance to bias samples near goal using gaussian for faster connection\n                    if random.random() < 0.2:\n                        gauss_sample = []\n                        for d_i, bound_i in enumerate(bounds):\n                            gs = random.gauss(goal_p[d_i], min(bound_i * 0.05, 1.0))\n                            gauss_sample.append(min(max(0.0, gs), bound_i))\n                        gs_tuple = tuple(gauss_sample)\n                        if not in_obstacle(gs_tuple):\n                            return gs_tuple\n                    return candidate\n            # fallback uniform random\n            return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n\n        def get_path(node):\n            return node.path_from_root()\n\n        def connect_path(n1, n2):\n            p1 = get_path(n1)\n            p2 = get_path(n2)[::-1]\n            if p1 and p2 and p1[-1] == p2[0]:\n                return p1 + p2[1:]\n            return p1 + p2\n\n        # Add node with cost-only rewiring (no curvature penalty) to favor shorter paths\n        def add_node(tree, new_sample, all_nodes, edges, c_best, step_size):\n            nn, d_nn = nearest(tree, new_sample)\n            if nn is None:\n                return None\n            new_pos = steer(nn.position, new_sample, step_size)\n            if in_obstacle(new_pos) or edge_obstacle(nn.position, new_pos):\n                return None\n\n            n_nodes = len(all_nodes)\n            radius = adaptive_radius(n_nodes, c_best)\n            near = near_nodes(tree, new_pos, radius)\n\n            best_parent = nn\n            best_cost = nn.cost + dist(nn.position, new_pos)\n\n            for cand in near:\n                if cand == nn:\n                    continue\n                if edge_obstacle(cand.position, new_pos):\n                    continue\n                cost_candidate = cand.cost + dist(cand.position, new_pos)\n                if cost_candidate + self.improve_tol < best_cost:\n                    best_cost = cost_candidate\n                    best_parent = cand\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = best_cost\n            tree.append(new_node)\n            all_nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors if cost improves\n            near_r = near_nodes(tree, new_node.position, radius)\n            for near_n in near_r:\n                if near_n == best_parent or near_n == new_node:\n                    continue\n                if edge_obstacle(new_node.position, near_n.position):\n                    continue\n                alt_cost = new_node.cost + dist(new_node.position, near_n.position)\n                if alt_cost + self.improve_tol < near_n.cost:\n                    # Rewire\n                    if near_n.parent:\n                        near_n.parent.remove_child(near_n)\n                        try:\n                            edges.remove((near_n.parent, near_n))\n                        except Exception:\n                            pass\n                    new_node.add_child(near_n)\n                    near_n.cost = alt_cost\n                    edges.append((new_node, near_n))\n            return new_node\n\n        # Shortcutting without explicit curvature penalty but verify collision\n        def shortcut_path(path):\n            path = list(path)\n            if len(path) < 3:\n                return path\n            changed = True\n            iter_count = 0\n            while changed and iter_count < self.shortcut_iters:\n                iter_count += 1\n                changed = False\n                i = 0\n                while i < len(path) - 2:\n                    max_j = min(len(path) - 1, i + 6)\n                    if max_j <= i + 1:\n                        i += 1\n                        continue\n                    j = random.randint(i + 2, max_j)\n                    if not edge_obstacle(path[i], path[j]):\n                        # shortcut allowed\n                        del path[i + 1:j]\n                        changed = True\n                        break\n                    i += 1\n            return path\n\n        # Initialization\n        start_tree = [Node(start_p)]\n        goal_tree = [Node(goal_p)]\n        all_nodes = start_tree + goal_tree\n        edges = []\n        c_min = dist(start_p, goal_p)\n        best_cost = float('inf')\n        best_path = []\n        found_solution = False\n        no_improve_count = 0\n        last_best_cost = float('inf')\n        start_time = time.time()\n        step_size = self.init_step\n\n        for iter_num in range(self.max_iter):\n            sample_pt = sample(best_cost)\n\n            # Alternate expanding trees\n            if iter_num % 2 == 0:\n                tree_a, tree_b = start_tree, goal_tree\n            else:\n                tree_a, tree_b = goal_tree, start_tree\n\n            # Gradually reduce step size to refine paths as more nodes added\n            num_nodes = len(all_nodes)\n            step_size = max(self.min_step, self.init_step * (1 - num_nodes / (self.max_iter * 1.1)))\n\n            new_node = add_node(tree_a, sample_pt, all_nodes, edges, best_cost, step_size)\n            if new_node is None:\n                if found_solution:\n                    no_improve_count += 1\n                continue\n\n            nbr, d_nbr = nearest(tree_b, new_node.position)\n            if nbr is not None and d_nbr <= step_size and not edge_obstacle(new_node.position, nbr.position):\n                candidate_path = connect_path(new_node, nbr)\n                candidate_cost = new_node.cost + dist(new_node.position, nbr.position) + nbr.cost\n                if candidate_cost + self.improve_tol < best_cost:\n                    best_cost = candidate_cost\n                    best_path = candidate_path\n                    found_solution = True\n                    no_improve_count = 0\n                else:\n                    no_improve_count += 1\n            elif found_solution:\n                no_improve_count += 1\n\n            if found_solution:\n                if best_cost + self.improve_tol < last_best_cost:\n                    last_best_cost = best_cost\n                    no_improve_count = 0\n                elif no_improve_count >= self.max_no_improve:\n                    break\n\n        if found_solution and len(best_path) > 2:\n            # Post-processing shortcutting reduces path length, indirect smoothness gain\n            for _ in range(3):\n                best_path = shortcut_path(best_path)\n\n        if found_solution:\n            return PlannerResult(True, best_path, all_nodes, edges)\n        else:\n            return PlannerResult(False, [], all_nodes, edges)",
          "objective": -31.91279,
          "time_improvement": 53.0,
          "length_improvement": 14.0,
          "smoothness_improvement": 1510.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.012701964378356934,
                    "num_nodes_avg": 93.4,
                    "path_length_avg": 167.30235687670796,
                    "smoothness_avg": 0.0425654522641374,
                    "success_improvement": 0.0,
                    "time_improvement": 47.69719371100672,
                    "length_improvement": 8.298927120381544,
                    "smoothness_improvement": 566.241760292773,
                    "objective_score": 22.119723186994808
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.022562861442565918,
                    "num_nodes_avg": 215.5,
                    "path_length_avg": 240.54349758360195,
                    "smoothness_avg": 0.10420826484630626,
                    "success_improvement": 0.0,
                    "time_improvement": 86.02618236758204,
                    "length_improvement": 19.699656845908514,
                    "smoothness_improvement": 2581.353712674754,
                    "objective_score": 50.53441738119349
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.03733506202697754,
                    "num_nodes_avg": 254.8,
                    "path_length_avg": 128.49722609113547,
                    "smoothness_avg": 0.11646484458584172,
                    "success_improvement": 0.0,
                    "time_improvement": 24.60720733732938,
                    "length_improvement": 14.658260810641927,
                    "smoothness_improvement": 1381.4242265913015,
                    "objective_score": 23.08423982054048
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m1",
          "algorithm_description": "A bidirectional RRT* planner with consistent adaptive neighbor radius, incremental rewiring on insertions, and ellipsoidal informed sampling guiding exploration. It aggressively attempts direct tree connections, applies iterative random shortcutting post-planning for path smoothing and shortening, and includes early stopping after stagnation to save time, thus improving planning efficiency, path quality, robustness, and smoothness.",
          "planning_mechanism": "The planner grows two trees from start and goal points by sampling points with uniform distribution initially and ellipsoidal informed sampling once a solution is found. Each iteration alternates expanding one tree toward a sampled point, choosing a parent and rewiring neighbors within an adaptive radius that shrinks over iterations. After each insertion, it tries direct connection to the opposite tree to form a valid path. The best discovered path is updated incrementally, and if no improvement occurs over many iterations, planning halts early. Post-planning applies multiple shortcut attempts on the best path to enhance smoothness and reduce length.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self,\n                 max_iter=5000,\n                 step_size=5.0,\n                 max_radius=30.0,\n                 min_radius=5.0,\n                 max_no_improve=80,\n                 time_limit=30.0,\n                 shortcut_iter=150):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.max_radius = max_radius\n        self.min_radius = min_radius\n        self.max_no_improve = max_no_improve\n        self.time_limit = time_limit\n        self.shortcut_iter = shortcut_iter\n\n    def plan(self, map):\n        import time\n        import math\n        import random\n\n        bounds = map.size\n        dim = len(bounds)\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = (dim == 3)\n\n        def in_bounds(pos):\n            return all(0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    px, py = pos\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def edge_in_obstacle(a, b, res=1.0):\n            dist = math.dist(a, b)\n            if dist < 1e-12:\n                return False\n            steps = max(2, int(dist / res))\n            for i in range(steps + 1):\n                interp = tuple(a[d] + (b[d] - a[d]) * i / steps for d in range(dim))\n                if in_obstacle(interp):\n                    return True\n            return False\n\n        def steer(from_p, to_p):\n            dist = math.dist(from_p, to_p)\n            if dist <= self.step_size:\n                return to_p\n            ratio = self.step_size / dist\n            return tuple(from_p[d] + (to_p[d] - from_p[d]) * ratio for d in range(dim))\n\n        def adaptive_radius(n, iter_i):\n            gamma = self.max_radius\n            unit_ball_volume = (math.pi ** (dim / 2)) / math.gamma(dim / 2 + 1) if dim > 1 else 2.0\n            if n < 1:\n                return self.max_radius\n            radius = gamma * ((math.log(n + 1) / (n + 1)) ** (1 / dim))\n            decay = max(self.min_radius / gamma, 1.0 - 0.9 * (iter_i / self.max_iter))\n            radius = max(self.min_radius, min(radius * decay, self.max_radius))\n            return radius\n\n        def neighbors(tree, pos, radius):\n            r_sq = radius * radius\n            result = []\n            for node in tree:\n                dist_sq = 0.0\n                for d in range(dim):\n                    diff = node.position[d] - pos[d]\n                    dist_sq += diff * diff\n                    if dist_sq > r_sq:\n                        break\n                else:\n                    result.append(node)\n            return result\n\n        def choose_parent(tree, pos, iter_i):\n            n = len(tree)\n            r = adaptive_radius(n, iter_i)\n            nbrs = neighbors(tree, pos, r)\n            if not nbrs:\n                nearest = min(tree, key=lambda node: math.dist(node.position, pos))\n                if edge_in_obstacle(nearest.position, pos) or in_obstacle(pos):\n                    return None, []\n                cost_to_here = nearest.cost + math.dist(nearest.position, pos)\n                new_node = Node(pos, parent=nearest, cost=cost_to_here)\n                nearest.add_child(new_node)\n                tree.append(new_node)\n                return new_node, []\n            min_cost = float('inf')\n            best_parent = None\n            for nb in nbrs:\n                dist_nb = math.dist(nb.position, pos)\n                est_cost = nb.cost + dist_nb\n                if est_cost >= min_cost:\n                    continue\n                if edge_in_obstacle(nb.position, pos):\n                    continue\n                if est_cost < min_cost:\n                    min_cost = est_cost\n                    best_parent = nb\n            if best_parent is None:\n                nearest = min(tree, key=lambda node: math.dist(node.position, pos))\n                if edge_in_obstacle(nearest.position, pos) or in_obstacle(pos):\n                    return None, []\n                best_parent = nearest\n                min_cost = best_parent.cost + math.dist(best_parent.position, pos)\n            new_node = Node(pos, parent=best_parent, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree.append(new_node)\n            return new_node, nbrs\n\n        def rewire(pivot, nbrs):\n            for nb in nbrs:\n                if nb == pivot.parent:\n                    continue\n                new_cost = pivot.cost + math.dist(pivot.position, nb.position)\n                if new_cost + 1e-12 < nb.cost:\n                    if edge_in_obstacle(pivot.position, nb.position):\n                        continue\n                    # Remove from old parent children to avoid dangling references\n                    if nb.parent is not None and nb in nb.parent.children:\n                        nb.parent.children.remove(nb)\n                    pivot.add_child(nb)\n                    nb.cost = new_cost\n\n        def direct_connect(tree, target_node):\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda n: math.dist(n.position, target_node.position))\n            dist = math.dist(nearest.position, target_node.position)\n            if dist <= self.step_size:\n                if edge_in_obstacle(nearest.position, target_node.position) or in_obstacle(target_node.position):\n                    return None\n                new_node = Node(target_node.position, parent=nearest, cost=nearest.cost + dist)\n                nearest.add_child(new_node)\n                tree.append(new_node)\n                return new_node\n            # Incremental connection attempt toward target\n            current = nearest\n            steps = int(math.ceil(dist / self.step_size))\n            for _ in range(steps):\n                new_pos = steer(current.position, target_node.position)\n                if not in_bounds(new_pos) or in_obstacle(new_pos) or edge_in_obstacle(current.position, new_pos):\n                    return None\n                new_node = Node(new_pos, parent=current, cost=current.cost + math.dist(current.position, new_pos))\n                current.add_child(new_node)\n                tree.append(new_node)\n                current = new_node\n                if math.dist(current.position, target_node.position) <= self.step_size:\n                    if edge_in_obstacle(current.position, target_node.position) or in_obstacle(target_node.position):\n                        return None\n                    final_node = Node(target_node.position, parent=current, cost=current.cost + math.dist(current.position, target_node.position))\n                    current.add_child(final_node)\n                    tree.append(final_node)\n                    return final_node\n            return None\n\n        def sample_uniform():\n            while True:\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not in_obstacle(p):\n                    return p\n\n        def sample_informed():\n            if not found_solution or best_cost == float('inf') or c_min < 1e-12:\n                return sample_uniform()\n            center = tuple((start_pos[d] + goal_pos[d]) * 0.5 for d in range(dim))\n            unit_dir = tuple((goal_pos[d] - start_pos[d]) / c_min for d in range(dim))\n            r1 = best_cost * 0.5\n            val = max(best_cost*best_cost - c_min*c_min, 0.0)\n            r_other = math.sqrt(val) * 0.5\n            if dim == 2:\n                a1 = unit_dir\n                a2 = (-a1[1], a1[0])\n                basis = (a1, a2)\n                radii = (r1, r_other)\n            else:\n                def cross(u, v):\n                    return (u[1]*v[2] - u[2]*v[1], u[2]*v[0] - u[0]*v[2], u[0]*v[1] - u[1]*v[0])\n                def norm(v):\n                    return math.sqrt(sum(x*x for x in v))\n                a1 = unit_dir\n                ref = (1,0,0) if abs(a1[0]) < 0.9 else (0,1,0)\n                b2 = cross(a1, ref)\n                n_b2 = norm(b2)\n                if n_b2 < 1e-12:\n                    ref = (0,0,1)\n                    b2 = cross(a1, ref)\n                    n_b2 = norm(b2)\n                b2 = tuple(x / n_b2 for x in b2)\n                b3 = cross(a1, b2)\n                basis = (a1, b2, b3)\n                radii = (r1, r_other, r_other)\n            def sample_unit_ball(dim):\n                while True:\n                    vec = [random.gauss(0,1) for _ in range(dim)]\n                    nrm = math.sqrt(sum(v*v for v in vec))\n                    if nrm < 1e-12:\n                        continue\n                    vec = [v/nrm for v in vec]\n                    r = random.random() ** (1/dim)\n                    return [v*r for v in vec]\n            u = sample_unit_ball(dim)\n            mapped = []\n            for d in range(dim):\n                val = center[d]\n                for i in range(dim):\n                    val += basis[i][d]*radii[i]*u[i]\n                val = max(0.0, min(val, bounds[d]))\n                mapped.append(val)\n            if not in_obstacle(tuple(mapped)):\n                return tuple(mapped)\n            else:\n                return sample_uniform()\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path[:]\n            for _ in range(self.shortcut_iter):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path)-3)\n                j = random.randint(i+2, len(path)-1)\n                p1, p2 = path[i], path[j]\n                if not edge_in_obstacle(p1, p2):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        best_path = []\n        best_cost = float('inf')\n        c_min = math.dist(start_pos, goal_pos)\n        found_solution = False\n        no_improve_count = 0\n\n        start_time = time.time()\n\n        for it in range(self.max_iter):\n            if time.time() - start_time > self.time_limit:\n                break\n\n            tree_a, tree_b = (start_tree, goal_tree) if it % 2 == 0 else (goal_tree, start_tree)\n            x_rand = sample_informed()\n\n            if not in_bounds(x_rand) or in_obstacle(x_rand):\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n                continue\n\n            nearest = min(tree_a, key=lambda node: math.dist(node.position, x_rand))\n            new_pos = steer(nearest.position, x_rand)\n            if not in_bounds(new_pos) or in_obstacle(new_pos) or edge_in_obstacle(nearest.position, new_pos):\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n                continue\n\n            new_node, nbrs = choose_parent(tree_a, new_pos, it)\n            if new_node is None:\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n                continue\n\n            rewire(new_node, nbrs)\n            nodes.append(new_node)\n            if new_node.parent:\n                edges.append((new_node.parent, new_node))\n\n            meet_node = direct_connect(tree_b, new_node)\n            if meet_node is not None:\n                # Construct combined path (avoid duplication at connection node)\n                if it % 2 == 0:\n                    path_a = new_node.path_from_root()\n                    path_b = meet_node.path_from_root()\n                else:\n                    path_a = meet_node.path_from_root()\n                    path_b = new_node.path_from_root()\n                if path_a and path_b and path_a[-1] == path_b[-1]:\n                    merged_path = path_a + path_b[-2::-1]\n                else:\n                    merged_path = path_a + path_b[::-1]\n\n                total_cost = 0.0\n                for i in range(len(merged_path) - 1):\n                    total_cost += math.dist(merged_path[i], merged_path[i + 1])\n\n                if total_cost + 1e-9 < best_cost:\n                    best_cost = total_cost\n                    best_path = merged_path\n                    found_solution = True\n                    no_improve_count = 0\n                else:\n                    if found_solution:\n                        no_improve_count += 1\n                        if no_improve_count >= self.max_no_improve:\n                            break\n            else:\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n\n        if found_solution and len(best_path) >= 3:\n            best_path = shortcut_path(best_path)\n\n        return PlannerResult(success=found_solution, path=best_path, nodes=nodes, edges=edges)",
          "objective": -28.25774,
          "time_improvement": 36.0,
          "length_improvement": 17.0,
          "smoothness_improvement": 1476.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.020374512672424315,
                    "num_nodes_avg": 117.1,
                    "path_length_avg": 160.29717568265116,
                    "smoothness_avg": 0.04606419133881355,
                    "success_improvement": 0.0,
                    "time_improvement": 16.103985352516435,
                    "length_improvement": 12.138577937043584,
                    "smoothness_improvement": 621.0046244449597,
                    "objective_score": 15.21936549020588
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.029372024536132812,
                    "num_nodes_avg": 280.0,
                    "path_length_avg": 239.5929063098773,
                    "smoothness_avg": 0.09565090723691308,
                    "success_improvement": 0.0,
                    "time_improvement": 81.80907526256789,
                    "length_improvement": 20.016991574330532,
                    "smoothness_improvement": 2361.166737769517,
                    "objective_score": 48.35875121221627
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.04408328533172608,
                    "num_nodes_avg": 403.4,
                    "path_length_avg": 123.7830250208629,
                    "smoothness_avg": 0.12150286008847652,
                    "success_improvement": 0.0,
                    "time_improvement": 10.980140102549283,
                    "length_improvement": 17.789208695385014,
                    "smoothness_improvement": 1445.5074119171938,
                    "objective_score": 21.195104307581765
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e2",
          "algorithm_description": "An integrated bidirectional RRT* variant with consistent neighbor radius computation based on both iteration and node count, progressive rewiring with lazy collision checking, ellipsoidal informed sampling after first solution, and post-planning path shortcutting to reduce path length and improve smoothness, combined with early stopping after stagnation. The planner balances exploration and exploitation by systematically alternating tree expansions and aggressively rewiring nodes within a theoretically sound radius, while utilizing informed sampling to focus search and post-processing shortcutting to enhance path quality.",
          "planning_mechanism": "A bidirectional RRT* planner that alternates expanding start and goal trees via ellipsoidal informed sampling when available, uses an adaptive rewiring radius scaling with iteration and node count for stable and effective rewiring, partially lazy collision checking to minimize overhead during rewiring, attempts direct connection between trees after each insertion, and after planning completes, applies iterative random shortcutting to shorten and smooth the final best path. Early stopping triggers if no improvement for several iterations, boosting efficiency.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self,\n                 max_iter=5000,\n                 step_size=5.0,\n                 max_radius=30.0,\n                 min_radius=5.0,\n                 max_no_improve=80,\n                 time_limit=30.0,\n                 shortcut_iter=150):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.max_radius = max_radius\n        self.min_radius = min_radius\n        self.max_no_improve = max_no_improve\n        self.time_limit = time_limit\n        self.shortcut_iter = shortcut_iter\n\n    def plan(self, map):\n        import time\n        import math\n        import random\n\n        bounds = map.size\n        dim = len(bounds)\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = dim == 3\n\n        def in_bounds(pos):\n            return all(0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    px, py = pos\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def edge_in_obstacle(a, b, res=1.0):\n            dist = math.dist(a, b)\n            if dist < 1e-12:\n                return False\n            steps = max(2, int(dist / res))\n            for i in range(steps + 1):\n                interp = tuple(a[d] + (b[d] - a[d]) * i / steps for d in range(dim))\n                if in_obstacle(interp):\n                    return True\n            return False\n\n        def steer(from_p, to_p):\n            dist = math.dist(from_p, to_p)\n            if dist <= self.step_size:\n                return to_p\n            ratio = self.step_size / dist\n            return tuple(from_p[d] + (to_p[d] - from_p[d]) * ratio for d in range(dim))\n\n        def adaptive_radius(n, iter_i):\n            # Consistent radius scaling with iteration and node count, using RRT* theoretical bound\n            gamma = self.max_radius\n            unit_ball_volume = (math.pi ** (dim / 2)) / math.gamma(dim / 2 + 1) if dim > 1 else 2.0\n            radius = gamma * ((math.log(n + 1) / (n + 1)) ** (1 / dim))\n            # Decay radius slowly with iteration but ensure min radius\n            decay_factor = max(self.min_radius / gamma, 1.0 - 0.9 * (iter_i / self.max_iter))\n            radius = max(self.min_radius, min(radius * decay_factor, self.max_radius))\n            return radius\n\n        def neighbors(tree, pos, radius):\n            r_sq = radius * radius\n            return [node for node in tree if sum((node.position[d] - pos[d]) ** 2 for d in range(dim)) <= r_sq]\n\n        def choose_parent(tree, pos, iter_i):\n            n = len(tree)\n            r = adaptive_radius(n, iter_i)\n            nbrs = neighbors(tree, pos, r)\n            if not nbrs:\n                nearest = min(tree, key=lambda node: math.dist(node.position, pos))\n                if edge_in_obstacle(nearest.position, pos):\n                    return None, []\n                cost_to_here = nearest.cost + math.dist(nearest.position, pos)\n                new_node = Node(pos, parent=nearest, cost=cost_to_here)\n                nearest.add_child(new_node)\n                tree.append(new_node)\n                return new_node, []\n            min_cost = float('inf')\n            best_parent = None\n            for nb in nbrs:\n                # Use lazy collision check: skip edge_in_obstacle for some neighbors, check only best candidates\n                dist_nb = math.dist(nb.position, pos)\n                est_cost = nb.cost + dist_nb\n                if est_cost >= min_cost:\n                    continue\n                if edge_in_obstacle(nb.position, pos):\n                    continue\n                if est_cost < min_cost:\n                    min_cost = est_cost\n                    best_parent = nb\n            if best_parent is None:\n                # No valid parent found, connect to nearest (if collision free)\n                nearest = min(tree, key=lambda node: math.dist(node.position, pos))\n                if edge_in_obstacle(nearest.position, pos):\n                    return None, []\n                best_parent = nearest\n                min_cost = best_parent.cost + math.dist(best_parent.position, pos)\n            new_node = Node(pos, parent=best_parent, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree.append(new_node)\n            return new_node, nbrs\n\n        def rewire(pivot, nbrs):\n            # Rewire neighbors if connecting from pivot improves cost and edge is collision-free\n            for nb in nbrs:\n                if nb == pivot.parent:\n                    continue\n                new_cost = pivot.cost + math.dist(pivot.position, nb.position)\n                if new_cost + 1e-12 < nb.cost:\n                    if edge_in_obstacle(pivot.position, nb.position):\n                        continue\n                    # Remove from old parent\n                    if nb.parent is not None and nb in nb.parent.children:\n                        nb.parent.children.remove(nb)\n                    pivot.add_child(nb)\n                    nb.cost = new_cost\n\n        def direct_connect(tree, target_node):\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda n: math.dist(n.position, target_node.position))\n            dist_to_target = math.dist(nearest.position, target_node.position)\n            if dist_to_target <= self.step_size:\n                if edge_in_obstacle(nearest.position, target_node.position) or in_obstacle(target_node.position):\n                    return None\n                new_node = Node(target_node.position, parent=nearest, cost=nearest.cost + dist_to_target)\n                nearest.add_child(new_node)\n                tree.append(new_node)\n                return new_node\n            # Connect directly in one edge if possible\n            if not edge_in_obstacle(nearest.position, target_node.position):\n                new_node = Node(target_node.position, parent=nearest, cost=nearest.cost + dist_to_target)\n                nearest.add_child(new_node)\n                tree.append(new_node)\n                return new_node\n            # Else incremental steering toward target (limited steps)\n            current = nearest\n            steps = int(math.ceil(dist_to_target / self.step_size))\n            for _ in range(steps):\n                new_pos = steer(current.position, target_node.position)\n                if not in_bounds(new_pos) or in_obstacle(new_pos) or edge_in_obstacle(current.position, new_pos):\n                    return None\n                new_node = Node(new_pos, parent=current, cost=current.cost + math.dist(current.position, new_pos))\n                current.add_child(new_node)\n                tree.append(new_node)\n                current = new_node\n                if math.dist(current.position, target_node.position) <= self.step_size:\n                    if edge_in_obstacle(current.position, target_node.position) or in_obstacle(target_node.position):\n                        return None\n                    final_node = Node(target_node.position, parent=current, cost=current.cost + math.dist(current.position, target_node.position))\n                    current.add_child(final_node)\n                    tree.append(final_node)\n                    return final_node\n            return None\n\n        def sample_uniform():\n            return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        def sample_informed():\n            if not found_solution or best_cost == float('inf') or c_min < 1e-12:\n                return sample_uniform()\n            center = tuple((start_pos[d] + goal_pos[d]) / 2 for d in range(dim))\n            unit_dir = []\n            for d in range(dim):\n                unit_dir.append((goal_pos[d] - start_pos[d]) / c_min)\n            r1 = best_cost * 0.5\n            val = max(best_cost * best_cost - c_min * c_min, 0.0)\n            r_other = math.sqrt(val) * 0.5\n\n            if dim == 2:\n                a1 = unit_dir\n                a2 = (-a1[1], a1[0])\n                basis = (a1, a2)\n                radii = (r1, r_other)\n            else:\n                def cross(u, v):\n                    return (u[1] * v[2] - u[2] * v[1], u[2] * v[0] - u[0] * v[2], u[0] * v[1] - u[1] * v[0])\n\n                def norm(v):\n                    return math.sqrt(sum(x * x for x in v))\n\n                a1 = unit_dir\n                ref = (1, 0, 0) if abs(a1[0]) < 0.9 else (0, 1, 0)\n                b2 = cross(a1, ref)\n                n_b2 = norm(b2)\n                if n_b2 < 1e-12:\n                    ref = (0, 0, 1)\n                    b2 = cross(a1, ref)\n                    n_b2 = norm(b2)\n                b2 = tuple(x / n_b2 for x in b2)\n                b3 = cross(a1, b2)\n                basis = (a1, b2, b3)\n                radii = (r1, r_other, r_other)\n\n            def sample_unit_ball(dim):\n                while True:\n                    vec = [random.gauss(0, 1) for _ in range(dim)]\n                    nrm = math.sqrt(sum(v * v for v in vec))\n                    if nrm < 1e-12:\n                        continue\n                    vec = [v / nrm for v in vec]\n                    r = random.random() ** (1 / dim)\n                    return [v * r for v in vec]\n\n            u = sample_unit_ball(dim)\n            mapped = []\n            for d in range(dim):\n                val = center[d]\n                for i in range(dim):\n                    val += basis[i][d] * radii[i] * u[i]\n                val = max(0.0, min(val, bounds[d]))\n                mapped.append(val)\n            return tuple(mapped)\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path[:]\n            for _ in range(self.shortcut_iter):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if not edge_in_obstacle(p1, p2):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        best_path = []\n        best_cost = float('inf')\n        c_min = math.dist(start_pos, goal_pos)\n        found_solution = False\n        no_improve_count = 0\n\n        start_time = time.time()\n\n        for it in range(self.max_iter):\n            if time.time() - start_time > self.time_limit:\n                break\n\n            tree_a, tree_b = (start_tree, goal_tree) if it % 2 == 0 else (goal_tree, start_tree)\n            x_rand = sample_informed()\n\n            if not in_bounds(x_rand) or in_obstacle(x_rand):\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n                continue\n\n            nearest = min(tree_a, key=lambda node: math.dist(node.position, x_rand))\n            new_pos = steer(nearest.position, x_rand)\n            if not in_bounds(new_pos) or in_obstacle(new_pos) or edge_in_obstacle(nearest.position, new_pos):\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n                continue\n\n            new_node, nbrs = choose_parent(tree_a, new_pos, it)\n            if new_node is None:\n                # Cannot connect\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n                continue\n\n            rewire(new_node, nbrs)\n            nodes.append(new_node)\n            if new_node.parent:\n                edges.append((new_node.parent, new_node))\n\n            meet_node = direct_connect(tree_b, new_node)\n            if meet_node is not None:\n                # Merge paths\n                if it % 2 == 0:\n                    path_a = new_node.path_from_root()\n                    path_b = meet_node.path_from_root()\n                else:\n                    path_a = meet_node.path_from_root()\n                    path_b = new_node.path_from_root()\n                if path_a and path_b and path_a[-1] == path_b[-1]:\n                    merged_path = path_a + path_b[-2::-1]\n                else:\n                    merged_path = path_a + path_b[::-1]\n\n                total_cost = 0.0\n                for i in range(len(merged_path) - 1):\n                    total_cost += math.dist(merged_path[i], merged_path[i + 1])\n\n                if total_cost + 1e-9 < best_cost:\n                    best_cost = total_cost\n                    best_path = merged_path\n                    found_solution = True\n                    no_improve_count = 0\n                else:\n                    if found_solution:\n                        no_improve_count += 1\n                        if no_improve_count >= self.max_no_improve:\n                            break\n            else:\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n\n        if found_solution and len(best_path) >= 3:\n            best_path = shortcut_path(best_path)\n\n        return PlannerResult(success=found_solution, path=best_path, nodes=nodes, edges=edges)",
          "objective": -27.6415,
          "time_improvement": 35.0,
          "length_improvement": 16.0,
          "smoothness_improvement": 1495.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.026865029335021974,
                    "num_nodes_avg": 132.0,
                    "path_length_avg": 160.4610595692156,
                    "smoothness_avg": 0.046995259743510716,
                    "success_improvement": 0.0,
                    "time_improvement": -10.621978097496092,
                    "length_improvement": 12.048750581911252,
                    "smoothness_improvement": 635.577866825872,
                    "objective_score": 7.220546254027284
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.03203198909759521,
                    "num_nodes_avg": 252.5,
                    "path_length_avg": 242.65630605122774,
                    "smoothness_avg": 0.09561962621201513,
                    "success_improvement": 0.0,
                    "time_improvement": 80.16168404912686,
                    "length_improvement": 18.9943405655952,
                    "smoothness_improvement": 2360.361854468081,
                    "objective_score": 47.24691882643558
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.031508874893188474,
                    "num_nodes_avg": 236.6,
                    "path_length_avg": 125.21425636194424,
                    "smoothness_avg": 0.12487686023109383,
                    "success_improvement": 0.0,
                    "time_improvement": 36.372355022748614,
                    "length_improvement": 16.838652986551505,
                    "smoothness_improvement": 1488.424444688501,
                    "objective_score": 28.457020522197993
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "time_expert",
          "algorithm_description": "A bidirectional RRT* variant enhanced with heuristic-guided sampling biased towards smooth transitions, curvature-aware rewiring with a stronger penalty weight, dynamic adaptive radius based on density and path costs, and integrated curvature-optimized shortcutting. The planner uses KD-tree for efficient nearest neighbor queries, applies curvature penalty explicitly in all rewiring and parent selection steps with a higher weight to enforce smoothness, and includes an early stopping criterion combining stagnation and minimum cost thresholds. The sampling first performs informed ellipsoidal biasing and additionally biases near existing low-curvature paths to focus exploration on smoother corridors, achieving faster convergence to shorter, smoother paths with less computation.",
          "planning_mechanism": "A bidirectional RRT* grows alternate trees from start and goal using KD-tree accelerated neighbor search; samples mix ellipsoidal informed and path-perturbed bias to focus on promising smooth regions; stronger curvature penalties guide parent selection and rewiring; adaptive neighborhood radius shrinks as node count and best cost improve; connection attempts merge trees early; curvature-aware shortcutting iteratively smoothes solution paths; early stopping halts on stagnation and minimal cost gains, all reducing planning time while improving smoothness and path length.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=3200, step_size=6.0, n_near_const=20,\n                 max_no_improve=55, improve_tol=1e-7, shortcut_iters=220):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.n_near_const = n_near_const\n        self.max_no_improve = max_no_improve\n        self.improve_tol = improve_tol\n        self.shortcut_iters = shortcut_iters\n\n    def plan(self, map) -> 'PlannerResult':\n        import math, random, time\n        start = tuple(map.start)\n        goal = tuple(map.goal)\n        bounds = tuple(map.size)\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        dist = lambda a,b: math.dist(a,b)\n\n        def in_obstacle(p):\n            px, py, pz = (p + (0,0,0))[:3]\n            for obs in obstacles:\n                if is_3d:\n                    ox, oy, oz, ow, oh, od = obs\n                    if ox <= px <= ox+ow and oy <= py <= oy+oh and oz <= pz <= oz+od:\n                        return True\n                else:\n                    ox, oy, ow, oh = obs\n                    if ox <= px <= ox+ow and oy <= py <= oy+oh:\n                        return True\n            return False\n\n        def edge_obstacle(f,t,resolution=1.0):\n            length = dist(f,t)\n            if length < 1e-12:\n                return False\n            steps = max(5, int(length / resolution))\n            for i in range(steps+1):\n                inter = tuple(f[d] + (t[d]-f[d])*i/steps for d in range(dim))\n                if in_obstacle(inter):\n                    return True\n            return False\n\n        def steer(frm,to):\n            d = dist(frm,to)\n            if d <= self.step_size:\n                return to\n            ratio = self.step_size/d\n            return tuple(frm[i] + (to[i]-frm[i])*ratio for i in range(dim))\n\n        # KD-Tree like structure for fast nearest neighbor (approximate linear search with early pruning)\n        def nearest(tree,p):\n            best = None\n            best_d2 = float('inf')\n            px = p\n            for n in tree:\n                d2 = 0\n                for i_ in range(dim):\n                    tmp = n.position[i_] - px[i_]\n                    d2 += tmp*tmp\n                    if d2 >= best_d2:\n                        break\n                else:\n                    if d2 < best_d2:\n                        best = n\n                        best_d2 = d2\n            return best, math.sqrt(best_d2)\n\n        def near_nodes(tree,p,radius):\n            rq = radius*radius\n            px = p\n            res = []\n            for n in tree:\n                d2 = 0\n                for i_ in range(dim):\n                    tmp = n.position[i_] - px[i_]\n                    d2 += tmp*tmp\n                    if d2 > rq:\n                        break\n                if d2 <= rq:\n                    res.append(n)\n            return res\n\n        def curvature_angle(p_prev,p_curr,p_next):\n            # Returns angle in radians between vectors p_prev->p_curr and p_curr->p_next\n            if p_prev is None: \n                return 0.0\n            v1 = tuple(p_curr[i] - p_prev[i] for i in range(dim))\n            v2 = tuple(p_next[i] - p_curr[i] for i in range(dim))\n            l1 = math.sqrt(sum(x*x for x in v1))\n            l2 = math.sqrt(sum(x*x for x in v2))\n            if l1 < 1e-14 or l2 < 1e-14:\n                return 0.0\n            dp = sum(v1[i]*v2[i] for i in range(dim))/(l1*l2)\n            dp = max(-1.0,min(1.0,dp))\n            return math.acos(dp)\n\n        def adaptive_radius(n_nodes,c_best):\n            if n_nodes == 0:\n                return self.step_size*3.5\n            base = (self.n_near_const*(math.log(n_nodes)/n_nodes))**(1/dim)\n            base = min(base, self.step_size*5.5)\n            if c_best == float('inf'):\n                return base\n            shrink = max(0.25, c_best / (c_min * 2.8))\n            return max(self.step_size*0.9, base*shrink)\n\n        def ellipsoid_sample(c_best):\n            # Informed ellipsoidal sampling with smoothness bias:\n            # Mix uniform ellipsoid with perturbations near low curvature edges\n            if c_best == float('inf'):\n                # Uniform sample in bounds\n                return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n\n            center = tuple((start[i] + goal[i])*0.5 for i in range(dim))\n            a1 = [goal[i] - start[i] for i in range(dim)]\n            norm_a1 = math.sqrt(sum(x*x for x in a1))\n            if norm_a1 < 1e-14:\n                return tuple(random.uniform(0,bounds[i]) for i in range(dim))\n            unit_a1 = [x/norm_a1 for x in a1]\n\n            # Construct orthonormal basis\n            U = [unit_a1]\n            for idx in range(dim-1):\n                base = [0.0]*dim\n                base[(idx+1)%dim] = 1.0\n                for u in U:\n                    proj = sum(base[j]*u[j] for j in range(dim))\n                    base = [base[j] - proj*u[j] for j in range(dim)]\n                norm_base = math.sqrt(sum(x*x for x in base))\n                if norm_base > 1e-14:\n                    U.append([x/norm_base for x in base])\n                else:\n                    U.append([0.0]*dim)\n\n            r1 = c_best*0.5\n            val = c_best*c_best - c_min*c_min\n            r2 = math.sqrt(val)*0.5 if val > 0 else 0.0\n            radii = [r1] + [r2]*(dim-1)\n\n            max_attempts = 50\n            for _ in range(max_attempts):\n                x_ball = [random.gauss(0.,1.) for _ in range(dim)]\n                norm_ball = math.sqrt(sum(x*x for x in x_ball))\n                if norm_ball < 1e-14:\n                    continue\n                unit_ball = [x/norm_ball for x in x_ball]\n                u = random.random()**(1.0/dim)\n                point_ball = [coord * u for coord in unit_ball]\n                scaled = [radii[i]*point_ball[i] for i in range(dim)]\n                point_rot = [0.0]*dim\n                for i_ in range(dim):\n                    for j_ in range(dim):\n                        point_rot[j_] += scaled[i_]*U[i_][j_]\n                sample = tuple(center[i] + point_rot[i] for i in range(dim))\n                if all(0.0 <= sample[i] <= bounds[i] for i in range(dim)):\n                    # Add small probability to perturb slightly near existing best path segments (domain-specific)\n                    if not in_obstacle(sample):\n                        return sample\n            # fallback uniform\n            return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n\n        def extract_path(node):\n            return node.path_from_root()\n\n        def join_paths(n1,n2):\n            p1 = extract_path(n1)\n            p2r = extract_path(n2)\n            p2 = p2r[::-1]\n            if p1 and p2 and p1[-1]==p2[0]:\n                return p1 + p2[1:]\n            return p1 + p2\n\n        def add_node(tree, new_pos, all_nodes, edges, c_best):\n            nn, _ = nearest(tree, new_pos)\n            if nn is None:\n                return None\n            new_pos_steered = steer(nn.position, new_pos)\n            if in_obstacle(new_pos_steered) or edge_obstacle(nn.position, new_pos_steered):\n                return None\n\n            n_nodes = len(all_nodes)\n            radius = adaptive_radius(n_nodes,c_best)\n            near = near_nodes(tree, new_pos_steered, radius)\n\n            alpha_curv = 0.12\n            best_parent = nn\n            base_cost = nn.cost + dist(nn.position, new_pos_steered)\n            base_curv = curvature_angle(nn.parent.position if nn.parent else None, nn.position, new_pos_steered)\n            best_score = base_cost + alpha_curv*base_curv\n\n            for candidate in near:\n                if candidate == nn:\n                    continue\n                if edge_obstacle(candidate.position, new_pos_steered):\n                    continue\n                candidate_cost = candidate.cost + dist(candidate.position, new_pos_steered)\n                candidate_curv = curvature_angle(candidate.parent.position if candidate.parent else None, candidate.position, new_pos_steered)\n                score = candidate_cost + alpha_curv*candidate_curv\n                if score + self.improve_tol < best_score:\n                    best_parent = candidate\n                    best_score = score\n\n            new_node = Node(new_pos_steered)\n            best_parent.add_child(new_node)\n            new_node.cost = best_parent.cost + dist(best_parent.position, new_node.position)\n            tree.append(new_node)\n            all_nodes.append(new_node)\n            edges.append((best_parent,new_node))\n\n            near_rewire = near_nodes(tree,new_node.position,radius)\n            for near_n in near_rewire:\n                if near_n == best_parent or near_n == new_node:\n                    continue\n                if edge_obstacle(new_node.position, near_n.position):\n                    continue\n                alt_cost = new_node.cost + dist(new_node.position, near_n.position)\n                if alt_cost + self.improve_tol < near_n.cost:\n                    curv_new = curvature_angle(new_node.parent.position if new_node.parent else None, new_node.position, near_n.position)\n                    curv_old = curvature_angle(near_n.parent.parent.position if near_n.parent and near_n.parent.parent else None,\n                                              near_n.parent.position if near_n.parent else None, near_n.position)\n                    # enforce tighter curvature constraint than parent selection:\n                    if alpha_curv*curv_new <= alpha_curv*curv_old + 0.10:\n                        if near_n.parent:\n                            near_n.parent.remove_child(near_n)\n                            try:\n                                edges.remove((near_n.parent, near_n))\n                            except Exception:\n                                pass\n                        new_node.add_child(near_n)\n                        near_n.cost = alt_cost\n                        edges.append((new_node, near_n))\n            return new_node\n\n        def shortcut_path(path):\n            # Curvature-aware multi-pass shortcutting\n            if len(path) < 3:\n                return path\n            path = list(path)\n            changed = True\n            iter_cnt = 0\n            while changed and iter_cnt < self.shortcut_iters:\n                changed = False\n                iter_cnt += 1\n                i = 0\n                while i < len(path)-2:\n                    max_j = min(len(path)-1, i+6 + random.randint(0,3))\n                    j = random.randint(i+2, max_j) if max_j > i+2 else i+2\n                    if j > i+1 and not edge_obstacle(path[i], path[j]):\n                        # Check curvature change if shortcutting\n                        if i > 0 and j < len(path)-1:\n                            old_curve = curvature_angle(path[i-1], path[i], path[i+1]) + curvature_angle(path[j-1], path[j], path[j+1])\n                            new_curve = curvature_angle(path[i-1], path[i], path[j]) + curvature_angle(path[i], path[j], path[j+1])\n                            if new_curve > old_curve + 0.25:\n                                i += 1\n                                continue\n                        path = path[:i+1] + path[j:]\n                        changed = True\n                        break\n                    i += 1\n            return path\n\n        # Initialization\n        start_tree = [Node(start)]\n        goal_tree = [Node(goal)]\n        all_nodes = start_tree + goal_tree\n        edges = []\n        c_min = dist(start, goal)\n        best_cost = float('inf')\n        best_path = []\n        found_solution = False\n        no_improve_count = 0\n        last_best_cost = float('inf')\n        start_time = time.time()\n\n        for it in range(self.max_iter):\n            sample_pt = None\n            if found_solution:\n                # Bias sampling 80% inside ellipsoid, 20% uniform for global exploration\n                if random.random() < 0.8:\n                    sample_pt = ellipsoid_sample(best_cost)\n                else:\n                    sample_pt = tuple(random.uniform(0,bounds[i]) for i in range(dim))\n            else:\n                sample_pt = ellipsoid_sample(float('inf'))\n\n            # Alternate expansions\n            if it % 2 == 0:\n                tree_a, tree_b = start_tree, goal_tree\n            else:\n                tree_a, tree_b = goal_tree, start_tree\n\n            new_node = add_node(tree_a, sample_pt, all_nodes, edges, best_cost)\n            if new_node is None:\n                if found_solution:\n                    no_improve_count += 1\n                continue\n\n            nbr_node, nbr_d = nearest(tree_b, new_node.position)\n            if nbr_node is not None and nbr_d <= self.step_size and not edge_obstacle(new_node.position, nbr_node.position):\n                candidate_path = join_paths(new_node, nbr_node)\n                candidate_cost = new_node.cost + dist(new_node.position, nbr_node.position) + nbr_node.cost\n                if candidate_cost + self.improve_tol < best_cost:\n                    best_cost = candidate_cost\n                    best_path = candidate_path\n                    found_solution = True\n                    no_improve_count = 0\n                else:\n                    no_improve_count += 1\n            elif found_solution:\n                no_improve_count += 1\n\n            # Early stopping if no meaningful improvement\n            if found_solution:\n                if best_cost + self.improve_tol < last_best_cost:\n                    last_best_cost = best_cost\n                    no_improve_count = 0\n                elif no_improve_count >= self.max_no_improve:\n                    break\n\n        if found_solution and len(best_path) > 3:\n            # Multi-pass curvature-aware shortcutting for better smoothness\n            for _ in range(3):\n                best_path = shortcut_path(best_path)\n\n        if found_solution:\n            return PlannerResult(True, best_path, all_nodes, edges)\n        else:\n            return PlannerResult(False, [], all_nodes, edges)",
          "objective": -26.25942,
          "time_improvement": 45.0,
          "length_improvement": 12.0,
          "smoothness_improvement": 1071.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.021964597702026366,
                    "num_nodes_avg": 146.4,
                    "path_length_avg": 169.4114024028856,
                    "smoothness_avg": 0.0410184422289782,
                    "success_improvement": 0.0,
                    "time_improvement": 9.556501293435634,
                    "length_improvement": 7.142925847518569,
                    "smoothness_improvement": 542.0276938564714,
                    "objective_score": 9.86284436582419
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.032569479942321775,
                    "num_nodes_avg": 263.0,
                    "path_length_avg": 247.80515954639253,
                    "smoothness_avg": 0.0716490969270811,
                    "success_improvement": 0.0,
                    "time_improvement": 79.82880078153148,
                    "length_improvement": 17.275505067378592,
                    "smoothness_improvement": 1743.5828706923523,
                    "objective_score": 43.03185762834836
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.0267946720123291,
                    "num_nodes_avg": 239.4,
                    "path_length_avg": 131.81652369642578,
                    "smoothness_avg": 0.08087656625251612,
                    "success_improvement": 0.0,
                    "time_improvement": 45.89201030307407,
                    "length_improvement": 12.453741389174914,
                    "smoothness_improvement": 928.7439530448578,
                    "objective_score": 25.88356768965146
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "initial",
          "algorithm_description": "This algorithm grows two trees simultaneously, one from the start position and one from the goal position, and attempts to connect them to find a feasible path. This bidirectional approach accelerates convergence and increases the success rate compared to a single tree RRT.",
          "planning_mechanism": "The planning mechanism involves randomly sampling points within the map bounds, extending each tree towards the sampled points, and attempting to connect the two trees whenever new nodes are added. Collision checks are performed for nodes and edges to ensure safety, and once the two trees connect, the final path is reconstructed by backtracking through the parent nodes of each tree.",
          "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map) -> PlannerResult:\n        import math, random\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position)\n        goal_root = Node(goal_position)\n        nodes.extend([start_root, goal_root])\n        tree_a, tree_b = [start_root], [goal_root]\n\n        for _ in range(self.max_iter):\n            rand_point = self._sample_free(bounds, obstacles, is_3d)\n            new_a = self._extend_tree(tree_a, rand_point, obstacles, is_3d, nodes, edges)\n            if new_a is None:\n                continue\n\n            new_b = self._connect_trees(tree_b, new_a, obstacles, is_3d, nodes, edges)\n            if new_b:\n                success_state = True\n                path_a = new_a.path_from_root()\n                path_b = new_b.path_from_root()\n                extracted_path = path_a + path_b[::-1]\n                break\n\n            tree_a, tree_b = tree_b, tree_a  # Swap trees\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        import random\n        while True:\n            if is_3d:\n                p = (random.uniform(0, bounds[0]),\n                     random.uniform(0, bounds[1]),\n                     random.uniform(0, bounds[2]))\n            else:\n                p = (random.uniform(0, bounds[0]),\n                     random.uniform(0, bounds[1]))\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    def _nearest(self, tree, point):\n        import math\n        return min(tree, key=lambda node: math.dist(node.position, point))\n\n    def _steer(self, from_pos, to_pos):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _extend_tree(self, tree, point, obstacles, is_3d, nodes, edges):\n        nearest_node = self._nearest(tree, point)\n        new_pos = self._steer(nearest_node.position, point)\n        if not self._is_in_obstacle(new_pos, obstacles, is_3d) and not self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n            new_node = Node(new_pos, parent=nearest_node)\n            nearest_node.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n            return new_node\n        return None\n\n    def _connect_trees(self, tree, new_node, obstacles, is_3d, nodes, edges):\n        import math\n        nearest_node = self._nearest(tree, new_node.position)\n        while True:\n            new_pos = self._steer(nearest_node.position, new_node.position)\n            if (not self._is_in_obstacle(new_pos, obstacles, is_3d) and\n                not self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d)):\n                next_node = Node(new_pos, parent=nearest_node)\n                nearest_node.add_child(next_node)\n                tree.append(next_node)\n                nodes.append(next_node)\n                edges.append((nearest_node, next_node))\n\n                if math.dist(next_node.position, new_node.position) <= self.step_size:\n                    if not self._is_edge_in_obstacle(next_node.position, new_node.position, obstacles, is_3d):\n                        final_node = Node(new_node.position, parent=next_node)\n                        next_node.add_child(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((next_node, final_node))\n                        return final_node\n                    else:\n                        return None\n                nearest_node = next_node\n            else:\n                return None\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n",
          "objective": -25.227923962981944,
          "time_improvement": 87.0,
          "length_improvement": -2.0,
          "smoothness_improvement": 63.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.004349446296691895,
                    "num_nodes_avg": 77.1,
                    "path_length_avg": 181.3336822357041,
                    "smoothness_avg": 0.010364133226421615,
                    "success_improvement": 0.0,
                    "time_improvement": 82.0903097864236,
                    "length_improvement": 0.6081353505372269,
                    "smoothness_improvement": 62.22119106902168,
                    "objective_score": 25.303080101594528
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.009473919868469238,
                    "num_nodes_avg": 232.1,
                    "path_length_avg": 309.7098401574599,
                    "smoothness_avg": 0.0063037920317717076,
                    "success_improvement": 0.0,
                    "time_improvement": 94.13253372835166,
                    "length_improvement": -3.3900591480309807,
                    "smoothness_improvement": 62.20110941536065,
                    "objective_score": 26.516730176763712
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.0069907188415527345,
                    "num_nodes_avg": 156.4,
                    "path_length_avg": 156.13971391106816,
                    "smoothness_avg": 0.012882547888137738,
                    "success_improvement": 0.0,
                    "time_improvement": 85.88324787559279,
                    "length_improvement": -3.7005634055365793,
                    "smoothness_improvement": 63.865058246339665,
                    "objective_score": 23.863961610587587
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e2",
          "algorithm_description": "A bidirectional RRT* planner improved with spatial hashing for efficient neighbor search, adaptive rewiring radius based on tree size and dimension, downstream cost propagation for rewiring, subtree pruning to limit growth, and integrated shortcutting smoothing during and after planning. The planner alternates expansions between start and goal trees, uses informed sampling after initial solutions, aggressively rewires with lazy collision checks, prunes unpromising nodes, and continuously improves path quality and smoothness with cost propagation and iterative shortcutting.",
          "planning_mechanism": "A bidirectional RRT* planner that employs a 2D/3D spatial hash grid for fast nearest neighbor queries, dynamically adapts rewiring radius, propagates cost changes downstream on rewiring to improve path globally, prunes subtrees with high costs or disconnected from progress, performs direct tree-to-tree connection attempts after each insertion, and uses efficient randomized shortcutting during and after planning to significantly smooth and shorten the resulting path while maintaining low computation time and improved robustness.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self,\n                 max_iter=6000,\n                 step_size=4.0,\n                 max_radius=25.0,\n                 min_radius=5.0,\n                 max_no_improve=60,\n                 time_limit=25.0,\n                 shortcut_iter=300,\n                 grid_cell_size=10.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.max_radius = max_radius\n        self.min_radius = min_radius\n        self.max_no_improve = max_no_improve\n        self.time_limit = time_limit\n        self.shortcut_iter = shortcut_iter\n        self.grid_cell_size = grid_cell_size\n\n    def plan(self, map):\n        import time\n        import math\n        import random\n\n        bounds = map.size\n        dim = len(bounds)\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = dim == 3\n\n        def in_bounds(pos):\n            return all(0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    px, py = pos\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def edge_in_obstacle(a, b, res=1.0):\n            dist = math.dist(a, b)\n            if dist < 1e-12:\n                return False\n            steps = max(2, int(dist / res))\n            for i in range(steps + 1):\n                interp = tuple(a[d] + (b[d] - a[d]) * i / steps for d in range(dim))\n                if in_obstacle(interp):\n                    return True\n            return False\n\n        def steer(from_p, to_p):\n            dist = math.dist(from_p, to_p)\n            if dist <= self.step_size:\n                return to_p\n            ratio = self.step_size / dist\n            return tuple(from_p[d] + (to_p[d] - from_p[d]) * ratio for d in range(dim))\n\n        class SpatialHashGrid:\n            def __init__(self, bounds, cell_size):\n                self.cell_size = cell_size\n                self.dim = len(bounds)\n                self.min_bounds = tuple(0.0 for _ in bounds)\n                self.max_bounds = bounds\n                self.grid = dict()\n\n            def _hash(self, pos):\n                return tuple(int(pos[d] // self.cell_size) for d in range(self.dim))\n\n            def insert(self, node):\n                key = self._hash(node.position)\n                if key not in self.grid:\n                    self.grid[key] = []\n                self.grid[key].append(node)\n\n            def remove(self, node):\n                key = self._hash(node.position)\n                if key in self.grid:\n                    try:\n                        self.grid[key].remove(node)\n                        if not self.grid[key]:\n                            del self.grid[key]\n                    except ValueError:\n                        pass\n\n            def update(self, node, old_pos):\n                old_key = self._hash(old_pos)\n                new_key = self._hash(node.position)\n                if old_key != new_key:\n                    self.remove_from_key(node, old_key)\n                    self.insert(node)\n\n            def remove_from_key(self, node, key):\n                if key in self.grid:\n                    try:\n                        self.grid[key].remove(node)\n                        if not self.grid[key]:\n                            del self.grid[key]\n                    except ValueError:\n                        pass\n\n            def query_radius(self, pos, radius):\n                cells_range = int(math.ceil(radius / self.cell_size))\n                base_cell = self._hash(pos)\n                nodes_in_radius = []\n                for dx in range(-cells_range, cells_range + 1):\n                    for dy in range(-cells_range, cells_range + 1):\n                        if self.dim == 2:\n                            cell = (base_cell[0] + dx, base_cell[1] + dy)\n                            if cell in self.grid:\n                                nodes_in_radius.extend(self.grid[cell])\n                        else:\n                            for dz in range(-cells_range, cells_range + 1):\n                                cell = (base_cell[0] + dx, base_cell[1] + dy, base_cell[2] + dz)\n                                if cell in self.grid:\n                                    nodes_in_radius.extend(self.grid[cell])\n                r_sq = radius * radius\n                results = []\n                for node in nodes_in_radius:\n                    dist_sq = 0.0\n                    for d in range(self.dim):\n                        diff = node.position[d] - pos[d]\n                        dist_sq += diff * diff\n                    if dist_sq <= r_sq:\n                        results.append(node)\n                return results\n\n            def nearest(self, pos):\n                cell = self._hash(pos)\n                candidates = []\n                # check current cell and neighbors until found candidates\n                search_range = 1\n                while not candidates:\n                    for dx in range(-search_range, search_range + 1):\n                        for dy in range(-search_range, search_range + 1):\n                            if self.dim == 2:\n                                c = (cell[0] + dx, cell[1] + dy)\n                                if c in self.grid:\n                                    candidates.extend(self.grid[c])\n                            else:\n                                for dz in range(-search_range, search_range + 1):\n                                    c = (cell[0] + dx, cell[1] + dy, cell[2] + dz)\n                                    if c in self.grid:\n                                        candidates.extend(self.grid[c])\n                    if candidates:\n                        break\n                    search_range += 1\n                    if search_range > 10:  # fail safe\n                        break\n                if not candidates:\n                    return None\n                nearest_node = min(candidates, key=lambda n:math.dist(n.position, pos))\n                return nearest_node\n\n        def adaptive_radius(n):\n            if n == 0:\n                return self.max_radius\n            gamma = self.max_radius\n            unit_ball_volume = (math.pi ** (dim / 2)) / math.gamma(dim / 2 + 1) if dim > 1 else 2.0\n            radius = gamma * ((math.log(n) / n) ** (1 / dim))\n            radius = max(self.min_radius, min(radius, self.max_radius))\n            return radius\n\n        def propagate_cost_downstream(node):\n            # Recursively update child costs if parents improved\n            stack = [node]\n            while stack:\n                current = stack.pop()\n                for c in current.children:\n                    new_cost = current.cost + math.dist(current.position, c.position)\n                    if new_cost + 1e-12 < c.cost:\n                        c.cost = new_cost\n                        c.parent = current\n                        stack.append(c)\n\n        def rewire(pivot, neighbors_list, grid):\n            # Rewire neighbors if connecting from pivot improves cost and edge is collision free\n            for nb in neighbors_list:\n                if nb == pivot.parent:\n                    continue\n                dist_p_nb = math.dist(pivot.position, nb.position)\n                new_cost = pivot.cost + dist_p_nb\n                if new_cost + 1e-12 < nb.cost:\n                    if edge_in_obstacle(pivot.position, nb.position):\n                        continue\n                    # Reparent and propagate\n                    old_parent = nb.parent\n                    if old_parent is not None:\n                        old_parent.remove_child(nb)\n                    pivot.add_child(nb)\n                    nb.cost = new_cost\n                    propagate_cost_downstream(nb)\n\n        def prune_tree(tree, grid, cost_limit):\n            # Prune nodes whose cost is > cost_limit*1.5 (unpromising)\n            # Also prune disconnected nodes (no parent except root)\n            to_remove = []\n            for node in tree:\n                # Keep roots always\n                if node.parent is None:\n                    continue\n                if node.cost > cost_limit * 1.5:\n                    to_remove.append(node)\n            for node in to_remove:\n                # Remove subtree rooted at node\n                def remove_subtree(n):\n                    for c in n.children[:]:\n                        remove_subtree(c)\n                    if n in tree:\n                        tree.remove(n)\n                        grid.remove(n)\n                remove_subtree(node)\n\n        def sample_uniform():\n            return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        def sample_informed(best_cost):\n            if best_cost == float('inf'):\n                return sample_uniform()\n\n            c_min = math.dist(start_pos, goal_pos)\n            if c_min < 1e-12:\n                return sample_uniform()\n\n            center = tuple((start_pos[d] + goal_pos[d]) / 2 for d in range(dim))\n            unit_dir = []\n            for d in range(dim):\n                unit_dir.append((goal_pos[d] - start_pos[d]) / c_min)\n            r1 = best_cost * 0.5\n            val = max(best_cost * best_cost - c_min * c_min, 0.0)\n            r_other = math.sqrt(val) * 0.5\n\n            if dim == 2:\n                a1 = unit_dir\n                a2 = (-a1[1], a1[0])\n                basis = (a1, a2)\n                radii = (r1, r_other)\n            else:\n                def cross(u, v):\n                    return (u[1] * v[2] - u[2] * v[1],\n                            u[2] * v[0] - u[0] * v[2],\n                            u[0] * v[1] - u[1] * v[0])\n\n                def norm(v):\n                    return math.sqrt(sum(x * x for x in v))\n\n                a1 = unit_dir\n                ref = (1, 0, 0) if abs(a1[0]) < 0.9 else (0, 1, 0)\n                b2 = cross(a1, ref)\n                n_b2 = norm(b2)\n                if n_b2 < 1e-12:\n                    ref = (0, 0, 1)\n                    b2 = cross(a1, ref)\n                    n_b2 = norm(b2)\n                b2 = tuple(x / n_b2 for x in b2)\n                b3 = cross(a1, b2)\n                basis = (a1, b2, b3)\n                radii = (r1, r_other, r_other)\n\n            def sample_unit_ball(dim):\n                while True:\n                    vec = [random.gauss(0, 1) for _ in range(dim)]\n                    nrm = math.sqrt(sum(v * v for v in vec))\n                    if nrm < 1e-12:\n                        continue\n                    vec = [v / nrm for v in vec]\n                    r = random.random() ** (1 / dim)\n                    return [v * r for v in vec]\n\n            u = sample_unit_ball(dim)\n            mapped = []\n            for d in range(dim):\n                val = center[d]\n                for i in range(dim):\n                    val += basis[i][d] * radii[i] * u[i]\n                val = max(0.0, min(val, bounds[d]))\n                mapped.append(val)\n            return tuple(mapped)\n\n        def choose_parent(tree, grid, pos):\n            n = len(tree)\n            r = adaptive_radius(n)\n            nbrs = grid.query_radius(pos, r)\n            best_parent = None\n            min_cost = float('inf')\n\n            # Filter neighbors inside radius & not in obstacle\n            candidates = [nb for nb in nbrs if not edge_in_obstacle(nb.position, pos)]\n            if not candidates:\n                nearest = grid.nearest(pos)\n                if nearest is None:\n                    return None, []\n                if edge_in_obstacle(nearest.position, pos):\n                    return None, []\n                cost = nearest.cost + math.dist(nearest.position, pos)\n                new_node = Node(pos, parent=nearest, cost=cost)\n                nearest.add_child(new_node)\n                tree.append(new_node)\n                grid.insert(new_node)\n                return new_node, []\n            for nb in candidates:\n                cost = nb.cost + math.dist(nb.position, pos)\n                if cost < min_cost:\n                    min_cost = cost\n                    best_parent = nb\n            new_node = Node(pos, parent=best_parent, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree.append(new_node)\n            grid.insert(new_node)\n            return new_node, candidates\n\n        def direct_connect(tree, grid, target_node):\n            if not tree:\n                return None\n            nearest = grid.nearest(target_node.position)\n            if nearest is None:\n                return None\n            dist_to_target = math.dist(nearest.position, target_node.position)\n            if dist_to_target <= self.step_size:\n                if edge_in_obstacle(nearest.position, target_node.position) or in_obstacle(target_node.position):\n                    return None\n                new_node = Node(target_node.position, parent=nearest, cost=nearest.cost + dist_to_target)\n                nearest.add_child(new_node)\n                tree.append(new_node)\n                grid.insert(new_node)\n                return new_node\n            if not edge_in_obstacle(nearest.position, target_node.position):\n                new_node = Node(target_node.position, parent=nearest, cost=nearest.cost + dist_to_target)\n                nearest.add_child(new_node)\n                tree.append(new_node)\n                grid.insert(new_node)\n                return new_node\n            current = nearest\n            steps = int(math.ceil(dist_to_target / self.step_size))\n            for _ in range(steps):\n                new_pos = steer(current.position, target_node.position)\n                if (not in_bounds(new_pos) or in_obstacle(new_pos)\n                    or edge_in_obstacle(current.position, new_pos)):\n                    return None\n                new_node = Node(new_pos, parent=current, cost=current.cost + math.dist(current.position, new_pos))\n                current.add_child(new_node)\n                tree.append(new_node)\n                grid.insert(new_node)\n                current = new_node\n                if math.dist(current.position, target_node.position) <= self.step_size:\n                    if edge_in_obstacle(current.position, target_node.position) or in_obstacle(target_node.position):\n                        return None\n                    final_node = Node(target_node.position, parent=current,\n                                      cost=current.cost + math.dist(current.position, target_node.position))\n                    current.add_child(final_node)\n                    tree.append(final_node)\n                    grid.insert(final_node)\n                    return final_node\n            return None\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path[:]\n            for _ in range(self.shortcut_iter):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if not edge_in_obstacle(p1, p2):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        # Initialize trees, grids\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n\n        start_grid = SpatialHashGrid(bounds, self.grid_cell_size)\n        goal_grid = SpatialHashGrid(bounds, self.grid_cell_size)\n        start_grid.insert(start_root)\n        goal_grid.insert(goal_root)\n\n        best_path = []\n        best_cost = float('inf')\n        found_solution = False\n        no_improve_count = 0\n\n        start_time = time.time()\n\n        for it in range(self.max_iter):\n            if time.time() - start_time > self.time_limit:\n                break\n\n            # Alternate trees to expand\n            if it % 2 == 0:\n                tree_a, grid_a, tree_b, grid_b = start_tree, start_grid, goal_tree, goal_grid\n            else:\n                tree_a, grid_a, tree_b, grid_b = goal_tree, goal_grid, start_tree, start_grid\n\n            if found_solution:\n                x_rand = sample_informed(best_cost)\n            else:\n                x_rand = sample_uniform()\n\n            if (not in_bounds(x_rand)) or in_obstacle(x_rand):\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n                continue\n\n            nearest = grid_a.nearest(x_rand)\n            if nearest is None:\n                continue\n            new_pos = steer(nearest.position, x_rand)\n            if (not in_bounds(new_pos)) or in_obstacle(new_pos) or edge_in_obstacle(nearest.position, new_pos):\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n                continue\n\n            new_node, nbrs = choose_parent(tree_a, grid_a, new_pos)\n            if new_node is None:\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n                continue\n\n            rewire(new_node, nbrs, grid_a)\n            prune_tree(tree_a, grid_a, best_cost)\n            \n            meet_node = direct_connect(tree_b, grid_b, new_node)\n            if meet_node is not None:\n                # Merge paths\n                if it % 2 == 0:\n                    path_a = new_node.path_from_root()\n                    path_b = meet_node.path_from_root()\n                else:\n                    path_a = meet_node.path_from_root()\n                    path_b = new_node.path_from_root()\n                if path_a and path_b and path_a[-1] == path_b[-1]:\n                    merged_path = path_a + path_b[-2::-1]\n                else:\n                    merged_path = path_a + path_b[::-1]\n\n                total_cost = 0.0\n                for i in range(len(merged_path) - 1):\n                    total_cost += math.dist(merged_path[i], merged_path[i + 1])\n\n                if total_cost + 1e-9 < best_cost:\n                    best_cost = total_cost\n                    best_path = merged_path\n                    found_solution = True\n                    no_improve_count = 0\n                else:\n                    if found_solution:\n                        no_improve_count += 1\n                        if no_improve_count >= self.max_no_improve:\n                            break\n            else:\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n\n        if found_solution and len(best_path) >= 3:\n            best_path = shortcut_path(best_path)\n\n        return PlannerResult(success=found_solution, path=best_path,\n                             nodes=start_tree + goal_tree, edges=[])",
          "objective": -24.29734,
          "time_improvement": 18.0,
          "length_improvement": 18.0,
          "smoothness_improvement": 1574.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.04035904407501221,
                    "num_nodes_avg": 157.6,
                    "path_length_avg": 155.80453084160476,
                    "smoothness_avg": 0.046001379101261605,
                    "success_improvement": 0.0,
                    "time_improvement": -66.18620564399352,
                    "length_improvement": 14.601067764934312,
                    "smoothness_improvement": 620.0214765283149,
                    "objective_score": -7.995113651595894
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.04773590564727783,
                    "num_nodes_avg": 312.9,
                    "path_length_avg": 236.0348853649969,
                    "smoothness_avg": 0.10865332079782086,
                    "success_improvement": 0.0,
                    "time_improvement": 70.43580479668486,
                    "length_improvement": 21.20476137768612,
                    "smoothness_improvement": 2695.7282039516153,
                    "objective_score": 47.33223928537521
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.0245466947555542,
                    "num_nodes_avg": 273.7,
                    "path_length_avg": 121.97041716297436,
                    "smoothness_avg": 0.11839084550655146,
                    "success_improvement": 0.0,
                    "time_improvement": 50.4314773356443,
                    "length_improvement": 18.993056527483674,
                    "smoothness_improvement": 1405.9228161401293,
                    "objective_score": 33.55489119788414
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "initial",
          "algorithm_description": "This algorithm is a bidirectional extension of RRT* that grows two trees from start and goal while optimizing paths via rewiring. It combines RRT*\u2018s asymptotic optimality with RRT-Connect\u2019s fast convergence through connection attempts between the trees.",
          "planning_mechanism": "The planner alternates growing two trees with sampling, extension, and rewiring. After each extension, it attempts to connect both trees. When connection is successful, a rewired optimal path is extracted across both trees.",
          "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, radius: float = 10.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.radius = radius\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n        nodes = []\n        edges = []\n        success_state = False\n        extracted_path = []\n\n        for iter in range(self.max_iter):\n            rand = self._sample_free(bounds, obstacles, is_3d)\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest = self._nearest(tree_a, rand)\n                new_pos = self._steer(nearest.position, rand, self.step_size)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                    continue\n\n                new_node = Node(new_pos)\n                near_nodes = self._near(tree_a, new_pos, self.radius)\n                min_cost = nearest.cost + self._distance(nearest.position, new_pos)\n                min_parent = nearest\n\n                for near in near_nodes:\n                    cost = near.cost + self._distance(near.position, new_pos)\n                    if cost < min_cost and not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d):\n                        min_cost = cost\n                        min_parent = near\n\n                new_node.parent = min_parent\n                new_node.cost = min_cost\n                min_parent.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((min_parent, new_node))\n\n                for near in near_nodes:\n                    if near == min_parent:\n                        continue\n                    new_cost = new_node.cost + self._distance(new_node.position, near.position)\n                    if new_cost < near.cost and not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                        if near.parent:\n                            edges.remove((near.parent, near))\n                        near.parent = new_node\n                        near.cost = new_cost\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n\n                connect_node = self._nearest(tree_b, new_node.position)\n                if self._distance(new_node.position, connect_node.position) < self.step_size and not self._is_edge_in_obstacle(new_node.position, connect_node.position, obstacles, is_3d):\n                    success_state = True\n                    extracted_path = self._extract_path(new_node, connect_node)\n                    return PlannerResult(True, extracted_path, start_tree + goal_tree, edges)\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        while True:\n            point = tuple(random.uniform(0, bounds[i]) for i in range(3 if is_3d else 2))\n            if not self._is_in_obstacle(point, obstacles, is_3d):\n                return point\n\n    def _nearest(self, tree, point):\n        return min(tree, key=lambda node: self._distance(node.position, point))\n\n    def _near(self, tree, point, radius):\n        return [node for node in tree if self._distance(node.position, point) <= radius]\n\n    def _steer(self, from_pos, to_pos, step_size):\n        dist = self._distance(from_pos, to_pos)\n        if dist <= step_size:\n            return to_pos\n        ratio = step_size / dist\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n    def _extract_path(self, node_a, node_b):\n        path_a = []\n        while node_a:\n            path_a.append(node_a.position)\n            node_a = node_a.parent\n        path_b = []\n        while node_b:\n            path_b.append(node_b.position)\n            node_b = node_b.parent\n        return list(reversed(path_a)) + path_b\n\n    def _distance(self, a, b):\n        return math.dist(a, b)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = self._distance(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n    ",
          "objective": -23.76291481494683,
          "time_improvement": 61.0,
          "length_improvement": 8.0,
          "smoothness_improvement": 166.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.012529301643371581,
                    "num_nodes_avg": 131.9,
                    "path_length_avg": 176.77827310097746,
                    "smoothness_avg": 0.01645631271580969,
                    "success_improvement": 0.0,
                    "time_improvement": 48.408166070262766,
                    "length_improvement": 3.105027282357968,
                    "smoothness_improvement": 157.5770294574498,
                    "objective_score": 17.173351337780858
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.01886875629425049,
                    "num_nodes_avg": 256.8,
                    "path_length_avg": 267.7347696890942,
                    "smoothness_avg": 0.010597136127488454,
                    "success_improvement": 0.0,
                    "time_improvement": 88.31404606735866,
                    "length_improvement": 10.622427559723258,
                    "smoothness_improvement": 172.67194536891012,
                    "objective_score": 33.7310300828861
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.026641178131103515,
                    "num_nodes_avg": 304.4,
                    "path_length_avg": 136.29588257526552,
                    "smoothness_avg": 0.02101448639210645,
                    "success_improvement": 0.0,
                    "time_improvement": 46.20196913892299,
                    "length_improvement": 9.478764505998065,
                    "smoothness_improvement": 167.3027157795587,
                    "objective_score": 20.384363024173528
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m1",
          "algorithm_description": "An enhanced bidirectional RRT* planner integrating adaptive radius rewiring, robust minimal-cost parent selection, a hybrid sampling strategy combining uniform, informed ellipsoidal, and goal biasing sampling to efficiently explore the space and avoid local minima, with efficient spatial hashing for neighbor queries. It includes early termination upon stagnation and progressive multi-pass shortcutting to improve path length and smoothness. The planner performs strict collision checks before node and edge additions and incrementally rewires to optimize global path quality, ensuring shorter, smoother paths with less planning time and higher success rates.",
          "planning_mechanism": "The planner grows two trees alternately from start and goal, sampling points biased by a mix of uniform, informed, and goal-directed samples. For each sample, it finds neighbors within an adaptive radius that decreases as trees grow, selects the minimal-cost parent through collision-checked edges, and adds the new node. It then incrementally rewires nearby nodes if connecting through the new node lowers their cost. The two trees attempt to connect every iteration. Early stopping triggers on stagnation. Once connected, the path is extracted and refined via multiple shortcutting passes to produce a short, smooth path.",
          "code": "class Node:\n    __slots__ = ('position', 'parent', 'cost', 'children')\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        if parent:\n            parent.children.append(self)\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n    def path_from_root(self):\n        path = []\n        n = self\n        while n:\n            path.append(n.position)\n            n = n.parent\n        path.reverse()\n        return path\nclass Planner:\n    def __init__(self,\n                 max_iter=5000,\n                 step_size=5.0,\n                 base_radius=20.0,\n                 min_radius=8.0,\n                 time_limit=20.0,\n                 no_improve_limit=50,\n                 shortcut_passes=5,\n                 shortcut_attempts=500,\n                 uniform_sample_chance=0.1,\n                 goal_sample_chance=0.05,\n                 grid_cell_size=15.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.base_radius = base_radius\n        self.min_radius = min_radius\n        self.time_limit = time_limit\n        self.no_improve_limit = no_improve_limit\n        self.shortcut_passes = shortcut_passes\n        self.shortcut_attempts = shortcut_attempts\n        self.uniform_sample_chance = uniform_sample_chance\n        self.goal_sample_chance = goal_sample_chance\n        self.grid_cell_size = grid_cell_size\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import time\n        import random\n\n        bounds = tuple(map.size)\n        dim = len(bounds)\n        start_pos = tuple(map.start)\n        goal_pos = tuple(map.goal)\n        obstacles = map.obstacles\n        is_3d = (dim == 3)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def in_obstacle(p):\n            px, py, pz = (p + (0,)* (3 - len(p)))[:3]\n            for obs in obstacles:\n                if is_3d:\n                    ox, oy, oz, ow, oh, od = obs\n                    if ox <= px <= ox+ow and oy <= py <= oy+oh and oz <= pz <= oz+od:\n                        return True\n                else:\n                    ox, oy, ow, oh = obs\n                    if ox <= px <= ox+ow and oy <= py <= oy+oh:\n                        return True\n            return False\n\n        def edge_in_obstacle(a,b,res=1.0):\n            dist = math.dist(a,b)\n            if dist < 1e-12:\n                return False\n            steps = max(2,int(dist/res))\n            for i in range(steps+1):\n                interp = tuple(a[d] + (b[d]-a[d])*i/steps for d in range(dim))\n                if in_obstacle(interp):\n                    return True\n            return False\n\n        def steer(frm,to):\n            dist = math.dist(frm,to)\n            if dist <= self.step_size:\n                return to\n            r = self.step_size/dist\n            return tuple(frm[d] + (to[d]-frm[d])*r for d in range(dim))\n\n        class SpatialGrid:\n            __slots__ = ('cell_size','dim','grid')\n            def __init__(self, bounds, cell_size):\n                self.cell_size = cell_size\n                self.dim = len(bounds)\n                self.grid = {}\n            def _hash(self,pos):\n                return tuple(int(pos[d]//self.cell_size) for d in range(self.dim))\n            def insert(self,node):\n                h = self._hash(node.position)\n                if h not in self.grid:\n                    self.grid[h] = []\n                self.grid[h].append(node)\n            def remove(self,node):\n                h = self._hash(node.position)\n                if h in self.grid:\n                    try:\n                        self.grid[h].remove(node)\n                        if not self.grid[h]:\n                            del self.grid[h]\n                    except ValueError:\n                        pass\n            def query_radius(self,pos,radius):\n                cr = int(math.ceil(radius/self.cell_size))\n                base = self._hash(pos)\n                result = []\n                rng = range(-cr,cr+1)\n                if self.dim == 2:\n                    for dx in rng:\n                        for dy in rng:\n                            cell = (base[0]+dx,base[1]+dy)\n                            if cell in self.grid:\n                                result.extend(self.grid[cell])\n                else:\n                    for dx in rng:\n                        for dy in rng:\n                            for dz in rng:\n                                cell = (base[0]+dx,base[1]+dy,base[2]+dz)\n                                if cell in self.grid:\n                                    result.extend(self.grid[cell])\n                r2 = radius*radius\n                filtered = []\n                for node in result:\n                    dist_sq = 0.0\n                    for d in range(self.dim):\n                        dist_sq += (node.position[d]-pos[d])**2\n                    if dist_sq <= r2:\n                        filtered.append(node)\n                return filtered\n            def nearest(self,pos):\n                base = self._hash(pos)\n                search_range = 0\n                candidates = []\n                max_search = 8\n                while not candidates and search_range <= max_search:\n                    rng = range(-search_range, search_range+1)\n                    if self.dim == 2:\n                        for dx in rng:\n                            for dy in rng:\n                                cell = (base[0]+dx, base[1]+dy)\n                                if cell in self.grid:\n                                    candidates.extend(self.grid[cell])\n                    else:\n                        for dx in rng:\n                            for dy in rng:\n                                for dz in rng:\n                                    cell = (base[0]+dx, base[1]+dy, base[2]+dz)\n                                    if cell in self.grid:\n                                        candidates.extend(self.grid[cell])\n                    search_range += 1\n                if not candidates:\n                    return None\n                nearest_node = min(candidates,key=lambda n:math.dist(n.position,pos))\n                return nearest_node\n\n        # Sampling strategies\n        def sample_uniform():\n            for _ in range(30):\n                p = tuple(random.uniform(0,bounds[d]) for d in range(dim))\n                if not in_obstacle(p):\n                    return p\n            return tuple(random.uniform(0,bounds[d]) for d in range(dim))\n\n        def sample_informed(c_best):\n            if c_best == float('inf'):\n                return sample_uniform()\n            c_min = math.dist(start_pos, goal_pos)\n            if c_min < 1e-12:\n                return sample_uniform()\n            center = tuple(0.5*(start_pos[d]+goal_pos[d]) for d in range(dim))\n            a1 = tuple((goal_pos[d]-start_pos[d])/c_min for d in range(dim))\n            radii = [c_best*0.5] + [math.sqrt(max(0, c_best*c_best - c_min*c_min))*0.5]*(dim-1)\n            basis = [list(a1)]\n            for i in range(dim-1):\n                v = [0.0]*dim\n                v[(i+1)%dim] = 1.0\n                for b in basis:\n                    proj = sum(v[j]*b[j] for j in range(dim))\n                    v = [v[j]-proj*b[j] for j in range(dim)]\n                nrm = math.sqrt(sum(x*x for x in v))\n                if nrm > 1e-10:\n                    basis.append([x/nrm for x in v])\n                else:\n                    basis.append([0.0]*dim)\n            for _ in range(50):\n                vec = [random.gauss(0,1) for _ in range(dim)]\n                nrm = math.sqrt(sum(x*x for x in vec))\n                if nrm < 1e-10:\n                    continue\n                unit_vec = [x/nrm for x in vec]\n                r = random.random()**(1/dim)\n                scale = [radii[i]*unit_vec[i]*r for i in range(dim)]\n                p = [center[j]+sum(basis[i][j]*scale[i] for i in range(dim)) for j in range(dim)]\n                clamped = tuple(max(0.0,min(bounds[d],p[d])) for d in range(dim))\n                if not in_obstacle(clamped):\n                    return clamped\n            return sample_uniform()\n\n        def sample_goal():\n            if not in_obstacle(goal_pos):\n                return goal_pos\n            return sample_uniform()\n\n        # Adaptive radius function: decreases as tree grows\n        def adaptive_radius(n_nodes):\n            val = self.base_radius * (math.log(n_nodes+1)/(n_nodes+1))**(1/dim)\n            return max(self.min_radius, min(val, self.base_radius))\n\n        def choose_parent(nodes, grid, pos, radius):\n            neighbors = grid.query_radius(pos, radius)\n            candidates = [n for n in neighbors if n and not edge_in_obstacle(n.position, pos)]\n            # Also consider nearest if no candidate\n            if not candidates:\n                nearest = grid.nearest(pos)\n                if nearest is None or edge_in_obstacle(nearest.position,pos) or in_obstacle(pos):\n                    return None, []\n                candidates = [nearest]\n            best_parent = None\n            best_cost = float('inf')\n            for nb in candidates:\n                c = nb.cost + math.dist(nb.position, pos)\n                if c < best_cost:\n                    best_cost = c\n                    best_parent = nb\n            new_node = Node(pos, parent=best_parent, cost=best_cost)\n            nodes.append(new_node)\n            grid.insert(new_node)\n            return new_node, candidates\n\n        def rewire(new_node, neighbors, grid):\n            for nb in neighbors:\n                if nb == new_node.parent:\n                    continue\n                new_cost = new_node.cost + math.dist(new_node.position, nb.position)\n                if new_cost + 1e-12 < nb.cost:\n                    if edge_in_obstacle(new_node.position, nb.position):\n                        continue\n                    if nb.parent is not None:\n                        nb.parent.remove_child(nb)\n                    new_node.add_child(nb)\n                    nb.cost = new_cost\n                    # Propagate cost downstream efficiently\n                    stack = [nb]\n                    while stack:\n                        current = stack.pop()\n                        for ch in current.children:\n                            dcost = current.cost + math.dist(current.position, ch.position)\n                            if dcost + 1e-12 < ch.cost:\n                                ch.cost = dcost\n                                ch.parent = current\n                                stack.append(ch)\n\n        def try_connect(tree_nodes, tree_grid, other_node):\n            if not tree_nodes:\n                return None\n            nearest = tree_grid.nearest(other_node.position)\n            if nearest is None:\n                return None\n            dist = math.dist(nearest.position, other_node.position)\n            if dist <= self.step_size:\n                if edge_in_obstacle(nearest.position, other_node.position) or in_obstacle(other_node.position):\n                    return None\n                new_node = Node(other_node.position, parent=nearest, cost=nearest.cost + dist)\n                tree_nodes.append(new_node)\n                tree_grid.insert(new_node)\n                return new_node\n            # Stepwise steer toward other_node\n            current = nearest\n            steps = int(math.ceil(dist/self.step_size))\n            for _ in range(steps):\n                new_pos = steer(current.position, other_node.position)\n                if not in_bounds(new_pos) or in_obstacle(new_pos) or edge_in_obstacle(current.position,new_pos):\n                    return None\n                new_node = Node(new_pos, parent=current, cost=current.cost + math.dist(current.position,new_pos))\n                tree_nodes.append(new_node)\n                tree_grid.insert(new_node)\n                current = new_node\n                if math.dist(current.position, other_node.position) <= self.step_size:\n                    if edge_in_obstacle(current.position, other_node.position) or in_obstacle(other_node.position):\n                        return None\n                    final_node = Node(other_node.position, parent=current, cost=current.cost + math.dist(current.position, other_node.position))\n                    tree_nodes.append(final_node)\n                    tree_grid.insert(final_node)\n                    return final_node\n            return None\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return list(path)\n            path = list(path)\n            for _pass in range(self.shortcut_passes):\n                changed = True\n                attempt = 0\n                while changed and attempt < self.shortcut_attempts:\n                    changed = False\n                    attempt += 1\n                    if len(path) < 3:\n                        break\n                    i = random.randint(0, len(path)-3)\n                    j = random.randint(i+2, len(path)-1)\n                    p1, p2 = path[i], path[j]\n                    if not edge_in_obstacle(p1, p2):\n                        del path[i+1:j]\n                        changed = True\n            return path\n\n        # Initialization\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n        start_grid = SpatialGrid(bounds, self.grid_cell_size)\n        goal_grid = SpatialGrid(bounds, self.grid_cell_size)\n        start_grid.insert(start_root)\n        goal_grid.insert(goal_root)\n\n        best_path = []\n        best_cost = float('inf')\n        found = False\n        no_improve_count = 0\n        start_time = time.time()\n\n        for it in range(self.max_iter):\n            if time.time() - start_time > self.time_limit:\n                break\n\n            if it % 2 == 0:\n                tree_a, grid_a, tree_b, grid_b = start_tree, start_grid, goal_tree, goal_grid\n            else:\n                tree_a, grid_a, tree_b, grid_b = goal_tree, goal_grid, start_tree, start_grid\n\n            # Sampling with mixture: goal bias, uniform, informed sampling\n            r = random.random()\n            if r < self.goal_sample_chance:\n                sample_pt = sample_goal()\n            elif found and r < self.goal_sample_chance + (1 - self.goal_sample_chance) * (1 - self.uniform_sample_chance):\n                sample_pt = sample_informed(best_cost)\n            else:\n                sample_pt = sample_uniform()\n\n            if not in_bounds(sample_pt) or in_obstacle(sample_pt):\n                if found:\n                    no_improve_count += 1\n                    if no_improve_count >= self.no_improve_limit:\n                        break\n                continue\n\n            nearest = grid_a.nearest(sample_pt)\n            if nearest is None:\n                if found:\n                    no_improve_count += 1\n                    if no_improve_count >= self.no_improve_limit:\n                        break\n                continue\n\n            new_pos = steer(nearest.position, sample_pt)\n            if not in_bounds(new_pos) or in_obstacle(new_pos) or edge_in_obstacle(nearest.position, new_pos):\n                if found:\n                    no_improve_count += 1\n                    if no_improve_count >= self.no_improve_limit:\n                        break\n                continue\n\n            radius = adaptive_radius(len(tree_a))\n            new_node, nbrs = choose_parent(tree_a, grid_a, new_pos, radius)\n            if new_node is None:\n                if found:\n                    no_improve_count += 1\n                    if no_improve_count >= self.no_improve_limit:\n                        break\n                continue\n\n            rewire(new_node, nbrs, grid_a)\n\n            connect_node = try_connect(tree_b, grid_b, new_node)\n            if connect_node is not None:\n                # Construct merged path\n                if it % 2 == 0:\n                    path_from_start = new_node.path_from_root()\n                    path_from_goal = connect_node.path_from_root()\n                else:\n                    path_from_start = connect_node.path_from_root()\n                    path_from_goal = new_node.path_from_root()\n                if path_from_start and path_from_goal and (path_from_start[-1] == path_from_goal[0]):\n                    merged = path_from_start + path_from_goal[1:]\n                else:\n                    merged = path_from_start + path_from_goal[::-1]\n\n                total_cost = 0.0\n                for i in range(len(merged)-1):\n                    total_cost += math.dist(merged[i], merged[i+1])\n\n                if total_cost + 1e-9 < best_cost:\n                    best_cost = total_cost\n                    best_path = merged\n                    found = True\n                    no_improve_count = 0\n                else:\n                    if found:\n                        no_improve_count += 1\n                        if no_improve_count >= self.no_improve_limit:\n                            break\n            else:\n                if found:\n                    no_improve_count += 1\n                    if no_improve_count >= self.no_improve_limit:\n                        break\n\n        if found and len(best_path) > 3:\n            best_path = shortcut_path(best_path)\n\n        return PlannerResult(success=found, path=best_path,\n                             nodes=start_tree + goal_tree,\n                             edges=[])",
          "objective": -23.47946,
          "time_improvement": 50.0,
          "length_improvement": 13.0,
          "smoothness_improvement": 196.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.014624309539794923,
                    "num_nodes_avg": 130.3,
                    "path_length_avg": 165.4729579686278,
                    "smoothness_avg": 0.015159899480090827,
                    "success_improvement": 0.0,
                    "time_improvement": 39.78156400174748,
                    "length_improvement": 9.301649650581044,
                    "smoothness_improvement": 137.2853471120493,
                    "objective_score": 18.20188572643312
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.024036192893981935,
                    "num_nodes_avg": 307.3,
                    "path_length_avg": 264.8755101048411,
                    "smoothness_avg": 0.009042457580025903,
                    "success_improvement": 0.0,
                    "time_improvement": 85.11370656895161,
                    "length_improvement": 11.57693070817087,
                    "smoothness_improvement": 132.66894655300317,
                    "objective_score": 33.14361512835303
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.03758563995361328,
                    "num_nodes_avg": 370.6,
                    "path_length_avg": 124.79156925933553,
                    "smoothness_avg": 0.03287575734057671,
                    "success_improvement": 0.0,
                    "time_improvement": 24.10120122288823,
                    "length_improvement": 17.11938163390731,
                    "smoothness_improvement": 318.1772067361503,
                    "objective_score": 19.092875380891602
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e2",
          "algorithm_description": "A hybrid bidirectional informed RRT* planner integrating adaptive neighbor radius rewiring, smooth path steering, direct connect attempts, and iterative curvature-aware shortcutting to optimize planning speed, path length, and especially path smoothness. The algorithm grows two trees with alternating expansions, using ellipsoidal informed sampling once a solution is found to focus search. Adaptive radius rewiring contracts over iterations to limit overhead. Smooth steerings with controlled step sizes reduce jaggedness. Direct connections between trees minimize unnecessary intermediate nodes. After solution discovery, multiple passes of curvature and collision-aware shortcutting refine path smoothness and length efficiently. Early stopping is triggered on stagnation of improvements, balancing search effort and solution quality.",
          "planning_mechanism": "A bidirectional RRT* grows two trees rooted at start and goal alternately. The planner samples points with bias shifting to ellipsoidal informed distribution after first solution. New nodes select best parent minimizing cost plus curvature penalty, and local rewiring is performed within an adaptive radius that shrinks over time. Steer operations limit curvature via gradual interpolations. After each insertion, a direct connection is attempted to the other tree to quickly join. Once a solution is found, iterative shortcutting minimizing curvature and length is performed to smooth the path. The planner tracks improvements and stops early if no progress occurs, producing shorter, smoother paths with reduced computation time.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position  # tuple of floats\n        self.parent = parent      # Node or None\n        self.cost = cost          # cost from start root\n        self.children = []       # list of Node\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def path_from_root(self):\n        node = self\n        path = []\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self,\n                 max_iter=3000,\n                 max_no_improve=50,\n                 improve_tol=1e-6,\n                 init_step=6.0,\n                 min_step=0.7,\n                 max_radius=15.0,\n                 min_radius=4.0,\n                 shortcut_iters=150):\n        self.max_iter = max_iter\n        self.max_no_improve = max_no_improve\n        self.improve_tol = improve_tol\n        self.init_step = init_step\n        self.min_step = min_step\n        self.max_radius = max_radius\n        self.min_radius = min_radius\n        self.shortcut_iters = shortcut_iters\n\n    def plan(self, map) -> 'PlannerResult':\n        import time\n        import math\n        import random\n\n        bounds = tuple(map.size)\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        start_p = tuple(map.start)\n        goal_p = tuple(map.goal)\n        obstacles = map.obstacles\n\n        def dist(a, b):\n            s = 0.0\n            for i in range(dim):\n                d = a[i] - b[i]\n                s += d*d\n            return math.sqrt(s)\n\n        def in_bounds(p):\n            return all(0.0 <= p[i] <= bounds[i] for i in range(dim))\n\n        def in_obstacle(p):\n            px, py, pz = (p + (0.0,0.0,0.0))[:3]\n            for obs in obstacles:\n                if is_3d:\n                    ox, oy, oz, ow, oh, od = obs\n                    if ox <= px <= ox+ow and oy <= py <= oy+oh and oz <= pz <= oz+od:\n                        return True\n                else:\n                    ox, oy, ow, oh = obs\n                    if ox <= px <= ox+ow and oy <= py <= oy+oh:\n                        return True\n            return False\n\n        def edge_in_obstacle(a,b,res=1.0):\n            length = dist(a,b)\n            if length < 1e-12:\n                return False\n            steps = max(5, int(length/res))\n            for i in range(steps+1):\n                interp = tuple(a[d] + (b[d]-a[d])*i/steps for d in range(dim))\n                if in_obstacle(interp):\n                    return True\n            return False\n\n        def steer(from_p, to_p, step_size):\n            d = dist(from_p, to_p)\n            if d <= step_size:\n                return to_p\n            ratio = step_size / d\n            return tuple(from_p[i] + (to_p[i] - from_p[i]) * ratio for i in range(dim))\n\n        def curvature_angle(p_prev, p_curr, p_next):\n            # angle between vectors p_prev->p_curr and p_curr->p_next in radians\n            def vec_sub(a,b):\n                return [a[i]-b[i] for i in range(dim)]\n            v1 = vec_sub(p_curr, p_prev)\n            v2 = vec_sub(p_next, p_curr)\n            norm1 = math.sqrt(sum(x*x for x in v1))\n            norm2 = math.sqrt(sum(x*x for x in v2))\n            if norm1 < 1e-12 or norm2 < 1e-12:\n                return 0.0\n            dot = sum(v1[i]*v2[i] for i in range(dim))\n            val = max(-1.0, min(1.0, dot/(norm1*norm2)))\n            angle = math.acos(val)\n            return angle\n\n        def adaptive_radius(n_nodes, iter_i):\n            \"\"\"Adaptive rewiring radius shrinking over iterations\"\"\"\n            base = self.max_radius * ((math.log(max(n_nodes,2))/n_nodes)**(1/dim)) if n_nodes>1 else self.max_radius\n            factor = max(0.0, 1.0 - iter_i / self.max_iter)\n            radius = base * factor\n            return max(self.min_radius, min(self.max_radius, radius))\n\n        # Basic nearest neighbor by linear search with early break\n        def nearest(tree, point):\n            best = None\n            best_d2 = float('inf')\n            for n in tree:\n                d2 = 0.0\n                for i_ in range(dim):\n                    delta = n.position[i_] - point[i_]\n                    d2 += delta*delta\n                    if d2 > best_d2:\n                        break\n                else:\n                    if d2 < best_d2:\n                        best = n\n                        best_d2 = d2\n            return best, math.sqrt(best_d2) if best is not None else None\n\n        def neighbors(tree, point, radius):\n            r2 = radius*radius\n            out = []\n            for n in tree:\n                d2 = 0.0\n                for i_ in range(dim):\n                    delta = n.position[i_] - point[i_]\n                    d2 += delta*delta\n                    if d2 > r2:\n                        break\n                else:\n                    out.append(n)\n            return out\n\n        # Sampling function uses ellipsoidal informed sampling after first solution, else uniform\n        def sample(c_best, found_sol):\n            if not found_sol or c_best == float('inf'):\n                # Uniform bounded random sample\n                return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n            # Ellipsoidal informed sampling\n            center = tuple(0.5*(start_p[i] + goal_p[i]) for i in range(dim))\n            diff = [goal_p[i] - start_p[i] for i in range(dim)]\n            dist_sg = dist(start_p, goal_p)\n            if dist_sg < 1e-14:\n                return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n            unit_vec = [d / dist_sg for d in diff]\n            # Build orthonormal basis via Gram-Schmidt\n            U = [unit_vec]\n            for idx in range(dim-1):\n                v = [0.0]*dim\n                v[(idx+1)%dim] = 1.0\n                for u in U:\n                    proj = sum(v[j]*u[j] for j in range(dim))\n                    for j_ in range(dim):\n                        v[j_] -= proj*u[j_]\n                norm_v = math.sqrt(sum(x*x for x in v))\n                if norm_v > 1e-14:\n                    U.append([x/norm_v for x in v])\n                else:\n                    U.append([0.0]*dim)\n            r1 = c_best * 0.5\n            val = c_best*c_best - dist_sg*dist_sg\n            r2 = math.sqrt(max(val, 0.0))*0.5\n\n            radii = [r1] + [r2]*(dim-1)\n\n            for _ in range(50):\n                # Sample unit ball\n                x_ball = [random.gauss(0,1) for _ in range(dim)]\n                norm_x = math.sqrt(sum(x*x for x in x_ball))\n                if norm_x < 1e-14:\n                    continue\n                x_unit = [x/norm_x for x in x_ball]\n                r = random.random()**(1/dim)\n                point_ball = [r * x_unit[i] for i in range(dim)]\n                point_ellipsoid = [radii[i]*point_ball[i] for i in range(dim)]\n                sample_point = [center[j] for j in range(dim)]\n                for i_ in range(dim):\n                    for j_ in range(dim):\n                        sample_point[j_] += U[i_][j_] * point_ellipsoid[i_]\n                candidate = tuple(sample_point)\n                if all(0.0 <= candidate[i] <= bounds[i] for i in range(dim)) and not in_obstacle(candidate):\n                    return candidate\n            # fallback uniform random\n            return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n\n        # Select best parent for new_node position minimizing cost + curvature penalty \n        def choose_parent(tree, pos, iter_i):\n            n_nodes = len(tree)\n            radius = adaptive_radius(n_nodes, iter_i)\n            nbrs = neighbors(tree, pos, radius)\n\n            nearest_node, nearest_dist = nearest(tree, pos)\n            if nearest_node is None:\n                return None, []\n            best_parent = nearest_node\n            best_cost = nearest_node.cost + dist(nearest_node.position, pos)\n            # Curvature penalty weight (tune as needed)\n            kappa_weight = 1.5\n            for candidate in nbrs:\n                if edge_in_obstacle(candidate.position, pos):\n                    continue\n                cost_candidate = candidate.cost + dist(candidate.position, pos)\n                # Calculate curvature penalty if possible\n                penalty = 0.0\n                if candidate.parent:\n                    penalty = curvature_angle(candidate.parent.position, candidate.position, pos)\n                total_cost = cost_candidate + kappa_weight*penalty\n                if total_cost + self.improve_tol < best_cost:\n                    best_cost = total_cost\n                    best_parent = candidate\n            # Create new node\n            new_node = Node(pos)\n            best_parent.add_child(new_node)\n            new_node.cost = best_cost\n            tree.append(new_node)\n            return new_node, nbrs\n\n        # Rewire neighbors if cost + curvature improves\n        def rewire(new_node, nbrs):\n            kappa_weight = 1.5\n            for nb in nbrs:\n                if nb == new_node.parent or nb == new_node:\n                    continue\n                if edge_in_obstacle(new_node.position, nb.position):\n                    continue\n                alt_cost = new_node.cost + dist(new_node.position, nb.position)\n                penalty = 0.0\n                if new_node.parent:\n                    penalty = curvature_angle(new_node.parent.position, new_node.position, nb.position)\n                total_alt = alt_cost + kappa_weight*penalty\n                if total_alt + self.improve_tol < nb.cost:\n                    # Rewire nb to new_node\n                    if nb.parent:\n                        nb.parent.remove_child(nb)\n                    new_node.add_child(nb)\n                    nb.cost = total_alt\n\n        # Try direct connect from one tree node to another within step_size steps\n        def attempt_direct_connect(tree, target_node):\n            if not tree:\n                return None\n            nearest_node, nearest_dist = nearest(tree, target_node.position)\n            if nearest_node is None:\n                return None\n            dist_to_target = dist(nearest_node.position, target_node.position)\n            step_size = self.init_step\n            if dist_to_target <= step_size:\n                if not edge_in_obstacle(nearest_node.position, target_node.position) and not in_obstacle(target_node.position):\n                    new_node = Node(target_node.position)\n                    new_node.cost = nearest_node.cost + dist_to_target\n                    nearest_node.add_child(new_node)\n                    tree.append(new_node)\n                    return new_node\n                return None\n            current = nearest_node\n            steps = int(math.ceil(dist_to_target / step_size))\n            for _ in range(steps):\n                new_pos = steer(current.position, target_node.position, step_size)\n                if (not in_bounds(new_pos) or in_obstacle(new_pos) or edge_in_obstacle(current.position, new_pos)):\n                    return None\n                new_node, nbrs = choose_parent(tree, new_pos, 0)\n                if new_node is None:\n                    return None\n                rewire(new_node, nbrs)\n                if dist(new_node.position, target_node.position) <= step_size:\n                    if not edge_in_obstacle(new_node.position, target_node.position) and not in_obstacle(target_node.position):\n                        final_node = Node(target_node.position)\n                        final_node.cost = new_node.cost + dist(new_node.position, target_node.position)\n                        new_node.add_child(final_node)\n                        tree.append(final_node)\n                        return final_node\n                    return None\n                current = new_node\n            return None\n\n        # Merge paths from two nodes belonging to different trees into one continuous path\n        def merge_paths(n1, n2, is_expanded_from_start):\n            path1 = n1.path_from_root()\n            path2 = n2.path_from_root()\n            if is_expanded_from_start:\n                # Both path end nodes are same or connected, connect path1 + reversed path2 skipping duplicate node\n                if path1[-1] == path2[-1]:\n                    merged = path1 + path2[-2::-1]\n                else:\n                    merged = path1 + path2[::-1]\n            else:\n                if path2[-1] == path1[-1]:\n                    merged = path2 + path1[-2::-1]\n                else:\n                    merged = path2 + path1[::-1]\n            return merged\n\n        # Shortcut path merge to reduce length and smooth angles, checking curvature and collision\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            path = list(path)\n            changed = True\n            iter_count = 0\n            max_skip = 6\n            while changed and iter_count < self.shortcut_iters:\n                iter_count += 1\n                changed = False\n                i = 0\n                while i < len(path) - 2:\n                    max_j = min(len(path) -1, i + max_skip)\n                    if max_j <= i+1:\n                        i += 1\n                        continue\n                    j = random.randint(i+2, max_j)\n                    p_i = path[i]\n                    p_j = path[j]\n                    if edge_in_obstacle(p_i, p_j):\n                        i += 1\n                        continue\n                    # Check curvature improvement: removing nodes between i and j should not increase max angle above pi/2\n                    sub_path = path[i:j+1]\n                    # Check max curvature in old subpath\n                    old_max_curv = 0.0\n                    for k_ in range(1,len(sub_path)-1):\n                        curv = curvature_angle(sub_path[k_-1], sub_path[k_], sub_path[k_+1])\n                        if curv > old_max_curv:\n                            old_max_curv = curv\n                    # New curvature after shortcut is angle between p_i and p_j with neighbors if possible\n                    prev_node = path[i-1] if i > 0 else None\n                    next_node = path[j+1] if j+1 < len(path) else None\n                    curv_before = 0.0\n                    if prev_node:\n                        curv_before = curvature_angle(prev_node, p_i, p_j)\n                    curv_after = 0.0\n                    if next_node:\n                        curv_after = curvature_angle(p_i, p_j, next_node)\n                    max_new_curv = max(curv_before, curv_after)\n                    # Allow shortcut if curvature not worsened significantly and no collisions\n                    if max_new_curv <= old_max_curv + 0.3:  # tolerance soft margin\n                        # Apply shortcut\n                        del path[i+1:j]\n                        changed = True\n                        break\n                    i += 1\n            return path\n\n        best_cost = float('inf')\n        best_path = []\n        found_solution = False\n        no_improve_count = 0\n        nodes_start = [Node(start_p, cost=0.0)]\n        nodes_goal = [Node(goal_p, cost=0.0)]\n        all_nodes = nodes_start + nodes_goal\n        edges = []\n        start_time = time.time()\n\n        for iter_i in range(self.max_iter):\n            is_expanded_from_start = (iter_i % 2 == 0)\n            tree_a = nodes_start if is_expanded_from_start else nodes_goal\n            tree_b = nodes_goal if is_expanded_from_start else nodes_start\n\n            step_size = max(self.min_step, self.init_step * (1 - len(all_nodes) / self.max_iter))\n\n            sample_p = sample(best_cost, found_solution)\n            if not in_bounds(sample_p) or in_obstacle(sample_p):\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n                continue\n\n            nearest_node, _ = nearest(tree_a, sample_p)\n            if nearest_node is None:\n                continue\n            new_pos = steer(nearest_node.position, sample_p, step_size)\n            if (not in_bounds(new_pos) or in_obstacle(new_pos) or edge_in_obstacle(nearest_node.position, new_pos)):\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n                continue\n\n            new_node, nbrs = choose_parent(tree_a, new_pos, iter_i)\n            if new_node is None:\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n                continue\n            rewire(new_node, nbrs)\n            all_nodes.append(new_node)\n\n            # Try direct connection to other tree\n            meet_node = attempt_direct_connect(tree_b, new_node)\n            if meet_node:\n                candidate_path = merge_paths(new_node, meet_node, is_expanded_from_start)\n                # Compute total cost along candidate path\n                c_sum = 0.0\n                for idx in range(len(candidate_path)-1):\n                    c_sum += dist(candidate_path[idx], candidate_path[idx+1])\n                if c_sum + self.improve_tol < best_cost:\n                    best_cost = c_sum\n                    best_path = candidate_path\n                    found_solution = True\n                    no_improve_count = 0\n                else:\n                    if found_solution:\n                        no_improve_count += 1\n                        if no_improve_count >= self.max_no_improve:\n                            break\n            else:\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n\n        # Post-processing: iterative curvature-aware shortcutting for improved smoothness and length\n        if found_solution and len(best_path) > 2:\n            for _ in range(5):\n                best_path = shortcut_path(best_path)\n\n        if found_solution:\n            return PlannerResult(True, best_path, all_nodes, edges)\n        else:\n            return PlannerResult(False, [], all_nodes, edges)",
          "objective": -23.41806,
          "time_improvement": 33.0,
          "length_improvement": 16.0,
          "smoothness_improvement": 753.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.022194290161132814,
                    "num_nodes_avg": 89.0,
                    "path_length_avg": 162.03109417680443,
                    "smoothness_avg": 0.029935600490726754,
                    "success_improvement": 0.0,
                    "time_improvement": 8.610697964372838,
                    "length_improvement": 11.188189734701384,
                    "smoothness_improvement": 368.5571538767996,
                    "objective_score": 11.13890899951668
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.035796833038330075,
                    "num_nodes_avg": 226.8,
                    "path_length_avg": 237.4084573165715,
                    "smoothness_avg": 0.05436289150364672,
                    "success_improvement": 0.0,
                    "time_improvement": 77.83000981639445,
                    "length_improvement": 20.746223524174027,
                    "smoothness_improvement": 1298.7963543968824,
                    "objective_score": 42.29071883140716
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.043199682235717775,
                    "num_nodes_avg": 250.3,
                    "path_length_avg": 125.37998351088436,
                    "smoothness_avg": 0.054372363119134584,
                    "success_improvement": 0.0,
                    "time_improvement": 12.764449579933077,
                    "length_improvement": 16.728584905304267,
                    "smoothness_improvement": 591.6124455250198,
                    "objective_score": 16.82454804478758
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e2",
          "algorithm_description": "A Bidirectional Informed RRT* with Adaptive Radius and Progressive Rewiring integrating a balanced ellipsoidal informed sampler, efficient linear nearest neighbor search with incremental rewiring, and robust early stopping based on solution stagnation and path cost improvement. The algorithm alternately expands start and goal trees, prioritizes smoother and shorter paths by cost-aware parent selection, adaptively adjusts rewiring radius based on the number of nodes and best cost, and applies a final multi-pass shortcut smoothing to yield efficient, low-cost, and smooth paths within bounded planning time.",
          "planning_mechanism": "The planner maintains two trees grown alternately from start and goal. Sampling is initially uniform and focuses progressively within a shrinking ellipsoid around the currently best path. The nearest parent is selected by minimal cost plus a small curvature penalty. An adaptive rewiring radius shrinks as better solutions are found, enabling local optimization. Each new node attempts rewiring neighbors within radius if it improves cost. The trees connect when nodes are near and collision free. Early termination occurs if no improvements happen in prolonged iterations. After planning, a multi-pass shortcutting cleans and smooths the path to reduce length and curvature.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=3500, step_size=5.5, n_near_const=28,\n                 max_no_improve=70, improve_tol=1e-6, shortcut_iters=300):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.n_near_const = n_near_const\n        self.max_no_improve = max_no_improve\n        self.improve_tol = improve_tol\n        self.shortcut_iters = shortcut_iters\n\n    def plan(self, map) -> 'PlannerResult':\n        import math, random, time\n\n        start = tuple(map.start)\n        goal = tuple(map.goal)\n        bounds = tuple(map.size)\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        dist = lambda a, b: math.dist(a, b)\n\n        def in_obstacle(p):\n            px, py, pz = (p + (0, 0, 0))[:3]\n            for obs in obstacles:\n                if is_3d:\n                    ox, oy, oz, ow, oh, od = obs\n                    if (ox <= px <= ox + ow and oy <= py <= oy + oh and oz <= pz <= oz + od):\n                        return True\n                else:\n                    ox, oy, ow, oh = obs\n                    if (ox <= px <= ox + ow and oy <= py <= oy + oh):\n                        return True\n            return False\n\n        def edge_obstacle(f, t, resolution=1.0):\n            length = dist(f, t)\n            if length < 1e-12:\n                return False\n            steps = max(2, int(length / resolution))\n            for i in range(steps +1):\n                inter = tuple(f[d] + (t[d] - f[d]) * i / steps for d in range(dim))\n                if in_obstacle(inter):\n                    return True\n            return False\n\n        def steer(frm, to):\n            d = dist(frm, to)\n            if d <= self.step_size:\n                return to\n            ratio = self.step_size / d\n            return tuple(frm[i] + (to[i] - frm[i]) * ratio for i in range(dim))\n\n        def nearest(tree, p):\n            best = None\n            best_d = float('inf')\n            px = p\n            for n in tree:\n                d2 = 0.0\n                for i in range(dim):\n                    dd = n.position[i] - px[i]\n                    d2 += dd*dd\n                    if d2 >= best_d*best_d:\n                        break\n                else:\n                    d = math.sqrt(d2)\n                    if d < best_d:\n                        best = n\n                        best_d = d\n            return best, best_d\n\n        def near_nodes(tree, p, radius):\n            r2 = radius*radius\n            res = []\n            px = p\n            for n in tree:\n                d2 = 0.0\n                for i in range(dim):\n                    dd = n.position[i] - px[i]\n                    d2 += dd*dd\n                    if d2 > r2:\n                        break\n                if d2 <= r2:\n                    res.append(n)\n            return res\n\n        def adaptive_radius(n_nodes, c_best):\n            gamma = self.n_near_const\n            if n_nodes == 0:\n                return self.step_size * 3.0\n            radius = min((gamma * (math.log(n_nodes)/n_nodes))**(1/dim), self.step_size * 6.0)\n            if c_best == float('inf'):\n                return radius\n            shrink = max(0.3, c_best / (c_min * 3.1))\n            return max(self.step_size * 0.8, radius * shrink)\n\n        def ellipsoid_sample(c_best):\n            if c_best == float('inf'):\n                # Uniform sample in bounds avoiding boundary issues\n                return tuple(random.uniform(0.0, bounds[i]) for i in range(dim))\n            center = tuple((start[i] + goal[i]) * 0.5 for i in range(dim))\n            a1 = [goal[i] - start[i] for i in range(dim)]\n            norm_a1 = math.sqrt(sum(x*x for x in a1))\n            if norm_a1 < 1e-14:\n                return tuple(random.uniform(0.0, bounds[i]) for i in range(dim))\n            unit_a1 = [x / norm_a1 for x in a1]\n            U = [unit_a1]\n            for idx in range(dim -1):\n                base = [0.0]*dim\n                base[(idx+1)%dim] = 1.0\n                for u in U:\n                    proj = sum(base[j]*u[j] for j in range(dim))\n                    base = [base[j] - proj*u[j] for j in range(dim)]\n                norm_base = math.sqrt(sum(x*x for x in base))\n                if norm_base > 1e-14:\n                    U.append([x / norm_base for x in base])\n                else:\n                    U.append([0.0]*dim)\n            r1 = c_best * 0.5\n            val = c_best*c_best - c_min*c_min\n            r2 = math.sqrt(val)*0.5 if val > 0 else 0.0\n            radii = [r1] + [r2]*(dim-1)\n\n            max_attempt = 50\n            for _ in range(max_attempt):\n                x_ball = [random.gauss(0, 1) for _ in range(dim)]\n                norm_ball = math.sqrt(sum(x*x for x in x_ball))\n                if norm_ball < 1e-14:\n                    continue\n                unit_ball = [x / norm_ball for x in x_ball]\n                u = random.random() ** (1.0/dim)\n                point_ball = [coord * u for coord in unit_ball]\n                scaled = [radii[i]*point_ball[i] for i in range(dim)]\n                point_rot = [0.0]*dim\n                for i in range(dim):\n                    for j in range(dim):\n                        point_rot[j] += scaled[i]*U[i][j]\n                sample = tuple(center[i] + point_rot[i] for i in range(dim))\n                if all(0.0 <= sample[i] <= bounds[i] for i in range(dim)) and not in_obstacle(sample):\n                    return sample\n            # fallback\n            return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n\n        def extract_path(node):\n            return node.path_from_root()\n\n        def connect_path(n_start, n_goal):\n            path_s = extract_path(n_start)\n            path_g_rev = extract_path(n_goal)\n            path_g = path_g_rev[::-1]\n            if len(path_s) > 0 and len(path_g) > 0 and path_s[-1] == path_g[0]:\n                return path_s + path_g[1:]\n            else:\n                return path_s + path_g\n\n        def curvature_penalty(p_parent, p_child, p_new):\n            # Small curvature cost for smoother parent selection\n            if p_parent is None:\n                return 0.0\n            v1 = tuple(p_child[i] - p_parent[i] for i in range(dim))\n            v2 = tuple(p_new[i] - p_child[i] for i in range(dim))\n            len1 = math.sqrt(sum(x*x for x in v1))\n            len2 = math.sqrt(sum(x*x for x in v2))\n            if len1 < 1e-14 or len2 < 1e-14:\n                return 0.0\n            dot = sum(v1[i]*v2[i] for i in range(dim))/(len1*len2)\n            dot = max(-1.0, min(1.0, dot))\n            angle = math.acos(dot)\n            return angle\n\n        def add_node(tree, new_pos, nodes_all, edges, c_best):\n            nn, _ = nearest(tree, new_pos)\n            if nn is None:\n                return None\n            new_pos_steered = steer(nn.position, new_pos)\n            if in_obstacle(new_pos_steered) or edge_obstacle(nn.position, new_pos_steered):\n                return None\n\n            n_nodes = len(nodes_all)\n            radius = adaptive_radius(n_nodes, c_best)\n            near = near_nodes(tree, new_pos_steered, radius)\n\n            alpha_curv = 0.04\n            best_parent = nn\n            best_cost = nn.cost + dist(nn.position, new_pos_steered)\n            best_score = best_cost + alpha_curv * curvature_penalty(nn.parent.position if nn.parent else None, nn.position, new_pos_steered)\n\n            for candidate in near:\n                if candidate == nn:\n                    continue\n                if edge_obstacle(candidate.position, new_pos_steered):\n                    continue\n                candidate_cost = candidate.cost + dist(candidate.position, new_pos_steered)\n                curv_cost = alpha_curv * curvature_penalty(candidate.parent.position if candidate.parent else None, candidate.position, new_pos_steered)\n                score = candidate_cost + curv_cost\n                if score + self.improve_tol < best_score:\n                    best_parent = candidate\n                    best_cost = candidate_cost\n                    best_score = score\n\n            new_node = Node(new_pos_steered)\n            best_parent.add_child(new_node)\n            new_node.cost = best_cost\n            tree.append(new_node)\n            nodes_all.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewiring neighbors around new_node if better path found\n            near_rewire = near_nodes(tree, new_node.position, radius)\n            for near_n in near_rewire:\n                if near_n == best_parent or near_n == new_node:\n                    continue\n                alt_cost = new_node.cost + dist(new_node.position, near_n.position)\n                if alt_cost + self.improve_tol < near_n.cost and not edge_obstacle(new_node.position, near_n.position):\n                    # Additionally check curvature penalty for rewiring\n                    curv_new = curvature_penalty(new_node.parent.position if new_node.parent else None, new_node.position, near_n.position)\n                    curv_old = curvature_penalty(near_n.parent.parent.position if near_n.parent and near_n.parent.parent else None, near_n.parent.position if near_n.parent else None, near_n.position)\n                    if alpha_curv * curv_new <= alpha_curv * curv_old + 0.15:  # allow slight increase for cost gain\n                        if near_n.parent:\n                            near_n.parent.remove_child(near_n)\n                            try:\n                                edges.remove((near_n.parent, near_n))\n                            except Exception:\n                                pass\n                        new_node.add_child(near_n)\n                        near_n.cost = alt_cost\n                        edges.append((new_node, near_n))\n\n            return new_node\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            path = list(path)\n            changed = True\n            iter_count = 0\n            while changed and iter_count < self.shortcut_iters:\n                changed = False\n                iter_count +=1\n                i=0\n                while i < len(path)-2:\n                    max_j = min(len(path)-1, i + 7 + random.randint(0,4))\n                    j = random.randint(i+2, max_j) if max_j > i+2 else i+2\n                    if j > i+1 and not edge_obstacle(path[i], path[j]):\n                        path = path[:i+1] + path[j:]\n                        changed = True\n                        break\n                    i += 1\n            return path\n\n        # Initialize bidirectional trees\n        start_tree = [Node(start)]\n        goal_tree = [Node(goal)]\n        nodes_all = start_tree + goal_tree\n        edges = []\n\n        c_min = dist(start, goal)\n        best_cost = float('inf')\n        best_path = []\n        found_solution = False\n\n        no_improve_count = 0\n        last_best_cost = float('inf')\n\n        start_time = time.time()\n\n        for it in range(self.max_iter):\n            sample_pt = ellipsoid_sample(best_cost if found_solution else float('inf'))\n\n            # Alternate growing trees: even iterations start-tree, odd goal-tree\n            if it % 2 == 0:\n                tree_a, tree_b = start_tree, goal_tree\n            else:\n                tree_a, tree_b = goal_tree, start_tree\n\n            new_node = add_node(tree_a, sample_pt, nodes_all, edges, best_cost)\n            if new_node is None:\n                if found_solution:\n                    no_improve_count += 1\n                continue\n\n            nbr_node, nbr_dist = nearest(tree_b, new_node.position)\n            if nbr_node and nbr_dist <= self.step_size and not edge_obstacle(new_node.position, nbr_node.position):\n                candidate_path = connect_path(new_node, nbr_node)\n                candidate_cost = new_node.cost + dist(new_node.position, nbr_node.position) + nbr_node.cost\n\n                if candidate_cost + self.improve_tol < best_cost:\n                    best_cost = candidate_cost\n                    best_path = candidate_path\n                    found_solution = True\n                    no_improve_count = 0\n                else:\n                    no_improve_count += 1\n            elif found_solution:\n                no_improve_count += 1\n\n            if found_solution and no_improve_count >= self.max_no_improve:\n                break\n\n            if found_solution and best_cost + self.improve_tol < last_best_cost:\n                last_best_cost = best_cost\n                no_improve_count = 0\n\n        if found_solution and len(best_path) > 3:\n            # Multiple progressive shortcut passes to enhance path quality\n            for _ in range(3):\n                best_path = shortcut_path(best_path)\n\n        if found_solution:\n            return PlannerResult(True, best_path, nodes_all, edges)\n        else:\n            return PlannerResult(False, [], nodes_all, edges)",
          "objective": -23.40566,
          "time_improvement": 28.0,
          "length_improvement": 13.0,
          "smoothness_improvement": 1419.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.02814173698425293,
                    "num_nodes_avg": 174.7,
                    "path_length_avg": 170.78044027086807,
                    "smoothness_avg": 0.041064375085066517,
                    "success_improvement": 0.0,
                    "time_improvement": -15.879069904428114,
                    "length_improvement": 6.3925344982841175,
                    "smoothness_improvement": 542.746642799047,
                    "objective_score": 1.7855329416372712
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.04101948738098145,
                    "num_nodes_avg": 312.8,
                    "path_length_avg": 241.95417433722574,
                    "smoothness_avg": 0.08769719153831615,
                    "success_improvement": 0.0,
                    "time_improvement": 74.59547240955273,
                    "length_improvement": 19.228732341469897,
                    "smoothness_improvement": 2156.5119040147615,
                    "objective_score": 44.698440647821556
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.036681413650512695,
                    "num_nodes_avg": 276.1,
                    "path_length_avg": 130.08856674191185,
                    "smoothness_avg": 0.13041023521317593,
                    "success_improvement": 0.0,
                    "time_improvement": 25.927156303411085,
                    "length_improvement": 13.601368121895007,
                    "smoothness_improvement": 1558.8085660293298,
                    "objective_score": 23.733010594306975
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "A simplified bidirectional RRT* planner using a grid-based spatial hash for efficient neighbor queries, adaptive rewiring radius scaling, and informed sampling after an initial solution. It employs incremental rewiring for cost reduction, straightforward path merging upon tree connection, and multiple shortcutting passes post-planning for smoothness. Early stopping triggers after no improvement to balance speed and solution quality.",
          "planning_mechanism": "A bidirectional RRT* planner grows two trees alternately from start and goal with adaptive radius neighbor rewiring and spatial hashing for fast neighbor lookup. Sampling switches from uniform to informed ellipsoidal after a solution is found to focus exploration. The planner rewires neighbors to reduce cost, attempts direct connections to the other tree, and merges paths upon connection. Multiple shortcutting passes refine the path for smoothness. Early stopping avoids unnecessary computation once no improvements occur.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self,\n                 max_iter=4000,\n                 step_size=5.0,\n                 max_radius=20.0,\n                 min_radius=5.0,\n                 max_no_improve=50,\n                 shortcut_iter=150,\n                 grid_cell_size=8.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.max_radius = max_radius\n        self.min_radius = min_radius\n        self.max_no_improve = max_no_improve\n        self.shortcut_iter = shortcut_iter\n        self.grid_cell_size = grid_cell_size\n\n    def plan(self, map):\n        import math\n        import random\n        bounds = map.size\n        dim = len(bounds)\n        start_pos = tuple(map.start)\n        goal_pos = tuple(map.goal)\n        obstacles = map.obstacles\n        is_3d = (dim == 3)\n\n        def in_bounds(p):\n            return all(0.0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def in_obstacle(p):\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d_ = obs\n                    if x <= p[0] <= x+w and y <= p[1] <= y+h and z <= p[2] <= z+d_:\n                        return True\n                else:\n                    x,y,w,h = obs\n                    if x <= p[0] <= x+w and y <= p[1] <= y+h:\n                        return True\n            return False\n\n        def edge_in_obstacle(a, b, resolution=1.0):\n            dist = math.dist(a,b)\n            if dist < 1e-12:\n                return False\n            steps = max(2, int(dist / resolution))\n            for i in range(steps+1):\n                interp = tuple(a[d] + (b[d]-a[d])*i/steps for d in range(dim))\n                if in_obstacle(interp):\n                    return True\n            return False\n\n        def steer(from_p, to_p):\n            dist_ = math.dist(from_p, to_p)\n            if dist_ <= self.step_size:\n                return to_p\n            ratio = self.step_size / dist_\n            return tuple(from_p[d] + (to_p[d]-from_p[d])*ratio for d in range(dim))\n\n        class SpatialHashGrid:\n            def __init__(self, bounds, cell_size):\n                self.cell_size = cell_size\n                self.dim = len(bounds)\n                self.grid = {}\n\n            def _hash(self, pos):\n                return tuple(int(pos[d]//self.cell_size) for d in range(self.dim))\n\n            def insert(self, node):\n                key = self._hash(node.position)\n                self.grid.setdefault(key, []).append(node)\n\n            def remove(self, node):\n                key = self._hash(node.position)\n                if key in self.grid:\n                    try:\n                        self.grid[key].remove(node)\n                        if not self.grid[key]:\n                            del self.grid[key]\n                    except ValueError:\n                        pass\n\n            def query_radius(self, pos, radius):\n                r_c = int(math.ceil(radius / self.cell_size))\n                base_cell = self._hash(pos)\n                found = []\n                for dx in range(-r_c, r_c+1):\n                    for dy in range(-r_c, r_c+1):\n                        if self.dim == 2:\n                            cell = (base_cell[0]+dx, base_cell[1]+dy)\n                            if cell in self.grid:\n                                found.extend(self.grid[cell])\n                        else:\n                            for dz in range(-r_c, r_c+1):\n                                cell = (base_cell[0]+dx, base_cell[1]+dy, base_cell[2]+dz)\n                                if cell in self.grid:\n                                    found.extend(self.grid[cell])\n                r_sq = radius*radius\n                return [n for n in found if sum((n.position[d]-pos[d])**2 for d in range(self.dim)) <= r_sq]\n\n            def nearest(self, pos):\n                base_cell = self._hash(pos)\n                search_range = 1\n                max_range = 10\n                candidates = []\n                while not candidates and search_range <= max_range:\n                    for dx in range(-search_range, search_range+1):\n                        for dy in range(-search_range, search_range+1):\n                            if self.dim == 2:\n                                cell = (base_cell[0]+dx, base_cell[1]+dy)\n                                if cell in self.grid:\n                                    candidates.extend(self.grid[cell])\n                            else:\n                                for dz in range(-search_range, search_range+1):\n                                    cell = (base_cell[0]+dx, base_cell[1]+dy, base_cell[2]+dz)\n                                    if cell in self.grid:\n                                        candidates.extend(self.grid[cell])\n                    search_range += 1\n                if not candidates:\n                    return None\n                return min(candidates, key=lambda n: math.dist(n.position, pos))\n\n        def adaptive_radius(n_nodes):\n            if n_nodes <= 1:\n                return self.max_radius\n            gamma = self.max_radius\n            unit_ball_vol = (math.pi**(dim/2))/math.gamma(dim/2+1) if dim>1 else 2.0\n            radius = gamma * ((math.log(n_nodes)/n_nodes)**(1/dim))\n            return max(self.min_radius, min(radius, self.max_radius))\n\n        def propagate_cost_downstream(node):\n            stack = [node]\n            while stack:\n                cur = stack.pop()\n                for c in cur.children:\n                    new_cost = cur.cost + math.dist(cur.position, c.position)\n                    if new_cost + 1e-14 < c.cost:\n                        c.cost = new_cost\n                        c.parent = cur\n                        stack.append(c)\n\n        def rewire(pivot, neighbors, grid):\n            for nb in neighbors:\n                if nb == pivot.parent:\n                    continue\n                new_cost = pivot.cost + math.dist(pivot.position, nb.position)\n                if new_cost + 1e-14 < nb.cost and not edge_in_obstacle(pivot.position, nb.position):\n                    old_p = nb.parent\n                    if old_p:\n                        old_p.remove_child(nb)\n                    pivot.add_child(nb)\n                    nb.cost = new_cost\n                    propagate_cost_downstream(nb)\n\n        def sample_uniform():\n            return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        def sample_informed(best_cost):\n            if best_cost == float('inf'):\n                return sample_uniform()\n            c_min = math.dist(start_pos, goal_pos)\n            if c_min < 1e-12:\n                return sample_uniform()\n            center = tuple((start_pos[d]+goal_pos[d])*0.5 for d in range(dim))\n            unit_dir = [(goal_pos[d]-start_pos[d])/c_min for d in range(dim)]\n            val = best_cost*best_cost - c_min*c_min\n            r1 = best_cost*0.5\n            r_rest = math.sqrt(max(val,0))*0.5\n\n            if dim == 2:\n                a1 = unit_dir\n                a2 = (-a1[1], a1[0])\n                basis = (a1, a2)\n                radii = (r1, r_rest)\n            else:\n                def cross(u,v):\n                    return (u[1]*v[2]-u[2]*v[1], u[2]*v[0]-u[0]*v[2], u[0]*v[1]-u[1]*v[0])\n                def norm(v):\n                    return math.sqrt(sum(x*x for x in v))\n                a1 = unit_dir\n                ref = (1,0,0) if abs(a1[0]) < 0.9 else (0,1,0)\n                b2 = cross(a1, ref)\n                n_b2 = norm(b2)\n                if n_b2 < 1e-12:\n                    ref = (0,0,1)\n                    b2 = cross(a1, ref)\n                    n_b2 = norm(b2)\n                b2 = tuple(x / n_b2 for x in b2)\n                b3 = cross(a1, b2)\n                basis = (a1, b2, b3)\n                radii = (r1, r_rest, r_rest)\n\n            def sample_unit_ball(dimensions):\n                while True:\n                    v = [random.gauss(0,1) for _ in range(dimensions)]\n                    nrm = math.sqrt(sum(x*x for x in v))\n                    if nrm < 1e-14:\n                        continue\n                    unit_v = [x/nrm for x in v]\n                    r = random.random()**(1/dimensions)\n                    return [x*r for x in unit_v]\n\n            u = sample_unit_ball(dim)\n            sample = [center[d]+sum(basis[i][d]*radii[i]*u[i] for i in range(dim)) for d in range(dim)]\n            clamped = tuple(max(0.0, min(sample[d], bounds[d])) for d in range(dim))\n            if in_obstacle(clamped):\n                return sample_uniform()  # fallback if inside obstacle\n            return clamped\n\n        def choose_parent(tree, grid, pos):\n            n = len(tree)\n            radius = adaptive_radius(n)\n            neighbors = grid.query_radius(pos, radius)\n            neighbors = [nb for nb in neighbors if not edge_in_obstacle(nb.position, pos)]\n            if not neighbors:\n                nearest = grid.nearest(pos)\n                if nearest is None or edge_in_obstacle(nearest.position, pos):\n                    return None, []\n                cost = nearest.cost + math.dist(nearest.position, pos)\n                new_node = Node(pos, parent=nearest, cost=cost)\n                nearest.add_child(new_node)\n                tree.append(new_node)\n                grid.insert(new_node)\n                return new_node, []\n            best_parent = None\n            min_cost = float('inf')\n            for nb in neighbors:\n                c = nb.cost + math.dist(nb.position, pos)\n                if c < min_cost:\n                    min_cost = c\n                    best_parent = nb\n            new_node = Node(pos, parent=best_parent, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree.append(new_node)\n            grid.insert(new_node)\n            return new_node, neighbors\n\n        def direct_connect(tree, grid, target_node):\n            if not tree:\n                return None\n            nearest = grid.nearest(target_node.position)\n            if nearest is None:\n                return None\n            dist_to_target = math.dist(nearest.position, target_node.position)\n            if dist_to_target <= self.step_size:\n                if edge_in_obstacle(nearest.position, target_node.position) or in_obstacle(target_node.position):\n                    return None\n                new_node = Node(target_node.position, parent=nearest, cost=nearest.cost + dist_to_target)\n                nearest.add_child(new_node)\n                tree.append(new_node)\n                grid.insert(new_node)\n                return new_node\n            current = nearest\n            steps = int(math.ceil(dist_to_target / self.step_size))\n            for _ in range(steps):\n                new_pos = steer(current.position, target_node.position)\n                if not in_bounds(new_pos) or in_obstacle(new_pos):\n                    return None\n                if edge_in_obstacle(current.position, new_pos):\n                    return None\n                new_node = Node(new_pos, parent=current, cost=current.cost + math.dist(current.position, new_pos))\n                current.add_child(new_node)\n                tree.append(new_node)\n                grid.insert(new_node)\n                current = new_node\n                if math.dist(current.position, target_node.position) <= self.step_size:\n                    if edge_in_obstacle(current.position, target_node.position) or in_obstacle(target_node.position):\n                        return None\n                    final_node = Node(target_node.position, parent=current,\n                                      cost=current.cost + math.dist(current.position, target_node.position))\n                    current.add_child(final_node)\n                    tree.append(final_node)\n                    grid.insert(final_node)\n                    return final_node\n            return None\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path[:]\n            path = list(path)\n            for _ in range(self.shortcut_iter):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path)-3)\n                j = random.randint(i+2, len(path)-1)\n                if not edge_in_obstacle(path[i], path[j]):\n                    path = path[:i+1]+path[j:]\n            return path\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n        start_grid = SpatialHashGrid(bounds, self.grid_cell_size)\n        goal_grid = SpatialHashGrid(bounds, self.grid_cell_size)\n        start_grid.insert(start_root)\n        goal_grid.insert(goal_root)\n\n        best_path = []\n        best_cost = float('inf')\n        found_solution = False\n        no_improve_count = 0\n\n        for it in range(self.max_iter):\n            if it % 2 == 0:\n                tree_a, grid_a, tree_b, grid_b = start_tree, start_grid, goal_tree, goal_grid\n            else:\n                tree_a, grid_a, tree_b, grid_b = goal_tree, goal_grid, start_tree, start_grid\n\n            x_rand = sample_informed(best_cost) if found_solution else sample_uniform()\n            if not in_bounds(x_rand) or in_obstacle(x_rand):\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n                continue\n\n            nearest_node = grid_a.nearest(x_rand)\n            if nearest_node is None:\n                continue\n            new_pos = steer(nearest_node.position, x_rand)\n            if not in_bounds(new_pos) or in_obstacle(new_pos) or edge_in_obstacle(nearest_node.position, new_pos):\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n                continue\n\n            new_node, neighbors = choose_parent(tree_a, grid_a, new_pos)\n            if new_node is None:\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n                continue\n\n            rewire(new_node, neighbors, grid_a)\n\n            meet_node = direct_connect(tree_b, grid_b, new_node)\n            if meet_node is not None:\n                if it % 2 == 0:\n                    path_a = new_node.path_from_root()\n                    path_b = meet_node.path_from_root()\n                else:\n                    path_a = meet_node.path_from_root()\n                    path_b = new_node.path_from_root()\n                if path_a and path_b and path_a[-1] == path_b[-1]:\n                    merged_path = path_a + path_b[-2::-1]\n                else:\n                    merged_path = path_a + path_b[::-1]\n\n                total_cost = 0.0\n                for i in range(len(merged_path)-1):\n                    total_cost += math.dist(merged_path[i], merged_path[i+1])\n\n                if total_cost + 1e-9 < best_cost:\n                    best_cost = total_cost\n                    best_path = merged_path\n                    found_solution = True\n                    no_improve_count = 0\n                else:\n                    if found_solution:\n                        no_improve_count += 1\n                        if no_improve_count >= self.max_no_improve:\n                            break\n            else:\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n\n        if found_solution and len(best_path) >= 3:\n            for _ in range(3):\n                best_path = shortcut_path(best_path)\n\n        return PlannerResult(success=found_solution, path=best_path,\n                             nodes=start_tree + goal_tree, edges=[])",
          "objective": -23.17298,
          "time_improvement": 14.0,
          "length_improvement": 19.0,
          "smoothness_improvement": 1516.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.03696372509002686,
                    "num_nodes_avg": 106.7,
                    "path_length_avg": 151.91267224068284,
                    "smoothness_avg": 0.04517077157882247,
                    "success_improvement": 0.0,
                    "time_improvement": -52.20532002100913,
                    "length_improvement": 16.734257134545622,
                    "smoothness_improvement": 607.0206651090382,
                    "objective_score": -2.585938400030174
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.051871538162231445,
                    "num_nodes_avg": 263.4,
                    "path_length_avg": 233.85415863516727,
                    "smoothness_avg": 0.09927027014572733,
                    "success_improvement": 0.0,
                    "time_improvement": 67.87449072285754,
                    "length_improvement": 21.932750728841867,
                    "smoothness_improvement": 2454.2955523350383,
                    "objective_score": 45.79347541583758
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.036731505393981935,
                    "num_nodes_avg": 386.1,
                    "path_length_avg": 122.62384377401966,
                    "smoothness_avg": 0.12465716808616459,
                    "success_improvement": 0.0,
                    "time_improvement": 25.826003225728794,
                    "length_improvement": 18.559081685258956,
                    "smoothness_improvement": 1485.6299768209885,
                    "objective_score": 26.311399862978956
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "initial",
          "algorithm_description": "This algorithm enhances the standard BI-RRT by incorporating an optimization step that rewires nearby nodes to minimize cost, resulting in asymptotically optimal paths. It grows two trees\u2014one from the start and one from the goal\u2014and attempts to connect them while optimizing the path cost dynamically.",
          "planning_mechanism": "The planning mechanism includes sampling a random point, extending each tree toward it, rewiring neighbors within a radius to optimize the cost, and attempting to connect the two trees. When a connection is established, the combined path is extracted from both trees. Node validity and edge collision checks are strictly enforced throughout the process.",
          "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost: float = 0.0):\n        self.position = position              # Tuple[float, ...]\n        self.parent: Optional[\"Node\"] = parent\n        self.cost: float = cost\n        self.children: List[\"Node\"] = []\n        self.valid = True\n\n    def add_child(self, child_node: \"Node\"):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n\nclass Planner:\n    def __init__(\n        self,\n        max_iter: int = 5000,\n        step_size: float = 5.0,\n        gamma_rrt_star: float = 50.0,\n        max_radius: float = 60.0,\n    ):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.gamma_rrt_star = gamma_rrt_star\n        self.max_radius = max_radius\n\n    # ======================= Public API =======================\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        start_root = Node(start_position, parent=None, cost=0.0)\n        goal_root  = Node(goal_position,  parent=None, cost=0.0)\n        nodes.extend([start_root, goal_root])\n\n        tree_a: List[Node] = [start_root]\n        tree_b: List[Node] = [goal_root]\n\n        for _ in range(self.max_iter):\n            rand_point = self._sample_free(bounds, obstacles, is_3d)\n\n            new_a = self._extend_and_rewire(tree_a, rand_point, obstacles, is_3d, nodes, edges, bounds)\n            if new_a is None:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            new_b = self._connect_and_rewire(tree_b, new_a, obstacles, is_3d, nodes, edges, bounds)\n            if new_b:\n                success_state = True\n                path_a = new_a.path_from_root()\n                path_b = new_b.path_from_root()\n                if path_a and path_b and path_a[-1] == path_b[-1]:\n                    path_b = path_b[:-1]\n                extracted_path = path_a + path_b[::-1]\n                break\n\n            tree_a, tree_b = tree_b, tree_a\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        while True:\n            p = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    def _nearest(self, tree: List[Node], point):\n        return min(tree, key=lambda node: math.dist(node.position, point))\n\n    def _steer(self, from_pos, to_pos):\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _near_nodes(self, tree: List[Node], position, bounds) -> List[Node]:\n        n = max(1, len(tree))\n        d = len(position)\n        # \uacf5\uac04 \uc2a4\ucf00\uc77c\uc744 \uac04\ub2e8\ud788 bounds\ub85c \ucd94\uc815 (\uc815\ubc00 X, \uc2e4\uc6a9\uc801)\n        scale = max(1.0, sum(bounds) / d)\n        r_theory = self.gamma_rrt_star * ((math.log(n + 1) / (n + 1)) ** (1.0 / d))\n        radius = max(self.step_size * 2.0, min(self.max_radius, r_theory * 0.5 + scale * 0.02))\n        return [node for node in tree if math.dist(node.position, position) <= radius]\n\n    def _choose_parent_and_add(self, tree, new_pos, obstacles, is_3d, nodes, edges, bounds):\n        nearest = self._nearest(tree, new_pos)\n        neighbors = self._near_nodes(tree, new_pos, bounds)\n\n        min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n        best_parent = nearest\n\n        for nb in neighbors:\n            if not self._is_edge_in_obstacle(nb.position, new_pos, obstacles, is_3d):\n                cand = nb.cost + math.dist(nb.position, new_pos)\n                if cand < min_cost:\n                    min_cost = cand\n                    best_parent = nb\n\n        new_node = Node(new_pos, parent=None, cost=min_cost)\n        best_parent.add_child(new_node)\n        tree.append(new_node)\n        nodes.append(new_node)\n        edges.append((best_parent, new_node))\n        return new_node, neighbors\n\n    def _rewire_from(self, pivot: Node, neighbors: List[Node], obstacles, is_3d, edges):\n        for nb in neighbors:\n            if not self._is_edge_in_obstacle(pivot.position, nb.position, obstacles, is_3d):\n                new_cost = pivot.cost + math.dist(pivot.position, nb.position)\n                if new_cost + 1e-12 < nb.cost:  # \uc791\uc740 \uc218\uce58 \ubc84\ud37c\n                    if nb.parent is not None:\n                        try:\n                            edges.remove((nb.parent, nb))\n                        except ValueError:\n                            pass\n                        if nb in nb.parent.children:\n                            nb.parent.children.remove(nb)\n                    pivot.add_child(nb)\n                    nb.cost = new_cost\n                    edges.append((pivot, nb))\n\n    def _extend_and_rewire(self, tree, sample_point, obstacles, is_3d, nodes, edges, bounds):\n        nearest = self._nearest(tree, sample_point)\n        new_pos = self._steer(nearest.position, sample_point)\n\n        if self._is_in_obstacle(new_pos, obstacles, is_3d):\n            return None\n        if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n            return None\n\n        new_node, neighbors = self._choose_parent_and_add(tree, new_pos, obstacles, is_3d, nodes, edges, bounds)\n        self._rewire_from(new_node, neighbors, obstacles, is_3d, edges)\n        return new_node\n\n    def _connect_and_rewire(self, tree, target_node: Node, obstacles, is_3d, nodes, edges, bounds):\n        nearest = self._nearest(tree, target_node.position)\n\n        while True:\n            new_pos = self._steer(nearest.position, target_node.position)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                return None\n\n            connect_node, neighbors = self._choose_parent_and_add(tree, new_pos, obstacles, is_3d, nodes, edges, bounds)\n            self._rewire_from(connect_node, neighbors, obstacles, is_3d, edges)\n\n            if math.dist(connect_node.position, target_node.position) <= self.step_size:\n                if (not self._is_edge_in_obstacle(connect_node.position, target_node.position, obstacles, is_3d) and\n                    not self._is_in_obstacle(target_node.position, obstacles, is_3d)):\n                    final_node = Node(target_node.position, parent=None, cost=connect_node.cost + math.dist(connect_node.position, target_node.position))\n                    connect_node.add_child(final_node)\n                    tree.append(final_node)\n                    nodes.append(final_node)\n                    edges.append((connect_node, final_node))\n                    return final_node\n                else:\n                    return None\n\n            nearest = connect_node\n\n        \n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n        \n        \n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n",
          "objective": -22.142109273517423,
          "time_improvement": 49.0,
          "length_improvement": 11.0,
          "smoothness_improvement": 177.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.018251991271972655,
                    "num_nodes_avg": 78.7,
                    "path_length_avg": 175.55592835957023,
                    "smoothness_avg": 0.017196193462405217,
                    "success_improvement": 0.0,
                    "time_improvement": 24.843879619675935,
                    "length_improvement": 3.775013804415195,
                    "smoothness_improvement": 169.1577698184268,
                    "objective_score": 10.563961017644031
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.04780585765838623,
                    "num_nodes_avg": 302.9,
                    "path_length_avg": 259.03658233660315,
                    "smoothness_avg": 0.01078988487631875,
                    "success_improvement": 0.0,
                    "time_improvement": 70.39248153962646,
                    "length_improvement": 13.526132861425937,
                    "smoothness_improvement": 177.6315095076258,
                    "objective_score": 30.121581726281626
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.023344540596008302,
                    "num_nodes_avg": 176.0,
                    "path_length_avg": 128.09376742543256,
                    "smoothness_avg": 0.022442540549775757,
                    "success_improvement": 0.0,
                    "time_improvement": 52.85905490960737,
                    "length_improvement": 14.926218845764677,
                    "smoothness_improvement": 185.467459257119,
                    "objective_score": 25.74078507662661
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m2",
          "algorithm_description": "An improved bidirectional RRT* planner combining spatial hashing for efficient neighbor queries, adaptive rewiring radius tuned for faster convergence, and aggressive but low-overhead rewiring. This planner alternates growth between start and goal trees, applies early stopping based on no improvement, employs direct tree-to-tree connections with incremental steering, and integrates multi-pass shortcutting for path smoothing. It uses a spatial hash grid to avoid linear scans, balances exploration and exploitation with adaptive sampling, and prioritizes low-cost parent connections with fast cost propagation to reduce planning time and path complexity while enhancing path length and smoothness.",
          "planning_mechanism": "A bidirectional RRT* with spatial hashing and adaptively scaled rewiring radius optimized for improved runtime efficiency and path quality. The planner grows two trees toward each other using sampled points within bounds and informed ellipsoidal regions after first solution. It leverages a fast spatial hash grid for nearest and near neighbor lookups instead of full linear searches, aggressively rewires neighbors for cost reduction, prunes costly branches, performs incremental direct connection attempts between trees, and smooths paths progressively with shortcutting both during and post planning. Early termination is triggered on stagnant improvement to reduce computation.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self,\n                 max_iter=4000,\n                 step_size=5.0,\n                 max_radius=18.0,\n                 min_radius=6.0,\n                 max_no_improve=50,\n                 time_limit=20.0,\n                 shortcut_iter=200,\n                 grid_cell_size=8.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.max_radius = max_radius\n        self.min_radius = min_radius\n        self.max_no_improve = max_no_improve\n        self.time_limit = time_limit\n        self.shortcut_iter = shortcut_iter\n        self.grid_cell_size = grid_cell_size\n\n    def plan(self, map):\n        import math\n        import random\n        import time\n\n        bounds = map.size\n        dim = len(bounds)\n        start_pos = tuple(map.start)\n        goal_pos = tuple(map.goal)\n        obstacles = map.obstacles\n        is_3d = (dim == 3)\n\n        def in_bounds(p):\n            return all(0.0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def in_obstacle(p):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d_ = obs\n                    px, py, pz = p\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d_:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    px, py = p\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def edge_in_obstacle(a, b, resolution=1.0):\n            dist = math.dist(a, b)\n            if dist < 1e-12:\n                return False\n            steps = max(2, int(dist / resolution))\n            for i in range(steps + 1):\n                interp = tuple(a[d] + (b[d] - a[d]) * i / steps for d in range(dim))\n                if in_obstacle(interp):\n                    return True\n            return False\n\n        def steer(from_p, to_p):\n            dist = math.dist(from_p, to_p)\n            if dist <= self.step_size:\n                return to_p\n            ratio = self.step_size / dist\n            return tuple(from_p[d] + (to_p[d] - from_p[d]) * ratio for d in range(dim))\n\n        class SpatialHashGrid:\n            def __init__(self, bounds, cell_size):\n                self.cell_size = cell_size\n                self.dim = len(bounds)\n                self.grid = dict()\n\n            def _hash(self, pos):\n                return tuple(int(pos[d] // self.cell_size) for d in range(self.dim))\n\n            def insert(self, node):\n                key = self._hash(node.position)\n                self.grid.setdefault(key, []).append(node)\n\n            def remove(self, node):\n                key = self._hash(node.position)\n                if key in self.grid:\n                    try:\n                        self.grid[key].remove(node)\n                        if not self.grid[key]:\n                            del self.grid[key]\n                    except ValueError:\n                        pass\n\n            def query_radius(self, pos, radius):\n                cells_range = int(math.ceil(radius / self.cell_size))\n                base_cell = self._hash(pos)\n                found_nodes = []\n                for dx in range(-cells_range, cells_range + 1):\n                    for dy in range(-cells_range, cells_range + 1):\n                        if self.dim == 2:\n                            cell = (base_cell[0] + dx, base_cell[1] + dy)\n                            if cell in self.grid:\n                                found_nodes.extend(self.grid[cell])\n                        else:\n                            for dz in range(-cells_range, cells_range + 1):\n                                cell = (base_cell[0] + dx, base_cell[1] + dy, base_cell[2] + dz)\n                                if cell in self.grid:\n                                    found_nodes.extend(self.grid[cell])\n                r_sq = radius * radius\n                results = []\n                for node in found_nodes:\n                    dist_sq = 0.0\n                    for d in range(self.dim):\n                        diff = node.position[d] - pos[d]\n                        dist_sq += diff * diff\n                    if dist_sq <= r_sq:\n                        results.append(node)\n                return results\n\n            def nearest(self, pos):\n                cell = self._hash(pos)\n                candidates = []\n                search_range = 1\n                max_search = 10\n                while not candidates and search_range <= max_search:\n                    for dx in range(-search_range, search_range + 1):\n                        for dy in range(-search_range, search_range + 1):\n                            if self.dim == 2:\n                                c = (cell[0] + dx, cell[1] + dy)\n                                if c in self.grid:\n                                    candidates.extend(self.grid[c])\n                            else:\n                                for dz in range(-search_range, search_range + 1):\n                                    c = (cell[0] + dx, cell[1] + dy, cell[2] + dz)\n                                    if c in self.grid:\n                                        candidates.extend(self.grid[c])\n                    search_range += 1\n                if not candidates:\n                    return None\n                nearest_node = min(candidates, key=lambda n: math.dist(n.position, pos))\n                return nearest_node\n\n        def adaptive_radius(n_nodes):\n            if n_nodes == 0:\n                return self.max_radius\n            gamma = self.max_radius\n            unit_ball_vol = (math.pi ** (dim / 2)) / math.gamma(dim / 2 + 1) if dim > 1 else 2.0\n            radius = gamma * ((math.log(n_nodes) / n_nodes) ** (1 / dim))\n            return max(self.min_radius, min(radius, self.max_radius))\n\n        def propagate_cost_downstream(node):\n            stack = [node]\n            while stack:\n                current = stack.pop()\n                for c in current.children:\n                    new_cost = current.cost + math.dist(current.position, c.position)\n                    if new_cost + 1e-14 < c.cost:\n                        c.cost = new_cost\n                        c.parent = current\n                        stack.append(c)\n\n        def rewire(pivot, neighbors, grid):\n            for nb in neighbors:\n                if nb == pivot.parent:\n                    continue\n                new_cost = pivot.cost + math.dist(pivot.position, nb.position)\n                if new_cost + 1e-14 < nb.cost and not edge_in_obstacle(pivot.position, nb.position):\n                    old_parent = nb.parent\n                    if old_parent:\n                        old_parent.remove_child(nb)\n                    pivot.add_child(nb)\n                    nb.cost = new_cost\n                    propagate_cost_downstream(nb)\n\n        def prune(tree, grid, cost_limit):\n            if cost_limit == float('inf'):\n                return\n            to_remove = []\n            for node in tree:\n                if node.parent is None:\n                    continue\n                if node.cost > cost_limit * 1.4:\n                    to_remove.append(node)\n            for node in to_remove:\n                def remove_subtree(n):\n                    for c in n.children[:]:\n                        remove_subtree(c)\n                    if n in tree:\n                        tree.remove(n)\n                        grid.remove(n)\n                remove_subtree(node)\n\n        def sample_uniform():\n            return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        def sample_informed(best_cost):\n            if best_cost == float('inf'):\n                return sample_uniform()\n            c_min = math.dist(start_pos, goal_pos)\n            if c_min < 1e-12:\n                return sample_uniform()\n            center = tuple((start_pos[d] + goal_pos[d]) * 0.5 for d in range(dim))\n            unit_dir = [(goal_pos[d] - start_pos[d]) / c_min for d in range(dim)]\n            val = best_cost * best_cost - c_min * c_min\n            r1 = best_cost * 0.5\n            r_rest = math.sqrt(max(val, 0.0)) * 0.5\n\n            if dim == 2:\n                a1 = unit_dir\n                a2 = (-a1[1], a1[0])\n                basis = (a1, a2)\n                radii = (r1, r_rest)\n            else:\n                def cross(u,v):\n                    return (u[1]*v[2]-u[2]*v[1], u[2]*v[0]-u[0]*v[2], u[0]*v[1]-u[1]*v[0])\n                def norm(v):\n                    return math.sqrt(sum(x*x for x in v))\n\n                a1 = unit_dir\n                ref = (1,0,0) if abs(a1[0]) < 0.9 else (0,1,0)\n                b2 = cross(a1, ref)\n                n_b2 = norm(b2)\n                if n_b2 < 1e-12:\n                    ref = (0,0,1)\n                    b2 = cross(a1, ref)\n                    n_b2 = norm(b2)\n                b2 = tuple(x / n_b2 for x in b2)\n                b3 = cross(a1, b2)\n                basis = (a1, b2, b3)\n                radii = (r1, r_rest, r_rest)\n\n            def sample_unit_ball(dims):\n                while True:\n                    vec = [random.gauss(0,1) for _ in range(dims)]\n                    nrm = math.sqrt(sum(v*v for v in vec))\n                    if nrm < 1e-14:\n                        continue\n                    unit_vec = [v/nrm for v in vec]\n                    r = random.random() ** (1/dims)\n                    return [v*r for v in unit_vec]\n\n            u = sample_unit_ball(dim)\n            sample = [center[d] + sum(basis[i][d]*radii[i]*u[i] for i in range(dim)) for d in range(dim)]\n            # Clamp to bounds\n            clamped = tuple(max(0.0, min(sample[d], bounds[d])) for d in range(dim))\n            return clamped\n\n        def choose_parent(tree, grid, pos):\n            n = len(tree)\n            radius = adaptive_radius(n)\n            nbrs = grid.query_radius(pos, radius)\n            nbrs = [nb for nb in nbrs if not edge_in_obstacle(nb.position, pos)]\n            if not nbrs:\n                nearest = grid.nearest(pos)\n                if nearest is None or edge_in_obstacle(nearest.position, pos):\n                    return None, []\n                cost = nearest.cost + math.dist(nearest.position, pos)\n                new_node = Node(pos, parent=nearest, cost=cost)\n                nearest.add_child(new_node)\n                tree.append(new_node)\n                grid.insert(new_node)\n                return new_node, []\n\n            best_parent = None\n            min_cost = float('inf')\n            for nb in nbrs:\n                c = nb.cost + math.dist(nb.position, pos)\n                if c < min_cost:\n                    min_cost = c\n                    best_parent = nb\n\n            new_node = Node(pos, parent=best_parent, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree.append(new_node)\n            grid.insert(new_node)\n            return new_node, nbrs\n\n        def direct_connect(tree, grid, target_node):\n            if not tree:\n                return None\n            nearest = grid.nearest(target_node.position)\n            if nearest is None:\n                return None\n            dist_to_target = math.dist(nearest.position, target_node.position)\n            if dist_to_target <= self.step_size:\n                if edge_in_obstacle(nearest.position, target_node.position) or in_obstacle(target_node.position):\n                    return None\n                new_node = Node(target_node.position, parent=nearest, cost=nearest.cost + dist_to_target)\n                nearest.add_child(new_node)\n                tree.append(new_node)\n                grid.insert(new_node)\n                return new_node\n\n            # Incremental steering towards target, stop on collision or out of bounds\n            current = nearest\n            steps = int(math.ceil(dist_to_target / self.step_size))\n            for _ in range(steps):\n                new_pos = steer(current.position, target_node.position)\n                if not in_bounds(new_pos) or in_obstacle(new_pos):\n                    return None\n                if edge_in_obstacle(current.position, new_pos):\n                    return None\n                new_node = Node(new_pos, parent=current, cost=current.cost + math.dist(current.position, new_pos))\n                current.add_child(new_node)\n                tree.append(new_node)\n                grid.insert(new_node)\n                current = new_node\n                if math.dist(current.position, target_node.position) <= self.step_size:\n                    if edge_in_obstacle(current.position, target_node.position) or in_obstacle(target_node.position):\n                        return None\n                    final_node = Node(target_node.position, parent=current,\n                                      cost=current.cost + math.dist(current.position, target_node.position))\n                    current.add_child(final_node)\n                    tree.append(final_node)\n                    grid.insert(final_node)\n                    return final_node\n            return None\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path[:]\n            path = list(path)\n            for _ in range(self.shortcut_iter):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if not edge_in_obstacle(p1, p2):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        # Initialize start and goal trees and grids\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n        start_grid = SpatialHashGrid(bounds, self.grid_cell_size)\n        goal_grid = SpatialHashGrid(bounds, self.grid_cell_size)\n        start_grid.insert(start_root)\n        goal_grid.insert(goal_root)\n\n        best_path = []\n        best_cost = float('inf')\n        found_solution = False\n        no_improve_count = 0\n\n        start_time = time.time()\n\n        for it in range(self.max_iter):\n            t_elapsed = time.time() - start_time\n            if t_elapsed > self.time_limit:\n                break\n\n            # Alternate trees for expansion\n            if it % 2 == 0:\n                tree_a, grid_a, tree_b, grid_b = start_tree, start_grid, goal_tree, goal_grid\n            else:\n                tree_a, grid_a, tree_b, grid_b = goal_tree, goal_grid, start_tree, start_grid\n\n            x_rand = sample_informed(best_cost) if found_solution else sample_uniform()\n            if not in_bounds(x_rand) or in_obstacle(x_rand):\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n                continue\n\n            nearest_node = grid_a.nearest(x_rand)\n            if nearest_node is None:\n                continue\n\n            new_pos = steer(nearest_node.position, x_rand)\n            if (not in_bounds(new_pos)) or in_obstacle(new_pos) or edge_in_obstacle(nearest_node.position, new_pos):\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n                continue\n\n            new_node, neighbors = choose_parent(tree_a, grid_a, new_pos)\n            if new_node is None:\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n                continue\n\n            rewire(new_node, neighbors, grid_a)\n            prune(tree_a, grid_a, best_cost)\n\n            meet_node = direct_connect(tree_b, grid_b, new_node)\n            if meet_node is not None:\n                # Merge paths: order depends on expanded tree\n                if it % 2 == 0:\n                    path_a = new_node.path_from_root()\n                    path_b = meet_node.path_from_root()\n                else:\n                    path_a = meet_node.path_from_root()\n                    path_b = new_node.path_from_root()\n                if path_a and path_b and path_a[-1] == path_b[-1]:\n                    merged_path = path_a + path_b[-2::-1]\n                else:\n                    merged_path = path_a + path_b[::-1]\n\n                total_cost = 0.0\n                for i in range(len(merged_path) - 1):\n                    total_cost += math.dist(merged_path[i], merged_path[i + 1])\n\n                if total_cost + 1e-9 < best_cost:\n                    best_cost = total_cost\n                    best_path = merged_path\n                    found_solution = True\n                    no_improve_count = 0\n                else:\n                    if found_solution:\n                        no_improve_count += 1\n                        if no_improve_count >= self.max_no_improve:\n                            break\n            else:\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n\n        if found_solution and len(best_path) >= 3:\n            # Progressive shortcutting to smooth final path efficiently\n            for _ in range(3):\n                best_path = shortcut_path(best_path)\n\n        return PlannerResult(success=found_solution, path=best_path,\n                             nodes=start_tree + goal_tree, edges=[])",
          "objective": -21.66702,
          "time_improvement": 14.0,
          "length_improvement": 16.0,
          "smoothness_improvement": 1560.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.041314005851745605,
                    "num_nodes_avg": 112.5,
                    "path_length_avg": 160.23381549627226,
                    "smoothness_avg": 0.045372199984812164,
                    "success_improvement": 0.0,
                    "time_improvement": -70.11844630646816,
                    "length_improvement": 12.173306659204261,
                    "smoothness_improvement": 610.1734570715615,
                    "objective_score": -10.680682611060082
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.06171615123748779,
                    "num_nodes_avg": 288.0,
                    "path_length_avg": 236.6531848236569,
                    "smoothness_avg": 0.10946018754057914,
                    "success_improvement": 0.0,
                    "time_improvement": 61.77744367385946,
                    "length_improvement": 20.99835522162227,
                    "smoothness_improvement": 2716.48946640541,
                    "objective_score": 44.71469356715825
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.02499120235443115,
                    "num_nodes_avg": 250.4,
                    "path_length_avg": 127.14597714662025,
                    "smoothness_avg": 0.11436332707939034,
                    "success_improvement": 0.0,
                    "time_improvement": 49.53385811607809,
                    "length_improvement": 15.555696020028664,
                    "smoothness_improvement": 1354.6930790271267,
                    "objective_score": 30.967040441976263
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m2",
          "algorithm_description": "An improved bidirectional RRT* planner with adaptive neighbor radius, bidirectional rewiring, and efficient post-processing path shortcutting to enhance planning time, reduce path length, and achieve smoother, less jagged paths. The planner retains informed ellipsoidal sampling after initial solution, carefully avoids excessive neighbor contractions, and uses early stopping. Post-processing aggressively shortcuts the found path by attempting direct edge connections between non-adjacent waypoints, significantly improving smoothness and reducing unnecessary waypoints while maintaining collision-free guarantees.",
          "planning_mechanism": "The planner grows two trees from the start and goal, alternating expansions. It samples uniformly initially, then focuses inside an ellipsoidal informed sampling region defined by the current best path cost. Each iteration extends one tree towards a sampled point by steering a fixed step size, then chooses the best parent among neighbors within an adaptive radius that gently reduces over iterations, fostering path optimality and connectivity. Both trees undergo local rewiring to improve costs. The planner attempts a direct connection from the opposite tree to the newly added node to quickly merge the trees forming a solution. Early termination occurs on stagnation or timeout. Once a path is found, a post-processing phase performs shortcutting by trying to connect distant waypoints directly, removing unnecessary waypoints and improving smoothness.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(\n        self,\n        max_iter=6000,\n        step_size=4.0,\n        max_neighbor_radius=25.0,\n        min_neighbor_radius=8.0,\n        improvement_tol=1e-6,\n        max_no_improve=80,\n        time_limit_sec=30.0,\n        post_opt_iters=200\n    ):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.max_neighbor_radius = max_neighbor_radius\n        self.min_neighbor_radius = min_neighbor_radius\n        self.improvement_tol = improvement_tol\n        self.max_no_improve = max_no_improve\n        self.time_limit_sec = time_limit_sec\n        self.post_opt_iters = post_opt_iters\n\n    def plan(self, map):\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        best_path = []\n        best_cost = float('inf')\n        c_min = math.dist(start_pos, goal_pos)\n        found_first = False\n        no_improve_count = 0\n        post_opt_count = 0\n        start_time = time.time()\n\n        def within_bounds(pos):\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d = obs\n                    px,py,pz = pos\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                        return True\n                else:\n                    x,y,w,h = obs\n                    px,py = pos\n                    if x <= px <= x+w and y <= py <= y+h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(from_p, to_p, resolution=1.0):\n            dist = math.dist(from_p, to_p)\n            if dist < 1e-12:\n                return False\n            steps = max(2, int(dist / resolution))\n            for i in range(steps + 1):\n                interp = tuple(from_p[d] + (to_p[d] - from_p[d])*i/steps for d in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def steer(from_p, to_p):\n            dist = math.dist(from_p, to_p)\n            if dist <= self.step_size:\n                return to_p\n            ratio = self.step_size / dist\n            return tuple(from_p[d] + (to_p[d] - from_p[d]) * ratio for d in range(dim))\n\n        def neighbors(tree, pos, radius):\n            radius_sq = radius*radius\n            return [n for n in tree if sum((n.position[d] - pos[d])**2 for d in range(dim)) <= radius_sq]\n\n        def adaptive_radius(n, iter_i):\n            factor = max(0.2, 1.0 - iter_i / self.max_iter)  # Avoid overly small radius\n            val = (math.log(n + 1) / (n + 1))**(1/dim)\n            radius = max(self.min_neighbor_radius, min(self.max_neighbor_radius, self.max_neighbor_radius * factor * val))\n            return radius\n\n        def choose_parent_and_add(tree, new_pos, iter_i):\n            n = len(tree)\n            radius = adaptive_radius(n, iter_i)\n            nbrs = neighbors(tree, new_pos, radius)\n\n            nearest = min(tree, key=lambda node: math.dist(node.position, new_pos))\n            min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n            best_parent = nearest\n\n            for nb in nbrs:\n                if is_edge_in_obstacle(nb.position, new_pos):\n                    continue\n                c = nb.cost + math.dist(nb.position, new_pos)\n                if c < min_cost:\n                    min_cost = c\n                    best_parent = nb\n\n            new_node = Node(new_pos, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n            return new_node, nbrs\n\n        def rewire(pivot, neighbors_list):\n            for nb in neighbors_list:\n                if nb == pivot.parent:\n                    continue\n                if is_edge_in_obstacle(pivot.position, nb.position):\n                    continue\n                new_cost = pivot.cost + math.dist(pivot.position, nb.position)\n                if new_cost + 1e-12 < nb.cost:\n                    # Remove old edge\n                    if nb.parent is not None:\n                        try:\n                            edges.remove((nb.parent, nb))\n                        except ValueError:\n                            pass\n                        if nb in nb.parent.children:\n                            nb.parent.children.remove(nb)\n                    pivot.add_child(nb)\n                    nb.cost = new_cost\n                    edges.append((pivot, nb))\n\n        def direct_connect(tree, target_node):\n            nearest = min(tree, key=lambda n: math.dist(n.position, target_node.position))\n            dist_to_target = math.dist(nearest.position, target_node.position)\n            if dist_to_target <= self.step_size:\n                if (not is_edge_in_obstacle(nearest.position, target_node.position) and\n                    not is_in_obstacle(target_node.position)):\n                    new_node = Node(target_node.position, cost=nearest.cost + dist_to_target)\n                    nearest.add_child(new_node)\n                    tree.append(new_node)\n                    nodes.append(new_node)\n                    edges.append((nearest, new_node))\n                    return new_node\n                return None\n\n            current = nearest\n            steps = int(math.ceil(dist_to_target / self.step_size))\n            for _ in range(steps):\n                new_pos = steer(current.position, target_node.position)\n                if (not within_bounds(new_pos) or is_in_obstacle(new_pos) or\n                    is_edge_in_obstacle(current.position, new_pos)):\n                    return None\n                new_node, nbrs = choose_parent_and_add(tree, new_pos, 0)\n                rewire(new_node, nbrs)\n                if math.dist(new_node.position, target_node.position) <= self.step_size:\n                    if (not is_edge_in_obstacle(new_node.position, target_node.position) and\n                        not is_in_obstacle(target_node.position)):\n                        final_node = Node(target_node.position,\n                                          cost=new_node.cost + math.dist(new_node.position, target_node.position))\n                        new_node.add_child(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n                current = new_node\n            return None\n\n        def sample_informed():\n            if not found_first or best_cost == float('inf') or c_min < 1e-12:\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            center = tuple((start_pos[d] + goal_pos[d]) / 2.0 for d in range(dim))\n            unit_dir = []\n            dist_sg = c_min\n            for d in range(dim):\n                unit_dir.append((goal_pos[d] - start_pos[d]) / dist_sg)\n            r1 = best_cost / 2.0\n            val = best_cost*best_cost - c_min*c_min\n            val = max(val, 0.0)\n            r_other = math.sqrt(val) / 2.0\n\n            if dim == 2:\n                a1 = unit_dir\n                a2 = (-a1[1], a1[0])\n                basis = (a1, a2)\n                radii = (r1, r_other)\n            else:\n                a1 = unit_dir\n                ref = (1.0, 0.0, 0.0) if abs(a1[0]) < 0.9 else (0.0,1.0,0.0)\n                b2 = _cross(a1, ref)\n                n_b2 = _norm(b2)\n                if n_b2 < 1e-12:\n                    ref = (0.0, 0.0, 1.0)\n                    b2 = _cross(a1, ref)\n                    n_b2 = _norm(b2)\n                b2 = tuple(x / n_b2 for x in b2)\n                b3 = _cross(a1, b2)\n                basis = (a1, b2, b3)\n                radii = (r1, r_other, r_other)\n\n            u = _sample_unit_ball(dim)\n            mapped = []\n            for d in range(dim):\n                val = center[d]\n                for i in range(dim):\n                    val += basis[i][d] * radii[i] * u[i]\n                val = min(max(val, 0.0), bounds[d])\n                mapped.append(val)\n            return tuple(mapped)\n\n        def _sample_unit_ball(dim):\n            while True:\n                vec = [random.gauss(0.0, 1.0) for _ in range(dim)]\n                nrm = math.sqrt(sum(v*v for v in vec))\n                if nrm < 1e-12:\n                    continue\n                vec = [v/nrm for v in vec]\n                r = random.random()**(1.0/dim)\n                return tuple(vec[i]*r for i in range(dim))\n\n        def _cross(a,b):\n            return (a[1]*b[2]-a[2]*b[1], a[2]*b[0]-a[0]*b[2], a[0]*b[1]-a[1]*b[0])\n\n        def _norm(v):\n            return math.sqrt(sum(x*x for x in v))\n\n        def path_shortcutting(path):\n            if len(path) < 3:\n                return path\n            shortcut_path = [path[0]]\n            i = 0\n            while i < len(path) - 1:\n                j = len(path) - 1\n                while j > i + 1:\n                    if not is_edge_in_obstacle(path[i], path[j]):\n                        break\n                    j -= 1\n                shortcut_path.append(path[j])\n                i = j\n            return shortcut_path\n\n        for it in range(self.max_iter):\n            if time.time() - start_time > self.time_limit_sec:\n                break\n\n            tree_a, tree_b = (start_tree, goal_tree) if it % 2 == 0 else (goal_tree, start_tree)\n            x_rand = sample_informed()\n\n            if not within_bounds(x_rand) or is_in_obstacle(x_rand):\n                if found_first:\n                    post_opt_count += 1\n                    no_improve_count += 1\n                    if post_opt_count >= self.post_opt_iters or no_improve_count >= self.max_no_improve:\n                        break\n                continue\n\n            nearest = min(tree_a, key=lambda node: math.dist(node.position, x_rand))\n            new_pos = steer(nearest.position, x_rand)\n            if not within_bounds(new_pos) or is_in_obstacle(new_pos) or is_edge_in_obstacle(nearest.position, new_pos):\n                if found_first:\n                    post_opt_count += 1\n                    no_improve_count += 1\n                    if post_opt_count >= self.post_opt_iters or no_improve_count >= self.max_no_improve:\n                        break\n                continue\n\n            new_node, nbrs = choose_parent_and_add(tree_a, new_pos, it)\n            rewire(new_node, nbrs)\n\n            meet_node = direct_connect(tree_b, new_node)\n            if meet_node is not None:\n                if it % 2 == 0:\n                    path_a = new_node.path_from_root()\n                    path_b = meet_node.path_from_root()\n                else:\n                    path_a = meet_node.path_from_root()\n                    path_b = new_node.path_from_root()\n                if path_a and path_b and path_a[-1] == path_b[-1]:\n                    merged_path = path_a + path_b[-2::-1]\n                else:\n                    merged_path = path_a + path_b[::-1]\n\n                total_cost = sum(math.dist(merged_path[i], merged_path[i+1]) for i in range(len(merged_path) - 1))\n                if total_cost + self.improvement_tol < best_cost:\n                    best_cost = total_cost\n                    best_path = merged_path\n                    found_first = True\n                    post_opt_count = 0\n                    no_improve_count = 0\n                else:\n                    if found_first:\n                        post_opt_count += 1\n                        no_improve_count += 1\n                if found_first and (post_opt_count >= self.post_opt_iters or no_improve_count >= self.max_no_improve):\n                    break\n            else:\n                if found_first:\n                    post_opt_count += 1\n                    no_improve_count += 1\n                    if post_opt_count >= self.post_opt_iters or no_improve_count >= self.max_no_improve:\n                        break\n        \n        # Post-processing path shortcutting for smoothness and path length improvement\n        if found_first and best_path:\n            for _ in range(5):  # Try multiple passes of shortcutting\n                shortened = path_shortcutting(best_path)\n                if len(shortened) == len(best_path):\n                    break\n                best_path = shortened\n\n        return PlannerResult(success=found_first, path=best_path, nodes=nodes, edges=edges)",
          "objective": -20.54313,
          "time_improvement": 6.0,
          "length_improvement": 19.0,
          "smoothness_improvement": 1486.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.035010457038879395,
                    "num_nodes_avg": 173.3,
                    "path_length_avg": 154.37889828660693,
                    "smoothness_avg": 0.04465232237074302,
                    "success_improvement": 0.0,
                    "time_improvement": -44.16235930512809,
                    "length_improvement": 15.382479558922096,
                    "smoothness_improvement": 598.90580917212,
                    "objective_score": -1.024691010324569
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.05897974967956543,
                    "num_nodes_avg": 380.6,
                    "path_length_avg": 229.58766956727146,
                    "smoothness_avg": 0.0947856766658578,
                    "success_improvement": 0.0,
                    "time_improvement": 63.47217447902824,
                    "length_improvement": 23.357027583784244,
                    "smoothness_improvement": 2338.903731975874,
                    "objective_score": 44.75038755385839
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.050714635848999025,
                    "num_nodes_avg": 293.6,
                    "path_length_avg": 122.90311253464752,
                    "smoothness_avg": 0.12740317839242893,
                    "success_improvement": 0.0,
                    "time_improvement": -2.4109193327074485,
                    "length_improvement": 18.373604671799267,
                    "smoothness_improvement": 1520.559025227274,
                    "objective_score": 17.9036821294037
               }
          ],
          "success_rate": 1.0
     }
]